
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000056c  00800200  000079de  00007a72  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000079de  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000014c6  0080076c  0080076c  00007fde  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00007fde  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000803c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000788  00000000  00000000  0000807c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a983  00000000  00000000  00008804  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002166  00000000  00000000  00013187  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000064c9  00000000  00000000  000152ed  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001930  00000000  00000000  0001b7b8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000312b  00000000  00000000  0001d0e8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b921  00000000  00000000  00020213  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008a0  00000000  00000000  0002bb34  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	20 c1       	rjmp	.+576    	; 0x242 <__ctors_end>
       2:	00 00       	nop
       4:	3f c1       	rjmp	.+638    	; 0x284 <__bad_interrupt>
       6:	00 00       	nop
       8:	3d c1       	rjmp	.+634    	; 0x284 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 9b 19 	jmp	0x3336	; 0x3336 <__vector_3>
      10:	0c 94 ac 19 	jmp	0x3358	; 0x3358 <__vector_4>
      14:	0c 94 bd 19 	jmp	0x337a	; 0x337a <__vector_5>
      18:	35 c1       	rjmp	.+618    	; 0x284 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	33 c1       	rjmp	.+614    	; 0x284 <__bad_interrupt>
      1e:	00 00       	nop
      20:	31 c1       	rjmp	.+610    	; 0x284 <__bad_interrupt>
      22:	00 00       	nop
      24:	2f c1       	rjmp	.+606    	; 0x284 <__bad_interrupt>
      26:	00 00       	nop
      28:	2d c1       	rjmp	.+602    	; 0x284 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	2b c1       	rjmp	.+598    	; 0x284 <__bad_interrupt>
      2e:	00 00       	nop
      30:	29 c1       	rjmp	.+594    	; 0x284 <__bad_interrupt>
      32:	00 00       	nop
      34:	27 c1       	rjmp	.+590    	; 0x284 <__bad_interrupt>
      36:	00 00       	nop
      38:	25 c1       	rjmp	.+586    	; 0x284 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	23 c1       	rjmp	.+582    	; 0x284 <__bad_interrupt>
      3e:	00 00       	nop
      40:	21 c1       	rjmp	.+578    	; 0x284 <__bad_interrupt>
      42:	00 00       	nop
      44:	1f c1       	rjmp	.+574    	; 0x284 <__bad_interrupt>
      46:	00 00       	nop
      48:	1d c1       	rjmp	.+570    	; 0x284 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1b c1       	rjmp	.+566    	; 0x284 <__bad_interrupt>
      4e:	00 00       	nop
      50:	19 c1       	rjmp	.+562    	; 0x284 <__bad_interrupt>
      52:	00 00       	nop
      54:	17 c1       	rjmp	.+558    	; 0x284 <__bad_interrupt>
      56:	00 00       	nop
      58:	15 c1       	rjmp	.+554    	; 0x284 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	13 c1       	rjmp	.+550    	; 0x284 <__bad_interrupt>
      5e:	00 00       	nop
      60:	11 c1       	rjmp	.+546    	; 0x284 <__bad_interrupt>
      62:	00 00       	nop
      64:	0f c1       	rjmp	.+542    	; 0x284 <__bad_interrupt>
      66:	00 00       	nop
      68:	0d c1       	rjmp	.+538    	; 0x284 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	0b c1       	rjmp	.+534    	; 0x284 <__bad_interrupt>
      6e:	00 00       	nop
      70:	09 c1       	rjmp	.+530    	; 0x284 <__bad_interrupt>
      72:	00 00       	nop
      74:	07 c1       	rjmp	.+526    	; 0x284 <__bad_interrupt>
      76:	00 00       	nop
      78:	05 c1       	rjmp	.+522    	; 0x284 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	03 c1       	rjmp	.+518    	; 0x284 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 46 1d 	jmp	0x3a8c	; 0x3a8c <__vector_32>
      84:	ff c0       	rjmp	.+510    	; 0x284 <__bad_interrupt>
      86:	00 00       	nop
      88:	fd c0       	rjmp	.+506    	; 0x284 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fb c0       	rjmp	.+502    	; 0x284 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f9 c0       	rjmp	.+498    	; 0x284 <__bad_interrupt>
      92:	00 00       	nop
      94:	f7 c0       	rjmp	.+494    	; 0x284 <__bad_interrupt>
      96:	00 00       	nop
      98:	f5 c0       	rjmp	.+490    	; 0x284 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	f3 c0       	rjmp	.+486    	; 0x284 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	f1 c0       	rjmp	.+482    	; 0x284 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	ef c0       	rjmp	.+478    	; 0x284 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	ed c0       	rjmp	.+474    	; 0x284 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	eb c0       	rjmp	.+470    	; 0x284 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	e9 c0       	rjmp	.+466    	; 0x284 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	e7 c0       	rjmp	.+462    	; 0x284 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	e5 c0       	rjmp	.+458    	; 0x284 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	e3 c0       	rjmp	.+454    	; 0x284 <__bad_interrupt>
      be:	00 00       	nop
      c0:	e1 c0       	rjmp	.+450    	; 0x284 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	df c0       	rjmp	.+446    	; 0x284 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	dd c0       	rjmp	.+442    	; 0x284 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 ac 33 	jmp	0x6758	; 0x6758 <__vector_51>
      d0:	d9 c0       	rjmp	.+434    	; 0x284 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	d7 c0       	rjmp	.+430    	; 0x284 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	d5 c0       	rjmp	.+426    	; 0x284 <__bad_interrupt>
      da:	00 00       	nop
      dc:	d3 c0       	rjmp	.+422    	; 0x284 <__bad_interrupt>
      de:	00 00       	nop
      e0:	d1 c0       	rjmp	.+418    	; 0x284 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 05       	cpc	r19, r15
     112:	a8 4c       	sbci	r26, 0xC8	; 200
     114:	cd b2       	in	r12, 0x1d	; 29
     116:	d4 4e       	sbci	r29, 0xE4	; 228
     118:	b9 38       	cpi	r27, 0x89	; 137
     11a:	36 a9       	ldd	r19, Z+54	; 0x36
     11c:	02 0c       	add	r0, r2
     11e:	50 b9       	out	0x00, r21	; 0
     120:	91 86       	std	Z+9, r9	; 0x09
     122:	88 08       	sbc	r8, r8
     124:	3c a6       	std	Y+44, r3	; 0x2c
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	2a be       	out	0x3a, r2	; 58
     12a:	00 00       	nop
     12c:	00 80       	ld	r0, Z
     12e:	3f 00       	.word	0x003f	; ????

00000130 <__trampolines_end>:
     130:	6e 61       	ori	r22, 0x1E	; 30
     132:	6e 00       	.word	0x006e	; ????

00000134 <__c.2332>:
     134:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     144:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     154:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     164:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     174:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     184:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     194:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     1a4:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     1b4:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     1c4:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     1d4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     1e4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1f4:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     204:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     214:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     224:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000232 <prvIdleTask>:
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     232:	c3 ec       	ldi	r28, 0xC3	; 195
     234:	da e1       	ldi	r29, 0x1A	; 26
     236:	88 81       	ld	r24, Y
     238:	82 30       	cpi	r24, 0x02	; 2
     23a:	f0 f3       	brcs	.-4      	; 0x238 <prvIdleTask+0x6>
     23c:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
     240:	fa cf       	rjmp	.-12     	; 0x236 <prvIdleTask+0x4>

00000242 <__ctors_end>:
     242:	11 24       	eor	r1, r1
     244:	1f be       	out	0x3f, r1	; 63
     246:	cf ef       	ldi	r28, 0xFF	; 255
     248:	d1 e2       	ldi	r29, 0x21	; 33
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	cd bf       	out	0x3d, r28	; 61
     24e:	00 e0       	ldi	r16, 0x00	; 0
     250:	0c bf       	out	0x3c, r16	; 60

00000252 <__do_copy_data>:
     252:	17 e0       	ldi	r17, 0x07	; 7
     254:	a0 e0       	ldi	r26, 0x00	; 0
     256:	b2 e0       	ldi	r27, 0x02	; 2
     258:	ee ed       	ldi	r30, 0xDE	; 222
     25a:	f9 e7       	ldi	r31, 0x79	; 121
     25c:	00 e0       	ldi	r16, 0x00	; 0
     25e:	0b bf       	out	0x3b, r16	; 59
     260:	02 c0       	rjmp	.+4      	; 0x266 <__do_copy_data+0x14>
     262:	07 90       	elpm	r0, Z+
     264:	0d 92       	st	X+, r0
     266:	ac 36       	cpi	r26, 0x6C	; 108
     268:	b1 07       	cpc	r27, r17
     26a:	d9 f7       	brne	.-10     	; 0x262 <__do_copy_data+0x10>

0000026c <__do_clear_bss>:
     26c:	2c e1       	ldi	r18, 0x1C	; 28
     26e:	ac e6       	ldi	r26, 0x6C	; 108
     270:	b7 e0       	ldi	r27, 0x07	; 7
     272:	01 c0       	rjmp	.+2      	; 0x276 <.do_clear_bss_start>

00000274 <.do_clear_bss_loop>:
     274:	1d 92       	st	X+, r1

00000276 <.do_clear_bss_start>:
     276:	a2 33       	cpi	r26, 0x32	; 50
     278:	b2 07       	cpc	r27, r18
     27a:	e1 f7       	brne	.-8      	; 0x274 <.do_clear_bss_loop>
     27c:	0e 94 ee 18 	call	0x31dc	; 0x31dc <main>
     280:	0c 94 ed 3c 	jmp	0x79da	; 0x79da <_exit>

00000284 <__bad_interrupt>:
     284:	bd ce       	rjmp	.-646    	; 0x0 <__vectors>

00000286 <arq_init>:
  return len;
}

uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}
     286:	cf 93       	push	r28
     288:	df 93       	push	r29
     28a:	6b e3       	ldi	r22, 0x3B	; 59
     28c:	74 e0       	ldi	r23, 0x04	; 4
     28e:	81 e0       	ldi	r24, 0x01	; 1
     290:	0e 94 36 1b 	call	0x366c	; 0x366c <network_set_callback>
     294:	10 92 6d 07 	sts	0x076D, r1	; 0x80076d <__data_end+0x1>
     298:	10 92 6c 07 	sts	0x076C, r1	; 0x80076c <__data_end>
     29c:	ce e6       	ldi	r28, 0x6E	; 110
     29e:	d7 e0       	ldi	r29, 0x07	; 7
     2a0:	8d e8       	ldi	r24, 0x8D	; 141
     2a2:	fe 01       	movw	r30, r28
     2a4:	11 92       	st	Z+, r1
     2a6:	8a 95       	dec	r24
     2a8:	e9 f7       	brne	.-6      	; 0x2a4 <arq_init+0x1e>
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <xQueueCreateMutex>
     2b0:	90 93 f8 07 	sts	0x07F8, r25	; 0x8007f8 <connections+0x8a>
     2b4:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <connections+0x89>
     2b8:	18 82       	st	Y, r1
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	08 95       	ret

000002c0 <arq_new_connection>:
     2c0:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     2c4:	81 11       	cpse	r24, r1
     2c6:	16 c0       	rjmp	.+44     	; 0x2f4 <arq_new_connection+0x34>
     2c8:	ee e6       	ldi	r30, 0x6E	; 110
     2ca:	f7 e0       	ldi	r31, 0x07	; 7
     2cc:	16 8e       	std	Z+30, r1	; 0x1e
     2ce:	15 8e       	std	Z+29, r1	; 0x1d
     2d0:	16 8a       	std	Z+22, r1	; 0x16
     2d2:	15 8a       	std	Z+21, r1	; 0x15
     2d4:	14 a2       	std	Z+36, r1	; 0x24
     2d6:	13 a2       	std	Z+35, r1	; 0x23
     2d8:	12 a2       	std	Z+34, r1	; 0x22
     2da:	11 a2       	std	Z+33, r1	; 0x21
     2dc:	17 8e       	std	Z+31, r1	; 0x1f
     2de:	14 8e       	std	Z+28, r1	; 0x1c
     2e0:	12 8e       	std	Z+26, r1	; 0x1a
     2e2:	11 8e       	std	Z+25, r1	; 0x19
     2e4:	13 8e       	std	Z+27, r1	; 0x1b
     2e6:	10 92 fa 07 	sts	0x07FA, r1	; 0x8007fa <connections+0x8c>
     2ea:	10 92 f9 07 	sts	0x07F9, r1	; 0x8007f9 <connections+0x8b>
     2ee:	91 e0       	ldi	r25, 0x01	; 1
     2f0:	90 83       	st	Z, r25
     2f2:	08 95       	ret
     2f4:	8f ef       	ldi	r24, 0xFF	; 255
     2f6:	08 95       	ret

000002f8 <arq_connect>:
     2f8:	cf 92       	push	r12
     2fa:	df 92       	push	r13
     2fc:	ef 92       	push	r14
     2fe:	ff 92       	push	r15
     300:	0f 93       	push	r16
     302:	1f 93       	push	r17
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	1f 92       	push	r1
     30a:	cd b7       	in	r28, 0x3d	; 61
     30c:	de b7       	in	r29, 0x3e	; 62
     30e:	69 01       	movw	r12, r18
     310:	e8 2e       	mov	r14, r24
     312:	f1 2c       	mov	r15, r1
     314:	9d e8       	ldi	r25, 0x8D	; 141
     316:	89 9f       	mul	r24, r25
     318:	80 01       	movw	r16, r0
     31a:	11 24       	eor	r1, r1
     31c:	02 59       	subi	r16, 0x92	; 146
     31e:	18 4f       	sbci	r17, 0xF8	; 248
     320:	83 e0       	ldi	r24, 0x03	; 3
     322:	f8 01       	movw	r30, r16
     324:	80 83       	st	Z, r24
     326:	50 8f       	std	Z+24, r21	; 0x18
     328:	47 8b       	std	Z+23, r20	; 0x17
     32a:	60 a3       	std	Z+32, r22	; 0x20
     32c:	82 e0       	ldi	r24, 0x02	; 2
     32e:	89 83       	std	Y+1, r24	; 0x01
     330:	0e 94 79 2f 	call	0x5ef2	; 0x5ef2 <xTaskGetCurrentTaskHandle>
     334:	f8 01       	movw	r30, r16
     336:	e5 57       	subi	r30, 0x75	; 117
     338:	ff 4f       	sbci	r31, 0xFF	; 255
     33a:	91 83       	std	Z+1, r25	; 0x01
     33c:	80 83       	st	Z, r24
     33e:	0e 94 b4 32 	call	0x6568	; 0x6568 <xTaskNotifyStateClear>
     342:	21 e0       	ldi	r18, 0x01	; 1
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	ae 01       	movw	r20, r28
     348:	4f 5f       	subi	r20, 0xFF	; 255
     34a:	5f 4f       	sbci	r21, 0xFF	; 255
     34c:	61 e0       	ldi	r22, 0x01	; 1
     34e:	f8 01       	movw	r30, r16
     350:	80 a1       	ldd	r24, Z+32	; 0x20
     352:	0e 94 41 1b 	call	0x3682	; 0x3682 <network_send>
     356:	b6 01       	movw	r22, r12
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	0e 94 32 30 	call	0x6064	; 0x6064 <ulTaskNotifyTake>
     35e:	67 2b       	or	r22, r23
     360:	68 2b       	or	r22, r24
     362:	69 2b       	or	r22, r25
     364:	61 f4       	brne	.+24     	; 0x37e <arq_connect+0x86>
     366:	8d e8       	ldi	r24, 0x8D	; 141
     368:	8e 9d       	mul	r24, r14
     36a:	f0 01       	movw	r30, r0
     36c:	8f 9d       	mul	r24, r15
     36e:	f0 0d       	add	r31, r0
     370:	11 24       	eor	r1, r1
     372:	e2 59       	subi	r30, 0x92	; 146
     374:	f8 4f       	sbci	r31, 0xF8	; 248
     376:	81 e0       	ldi	r24, 0x01	; 1
     378:	80 83       	st	Z, r24
     37a:	80 e0       	ldi	r24, 0x00	; 0
     37c:	2e c0       	rjmp	.+92     	; 0x3da <arq_connect+0xe2>
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	91 e0       	ldi	r25, 0x01	; 1
     382:	65 d6       	rcall	.+3274   	; 0x104e <pvPortMalloc>
     384:	00 97       	sbiw	r24, 0x00	; 0
     386:	31 f1       	breq	.+76     	; 0x3d4 <arq_connect+0xdc>
     388:	4d e8       	ldi	r20, 0x8D	; 141
     38a:	4e 9d       	mul	r20, r14
     38c:	90 01       	movw	r18, r0
     38e:	4f 9d       	mul	r20, r15
     390:	30 0d       	add	r19, r0
     392:	11 24       	eor	r1, r1
     394:	40 e0       	ldi	r20, 0x00	; 0
     396:	51 e0       	ldi	r21, 0x01	; 1
     398:	bc 01       	movw	r22, r24
     39a:	c9 01       	movw	r24, r18
     39c:	81 59       	subi	r24, 0x91	; 145
     39e:	98 4f       	sbci	r25, 0xF8	; 248
     3a0:	5b d3       	rcall	.+1718   	; 0xa58 <buffer_init>
     3a2:	84 e1       	ldi	r24, 0x14	; 20
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	53 d6       	rcall	.+3238   	; 0x104e <pvPortMalloc>
     3a8:	00 97       	sbiw	r24, 0x00	; 0
     3aa:	b1 f0       	breq	.+44     	; 0x3d8 <arq_connect+0xe0>
     3ac:	2d e8       	ldi	r18, 0x8D	; 141
     3ae:	2e 9d       	mul	r18, r14
     3b0:	80 01       	movw	r16, r0
     3b2:	2f 9d       	mul	r18, r15
     3b4:	10 0d       	add	r17, r0
     3b6:	11 24       	eor	r1, r1
     3b8:	44 e1       	ldi	r20, 0x14	; 20
     3ba:	50 e0       	ldi	r21, 0x00	; 0
     3bc:	bc 01       	movw	r22, r24
     3be:	c8 01       	movw	r24, r16
     3c0:	87 58       	subi	r24, 0x87	; 135
     3c2:	98 4f       	sbci	r25, 0xF8	; 248
     3c4:	49 d3       	rcall	.+1682   	; 0xa58 <buffer_init>
     3c6:	f8 01       	movw	r30, r16
     3c8:	e2 59       	subi	r30, 0x92	; 146
     3ca:	f8 4f       	sbci	r31, 0xF8	; 248
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	80 83       	st	Z, r24
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	03 c0       	rjmp	.+6      	; 0x3da <arq_connect+0xe2>
     3d4:	8f ef       	ldi	r24, 0xFF	; 255
     3d6:	01 c0       	rjmp	.+2      	; 0x3da <arq_connect+0xe2>
     3d8:	8f ef       	ldi	r24, 0xFF	; 255
     3da:	0f 90       	pop	r0
     3dc:	df 91       	pop	r29
     3de:	cf 91       	pop	r28
     3e0:	1f 91       	pop	r17
     3e2:	0f 91       	pop	r16
     3e4:	ff 90       	pop	r15
     3e6:	ef 90       	pop	r14
     3e8:	df 90       	pop	r13
     3ea:	cf 90       	pop	r12
     3ec:	08 95       	ret

000003ee <arq_close_connection>:
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
     3f2:	81 11       	cpse	r24, r1
     3f4:	34 c0       	rjmp	.+104    	; 0x45e <__FUSE_REGION_LENGTH__+0x5e>
     3f6:	20 e0       	ldi	r18, 0x00	; 0
     3f8:	4f ef       	ldi	r20, 0xFF	; 255
     3fa:	5f ef       	ldi	r21, 0xFF	; 255
     3fc:	60 e0       	ldi	r22, 0x00	; 0
     3fe:	70 e0       	ldi	r23, 0x00	; 0
     400:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     404:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     408:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
     40c:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     410:	82 30       	cpi	r24, 0x02	; 2
     412:	51 f0       	breq	.+20     	; 0x428 <__FUSE_REGION_LENGTH__+0x28>
     414:	60 e0       	ldi	r22, 0x00	; 0
     416:	70 e0       	ldi	r23, 0x00	; 0
     418:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     41c:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     420:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	1c c0       	rjmp	.+56     	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     428:	ce e6       	ldi	r28, 0x6E	; 110
     42a:	d7 e0       	ldi	r29, 0x07	; 7
     42c:	89 81       	ldd	r24, Y+1	; 0x01
     42e:	9a 81       	ldd	r25, Y+2	; 0x02
     430:	18 d7       	rcall	.+3632   	; 0x1262 <vPortFree>
     432:	8b 85       	ldd	r24, Y+11	; 0x0b
     434:	9c 85       	ldd	r25, Y+12	; 0x0c
     436:	15 d7       	rcall	.+3626   	; 0x1262 <vPortFree>
     438:	81 e0       	ldi	r24, 0x01	; 1
     43a:	88 83       	st	Y, r24
     43c:	ef 89       	ldd	r30, Y+23	; 0x17
     43e:	f8 8d       	ldd	r31, Y+24	; 0x18
     440:	60 e0       	ldi	r22, 0x00	; 0
     442:	70 e0       	ldi	r23, 0x00	; 0
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	19 95       	eicall
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     452:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     456:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
     45a:	81 e0       	ldi	r24, 0x01	; 1
     45c:	01 c0       	rjmp	.+2      	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	08 95       	ret

00000466 <arq_send>:
     466:	ef 92       	push	r14
     468:	ff 92       	push	r15
     46a:	0f 93       	push	r16
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	df 93       	push	r29
     472:	00 d0       	rcall	.+0      	; 0x474 <arq_send+0xe>
     474:	1f 92       	push	r1
     476:	cd b7       	in	r28, 0x3d	; 61
     478:	de b7       	in	r29, 0x3e	; 62
     47a:	5c 83       	std	Y+4, r21	; 0x04
     47c:	4b 83       	std	Y+3, r20	; 0x03
     47e:	81 11       	cpse	r24, r1
     480:	7b c0       	rjmp	.+246    	; 0x578 <arq_send+0x112>
     482:	7b 01       	movw	r14, r22
     484:	20 e0       	ldi	r18, 0x00	; 0
     486:	4f ef       	ldi	r20, 0xFF	; 255
     488:	5f ef       	ldi	r21, 0xFF	; 255
     48a:	60 e0       	ldi	r22, 0x00	; 0
     48c:	70 e0       	ldi	r23, 0x00	; 0
     48e:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     492:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     496:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
     49a:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     49e:	82 30       	cpi	r24, 0x02	; 2
     4a0:	51 f4       	brne	.+20     	; 0x4b6 <arq_send+0x50>
     4a2:	e1 14       	cp	r14, r1
     4a4:	f1 04       	cpc	r15, r1
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <arq_send+0x50>
     4a8:	0b 81       	ldd	r16, Y+3	; 0x03
     4aa:	1c 81       	ldd	r17, Y+4	; 0x04
     4ac:	c8 01       	movw	r24, r16
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	84 36       	cpi	r24, 0x64	; 100
     4b2:	91 05       	cpc	r25, r1
     4b4:	50 f0       	brcs	.+20     	; 0x4ca <arq_send+0x64>
     4b6:	60 e0       	ldi	r22, 0x00	; 0
     4b8:	70 e0       	ldi	r23, 0x00	; 0
     4ba:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     4be:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     4c2:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	58 c0       	rjmp	.+176    	; 0x57a <arq_send+0x114>
     4ca:	0e 5f       	subi	r16, 0xFE	; 254
     4cc:	1f 4f       	sbci	r17, 0xFF	; 255
     4ce:	20 91 77 07 	lds	r18, 0x0777	; 0x800777 <connections+0x9>
     4d2:	30 91 78 07 	lds	r19, 0x0778	; 0x800778 <connections+0xa>
     4d6:	80 e0       	ldi	r24, 0x00	; 0
     4d8:	91 e0       	ldi	r25, 0x01	; 1
     4da:	82 1b       	sub	r24, r18
     4dc:	93 0b       	sbc	r25, r19
     4de:	08 17       	cp	r16, r24
     4e0:	19 07       	cpc	r17, r25
     4e2:	08 f0       	brcs	.+2      	; 0x4e6 <arq_send+0x80>
     4e4:	3f c0       	rjmp	.+126    	; 0x564 <arq_send+0xfe>
     4e6:	20 91 81 07 	lds	r18, 0x0781	; 0x800781 <connections+0x13>
     4ea:	30 91 82 07 	lds	r19, 0x0782	; 0x800782 <connections+0x14>
     4ee:	84 e1       	ldi	r24, 0x14	; 20
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	82 1b       	sub	r24, r18
     4f4:	93 0b       	sbc	r25, r19
     4f6:	02 97       	sbiw	r24, 0x02	; 2
     4f8:	a8 f1       	brcs	.+106    	; 0x564 <arq_send+0xfe>
     4fa:	8a e2       	ldi	r24, 0x2A	; 42
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	9a 83       	std	Y+2, r25	; 0x02
     500:	89 83       	std	Y+1, r24	; 0x01
     502:	42 e0       	ldi	r20, 0x02	; 2
     504:	50 e0       	ldi	r21, 0x00	; 0
     506:	be 01       	movw	r22, r28
     508:	6d 5f       	subi	r22, 0xFD	; 253
     50a:	7f 4f       	sbci	r23, 0xFF	; 255
     50c:	8f e6       	ldi	r24, 0x6F	; 111
     50e:	97 e0       	ldi	r25, 0x07	; 7
     510:	b5 d2       	rcall	.+1386   	; 0xa7c <buffer_append>
     512:	4b 81       	ldd	r20, Y+3	; 0x03
     514:	5c 81       	ldd	r21, Y+4	; 0x04
     516:	b7 01       	movw	r22, r14
     518:	8f e6       	ldi	r24, 0x6F	; 111
     51a:	97 e0       	ldi	r25, 0x07	; 7
     51c:	af d2       	rcall	.+1374   	; 0xa7c <buffer_append>
     51e:	01 15       	cp	r16, r1
     520:	11 05       	cpc	r17, r1
     522:	b1 f0       	breq	.+44     	; 0x550 <arq_send+0xea>
     524:	90 2f       	mov	r25, r16
     526:	81 2f       	mov	r24, r17
     528:	0b 32       	cpi	r16, 0x2B	; 43
     52a:	11 05       	cpc	r17, r1
     52c:	10 f0       	brcs	.+4      	; 0x532 <arq_send+0xcc>
     52e:	9a e2       	ldi	r25, 0x2A	; 42
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	99 83       	std	Y+1, r25	; 0x01
     534:	8a 83       	std	Y+2, r24	; 0x02
     536:	42 e0       	ldi	r20, 0x02	; 2
     538:	50 e0       	ldi	r21, 0x00	; 0
     53a:	be 01       	movw	r22, r28
     53c:	6f 5f       	subi	r22, 0xFF	; 255
     53e:	7f 4f       	sbci	r23, 0xFF	; 255
     540:	89 e7       	ldi	r24, 0x79	; 121
     542:	97 e0       	ldi	r25, 0x07	; 7
     544:	9b d2       	rcall	.+1334   	; 0xa7c <buffer_append>
     546:	89 81       	ldd	r24, Y+1	; 0x01
     548:	9a 81       	ldd	r25, Y+2	; 0x02
     54a:	08 1b       	sub	r16, r24
     54c:	19 0b       	sbc	r17, r25
     54e:	51 f7       	brne	.-44     	; 0x524 <arq_send+0xbe>
     550:	60 e0       	ldi	r22, 0x00	; 0
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     558:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     55c:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	0b c0       	rjmp	.+22     	; 0x57a <arq_send+0x114>
     564:	60 e0       	ldi	r22, 0x00	; 0
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     56c:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     570:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	01 c0       	rjmp	.+2      	; 0x57a <arq_send+0x114>
     578:	80 e0       	ldi	r24, 0x00	; 0
     57a:	0f 90       	pop	r0
     57c:	0f 90       	pop	r0
     57e:	0f 90       	pop	r0
     580:	0f 90       	pop	r0
     582:	df 91       	pop	r29
     584:	cf 91       	pop	r28
     586:	1f 91       	pop	r17
     588:	0f 91       	pop	r16
     58a:	ff 90       	pop	r15
     58c:	ef 90       	pop	r14
     58e:	08 95       	ret

00000590 <arq_send_ack>:

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	1f 92       	push	r1
     596:	1f 92       	push	r1
     598:	cd b7       	in	r28, 0x3d	; 61
     59a:	de b7       	in	r29, 0x3e	; 62
  if(id >= MAX_CONNECTIONS) return 0;
     59c:	81 11       	cpse	r24, r1
     59e:	14 c0       	rjmp	.+40     	; 0x5c8 <arq_send_ack+0x38>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
     5a0:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     5a4:	82 30       	cpi	r24, 0x02	; 2
     5a6:	91 f4       	brne	.+36     	; 0x5cc <arq_send_ack+0x3c>
     5a8:	66 23       	and	r22, r22
     5aa:	94 f0       	brlt	.+36     	; 0x5d0 <arq_send_ack+0x40>
    return 0;
  }
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	89 83       	std	Y+1, r24	; 0x01
  data[1] = sequence_number;
     5b0:	6a 83       	std	Y+2, r22	; 0x02
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
     5b2:	22 e0       	ldi	r18, 0x02	; 2
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	ae 01       	movw	r20, r28
     5b8:	4f 5f       	subi	r20, 0xFF	; 255
     5ba:	5f 4f       	sbci	r21, 0xFF	; 255
     5bc:	61 e0       	ldi	r22, 0x01	; 1
     5be:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <connections+0x20>
     5c2:	0e 94 41 1b 	call	0x3682	; 0x3682 <network_send>
     5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <arq_send_ack+0x42>
uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
  if(id >= MAX_CONNECTIONS) return 0;
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	03 c0       	rjmp	.+6      	; 0x5d2 <arq_send_ack+0x42>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
    return 0;
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <arq_send_ack+0x42>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}
     5d2:	0f 90       	pop	r0
     5d4:	0f 90       	pop	r0
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	08 95       	ret

000005dc <sender>:
/  When the transmit window has available space, it removes segments from the send buffer 
/  and sends them. It also increments a retransmit timer and timeout timer. When the retransmit timer
/  expires the function resends all the segments in the transmit window. On timeout the connection is
/  closed. 
*/
void sender(arq_connection id) { 
     5dc:	af 92       	push	r10
     5de:	bf 92       	push	r11
     5e0:	cf 92       	push	r12
     5e2:	df 92       	push	r13
     5e4:	ef 92       	push	r14
     5e6:	ff 92       	push	r15
     5e8:	0f 93       	push	r16
     5ea:	1f 93       	push	r17
     5ec:	cf 93       	push	r28
     5ee:	df 93       	push	r29
     5f0:	cd b7       	in	r28, 0x3d	; 61
     5f2:	de b7       	in	r29, 0x3e	; 62
     5f4:	ae 97       	sbiw	r28, 0x2e	; 46
     5f6:	0f b6       	in	r0, 0x3f	; 63
     5f8:	f8 94       	cli
     5fa:	de bf       	out	0x3e, r29	; 62
     5fc:	0f be       	out	0x3f, r0	; 63
     5fe:	cd bf       	out	0x3d, r28	; 61
  if(id >= MAX_CONNECTIONS) return;
     600:	81 11       	cpse	r24, r1
     602:	db c0       	rjmp	.+438    	; 0x7ba <sender+0x1de>
  arq_connection_t *con = &connections[id];
  if(con->status == STATUS_NONE) return;
     604:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     608:	88 23       	and	r24, r24
     60a:	09 f4       	brne	.+2      	; 0x60e <sender+0x32>
     60c:	d6 c0       	rjmp	.+428    	; 0x7ba <sender+0x1de>
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     60e:	20 e0       	ldi	r18, 0x00	; 0
     610:	4f ef       	ldi	r20, 0xFF	; 255
     612:	5f ef       	ldi	r21, 0xFF	; 255
     614:	60 e0       	ldi	r22, 0x00	; 0
     616:	70 e0       	ldi	r23, 0x00	; 0
     618:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     61c:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     620:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
  
  if(con->status != STATUS_CONNECTED) {
     624:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     628:	82 30       	cpi	r24, 0x02	; 2
     62a:	49 f0       	breq	.+18     	; 0x63e <sender+0x62>
    xSemaphoreGive(con->mutex);
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     634:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     638:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
    return;
     63c:	be c0       	rjmp	.+380    	; 0x7ba <sender+0x1de>
  }

  if(con->timer_started) {
     63e:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <connections+0x1f>
     642:	88 23       	and	r24, r24
     644:	09 f4       	brne	.+2      	; 0x648 <sender+0x6c>
     646:	62 c0       	rjmp	.+196    	; 0x70c <sender+0x130>
    con->timeout += 10;
     648:	ee e6       	ldi	r30, 0x6E	; 110
     64a:	f7 e0       	ldi	r31, 0x07	; 7
     64c:	85 8d       	ldd	r24, Z+29	; 0x1d
     64e:	96 8d       	ldd	r25, Z+30	; 0x1e
     650:	0a 96       	adiw	r24, 0x0a	; 10
     652:	96 8f       	std	Z+30, r25	; 0x1e
     654:	85 8f       	std	Z+29, r24	; 0x1d
    con->timer += 10;
     656:	24 8d       	ldd	r18, Z+28	; 0x1c
     658:	26 5f       	subi	r18, 0xF6	; 246
     65a:	24 8f       	std	Z+28, r18	; 0x1c
    if(con->timeout > LOST_CONNECTION_TIMEOUT_MS) { 
     65c:	89 3e       	cpi	r24, 0xE9	; 233
     65e:	93 40       	sbci	r25, 0x03	; 3
     660:	58 f0       	brcs	.+22     	; 0x678 <sender+0x9c>
      xSemaphoreGive(con->mutex);
     662:	60 e0       	ldi	r22, 0x00	; 0
     664:	70 e0       	ldi	r23, 0x00	; 0
     666:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     66a:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     66e:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
      arq_close_connection(id);
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	bc de       	rcall	.-648    	; 0x3ee <arq_close_connection>
      return;
     676:	a1 c0       	rjmp	.+322    	; 0x7ba <sender+0x1de>
    }
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
     678:	29 3c       	cpi	r18, 0xC9	; 201
     67a:	08 f4       	brcc	.+2      	; 0x67e <sender+0xa2>
     67c:	47 c0       	rjmp	.+142    	; 0x70c <sender+0x130>
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
     67e:	ee e6       	ldi	r30, 0x6E	; 110
     680:	f7 e0       	ldi	r31, 0x07	; 7
     682:	07 81       	ldd	r16, Z+7	; 0x07
     684:	10 85       	ldd	r17, Z+8	; 0x08
      uint16_t len = 0;
     686:	1e a6       	std	Y+46, r1	; 0x2e
     688:	1d a6       	std	Y+45, r1	; 0x2d
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
     68a:	a1 8c       	ldd	r10, Z+25	; 0x19
     68c:	83 8d       	ldd	r24, Z+27	; 0x1b
     68e:	a8 1a       	sub	r10, r24
     690:	8a 2d       	mov	r24, r10
     692:	8f 77       	andi	r24, 0x7F	; 127
     694:	a8 2e       	mov	r10, r24
      while(i < resend_count) {
     696:	c1 f1       	breq	.+112    	; 0x708 <sender+0x12c>
     698:	c1 2c       	mov	r12, r1
     69a:	d1 2c       	mov	r13, r1
     69c:	b1 2c       	mov	r11, r1
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
        data[1] = (con->sequence_base+i) & 127; 
     69e:	7f 01       	movw	r14, r30
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
     6a0:	19 82       	std	Y+1, r1	; 0x01
        data[1] = (con->sequence_base+i) & 127; 
     6a2:	f7 01       	movw	r30, r14
     6a4:	83 8d       	ldd	r24, Z+27	; 0x1b
     6a6:	8b 0d       	add	r24, r11
     6a8:	8f 77       	andi	r24, 0x7F	; 127
     6aa:	8a 83       	std	Y+2, r24	; 0x02
        buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*i, 2);
     6ac:	41 89       	ldd	r20, Z+17	; 0x11
     6ae:	52 89       	ldd	r21, Z+18	; 0x12
     6b0:	4c 0d       	add	r20, r12
     6b2:	5d 1d       	adc	r21, r13
     6b4:	22 e0       	ldi	r18, 0x02	; 2
     6b6:	30 e0       	ldi	r19, 0x00	; 0
     6b8:	be 01       	movw	r22, r28
     6ba:	63 5d       	subi	r22, 0xD3	; 211
     6bc:	7f 4f       	sbci	r23, 0xFF	; 255
     6be:	89 e7       	ldi	r24, 0x79	; 121
     6c0:	97 e0       	ldi	r25, 0x07	; 7
     6c2:	8b d2       	rcall	.+1302   	; 0xbda <buffer_read>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
     6c4:	2d a5       	ldd	r18, Y+45	; 0x2d
     6c6:	3e a5       	ldd	r19, Y+46	; 0x2e
     6c8:	a8 01       	movw	r20, r16
     6ca:	be 01       	movw	r22, r28
     6cc:	6d 5f       	subi	r22, 0xFD	; 253
     6ce:	7f 4f       	sbci	r23, 0xFF	; 255
     6d0:	8f e6       	ldi	r24, 0x6F	; 111
     6d2:	97 e0       	ldi	r25, 0x07	; 7
     6d4:	82 d2       	rcall	.+1284   	; 0xbda <buffer_read>
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
     6d6:	2d a5       	ldd	r18, Y+45	; 0x2d
     6d8:	3e a5       	ldd	r19, Y+46	; 0x2e
     6da:	02 0f       	add	r16, r18
     6dc:	13 1f       	adc	r17, r19
     6de:	f7 01       	movw	r30, r14
     6e0:	83 81       	ldd	r24, Z+3	; 0x03
     6e2:	94 81       	ldd	r25, Z+4	; 0x04
     6e4:	01 97       	sbiw	r24, 0x01	; 1
     6e6:	08 23       	and	r16, r24
     6e8:	19 23       	and	r17, r25
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     6ea:	2e 5f       	subi	r18, 0xFE	; 254
     6ec:	3f 4f       	sbci	r19, 0xFF	; 255
     6ee:	ae 01       	movw	r20, r28
     6f0:	4f 5f       	subi	r20, 0xFF	; 255
     6f2:	5f 4f       	sbci	r21, 0xFF	; 255
     6f4:	61 e0       	ldi	r22, 0x01	; 1
     6f6:	80 a1       	ldd	r24, Z+32	; 0x20
     6f8:	0e 94 41 1b 	call	0x3682	; 0x3682 <network_send>
        ++i;
     6fc:	b3 94       	inc	r11
     6fe:	f2 e0       	ldi	r31, 0x02	; 2
     700:	cf 0e       	add	r12, r31
     702:	d1 1c       	adc	r13, r1
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
     704:	ab 10       	cpse	r10, r11
     706:	cc cf       	rjmp	.-104    	; 0x6a0 <sender+0xc4>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
        ++i;
      }
      con->timer = 0;
     708:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <connections+0x1c>
    }
  }
  if( ((con->sequence_number-con->sequence_base) & 127) < WINDOW_SIZE && con->send_buffer.head != con->send_buffer_window_end) {
     70c:	ee e6       	ldi	r30, 0x6E	; 110
     70e:	f7 e0       	ldi	r31, 0x07	; 7
     710:	81 8d       	ldd	r24, Z+25	; 0x19
     712:	48 2f       	mov	r20, r24
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	93 8d       	ldd	r25, Z+27	; 0x1b
     718:	49 1b       	sub	r20, r25
     71a:	51 09       	sbc	r21, r1
     71c:	4f 77       	andi	r20, 0x7F	; 127
     71e:	55 27       	eor	r21, r21
     720:	44 30       	cpi	r20, 0x04	; 4
     722:	51 05       	cpc	r21, r1
     724:	0c f0       	brlt	.+2      	; 0x728 <sender+0x14c>
     726:	41 c0       	rjmp	.+130    	; 0x7aa <sender+0x1ce>
     728:	65 81       	ldd	r22, Z+5	; 0x05
     72a:	76 81       	ldd	r23, Z+6	; 0x06
     72c:	25 89       	ldd	r18, Z+21	; 0x15
     72e:	36 89       	ldd	r19, Z+22	; 0x16
     730:	62 17       	cp	r22, r18
     732:	73 07       	cpc	r23, r19
     734:	d1 f1       	breq	.+116    	; 0x7aa <sender+0x1ce>
    uint8_t data[MAX_PAYLOAD_SIZE];
    uint16_t len;
    data[0] = TYPE_DATA;
     736:	19 82       	std	Y+1, r1	; 0x01
    data[1] = con->sequence_number;
     738:	8a 83       	std	Y+2, r24	; 0x02
    buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*((con->sequence_number-con->sequence_base) & 127), 2);
     73a:	8f 01       	movw	r16, r30
     73c:	44 0f       	add	r20, r20
     73e:	55 1f       	adc	r21, r21
     740:	81 89       	ldd	r24, Z+17	; 0x11
     742:	92 89       	ldd	r25, Z+18	; 0x12
     744:	48 0f       	add	r20, r24
     746:	59 1f       	adc	r21, r25
     748:	22 e0       	ldi	r18, 0x02	; 2
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	be 01       	movw	r22, r28
     74e:	63 5d       	subi	r22, 0xD3	; 211
     750:	7f 4f       	sbci	r23, 0xFF	; 255
     752:	89 e7       	ldi	r24, 0x79	; 121
     754:	97 e0       	ldi	r25, 0x07	; 7
     756:	41 d2       	rcall	.+1154   	; 0xbda <buffer_read>
    buffer_read(&con->send_buffer, &data[2], con->send_buffer_window_end, len);
     758:	2d a5       	ldd	r18, Y+45	; 0x2d
     75a:	3e a5       	ldd	r19, Y+46	; 0x2e
     75c:	f8 01       	movw	r30, r16
     75e:	45 89       	ldd	r20, Z+21	; 0x15
     760:	56 89       	ldd	r21, Z+22	; 0x16
     762:	be 01       	movw	r22, r28
     764:	6d 5f       	subi	r22, 0xFD	; 253
     766:	7f 4f       	sbci	r23, 0xFF	; 255
     768:	8f e6       	ldi	r24, 0x6F	; 111
     76a:	97 e0       	ldi	r25, 0x07	; 7
     76c:	36 d2       	rcall	.+1132   	; 0xbda <buffer_read>
    con->send_buffer_window_end = (con->send_buffer_window_end+len) & (con->send_buffer.capacity-1);
     76e:	2d a5       	ldd	r18, Y+45	; 0x2d
     770:	3e a5       	ldd	r19, Y+46	; 0x2e
     772:	f8 01       	movw	r30, r16
     774:	85 89       	ldd	r24, Z+21	; 0x15
     776:	96 89       	ldd	r25, Z+22	; 0x16
     778:	a9 01       	movw	r20, r18
     77a:	48 0f       	add	r20, r24
     77c:	59 1f       	adc	r21, r25
     77e:	83 81       	ldd	r24, Z+3	; 0x03
     780:	94 81       	ldd	r25, Z+4	; 0x04
     782:	01 97       	sbiw	r24, 0x01	; 1
     784:	84 23       	and	r24, r20
     786:	95 23       	and	r25, r21
     788:	96 8b       	std	Z+22, r25	; 0x16
     78a:	85 8b       	std	Z+21, r24	; 0x15
    con->timer_started = 1;
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	87 8f       	std	Z+31, r24	; 0x1f
    con->sequence_number = (con->sequence_number+1) & 127;
     790:	81 8d       	ldd	r24, Z+25	; 0x19
     792:	8f 5f       	subi	r24, 0xFF	; 255
     794:	8f 77       	andi	r24, 0x7F	; 127
     796:	81 8f       	std	Z+25, r24	; 0x19
    network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     798:	2e 5f       	subi	r18, 0xFE	; 254
     79a:	3f 4f       	sbci	r19, 0xFF	; 255
     79c:	ae 01       	movw	r20, r28
     79e:	4f 5f       	subi	r20, 0xFF	; 255
     7a0:	5f 4f       	sbci	r21, 0xFF	; 255
     7a2:	61 e0       	ldi	r22, 0x01	; 1
     7a4:	80 a1       	ldd	r24, Z+32	; 0x20
     7a6:	0e 94 41 1b 	call	0x3682	; 0x3682 <network_send>
  } 
  
  xSemaphoreGive(con->mutex);
     7aa:	60 e0       	ldi	r22, 0x00	; 0
     7ac:	70 e0       	ldi	r23, 0x00	; 0
     7ae:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     7b2:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     7b6:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
}
     7ba:	ae 96       	adiw	r28, 0x2e	; 46
     7bc:	0f b6       	in	r0, 0x3f	; 63
     7be:	f8 94       	cli
     7c0:	de bf       	out	0x3e, r29	; 62
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	cd bf       	out	0x3d, r28	; 61
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	df 90       	pop	r13
     7d4:	cf 90       	pop	r12
     7d6:	bf 90       	pop	r11
     7d8:	af 90       	pop	r10
     7da:	08 95       	ret

000007dc <arq_reassembly>:

void arq_reassembly(arq_connection id, uint8_t *data, uint16_t len) { 
     7dc:	0f 93       	push	r16
     7de:	1f 93       	push	r17
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	ea 01       	movw	r28, r20
  if(id >= MAX_CONNECTIONS) return;
     7e6:	81 11       	cpse	r24, r1
     7e8:	41 c0       	rjmp	.+130    	; 0x86c <arq_reassembly+0x90>
  
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
     7ea:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <connections+0x23>
     7ee:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <connections+0x24>
     7f2:	89 2b       	or	r24, r25
     7f4:	99 f4       	brne	.+38     	; 0x81c <arq_reassembly+0x40>
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
     7f6:	db 01       	movw	r26, r22
     7f8:	11 96       	adiw	r26, 0x01	; 1
     7fa:	8c 91       	ld	r24, X
     7fc:	11 97       	sbiw	r26, 0x01	; 1
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	98 2f       	mov	r25, r24
     802:	88 27       	eor	r24, r24
     804:	2c 91       	ld	r18, X
     806:	82 2b       	or	r24, r18
     808:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <connections+0x24>
     80c:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <connections+0x23>
    len-=2; // Remove the header from the length, left with the length of the payload
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
     810:	85 36       	cpi	r24, 0x65	; 101
     812:	91 05       	cpc	r25, r1
     814:	58 f5       	brcc	.+86     	; 0x86c <arq_reassembly+0x90>
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
    len-=2; // Remove the header from the length, left with the length of the payload
     816:	22 97       	sbiw	r28, 0x02	; 2
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
     818:	6e 5f       	subi	r22, 0xFE	; 254
     81a:	7f 4f       	sbci	r23, 0xFF	; 255
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
      return;
    }
  } 
  memcpy(con->message+con->num_received_bytes, data, len);
     81c:	0e e6       	ldi	r16, 0x6E	; 110
     81e:	17 e0       	ldi	r17, 0x07	; 7
     820:	f8 01       	movw	r30, r16
     822:	81 a1       	ldd	r24, Z+33	; 0x21
     824:	92 a1       	ldd	r25, Z+34	; 0x22
     826:	ae 01       	movw	r20, r28
     828:	8d 56       	subi	r24, 0x6D	; 109
     82a:	98 4f       	sbci	r25, 0xF8	; 248
     82c:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
  con->num_received_bytes += len;
     830:	d8 01       	movw	r26, r16
     832:	91 96       	adiw	r26, 0x21	; 33
     834:	6d 91       	ld	r22, X+
     836:	7c 91       	ld	r23, X
     838:	92 97       	sbiw	r26, 0x22	; 34
     83a:	6c 0f       	add	r22, r28
     83c:	7d 1f       	adc	r23, r29
     83e:	92 96       	adiw	r26, 0x22	; 34
     840:	7c 93       	st	X, r23
     842:	6e 93       	st	-X, r22
     844:	91 97       	sbiw	r26, 0x21	; 33
  
  if(con->num_received_bytes == con->receive_message_length) {
     846:	93 96       	adiw	r26, 0x23	; 35
     848:	8d 91       	ld	r24, X+
     84a:	9c 91       	ld	r25, X
     84c:	94 97       	sbiw	r26, 0x24	; 36
     84e:	68 17       	cp	r22, r24
     850:	79 07       	cpc	r23, r25
     852:	61 f4       	brne	.+24     	; 0x86c <arq_reassembly+0x90>
    con->callback_data_received(con->message, con->num_received_bytes);
     854:	57 96       	adiw	r26, 0x17	; 23
     856:	ed 91       	ld	r30, X+
     858:	fc 91       	ld	r31, X
     85a:	58 97       	sbiw	r26, 0x18	; 24
     85c:	83 e9       	ldi	r24, 0x93	; 147
     85e:	97 e0       	ldi	r25, 0x07	; 7
     860:	19 95       	eicall
    con->num_received_bytes = con->receive_message_length = 0;
     862:	f8 01       	movw	r30, r16
     864:	14 a2       	std	Z+36, r1	; 0x24
     866:	13 a2       	std	Z+35, r1	; 0x23
     868:	12 a2       	std	Z+34, r1	; 0x22
     86a:	11 a2       	std	Z+33, r1	; 0x21
  }
}
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	1f 91       	pop	r17
     872:	0f 91       	pop	r16
     874:	08 95       	ret

00000876 <receiver>:
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
     876:	9f 92       	push	r9
     878:	af 92       	push	r10
     87a:	bf 92       	push	r11
     87c:	cf 92       	push	r12
     87e:	df 92       	push	r13
     880:	ef 92       	push	r14
     882:	ff 92       	push	r15
     884:	0f 93       	push	r16
     886:	1f 93       	push	r17
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	1f 92       	push	r1
     88e:	cd b7       	in	r28, 0x3d	; 61
     890:	de b7       	in	r29, 0x3e	; 62
     892:	8b 01       	movw	r16, r22
     894:	5a 01       	movw	r10, r20
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
     896:	90 91 8e 07 	lds	r25, 0x078E	; 0x80078e <connections+0x20>
     89a:	98 13       	cpse	r25, r24
     89c:	b8 c0       	rjmp	.+368    	; 0xa0e <receiver+0x198>
     89e:	90 91 6e 07 	lds	r25, 0x076E	; 0x80076e <connections>
     8a2:	99 23       	and	r25, r25
     8a4:	09 f4       	brne	.+2      	; 0x8a8 <receiver+0x32>
     8a6:	b3 c0       	rjmp	.+358    	; 0xa0e <receiver+0x198>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     8a8:	fb 01       	movw	r30, r22
     8aa:	d0 80       	ld	r13, Z
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
      con = &connections[i];
     8ac:	0f 2e       	mov	r0, r31
     8ae:	fe e6       	ldi	r31, 0x6E	; 110
     8b0:	ef 2e       	mov	r14, r31
     8b2:	f7 e0       	ldi	r31, 0x07	; 7
     8b4:	ff 2e       	mov	r15, r31
     8b6:	f0 2d       	mov	r31, r0
     8b8:	13 c0       	rjmp	.+38     	; 0x8e0 <receiver+0x6a>
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
  if(con == NULL && type == TYPE_SYN && listening_task != NULL) {
     8ba:	e0 91 6c 07 	lds	r30, 0x076C	; 0x80076c <__data_end>
     8be:	f0 91 6d 07 	lds	r31, 0x076D	; 0x80076d <__data_end+0x1>
     8c2:	30 97       	sbiw	r30, 0x00	; 0
     8c4:	59 f0       	breq	.+22     	; 0x8dc <receiver+0x66>
    xTaskNotify(listening_task, address, eSetValueWithOverwrite);
     8c6:	48 2f       	mov	r20, r24
     8c8:	50 e0       	ldi	r21, 0x00	; 0
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	70 e0       	ldi	r23, 0x00	; 0
     8ce:	00 e0       	ldi	r16, 0x00	; 0
     8d0:	10 e0       	ldi	r17, 0x00	; 0
     8d2:	23 e0       	ldi	r18, 0x03	; 3
     8d4:	cf 01       	movw	r24, r30
     8d6:	0e 94 a8 31 	call	0x6350	; 0x6350 <xTaskGenericNotify>
    return;
     8da:	aa c0       	rjmp	.+340    	; 0xa30 <receiver+0x1ba>
     8dc:	e1 2c       	mov	r14, r1
     8de:	f1 2c       	mov	r15, r1
  }
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     8e0:	20 e0       	ldi	r18, 0x00	; 0
     8e2:	4f ef       	ldi	r20, 0xFF	; 255
     8e4:	5f ef       	ldi	r21, 0xFF	; 255
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	70 e0       	ldi	r23, 0x00	; 0
     8ea:	f7 01       	movw	r30, r14
     8ec:	e7 57       	subi	r30, 0x77	; 119
     8ee:	ff 4f       	sbci	r31, 0xFF	; 255
     8f0:	80 81       	ld	r24, Z
     8f2:	91 81       	ldd	r25, Z+1	; 0x01
     8f4:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
  
  if(con->status == STATUS_CLOSED || con->status == STATUS_NONE || len == 0 || data == NULL) {
     8f8:	f7 01       	movw	r30, r14
     8fa:	80 81       	ld	r24, Z
     8fc:	82 30       	cpi	r24, 0x02	; 2
     8fe:	30 f0       	brcs	.+12     	; 0x90c <receiver+0x96>
     900:	a1 14       	cp	r10, r1
     902:	b1 04       	cpc	r11, r1
     904:	19 f0       	breq	.+6      	; 0x90c <receiver+0x96>
     906:	01 15       	cp	r16, r1
     908:	11 05       	cpc	r17, r1
     90a:	51 f4       	brne	.+20     	; 0x920 <receiver+0xaa>
    xSemaphoreGive(con->mutex);
     90c:	f7 01       	movw	r30, r14
     90e:	e7 57       	subi	r30, 0x77	; 119
     910:	ff 4f       	sbci	r31, 0xFF	; 255
     912:	60 e0       	ldi	r22, 0x00	; 0
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	80 81       	ld	r24, Z
     918:	91 81       	ldd	r25, Z+1	; 0x01
     91a:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
    return;
     91e:	88 c0       	rjmp	.+272    	; 0xa30 <receiver+0x1ba>
  }
  
  if(con->status == STATUS_CONNECTING && type == TYPE_SYNACK) {
     920:	83 30       	cpi	r24, 0x03	; 3
     922:	21 f5       	brne	.+72     	; 0x96c <receiver+0xf6>
     924:	f3 e0       	ldi	r31, 0x03	; 3
     926:	df 12       	cpse	r13, r31
     928:	21 c0       	rjmp	.+66     	; 0x96c <receiver+0xf6>
    if(con->blocked_task != NULL) {
     92a:	f7 01       	movw	r30, r14
     92c:	e5 57       	subi	r30, 0x75	; 117
     92e:	ff 4f       	sbci	r31, 0xFF	; 255
     930:	80 81       	ld	r24, Z
     932:	91 81       	ldd	r25, Z+1	; 0x01
     934:	00 97       	sbiw	r24, 0x00	; 0
     936:	81 f0       	breq	.+32     	; 0x958 <receiver+0xe2>
      xTaskNotifyGive(con->blocked_task);
     938:	00 e0       	ldi	r16, 0x00	; 0
     93a:	10 e0       	ldi	r17, 0x00	; 0
     93c:	22 e0       	ldi	r18, 0x02	; 2
     93e:	40 e0       	ldi	r20, 0x00	; 0
     940:	50 e0       	ldi	r21, 0x00	; 0
     942:	ba 01       	movw	r22, r20
     944:	0e 94 a8 31 	call	0x6350	; 0x6350 <xTaskGenericNotify>
      con->blocked_task = NULL;
     948:	f7 01       	movw	r30, r14
     94a:	e5 57       	subi	r30, 0x75	; 117
     94c:	ff 4f       	sbci	r31, 0xFF	; 255
     94e:	11 82       	std	Z+1, r1	; 0x01
     950:	10 82       	st	Z, r1
      arq_send_ack(id, 0x00);
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	1c de       	rcall	.-968    	; 0x590 <arq_send_ack>
    }
    
    xSemaphoreGive(con->mutex);
     958:	f7 01       	movw	r30, r14
     95a:	e7 57       	subi	r30, 0x77	; 119
     95c:	ff 4f       	sbci	r31, 0xFF	; 255
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	70 e0       	ldi	r23, 0x00	; 0
     962:	80 81       	ld	r24, Z
     964:	91 81       	ldd	r25, Z+1	; 0x01
     966:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
    return;
     96a:	62 c0       	rjmp	.+196    	; 0xa30 <receiver+0x1ba>
  }
  
  uint8_t sequence = data[1];
     96c:	f8 01       	movw	r30, r16
     96e:	c1 80       	ldd	r12, Z+1	; 0x01
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
     970:	dd 20       	and	r13, r13
     972:	09 f4       	brne	.+2      	; 0x976 <receiver+0x100>
     974:	52 c0       	rjmp	.+164    	; 0xa1a <receiver+0x1a4>
     976:	f4 e0       	ldi	r31, 0x04	; 4
     978:	df 12       	cpse	r13, r31
     97a:	13 c0       	rjmp	.+38     	; 0x9a2 <receiver+0x12c>
     97c:	53 c0       	rjmp	.+166    	; 0xa24 <receiver+0x1ae>
    if(sequence == con->request_number) {
      if(type == TYPE_DATA) arq_reassembly(id, &data[2], len-2);
     97e:	a5 01       	movw	r20, r10
     980:	42 50       	subi	r20, 0x02	; 2
     982:	51 09       	sbc	r21, r1
     984:	b8 01       	movw	r22, r16
     986:	6e 5f       	subi	r22, 0xFE	; 254
     988:	7f 4f       	sbci	r23, 0xFF	; 255
     98a:	80 e0       	ldi	r24, 0x00	; 0
     98c:	27 df       	rcall	.-434    	; 0x7dc <arq_reassembly>
      con->request_number = (con->request_number+1) & 127;
     98e:	f7 01       	movw	r30, r14
     990:	82 8d       	ldd	r24, Z+26	; 0x1a
     992:	8f 5f       	subi	r24, 0xFF	; 255
     994:	8f 77       	andi	r24, 0x7F	; 127
     996:	82 8f       	std	Z+26, r24	; 0x1a
    }
    arq_send_ack(id, con->request_number);
     998:	f7 01       	movw	r30, r14
     99a:	62 8d       	ldd	r22, Z+26	; 0x1a
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	f8 dd       	rcall	.-1040   	; 0x590 <arq_send_ack>
     9a0:	2c c0       	rjmp	.+88     	; 0x9fa <receiver+0x184>
  } else if(type == TYPE_ACK) {
     9a2:	f1 e0       	ldi	r31, 0x01	; 1
     9a4:	df 12       	cpse	r13, r31
     9a6:	29 c0       	rjmp	.+82     	; 0x9fa <receiver+0x184>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
     9a8:	f7 01       	movw	r30, r14
     9aa:	83 8d       	ldd	r24, Z+27	; 0x1b
     9ac:	fc 2d       	mov	r31, r12
     9ae:	f8 1b       	sub	r31, r24
     9b0:	8f 2f       	mov	r24, r31
     9b2:	8f 77       	andi	r24, 0x7F	; 127
     9b4:	98 2e       	mov	r9, r24
    if(count != 0) {
     9b6:	09 f1       	breq	.+66     	; 0x9fa <receiver+0x184>
     9b8:	d1 2c       	mov	r13, r1
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9ba:	57 01       	movw	r10, r14
     9bc:	8b e0       	ldi	r24, 0x0B	; 11
     9be:	a8 0e       	add	r10, r24
     9c0:	b1 1c       	adc	r11, r1
        buffer_remove(&con->send_buffer, NULL, len);
     9c2:	87 01       	movw	r16, r14
     9c4:	0f 5f       	subi	r16, 0xFF	; 255
     9c6:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9c8:	42 e0       	ldi	r20, 0x02	; 2
     9ca:	50 e0       	ldi	r21, 0x00	; 0
     9cc:	be 01       	movw	r22, r28
     9ce:	6f 5f       	subi	r22, 0xFF	; 255
     9d0:	7f 4f       	sbci	r23, 0xFF	; 255
     9d2:	c5 01       	movw	r24, r10
     9d4:	50 d1       	rcall	.+672    	; 0xc76 <buffer_remove>
        buffer_remove(&con->send_buffer, NULL, len);
     9d6:	49 81       	ldd	r20, Y+1	; 0x01
     9d8:	50 e0       	ldi	r21, 0x00	; 0
     9da:	60 e0       	ldi	r22, 0x00	; 0
     9dc:	70 e0       	ldi	r23, 0x00	; 0
     9de:	c8 01       	movw	r24, r16
     9e0:	4a d1       	rcall	.+660    	; 0xc76 <buffer_remove>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
     9e2:	d3 94       	inc	r13
     9e4:	9d 10       	cpse	r9, r13
     9e6:	f0 cf       	rjmp	.-32     	; 0x9c8 <receiver+0x152>
        buffer_remove(&con->segment_lengths, &len, 2);
        buffer_remove(&con->send_buffer, NULL, len);
      }
      con->sequence_base = sequence;
     9e8:	f7 01       	movw	r30, r14
     9ea:	c3 8e       	std	Z+27, r12	; 0x1b

      con->timer = 0;
     9ec:	14 8e       	std	Z+28, r1	; 0x1c
      con->timeout = 0;
     9ee:	16 8e       	std	Z+30, r1	; 0x1e
     9f0:	15 8e       	std	Z+29, r1	; 0x1d
      if(con->sequence_base == con->sequence_number) con->timer_started = 0; // No more un-acked packets
     9f2:	81 8d       	ldd	r24, Z+25	; 0x19
     9f4:	c8 12       	cpse	r12, r24
     9f6:	01 c0       	rjmp	.+2      	; 0x9fa <receiver+0x184>
     9f8:	17 8e       	std	Z+31, r1	; 0x1f
    }
  }
  
  xSemaphoreGive(con->mutex);
     9fa:	f7 01       	movw	r30, r14
     9fc:	e7 57       	subi	r30, 0x77	; 119
     9fe:	ff 4f       	sbci	r31, 0xFF	; 255
     a00:	60 e0       	ldi	r22, 0x00	; 0
     a02:	70 e0       	ldi	r23, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	91 81       	ldd	r25, Z+1	; 0x01
     a08:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
     a0c:	11 c0       	rjmp	.+34     	; 0xa30 <receiver+0x1ba>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     a0e:	f8 01       	movw	r30, r16
     a10:	d0 80       	ld	r13, Z
  
  if(con == NULL && type != TYPE_SYN) return;
     a12:	f2 e0       	ldi	r31, 0x02	; 2
     a14:	df 12       	cpse	r13, r31
     a16:	0c c0       	rjmp	.+24     	; 0xa30 <receiver+0x1ba>
     a18:	50 cf       	rjmp	.-352    	; 0x8ba <receiver+0x44>
    return;
  }
  
  uint8_t sequence = data[1];
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
    if(sequence == con->request_number) {
     a1a:	f7 01       	movw	r30, r14
     a1c:	82 8d       	ldd	r24, Z+26	; 0x1a
     a1e:	c8 12       	cpse	r12, r24
     a20:	bb cf       	rjmp	.-138    	; 0x998 <receiver+0x122>
     a22:	ad cf       	rjmp	.-166    	; 0x97e <receiver+0x108>
     a24:	f7 01       	movw	r30, r14
     a26:	82 8d       	ldd	r24, Z+26	; 0x1a
     a28:	c8 16       	cp	r12, r24
     a2a:	09 f4       	brne	.+2      	; 0xa2e <receiver+0x1b8>
     a2c:	b0 cf       	rjmp	.-160    	; 0x98e <receiver+0x118>
     a2e:	b4 cf       	rjmp	.-152    	; 0x998 <receiver+0x122>
    }
  }
  
  xSemaphoreGive(con->mutex);
  
}
     a30:	0f 90       	pop	r0
     a32:	df 91       	pop	r29
     a34:	cf 91       	pop	r28
     a36:	1f 91       	pop	r17
     a38:	0f 91       	pop	r16
     a3a:	ff 90       	pop	r15
     a3c:	ef 90       	pop	r14
     a3e:	df 90       	pop	r13
     a40:	cf 90       	pop	r12
     a42:	bf 90       	pop	r11
     a44:	af 90       	pop	r10
     a46:	9f 90       	pop	r9
     a48:	08 95       	ret

00000a4a <vARQTask>:
void vARQTask(void *pvParamters) {
  uint8_t i;
  
  while(1) {
    for(i=0;i<MAX_CONNECTIONS;i++) {
		sender(i);
     a4a:	80 e0       	ldi	r24, 0x00	; 0
     a4c:	c7 dd       	rcall	.-1138   	; 0x5dc <sender>
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
     a4e:	8a e0       	ldi	r24, 0x0A	; 10
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	0e 94 86 29 	call	0x530c	; 0x530c <vTaskDelay>
     a56:	f9 cf       	rjmp	.-14     	; 0xa4a <vARQTask>

00000a58 <buffer_init>:
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
     a58:	fc 01       	movw	r30, r24
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a5a:	61 15       	cp	r22, r1
     a5c:	71 05       	cpc	r23, r1
     a5e:	61 f0       	breq	.+24     	; 0xa78 <buffer_init+0x20>
  b->buf = buf;
     a60:	71 83       	std	Z+1, r23	; 0x01
     a62:	60 83       	st	Z, r22
  b->capacity = size;
     a64:	53 83       	std	Z+3, r21	; 0x03
     a66:	42 83       	std	Z+2, r20	; 0x02
  b->head = b->tail = b->len = 0;
     a68:	11 86       	std	Z+9, r1	; 0x09
     a6a:	10 86       	std	Z+8, r1	; 0x08
     a6c:	17 82       	std	Z+7, r1	; 0x07
     a6e:	16 82       	std	Z+6, r1	; 0x06
     a70:	15 82       	std	Z+5, r1	; 0x05
     a72:	14 82       	std	Z+4, r1	; 0x04
  return 1;
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	08 95       	ret
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a78:	80 e0       	ldi	r24, 0x00	; 0
  b->buf = buf;
  b->capacity = size;
  b->head = b->tail = b->len = 0;
  return 1;
}
     a7a:	08 95       	ret

00000a7c <buffer_append>:

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	ec 01       	movw	r28, r24
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     a8a:	2a 81       	ldd	r18, Y+2	; 0x02
     a8c:	3b 81       	ldd	r19, Y+3	; 0x03
     a8e:	88 85       	ldd	r24, Y+8	; 0x08
     a90:	99 85       	ldd	r25, Y+9	; 0x09
     a92:	f9 01       	movw	r30, r18
     a94:	e8 1b       	sub	r30, r24
     a96:	f9 0b       	sbc	r31, r25
     a98:	e4 17       	cp	r30, r20
     a9a:	f5 07       	cpc	r31, r21
     a9c:	08 f4       	brcc	.+2      	; 0xaa0 <buffer_append+0x24>
     a9e:	49 c0       	rjmp	.+146    	; 0xb32 <buffer_append+0xb6>
     aa0:	8a 01       	movw	r16, r20
     aa2:	7b 01       	movw	r14, r22
  if(len < b->capacity - b->head) {
     aa4:	8c 81       	ldd	r24, Y+4	; 0x04
     aa6:	9d 81       	ldd	r25, Y+5	; 0x05
     aa8:	a9 01       	movw	r20, r18
     aaa:	48 1b       	sub	r20, r24
     aac:	59 0b       	sbc	r21, r25
     aae:	04 17       	cp	r16, r20
     ab0:	15 07       	cpc	r17, r21
     ab2:	a8 f4       	brcc	.+42     	; 0xade <buffer_append+0x62>
    memcpy(b->buf+b->head, data, len);
     ab4:	28 81       	ld	r18, Y
     ab6:	39 81       	ldd	r19, Y+1	; 0x01
     ab8:	a8 01       	movw	r20, r16
     aba:	82 0f       	add	r24, r18
     abc:	93 1f       	adc	r25, r19
     abe:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    b->head += len;
     ac2:	8c 81       	ldd	r24, Y+4	; 0x04
     ac4:	9d 81       	ldd	r25, Y+5	; 0x05
     ac6:	80 0f       	add	r24, r16
     ac8:	91 1f       	adc	r25, r17
     aca:	9d 83       	std	Y+5, r25	; 0x05
     acc:	8c 83       	std	Y+4, r24	; 0x04
    if(b->head == b->capacity) b->head = 0;
     ace:	2a 81       	ldd	r18, Y+2	; 0x02
     ad0:	3b 81       	ldd	r19, Y+3	; 0x03
     ad2:	82 17       	cp	r24, r18
     ad4:	93 07       	cpc	r25, r19
     ad6:	21 f5       	brne	.+72     	; 0xb20 <buffer_append+0xa4>
     ad8:	1d 82       	std	Y+5, r1	; 0x05
     ada:	1c 82       	std	Y+4, r1	; 0x04
     adc:	21 c0       	rjmp	.+66     	; 0xb20 <buffer_append+0xa4>
  } else {
    memcpy(b->buf+b->head, data, (b->capacity - b->head) );
     ade:	28 81       	ld	r18, Y
     ae0:	39 81       	ldd	r19, Y+1	; 0x01
     ae2:	82 0f       	add	r24, r18
     ae4:	93 1f       	adc	r25, r19
     ae6:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
     aea:	8c 81       	ldd	r24, Y+4	; 0x04
     aec:	9d 81       	ldd	r25, Y+5	; 0x05
     aee:	6a 81       	ldd	r22, Y+2	; 0x02
     af0:	7b 81       	ldd	r23, Y+3	; 0x03
     af2:	ac 01       	movw	r20, r24
     af4:	46 1b       	sub	r20, r22
     af6:	57 0b       	sbc	r21, r23
     af8:	40 0f       	add	r20, r16
     afa:	51 1f       	adc	r21, r17
     afc:	68 1b       	sub	r22, r24
     afe:	79 0b       	sbc	r23, r25
     b00:	6e 0d       	add	r22, r14
     b02:	7f 1d       	adc	r23, r15
     b04:	88 81       	ld	r24, Y
     b06:	99 81       	ldd	r25, Y+1	; 0x01
     b08:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    b->head = len-(b->capacity - b->head);
     b0c:	8c 81       	ldd	r24, Y+4	; 0x04
     b0e:	9d 81       	ldd	r25, Y+5	; 0x05
     b10:	2a 81       	ldd	r18, Y+2	; 0x02
     b12:	3b 81       	ldd	r19, Y+3	; 0x03
     b14:	82 1b       	sub	r24, r18
     b16:	93 0b       	sbc	r25, r19
     b18:	80 0f       	add	r24, r16
     b1a:	91 1f       	adc	r25, r17
     b1c:	9d 83       	std	Y+5, r25	; 0x05
     b1e:	8c 83       	std	Y+4, r24	; 0x04
  }
  b->len += len;
     b20:	48 85       	ldd	r20, Y+8	; 0x08
     b22:	59 85       	ldd	r21, Y+9	; 0x09
     b24:	04 0f       	add	r16, r20
     b26:	15 1f       	adc	r17, r21
     b28:	19 87       	std	Y+9, r17	; 0x09
     b2a:	08 87       	std	Y+8, r16	; 0x08
  return 1;
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	02 c0       	rjmp	.+4      	; 0xb36 <buffer_append+0xba>
  b->head = b->tail = b->len = 0;
  return 1;
}

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	90 e0       	ldi	r25, 0x00	; 0
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
    b->head = len-(b->capacity - b->head);
  }
  b->len += len;
  return 1;
}
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	08 95       	ret

00000b44 <buffer_remove_token>:

//This reads bytes from the buffer until token is found, or nbytes is reached
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
     b44:	0f 93       	push	r16
     b46:	1f 93       	push	r17
     b48:	cf 93       	push	r28
     b4a:	df 93       	push	r29
     b4c:	fc 01       	movw	r30, r24
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     b4e:	21 15       	cp	r18, r1
     b50:	31 05       	cpc	r19, r1
     b52:	c9 f1       	breq	.+114    	; 0xbc6 <buffer_remove_token+0x82>
    if( b->tail != b->head ){ //see if any data is available
     b54:	a6 81       	ldd	r26, Z+6	; 0x06
     b56:	b7 81       	ldd	r27, Z+7	; 0x07
     b58:	84 81       	ldd	r24, Z+4	; 0x04
     b5a:	95 81       	ldd	r25, Z+5	; 0x05
     b5c:	a8 17       	cp	r26, r24
     b5e:	b9 07       	cpc	r27, r25
     b60:	a9 f1       	breq	.+106    	; 0xbcc <buffer_remove_token+0x88>
     b62:	c6 2f       	mov	r28, r22
     b64:	d7 2f       	mov	r29, r23
     b66:	80 e0       	ldi	r24, 0x00	; 0
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	07 c0       	rjmp	.+14     	; 0xb7a <buffer_remove_token+0x36>
     b6c:	a6 81       	ldd	r26, Z+6	; 0x06
     b6e:	b7 81       	ldd	r27, Z+7	; 0x07
     b70:	64 81       	ldd	r22, Z+4	; 0x04
     b72:	75 81       	ldd	r23, Z+5	; 0x05
     b74:	a6 17       	cp	r26, r22
     b76:	b7 07       	cpc	r27, r23
     b78:	59 f1       	breq	.+86     	; 0xbd0 <buffer_remove_token+0x8c>
      *p++ = b->buf[b->tail];  //grab a byte from the buffer
     b7a:	60 81       	ld	r22, Z
     b7c:	71 81       	ldd	r23, Z+1	; 0x01
     b7e:	a6 0f       	add	r26, r22
     b80:	b7 1f       	adc	r27, r23
     b82:	5c 91       	ld	r21, X
     b84:	8e 01       	movw	r16, r28
     b86:	58 83       	st	Y, r21
      b->tail++;  //increment the tail
     b88:	66 81       	ldd	r22, Z+6	; 0x06
     b8a:	77 81       	ldd	r23, Z+7	; 0x07
     b8c:	6f 5f       	subi	r22, 0xFF	; 255
     b8e:	7f 4f       	sbci	r23, 0xFF	; 255
     b90:	77 83       	std	Z+7, r23	; 0x07
     b92:	66 83       	std	Z+6, r22	; 0x06
      b->len--;
     b94:	a0 85       	ldd	r26, Z+8	; 0x08
     b96:	b1 85       	ldd	r27, Z+9	; 0x09
     b98:	11 97       	sbiw	r26, 0x01	; 1
     b9a:	b1 87       	std	Z+9, r27	; 0x09
     b9c:	a0 87       	std	Z+8, r26	; 0x08
      if( b->tail == b->capacity ){  //check for wrap-around
     b9e:	a2 81       	ldd	r26, Z+2	; 0x02
     ba0:	b3 81       	ldd	r27, Z+3	; 0x03
     ba2:	6a 17       	cp	r22, r26
     ba4:	7b 07       	cpc	r23, r27
     ba6:	11 f4       	brne	.+4      	; 0xbac <buffer_remove_token+0x68>
        b->tail = 0;
     ba8:	17 82       	std	Z+7, r1	; 0x07
     baa:	16 82       	std	Z+6, r1	; 0x06
     bac:	21 96       	adiw	r28, 0x01	; 1
      }
      if(*(p-1) == token) return i+1;
     bae:	d8 01       	movw	r26, r16
     bb0:	5c 91       	ld	r21, X
     bb2:	54 13       	cpse	r21, r20
     bb4:	02 c0       	rjmp	.+4      	; 0xbba <buffer_remove_token+0x76>
     bb6:	01 96       	adiw	r24, 0x01	; 1
     bb8:	0b c0       	rjmp	.+22     	; 0xbd0 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     bba:	01 96       	adiw	r24, 0x01	; 1
     bbc:	28 17       	cp	r18, r24
     bbe:	39 07       	cpc	r19, r25
     bc0:	a9 f6       	brne	.-86     	; 0xb6c <buffer_remove_token+0x28>
      if(*(p-1) == token) return i+1;
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
     bc2:	c9 01       	movw	r24, r18
     bc4:	05 c0       	rjmp	.+10     	; 0xbd0 <buffer_remove_token+0x8c>
     bc6:	80 e0       	ldi	r24, 0x00	; 0
     bc8:	90 e0       	ldi	r25, 0x00	; 0
     bca:	02 c0       	rjmp	.+4      	; 0xbd0 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     bcc:	80 e0       	ldi	r24, 0x00	; 0
     bce:	90 e0       	ldi	r25, 0x00	; 0
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
}
     bd0:	df 91       	pop	r29
     bd2:	cf 91       	pop	r28
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	08 95       	ret

00000bda <buffer_read>:
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
     bda:	cf 92       	push	r12
     bdc:	df 92       	push	r13
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	7c 01       	movw	r14, r24
     bec:	6b 01       	movw	r12, r22
     bee:	ea 01       	movw	r28, r20
     bf0:	89 01       	movw	r16, r18
  if(data == NULL) return 0;
     bf2:	67 2b       	or	r22, r23
     bf4:	a9 f1       	breq	.+106    	; 0xc60 <buffer_read+0x86>
  if(idx >= b->capacity) idx -= b->capacity;
     bf6:	fc 01       	movw	r30, r24
     bf8:	42 81       	ldd	r20, Z+2	; 0x02
     bfa:	53 81       	ldd	r21, Z+3	; 0x03
     bfc:	c4 17       	cp	r28, r20
     bfe:	d5 07       	cpc	r29, r21
     c00:	10 f0       	brcs	.+4      	; 0xc06 <buffer_read+0x2c>
     c02:	c4 1b       	sub	r28, r20
     c04:	d5 0b       	sbc	r29, r21
  if(b->capacity - idx >= len) {
     c06:	4c 1b       	sub	r20, r28
     c08:	5d 0b       	sbc	r21, r29
     c0a:	40 17       	cp	r20, r16
     c0c:	51 07       	cpc	r21, r17
     c0e:	60 f0       	brcs	.+24     	; 0xc28 <buffer_read+0x4e>
    memcpy(data, b->buf+idx, len);
     c10:	f7 01       	movw	r30, r14
     c12:	60 81       	ld	r22, Z
     c14:	71 81       	ldd	r23, Z+1	; 0x01
     c16:	6c 0f       	add	r22, r28
     c18:	7d 1f       	adc	r23, r29
     c1a:	a8 01       	movw	r20, r16
     c1c:	c6 01       	movw	r24, r12
     c1e:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
     c22:	80 2f       	mov	r24, r16
     c24:	91 2f       	mov	r25, r17
     c26:	1e c0       	rjmp	.+60     	; 0xc64 <buffer_read+0x8a>
  if(data == NULL) return 0;
  if(idx >= b->capacity) idx -= b->capacity;
  if(b->capacity - idx >= len) {
    memcpy(data, b->buf+idx, len);
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
     c28:	f7 01       	movw	r30, r14
     c2a:	60 81       	ld	r22, Z
     c2c:	71 81       	ldd	r23, Z+1	; 0x01
     c2e:	6c 0f       	add	r22, r28
     c30:	7d 1f       	adc	r23, r29
     c32:	c6 01       	movw	r24, r12
     c34:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
     c38:	f7 01       	movw	r30, r14
     c3a:	22 81       	ldd	r18, Z+2	; 0x02
     c3c:	33 81       	ldd	r19, Z+3	; 0x03
     c3e:	c9 01       	movw	r24, r18
     c40:	8c 1b       	sub	r24, r28
     c42:	9d 0b       	sbc	r25, r29
     c44:	a8 01       	movw	r20, r16
     c46:	42 1b       	sub	r20, r18
     c48:	53 0b       	sbc	r21, r19
     c4a:	4c 0f       	add	r20, r28
     c4c:	5d 1f       	adc	r21, r29
     c4e:	60 81       	ld	r22, Z
     c50:	71 81       	ldd	r23, Z+1	; 0x01
     c52:	8c 0d       	add	r24, r12
     c54:	9d 1d       	adc	r25, r13
     c56:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
  }
  return len;
     c5a:	80 2f       	mov	r24, r16
     c5c:	91 2f       	mov	r25, r17
     c5e:	02 c0       	rjmp	.+4      	; 0xc64 <buffer_read+0x8a>
  }
  return nbytes;
}
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
  if(data == NULL) return 0;
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	90 e0       	ldi	r25, 0x00	; 0
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
}
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	08 95       	ret

00000c76 <buffer_remove>:

//Remove 'len' bytes from the buffer and add them to 'data'
uint16_t buffer_remove(buffer_t *b, uint8_t *data, uint16_t len) {
     c76:	ef 92       	push	r14
     c78:	ff 92       	push	r15
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	ec 01       	movw	r28, r24
     c84:	7b 01       	movw	r14, r22
  if(len > b->len) len = b->len;
     c86:	08 85       	ldd	r16, Y+8	; 0x08
     c88:	19 85       	ldd	r17, Y+9	; 0x09
     c8a:	40 17       	cp	r20, r16
     c8c:	51 07       	cpc	r21, r17
     c8e:	08 f4       	brcc	.+2      	; 0xc92 <buffer_remove+0x1c>
     c90:	8a 01       	movw	r16, r20
  if(b->capacity - b->tail >= len) {
     c92:	8e 81       	ldd	r24, Y+6	; 0x06
     c94:	9f 81       	ldd	r25, Y+7	; 0x07
     c96:	4a 81       	ldd	r20, Y+2	; 0x02
     c98:	5b 81       	ldd	r21, Y+3	; 0x03
     c9a:	48 1b       	sub	r20, r24
     c9c:	59 0b       	sbc	r21, r25
     c9e:	40 17       	cp	r20, r16
     ca0:	51 07       	cpc	r21, r17
     ca2:	c8 f0       	brcs	.+50     	; 0xcd6 <buffer_remove+0x60>
    if(data != NULL) memcpy(data, b->buf+b->tail, len);
     ca4:	e1 14       	cp	r14, r1
     ca6:	f1 04       	cpc	r15, r1
     ca8:	41 f0       	breq	.+16     	; 0xcba <buffer_remove+0x44>
     caa:	68 81       	ld	r22, Y
     cac:	79 81       	ldd	r23, Y+1	; 0x01
     cae:	68 0f       	add	r22, r24
     cb0:	79 1f       	adc	r23, r25
     cb2:	a8 01       	movw	r20, r16
     cb4:	c7 01       	movw	r24, r14
     cb6:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    b->tail = b->tail + len;
     cba:	8e 81       	ldd	r24, Y+6	; 0x06
     cbc:	9f 81       	ldd	r25, Y+7	; 0x07
     cbe:	80 0f       	add	r24, r16
     cc0:	91 1f       	adc	r25, r17
     cc2:	9f 83       	std	Y+7, r25	; 0x07
     cc4:	8e 83       	std	Y+6, r24	; 0x06
    if(b->tail == b->capacity) b->tail = 0;
     cc6:	2a 81       	ldd	r18, Y+2	; 0x02
     cc8:	3b 81       	ldd	r19, Y+3	; 0x03
     cca:	82 17       	cp	r24, r18
     ccc:	93 07       	cpc	r25, r19
     cce:	41 f5       	brne	.+80     	; 0xd20 <buffer_remove+0xaa>
     cd0:	1f 82       	std	Y+7, r1	; 0x07
     cd2:	1e 82       	std	Y+6, r1	; 0x06
     cd4:	25 c0       	rjmp	.+74     	; 0xd20 <buffer_remove+0xaa>
  } else {
    if(data != NULL) {
     cd6:	e1 14       	cp	r14, r1
     cd8:	f1 04       	cpc	r15, r1
     cda:	c1 f0       	breq	.+48     	; 0xd0c <buffer_remove+0x96>
      memcpy(data, b->buf+b->tail, b->capacity - b->tail);
     cdc:	68 81       	ld	r22, Y
     cde:	79 81       	ldd	r23, Y+1	; 0x01
     ce0:	68 0f       	add	r22, r24
     ce2:	79 1f       	adc	r23, r25
     ce4:	c7 01       	movw	r24, r14
     ce6:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
      memcpy(data + (b->capacity - b->tail), b->buf, len - (b->capacity - b->tail) );
     cea:	4e 81       	ldd	r20, Y+6	; 0x06
     cec:	5f 81       	ldd	r21, Y+7	; 0x07
     cee:	2a 81       	ldd	r18, Y+2	; 0x02
     cf0:	3b 81       	ldd	r19, Y+3	; 0x03
     cf2:	c9 01       	movw	r24, r18
     cf4:	84 1b       	sub	r24, r20
     cf6:	95 0b       	sbc	r25, r21
     cf8:	42 1b       	sub	r20, r18
     cfa:	53 0b       	sbc	r21, r19
     cfc:	40 0f       	add	r20, r16
     cfe:	51 1f       	adc	r21, r17
     d00:	68 81       	ld	r22, Y
     d02:	79 81       	ldd	r23, Y+1	; 0x01
     d04:	8e 0d       	add	r24, r14
     d06:	9f 1d       	adc	r25, r15
     d08:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    }
    b->tail = len - (b->capacity - b->tail);
     d0c:	8e 81       	ldd	r24, Y+6	; 0x06
     d0e:	9f 81       	ldd	r25, Y+7	; 0x07
     d10:	2a 81       	ldd	r18, Y+2	; 0x02
     d12:	3b 81       	ldd	r19, Y+3	; 0x03
     d14:	82 1b       	sub	r24, r18
     d16:	93 0b       	sbc	r25, r19
     d18:	80 0f       	add	r24, r16
     d1a:	91 1f       	adc	r25, r17
     d1c:	9f 83       	std	Y+7, r25	; 0x07
     d1e:	8e 83       	std	Y+6, r24	; 0x06
  }
  b->len -= len;
     d20:	88 85       	ldd	r24, Y+8	; 0x08
     d22:	99 85       	ldd	r25, Y+9	; 0x09
     d24:	80 1b       	sub	r24, r16
     d26:	91 0b       	sbc	r25, r17
     d28:	99 87       	std	Y+9, r25	; 0x09
     d2a:	88 87       	std	Y+8, r24	; 0x08
  return len;
     d2c:	c8 01       	movw	r24, r16
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	08 95       	ret

00000d3c <cobs_encode>:
/*****************************************************************************
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     d3c:	ef 92       	push	r14
     d3e:	ff 92       	push	r15
     d40:	0f 93       	push	r16
     d42:	1f 93       	push	r17
     d44:	cf 93       	push	r28
     d46:	df 93       	push	r29
     d48:	7c 01       	movw	r14, r24
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     d4a:	68 0f       	add	r22, r24
     d4c:	79 1f       	adc	r23, r25
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
     d4e:	fc 01       	movw	r30, r24
     d50:	31 96       	adiw	r30, 0x01	; 1
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     d52:	00 97       	sbiw	r24, 0x00	; 0
     d54:	19 f0       	breq	.+6      	; 0xd5c <cobs_encode+0x20>
     d56:	41 15       	cp	r20, r1
     d58:	51 05       	cpc	r21, r1
     d5a:	21 f4       	brne	.+8      	; 0xd64 <cobs_encode+0x28>
    {
        result.status = COBS_ENCODE_NULL_POINTER;
        return result;
     d5c:	60 e0       	ldi	r22, 0x00	; 0
     d5e:	70 e0       	ldi	r23, 0x00	; 0
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	4b c0       	rjmp	.+150    	; 0xdfa <cobs_encode+0xbe>
    }

    if (src_len != 0)
     d64:	21 15       	cp	r18, r1
     d66:	31 05       	cpc	r19, r1
     d68:	59 f1       	breq	.+86     	; 0xdc0 <cobs_encode+0x84>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d6a:	e6 17       	cp	r30, r22
     d6c:	f7 07       	cpc	r31, r23
     d6e:	60 f5       	brcc	.+88     	; 0xdc8 <cobs_encode+0x8c>
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     d70:	8a 01       	movw	r16, r20
     d72:	02 0f       	add	r16, r18
     d74:	13 1f       	adc	r17, r19
     d76:	da 01       	movw	r26, r20
     d78:	ec 01       	movw	r28, r24
     d7a:	91 e0       	ldi	r25, 0x01	; 1
                }
                if (search_len == 0xFF)
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     d7c:	2f ef       	ldi	r18, 0xFF	; 255
     d7e:	04 c0       	rjmp	.+8      	; 0xd88 <cobs_encode+0x4c>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     d80:	fa 01       	movw	r30, r20
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d82:	e6 17       	cp	r30, r22
     d84:	f7 07       	cpc	r31, r23
     d86:	20 f5       	brcc	.+72     	; 0xdd0 <cobs_encode+0x94>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
                break;
            }

            src_byte = *src_ptr++;
     d88:	3d 91       	ld	r19, X+
            if (src_byte == 0)
     d8a:	31 11       	cpse	r19, r1
     d8c:	0a c0       	rjmp	.+20     	; 0xda2 <cobs_encode+0x66>
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
     d8e:	98 83       	st	Y, r25
                dst_code_write_ptr = dst_write_ptr++;
     d90:	cf 01       	movw	r24, r30
     d92:	01 96       	adiw	r24, 0x01	; 1
                search_len = 1;
                if (src_ptr >= src_end_ptr)
     d94:	a0 17       	cp	r26, r16
     d96:	b1 07       	cpc	r27, r17
     d98:	e8 f4       	brcc	.+58     	; 0xdd4 <cobs_encode+0x98>
     d9a:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     d9c:	fc 01       	movw	r30, r24
                search_len = 1;
     d9e:	91 e0       	ldi	r25, 0x01	; 1
     da0:	f0 cf       	rjmp	.-32     	; 0xd82 <cobs_encode+0x46>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     da2:	af 01       	movw	r20, r30
     da4:	4f 5f       	subi	r20, 0xFF	; 255
     da6:	5f 4f       	sbci	r21, 0xFF	; 255
     da8:	30 83       	st	Z, r19
                search_len++;
     daa:	9f 5f       	subi	r25, 0xFF	; 255
                if (src_ptr >= src_end_ptr)
     dac:	a0 17       	cp	r26, r16
     dae:	b1 07       	cpc	r27, r17
     db0:	b0 f4       	brcc	.+44     	; 0xdde <cobs_encode+0xa2>
                {
                    break;
                }
                if (search_len == 0xFF)
     db2:	9f 3f       	cpi	r25, 0xFF	; 255
     db4:	29 f7       	brne	.-54     	; 0xd80 <cobs_encode+0x44>
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     db6:	28 83       	st	Y, r18
                    dst_code_write_ptr = dst_write_ptr++;
     db8:	32 96       	adiw	r30, 0x02	; 2
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     dba:	ea 01       	movw	r28, r20
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
                    dst_code_write_ptr = dst_write_ptr++;
                    search_len = 1;
     dbc:	91 e0       	ldi	r25, 0x01	; 1
     dbe:	e1 cf       	rjmp	.-62     	; 0xd82 <cobs_encode+0x46>
cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
     dc0:	ec 01       	movw	r28, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     dc2:	80 e0       	ldi	r24, 0x00	; 0
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;
     dc4:	91 e0       	ldi	r25, 0x01	; 1
     dc6:	0d c0       	rjmp	.+26     	; 0xde2 <cobs_encode+0xa6>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     dc8:	ec 01       	movw	r28, r24
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dca:	82 e0       	ldi	r24, 0x02	; 2
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     dcc:	91 e0       	ldi	r25, 0x01	; 1
     dce:	09 c0       	rjmp	.+18     	; 0xde2 <cobs_encode+0xa6>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dd0:	82 e0       	ldi	r24, 0x02	; 2
     dd2:	07 c0       	rjmp	.+14     	; 0xde2 <cobs_encode+0xa6>
     dd4:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     dd6:	fc 01       	movw	r30, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     dd8:	80 e0       	ldi	r24, 0x00	; 0
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
                search_len = 1;
     dda:	91 e0       	ldi	r25, 0x01	; 1
     ddc:	02 c0       	rjmp	.+4      	; 0xde2 <cobs_encode+0xa6>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     dde:	fa 01       	movw	r30, r20
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     de0:	80 e0       	ldi	r24, 0x00	; 0

    /* We've reached the end of the source data (or possibly run out of output buffer)
     * Finalise the remaining output. In particular, write the code (length) byte.
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
     de2:	c6 17       	cp	r28, r22
     de4:	d7 07       	cpc	r29, r23
     de6:	18 f4       	brcc	.+6      	; 0xdee <cobs_encode+0xb2>
        dst_write_ptr = dst_buf_end_ptr;
    }
    else
    {
        /* Write the last code (length) byte. */
        *dst_code_write_ptr = search_len;
     de8:	98 83       	st	Y, r25
     dea:	bf 01       	movw	r22, r30
     dec:	01 c0       	rjmp	.+2      	; 0xdf0 <cobs_encode+0xb4>
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
    {
        /* We've run out of output buffer to write the code byte. */
        result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dee:	82 e0       	ldi	r24, 0x02	; 2
    }

    /* Calculate the output length, from the value of dst_code_write_ptr */
    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     df0:	9b 01       	movw	r18, r22
     df2:	2e 19       	sub	r18, r14
     df4:	3f 09       	sbc	r19, r15
     df6:	62 2f       	mov	r22, r18
     df8:	73 2f       	mov	r23, r19
}
     dfa:	df 91       	pop	r29
     dfc:	cf 91       	pop	r28
     dfe:	1f 91       	pop	r17
     e00:	0f 91       	pop	r16
     e02:	ff 90       	pop	r15
     e04:	ef 90       	pop	r14
     e06:	08 95       	ret

00000e08 <cobs_decode>:


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     e08:	af 92       	push	r10
     e0a:	bf 92       	push	r11
     e0c:	cf 92       	push	r12
     e0e:	df 92       	push	r13
     e10:	ef 92       	push	r14
     e12:	ff 92       	push	r15
     e14:	0f 93       	push	r16
     e16:	1f 93       	push	r17
     e18:	cf 93       	push	r28
     e1a:	df 93       	push	r29
     e1c:	7c 01       	movw	r14, r24
     e1e:	da 01       	movw	r26, r20
    uint8_t             i;
    uint8_t             len_code;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     e20:	00 97       	sbiw	r24, 0x00	; 0
     e22:	11 f0       	breq	.+4      	; 0xe28 <cobs_decode+0x20>
     e24:	10 97       	sbiw	r26, 0x00	; 0
     e26:	21 f4       	brne	.+8      	; 0xe30 <cobs_decode+0x28>
    {
        result.status = COBS_DECODE_NULL_POINTER;
        return result;
     e28:	60 e0       	ldi	r22, 0x00	; 0
     e2a:	70 e0       	ldi	r23, 0x00	; 0
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	5f c0       	rjmp	.+190    	; 0xeee <cobs_decode+0xe6>
    }

    if (src_len != 0)
     e30:	21 15       	cp	r18, r1
     e32:	31 05       	cpc	r19, r1
     e34:	09 f4       	brne	.+2      	; 0xe38 <cobs_decode+0x30>
     e36:	4b c0       	rjmp	.+150    	; 0xece <cobs_decode+0xc6>


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     e38:	6a 01       	movw	r12, r20
     e3a:	c2 0e       	add	r12, r18
     e3c:	d3 1e       	adc	r13, r19
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     e3e:	5c 01       	movw	r10, r24
     e40:	a6 0e       	add	r10, r22
     e42:	b7 1e       	adc	r11, r23
     e44:	8c 01       	movw	r16, r24
     e46:	50 e0       	ldi	r21, 0x00	; 0
     e48:	01 c0       	rjmp	.+2      	; 0xe4c <cobs_decode+0x44>
                src_byte = *src_ptr++;
                if (src_byte == 0)
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
     e4a:	8f 01       	movw	r16, r30

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     e4c:	ed 01       	movw	r28, r26
     e4e:	21 96       	adiw	r28, 0x01	; 1
     e50:	7c 91       	ld	r23, X
            if (len_code == 0)
     e52:	71 11       	cpse	r23, r1
     e54:	03 c0       	rjmp	.+6      	; 0xe5c <cobs_decode+0x54>
            {
                result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e56:	54 60       	ori	r21, 0x04	; 4
                break;
     e58:	f8 01       	movw	r30, r16
     e5a:	3d c0       	rjmp	.+122    	; 0xed6 <cobs_decode+0xce>
            }
            len_code--;
     e5c:	71 50       	subi	r23, 0x01	; 1

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
     e5e:	c6 01       	movw	r24, r12
     e60:	8c 1b       	sub	r24, r28
     e62:	9d 0b       	sbc	r25, r29
            if (len_code > remaining_bytes)
     e64:	27 2f       	mov	r18, r23
     e66:	30 e0       	ldi	r19, 0x00	; 0
     e68:	82 17       	cp	r24, r18
     e6a:	93 07       	cpc	r25, r19
     e6c:	10 f4       	brcc	.+4      	; 0xe72 <cobs_decode+0x6a>
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
                len_code = remaining_bytes;
     e6e:	78 2f       	mov	r23, r24

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
     e70:	58 60       	ori	r21, 0x08	; 8
                len_code = remaining_bytes;
            }

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
     e72:	c5 01       	movw	r24, r10
     e74:	80 1b       	sub	r24, r16
     e76:	91 0b       	sbc	r25, r17
            if (len_code > remaining_bytes)
     e78:	27 2f       	mov	r18, r23
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	82 17       	cp	r24, r18
     e7e:	93 07       	cpc	r25, r19
     e80:	10 f4       	brcc	.+4      	; 0xe86 <cobs_decode+0x7e>
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
     e82:	78 2f       	mov	r23, r24

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     e84:	52 60       	ori	r21, 0x02	; 2
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e86:	77 23       	and	r23, r23
     e88:	61 f1       	breq	.+88     	; 0xee2 <cobs_decode+0xda>
     e8a:	de 01       	movw	r26, r28
     e8c:	f8 01       	movw	r30, r16
     e8e:	97 2f       	mov	r25, r23
            {
                src_byte = *src_ptr++;
     e90:	3d 91       	ld	r19, X+
                if (src_byte == 0)
     e92:	31 11       	cpse	r19, r1
     e94:	01 c0       	rjmp	.+2      	; 0xe98 <cobs_decode+0x90>
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e96:	54 60       	ori	r21, 0x04	; 4
                }
                *dst_write_ptr++ = src_byte;
     e98:	31 93       	st	Z+, r19
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e9a:	91 50       	subi	r25, 0x01	; 1
     e9c:	c9 f7       	brne	.-14     	; 0xe90 <cobs_decode+0x88>
     e9e:	ef ef       	ldi	r30, 0xFF	; 255
     ea0:	e7 0f       	add	r30, r23
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	31 96       	adiw	r30, 0x01	; 1
     ea6:	de 01       	movw	r26, r28
     ea8:	ae 0f       	add	r26, r30
     eaa:	bf 1f       	adc	r27, r31
     eac:	e0 0f       	add	r30, r16
     eae:	f1 1f       	adc	r31, r17
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     eb0:	ac 15       	cp	r26, r12
     eb2:	bd 05       	cpc	r27, r13
     eb4:	80 f4       	brcc	.+32     	; 0xed6 <cobs_decode+0xce>
            {
                break;
            }

            /* Add a zero to the end */
            if (len_code != 0xFE)
     eb6:	7e 3f       	cpi	r23, 0xFE	; 254
     eb8:	41 f2       	breq	.-112    	; 0xe4a <cobs_decode+0x42>
            {
                if (dst_write_ptr >= dst_buf_end_ptr)
     eba:	ea 15       	cp	r30, r10
     ebc:	fb 05       	cpc	r31, r11
     ebe:	10 f0       	brcs	.+4      	; 0xec4 <cobs_decode+0xbc>
                {
                    result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     ec0:	52 60       	ori	r21, 0x02	; 2
                    break;
     ec2:	09 c0       	rjmp	.+18     	; 0xed6 <cobs_decode+0xce>
                }
                *dst_write_ptr++ = 0;
     ec4:	8f 01       	movw	r16, r30
     ec6:	0f 5f       	subi	r16, 0xFF	; 255
     ec8:	1f 4f       	sbci	r17, 0xFF	; 255
     eca:	10 82       	st	Z, r1
     ecc:	bf cf       	rjmp	.-130    	; 0xe4c <cobs_decode+0x44>
cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_write_ptr       = dst_buf_ptr;
     ece:	fc 01       	movw	r30, r24
}


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
     ed0:	50 e0       	ldi	r21, 0x00	; 0
     ed2:	01 c0       	rjmp	.+2      	; 0xed6 <cobs_decode+0xce>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ed4:	f8 01       	movw	r30, r16
        }
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     ed6:	ee 19       	sub	r30, r14
     ed8:	ff 09       	sbc	r31, r15
     eda:	6e 2f       	mov	r22, r30
     edc:	7f 2f       	mov	r23, r31
     ede:	85 2f       	mov	r24, r21
     ee0:	06 c0       	rjmp	.+12     	; 0xeee <cobs_decode+0xe6>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ee2:	cc 15       	cp	r28, r12
     ee4:	dd 05       	cpc	r29, r13
     ee6:	b0 f7       	brcc	.-20     	; 0xed4 <cobs_decode+0xcc>
     ee8:	f8 01       	movw	r30, r16

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     eea:	de 01       	movw	r26, r28
     eec:	e6 cf       	rjmp	.-52     	; 0xeba <cobs_decode+0xb2>
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
}
     eee:	df 91       	pop	r29
     ef0:	cf 91       	pop	r28
     ef2:	1f 91       	pop	r17
     ef4:	0f 91       	pop	r16
     ef6:	ff 90       	pop	r15
     ef8:	ef 90       	pop	r14
     efa:	df 90       	pop	r13
     efc:	cf 90       	pop	r12
     efe:	bf 90       	pop	r11
     f00:	af 90       	pop	r10
     f02:	08 95       	ret

00000f04 <crc_ibutton_update>:
  return crc;
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
     f04:	86 27       	eor	r24, r22
     f06:	98 e0       	ldi	r25, 0x08	; 8
  for (i = 0; i < 8; i++) {
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
     f08:	2c e8       	ldi	r18, 0x8C	; 140
     f0a:	80 ff       	sbrs	r24, 0
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <crc_ibutton_update+0x10>
     f0e:	86 95       	lsr	r24
     f10:	82 27       	eor	r24, r18
     f12:	01 c0       	rjmp	.+2      	; 0xf16 <crc_ibutton_update+0x12>
    else crc >>= 1;
     f14:	86 95       	lsr	r24
     f16:	91 50       	subi	r25, 0x01	; 1
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
  for (i = 0; i < 8; i++) {
     f18:	c1 f7       	brne	.-16     	; 0xf0a <crc_ibutton_update+0x6>
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
    else crc >>= 1;
  }
  return crc;
     f1a:	08 95       	ret

00000f1c <calculate_crc>:

#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
     f1c:	0f 93       	push	r16
     f1e:	1f 93       	push	r17
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
     f24:	66 23       	and	r22, r22
     f26:	59 f0       	breq	.+22     	; 0xf3e <calculate_crc+0x22>
     f28:	8c 01       	movw	r16, r24
     f2a:	ec 01       	movw	r28, r24
     f2c:	06 0f       	add	r16, r22
     f2e:	11 1d       	adc	r17, r1
     f30:	80 e0       	ldi	r24, 0x00	; 0
    crc = crc_ibutton_update(crc, data[i]);
     f32:	69 91       	ld	r22, Y+
     f34:	e7 df       	rcall	.-50     	; 0xf04 <crc_ibutton_update>
char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
     f36:	0c 17       	cp	r16, r28
     f38:	1d 07       	cpc	r17, r29
     f3a:	d9 f7       	brne	.-10     	; 0xf32 <calculate_crc+0x16>
     f3c:	01 c0       	rjmp	.+2      	; 0xf40 <calculate_crc+0x24>
#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
     f3e:	80 e0       	ldi	r24, 0x00	; 0
  int i;
  for(i=0;i<len;i++) {
    crc = crc_ibutton_update(crc, data[i]);
  }
  return crc;
}
     f40:	df 91       	pop	r29
     f42:	cf 91       	pop	r28
     f44:	1f 91       	pop	r17
     f46:	0f 91       	pop	r16
     f48:	08 95       	ret

00000f4a <vDistSens_init>:
*/

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
     f4a:	80 b3       	in	r24, 0x10	; 16
     f4c:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     f4e:	ec e7       	ldi	r30, 0x7C	; 124
     f50:	f0 e0       	ldi	r31, 0x00	; 0
     f52:	80 81       	ld	r24, Z
     f54:	80 6c       	ori	r24, 0xC0	; 192
     f56:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
     f58:	ea e7       	ldi	r30, 0x7A	; 122
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	80 81       	ld	r24, Z
     f5e:	80 68       	ori	r24, 0x80	; 128
     f60:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
     f62:	80 81       	ld	r24, Z
     f64:	84 60       	ori	r24, 0x04	; 4
     f66:	80 83       	st	Z, r24
     f68:	08 95       	ret

00000f6a <ui8DistSens_readCM>:
uint8_t ui8DistSens_readCM(uint8_t sensorDirection){
    
    uint8_t ui8_analogValue;
    
    /* Choose channel */
    ADMUX = sensorDirection;
     f6a:	ec e7       	ldi	r30, 0x7C	; 124
     f6c:	f0 e0       	ldi	r31, 0x00	; 0
     f6e:	80 83       	st	Z, r24
    
    /* Enable internal 2,54V AREF */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     f70:	90 81       	ld	r25, Z
     f72:	90 6c       	ori	r25, 0xC0	; 192
     f74:	90 83       	st	Z, r25
    
    /* Start conversion */
    ADCSRA |= (1<<ADSC);
     f76:	ea e7       	ldi	r30, 0x7A	; 122
     f78:	f0 e0       	ldi	r31, 0x00	; 0
     f7a:	90 81       	ld	r25, Z
     f7c:	90 64       	ori	r25, 0x40	; 64
     f7e:	90 83       	st	Z, r25
    loop_until_bit_is_clear(ADCSRA, ADSC); // Macro from <avr/io.h>, wait until bit bit in IO register is set.
     f80:	90 81       	ld	r25, Z
     f82:	96 fd       	sbrc	r25, 6
     f84:	fd cf       	rjmp	.-6      	; 0xf80 <ui8DistSens_readCM+0x16>

    /* Return the 8 most significant bits from the 10 bit register */
    ui8_analogValue = (ADCL >> 2) | (ADCH << 6);
     f86:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     f8a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    // Returns corresponding distance in CM
    return ui8_analogToCM[sensorDirection][ui8_analogValue];
     f8e:	e8 2f       	mov	r30, r24
     f90:	f0 e0       	ldi	r31, 0x00	; 0
     f92:	26 95       	lsr	r18
     f94:	26 95       	lsr	r18
     f96:	30 e4       	ldi	r19, 0x40	; 64
     f98:	93 9f       	mul	r25, r19
     f9a:	c0 01       	movw	r24, r0
     f9c:	11 24       	eor	r1, r1
     f9e:	82 2b       	or	r24, r18
     fa0:	fe 2f       	mov	r31, r30
     fa2:	ee 27       	eor	r30, r30
     fa4:	e0 50       	subi	r30, 0x00	; 0
     fa6:	fe 4f       	sbci	r31, 0xFE	; 254
     fa8:	e8 0f       	add	r30, r24
     faa:	f1 1d       	adc	r31, r1
}
     fac:	80 81       	ld	r24, Z
     fae:	08 95       	ret

00000fb0 <vFunc_Inf2pi>:
#include <string.h>
#include <math.h>
#include <stdlib.h>

/* Take any angle and put it inside -pi,pi */
void vFunc_Inf2pi(float *angle_in_radians){
     fb0:	cf 92       	push	r12
     fb2:	df 92       	push	r13
     fb4:	ef 92       	push	r14
     fb6:	ff 92       	push	r15
     fb8:	cf 93       	push	r28
     fba:	df 93       	push	r29
     fbc:	ec 01       	movw	r28, r24
    do{
        if (*angle_in_radians > M_PI) *angle_in_radians -= 2*M_PI;
     fbe:	c8 80       	ld	r12, Y
     fc0:	d9 80       	ldd	r13, Y+1	; 0x01
     fc2:	ea 80       	ldd	r14, Y+2	; 0x02
     fc4:	fb 80       	ldd	r15, Y+3	; 0x03
     fc6:	2b ed       	ldi	r18, 0xDB	; 219
     fc8:	3f e0       	ldi	r19, 0x0F	; 15
     fca:	49 e4       	ldi	r20, 0x49	; 73
     fcc:	50 e4       	ldi	r21, 0x40	; 64
     fce:	c7 01       	movw	r24, r14
     fd0:	b6 01       	movw	r22, r12
     fd2:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
     fd6:	18 16       	cp	r1, r24
     fd8:	6c f4       	brge	.+26     	; 0xff4 <vFunc_Inf2pi+0x44>
     fda:	2b ed       	ldi	r18, 0xDB	; 219
     fdc:	3f e0       	ldi	r19, 0x0F	; 15
     fde:	49 ec       	ldi	r20, 0xC9	; 201
     fe0:	50 e4       	ldi	r21, 0x40	; 64
     fe2:	c7 01       	movw	r24, r14
     fe4:	b6 01       	movw	r22, r12
     fe6:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
     fea:	68 83       	st	Y, r22
     fec:	79 83       	std	Y+1, r23	; 0x01
     fee:	8a 83       	std	Y+2, r24	; 0x02
     ff0:	9b 83       	std	Y+3, r25	; 0x03
     ff2:	16 c0       	rjmp	.+44     	; 0x1020 <vFunc_Inf2pi+0x70>
        else if (*angle_in_radians < -M_PI) *angle_in_radians += 2*M_PI;
     ff4:	2b ed       	ldi	r18, 0xDB	; 219
     ff6:	3f e0       	ldi	r19, 0x0F	; 15
     ff8:	49 e4       	ldi	r20, 0x49	; 73
     ffa:	50 ec       	ldi	r21, 0xC0	; 192
     ffc:	c7 01       	movw	r24, r14
     ffe:	b6 01       	movw	r22, r12
    1000:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    1004:	88 23       	and	r24, r24
    1006:	64 f4       	brge	.+24     	; 0x1020 <vFunc_Inf2pi+0x70>
    1008:	2b ed       	ldi	r18, 0xDB	; 219
    100a:	3f e0       	ldi	r19, 0x0F	; 15
    100c:	49 ec       	ldi	r20, 0xC9	; 201
    100e:	50 e4       	ldi	r21, 0x40	; 64
    1010:	c7 01       	movw	r24, r14
    1012:	b6 01       	movw	r22, r12
    1014:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    1018:	68 83       	st	Y, r22
    101a:	79 83       	std	Y+1, r23	; 0x01
    101c:	8a 83       	std	Y+2, r24	; 0x02
    101e:	9b 83       	std	Y+3, r25	; 0x03
    } while (fabs(*angle_in_radians) > M_PI);
    1020:	88 81       	ld	r24, Y
    1022:	99 81       	ldd	r25, Y+1	; 0x01
    1024:	aa 81       	ldd	r26, Y+2	; 0x02
    1026:	bb 81       	ldd	r27, Y+3	; 0x03
    1028:	bc 01       	movw	r22, r24
    102a:	cd 01       	movw	r24, r26
    102c:	9f 77       	andi	r25, 0x7F	; 127
    102e:	2b ed       	ldi	r18, 0xDB	; 219
    1030:	3f e0       	ldi	r19, 0x0F	; 15
    1032:	49 e4       	ldi	r20, 0x49	; 73
    1034:	50 e4       	ldi	r21, 0x40	; 64
    1036:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    103a:	18 16       	cp	r1, r24
    103c:	0c f4       	brge	.+2      	; 0x1040 <vFunc_Inf2pi+0x90>
    103e:	bf cf       	rjmp	.-130    	; 0xfbe <vFunc_Inf2pi+0xe>
}
    1040:	df 91       	pop	r29
    1042:	cf 91       	pop	r28
    1044:	ff 90       	pop	r15
    1046:	ef 90       	pop	r14
    1048:	df 90       	pop	r13
    104a:	cf 90       	pop	r12
    104c:	08 95       	ret

0000104e <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    104e:	ef 92       	push	r14
    1050:	ff 92       	push	r15
    1052:	0f 93       	push	r16
    1054:	1f 93       	push	r17
    1056:	cf 93       	push	r28
    1058:	df 93       	push	r29
    105a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    105c:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    1060:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <pxEnd>
    1064:	90 91 02 08 	lds	r25, 0x0802	; 0x800802 <pxEnd+0x1>
    1068:	89 2b       	or	r24, r25
    106a:	41 f5       	brne	.+80     	; 0x10bc <pvPortMalloc+0x6e>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    106c:	e3 e0       	ldi	r30, 0x03	; 3
    106e:	f8 e0       	ldi	r31, 0x08	; 8
    1070:	a7 e0       	ldi	r26, 0x07	; 7
    1072:	b8 e0       	ldi	r27, 0x08	; 8
    1074:	b1 83       	std	Z+1, r27	; 0x01
    1076:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    1078:	13 82       	std	Z+3, r1	; 0x03
    107a:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    107c:	e3 e0       	ldi	r30, 0x03	; 3
    107e:	fa e1       	ldi	r31, 0x1A	; 26
    1080:	f0 93 02 08 	sts	0x0802, r31	; 0x800802 <pxEnd+0x1>
    1084:	e0 93 01 08 	sts	0x0801, r30	; 0x800801 <pxEnd>
	pxEnd->xBlockSize = 0;
    1088:	13 82       	std	Z+3, r1	; 0x03
    108a:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    108c:	11 82       	std	Z+1, r1	; 0x01
    108e:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    1090:	8c ef       	ldi	r24, 0xFC	; 252
    1092:	91 e1       	ldi	r25, 0x11	; 17
    1094:	13 96       	adiw	r26, 0x03	; 3
    1096:	9c 93       	st	X, r25
    1098:	8e 93       	st	-X, r24
    109a:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    109c:	ed 93       	st	X+, r30
    109e:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    10a0:	90 93 fe 07 	sts	0x07FE, r25	; 0x8007fe <xMinimumEverFreeBytesRemaining+0x1>
    10a4:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    10a8:	90 93 00 08 	sts	0x0800, r25	; 0x800800 <xFreeBytesRemaining+0x1>
    10ac:	80 93 ff 07 	sts	0x07FF, r24	; 0x8007ff <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    10b0:	80 e0       	ldi	r24, 0x00	; 0
    10b2:	90 e8       	ldi	r25, 0x80	; 128
    10b4:	90 93 fc 07 	sts	0x07FC, r25	; 0x8007fc <xBlockAllocatedBit+0x1>
    10b8:	80 93 fb 07 	sts	0x07FB, r24	; 0x8007fb <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    10bc:	80 91 fb 07 	lds	r24, 0x07FB	; 0x8007fb <xBlockAllocatedBit>
    10c0:	90 91 fc 07 	lds	r25, 0x07FC	; 0x8007fc <xBlockAllocatedBit+0x1>
    10c4:	8c 23       	and	r24, r28
    10c6:	9d 23       	and	r25, r29
    10c8:	89 2b       	or	r24, r25
    10ca:	09 f0       	breq	.+2      	; 0x10ce <pvPortMalloc+0x80>
    10cc:	b2 c0       	rjmp	.+356    	; 0x1232 <pvPortMalloc+0x1e4>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    10ce:	20 97       	sbiw	r28, 0x00	; 0
    10d0:	09 f4       	brne	.+2      	; 0x10d4 <pvPortMalloc+0x86>
    10d2:	b2 c0       	rjmp	.+356    	; 0x1238 <pvPortMalloc+0x1ea>
			{
				xWantedSize += xHeapStructSize;
    10d4:	ae 01       	movw	r20, r28
    10d6:	4c 5f       	subi	r20, 0xFC	; 252
    10d8:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    10da:	09 f4       	brne	.+2      	; 0x10de <pvPortMalloc+0x90>
    10dc:	b0 c0       	rjmp	.+352    	; 0x123e <pvPortMalloc+0x1f0>
    10de:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <xFreeBytesRemaining>
    10e2:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <xFreeBytesRemaining+0x1>
    10e6:	84 17       	cp	r24, r20
    10e8:	95 07       	cpc	r25, r21
    10ea:	08 f4       	brcc	.+2      	; 0x10ee <pvPortMalloc+0xa0>
    10ec:	ab c0       	rjmp	.+342    	; 0x1244 <pvPortMalloc+0x1f6>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    10ee:	e0 91 03 08 	lds	r30, 0x0803	; 0x800803 <xStart>
    10f2:	f0 91 04 08 	lds	r31, 0x0804	; 0x800804 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    10f6:	a3 e0       	ldi	r26, 0x03	; 3
    10f8:	b8 e0       	ldi	r27, 0x08	; 8
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    10fa:	02 c0       	rjmp	.+4      	; 0x1100 <pvPortMalloc+0xb2>
    10fc:	df 01       	movw	r26, r30
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    10fe:	f9 01       	movw	r30, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1100:	22 81       	ldd	r18, Z+2	; 0x02
    1102:	33 81       	ldd	r19, Z+3	; 0x03
    1104:	24 17       	cp	r18, r20
    1106:	35 07       	cpc	r19, r21
    1108:	28 f4       	brcc	.+10     	; 0x1114 <pvPortMalloc+0xc6>
    110a:	20 81       	ld	r18, Z
    110c:	31 81       	ldd	r19, Z+1	; 0x01
    110e:	21 15       	cp	r18, r1
    1110:	31 05       	cpc	r19, r1
    1112:	a1 f7       	brne	.-24     	; 0x10fc <pvPortMalloc+0xae>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    1114:	60 91 01 08 	lds	r22, 0x0801	; 0x800801 <pxEnd>
    1118:	70 91 02 08 	lds	r23, 0x0802	; 0x800802 <pxEnd+0x1>
    111c:	e6 17       	cp	r30, r22
    111e:	f7 07       	cpc	r31, r23
    1120:	09 f4       	brne	.+2      	; 0x1124 <pvPortMalloc+0xd6>
    1122:	93 c0       	rjmp	.+294    	; 0x124a <pvPortMalloc+0x1fc>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    1124:	cd 91       	ld	r28, X+
    1126:	dc 91       	ld	r29, X
    1128:	11 97       	sbiw	r26, 0x01	; 1
    112a:	7e 01       	movw	r14, r28
    112c:	84 e0       	ldi	r24, 0x04	; 4
    112e:	e8 0e       	add	r14, r24
    1130:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1132:	80 81       	ld	r24, Z
    1134:	91 81       	ldd	r25, Z+1	; 0x01
    1136:	8d 93       	st	X+, r24
    1138:	9c 93       	st	X, r25

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    113a:	82 81       	ldd	r24, Z+2	; 0x02
    113c:	93 81       	ldd	r25, Z+3	; 0x03
    113e:	84 1b       	sub	r24, r20
    1140:	95 0b       	sbc	r25, r21
    1142:	89 30       	cpi	r24, 0x09	; 9
    1144:	91 05       	cpc	r25, r1
    1146:	08 f4       	brcc	.+2      	; 0x114a <pvPortMalloc+0xfc>
    1148:	52 c0       	rjmp	.+164    	; 0x11ee <pvPortMalloc+0x1a0>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    114a:	9f 01       	movw	r18, r30
    114c:	24 0f       	add	r18, r20
    114e:	35 1f       	adc	r19, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1150:	d9 01       	movw	r26, r18
    1152:	13 96       	adiw	r26, 0x03	; 3
    1154:	9c 93       	st	X, r25
    1156:	8e 93       	st	-X, r24
    1158:	12 97       	sbiw	r26, 0x02	; 2
						pxBlock->xBlockSize = xWantedSize;
    115a:	53 83       	std	Z+3, r21	; 0x03
    115c:	42 83       	std	Z+2, r20	; 0x02
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    115e:	a3 e0       	ldi	r26, 0x03	; 3
    1160:	b8 e0       	ldi	r27, 0x08	; 8
    1162:	01 c0       	rjmp	.+2      	; 0x1166 <pvPortMalloc+0x118>
    1164:	dc 01       	movw	r26, r24
    1166:	8d 91       	ld	r24, X+
    1168:	9c 91       	ld	r25, X
    116a:	11 97       	sbiw	r26, 0x01	; 1
    116c:	82 17       	cp	r24, r18
    116e:	93 07       	cpc	r25, r19
    1170:	c8 f3       	brcs	.-14     	; 0x1164 <pvPortMalloc+0x116>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1172:	12 96       	adiw	r26, 0x02	; 2
    1174:	4d 91       	ld	r20, X+
    1176:	5c 91       	ld	r21, X
    1178:	13 97       	sbiw	r26, 0x03	; 3
    117a:	8d 01       	movw	r16, r26
    117c:	04 0f       	add	r16, r20
    117e:	15 1f       	adc	r17, r21
    1180:	20 17       	cp	r18, r16
    1182:	31 07       	cpc	r19, r17
    1184:	51 f4       	brne	.+20     	; 0x119a <pvPortMalloc+0x14c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    1186:	e9 01       	movw	r28, r18
    1188:	2a 81       	ldd	r18, Y+2	; 0x02
    118a:	3b 81       	ldd	r19, Y+3	; 0x03
    118c:	42 0f       	add	r20, r18
    118e:	53 1f       	adc	r21, r19
    1190:	13 96       	adiw	r26, 0x03	; 3
    1192:	5c 93       	st	X, r21
    1194:	4e 93       	st	-X, r20
    1196:	12 97       	sbiw	r26, 0x02	; 2
    1198:	9d 01       	movw	r18, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    119a:	e9 01       	movw	r28, r18
    119c:	4a 81       	ldd	r20, Y+2	; 0x02
    119e:	5b 81       	ldd	r21, Y+3	; 0x03
    11a0:	89 01       	movw	r16, r18
    11a2:	04 0f       	add	r16, r20
    11a4:	15 1f       	adc	r17, r21
    11a6:	80 17       	cp	r24, r16
    11a8:	91 07       	cpc	r25, r17
    11aa:	c9 f4       	brne	.+50     	; 0x11de <pvPortMalloc+0x190>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    11ac:	60 17       	cp	r22, r16
    11ae:	71 07       	cpc	r23, r17
    11b0:	91 f0       	breq	.+36     	; 0x11d6 <pvPortMalloc+0x188>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    11b2:	e8 01       	movw	r28, r16
    11b4:	8a 81       	ldd	r24, Y+2	; 0x02
    11b6:	9b 81       	ldd	r25, Y+3	; 0x03
    11b8:	48 0f       	add	r20, r24
    11ba:	59 1f       	adc	r21, r25
    11bc:	e9 01       	movw	r28, r18
    11be:	5b 83       	std	Y+3, r21	; 0x03
    11c0:	4a 83       	std	Y+2, r20	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    11c2:	8d 91       	ld	r24, X+
    11c4:	9c 91       	ld	r25, X
    11c6:	11 97       	sbiw	r26, 0x01	; 1
    11c8:	ec 01       	movw	r28, r24
    11ca:	88 81       	ld	r24, Y
    11cc:	99 81       	ldd	r25, Y+1	; 0x01
    11ce:	e9 01       	movw	r28, r18
    11d0:	99 83       	std	Y+1, r25	; 0x01
    11d2:	88 83       	st	Y, r24
    11d4:	07 c0       	rjmp	.+14     	; 0x11e4 <pvPortMalloc+0x196>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    11d6:	e9 01       	movw	r28, r18
    11d8:	79 83       	std	Y+1, r23	; 0x01
    11da:	68 83       	st	Y, r22
    11dc:	03 c0       	rjmp	.+6      	; 0x11e4 <pvPortMalloc+0x196>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    11de:	e9 01       	movw	r28, r18
    11e0:	99 83       	std	Y+1, r25	; 0x01
    11e2:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    11e4:	a2 17       	cp	r26, r18
    11e6:	b3 07       	cpc	r27, r19
    11e8:	11 f0       	breq	.+4      	; 0x11ee <pvPortMalloc+0x1a0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    11ea:	2d 93       	st	X+, r18
    11ec:	3c 93       	st	X, r19
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    11ee:	22 81       	ldd	r18, Z+2	; 0x02
    11f0:	33 81       	ldd	r19, Z+3	; 0x03
    11f2:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <xFreeBytesRemaining>
    11f6:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <xFreeBytesRemaining+0x1>
    11fa:	82 1b       	sub	r24, r18
    11fc:	93 0b       	sbc	r25, r19
    11fe:	90 93 00 08 	sts	0x0800, r25	; 0x800800 <xFreeBytesRemaining+0x1>
    1202:	80 93 ff 07 	sts	0x07FF, r24	; 0x8007ff <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    1206:	40 91 fd 07 	lds	r20, 0x07FD	; 0x8007fd <xMinimumEverFreeBytesRemaining>
    120a:	50 91 fe 07 	lds	r21, 0x07FE	; 0x8007fe <xMinimumEverFreeBytesRemaining+0x1>
    120e:	84 17       	cp	r24, r20
    1210:	95 07       	cpc	r25, r21
    1212:	20 f4       	brcc	.+8      	; 0x121c <pvPortMalloc+0x1ce>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1214:	90 93 fe 07 	sts	0x07FE, r25	; 0x8007fe <xMinimumEverFreeBytesRemaining+0x1>
    1218:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    121c:	80 91 fb 07 	lds	r24, 0x07FB	; 0x8007fb <xBlockAllocatedBit>
    1220:	90 91 fc 07 	lds	r25, 0x07FC	; 0x8007fc <xBlockAllocatedBit+0x1>
    1224:	28 2b       	or	r18, r24
    1226:	39 2b       	or	r19, r25
    1228:	33 83       	std	Z+3, r19	; 0x03
    122a:	22 83       	std	Z+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    122c:	11 82       	std	Z+1, r1	; 0x01
    122e:	10 82       	st	Z, r1
    1230:	0e c0       	rjmp	.+28     	; 0x124e <pvPortMalloc+0x200>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    1232:	e1 2c       	mov	r14, r1
    1234:	f1 2c       	mov	r15, r1
    1236:	0b c0       	rjmp	.+22     	; 0x124e <pvPortMalloc+0x200>
    1238:	e1 2c       	mov	r14, r1
    123a:	f1 2c       	mov	r15, r1
    123c:	08 c0       	rjmp	.+16     	; 0x124e <pvPortMalloc+0x200>
    123e:	e1 2c       	mov	r14, r1
    1240:	f1 2c       	mov	r15, r1
    1242:	05 c0       	rjmp	.+10     	; 0x124e <pvPortMalloc+0x200>
    1244:	e1 2c       	mov	r14, r1
    1246:	f1 2c       	mov	r15, r1
    1248:	02 c0       	rjmp	.+4      	; 0x124e <pvPortMalloc+0x200>
    124a:	e1 2c       	mov	r14, r1
    124c:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    124e:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    1252:	c7 01       	movw	r24, r14
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	1f 91       	pop	r17
    125a:	0f 91       	pop	r16
    125c:	ff 90       	pop	r15
    125e:	ef 90       	pop	r14
    1260:	08 95       	ret

00001262 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    1266:	00 97       	sbiw	r24, 0x00	; 0
    1268:	09 f4       	brne	.+2      	; 0x126c <vPortFree+0xa>
    126a:	68 c0       	rjmp	.+208    	; 0x133c <vPortFree+0xda>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    126c:	fc 01       	movw	r30, r24
    126e:	34 97       	sbiw	r30, 0x04	; 4
    1270:	22 81       	ldd	r18, Z+2	; 0x02
    1272:	33 81       	ldd	r19, Z+3	; 0x03
    1274:	40 91 fb 07 	lds	r20, 0x07FB	; 0x8007fb <xBlockAllocatedBit>
    1278:	50 91 fc 07 	lds	r21, 0x07FC	; 0x8007fc <xBlockAllocatedBit+0x1>
    127c:	b9 01       	movw	r22, r18
    127e:	64 23       	and	r22, r20
    1280:	75 23       	and	r23, r21
    1282:	67 2b       	or	r22, r23
    1284:	09 f4       	brne	.+2      	; 0x1288 <vPortFree+0x26>
    1286:	5a c0       	rjmp	.+180    	; 0x133c <vPortFree+0xda>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    1288:	60 81       	ld	r22, Z
    128a:	71 81       	ldd	r23, Z+1	; 0x01
    128c:	67 2b       	or	r22, r23
    128e:	09 f0       	breq	.+2      	; 0x1292 <vPortFree+0x30>
    1290:	55 c0       	rjmp	.+170    	; 0x133c <vPortFree+0xda>

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    1292:	ef 01       	movw	r28, r30
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    1294:	40 95       	com	r20
    1296:	50 95       	com	r21
    1298:	24 23       	and	r18, r20
    129a:	35 23       	and	r19, r21
    129c:	33 83       	std	Z+3, r19	; 0x03
    129e:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    12a0:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    12a4:	4a 81       	ldd	r20, Y+2	; 0x02
    12a6:	5b 81       	ldd	r21, Y+3	; 0x03
    12a8:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <xFreeBytesRemaining>
    12ac:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <xFreeBytesRemaining+0x1>
    12b0:	84 0f       	add	r24, r20
    12b2:	95 1f       	adc	r25, r21
    12b4:	90 93 00 08 	sts	0x0800, r25	; 0x800800 <xFreeBytesRemaining+0x1>
    12b8:	80 93 ff 07 	sts	0x07FF, r24	; 0x8007ff <xFreeBytesRemaining>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    12bc:	e3 e0       	ldi	r30, 0x03	; 3
    12be:	f8 e0       	ldi	r31, 0x08	; 8
    12c0:	01 c0       	rjmp	.+2      	; 0x12c4 <vPortFree+0x62>
    12c2:	fc 01       	movw	r30, r24
    12c4:	80 81       	ld	r24, Z
    12c6:	91 81       	ldd	r25, Z+1	; 0x01
    12c8:	8c 17       	cp	r24, r28
    12ca:	9d 07       	cpc	r25, r29
    12cc:	d0 f3       	brcs	.-12     	; 0x12c2 <vPortFree+0x60>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    12ce:	22 81       	ldd	r18, Z+2	; 0x02
    12d0:	33 81       	ldd	r19, Z+3	; 0x03
    12d2:	bf 01       	movw	r22, r30
    12d4:	62 0f       	add	r22, r18
    12d6:	73 1f       	adc	r23, r19
    12d8:	c6 17       	cp	r28, r22
    12da:	d7 07       	cpc	r29, r23
    12dc:	29 f4       	brne	.+10     	; 0x12e8 <vPortFree+0x86>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    12de:	24 0f       	add	r18, r20
    12e0:	35 1f       	adc	r19, r21
    12e2:	33 83       	std	Z+3, r19	; 0x03
    12e4:	22 83       	std	Z+2, r18	; 0x02
    12e6:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    12e8:	2a 81       	ldd	r18, Y+2	; 0x02
    12ea:	3b 81       	ldd	r19, Y+3	; 0x03
    12ec:	de 01       	movw	r26, r28
    12ee:	a2 0f       	add	r26, r18
    12f0:	b3 1f       	adc	r27, r19
    12f2:	8a 17       	cp	r24, r26
    12f4:	9b 07       	cpc	r25, r27
    12f6:	c9 f4       	brne	.+50     	; 0x132a <vPortFree+0xc8>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    12f8:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <pxEnd>
    12fc:	90 91 02 08 	lds	r25, 0x0802	; 0x800802 <pxEnd+0x1>
    1300:	a8 17       	cp	r26, r24
    1302:	b9 07       	cpc	r27, r25
    1304:	79 f0       	breq	.+30     	; 0x1324 <vPortFree+0xc2>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    1306:	12 96       	adiw	r26, 0x02	; 2
    1308:	8d 91       	ld	r24, X+
    130a:	9c 91       	ld	r25, X
    130c:	13 97       	sbiw	r26, 0x03	; 3
    130e:	28 0f       	add	r18, r24
    1310:	39 1f       	adc	r19, r25
    1312:	3b 83       	std	Y+3, r19	; 0x03
    1314:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1316:	a0 81       	ld	r26, Z
    1318:	b1 81       	ldd	r27, Z+1	; 0x01
    131a:	8d 91       	ld	r24, X+
    131c:	9c 91       	ld	r25, X
    131e:	99 83       	std	Y+1, r25	; 0x01
    1320:	88 83       	st	Y, r24
    1322:	05 c0       	rjmp	.+10     	; 0x132e <vPortFree+0xcc>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    1324:	b9 83       	std	Y+1, r27	; 0x01
    1326:	a8 83       	st	Y, r26
    1328:	02 c0       	rjmp	.+4      	; 0x132e <vPortFree+0xcc>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    132a:	99 83       	std	Y+1, r25	; 0x01
    132c:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    132e:	ec 17       	cp	r30, r28
    1330:	fd 07       	cpc	r31, r29
    1332:	11 f0       	breq	.+4      	; 0x1338 <vPortFree+0xd6>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    1334:	d1 83       	std	Z+1, r29	; 0x01
    1336:	c0 83       	st	Z, r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
    1338:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	08 95       	ret

00001342 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1342:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <xFreeBytesRemaining>
    1346:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <xFreeBytesRemaining+0x1>
    134a:	08 95       	ret

0000134c <sIMU_readRegisterRegion>:
}
float fIMU_readFloatGyroY( void ){
    
    float output = fIMU_calcGyro(i16IMU_readRawGyroY());
    return output;
}
    134c:	ef 92       	push	r14
    134e:	ff 92       	push	r15
    1350:	0f 93       	push	r16
    1352:	1f 93       	push	r17
    1354:	cf 93       	push	r28
    1356:	df 93       	push	r29
    1358:	ec 01       	movw	r28, r24
    135a:	e4 2e       	mov	r14, r20
    135c:	28 98       	cbi	0x05, 0	; 5
    135e:	86 2f       	mov	r24, r22
    1360:	80 68       	ori	r24, 0x80	; 128
    1362:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ui8SPI_MasterTransmit>
    1366:	ee 20       	and	r14, r14
    1368:	b1 f0       	breq	.+44     	; 0x1396 <sIMU_readRegisterRegion+0x4a>
    136a:	0f ef       	ldi	r16, 0xFF	; 255
    136c:	0e 0d       	add	r16, r14
    136e:	10 e0       	ldi	r17, 0x00	; 0
    1370:	0f 5f       	subi	r16, 0xFF	; 255
    1372:	1f 4f       	sbci	r17, 0xFF	; 255
    1374:	0c 0f       	add	r16, r28
    1376:	1d 1f       	adc	r17, r29
    1378:	f1 2c       	mov	r15, r1
    137a:	80 e0       	ldi	r24, 0x00	; 0
    137c:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ui8SPI_MasterTransmit>
    1380:	8f 3f       	cpi	r24, 0xFF	; 255
    1382:	09 f4       	brne	.+2      	; 0x1386 <sIMU_readRegisterRegion+0x3a>
    1384:	f3 94       	inc	r15
    1386:	89 93       	st	Y+, r24
    1388:	0c 17       	cp	r16, r28
    138a:	1d 07       	cpc	r17, r29
    138c:	b1 f7       	brne	.-20     	; 0x137a <sIMU_readRegisterRegion+0x2e>
    138e:	fe 10       	cpse	r15, r14
    1390:	04 c0       	rjmp	.+8      	; 0x139a <sIMU_readRegisterRegion+0x4e>
    1392:	85 e0       	ldi	r24, 0x05	; 5
    1394:	03 c0       	rjmp	.+6      	; 0x139c <sIMU_readRegisterRegion+0x50>
    1396:	85 e0       	ldi	r24, 0x05	; 5
    1398:	01 c0       	rjmp	.+2      	; 0x139c <sIMU_readRegisterRegion+0x50>
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	28 9a       	sbi	0x05, 0	; 5
    139e:	df 91       	pop	r29
    13a0:	cf 91       	pop	r28
    13a2:	1f 91       	pop	r17
    13a4:	0f 91       	pop	r16
    13a6:	ff 90       	pop	r15
    13a8:	ef 90       	pop	r14
    13aa:	08 95       	ret

000013ac <sIMU_readRegister>:
    13ac:	cf 93       	push	r28
    13ae:	df 93       	push	r29
    13b0:	ec 01       	movw	r28, r24
    13b2:	28 98       	cbi	0x05, 0	; 5
    13b4:	86 2f       	mov	r24, r22
    13b6:	80 68       	ori	r24, 0x80	; 128
    13b8:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ui8SPI_MasterTransmit>
    13bc:	80 e0       	ldi	r24, 0x00	; 0
    13be:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ui8SPI_MasterTransmit>
    13c2:	28 9a       	sbi	0x05, 0	; 5
    13c4:	8f 3f       	cpi	r24, 0xFF	; 255
    13c6:	11 f4       	brne	.+4      	; 0x13cc <sIMU_readRegister+0x20>
    13c8:	95 e0       	ldi	r25, 0x05	; 5
    13ca:	01 c0       	rjmp	.+2      	; 0x13ce <sIMU_readRegister+0x22>
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	88 83       	st	Y, r24
    13d0:	89 2f       	mov	r24, r25
    13d2:	df 91       	pop	r29
    13d4:	cf 91       	pop	r28
    13d6:	08 95       	ret

000013d8 <sIMU_Init>:
    13d8:	cf 93       	push	r28
    13da:	df 93       	push	r29
    13dc:	1f 92       	push	r1
    13de:	1f 92       	push	r1
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62
    13e4:	e3 e6       	ldi	r30, 0x63	; 99
    13e6:	fb e1       	ldi	r31, 0x1B	; 27
    13e8:	81 e0       	ldi	r24, 0x01	; 1
    13ea:	80 83       	st	Z, r24
    13ec:	24 ef       	ldi	r18, 0xF4	; 244
    13ee:	31 e0       	ldi	r19, 0x01	; 1
    13f0:	32 83       	std	Z+2, r19	; 0x02
    13f2:	21 83       	std	Z+1, r18	; 0x01
    13f4:	22 e8       	ldi	r18, 0x82	; 130
    13f6:	36 e0       	ldi	r19, 0x06	; 6
    13f8:	34 83       	std	Z+4, r19	; 0x04
    13fa:	23 83       	std	Z+3, r18	; 0x03
    13fc:	20 e9       	ldi	r18, 0x90	; 144
    13fe:	31 e0       	ldi	r19, 0x01	; 1
    1400:	36 83       	std	Z+6, r19	; 0x06
    1402:	25 83       	std	Z+5, r18	; 0x05
    1404:	17 82       	std	Z+7, r1	; 0x07
    1406:	10 86       	std	Z+8, r1	; 0x08
    1408:	81 87       	std	Z+9, r24	; 0x09
    140a:	82 87       	std	Z+10, r24	; 0x0a
    140c:	20 e1       	ldi	r18, 0x10	; 16
    140e:	30 e0       	ldi	r19, 0x00	; 0
    1410:	34 87       	std	Z+12, r19	; 0x0c
    1412:	23 87       	std	Z+11, r18	; 0x0b
    1414:	2d e0       	ldi	r18, 0x0D	; 13
    1416:	30 e0       	ldi	r19, 0x00	; 0
    1418:	36 87       	std	Z+14, r19	; 0x0e
    141a:	25 87       	std	Z+13, r18	; 0x0d
    141c:	22 e3       	ldi	r18, 0x32	; 50
    141e:	30 e0       	ldi	r19, 0x00	; 0
    1420:	30 8b       	std	Z+16, r19	; 0x10
    1422:	27 87       	std	Z+15, r18	; 0x0f
    1424:	11 8a       	std	Z+17, r1	; 0x11
    1426:	12 8a       	std	Z+18, r1	; 0x12
    1428:	83 8b       	std	Z+19, r24	; 0x13
    142a:	84 8b       	std	Z+20, r24	; 0x14
    142c:	88 eb       	ldi	r24, 0xB8	; 184
    142e:	9b e0       	ldi	r25, 0x0B	; 11
    1430:	96 8b       	std	Z+22, r25	; 0x16
    1432:	85 8b       	std	Z+21, r24	; 0x15
    1434:	8a e0       	ldi	r24, 0x0A	; 10
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	90 8f       	std	Z+24, r25	; 0x18
    143a:	87 8b       	std	Z+23, r24	; 0x17
    143c:	11 8e       	std	Z+25, r1	; 0x19
    143e:	10 92 7e 1b 	sts	0x1B7E, r1	; 0x801b7e <allOnesCounter+0x1>
    1442:	10 92 7d 1b 	sts	0x1B7D, r1	; 0x801b7d <allOnesCounter>
    1446:	10 92 80 1b 	sts	0x1B80, r1	; 0x801b80 <nonSuccessCounter+0x1>
    144a:	10 92 7f 1b 	sts	0x1B7F, r1	; 0x801b7f <nonSuccessCounter>
    144e:	0e 94 b2 26 	call	0x4d64	; 0x4d64 <vSPI_MasterInit>
    1452:	20 9a       	sbi	0x04, 0	; 4
    1454:	28 9a       	sbi	0x05, 0	; 5
    1456:	19 82       	std	Y+1, r1	; 0x01
    1458:	20 e1       	ldi	r18, 0x10	; 16
    145a:	37 e2       	ldi	r19, 0x27	; 39
    145c:	89 81       	ldd	r24, Y+1	; 0x01
    145e:	8f 5f       	subi	r24, 0xFF	; 255
    1460:	89 83       	std	Y+1, r24	; 0x01
    1462:	21 50       	subi	r18, 0x01	; 1
    1464:	31 09       	sbc	r19, r1
    1466:	d1 f7       	brne	.-12     	; 0x145c <sIMU_Init+0x84>
    1468:	6f e0       	ldi	r22, 0x0F	; 15
    146a:	ce 01       	movw	r24, r28
    146c:	02 96       	adiw	r24, 0x02	; 2
    146e:	9e df       	rcall	.-196    	; 0x13ac <sIMU_readRegister>
    1470:	8a 81       	ldd	r24, Y+2	; 0x02
    1472:	89 36       	cpi	r24, 0x69	; 105
    1474:	c9 f7       	brne	.-14     	; 0x1468 <sIMU_Init+0x90>
    1476:	80 e0       	ldi	r24, 0x00	; 0
    1478:	0f 90       	pop	r0
    147a:	0f 90       	pop	r0
    147c:	df 91       	pop	r29
    147e:	cf 91       	pop	r28
    1480:	08 95       	ret

00001482 <sIMU_readRegisterInt16>:
    1482:	0f 93       	push	r16
    1484:	1f 93       	push	r17
    1486:	cf 93       	push	r28
    1488:	df 93       	push	r29
    148a:	1f 92       	push	r1
    148c:	1f 92       	push	r1
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
    1492:	8c 01       	movw	r16, r24
    1494:	42 e0       	ldi	r20, 0x02	; 2
    1496:	ce 01       	movw	r24, r28
    1498:	01 96       	adiw	r24, 0x01	; 1
    149a:	58 df       	rcall	.-336    	; 0x134c <sIMU_readRegisterRegion>
    149c:	2a 81       	ldd	r18, Y+2	; 0x02
    149e:	30 e0       	ldi	r19, 0x00	; 0
    14a0:	32 2f       	mov	r19, r18
    14a2:	22 27       	eor	r18, r18
    14a4:	99 81       	ldd	r25, Y+1	; 0x01
    14a6:	29 2b       	or	r18, r25
    14a8:	f8 01       	movw	r30, r16
    14aa:	31 83       	std	Z+1, r19	; 0x01
    14ac:	20 83       	st	Z, r18
    14ae:	0f 90       	pop	r0
    14b0:	0f 90       	pop	r0
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	08 95       	ret

000014bc <sIMU_writeRegister>:
    14bc:	cf 93       	push	r28
    14be:	c6 2f       	mov	r28, r22
    14c0:	28 98       	cbi	0x05, 0	; 5
    14c2:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ui8SPI_MasterTransmit>
    14c6:	8c 2f       	mov	r24, r28
    14c8:	0e 94 c0 26 	call	0x4d80	; 0x4d80 <ui8SPI_MasterTransmit>
    14cc:	28 9a       	sbi	0x05, 0	; 5
    14ce:	80 e0       	ldi	r24, 0x00	; 0
    14d0:	cf 91       	pop	r28
    14d2:	08 95       	ret

000014d4 <sIMU_begin>:
    14d4:	1f 93       	push	r17
    14d6:	cf 93       	push	r28
    14d8:	df 93       	push	r29
    14da:	1f 92       	push	r1
    14dc:	1f 92       	push	r1
    14de:	cd b7       	in	r28, 0x3d	; 61
    14e0:	de b7       	in	r29, 0x3e	; 62
    14e2:	19 82       	std	Y+1, r1	; 0x01
    14e4:	79 df       	rcall	.-270    	; 0x13d8 <sIMU_Init>
    14e6:	18 2f       	mov	r17, r24
    14e8:	19 82       	std	Y+1, r1	; 0x01
    14ea:	80 91 6c 1b 	lds	r24, 0x1B6C	; 0x801b6c <settings+0x9>
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	09 f0       	breq	.+2      	; 0x14f4 <sIMU_begin+0x20>
    14f2:	83 c0       	rjmp	.+262    	; 0x15fa <sIMU_begin+0x126>
    14f4:	80 91 72 1b 	lds	r24, 0x1B72	; 0x801b72 <settings+0xf>
    14f8:	90 91 73 1b 	lds	r25, 0x1B73	; 0x801b73 <settings+0x10>
    14fc:	84 36       	cpi	r24, 0x64	; 100
    14fe:	91 05       	cpc	r25, r1
    1500:	41 f0       	breq	.+16     	; 0x1512 <sIMU_begin+0x3e>
    1502:	88 3c       	cpi	r24, 0xC8	; 200
    1504:	91 05       	cpc	r25, r1
    1506:	41 f0       	breq	.+16     	; 0x1518 <sIMU_begin+0x44>
    1508:	c2 97       	sbiw	r24, 0x32	; 50
    150a:	41 f4       	brne	.+16     	; 0x151c <sIMU_begin+0x48>
    150c:	83 e0       	ldi	r24, 0x03	; 3
    150e:	89 83       	std	Y+1, r24	; 0x01
    1510:	05 c0       	rjmp	.+10     	; 0x151c <sIMU_begin+0x48>
    1512:	82 e0       	ldi	r24, 0x02	; 2
    1514:	89 83       	std	Y+1, r24	; 0x01
    1516:	02 c0       	rjmp	.+4      	; 0x151c <sIMU_begin+0x48>
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	89 83       	std	Y+1, r24	; 0x01
    151c:	80 91 6e 1b 	lds	r24, 0x1B6E	; 0x801b6e <settings+0xb>
    1520:	90 91 6f 1b 	lds	r25, 0x1B6F	; 0x801b6f <settings+0xc>
    1524:	84 30       	cpi	r24, 0x04	; 4
    1526:	91 05       	cpc	r25, r1
    1528:	31 f0       	breq	.+12     	; 0x1536 <sIMU_begin+0x62>
    152a:	88 30       	cpi	r24, 0x08	; 8
    152c:	91 05       	cpc	r25, r1
    152e:	39 f0       	breq	.+14     	; 0x153e <sIMU_begin+0x6a>
    1530:	02 97       	sbiw	r24, 0x02	; 2
    1532:	49 f4       	brne	.+18     	; 0x1546 <sIMU_begin+0x72>
    1534:	0b c0       	rjmp	.+22     	; 0x154c <sIMU_begin+0x78>
    1536:	89 81       	ldd	r24, Y+1	; 0x01
    1538:	88 60       	ori	r24, 0x08	; 8
    153a:	89 83       	std	Y+1, r24	; 0x01
    153c:	07 c0       	rjmp	.+14     	; 0x154c <sIMU_begin+0x78>
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	8c 60       	ori	r24, 0x0C	; 12
    1542:	89 83       	std	Y+1, r24	; 0x01
    1544:	03 c0       	rjmp	.+6      	; 0x154c <sIMU_begin+0x78>
    1546:	89 81       	ldd	r24, Y+1	; 0x01
    1548:	84 60       	ori	r24, 0x04	; 4
    154a:	89 83       	std	Y+1, r24	; 0x01
    154c:	80 91 70 1b 	lds	r24, 0x1B70	; 0x801b70 <settings+0xd>
    1550:	90 91 71 1b 	lds	r25, 0x1B71	; 0x801b71 <settings+0xe>
    1554:	80 3a       	cpi	r24, 0xA0	; 160
    1556:	21 e0       	ldi	r18, 0x01	; 1
    1558:	92 07       	cpc	r25, r18
    155a:	c1 f1       	breq	.+112    	; 0x15cc <sIMU_begin+0xf8>
    155c:	70 f4       	brcc	.+28     	; 0x157a <sIMU_begin+0xa6>
    155e:	8a 31       	cpi	r24, 0x1A	; 26
    1560:	91 05       	cpc	r25, r1
    1562:	21 f1       	breq	.+72     	; 0x15ac <sIMU_begin+0xd8>
    1564:	18 f4       	brcc	.+6      	; 0x156c <sIMU_begin+0x98>
    1566:	0d 97       	sbiw	r24, 0x0d	; 13
    1568:	e9 f0       	breq	.+58     	; 0x15a4 <sIMU_begin+0xd0>
    156a:	28 c0       	rjmp	.+80     	; 0x15bc <sIMU_begin+0xe8>
    156c:	84 33       	cpi	r24, 0x34	; 52
    156e:	91 05       	cpc	r25, r1
    1570:	09 f1       	breq	.+66     	; 0x15b4 <sIMU_begin+0xe0>
    1572:	80 3d       	cpi	r24, 0xD0	; 208
    1574:	91 05       	cpc	r25, r1
    1576:	31 f1       	breq	.+76     	; 0x15c4 <sIMU_begin+0xf0>
    1578:	21 c0       	rjmp	.+66     	; 0x15bc <sIMU_begin+0xe8>
    157a:	82 30       	cpi	r24, 0x02	; 2
    157c:	2d e0       	ldi	r18, 0x0D	; 13
    157e:	92 07       	cpc	r25, r18
    1580:	89 f1       	breq	.+98     	; 0x15e4 <sIMU_begin+0x110>
    1582:	40 f4       	brcc	.+16     	; 0x1594 <sIMU_begin+0xc0>
    1584:	81 34       	cpi	r24, 0x41	; 65
    1586:	23 e0       	ldi	r18, 0x03	; 3
    1588:	92 07       	cpc	r25, r18
    158a:	21 f1       	breq	.+72     	; 0x15d4 <sIMU_begin+0x100>
    158c:	8c 37       	cpi	r24, 0x7C	; 124
    158e:	96 40       	sbci	r25, 0x06	; 6
    1590:	29 f1       	breq	.+74     	; 0x15dc <sIMU_begin+0x108>
    1592:	14 c0       	rjmp	.+40     	; 0x15bc <sIMU_begin+0xe8>
    1594:	84 30       	cpi	r24, 0x04	; 4
    1596:	2a e1       	ldi	r18, 0x1A	; 26
    1598:	92 07       	cpc	r25, r18
    159a:	41 f1       	breq	.+80     	; 0x15ec <sIMU_begin+0x118>
    159c:	82 31       	cpi	r24, 0x12	; 18
    159e:	94 43       	sbci	r25, 0x34	; 52
    15a0:	49 f1       	breq	.+82     	; 0x15f4 <sIMU_begin+0x120>
    15a2:	0c c0       	rjmp	.+24     	; 0x15bc <sIMU_begin+0xe8>
    15a4:	89 81       	ldd	r24, Y+1	; 0x01
    15a6:	80 61       	ori	r24, 0x10	; 16
    15a8:	89 83       	std	Y+1, r24	; 0x01
    15aa:	27 c0       	rjmp	.+78     	; 0x15fa <sIMU_begin+0x126>
    15ac:	89 81       	ldd	r24, Y+1	; 0x01
    15ae:	80 62       	ori	r24, 0x20	; 32
    15b0:	89 83       	std	Y+1, r24	; 0x01
    15b2:	23 c0       	rjmp	.+70     	; 0x15fa <sIMU_begin+0x126>
    15b4:	89 81       	ldd	r24, Y+1	; 0x01
    15b6:	80 63       	ori	r24, 0x30	; 48
    15b8:	89 83       	std	Y+1, r24	; 0x01
    15ba:	1f c0       	rjmp	.+62     	; 0x15fa <sIMU_begin+0x126>
    15bc:	89 81       	ldd	r24, Y+1	; 0x01
    15be:	80 64       	ori	r24, 0x40	; 64
    15c0:	89 83       	std	Y+1, r24	; 0x01
    15c2:	1b c0       	rjmp	.+54     	; 0x15fa <sIMU_begin+0x126>
    15c4:	89 81       	ldd	r24, Y+1	; 0x01
    15c6:	80 65       	ori	r24, 0x50	; 80
    15c8:	89 83       	std	Y+1, r24	; 0x01
    15ca:	17 c0       	rjmp	.+46     	; 0x15fa <sIMU_begin+0x126>
    15cc:	89 81       	ldd	r24, Y+1	; 0x01
    15ce:	80 66       	ori	r24, 0x60	; 96
    15d0:	89 83       	std	Y+1, r24	; 0x01
    15d2:	13 c0       	rjmp	.+38     	; 0x15fa <sIMU_begin+0x126>
    15d4:	89 81       	ldd	r24, Y+1	; 0x01
    15d6:	80 67       	ori	r24, 0x70	; 112
    15d8:	89 83       	std	Y+1, r24	; 0x01
    15da:	0f c0       	rjmp	.+30     	; 0x15fa <sIMU_begin+0x126>
    15dc:	89 81       	ldd	r24, Y+1	; 0x01
    15de:	80 68       	ori	r24, 0x80	; 128
    15e0:	89 83       	std	Y+1, r24	; 0x01
    15e2:	0b c0       	rjmp	.+22     	; 0x15fa <sIMU_begin+0x126>
    15e4:	89 81       	ldd	r24, Y+1	; 0x01
    15e6:	80 69       	ori	r24, 0x90	; 144
    15e8:	89 83       	std	Y+1, r24	; 0x01
    15ea:	07 c0       	rjmp	.+14     	; 0x15fa <sIMU_begin+0x126>
    15ec:	89 81       	ldd	r24, Y+1	; 0x01
    15ee:	80 6a       	ori	r24, 0xA0	; 160
    15f0:	89 83       	std	Y+1, r24	; 0x01
    15f2:	03 c0       	rjmp	.+6      	; 0x15fa <sIMU_begin+0x126>
    15f4:	89 81       	ldd	r24, Y+1	; 0x01
    15f6:	80 6b       	ori	r24, 0xB0	; 176
    15f8:	89 83       	std	Y+1, r24	; 0x01
    15fa:	69 81       	ldd	r22, Y+1	; 0x01
    15fc:	80 e1       	ldi	r24, 0x10	; 16
    15fe:	5e df       	rcall	.-324    	; 0x14bc <sIMU_writeRegister>
    1600:	63 e1       	ldi	r22, 0x13	; 19
    1602:	ce 01       	movw	r24, r28
    1604:	01 96       	adiw	r24, 0x01	; 1
    1606:	d2 de       	rcall	.-604    	; 0x13ac <sIMU_readRegister>
    1608:	89 81       	ldd	r24, Y+1	; 0x01
    160a:	8f 77       	andi	r24, 0x7F	; 127
    160c:	89 83       	std	Y+1, r24	; 0x01
    160e:	90 91 6d 1b 	lds	r25, 0x1B6D	; 0x801b6d <settings+0xa>
    1612:	91 30       	cpi	r25, 0x01	; 1
    1614:	11 f4       	brne	.+4      	; 0x161a <sIMU_begin+0x146>
    1616:	80 68       	ori	r24, 0x80	; 128
    1618:	89 83       	std	Y+1, r24	; 0x01
    161a:	69 81       	ldd	r22, Y+1	; 0x01
    161c:	83 e1       	ldi	r24, 0x13	; 19
    161e:	4e df       	rcall	.-356    	; 0x14bc <sIMU_writeRegister>
    1620:	19 82       	std	Y+1, r1	; 0x01
    1622:	80 91 63 1b 	lds	r24, 0x1B63	; 0x801b63 <settings>
    1626:	81 30       	cpi	r24, 0x01	; 1
    1628:	09 f0       	breq	.+2      	; 0x162c <sIMU_begin+0x158>
    162a:	5b c0       	rjmp	.+182    	; 0x16e2 <sIMU_begin+0x20e>
    162c:	80 91 64 1b 	lds	r24, 0x1B64	; 0x801b64 <settings+0x1>
    1630:	90 91 65 1b 	lds	r25, 0x1B65	; 0x801b65 <settings+0x2>
    1634:	85 3f       	cpi	r24, 0xF5	; 245
    1636:	91 05       	cpc	r25, r1
    1638:	c1 f0       	breq	.+48     	; 0x166a <sIMU_begin+0x196>
    163a:	20 f4       	brcc	.+8      	; 0x1644 <sIMU_begin+0x170>
    163c:	8d 37       	cpi	r24, 0x7D	; 125
    163e:	91 05       	cpc	r25, r1
    1640:	49 f0       	breq	.+18     	; 0x1654 <sIMU_begin+0x180>
    1642:	11 c0       	rjmp	.+34     	; 0x1666 <sIMU_begin+0x192>
    1644:	84 3f       	cpi	r24, 0xF4	; 244
    1646:	21 e0       	ldi	r18, 0x01	; 1
    1648:	92 07       	cpc	r25, r18
    164a:	39 f0       	breq	.+14     	; 0x165a <sIMU_begin+0x186>
    164c:	88 3e       	cpi	r24, 0xE8	; 232
    164e:	93 40       	sbci	r25, 0x03	; 3
    1650:	39 f0       	breq	.+14     	; 0x1660 <sIMU_begin+0x18c>
    1652:	09 c0       	rjmp	.+18     	; 0x1666 <sIMU_begin+0x192>
    1654:	82 e0       	ldi	r24, 0x02	; 2
    1656:	89 83       	std	Y+1, r24	; 0x01
    1658:	08 c0       	rjmp	.+16     	; 0x166a <sIMU_begin+0x196>
    165a:	84 e0       	ldi	r24, 0x04	; 4
    165c:	89 83       	std	Y+1, r24	; 0x01
    165e:	05 c0       	rjmp	.+10     	; 0x166a <sIMU_begin+0x196>
    1660:	88 e0       	ldi	r24, 0x08	; 8
    1662:	89 83       	std	Y+1, r24	; 0x01
    1664:	02 c0       	rjmp	.+4      	; 0x166a <sIMU_begin+0x196>
    1666:	8c e0       	ldi	r24, 0x0C	; 12
    1668:	89 83       	std	Y+1, r24	; 0x01
    166a:	80 91 66 1b 	lds	r24, 0x1B66	; 0x801b66 <settings+0x3>
    166e:	90 91 67 1b 	lds	r25, 0x1B67	; 0x801b67 <settings+0x4>
    1672:	80 3d       	cpi	r24, 0xD0	; 208
    1674:	91 05       	cpc	r25, r1
    1676:	31 f1       	breq	.+76     	; 0x16c4 <sIMU_begin+0x1f0>
    1678:	48 f4       	brcc	.+18     	; 0x168c <sIMU_begin+0x1b8>
    167a:	8a 31       	cpi	r24, 0x1A	; 26
    167c:	91 05       	cpc	r25, r1
    167e:	b1 f0       	breq	.+44     	; 0x16ac <sIMU_begin+0x1d8>
    1680:	84 33       	cpi	r24, 0x34	; 52
    1682:	91 05       	cpc	r25, r1
    1684:	b9 f0       	breq	.+46     	; 0x16b4 <sIMU_begin+0x1e0>
    1686:	0d 97       	sbiw	r24, 0x0d	; 13
    1688:	c9 f4       	brne	.+50     	; 0x16bc <sIMU_begin+0x1e8>
    168a:	0c c0       	rjmp	.+24     	; 0x16a4 <sIMU_begin+0x1d0>
    168c:	81 34       	cpi	r24, 0x41	; 65
    168e:	23 e0       	ldi	r18, 0x03	; 3
    1690:	92 07       	cpc	r25, r18
    1692:	01 f1       	breq	.+64     	; 0x16d4 <sIMU_begin+0x200>
    1694:	8c 37       	cpi	r24, 0x7C	; 124
    1696:	26 e0       	ldi	r18, 0x06	; 6
    1698:	92 07       	cpc	r25, r18
    169a:	01 f1       	breq	.+64     	; 0x16dc <sIMU_begin+0x208>
    169c:	80 3a       	cpi	r24, 0xA0	; 160
    169e:	91 40       	sbci	r25, 0x01	; 1
    16a0:	69 f4       	brne	.+26     	; 0x16bc <sIMU_begin+0x1e8>
    16a2:	14 c0       	rjmp	.+40     	; 0x16cc <sIMU_begin+0x1f8>
    16a4:	89 81       	ldd	r24, Y+1	; 0x01
    16a6:	80 61       	ori	r24, 0x10	; 16
    16a8:	89 83       	std	Y+1, r24	; 0x01
    16aa:	1b c0       	rjmp	.+54     	; 0x16e2 <sIMU_begin+0x20e>
    16ac:	89 81       	ldd	r24, Y+1	; 0x01
    16ae:	80 62       	ori	r24, 0x20	; 32
    16b0:	89 83       	std	Y+1, r24	; 0x01
    16b2:	17 c0       	rjmp	.+46     	; 0x16e2 <sIMU_begin+0x20e>
    16b4:	89 81       	ldd	r24, Y+1	; 0x01
    16b6:	80 63       	ori	r24, 0x30	; 48
    16b8:	89 83       	std	Y+1, r24	; 0x01
    16ba:	13 c0       	rjmp	.+38     	; 0x16e2 <sIMU_begin+0x20e>
    16bc:	89 81       	ldd	r24, Y+1	; 0x01
    16be:	80 64       	ori	r24, 0x40	; 64
    16c0:	89 83       	std	Y+1, r24	; 0x01
    16c2:	0f c0       	rjmp	.+30     	; 0x16e2 <sIMU_begin+0x20e>
    16c4:	89 81       	ldd	r24, Y+1	; 0x01
    16c6:	80 65       	ori	r24, 0x50	; 80
    16c8:	89 83       	std	Y+1, r24	; 0x01
    16ca:	0b c0       	rjmp	.+22     	; 0x16e2 <sIMU_begin+0x20e>
    16cc:	89 81       	ldd	r24, Y+1	; 0x01
    16ce:	80 66       	ori	r24, 0x60	; 96
    16d0:	89 83       	std	Y+1, r24	; 0x01
    16d2:	07 c0       	rjmp	.+14     	; 0x16e2 <sIMU_begin+0x20e>
    16d4:	89 81       	ldd	r24, Y+1	; 0x01
    16d6:	80 67       	ori	r24, 0x70	; 112
    16d8:	89 83       	std	Y+1, r24	; 0x01
    16da:	03 c0       	rjmp	.+6      	; 0x16e2 <sIMU_begin+0x20e>
    16dc:	89 81       	ldd	r24, Y+1	; 0x01
    16de:	80 68       	ori	r24, 0x80	; 128
    16e0:	89 83       	std	Y+1, r24	; 0x01
    16e2:	69 81       	ldd	r22, Y+1	; 0x01
    16e4:	81 e1       	ldi	r24, 0x11	; 17
    16e6:	ea de       	rcall	.-556    	; 0x14bc <sIMU_writeRegister>
    16e8:	6f e0       	ldi	r22, 0x0F	; 15
    16ea:	ce 01       	movw	r24, r28
    16ec:	02 96       	adiw	r24, 0x02	; 2
    16ee:	5e de       	rcall	.-836    	; 0x13ac <sIMU_readRegister>
    16f0:	81 2f       	mov	r24, r17
    16f2:	0f 90       	pop	r0
    16f4:	0f 90       	pop	r0
    16f6:	df 91       	pop	r29
    16f8:	cf 91       	pop	r28
    16fa:	1f 91       	pop	r17
    16fc:	08 95       	ret

000016fe <i16IMU_readRawGyroZ>:
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
    1702:	1f 92       	push	r1
    1704:	1f 92       	push	r1
    1706:	cd b7       	in	r28, 0x3d	; 61
    1708:	de b7       	in	r29, 0x3e	; 62
    170a:	66 e2       	ldi	r22, 0x26	; 38
    170c:	ce 01       	movw	r24, r28
    170e:	01 96       	adiw	r24, 0x01	; 1
    1710:	b8 de       	rcall	.-656    	; 0x1482 <sIMU_readRegisterInt16>
    1712:	88 23       	and	r24, r24
    1714:	a9 f0       	breq	.+42     	; 0x1740 <i16IMU_readRawGyroZ+0x42>
    1716:	85 30       	cpi	r24, 0x05	; 5
    1718:	51 f4       	brne	.+20     	; 0x172e <i16IMU_readRawGyroZ+0x30>
    171a:	80 91 7d 1b 	lds	r24, 0x1B7D	; 0x801b7d <allOnesCounter>
    171e:	90 91 7e 1b 	lds	r25, 0x1B7E	; 0x801b7e <allOnesCounter+0x1>
    1722:	01 96       	adiw	r24, 0x01	; 1
    1724:	90 93 7e 1b 	sts	0x1B7E, r25	; 0x801b7e <allOnesCounter+0x1>
    1728:	80 93 7d 1b 	sts	0x1B7D, r24	; 0x801b7d <allOnesCounter>
    172c:	09 c0       	rjmp	.+18     	; 0x1740 <i16IMU_readRawGyroZ+0x42>
    172e:	80 91 7f 1b 	lds	r24, 0x1B7F	; 0x801b7f <nonSuccessCounter>
    1732:	90 91 80 1b 	lds	r25, 0x1B80	; 0x801b80 <nonSuccessCounter+0x1>
    1736:	01 96       	adiw	r24, 0x01	; 1
    1738:	90 93 80 1b 	sts	0x1B80, r25	; 0x801b80 <nonSuccessCounter+0x1>
    173c:	80 93 7f 1b 	sts	0x1B7F, r24	; 0x801b7f <nonSuccessCounter>
    1740:	89 81       	ldd	r24, Y+1	; 0x01
    1742:	9a 81       	ldd	r25, Y+2	; 0x02
    1744:	0f 90       	pop	r0
    1746:	0f 90       	pop	r0
    1748:	df 91       	pop	r29
    174a:	cf 91       	pop	r28
    174c:	08 95       	ret

0000174e <fIMU_calcGyro>:
    174e:	cf 92       	push	r12
    1750:	df 92       	push	r13
    1752:	ef 92       	push	r14
    1754:	ff 92       	push	r15
    1756:	cf 93       	push	r28
    1758:	fc 01       	movw	r30, r24
    175a:	40 91 64 1b 	lds	r20, 0x1B64	; 0x801b64 <settings+0x1>
    175e:	50 91 65 1b 	lds	r21, 0x1B65	; 0x801b65 <settings+0x2>
    1762:	45 3f       	cpi	r20, 0xF5	; 245
    1764:	51 05       	cpc	r21, r1
    1766:	b1 f0       	breq	.+44     	; 0x1794 <fIMU_calcGyro+0x46>
    1768:	9a 01       	movw	r18, r20
    176a:	a5 e2       	ldi	r26, 0x25	; 37
    176c:	b6 e0       	ldi	r27, 0x06	; 6
    176e:	0e 94 0a 3b 	call	0x7614	; 0x7614 <__umulhisi3>
    1772:	48 1b       	sub	r20, r24
    1774:	59 0b       	sbc	r21, r25
    1776:	56 95       	lsr	r21
    1778:	47 95       	ror	r20
    177a:	84 0f       	add	r24, r20
    177c:	95 1f       	adc	r25, r21
    177e:	00 24       	eor	r0, r0
    1780:	88 0f       	add	r24, r24
    1782:	99 1f       	adc	r25, r25
    1784:	00 1c       	adc	r0, r0
    1786:	88 0f       	add	r24, r24
    1788:	99 1f       	adc	r25, r25
    178a:	00 1c       	adc	r0, r0
    178c:	89 2f       	mov	r24, r25
    178e:	90 2d       	mov	r25, r0
    1790:	c8 2f       	mov	r28, r24
    1792:	01 c0       	rjmp	.+2      	; 0x1796 <fIMU_calcGyro+0x48>
    1794:	c2 e0       	ldi	r28, 0x02	; 2
    1796:	bf 01       	movw	r22, r30
    1798:	ff 0f       	add	r31, r31
    179a:	88 0b       	sbc	r24, r24
    179c:	99 0b       	sbc	r25, r25
    179e:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    17a2:	20 e0       	ldi	r18, 0x00	; 0
    17a4:	30 e0       	ldi	r19, 0x00	; 0
    17a6:	4c e8       	ldi	r20, 0x8C	; 140
    17a8:	50 e4       	ldi	r21, 0x40	; 64
    17aa:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    17ae:	6b 01       	movw	r12, r22
    17b0:	7c 01       	movw	r14, r24
    17b2:	6c 2f       	mov	r22, r28
    17b4:	70 e0       	ldi	r23, 0x00	; 0
    17b6:	80 e0       	ldi	r24, 0x00	; 0
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    17be:	9b 01       	movw	r18, r22
    17c0:	ac 01       	movw	r20, r24
    17c2:	c7 01       	movw	r24, r14
    17c4:	b6 01       	movw	r22, r12
    17c6:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    17ca:	20 e0       	ldi	r18, 0x00	; 0
    17cc:	30 e0       	ldi	r19, 0x00	; 0
    17ce:	4a e7       	ldi	r20, 0x7A	; 122
    17d0:	54 e4       	ldi	r21, 0x44	; 68
    17d2:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    17d6:	cf 91       	pop	r28
    17d8:	ff 90       	pop	r15
    17da:	ef 90       	pop	r14
    17dc:	df 90       	pop	r13
    17de:	cf 90       	pop	r12
    17e0:	08 95       	ret

000017e2 <fIMU_readFloatGyroZ>:
    }
    
    return output;
}
float fIMU_readFloatGyroZ(){
    float output = fIMU_calcGyro(i16IMU_readRawGyroZ());
    17e2:	8d df       	rcall	.-230    	; 0x16fe <i16IMU_readRawGyroZ>
    17e4:	b4 cf       	rjmp	.-152    	; 0x174e <fIMU_calcGyro>
    
    return output;
}
    17e6:	08 95       	ret

000017e8 <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    17e8:	ea e0       	ldi	r30, 0x0A	; 10
    17ea:	f1 e0       	ldi	r31, 0x01	; 1
    17ec:	80 81       	ld	r24, Z
    17ee:	87 60       	ori	r24, 0x07	; 7
    17f0:	80 83       	st	Z, r24
    17f2:	08 95       	ret

000017f4 <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
    17f4:	82 30       	cpi	r24, 0x02	; 2
    17f6:	91 05       	cpc	r25, r1
    17f8:	31 f4       	brne	.+12     	; 0x1806 <vLED_singleHigh+0x12>
    17fa:	eb e0       	ldi	r30, 0x0B	; 11
    17fc:	f1 e0       	ldi	r31, 0x01	; 1
    17fe:	80 81       	ld	r24, Z
    1800:	84 60       	ori	r24, 0x04	; 4
    1802:	80 83       	st	Z, r24
    1804:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
    1806:	81 30       	cpi	r24, 0x01	; 1
    1808:	91 05       	cpc	r25, r1
    180a:	31 f4       	brne	.+12     	; 0x1818 <vLED_singleHigh+0x24>
    180c:	eb e0       	ldi	r30, 0x0B	; 11
    180e:	f1 e0       	ldi	r31, 0x01	; 1
    1810:	80 81       	ld	r24, Z
    1812:	82 60       	ori	r24, 0x02	; 2
    1814:	80 83       	st	Z, r24
    1816:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
    1818:	89 2b       	or	r24, r25
    181a:	29 f4       	brne	.+10     	; 0x1826 <vLED_singleHigh+0x32>
    181c:	eb e0       	ldi	r30, 0x0B	; 11
    181e:	f1 e0       	ldi	r31, 0x01	; 1
    1820:	80 81       	ld	r24, Z
    1822:	81 60       	ori	r24, 0x01	; 1
    1824:	80 83       	st	Z, r24
    1826:	08 95       	ret

00001828 <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
    1828:	82 30       	cpi	r24, 0x02	; 2
    182a:	91 05       	cpc	r25, r1
    182c:	31 f4       	brne	.+12     	; 0x183a <vLED_singleLow+0x12>
    182e:	eb e0       	ldi	r30, 0x0B	; 11
    1830:	f1 e0       	ldi	r31, 0x01	; 1
    1832:	80 81       	ld	r24, Z
    1834:	8b 7f       	andi	r24, 0xFB	; 251
    1836:	80 83       	st	Z, r24
    1838:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
    183a:	81 30       	cpi	r24, 0x01	; 1
    183c:	91 05       	cpc	r25, r1
    183e:	31 f4       	brne	.+12     	; 0x184c <vLED_singleLow+0x24>
    1840:	eb e0       	ldi	r30, 0x0B	; 11
    1842:	f1 e0       	ldi	r31, 0x01	; 1
    1844:	80 81       	ld	r24, Z
    1846:	8d 7f       	andi	r24, 0xFD	; 253
    1848:	80 83       	st	Z, r24
    184a:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
    184c:	89 2b       	or	r24, r25
    184e:	29 f4       	brne	.+10     	; 0x185a <vLED_singleLow+0x32>
    1850:	eb e0       	ldi	r30, 0x0B	; 11
    1852:	f1 e0       	ldi	r31, 0x01	; 1
    1854:	80 81       	ld	r24, Z
    1856:	8e 7f       	andi	r24, 0xFE	; 254
    1858:	80 83       	st	Z, r24
    185a:	08 95       	ret

0000185c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    185c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    185e:	03 96       	adiw	r24, 0x03	; 3
    1860:	92 83       	std	Z+2, r25	; 0x02
    1862:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1864:	2f ef       	ldi	r18, 0xFF	; 255
    1866:	3f ef       	ldi	r19, 0xFF	; 255
    1868:	34 83       	std	Z+4, r19	; 0x04
    186a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    186c:	96 83       	std	Z+6, r25	; 0x06
    186e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1870:	90 87       	std	Z+8, r25	; 0x08
    1872:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1874:	10 82       	st	Z, r1
    1876:	08 95       	ret

00001878 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1878:	fc 01       	movw	r30, r24
    187a:	11 86       	std	Z+9, r1	; 0x09
    187c:	10 86       	std	Z+8, r1	; 0x08
    187e:	08 95       	ret

00001880 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1880:	cf 93       	push	r28
    1882:	df 93       	push	r29
    1884:	9c 01       	movw	r18, r24
    1886:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1888:	dc 01       	movw	r26, r24
    188a:	11 96       	adiw	r26, 0x01	; 1
    188c:	cd 91       	ld	r28, X+
    188e:	dc 91       	ld	r29, X
    1890:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1892:	d3 83       	std	Z+3, r29	; 0x03
    1894:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1896:	8c 81       	ldd	r24, Y+4	; 0x04
    1898:	9d 81       	ldd	r25, Y+5	; 0x05
    189a:	95 83       	std	Z+5, r25	; 0x05
    189c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    189e:	8c 81       	ldd	r24, Y+4	; 0x04
    18a0:	9d 81       	ldd	r25, Y+5	; 0x05
    18a2:	dc 01       	movw	r26, r24
    18a4:	13 96       	adiw	r26, 0x03	; 3
    18a6:	7c 93       	st	X, r23
    18a8:	6e 93       	st	-X, r22
    18aa:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    18ac:	7d 83       	std	Y+5, r23	; 0x05
    18ae:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    18b0:	31 87       	std	Z+9, r19	; 0x09
    18b2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    18b4:	f9 01       	movw	r30, r18
    18b6:	80 81       	ld	r24, Z
    18b8:	8f 5f       	subi	r24, 0xFF	; 255
    18ba:	80 83       	st	Z, r24
}
    18bc:	df 91       	pop	r29
    18be:	cf 91       	pop	r28
    18c0:	08 95       	ret

000018c2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    18c2:	cf 93       	push	r28
    18c4:	df 93       	push	r29
    18c6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    18c8:	48 81       	ld	r20, Y
    18ca:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    18cc:	4f 3f       	cpi	r20, 0xFF	; 255
    18ce:	2f ef       	ldi	r18, 0xFF	; 255
    18d0:	52 07       	cpc	r21, r18
    18d2:	21 f4       	brne	.+8      	; 0x18dc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    18d4:	fc 01       	movw	r30, r24
    18d6:	a7 81       	ldd	r26, Z+7	; 0x07
    18d8:	b0 85       	ldd	r27, Z+8	; 0x08
    18da:	0d c0       	rjmp	.+26     	; 0x18f6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18dc:	dc 01       	movw	r26, r24
    18de:	13 96       	adiw	r26, 0x03	; 3
    18e0:	01 c0       	rjmp	.+2      	; 0x18e4 <vListInsert+0x22>
    18e2:	df 01       	movw	r26, r30
    18e4:	12 96       	adiw	r26, 0x02	; 2
    18e6:	ed 91       	ld	r30, X+
    18e8:	fc 91       	ld	r31, X
    18ea:	13 97       	sbiw	r26, 0x03	; 3
    18ec:	20 81       	ld	r18, Z
    18ee:	31 81       	ldd	r19, Z+1	; 0x01
    18f0:	42 17       	cp	r20, r18
    18f2:	53 07       	cpc	r21, r19
    18f4:	b0 f7       	brcc	.-20     	; 0x18e2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    18f6:	12 96       	adiw	r26, 0x02	; 2
    18f8:	ed 91       	ld	r30, X+
    18fa:	fc 91       	ld	r31, X
    18fc:	13 97       	sbiw	r26, 0x03	; 3
    18fe:	fb 83       	std	Y+3, r31	; 0x03
    1900:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1902:	d5 83       	std	Z+5, r29	; 0x05
    1904:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1906:	bd 83       	std	Y+5, r27	; 0x05
    1908:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    190a:	13 96       	adiw	r26, 0x03	; 3
    190c:	dc 93       	st	X, r29
    190e:	ce 93       	st	-X, r28
    1910:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1912:	99 87       	std	Y+9, r25	; 0x09
    1914:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1916:	fc 01       	movw	r30, r24
    1918:	20 81       	ld	r18, Z
    191a:	2f 5f       	subi	r18, 0xFF	; 255
    191c:	20 83       	st	Z, r18
}
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	08 95       	ret

00001924 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    192a:	a0 85       	ldd	r26, Z+8	; 0x08
    192c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    192e:	c2 81       	ldd	r28, Z+2	; 0x02
    1930:	d3 81       	ldd	r29, Z+3	; 0x03
    1932:	84 81       	ldd	r24, Z+4	; 0x04
    1934:	95 81       	ldd	r25, Z+5	; 0x05
    1936:	9d 83       	std	Y+5, r25	; 0x05
    1938:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    193a:	c4 81       	ldd	r28, Z+4	; 0x04
    193c:	d5 81       	ldd	r29, Z+5	; 0x05
    193e:	82 81       	ldd	r24, Z+2	; 0x02
    1940:	93 81       	ldd	r25, Z+3	; 0x03
    1942:	9b 83       	std	Y+3, r25	; 0x03
    1944:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1946:	11 96       	adiw	r26, 0x01	; 1
    1948:	8d 91       	ld	r24, X+
    194a:	9c 91       	ld	r25, X
    194c:	12 97       	sbiw	r26, 0x02	; 2
    194e:	e8 17       	cp	r30, r24
    1950:	f9 07       	cpc	r31, r25
    1952:	31 f4       	brne	.+12     	; 0x1960 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1954:	84 81       	ldd	r24, Z+4	; 0x04
    1956:	95 81       	ldd	r25, Z+5	; 0x05
    1958:	12 96       	adiw	r26, 0x02	; 2
    195a:	9c 93       	st	X, r25
    195c:	8e 93       	st	-X, r24
    195e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1960:	11 86       	std	Z+9, r1	; 0x09
    1962:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1964:	8c 91       	ld	r24, X
    1966:	81 50       	subi	r24, 0x01	; 1
    1968:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    196a:	df 91       	pop	r29
    196c:	cf 91       	pop	r28
    196e:	08 95       	ret

00001970 <vMainCommunicationTask>:
    #define toc PORTH &= ~(1<<PINH5)
#endif
void vMainPoseControllerTask( void *pvParameters );
/*  Communication task */
/*  Communication task */
void vMainCommunicationTask( void *pvParameters ){
    1970:	cf 93       	push	r28
    1972:	df 93       	push	r29
    1974:	cd b7       	in	r28, 0x3d	; 61
    1976:	de b7       	in	r29, 0x3e	; 62
    1978:	28 97       	sbiw	r28, 0x08	; 8
    197a:	0f b6       	in	r0, 0x3f	; 63
    197c:	f8 94       	cli
    197e:	de bf       	out	0x3e, r29	; 62
    1980:	0f be       	out	0x3f, r0	; 63
    1982:	cd bf       	out	0x3d, r28	; 61
	// Setup for the communication task
	
	struct sCartesian Setpoint = {0,0}; // Struct for setpoints from server
    1984:	19 82       	std	Y+1, r1	; 0x01
    1986:	1a 82       	std	Y+2, r1	; 0x02
    1988:	1b 82       	std	Y+3, r1	; 0x03
    198a:	1c 82       	std	Y+4, r1	; 0x04
    198c:	1d 82       	std	Y+5, r1	; 0x05
    198e:	1e 82       	std	Y+6, r1	; 0x06
    1990:	1f 82       	std	Y+7, r1	; 0x07
    1992:	18 86       	std	Y+8, r1	; 0x08

	message_t command_in; // Buffer for recieved messages

	server_communication_init();
    1994:	0e 94 3a 24 	call	0x4874	; 0x4874 <server_communication_init>
	if(xTaskCreate(vARQTask, "ARQ", 300, NULL, 3, NULL) != pdPASS) {
    1998:	a1 2c       	mov	r10, r1
    199a:	b1 2c       	mov	r11, r1
    199c:	c1 2c       	mov	r12, r1
    199e:	d1 2c       	mov	r13, r1
    19a0:	e1 2c       	mov	r14, r1
    19a2:	f1 2c       	mov	r15, r1
    19a4:	03 e0       	ldi	r16, 0x03	; 3
    19a6:	20 e0       	ldi	r18, 0x00	; 0
    19a8:	30 e0       	ldi	r19, 0x00	; 0
    19aa:	4c e2       	ldi	r20, 0x2C	; 44
    19ac:	51 e0       	ldi	r21, 0x01	; 1
    19ae:	6b e0       	ldi	r22, 0x0B	; 11
    19b0:	76 e0       	ldi	r23, 0x06	; 6
    19b2:	85 e2       	ldi	r24, 0x25	; 37
    19b4:	95 e0       	ldi	r25, 0x05	; 5
    19b6:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <xTaskGenericCreate>
		//vLED_singleHigh(ledRED);
	}
	uint8_t success = 0;
	
	while(!success) {
		success = server_connect();
    19ba:	0e 94 43 24 	call	0x4886	; 0x4886 <server_connect>
    19be:	18 2f       	mov	r17, r24
		vTaskDelay(1000 / portTICK_PERIOD_MS);
    19c0:	88 ee       	ldi	r24, 0xE8	; 232
    19c2:	93 e0       	ldi	r25, 0x03	; 3
    19c4:	0e 94 86 29 	call	0x530c	; 0x530c <vTaskDelay>
	if(xTaskCreate(vARQTask, "ARQ", 300, NULL, 3, NULL) != pdPASS) {
		//vLED_singleHigh(ledRED);
	}
	uint8_t success = 0;
	
	while(!success) {
    19c8:	11 23       	and	r17, r17
    19ca:	b9 f3       	breq	.-18     	; 0x19ba <vMainCommunicationTask+0x4a>
		success = server_connect();
		vTaskDelay(1000 / portTICK_PERIOD_MS);
		//vLED_toggle(ledGREEN);
	}
	
	send_handshake();
    19cc:	0e 94 4f 24 	call	0x489e	; 0x489e <send_handshake>
		
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
			taskENTER_CRITICAL();
			command_in = message_in;
    19d0:	0f 2e       	mov	r0, r31
    19d2:	fd e8       	ldi	r31, 0x8D	; 141
    19d4:	ef 2e       	mov	r14, r31
    19d6:	fb e1       	ldi	r31, 0x1B	; 27
    19d8:	ff 2e       	mov	r15, r31
    19da:	f0 2d       	mov	r31, r0
			
		
			switch(command_in.type){
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
					gHandshook = TRUE; // Set start flag true
    19dc:	01 e0       	ldi	r16, 0x01	; 1
	
	send_handshake();
	
	while(1){
		
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
    19de:	20 e0       	ldi	r18, 0x00	; 0
    19e0:	4f ef       	ldi	r20, 0xFF	; 255
    19e2:	5f ef       	ldi	r21, 0xFF	; 255
    19e4:	60 e0       	ldi	r22, 0x00	; 0
    19e6:	70 e0       	ldi	r23, 0x00	; 0
    19e8:	80 91 89 1b 	lds	r24, 0x1B89	; 0x801b89 <xCommandReadyBSem>
    19ec:	90 91 8a 1b 	lds	r25, 0x1B8A	; 0x801b8a <xCommandReadyBSem+0x1>
    19f0:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
    19f4:	81 30       	cpi	r24, 0x01	; 1
    19f6:	09 f0       	breq	.+2      	; 0x19fa <vMainCommunicationTask+0x8a>
    19f8:	76 c0       	rjmp	.+236    	; 0x1ae6 <vMainCommunicationTask+0x176>
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
    19fa:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <vTaskSuspendAll>
			taskENTER_CRITICAL();
    19fe:	0f b6       	in	r0, 0x3f	; 63
    1a00:	f8 94       	cli
    1a02:	0f 92       	push	r0
			command_in = message_in;
    1a04:	f7 01       	movw	r30, r14
    1a06:	10 81       	ld	r17, Z
    1a08:	a1 80       	ldd	r10, Z+1	; 0x01
    1a0a:	b2 80       	ldd	r11, Z+2	; 0x02
    1a0c:	c3 80       	ldd	r12, Z+3	; 0x03
    1a0e:	d4 80       	ldd	r13, Z+4	; 0x04
			taskEXIT_CRITICAL();
    1a10:	0f 90       	pop	r0
    1a12:	0f be       	out	0x3f, r0	; 63
			xTaskResumeAll ();      // Enable context switching
    1a14:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
			
		
			switch(command_in.type){
    1a18:	15 30       	cpi	r17, 0x05	; 5
    1a1a:	09 f4       	brne	.+2      	; 0x1a1e <vMainCommunicationTask+0xae>
    1a1c:	55 c0       	rjmp	.+170    	; 0x1ac8 <vMainCommunicationTask+0x158>
    1a1e:	28 f4       	brcc	.+10     	; 0x1a2a <vMainCommunicationTask+0xba>
    1a20:	12 30       	cpi	r17, 0x02	; 2
    1a22:	a9 f0       	breq	.+42     	; 0x1a4e <vMainCommunicationTask+0xde>
    1a24:	14 30       	cpi	r17, 0x04	; 4
    1a26:	a1 f1       	breq	.+104    	; 0x1a90 <vMainCommunicationTask+0x120>
    1a28:	5e c0       	rjmp	.+188    	; 0x1ae6 <vMainCommunicationTask+0x176>
    1a2a:	17 30       	cpi	r17, 0x07	; 7
    1a2c:	09 f4       	brne	.+2      	; 0x1a30 <vMainCommunicationTask+0xc0>
    1a2e:	54 c0       	rjmp	.+168    	; 0x1ad8 <vMainCommunicationTask+0x168>
    1a30:	18 f0       	brcs	.+6      	; 0x1a38 <vMainCommunicationTask+0xc8>
    1a32:	18 30       	cpi	r17, 0x08	; 8
    1a34:	49 f0       	breq	.+18     	; 0x1a48 <vMainCommunicationTask+0xd8>
    1a36:	57 c0       	rjmp	.+174    	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
    1a38:	0f b6       	in	r0, 0x3f	; 63
    1a3a:	f8 94       	cli
    1a3c:	0f 92       	push	r0
					gHandshook = TRUE; // Set start flag true
    1a3e:	00 93 1c 1a 	sts	0x1A1C, r16	; 0x801a1c <gHandshook>
					taskEXIT_CRITICAL();
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63

					break;
    1a46:	4f c0       	rjmp	.+158    	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_PING:
					send_ping_response();
    1a48:	0e 94 57 25 	call	0x4aae	; 0x4aae <send_ping_response>
					break;
    1a4c:	4c c0       	rjmp	.+152    	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_ORDER:
					Setpoint.x = command_in.message.order.x;
    1a4e:	b5 01       	movw	r22, r10
    1a50:	bb 0c       	add	r11, r11
    1a52:	88 0b       	sbc	r24, r24
    1a54:	99 0b       	sbc	r25, r25
    1a56:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    1a5a:	69 83       	std	Y+1, r22	; 0x01
    1a5c:	7a 83       	std	Y+2, r23	; 0x02
    1a5e:	8b 83       	std	Y+3, r24	; 0x03
    1a60:	9c 83       	std	Y+4, r25	; 0x04
					Setpoint.y = command_in.message.order.y;
    1a62:	b6 01       	movw	r22, r12
    1a64:	dd 0c       	add	r13, r13
    1a66:	88 0b       	sbc	r24, r24
    1a68:	99 0b       	sbc	r25, r25
    1a6a:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    1a6e:	6d 83       	std	Y+5, r22	; 0x05
    1a70:	7e 83       	std	Y+6, r23	; 0x06
    1a72:	8f 83       	std	Y+7, r24	; 0x07
    1a74:	98 87       	std	Y+8, r25	; 0x08
					/* Relay new coordinates to position controller */
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1a76:	20 e0       	ldi	r18, 0x00	; 0
    1a78:	44 e6       	ldi	r20, 0x64	; 100
    1a7a:	50 e0       	ldi	r21, 0x00	; 0
    1a7c:	be 01       	movw	r22, r28
    1a7e:	6f 5f       	subi	r22, 0xFF	; 255
    1a80:	7f 4f       	sbci	r23, 0xFF	; 255
    1a82:	80 91 23 1a 	lds	r24, 0x1A23	; 0x801a23 <poseControllerQ>
    1a86:	90 91 24 1a 	lds	r25, 0x1A24	; 0x801a24 <poseControllerQ+0x1>
    1a8a:	0e 94 1c 1f 	call	0x3e38	; 0x3e38 <xQueueGenericSend>
					break;
    1a8e:	2b c0       	rjmp	.+86     	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_PAUSE:
					// Stop sending update messages
					taskENTER_CRITICAL();
    1a90:	0f b6       	in	r0, 0x3f	; 63
    1a92:	f8 94       	cli
    1a94:	0f 92       	push	r0
					gPaused = TRUE;
    1a96:	00 93 1b 1a 	sts	0x1A1B, r16	; 0x801a1b <gPaused>
					taskEXIT_CRITICAL();
    1a9a:	0f 90       	pop	r0
    1a9c:	0f be       	out	0x3f, r0	; 63
					// Stop controller
					Setpoint.x = 0;
    1a9e:	19 82       	std	Y+1, r1	; 0x01
    1aa0:	1a 82       	std	Y+2, r1	; 0x02
    1aa2:	1b 82       	std	Y+3, r1	; 0x03
    1aa4:	1c 82       	std	Y+4, r1	; 0x04
					Setpoint.y = 0;
    1aa6:	1d 82       	std	Y+5, r1	; 0x05
    1aa8:	1e 82       	std	Y+6, r1	; 0x06
    1aaa:	1f 82       	std	Y+7, r1	; 0x07
    1aac:	18 86       	std	Y+8, r1	; 0x08
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	44 e6       	ldi	r20, 0x64	; 100
    1ab2:	50 e0       	ldi	r21, 0x00	; 0
    1ab4:	be 01       	movw	r22, r28
    1ab6:	6f 5f       	subi	r22, 0xFF	; 255
    1ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    1aba:	80 91 23 1a 	lds	r24, 0x1A23	; 0x801a23 <poseControllerQ>
    1abe:	90 91 24 1a 	lds	r25, 0x1A24	; 0x801a24 <poseControllerQ+0x1>
    1ac2:	0e 94 1c 1f 	call	0x3e38	; 0x3e38 <xQueueGenericSend>
					break;
    1ac6:	0f c0       	rjmp	.+30     	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_UNPAUSE:
					taskENTER_CRITICAL();
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	0f 92       	push	r0
					gPaused = FALSE;
    1ace:	10 92 1b 1a 	sts	0x1A1B, r1	; 0x801a1b <gPaused>
					taskEXIT_CRITICAL();
    1ad2:	0f 90       	pop	r0
    1ad4:	0f be       	out	0x3f, r0	; 63
					break;
    1ad6:	07 c0       	rjmp	.+14     	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_FINISH:
					taskENTER_CRITICAL();
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
					gHandshook = FALSE;
    1ade:	10 92 1c 1a 	sts	0x1A1C, r1	; 0x801a1c <gHandshook>
					taskEXIT_CRITICAL();
    1ae2:	0f 90       	pop	r0
    1ae4:	0f be       	out	0x3f, r0	; 63
					break;
			}
			
			// Command is processed
		} // if (xCommandReady) end
		vLED_singleLow(ledYELLOW);
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	9e de       	rcall	.-708    	; 0x1828 <vLED_singleLow>
		//_delay_ms(100);
	}// While(1) end
    1aec:	78 cf       	rjmp	.-272    	; 0x19de <vMainCommunicationTask+0x6e>

00001aee <vMainSensorTowerTask>:
}// vMainComtask end

/*  Sensor tower task */
void vMainSensorTowerTask( void *pvParameters){
    1aee:	cf 93       	push	r28
    1af0:	df 93       	push	r29
    1af2:	cd b7       	in	r28, 0x3d	; 61
    1af4:	de b7       	in	r29, 0x3e	; 62
    1af6:	63 97       	sbiw	r28, 0x13	; 19
    1af8:	0f b6       	in	r0, 0x3f	; 63
    1afa:	f8 94       	cli
    1afc:	de bf       	out	0x3e, r29	; 62
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	cd bf       	out	0x3d, r28	; 61
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    uint8_t robotMovement = moveStop;
    1b02:	19 82       	std	Y+1, r1	; 0x01
    
    uint8_t idleCounter = 0;
    1b04:	10 e0       	ldi	r17, 0x00	; 0
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    1b06:	21 e0       	ldi	r18, 0x01	; 1
    1b08:	28 8b       	std	Y+16, r18	; 0x10
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    1b0a:	f1 2c       	mov	r15, r1
        
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    1b0c:	68 94       	set
    1b0e:	22 24       	eor	r2, r2
    1b10:	22 f8       	bld	r2, 2
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1b12:	68 94       	set
    1b14:	33 24       	eor	r3, r3
    1b16:	32 f8       	bld	r3, 2
    1b18:	0e c0       	rjmp	.+28     	; 0x1b36 <vMainSensorTowerTask+0x48>
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
                rotationDirection = moveClockwise;
    1b1a:	0f 2e       	mov	r0, r31
    1b1c:	f3 e0       	ldi	r31, 0x03	; 3
    1b1e:	2f 2e       	mov	r2, r31
    1b20:	f0 2d       	mov	r31, r0
    1b22:	09 c0       	rjmp	.+18     	; 0x1b36 <vMainSensorTowerTask+0x48>
    1b24:	0f 2e       	mov	r0, r31
    1b26:	f3 e0       	ldi	r31, 0x03	; 3
    1b28:	2f 2e       	mov	r2, r31
    1b2a:	f0 2d       	mov	r31, r0
    1b2c:	04 c0       	rjmp	.+8      	; 0x1b36 <vMainSensorTowerTask+0x48>
    1b2e:	0f 2e       	mov	r0, r31
    1b30:	f3 e0       	ldi	r31, 0x03	; 3
    1b32:	2f 2e       	mov	r2, r31
    1b34:	f0 2d       	mov	r31, r0
    TickType_t xLastWakeTime;
	
	uint8_t incr = 0;
    while(1){

	        if ((gHandshook == TRUE) && (gPaused == FALSE)){
    1b36:	80 91 1c 1a 	lds	r24, 0x1A1C	; 0x801a1c <gHandshook>
    1b3a:	81 30       	cpi	r24, 0x01	; 1
    1b3c:	09 f0       	breq	.+2      	; 0x1b40 <vMainSensorTowerTask+0x52>
    1b3e:	20 c1       	rjmp	.+576    	; 0x1d80 <vMainSensorTowerTask+0x292>
    1b40:	80 91 1b 1a 	lds	r24, 0x1A1B	; 0x801a1b <gPaused>
    1b44:	81 11       	cpse	r24, r1
    1b46:	1c c1       	rjmp	.+568    	; 0x1d80 <vMainSensorTowerTask+0x292>
            // xLastWakeTime variable with the current time.
            xLastWakeTime = xTaskGetTickCount(); 
    1b48:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <xTaskGetTickCount>
    1b4c:	9b 83       	std	Y+3, r25	; 0x03
    1b4e:	8a 83       	std	Y+2, r24	; 0x02
            // Set scanning resolution depending on which movement the robot is executing.
            if (xQueueReceive(scanStatusQ, &robotMovement,150 / portTICK_PERIOD_MS) == pdTRUE){
    1b50:	20 e0       	ldi	r18, 0x00	; 0
    1b52:	46 e9       	ldi	r20, 0x96	; 150
    1b54:	50 e0       	ldi	r21, 0x00	; 0
    1b56:	be 01       	movw	r22, r28
    1b58:	6f 5f       	subi	r22, 0xFF	; 255
    1b5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5c:	80 91 21 1a 	lds	r24, 0x1A21	; 0x801a21 <scanStatusQ>
    1b60:	90 91 22 1a 	lds	r25, 0x1A22	; 0x801a22 <scanStatusQ+0x1>
    1b64:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
    1b68:	81 30       	cpi	r24, 0x01	; 1
    1b6a:	c9 f4       	brne	.+50     	; 0x1b9e <vMainSensorTowerTask+0xb0>
                // Set servo step length according to movement, 
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
    1b6c:	89 81       	ldd	r24, Y+1	; 0x01
    1b6e:	88 23       	and	r24, r24
    1b70:	19 f0       	breq	.+6      	; 0x1b78 <vMainSensorTowerTask+0x8a>
    1b72:	83 30       	cpi	r24, 0x03	; 3
    1b74:	98 f4       	brcc	.+38     	; 0x1b9c <vMainSensorTowerTask+0xae>
    1b76:	08 c0       	rjmp	.+16     	; 0x1b88 <vMainSensorTowerTask+0x9a>
                {
                    case moveStop:
                        servoStep *= servoResolution;
    1b78:	38 89       	ldd	r19, Y+16	; 0x10
    1b7a:	f3 9e       	mul	r15, r19
    1b7c:	f0 2c       	mov	r15, r0
    1b7e:	11 24       	eor	r1, r1
                        servoResolution = 1;
                        idleCounter = 1;
    1b80:	11 e0       	ldi	r17, 0x01	; 1
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
                {
                    case moveStop:
                        servoStep *= servoResolution;
                        servoResolution = 1;
    1b82:	81 e0       	ldi	r24, 0x01	; 1
    1b84:	88 8b       	std	Y+16, r24	; 0x10
                        idleCounter = 1;
                    break;
    1b86:	0b c0       	rjmp	.+22     	; 0x1b9e <vMainSensorTowerTask+0xb0>
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
                        servoStep /= servoResolution;
    1b88:	9d ec       	ldi	r25, 0xCD	; 205
    1b8a:	f9 9e       	mul	r15, r25
    1b8c:	f1 2c       	mov	r15, r1
    1b8e:	11 24       	eor	r1, r1
    1b90:	f6 94       	lsr	r15
    1b92:	f6 94       	lsr	r15
                        idleCounter = 0;
    1b94:	10 e0       	ldi	r17, 0x00	; 0
                        servoResolution = 1;
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
    1b96:	25 e0       	ldi	r18, 0x05	; 5
    1b98:	28 8b       	std	Y+16, r18	; 0x10
                        servoStep /= servoResolution;
                        idleCounter = 0;
                    break;
    1b9a:	01 c0       	rjmp	.+2      	; 0x1b9e <vMainSensorTowerTask+0xb0>
                    case moveClockwise:
                    case moveCounterClockwise:
                        // Iterations are frozen while rotating, see further down
                        idleCounter = 0;
    1b9c:	10 e0       	ldi	r17, 0x00	; 0
                    default:
                        idleCounter = 0;
                    break;
                }
            }
            vServo_setAngle(servoStep*servoResolution);
    1b9e:	38 89       	ldd	r19, Y+16	; 0x10
    1ba0:	f3 9e       	mul	r15, r19
    1ba2:	80 2d       	mov	r24, r0
    1ba4:	11 24       	eor	r1, r1
    1ba6:	0e 94 7b 25 	call	0x4af6	; 0x4af6 <vServo_setAngle>
            vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_PERIOD_MS); // Wait total of 200 ms for servo to reach set point
    1baa:	68 ec       	ldi	r22, 0xC8	; 200
    1bac:	70 e0       	ldi	r23, 0x00	; 0
    1bae:	ce 01       	movw	r24, r28
    1bb0:	02 96       	adiw	r24, 0x02	; 2
    1bb2:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <vTaskDelayUntil>
            
            uint8_t forwardSensor = ui8DistSens_readCM(distSensFwd);
    1bb6:	80 e0       	ldi	r24, 0x00	; 0
    1bb8:	d8 d9       	rcall	.-3152   	; 0xf6a <ui8DistSens_readCM>
    1bba:	d8 2e       	mov	r13, r24
            uint8_t leftSensor = ui8DistSens_readCM(distSensLeft);
    1bbc:	81 e0       	ldi	r24, 0x01	; 1
    1bbe:	d5 d9       	rcall	.-3158   	; 0xf6a <ui8DistSens_readCM>
    1bc0:	e8 2e       	mov	r14, r24
            uint8_t rearSensor = ui8DistSens_readCM(distSensRear);
    1bc2:	83 e0       	ldi	r24, 0x03	; 3
    1bc4:	d2 d9       	rcall	.-3164   	; 0xf6a <ui8DistSens_readCM>
    1bc6:	c8 2e       	mov	r12, r24
            uint8_t rightSensor = ui8DistSens_readCM(distSensRight);
    1bc8:	82 e0       	ldi	r24, 0x02	; 2
    1bca:	cf d9       	rcall	.-3170   	; 0xf6a <ui8DistSens_readCM>
    1bcc:	89 8b       	std	Y+17, r24	; 0x11
    1bce:	20 e0       	ldi	r18, 0x00	; 0
		
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
    1bd0:	48 e2       	ldi	r20, 0x28	; 40
    1bd2:	50 e0       	ldi	r21, 0x00	; 0
    1bd4:	60 e0       	ldi	r22, 0x00	; 0
    1bd6:	70 e0       	ldi	r23, 0x00	; 0
    1bd8:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    1bdc:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    1be0:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
    1be4:	40 90 17 1a 	lds	r4, 0x1A17	; 0x801a17 <gTheta_hat>
                thetahat = gTheta_hat;
    1be8:	50 90 18 1a 	lds	r5, 0x1A18	; 0x801a18 <gTheta_hat+0x1>
    1bec:	60 90 19 1a 	lds	r6, 0x1A19	; 0x801a19 <gTheta_hat+0x2>
    1bf0:	70 90 1a 1a 	lds	r7, 0x1A1A	; 0x801a1a <gTheta_hat+0x3>
    1bf4:	a0 90 15 1a 	lds	r10, 0x1A15	; 0x801a15 <gX_hat>
                xhat = gX_hat;
    1bf8:	b0 90 16 1a 	lds	r11, 0x1A16	; 0x801a16 <gX_hat+0x1>
    1bfc:	80 91 13 1a 	lds	r24, 0x1A13	; 0x801a13 <gY_hat>
                yhat = gY_hat;
    1c00:	90 91 14 1a 	lds	r25, 0x1A14	; 0x801a14 <gY_hat+0x1>
    1c04:	9d 87       	std	Y+13, r25	; 0x0d
    1c06:	8c 87       	std	Y+12, r24	; 0x0c
    1c08:	60 e0       	ldi	r22, 0x00	; 0
            xSemaphoreGive(xPoseMutex);
    1c0a:	70 e0       	ldi	r23, 0x00	; 0
    1c0c:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    1c10:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    1c14:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
    1c18:	1b 30       	cpi	r17, 0x0B	; 11
            
            // Experimental
            if ((idleCounter > 10) && (robotMovement == moveStop)){
    1c1a:	38 f0       	brcs	.+14     	; 0x1c2a <vMainSensorTowerTask+0x13c>
    1c1c:	89 81       	ldd	r24, Y+1	; 0x01
    1c1e:	81 11       	cpse	r24, r1
    1c20:	04 c0       	rjmp	.+8      	; 0x1c2a <vMainSensorTowerTask+0x13c>
    1c22:	0e 94 f6 24 	call	0x49ec	; 0x49ec <send_idle>
                // If the robot stands idle for 1 second, send 'status:idle' in case the server missed it.
                send_idle();
    1c26:	11 e0       	ldi	r17, 0x01	; 1
                idleCounter = 1;
    1c28:	06 c0       	rjmp	.+12     	; 0x1c36 <vMainSensorTowerTask+0x148>
    1c2a:	11 23       	and	r17, r17
            }
            else if ((idleCounter >= 1) && (robotMovement == moveStop)){
    1c2c:	21 f0       	breq	.+8      	; 0x1c36 <vMainSensorTowerTask+0x148>
    1c2e:	89 81       	ldd	r24, Y+1	; 0x01
    1c30:	81 11       	cpse	r24, r1
    1c32:	01 c0       	rjmp	.+2      	; 0x1c36 <vMainSensorTowerTask+0x148>
    1c34:	1f 5f       	subi	r17, 0xFF	; 255
                idleCounter++;
    1c36:	38 89       	ldd	r19, Y+16	; 0x10
            }             

            // Send updates to server
			
			//[Commented out to decrease messages, ]
            send_update(xhat/10,yhat/10,thetahat*RAD2DEG,servoStep*servoResolution,forwardSensor,leftSensor,rearSensor,rightSensor);
    1c38:	23 2f       	mov	r18, r19
    1c3a:	30 e0       	ldi	r19, 0x00	; 0
    1c3c:	3b 8b       	std	Y+19, r19	; 0x13
    1c3e:	2a 8b       	std	Y+18, r18	; 0x12
    1c40:	f2 9e       	mul	r15, r18
    1c42:	40 01       	movw	r8, r0
    1c44:	f3 9e       	mul	r15, r19
    1c46:	90 0c       	add	r9, r0
    1c48:	11 24       	eor	r1, r1
    1c4a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c4c:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c4e:	6a e0       	ldi	r22, 0x0A	; 10
    1c50:	70 e0       	ldi	r23, 0x00	; 0
    1c52:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <__divmodhi4>
    1c56:	7d 87       	std	Y+13, r23	; 0x0d
    1c58:	6c 87       	std	Y+12, r22	; 0x0c
    1c5a:	c5 01       	movw	r24, r10
    1c5c:	6a e0       	ldi	r22, 0x0A	; 10
    1c5e:	70 e0       	ldi	r23, 0x00	; 0
    1c60:	0e 94 f7 3a 	call	0x75ee	; 0x75ee <__divmodhi4>
    1c64:	7f 87       	std	Y+15, r23	; 0x0f
    1c66:	6e 87       	std	Y+14, r22	; 0x0e
    1c68:	20 e0       	ldi	r18, 0x00	; 0
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	44 e3       	ldi	r20, 0x34	; 52
    1c6e:	53 e4       	ldi	r21, 0x43	; 67
    1c70:	c3 01       	movw	r24, r6
    1c72:	b2 01       	movw	r22, r4
    1c74:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    1c78:	2b ed       	ldi	r18, 0xDB	; 219
    1c7a:	3f e0       	ldi	r19, 0x0F	; 15
    1c7c:	49 e4       	ldi	r20, 0x49	; 73
    1c7e:	50 e4       	ldi	r21, 0x40	; 64
    1c80:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    1c84:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    1c88:	a9 88       	ldd	r10, Y+17	; 0x11
    1c8a:	0d 2d       	mov	r16, r13
    1c8c:	94 01       	movw	r18, r8
    1c8e:	ab 01       	movw	r20, r22
    1c90:	6c 85       	ldd	r22, Y+12	; 0x0c
    1c92:	7d 85       	ldd	r23, Y+13	; 0x0d
    1c94:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c96:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c98:	0e 94 b4 24 	call	0x4968	; 0x4968 <send_update>
    1c9c:	8f e1       	ldi	r24, 0x1F	; 31
            
            
            // Low level anti collision
            uint8_t objectX;
            if ((servoStep*servoResolution) <= 30) objectX = forwardSensor;// * cos(servoStep*5);
    1c9e:	88 16       	cp	r8, r24
    1ca0:	91 04       	cpc	r9, r1
    1ca2:	2c f0       	brlt	.+10     	; 0x1cae <vMainSensorTowerTask+0x1c0>
    1ca4:	9c e3       	ldi	r25, 0x3C	; 60
            else if((servoStep*servoResolution) >= 60) objectX = rightSensor;// * cos(270 + servoStep*5);
    1ca6:	89 16       	cp	r8, r25
    1ca8:	91 04       	cpc	r9, r1
    1caa:	8c f1       	brlt	.+98     	; 0x1d0e <vMainSensorTowerTask+0x220>
    1cac:	d9 88       	ldd	r13, Y+17	; 0x11
    1cae:	8f ef       	ldi	r24, 0xFF	; 255
            else objectX = 0;
            

			
            if ((objectX > 0) && (objectX < 25)){
    1cb0:	8d 0d       	add	r24, r13
    1cb2:	88 31       	cpi	r24, 0x18	; 24
    1cb4:	60 f5       	brcc	.+88     	; 0x1d0e <vMainSensorTowerTask+0x220>
    1cb6:	2e 85       	ldd	r18, Y+14	; 0x0e
                // Stop controller
                struct sCartesian Setpoint = {xhat/10, yhat/10};
    1cb8:	3f 85       	ldd	r19, Y+15	; 0x0f
    1cba:	b9 01       	movw	r22, r18
    1cbc:	33 0f       	add	r19, r19
    1cbe:	88 0b       	sbc	r24, r24
    1cc0:	99 0b       	sbc	r25, r25
    1cc2:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    1cc6:	6c 83       	std	Y+4, r22	; 0x04
    1cc8:	7d 83       	std	Y+5, r23	; 0x05
    1cca:	8e 83       	std	Y+6, r24	; 0x06
    1ccc:	9f 83       	std	Y+7, r25	; 0x07
    1cce:	2c 85       	ldd	r18, Y+12	; 0x0c
    1cd0:	3d 85       	ldd	r19, Y+13	; 0x0d
    1cd2:	b9 01       	movw	r22, r18
    1cd4:	33 0f       	add	r19, r19
    1cd6:	88 0b       	sbc	r24, r24
    1cd8:	99 0b       	sbc	r25, r25
    1cda:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    1cde:	68 87       	std	Y+8, r22	; 0x08
    1ce0:	79 87       	std	Y+9, r23	; 0x09
    1ce2:	8a 87       	std	Y+10, r24	; 0x0a
    1ce4:	9b 87       	std	Y+11, r25	; 0x0b
    1ce6:	8f e0       	ldi	r24, 0x0F	; 15
					debug("anti kollisjon");
    1ce8:	96 e0       	ldi	r25, 0x06	; 6
    1cea:	9f 93       	push	r25
    1cec:	8f 93       	push	r24
    1cee:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <debug>
    1cf2:	20 e0       	ldi	r18, 0x00	; 0
                xQueueSend(poseControllerQ, &Setpoint, 100);
    1cf4:	44 e6       	ldi	r20, 0x64	; 100
    1cf6:	50 e0       	ldi	r21, 0x00	; 0
    1cf8:	be 01       	movw	r22, r28
    1cfa:	6c 5f       	subi	r22, 0xFC	; 252
    1cfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1cfe:	80 91 23 1a 	lds	r24, 0x1A23	; 0x801a23 <poseControllerQ>
    1d02:	90 91 24 1a 	lds	r25, 0x1A24	; 0x801a24 <poseControllerQ+0x1>
    1d06:	0e 94 1c 1f 	call	0x3e38	; 0x3e38 <xQueueGenericSend>
    1d0a:	0f 90       	pop	r0
    1d0c:	0f 90       	pop	r0
    1d0e:	3b e5       	ldi	r19, 0x5B	; 91
				
				
            }
            
            // Iterate in a increasing/decreasign manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
    1d10:	83 16       	cp	r8, r19
    1d12:	91 04       	cpc	r9, r1
    1d14:	ac f4       	brge	.+42     	; 0x1d40 <vMainSensorTowerTask+0x252>
    1d16:	84 e0       	ldi	r24, 0x04	; 4
    1d18:	28 12       	cpse	r2, r24
    1d1a:	12 c0       	rjmp	.+36     	; 0x1d40 <vMainSensorTowerTask+0x252>
    1d1c:	89 81       	ldd	r24, Y+1	; 0x01
    1d1e:	83 30       	cpi	r24, 0x03	; 3
    1d20:	08 f0       	brcs	.+2      	; 0x1d24 <vMainSensorTowerTask+0x236>
    1d22:	44 c0       	rjmp	.+136    	; 0x1dac <vMainSensorTowerTask+0x2be>
    1d24:	f3 94       	inc	r15
                servoStep++;
    1d26:	2a 89       	ldd	r18, Y+18	; 0x12
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1d28:	3b 89       	ldd	r19, Y+19	; 0x13
    1d2a:	f2 9e       	mul	r15, r18
    1d2c:	40 01       	movw	r8, r0
    1d2e:	f3 9e       	mul	r15, r19
    1d30:	90 0c       	add	r9, r0
    1d32:	11 24       	eor	r1, r1
    1d34:	3a e5       	ldi	r19, 0x5A	; 90
    1d36:	83 16       	cp	r8, r19
    1d38:	91 04       	cpc	r9, r1
    1d3a:	0c f0       	brlt	.+2      	; 0x1d3e <vMainSensorTowerTask+0x250>
    1d3c:	ee ce       	rjmp	.-548    	; 0x1b1a <vMainSensorTowerTask+0x2c>
    1d3e:	17 c0       	rjmp	.+46     	; 0x1d6e <vMainSensorTowerTask+0x280>
    1d40:	18 14       	cp	r1, r8
            
            // Iterate in a increasing/decreasign manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1d42:	19 04       	cpc	r1, r9
    1d44:	44 f5       	brge	.+80     	; 0x1d96 <vMainSensorTowerTask+0x2a8>
    1d46:	83 e0       	ldi	r24, 0x03	; 3
    1d48:	28 12       	cpse	r2, r24
    1d4a:	2a c0       	rjmp	.+84     	; 0x1da0 <vMainSensorTowerTask+0x2b2>
    1d4c:	89 81       	ldd	r24, Y+1	; 0x01
    1d4e:	83 30       	cpi	r24, 0x03	; 3
    1d50:	08 f0       	brcs	.+2      	; 0x1d54 <vMainSensorTowerTask+0x266>
    1d52:	f1 ce       	rjmp	.-542    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d54:	fa 94       	dec	r15
                servoStep --;
    1d56:	2a 89       	ldd	r18, Y+18	; 0x12
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1d58:	3b 89       	ldd	r19, Y+19	; 0x13
    1d5a:	f2 9e       	mul	r15, r18
    1d5c:	40 01       	movw	r8, r0
    1d5e:	f3 9e       	mul	r15, r19
    1d60:	90 0c       	add	r9, r0
    1d62:	11 24       	eor	r1, r1
    1d64:	04 c0       	rjmp	.+8      	; 0x1d6e <vMainSensorTowerTask+0x280>
    1d66:	34 e0       	ldi	r19, 0x04	; 4
    1d68:	23 16       	cp	r2, r19
    1d6a:	09 f4       	brne	.+2      	; 0x1d6e <vMainSensorTowerTask+0x280>
    1d6c:	db ce       	rjmp	.-586    	; 0x1b24 <vMainSensorTowerTask+0x36>
    1d6e:	18 14       	cp	r1, r8
                rotationDirection = moveClockwise;
            }
            else if ((servoStep*servoResolution <= 0) && (rotationDirection == moveClockwise)){
    1d70:	19 04       	cpc	r1, r9
    1d72:	0c f4       	brge	.+2      	; 0x1d76 <vMainSensorTowerTask+0x288>
    1d74:	e0 ce       	rjmp	.-576    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d76:	83 e0       	ldi	r24, 0x03	; 3
    1d78:	28 12       	cpse	r2, r24
    1d7a:	dd ce       	rjmp	.-582    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d7c:	23 2c       	mov	r2, r3
                rotationDirection = moveCounterClockwise;
    1d7e:	db ce       	rjmp	.-586    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d80:	80 e0       	ldi	r24, 0x00	; 0
            }    
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
    1d82:	0e 94 7b 25 	call	0x4af6	; 0x4af6 <vServo_setAngle>
    1d86:	84 e6       	ldi	r24, 0x64	; 100
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
            vTaskDelay(100/portTICK_PERIOD_MS);
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	0e 94 86 29 	call	0x530c	; 0x530c <vTaskDelay>
    1d8e:	10 e0       	ldi	r17, 0x00	; 0
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
    1d90:	f1 2c       	mov	r15, r1
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
    1d92:	23 2c       	mov	r2, r3
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1d94:	d0 ce       	rjmp	.-608    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d96:	9a e5       	ldi	r25, 0x5A	; 90
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1d98:	89 16       	cp	r8, r25
    1d9a:	91 04       	cpc	r9, r1
    1d9c:	64 f3       	brlt	.-40     	; 0x1d76 <vMainSensorTowerTask+0x288>
    1d9e:	0a c0       	rjmp	.+20     	; 0x1db4 <vMainSensorTowerTask+0x2c6>
    1da0:	2a e5       	ldi	r18, 0x5A	; 90
    1da2:	82 16       	cp	r8, r18
    1da4:	91 04       	cpc	r9, r1
    1da6:	0c f4       	brge	.+2      	; 0x1daa <vMainSensorTowerTask+0x2bc>
    1da8:	c6 ce       	rjmp	.-628    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1daa:	dd cf       	rjmp	.-70     	; 0x1d66 <vMainSensorTowerTask+0x278>
    1dac:	18 14       	cp	r1, r8
            
            // Iterate in a increasing/decreasign manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1dae:	19 04       	cpc	r1, r9
    1db0:	bc f3       	brlt	.-18     	; 0x1da0 <vMainSensorTowerTask+0x2b2>
    1db2:	f1 cf       	rjmp	.-30     	; 0x1d96 <vMainSensorTowerTask+0x2a8>
    1db4:	34 e0       	ldi	r19, 0x04	; 4
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1db6:	23 16       	cp	r2, r19
    1db8:	09 f4       	brne	.+2      	; 0x1dbc <vMainSensorTowerTask+0x2ce>
    1dba:	b9 ce       	rjmp	.-654    	; 0x1b2e <vMainSensorTowerTask+0x40>
    1dbc:	dc cf       	rjmp	.-72     	; 0x1d76 <vMainSensorTowerTask+0x288>

00001dbe <vMainPoseControllerTask>:
    1dbe:	cf 93       	push	r28
        }
    }// While end
}

/*  Calculates new settings for the movement task */
void vMainPoseControllerTask( void *pvParameters ){
    1dc0:	df 93       	push	r29
    1dc2:	cd b7       	in	r28, 0x3d	; 61
    1dc4:	de b7       	in	r29, 0x3e	; 62
    1dc6:	c4 57       	subi	r28, 0x74	; 116
    1dc8:	d1 09       	sbc	r29, r1
    1dca:	0f b6       	in	r0, 0x3f	; 63
    1dcc:	f8 94       	cli
    1dce:	de bf       	out	0x3e, r29	; 62
    1dd0:	0f be       	out	0x3f, r0	; 63
    1dd2:	cd bf       	out	0x3d, r28	; 61
    #ifdef DEBUG
        debug("PoseController OK\n");
        uint8_t tellar = 0;
    #endif
    /* Task init */    
    struct sCartesian Setpoint = {0,0}; // Updates from server
    1dd4:	19 82       	std	Y+1, r1	; 0x01
    1dd6:	1a 82       	std	Y+2, r1	; 0x02
    1dd8:	1b 82       	std	Y+3, r1	; 0x03
    1dda:	1c 82       	std	Y+4, r1	; 0x04
    1ddc:	1d 82       	std	Y+5, r1	; 0x05
    1dde:	1e 82       	std	Y+6, r1	; 0x06
    1de0:	1f 82       	std	Y+7, r1	; 0x07
    1de2:	18 86       	std	Y+8, r1	; 0x08
    struct sCartesian Error = {0,0}; // Error values
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
	float radiusEpsilon = 15; //[mm]The acceptable radius from goal for completion
	uint8_t lastMovement = 0;
    1de4:	19 86       	std	Y+9, r1	; 0x09
	int16_t xhat = 0;
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
    1de6:	1a 86       	std	Y+10, r1	; 0x0a
    1de8:	1b 86       	std	Y+11, r1	; 0x0b
    1dea:	1c 86       	std	Y+12, r1	; 0x0c
    1dec:	1d 86       	std	Y+13, r1	; 0x0d
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
	volatile int16_t LSpeed = 0;
    1dee:	1f 86       	std	Y+15, r1	; 0x0f
    1df0:	1e 86       	std	Y+14, r1	; 0x0e
	volatile int16_t RSpeed = 0;
    1df2:	19 8a       	std	Y+17, r1	; 0x11
    1df4:	18 8a       	std	Y+16, r1	; 0x10
	
	int16_t leftWheelTicks = 0;
    1df6:	1b 8a       	std	Y+19, r1	; 0x13
    1df8:	1a 8a       	std	Y+18, r1	; 0x12
	int16_t rightWheelTicks = 0;
    1dfa:	1d 8a       	std	Y+21, r1	; 0x15
    1dfc:	1c 8a       	std	Y+20, r1	; 0x14
	
	uint8_t leftEncoderVal = 0;
	uint8_t rightEncoderVal = 0;
	
	uint8_t gLeftWheelDirection = 0;
    1dfe:	1e 8a       	std	Y+22, r1	; 0x16
	uint8_t gRightWheelDirection = 0;
    1e00:	1f 8a       	std	Y+23, r1	; 0x17
	
	/* TESTING VARIABLES */
	float distanceStart = 0;
	float prevDist= 0;
	float prevThetaDiff = 0;
	float StartDiff = 0;
    1e02:	18 8e       	std	Y+24, r1	; 0x18
    1e04:	19 8e       	std	Y+25, r1	; 0x19
    1e06:	1a 8e       	std	Y+26, r1	; 0x1a
    1e08:	1b 8e       	std	Y+27, r1	; 0x1b
	uint8_t blabla = 0;
	uint8_t printInc = 0;
	float thetaTraveled = 0;
    uint8_t newOrder = FALSE;
	uint8_t initIncrement = 40;
	uint8_t bStuck = FALSE;
    1e0a:	aa 96       	adiw	r28, 0x2a	; 42
    1e0c:	1f ae       	std	Y+63, r1	; 0x3f
    1e0e:	aa 97       	sbiw	r28, 0x2a	; 42
	uint8_t baseRotationSpeed = 20;
	uint8_t starteds = 0;
	uint8_t blabla = 0;
	uint8_t printInc = 0;
	float thetaTraveled = 0;
    uint8_t newOrder = FALSE;
    1e10:	2d 96       	adiw	r28, 0x0d	; 13
    1e12:	1f ae       	std	Y+63, r1	; 0x3f
    1e14:	2d 97       	sbiw	r28, 0x0d	; 13
	uint8_t bBaseDownRampActFound = FALSE;
	uint8_t bBaseRotationSpeed = FALSE;
	uint8_t baseRotationSpeed = 20;
	uint8_t starteds = 0;
	uint8_t blabla = 0;
	uint8_t printInc = 0;
    1e16:	1f aa       	std	Y+55, r1	; 0x37
	uint8_t baseDownRampActuation = 5;
	uint8_t bBaseUpRampActFound = FALSE;
	uint8_t bBaseDownRampActFound = FALSE;
	uint8_t bBaseRotationSpeed = FALSE;
	uint8_t baseRotationSpeed = 20;
	uint8_t starteds = 0;
    1e18:	a8 96       	adiw	r28, 0x28	; 40
    1e1a:	1f ae       	std	Y+63, r1	; 0x3f
    1e1c:	a8 97       	sbiw	r28, 0x28	; 40
	uint8_t baseUpRampActuation = 10;
	uint8_t baseDownRampActuation = 5;
	uint8_t bBaseUpRampActFound = FALSE;
	uint8_t bBaseDownRampActFound = FALSE;
	uint8_t bBaseRotationSpeed = FALSE;
	uint8_t baseRotationSpeed = 20;
    1e1e:	24 e1       	ldi	r18, 0x14	; 20
    1e20:	24 96       	adiw	r28, 0x04	; 4
    1e22:	2f af       	std	Y+63, r18	; 0x3f
    1e24:	24 97       	sbiw	r28, 0x04	; 4
	uint8_t idlesendtInc = 0;
	uint8_t baseUpRampActuation = 10;
	uint8_t baseDownRampActuation = 5;
	uint8_t bBaseUpRampActFound = FALSE;
	uint8_t bBaseDownRampActFound = FALSE;
	uint8_t bBaseRotationSpeed = FALSE;
    1e26:	a9 96       	adiw	r28, 0x29	; 41
    1e28:	1f ae       	std	Y+63, r1	; 0x3f
    1e2a:	a9 97       	sbiw	r28, 0x29	; 41

	int sugmeg = 0;
	uint8_t idlesendtInc = 0;
	uint8_t baseUpRampActuation = 10;
	uint8_t baseDownRampActuation = 5;
	uint8_t bBaseUpRampActFound = FALSE;
    1e2c:	e5 96       	adiw	r28, 0x35	; 53
    1e2e:	1f ae       	std	Y+63, r1	; 0x3f
    1e30:	e5 97       	sbiw	r28, 0x35	; 53
	uint8_t stuckRotRight = 0;

	int sugmeg = 0;
	uint8_t idlesendtInc = 0;
	uint8_t baseUpRampActuation = 10;
	uint8_t baseDownRampActuation = 5;
    1e32:	45 e0       	ldi	r20, 0x05	; 5
    1e34:	e4 96       	adiw	r28, 0x34	; 52
    1e36:	4f af       	std	Y+63, r20	; 0x3f
    1e38:	e4 97       	sbiw	r28, 0x34	; 52
	uint8_t stuckRotLeft = 0;
	uint8_t stuckRotRight = 0;

	int sugmeg = 0;
	uint8_t idlesendtInc = 0;
	uint8_t baseUpRampActuation = 10;
    1e3a:	8a e0       	ldi	r24, 0x0A	; 10
    1e3c:	a7 96       	adiw	r28, 0x27	; 39
    1e3e:	8f af       	std	Y+63, r24	; 0x3f
    1e40:	a7 97       	sbiw	r28, 0x27	; 39
	float xhatStart = 0;
	float yhatStart = 0;

	uint8_t stuckIncrement = 0;
	uint8_t stuckRotLeft = 0;
	uint8_t stuckRotRight = 0;
    1e42:	1a ae       	std	Y+58, r1	; 0x3a
	float thetahatStart = 0;
	float xhatStart = 0;
	float yhatStart = 0;

	uint8_t stuckIncrement = 0;
	uint8_t stuckRotLeft = 0;
    1e44:	19 ae       	std	Y+57, r1	; 0x39
	float StartDiff = 0;
	float thetahatStart = 0;
	float xhatStart = 0;
	float yhatStart = 0;

	uint8_t stuckIncrement = 0;
    1e46:	18 ae       	std	Y+56, r1	; 0x38
	float prevDist= 0;
	float prevThetaDiff = 0;
	float StartDiff = 0;
	float thetahatStart = 0;
	float xhatStart = 0;
	float yhatStart = 0;
    1e48:	e2 96       	adiw	r28, 0x32	; 50
    1e4a:	1c ae       	std	Y+60, r1	; 0x3c
    1e4c:	1d ae       	std	Y+61, r1	; 0x3d
    1e4e:	1e ae       	std	Y+62, r1	; 0x3e
    1e50:	1f ae       	std	Y+63, r1	; 0x3f
    1e52:	e2 97       	sbiw	r28, 0x32	; 50
	float distanceStart = 0;
	float prevDist= 0;
	float prevThetaDiff = 0;
	float StartDiff = 0;
	float thetahatStart = 0;
	float xhatStart = 0;
    1e54:	ae 96       	adiw	r28, 0x2e	; 46
    1e56:	1c ae       	std	Y+60, r1	; 0x3c
    1e58:	1d ae       	std	Y+61, r1	; 0x3d
    1e5a:	1e ae       	std	Y+62, r1	; 0x3e
    1e5c:	1f ae       	std	Y+63, r1	; 0x3f
    1e5e:	ae 97       	sbiw	r28, 0x2e	; 46
	uint8_t rightEncoderVal = 0;
	
	uint8_t gLeftWheelDirection = 0;
	uint8_t gRightWheelDirection = 0;
	
	uint8_t idleSendt = FALSE;
    1e60:	6b 96       	adiw	r28, 0x1b	; 27
    1e62:	1f ae       	std	Y+63, r1	; 0x3f
    1e64:	6b 97       	sbiw	r28, 0x1b	; 27
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
    1e66:	91 e0       	ldi	r25, 0x01	; 1
    1e68:	62 96       	adiw	r28, 0x12	; 18
    1e6a:	9f af       	std	Y+63, r25	; 0x3f
    1e6c:	62 97       	sbiw	r28, 0x12	; 18
	float thetaTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
    1e6e:	6a 96       	adiw	r28, 0x1a	; 26
    1e70:	1c ae       	std	Y+60, r1	; 0x3c
    1e72:	1d ae       	std	Y+61, r1	; 0x3d
    1e74:	1e ae       	std	Y+62, r1	; 0x3e
    1e76:	1f ae       	std	Y+63, r1	; 0x3f
    1e78:	6a 97       	sbiw	r28, 0x1a	; 26
	float ydiff = 0;
	float thetaTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
    1e7a:	61 96       	adiw	r28, 0x11	; 17
    1e7c:	1c ae       	std	Y+60, r1	; 0x3c
    1e7e:	1d ae       	std	Y+61, r1	; 0x3d
    1e80:	1e ae       	std	Y+62, r1	; 0x3e
    1e82:	1f ae       	std	Y+63, r1	; 0x3f
    1e84:	61 97       	sbiw	r28, 0x11	; 17
	float xTargt = 0;
	float yTargt = 0;
	
	float xdiff = 0;
	float ydiff = 0;
	float thetaTargt = 0;
    1e86:	1b a6       	std	Y+43, r1	; 0x2b
    1e88:	1c a6       	std	Y+44, r1	; 0x2c
    1e8a:	1d a6       	std	Y+45, r1	; 0x2d
    1e8c:	1e a6       	std	Y+46, r1	; 0x2e
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
	float yTargt = 0;
    1e8e:	23 96       	adiw	r28, 0x03	; 3
    1e90:	1c ae       	std	Y+60, r1	; 0x3c
    1e92:	1d ae       	std	Y+61, r1	; 0x3d
    1e94:	1e ae       	std	Y+62, r1	; 0x3e
    1e96:	1f ae       	std	Y+63, r1	; 0x3f
    1e98:	23 97       	sbiw	r28, 0x03	; 3
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
    1e9a:	1b ae       	std	Y+59, r1	; 0x3b
    1e9c:	1c ae       	std	Y+60, r1	; 0x3c
    1e9e:	1d ae       	std	Y+61, r1	; 0x3d
    1ea0:	1e ae       	std	Y+62, r1	; 0x3e
	float thetahat = 0;
	int16_t xhat = 0;
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
    1ea2:	63 96       	adiw	r28, 0x13	; 19
    1ea4:	1f ae       	std	Y+63, r1	; 0x3f
    1ea6:	63 97       	sbiw	r28, 0x13	; 19
    1ea8:	64 96       	adiw	r28, 0x14	; 20
    1eaa:	1f ae       	std	Y+63, r1	; 0x3f
    1eac:	64 97       	sbiw	r28, 0x14	; 20
    1eae:	65 96       	adiw	r28, 0x15	; 21
    1eb0:	1f ae       	std	Y+63, r1	; 0x3f
    1eb2:	65 97       	sbiw	r28, 0x15	; 21
    1eb4:	66 96       	adiw	r28, 0x16	; 22
    1eb6:	1f ae       	std	Y+63, r1	; 0x3f
    1eb8:	66 97       	sbiw	r28, 0x16	; 22
	float rotateThreshold = 0.5235; //[rad] The threshold at which the robot will go from driving to rotation. Equals 10 degrees
	float driveThreshold = 0.0174; // [rad ]The threshold at which the robot will go from rotation to driving. In degrees.
	float driveKp = 600; //Proportional gain for theta control during drive
	float driveKi = 10;//Integral gain for theta during drive
	float speedDecreaseThreshold = 300; //[mm] Distance from goal where the robot will decrease its speed inverse proportionally
	float speedIncreaseThreshold = 100;	//[mm] Distance from start of movement where the speed increases to avoid spinning
    1eba:	1f a2       	std	Y+39, r1	; 0x27
    1ebc:	18 a6       	std	Y+40, r1	; 0x28
    1ebe:	a8 ec       	ldi	r26, 0xC8	; 200
    1ec0:	a9 a7       	std	Y+41, r26	; 0x29
    1ec2:	b2 e4       	ldi	r27, 0x42	; 66
    1ec4:	ba a7       	std	Y+42, r27	; 0x2a
	/* Controller variables for tuning */
	float rotateThreshold = 0.5235; //[rad] The threshold at which the robot will go from driving to rotation. Equals 10 degrees
	float driveThreshold = 0.0174; // [rad ]The threshold at which the robot will go from rotation to driving. In degrees.
	float driveKp = 600; //Proportional gain for theta control during drive
	float driveKi = 10;//Integral gain for theta during drive
	float speedDecreaseThreshold = 300; //[mm] Distance from goal where the robot will decrease its speed inverse proportionally
    1ec6:	1b aa       	std	Y+51, r1	; 0x33
    1ec8:	1c aa       	std	Y+52, r1	; 0x34
    1eca:	26 e9       	ldi	r18, 0x96	; 150
    1ecc:	2d ab       	std	Y+53, r18	; 0x35
    1ece:	43 e4       	ldi	r20, 0x43	; 67
    1ed0:	4e ab       	std	Y+54, r20	; 0x36
    struct sPolar referenceModel = {0};
	float radiusEpsilon = 15; //[mm]The acceptable radius from goal for completion
	uint8_t lastMovement = 0;
	
	uint8_t maxRotateActuation = 100; //The max speed the motors will run at during rotation max is 255
	uint8_t maxDriveActuation = 100; //The max speed the motors will run at during drive max is 255
    1ed2:	84 e6       	ldi	r24, 0x64	; 100
    1ed4:	e3 96       	adiw	r28, 0x33	; 51
    1ed6:	8f af       	std	Y+63, r24	; 0x3f
    1ed8:	e3 97       	sbiw	r28, 0x33	; 51
	
	uint8_t stuckValueFound = FALSE;
	 
	while(1){
		
		if (gHandshook){
    1eda:	80 91 1c 1a 	lds	r24, 0x1A1C	; 0x801a1c <gHandshook>
    1ede:	88 23       	and	r24, r24
    1ee0:	09 f4       	brne	.+2      	; 0x1ee4 <vMainPoseControllerTask+0x126>
    1ee2:	e1 c7       	rjmp	.+4034   	; 0x2ea6 <__stack+0xca7>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1ee4:	f8 94       	cli
		
			ATOMIC_BLOCK(ATOMIC_FORCEON){
				leftEncoderVal = gISR_leftWheelTicks;
    1ee6:	40 91 1d 1a 	lds	r20, 0x1A1D	; 0x801a1d <gISR_leftWheelTicks>
				gISR_leftWheelTicks = 0;
    1eea:	10 92 1d 1a 	sts	0x1A1D, r1	; 0x801a1d <gISR_leftWheelTicks>
				rightEncoderVal = gISR_rightWheelTicks;
    1eee:	10 91 1e 1a 	lds	r17, 0x1A1E	; 0x801a1e <gISR_rightWheelTicks>
				gISR_rightWheelTicks = 0;
    1ef2:	10 92 1e 1a 	sts	0x1A1E, r1	; 0x801a1e <gISR_rightWheelTicks>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1ef6:	78 94       	sei
			}

			vMotorEncoderLeftTickFromISR(gLeftWheelDirection, &leftWheelTicks, leftEncoderVal);
    1ef8:	be 01       	movw	r22, r28
    1efa:	6e 5e       	subi	r22, 0xEE	; 238
    1efc:	7f 4f       	sbci	r23, 0xFF	; 255
    1efe:	8e 89       	ldd	r24, Y+22	; 0x16
    1f00:	0e 94 b4 1a 	call	0x3568	; 0x3568 <vMotorEncoderLeftTickFromISR>
			vMotorEncoderRightTickFromISR(gRightWheelDirection, &rightWheelTicks, rightEncoderVal);
    1f04:	41 2f       	mov	r20, r17
    1f06:	be 01       	movw	r22, r28
    1f08:	6c 5e       	subi	r22, 0xEC	; 236
    1f0a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0c:	8f 89       	ldd	r24, Y+23	; 0x17
    1f0e:	0e 94 c9 1a 	call	0x3592	; 0x3592 <vMotorEncoderRightTickFromISR>
			
			xSemaphoreTake(xTickMutex,1 / portTICK_PERIOD_MS);
    1f12:	20 e0       	ldi	r18, 0x00	; 0
    1f14:	41 e0       	ldi	r20, 0x01	; 1
    1f16:	50 e0       	ldi	r21, 0x00	; 0
    1f18:	60 e0       	ldi	r22, 0x00	; 0
    1f1a:	70 e0       	ldi	r23, 0x00	; 0
    1f1c:	80 91 85 1b 	lds	r24, 0x1B85	; 0x801b85 <xTickMutex>
    1f20:	90 91 86 1b 	lds	r25, 0x1B86	; 0x801b86 <xTickMutex+0x1>
    1f24:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
			gLeftWheelTicks = leftWheelTicks;
    1f28:	8a 89       	ldd	r24, Y+18	; 0x12
    1f2a:	9b 89       	ldd	r25, Y+19	; 0x13
    1f2c:	90 93 08 1a 	sts	0x1A08, r25	; 0x801a08 <gLeftWheelTicks+0x1>
    1f30:	80 93 07 1a 	sts	0x1A07, r24	; 0x801a07 <gLeftWheelTicks>
			gRightWheelTicks = rightWheelTicks;
    1f34:	8c 89       	ldd	r24, Y+20	; 0x14
    1f36:	9d 89       	ldd	r25, Y+21	; 0x15
    1f38:	90 93 0a 1a 	sts	0x1A0A, r25	; 0x801a0a <gRightWheelTicks+0x1>
    1f3c:	80 93 09 1a 	sts	0x1A09, r24	; 0x801a09 <gRightWheelTicks>
			xSemaphoreGive(xTickMutex);
    1f40:	60 e0       	ldi	r22, 0x00	; 0
    1f42:	70 e0       	ldi	r23, 0x00	; 0
    1f44:	80 91 85 1b 	lds	r24, 0x1B85	; 0x801b85 <xTickMutex>
    1f48:	90 91 86 1b 	lds	r25, 0x1B86	; 0x801b86 <xTickMutex+0x1>
    1f4c:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
	
			if (xSemaphoreTake(xControllerBSem, portMAX_DELAY) == pdTRUE){    // Wait for synchronization from estimator
    1f50:	20 e0       	ldi	r18, 0x00	; 0
    1f52:	4f ef       	ldi	r20, 0xFF	; 255
    1f54:	5f ef       	ldi	r21, 0xFF	; 255
    1f56:	60 e0       	ldi	r22, 0x00	; 0
    1f58:	70 e0       	ldi	r23, 0x00	; 0
    1f5a:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <xControllerBSem>
    1f5e:	90 91 84 1b 	lds	r25, 0x1B84	; 0x801b84 <xControllerBSem+0x1>
    1f62:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
    1f66:	81 30       	cpi	r24, 0x01	; 1
    1f68:	09 f0       	breq	.+2      	; 0x1f6c <vMainPoseControllerTask+0x1ae>
    1f6a:	b7 cf       	rjmp	.-146    	; 0x1eda <vMainPoseControllerTask+0x11c>
				// Get robot pose
				xSemaphoreTake(xPoseMutex,portMAX_DELAY);
    1f6c:	20 e0       	ldi	r18, 0x00	; 0
    1f6e:	4f ef       	ldi	r20, 0xFF	; 255
    1f70:	5f ef       	ldi	r21, 0xFF	; 255
    1f72:	60 e0       	ldi	r22, 0x00	; 0
    1f74:	70 e0       	ldi	r23, 0x00	; 0
    1f76:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    1f7a:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    1f7e:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
					thetahat = gTheta_hat;
    1f82:	90 91 17 1a 	lds	r25, 0x1A17	; 0x801a17 <gTheta_hat>
    1f86:	9f a7       	std	Y+47, r25	; 0x2f
    1f88:	a0 91 18 1a 	lds	r26, 0x1A18	; 0x801a18 <gTheta_hat+0x1>
    1f8c:	a8 ab       	std	Y+48, r26	; 0x30
    1f8e:	b0 91 19 1a 	lds	r27, 0x1A19	; 0x801a19 <gTheta_hat+0x2>
    1f92:	b9 ab       	std	Y+49, r27	; 0x31
    1f94:	20 91 1a 1a 	lds	r18, 0x1A1A	; 0x801a1a <gTheta_hat+0x3>
    1f98:	2a ab       	std	Y+50, r18	; 0x32
					xhat = gX_hat;
    1f9a:	20 90 15 1a 	lds	r2, 0x1A15	; 0x801a15 <gX_hat>
    1f9e:	30 90 16 1a 	lds	r3, 0x1A16	; 0x801a16 <gX_hat+0x1>
					yhat = gY_hat;
    1fa2:	00 91 13 1a 	lds	r16, 0x1A13	; 0x801a13 <gY_hat>
    1fa6:	10 91 14 1a 	lds	r17, 0x1A14	; 0x801a14 <gY_hat+0x1>
					dLeft = gLeft;
    1faa:	80 91 0f 1a 	lds	r24, 0x1A0F	; 0x801a0f <gLeft>
    1fae:	90 91 10 1a 	lds	r25, 0x1A10	; 0x801a10 <gLeft+0x1>
    1fb2:	a0 91 11 1a 	lds	r26, 0x1A11	; 0x801a11 <gLeft+0x2>
    1fb6:	b0 91 12 1a 	lds	r27, 0x1A12	; 0x801a12 <gLeft+0x3>
    1fba:	28 96       	adiw	r28, 0x08	; 8
    1fbc:	8c af       	std	Y+60, r24	; 0x3c
    1fbe:	9d af       	std	Y+61, r25	; 0x3d
    1fc0:	ae af       	std	Y+62, r26	; 0x3e
    1fc2:	bf af       	std	Y+63, r27	; 0x3f
    1fc4:	28 97       	sbiw	r28, 0x08	; 8
					dRight = gRight;
    1fc6:	80 91 0b 1a 	lds	r24, 0x1A0B	; 0x801a0b <gRight>
    1fca:	90 91 0c 1a 	lds	r25, 0x1A0C	; 0x801a0c <gRight+0x1>
    1fce:	a0 91 0d 1a 	lds	r26, 0x1A0D	; 0x801a0d <gRight+0x2>
    1fd2:	b0 91 0e 1a 	lds	r27, 0x1A0E	; 0x801a0e <gRight+0x3>
    1fd6:	2c 96       	adiw	r28, 0x0c	; 12
    1fd8:	8c af       	std	Y+60, r24	; 0x3c
    1fda:	9d af       	std	Y+61, r25	; 0x3d
    1fdc:	ae af       	std	Y+62, r26	; 0x3e
    1fde:	bf af       	std	Y+63, r27	; 0x3f
    1fe0:	2c 97       	sbiw	r28, 0x0c	; 12
				xSemaphoreGive(xPoseMutex);
    1fe2:	60 e0       	ldi	r22, 0x00	; 0
    1fe4:	70 e0       	ldi	r23, 0x00	; 0
    1fe6:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    1fea:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    1fee:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
				
				// Check if a new update is received
				if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
    1ff2:	20 e0       	ldi	r18, 0x00	; 0
    1ff4:	40 e0       	ldi	r20, 0x00	; 0
    1ff6:	50 e0       	ldi	r21, 0x00	; 0
    1ff8:	be 01       	movw	r22, r28
    1ffa:	6f 5f       	subi	r22, 0xFF	; 255
    1ffc:	7f 4f       	sbci	r23, 0xFF	; 255
    1ffe:	80 91 23 1a 	lds	r24, 0x1A23	; 0x801a23 <poseControllerQ>
    2002:	90 91 24 1a 	lds	r25, 0x1A24	; 0x801a24 <poseControllerQ+0x1>
    2006:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
    200a:	81 30       	cpi	r24, 0x01	; 1
    200c:	09 f0       	breq	.+2      	; 0x2010 <vMainPoseControllerTask+0x252>
    200e:	59 c0       	rjmp	.+178    	; 0x20c2 <vMainPoseControllerTask+0x304>
					//xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
					xTargt = (float)Setpoint.x*10;	//Distance is received in cm, convert to mm for continuity
    2010:	20 e0       	ldi	r18, 0x00	; 0
    2012:	30 e0       	ldi	r19, 0x00	; 0
    2014:	40 e2       	ldi	r20, 0x20	; 32
    2016:	51 e4       	ldi	r21, 0x41	; 65
    2018:	69 81       	ldd	r22, Y+1	; 0x01
    201a:	7a 81       	ldd	r23, Y+2	; 0x02
    201c:	8b 81       	ldd	r24, Y+3	; 0x03
    201e:	9c 81       	ldd	r25, Y+4	; 0x04
    2020:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2024:	6b af       	std	Y+59, r22	; 0x3b
    2026:	7c af       	std	Y+60, r23	; 0x3c
    2028:	8d af       	std	Y+61, r24	; 0x3d
    202a:	9e af       	std	Y+62, r25	; 0x3e
					yTargt = (float)Setpoint.y*10;	//Distance is received in cm, convert to mm for continuity
    202c:	20 e0       	ldi	r18, 0x00	; 0
    202e:	30 e0       	ldi	r19, 0x00	; 0
    2030:	40 e2       	ldi	r20, 0x20	; 32
    2032:	51 e4       	ldi	r21, 0x41	; 65
    2034:	6d 81       	ldd	r22, Y+5	; 0x05
    2036:	7e 81       	ldd	r23, Y+6	; 0x06
    2038:	8f 81       	ldd	r24, Y+7	; 0x07
    203a:	98 85       	ldd	r25, Y+8	; 0x08
    203c:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2040:	23 96       	adiw	r28, 0x03	; 3
    2042:	6c af       	std	Y+60, r22	; 0x3c
    2044:	7d af       	std	Y+61, r23	; 0x3d
    2046:	8e af       	std	Y+62, r24	; 0x3e
    2048:	9f af       	std	Y+63, r25	; 0x3f
    204a:	23 97       	sbiw	r28, 0x03	; 3
					thetahatStart = thetahat;
					xhatStart = xhat;
    204c:	b1 01       	movw	r22, r2
    204e:	03 2c       	mov	r0, r3
    2050:	00 0c       	add	r0, r0
    2052:	88 0b       	sbc	r24, r24
    2054:	99 0b       	sbc	r25, r25
    2056:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    205a:	ae 96       	adiw	r28, 0x2e	; 46
    205c:	6c af       	std	Y+60, r22	; 0x3c
    205e:	7d af       	std	Y+61, r23	; 0x3d
    2060:	8e af       	std	Y+62, r24	; 0x3e
    2062:	9f af       	std	Y+63, r25	; 0x3f
    2064:	ae 97       	sbiw	r28, 0x2e	; 46
					yhatStart = yhat;
    2066:	b8 01       	movw	r22, r16
    2068:	01 2e       	mov	r0, r17
    206a:	00 0c       	add	r0, r0
    206c:	88 0b       	sbc	r24, r24
    206e:	99 0b       	sbc	r25, r25
    2070:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2074:	e2 96       	adiw	r28, 0x32	; 50
    2076:	6c af       	std	Y+60, r22	; 0x3c
    2078:	7d af       	std	Y+61, r23	; 0x3d
    207a:	8e af       	std	Y+62, r24	; 0x3e
    207c:	9f af       	std	Y+63, r25	; 0x3f
    207e:	e2 97       	sbiw	r28, 0x32	; 50
					StartDiff = thetaTargt - thetahatStart;
    2080:	7f a5       	ldd	r23, Y+47	; 0x2f
    2082:	68 a9       	ldd	r22, Y+48	; 0x30
    2084:	99 a9       	ldd	r25, Y+49	; 0x31
    2086:	8a a9       	ldd	r24, Y+50	; 0x32
    2088:	27 2f       	mov	r18, r23
    208a:	36 2f       	mov	r19, r22
    208c:	49 2f       	mov	r20, r25
    208e:	58 2f       	mov	r21, r24
    2090:	6b a5       	ldd	r22, Y+43	; 0x2b
    2092:	7c a5       	ldd	r23, Y+44	; 0x2c
    2094:	8d a5       	ldd	r24, Y+45	; 0x2d
    2096:	9e a5       	ldd	r25, Y+46	; 0x2e
    2098:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    209c:	68 8f       	std	Y+24, r22	; 0x18
    209e:	79 8f       	std	Y+25, r23	; 0x19
    20a0:	8a 8f       	std	Y+26, r24	; 0x1a
    20a2:	9b 8f       	std	Y+27, r25	; 0x1b
					starteds++;
    20a4:	a8 96       	adiw	r28, 0x28	; 40
    20a6:	9f ad       	ldd	r25, Y+63	; 0x3f
    20a8:	a8 97       	sbiw	r28, 0x28	; 40
    20aa:	9f 5f       	subi	r25, 0xFF	; 255
    20ac:	a8 96       	adiw	r28, 0x28	; 40
    20ae:	9f af       	std	Y+63, r25	; 0x3f
    20b0:	a8 97       	sbiw	r28, 0x28	; 40
					printInc = 0;
					newOrder = TRUE;
    20b2:	a1 e0       	ldi	r26, 0x01	; 1
    20b4:	2d 96       	adiw	r28, 0x0d	; 13
    20b6:	af af       	std	Y+63, r26	; 0x3f
    20b8:	2d 97       	sbiw	r28, 0x0d	; 13
					thetahatStart = thetahat;
					xhatStart = xhat;
					yhatStart = yhat;
					StartDiff = thetaTargt - thetahatStart;
					starteds++;
					printInc = 0;
    20ba:	1f aa       	std	Y+55, r1	; 0x37
					newOrder = TRUE;
					stuckRotLeft = 0;
					stuckRotRight = 0;
    20bc:	1a ae       	std	Y+58, r1	; 0x3a
					yhatStart = yhat;
					StartDiff = thetaTargt - thetahatStart;
					starteds++;
					printInc = 0;
					newOrder = TRUE;
					stuckRotLeft = 0;
    20be:	19 ae       	std	Y+57, r1	; 0x39
					stuckRotRight = 0;
					stuckIncrement = 0;
    20c0:	18 ae       	std	Y+56, r1	; 0x38
				} 
				
				
				
				prevDist = distance;
				distance = (float)sqrt((xTargt-xhat)*(xTargt-xhat) + (yTargt-yhat)*(yTargt-yhat));
    20c2:	b1 01       	movw	r22, r2
    20c4:	03 2c       	mov	r0, r3
    20c6:	00 0c       	add	r0, r0
    20c8:	88 0b       	sbc	r24, r24
    20ca:	99 0b       	sbc	r25, r25
    20cc:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    20d0:	9b 01       	movw	r18, r22
    20d2:	ac 01       	movw	r20, r24
    20d4:	6b ad       	ldd	r22, Y+59	; 0x3b
    20d6:	7c ad       	ldd	r23, Y+60	; 0x3c
    20d8:	8d ad       	ldd	r24, Y+61	; 0x3d
    20da:	9e ad       	ldd	r25, Y+62	; 0x3e
    20dc:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    20e0:	4b 01       	movw	r8, r22
    20e2:	5c 01       	movw	r10, r24
    20e4:	b8 01       	movw	r22, r16
    20e6:	01 2e       	mov	r0, r17
    20e8:	00 0c       	add	r0, r0
    20ea:	88 0b       	sbc	r24, r24
    20ec:	99 0b       	sbc	r25, r25
    20ee:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    20f2:	9b 01       	movw	r18, r22
    20f4:	ac 01       	movw	r20, r24
    20f6:	23 96       	adiw	r28, 0x03	; 3
    20f8:	6c ad       	ldd	r22, Y+60	; 0x3c
    20fa:	7d ad       	ldd	r23, Y+61	; 0x3d
    20fc:	8e ad       	ldd	r24, Y+62	; 0x3e
    20fe:	9f ad       	ldd	r25, Y+63	; 0x3f
    2100:	23 97       	sbiw	r28, 0x03	; 3
    2102:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    2106:	6b 01       	movw	r12, r22
    2108:	7c 01       	movw	r14, r24
    210a:	a5 01       	movw	r20, r10
    210c:	94 01       	movw	r18, r8
    210e:	c5 01       	movw	r24, r10
    2110:	b4 01       	movw	r22, r8
    2112:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2116:	6c 8f       	std	Y+28, r22	; 0x1c
    2118:	7d 8f       	std	Y+29, r23	; 0x1d
    211a:	8e 8f       	std	Y+30, r24	; 0x1e
    211c:	9f 8f       	std	Y+31, r25	; 0x1f
    211e:	a7 01       	movw	r20, r14
    2120:	96 01       	movw	r18, r12
    2122:	c7 01       	movw	r24, r14
    2124:	b6 01       	movw	r22, r12
    2126:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    212a:	2b 01       	movw	r4, r22
    212c:	3c 01       	movw	r6, r24
    212e:	a3 01       	movw	r20, r6
    2130:	92 01       	movw	r18, r4
    2132:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2134:	7d 8d       	ldd	r23, Y+29	; 0x1d
    2136:	8e 8d       	ldd	r24, Y+30	; 0x1e
    2138:	9f 8d       	ldd	r25, Y+31	; 0x1f
    213a:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    213e:	0e 94 07 37 	call	0x6e0e	; 0x6e0e <sqrt>
    2142:	6c 8f       	std	Y+28, r22	; 0x1c
    2144:	78 a3       	std	Y+32, r23	; 0x20
    2146:	89 a3       	std	Y+33, r24	; 0x21
    2148:	9a a3       	std	Y+34, r25	; 0x22
				
				xdiff = xTargt - xhat;
				ydiff = yTargt - yhat;
				thetaTargt = atan2(ydiff,xdiff); //atan() returns radians
    214a:	a5 01       	movw	r20, r10
    214c:	94 01       	movw	r18, r8
    214e:	c7 01       	movw	r24, r14
    2150:	b6 01       	movw	r22, r12
    2152:	0e 94 8c 34 	call	0x6918	; 0x6918 <atan2>
    2156:	6b a7       	std	Y+43, r22	; 0x2b
    2158:	7c a7       	std	Y+44, r23	; 0x2c
    215a:	8d a7       	std	Y+45, r24	; 0x2d
    215c:	9e a7       	std	Y+46, r25	; 0x2e
				
				prevThetaDiff = thetaDiff;
    215e:	8a 85       	ldd	r24, Y+10	; 0x0a
    2160:	9b 85       	ldd	r25, Y+11	; 0x0b
    2162:	ac 85       	ldd	r26, Y+12	; 0x0c
    2164:	bd 85       	ldd	r27, Y+13	; 0x0d
    2166:	8b a3       	std	Y+35, r24	; 0x23
    2168:	9c a3       	std	Y+36, r25	; 0x24
    216a:	ad a3       	std	Y+37, r26	; 0x25
    216c:	be a3       	std	Y+38, r27	; 0x26
				thetaDiff = thetaTargt-thetahat; //Might be outside pi to -pi degrees
    216e:	7f a5       	ldd	r23, Y+47	; 0x2f
    2170:	68 a9       	ldd	r22, Y+48	; 0x30
    2172:	99 a9       	ldd	r25, Y+49	; 0x31
    2174:	8a a9       	ldd	r24, Y+50	; 0x32
    2176:	27 2f       	mov	r18, r23
    2178:	36 2f       	mov	r19, r22
    217a:	49 2f       	mov	r20, r25
    217c:	58 2f       	mov	r21, r24
    217e:	6b a5       	ldd	r22, Y+43	; 0x2b
    2180:	7c a5       	ldd	r23, Y+44	; 0x2c
    2182:	8d a5       	ldd	r24, Y+45	; 0x2d
    2184:	9e a5       	ldd	r25, Y+46	; 0x2e
    2186:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    218a:	4b 01       	movw	r8, r22
    218c:	5c 01       	movw	r10, r24
    218e:	6a 87       	std	Y+10, r22	; 0x0a
    2190:	7b 87       	std	Y+11, r23	; 0x0b
    2192:	8c 87       	std	Y+12, r24	; 0x0c
    2194:	9d 87       	std	Y+13, r25	; 0x0d
				vFunc_Inf2pi(&thetaDiff);
    2196:	ce 01       	movw	r24, r28
    2198:	0a 96       	adiw	r24, 0x0a	; 10
    219a:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
				
				//Hysteresis mechanics
				if (fabs(thetaDiff) > rotateThreshold){
    219e:	ca 84       	ldd	r12, Y+10	; 0x0a
    21a0:	db 84       	ldd	r13, Y+11	; 0x0b
    21a2:	ec 84       	ldd	r14, Y+12	; 0x0c
    21a4:	fd 84       	ldd	r15, Y+13	; 0x0d
    21a6:	26 01       	movw	r4, r12
    21a8:	37 01       	movw	r6, r14
    21aa:	e8 94       	clt
    21ac:	77 f8       	bld	r7, 7
    21ae:	29 e1       	ldi	r18, 0x19	; 25
    21b0:	34 e0       	ldi	r19, 0x04	; 4
    21b2:	46 e0       	ldi	r20, 0x06	; 6
    21b4:	5f e3       	ldi	r21, 0x3F	; 63
    21b6:	c3 01       	movw	r24, r6
    21b8:	b2 01       	movw	r22, r4
    21ba:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    21be:	18 16       	cp	r1, r24
    21c0:	7c f0       	brlt	.+30     	; 0x21e0 <vMainPoseControllerTask+0x422>
					doneTurning = FALSE;
				} else if (fabs(thetaDiff) < driveThreshold){
    21c2:	22 e7       	ldi	r18, 0x72	; 114
    21c4:	3a e8       	ldi	r19, 0x8A	; 138
    21c6:	4e e8       	ldi	r20, 0x8E	; 142
    21c8:	5c e3       	ldi	r21, 0x3C	; 60
    21ca:	c3 01       	movw	r24, r6
    21cc:	b2 01       	movw	r22, r4
    21ce:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    21d2:	88 23       	and	r24, r24
    21d4:	44 f4       	brge	.+16     	; 0x21e6 <vMainPoseControllerTask+0x428>
					doneTurning = TRUE;
    21d6:	91 e0       	ldi	r25, 0x01	; 1
    21d8:	62 96       	adiw	r28, 0x12	; 18
    21da:	9f af       	std	Y+63, r25	; 0x3f
    21dc:	62 97       	sbiw	r28, 0x12	; 18
    21de:	03 c0       	rjmp	.+6      	; 0x21e6 <vMainPoseControllerTask+0x428>
				thetaDiff = thetaTargt-thetahat; //Might be outside pi to -pi degrees
				vFunc_Inf2pi(&thetaDiff);
				
				//Hysteresis mechanics
				if (fabs(thetaDiff) > rotateThreshold){
					doneTurning = FALSE;
    21e0:	62 96       	adiw	r28, 0x12	; 18
    21e2:	1f ae       	std	Y+63, r1	; 0x3f
    21e4:	62 97       	sbiw	r28, 0x12	; 18
				} else if (fabs(thetaDiff) < driveThreshold){
					doneTurning = TRUE;
				}
				
				if ((prevThetaDiff-thetaDiff)>(M_PI/2) || ((prevThetaDiff-thetaDiff)<(-M_PI/2))) // Gone past target or new target
    21e6:	a7 01       	movw	r20, r14
    21e8:	96 01       	movw	r18, r12
    21ea:	6b a1       	ldd	r22, Y+35	; 0x23
    21ec:	7c a1       	ldd	r23, Y+36	; 0x24
    21ee:	8d a1       	ldd	r24, Y+37	; 0x25
    21f0:	9e a1       	ldd	r25, Y+38	; 0x26
    21f2:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    21f6:	6b 01       	movw	r12, r22
    21f8:	7c 01       	movw	r14, r24
    21fa:	2b ed       	ldi	r18, 0xDB	; 219
    21fc:	3f e0       	ldi	r19, 0x0F	; 15
    21fe:	49 ec       	ldi	r20, 0xC9	; 201
    2200:	5f e3       	ldi	r21, 0x3F	; 63
    2202:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    2206:	18 16       	cp	r1, r24
    2208:	54 f0       	brlt	.+20     	; 0x221e <__stack+0x1f>
    220a:	2b ed       	ldi	r18, 0xDB	; 219
    220c:	3f e0       	ldi	r19, 0x0F	; 15
    220e:	49 ec       	ldi	r20, 0xC9	; 201
    2210:	5f eb       	ldi	r21, 0xBF	; 191
    2212:	c7 01       	movw	r24, r14
    2214:	b6 01       	movw	r22, r12
    2216:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    221a:	88 23       	and	r24, r24
    221c:	4c f4       	brge	.+18     	; 0x2230 <__stack+0x31>
				{
					StartDiff = thetaTargt-thetahat;
    221e:	88 8e       	std	Y+24, r8	; 0x18
    2220:	99 8e       	std	Y+25, r9	; 0x19
    2222:	aa 8e       	std	Y+26, r10	; 0x1a
    2224:	bb 8e       	std	Y+27, r11	; 0x1b
					distanceStart = distance;
    2226:	bc 8c       	ldd	r11, Y+28	; 0x1c
    2228:	a8 a0       	ldd	r10, Y+32	; 0x20
    222a:	99 a0       	ldd	r9, Y+33	; 0x21
    222c:	8a a0       	ldd	r8, Y+34	; 0x22
    222e:	38 c0       	rjmp	.+112    	; 0x22a0 <__stack+0xa1>
				} else {
					distanceStart = (float)sqrt((xTargt-xhatStart)*(xTargt-xhatStart) + (yTargt-yhatStart)*(yTargt-yhatStart)); // KAN KANSKJE BLI FEIL VED ROTATSJON I STARTEN. ROBOTEN ROTERER IKKE HELT STATISK S XHAT OG YHAT KAN VRE FEIL
    2230:	ae 96       	adiw	r28, 0x2e	; 46
    2232:	2c ad       	ldd	r18, Y+60	; 0x3c
    2234:	3d ad       	ldd	r19, Y+61	; 0x3d
    2236:	4e ad       	ldd	r20, Y+62	; 0x3e
    2238:	5f ad       	ldd	r21, Y+63	; 0x3f
    223a:	ae 97       	sbiw	r28, 0x2e	; 46
    223c:	6b ad       	ldd	r22, Y+59	; 0x3b
    223e:	7c ad       	ldd	r23, Y+60	; 0x3c
    2240:	8d ad       	ldd	r24, Y+61	; 0x3d
    2242:	9e ad       	ldd	r25, Y+62	; 0x3e
    2244:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    2248:	4b 01       	movw	r8, r22
    224a:	5c 01       	movw	r10, r24
    224c:	e2 96       	adiw	r28, 0x32	; 50
    224e:	2c ad       	ldd	r18, Y+60	; 0x3c
    2250:	3d ad       	ldd	r19, Y+61	; 0x3d
    2252:	4e ad       	ldd	r20, Y+62	; 0x3e
    2254:	5f ad       	ldd	r21, Y+63	; 0x3f
    2256:	e2 97       	sbiw	r28, 0x32	; 50
    2258:	23 96       	adiw	r28, 0x03	; 3
    225a:	6c ad       	ldd	r22, Y+60	; 0x3c
    225c:	7d ad       	ldd	r23, Y+61	; 0x3d
    225e:	8e ad       	ldd	r24, Y+62	; 0x3e
    2260:	9f ad       	ldd	r25, Y+63	; 0x3f
    2262:	23 97       	sbiw	r28, 0x03	; 3
    2264:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    2268:	6b 01       	movw	r12, r22
    226a:	7c 01       	movw	r14, r24
    226c:	a5 01       	movw	r20, r10
    226e:	94 01       	movw	r18, r8
    2270:	c5 01       	movw	r24, r10
    2272:	b4 01       	movw	r22, r8
    2274:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2278:	4b 01       	movw	r8, r22
    227a:	5c 01       	movw	r10, r24
    227c:	a7 01       	movw	r20, r14
    227e:	96 01       	movw	r18, r12
    2280:	c7 01       	movw	r24, r14
    2282:	b6 01       	movw	r22, r12
    2284:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2288:	9b 01       	movw	r18, r22
    228a:	ac 01       	movw	r20, r24
    228c:	c5 01       	movw	r24, r10
    228e:	b4 01       	movw	r22, r8
    2290:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    2294:	0e 94 07 37 	call	0x6e0e	; 0x6e0e <sqrt>
    2298:	b6 2e       	mov	r11, r22
    229a:	a7 2e       	mov	r10, r23
    229c:	98 2e       	mov	r9, r24
    229e:	89 2e       	mov	r8, r25
				}
				
				vFunc_Inf2pi(&StartDiff);
    22a0:	ce 01       	movw	r24, r28
    22a2:	48 96       	adiw	r24, 0x18	; 24
    22a4:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
				StartDiff = fabs(StartDiff);
    22a8:	c8 8c       	ldd	r12, Y+24	; 0x18
    22aa:	d9 8c       	ldd	r13, Y+25	; 0x19
    22ac:	ea 8c       	ldd	r14, Y+26	; 0x1a
    22ae:	fb 8c       	ldd	r15, Y+27	; 0x1b
    22b0:	e8 94       	clt
    22b2:	f7 f8       	bld	r15, 7
    22b4:	c8 8e       	std	Y+24, r12	; 0x18
    22b6:	d9 8e       	std	Y+25, r13	; 0x19
    22b8:	ea 8e       	std	Y+26, r14	; 0x1a
    22ba:	fb 8e       	std	Y+27, r15	; 0x1b
				
				
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
				if(distanceStart > 0 && distanceStart < (speedIncreaseThreshold+speedDecreaseThreshold)){ // Check if distance is shorter than upramp threshold + downramp threshold
    22bc:	20 e0       	ldi	r18, 0x00	; 0
    22be:	30 e0       	ldi	r19, 0x00	; 0
    22c0:	a9 01       	movw	r20, r18
    22c2:	6b 2d       	mov	r22, r11
    22c4:	7a 2d       	mov	r23, r10
    22c6:	89 2d       	mov	r24, r9
    22c8:	98 2d       	mov	r25, r8
    22ca:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    22ce:	18 16       	cp	r1, r24
    22d0:	0c f0       	brlt	.+2      	; 0x22d4 <__stack+0xd5>
    22d2:	86 c0       	rjmp	.+268    	; 0x23e0 <__stack+0x1e1>
    22d4:	2f a1       	ldd	r18, Y+39	; 0x27
    22d6:	38 a5       	ldd	r19, Y+40	; 0x28
    22d8:	49 a5       	ldd	r20, Y+41	; 0x29
    22da:	5a a5       	ldd	r21, Y+42	; 0x2a
    22dc:	6b a9       	ldd	r22, Y+51	; 0x33
    22de:	7c a9       	ldd	r23, Y+52	; 0x34
    22e0:	8d a9       	ldd	r24, Y+53	; 0x35
    22e2:	9e a9       	ldd	r25, Y+54	; 0x36
    22e4:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    22e8:	9b 01       	movw	r18, r22
    22ea:	ac 01       	movw	r20, r24
    22ec:	6b 2d       	mov	r22, r11
    22ee:	7a 2d       	mov	r23, r10
    22f0:	89 2d       	mov	r24, r9
    22f2:	98 2d       	mov	r25, r8
    22f4:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    22f8:	88 23       	and	r24, r24
    22fa:	0c f0       	brlt	.+2      	; 0x22fe <__stack+0xff>
    22fc:	98 c0       	rjmp	.+304    	; 0x242e <__stack+0x22f>
					float temp_inc = speedIncreaseThreshold;
					float temp_dec = speedDecreaseThreshold;
					speedIncreaseThreshold = distanceStart/4; // scale increase threshold to 1/4 of the Start distance
    22fe:	20 e0       	ldi	r18, 0x00	; 0
    2300:	30 e0       	ldi	r19, 0x00	; 0
    2302:	40 e8       	ldi	r20, 0x80	; 128
    2304:	5e e3       	ldi	r21, 0x3E	; 62
    2306:	6b 2d       	mov	r22, r11
    2308:	7a 2d       	mov	r23, r10
    230a:	89 2d       	mov	r24, r9
    230c:	98 2d       	mov	r25, r8
    230e:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2312:	76 2e       	mov	r7, r22
    2314:	67 2e       	mov	r6, r23
    2316:	58 2e       	mov	r5, r24
    2318:	49 2e       	mov	r4, r25
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
    231a:	20 e0       	ldi	r18, 0x00	; 0
    231c:	30 e0       	ldi	r19, 0x00	; 0
    231e:	40 e4       	ldi	r20, 0x40	; 64
    2320:	50 e4       	ldi	r21, 0x40	; 64
    2322:	6b 2d       	mov	r22, r11
    2324:	7a 2d       	mov	r23, r10
    2326:	89 2d       	mov	r24, r9
    2328:	98 2d       	mov	r25, r8
    232a:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    232e:	20 e0       	ldi	r18, 0x00	; 0
    2330:	30 e0       	ldi	r19, 0x00	; 0
    2332:	40 e8       	ldi	r20, 0x80	; 128
    2334:	5e e3       	ldi	r21, 0x3E	; 62
    2336:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    233a:	a3 96       	adiw	r28, 0x23	; 35
    233c:	6f af       	std	Y+63, r22	; 0x3f
    233e:	a3 97       	sbiw	r28, 0x23	; 35
    2340:	a4 96       	adiw	r28, 0x24	; 36
    2342:	7f af       	std	Y+63, r23	; 0x3f
    2344:	a4 97       	sbiw	r28, 0x24	; 36
    2346:	a5 96       	adiw	r28, 0x25	; 37
    2348:	8f af       	std	Y+63, r24	; 0x3f
    234a:	a5 97       	sbiw	r28, 0x25	; 37
    234c:	a6 96       	adiw	r28, 0x26	; 38
    234e:	9f af       	std	Y+63, r25	; 0x3f
    2350:	a6 97       	sbiw	r28, 0x26	; 38
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
    2352:	2f a1       	ldd	r18, Y+39	; 0x27
    2354:	38 a5       	ldd	r19, Y+40	; 0x28
    2356:	49 a5       	ldd	r20, Y+41	; 0x29
    2358:	5a a5       	ldd	r21, Y+42	; 0x2a
    235a:	67 2d       	mov	r22, r7
    235c:	76 2d       	mov	r23, r6
    235e:	85 2d       	mov	r24, r5
    2360:	94 2d       	mov	r25, r4
    2362:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    2366:	6b a3       	std	Y+35, r22	; 0x23
    2368:	6c 96       	adiw	r28, 0x1c	; 28
    236a:	7f af       	std	Y+63, r23	; 0x3f
    236c:	6c 97       	sbiw	r28, 0x1c	; 28
    236e:	6d 96       	adiw	r28, 0x1d	; 29
    2370:	8f af       	std	Y+63, r24	; 0x3f
    2372:	6d 97       	sbiw	r28, 0x1d	; 29
    2374:	6e 96       	adiw	r28, 0x1e	; 30
    2376:	9f af       	std	Y+63, r25	; 0x3f
    2378:	6e 97       	sbiw	r28, 0x1e	; 30
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
    237a:	2b a9       	ldd	r18, Y+51	; 0x33
    237c:	3c a9       	ldd	r19, Y+52	; 0x34
    237e:	4d a9       	ldd	r20, Y+53	; 0x35
    2380:	5e a9       	ldd	r21, Y+54	; 0x36
    2382:	a3 96       	adiw	r28, 0x23	; 35
    2384:	6f ad       	ldd	r22, Y+63	; 0x3f
    2386:	a3 97       	sbiw	r28, 0x23	; 35
    2388:	a4 96       	adiw	r28, 0x24	; 36
    238a:	7f ad       	ldd	r23, Y+63	; 0x3f
    238c:	a4 97       	sbiw	r28, 0x24	; 36
    238e:	a5 96       	adiw	r28, 0x25	; 37
    2390:	8f ad       	ldd	r24, Y+63	; 0x3f
    2392:	a5 97       	sbiw	r28, 0x25	; 37
    2394:	a6 96       	adiw	r28, 0x26	; 38
    2396:	9f ad       	ldd	r25, Y+63	; 0x3f
    2398:	a6 97       	sbiw	r28, 0x26	; 38
    239a:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    239e:	6f 96       	adiw	r28, 0x1f	; 31
    23a0:	6f af       	std	Y+63, r22	; 0x3f
    23a2:	6f 97       	sbiw	r28, 0x1f	; 31
    23a4:	a0 96       	adiw	r28, 0x20	; 32
    23a6:	7f af       	std	Y+63, r23	; 0x3f
    23a8:	a0 97       	sbiw	r28, 0x20	; 32
    23aa:	a1 96       	adiw	r28, 0x21	; 33
    23ac:	8f af       	std	Y+63, r24	; 0x3f
    23ae:	a1 97       	sbiw	r28, 0x21	; 33
    23b0:	a2 96       	adiw	r28, 0x22	; 34
    23b2:	9f af       	std	Y+63, r25	; 0x3f
    23b4:	a2 97       	sbiw	r28, 0x22	; 34
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
				if(distanceStart > 0 && distanceStart < (speedIncreaseThreshold+speedDecreaseThreshold)){ // Check if distance is shorter than upramp threshold + downramp threshold
					float temp_inc = speedIncreaseThreshold;
					float temp_dec = speedDecreaseThreshold;
					speedIncreaseThreshold = distanceStart/4; // scale increase threshold to 1/4 of the Start distance
    23b6:	7f a2       	std	Y+39, r7	; 0x27
    23b8:	68 a6       	std	Y+40, r6	; 0x28
    23ba:	59 a6       	std	Y+41, r5	; 0x29
    23bc:	4a a6       	std	Y+42, r4	; 0x2a
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
    23be:	a3 96       	adiw	r28, 0x23	; 35
    23c0:	af ad       	ldd	r26, Y+63	; 0x3f
    23c2:	a3 97       	sbiw	r28, 0x23	; 35
    23c4:	ab ab       	std	Y+51, r26	; 0x33
    23c6:	a4 96       	adiw	r28, 0x24	; 36
    23c8:	bf ad       	ldd	r27, Y+63	; 0x3f
    23ca:	a4 97       	sbiw	r28, 0x24	; 36
    23cc:	bc ab       	std	Y+52, r27	; 0x34
    23ce:	a5 96       	adiw	r28, 0x25	; 37
    23d0:	2f ad       	ldd	r18, Y+63	; 0x3f
    23d2:	a5 97       	sbiw	r28, 0x25	; 37
    23d4:	2d ab       	std	Y+53, r18	; 0x35
    23d6:	a6 96       	adiw	r28, 0x26	; 38
    23d8:	4f ad       	ldd	r20, Y+63	; 0x3f
    23da:	a6 97       	sbiw	r28, 0x26	; 38
    23dc:	4e ab       	std	Y+54, r20	; 0x36
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
				if(distanceStart > 0 && distanceStart < (speedIncreaseThreshold+speedDecreaseThreshold)){ // Check if distance is shorter than upramp threshold + downramp threshold
    23de:	4d c0       	rjmp	.+154    	; 0x247a <__stack+0x27b>
				vFunc_Inf2pi(&StartDiff);
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
    23e0:	6f 96       	adiw	r28, 0x1f	; 31
    23e2:	1f ae       	std	Y+63, r1	; 0x3f
    23e4:	6f 97       	sbiw	r28, 0x1f	; 31
    23e6:	a0 96       	adiw	r28, 0x20	; 32
    23e8:	1f ae       	std	Y+63, r1	; 0x3f
    23ea:	a0 97       	sbiw	r28, 0x20	; 32
    23ec:	80 e8       	ldi	r24, 0x80	; 128
    23ee:	a1 96       	adiw	r28, 0x21	; 33
    23f0:	8f af       	std	Y+63, r24	; 0x3f
    23f2:	a1 97       	sbiw	r28, 0x21	; 33
    23f4:	9f e3       	ldi	r25, 0x3F	; 63
    23f6:	a2 96       	adiw	r28, 0x22	; 34
    23f8:	9f af       	std	Y+63, r25	; 0x3f
    23fa:	a2 97       	sbiw	r28, 0x22	; 34
				
				vFunc_Inf2pi(&StartDiff);
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
    23fc:	1b a2       	std	Y+35, r1	; 0x23
    23fe:	6c 96       	adiw	r28, 0x1c	; 28
    2400:	1f ae       	std	Y+63, r1	; 0x3f
    2402:	6c 97       	sbiw	r28, 0x1c	; 28
    2404:	a0 e8       	ldi	r26, 0x80	; 128
    2406:	6d 96       	adiw	r28, 0x1d	; 29
    2408:	af af       	std	Y+63, r26	; 0x3f
    240a:	6d 97       	sbiw	r28, 0x1d	; 29
    240c:	bf e3       	ldi	r27, 0x3F	; 63
    240e:	6e 96       	adiw	r28, 0x1e	; 30
    2410:	bf af       	std	Y+63, r27	; 0x3f
    2412:	6e 97       	sbiw	r28, 0x1e	; 30
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
				} else {
					speedDecreaseThreshold = 300;
					speedIncreaseThreshold = 100;
    2414:	1f a2       	std	Y+39, r1	; 0x27
    2416:	18 a6       	std	Y+40, r1	; 0x28
    2418:	28 ec       	ldi	r18, 0xC8	; 200
    241a:	29 a7       	std	Y+41, r18	; 0x29
    241c:	42 e4       	ldi	r20, 0x42	; 66
    241e:	4a a7       	std	Y+42, r20	; 0x2a
					speedIncreaseThreshold = distanceStart/4; // scale increase threshold to 1/4 of the Start distance
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
				} else {
					speedDecreaseThreshold = 300;
    2420:	1b aa       	std	Y+51, r1	; 0x33
    2422:	1c aa       	std	Y+52, r1	; 0x34
    2424:	86 e9       	ldi	r24, 0x96	; 150
    2426:	8d ab       	std	Y+53, r24	; 0x35
    2428:	93 e4       	ldi	r25, 0x43	; 67
    242a:	9e ab       	std	Y+54, r25	; 0x36
    242c:	26 c0       	rjmp	.+76     	; 0x247a <__stack+0x27b>
				vFunc_Inf2pi(&StartDiff);
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
    242e:	6f 96       	adiw	r28, 0x1f	; 31
    2430:	1f ae       	std	Y+63, r1	; 0x3f
    2432:	6f 97       	sbiw	r28, 0x1f	; 31
    2434:	a0 96       	adiw	r28, 0x20	; 32
    2436:	1f ae       	std	Y+63, r1	; 0x3f
    2438:	a0 97       	sbiw	r28, 0x20	; 32
    243a:	a0 e8       	ldi	r26, 0x80	; 128
    243c:	a1 96       	adiw	r28, 0x21	; 33
    243e:	af af       	std	Y+63, r26	; 0x3f
    2440:	a1 97       	sbiw	r28, 0x21	; 33
    2442:	bf e3       	ldi	r27, 0x3F	; 63
    2444:	a2 96       	adiw	r28, 0x22	; 34
    2446:	bf af       	std	Y+63, r27	; 0x3f
    2448:	a2 97       	sbiw	r28, 0x22	; 34
				
				vFunc_Inf2pi(&StartDiff);
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
    244a:	1b a2       	std	Y+35, r1	; 0x23
    244c:	6c 96       	adiw	r28, 0x1c	; 28
    244e:	1f ae       	std	Y+63, r1	; 0x3f
    2450:	6c 97       	sbiw	r28, 0x1c	; 28
    2452:	20 e8       	ldi	r18, 0x80	; 128
    2454:	6d 96       	adiw	r28, 0x1d	; 29
    2456:	2f af       	std	Y+63, r18	; 0x3f
    2458:	6d 97       	sbiw	r28, 0x1d	; 29
    245a:	4f e3       	ldi	r20, 0x3F	; 63
    245c:	6e 96       	adiw	r28, 0x1e	; 30
    245e:	4f af       	std	Y+63, r20	; 0x3f
    2460:	6e 97       	sbiw	r28, 0x1e	; 30
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
				} else {
					speedDecreaseThreshold = 300;
					speedIncreaseThreshold = 100;
    2462:	1f a2       	std	Y+39, r1	; 0x27
    2464:	18 a6       	std	Y+40, r1	; 0x28
    2466:	88 ec       	ldi	r24, 0xC8	; 200
    2468:	89 a7       	std	Y+41, r24	; 0x29
    246a:	92 e4       	ldi	r25, 0x42	; 66
    246c:	9a a7       	std	Y+42, r25	; 0x2a
					speedIncreaseThreshold = distanceStart/4; // scale increase threshold to 1/4 of the Start distance
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
				} else {
					speedDecreaseThreshold = 300;
    246e:	1b aa       	std	Y+51, r1	; 0x33
    2470:	1c aa       	std	Y+52, r1	; 0x34
    2472:	a6 e9       	ldi	r26, 0x96	; 150
    2474:	ad ab       	std	Y+53, r26	; 0x35
    2476:	b3 e4       	ldi	r27, 0x43	; 67
    2478:	be ab       	std	Y+54, r27	; 0x36
					speedIncreaseThreshold = 100;
				}
				
				if(distance > radiusEpsilon){//Not close enough to target
    247a:	20 e0       	ldi	r18, 0x00	; 0
    247c:	30 e0       	ldi	r19, 0x00	; 0
    247e:	40 e7       	ldi	r20, 0x70	; 112
    2480:	51 e4       	ldi	r21, 0x41	; 65
    2482:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2484:	78 a1       	ldd	r23, Y+32	; 0x20
    2486:	89 a1       	ldd	r24, Y+33	; 0x21
    2488:	9a a1       	ldd	r25, Y+34	; 0x22
    248a:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    248e:	18 16       	cp	r1, r24
    2490:	0c f0       	brlt	.+2      	; 0x2494 <__stack+0x295>
    2492:	bb c4       	rjmp	.+2422   	; 0x2e0a <__stack+0xc0b>
					
					
				
					idleSendt = FALSE;
				
					if (doneTurning){//Start forward movement
    2494:	62 96       	adiw	r28, 0x12	; 18
    2496:	2f ad       	ldd	r18, Y+63	; 0x3f
    2498:	62 97       	sbiw	r28, 0x12	; 18
    249a:	22 23       	and	r18, r18
    249c:	09 f4       	brne	.+2      	; 0x24a0 <__stack+0x2a1>
    249e:	5b c2       	rjmp	.+1206   	; 0x2956 <__stack+0x757>
						//debug("Done Turning");
						stuckRotLeft = 0;
						stuckRotRight = 0;
						float distanceTraveled = distanceStart-distance;
    24a0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    24a2:	38 a1       	ldd	r19, Y+32	; 0x20
    24a4:	49 a1       	ldd	r20, Y+33	; 0x21
    24a6:	5a a1       	ldd	r21, Y+34	; 0x22
    24a8:	6b 2d       	mov	r22, r11
    24aa:	7a 2d       	mov	r23, r10
    24ac:	89 2d       	mov	r24, r9
    24ae:	98 2d       	mov	r25, r8
    24b0:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    24b4:	4b 01       	movw	r8, r22
    24b6:	5c 01       	movw	r10, r24
						
						// Ramp up
						if (distanceTraveled >= 0 && distanceTraveled <= speedIncreaseThreshold){
    24b8:	20 e0       	ldi	r18, 0x00	; 0
    24ba:	30 e0       	ldi	r19, 0x00	; 0
    24bc:	a9 01       	movw	r20, r18
    24be:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    24c2:	88 23       	and	r24, r24
    24c4:	0c f4       	brge	.+2      	; 0x24c8 <__stack+0x2c9>
    24c6:	ad c0       	rjmp	.+346    	; 0x2622 <__stack+0x423>
    24c8:	a5 01       	movw	r20, r10
    24ca:	94 01       	movw	r18, r8
    24cc:	6f a1       	ldd	r22, Y+39	; 0x27
    24ce:	78 a5       	ldd	r23, Y+40	; 0x28
    24d0:	89 a5       	ldd	r24, Y+41	; 0x29
    24d2:	9a a5       	ldd	r25, Y+42	; 0x2a
    24d4:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    24d8:	88 23       	and	r24, r24
    24da:	0c f4       	brge	.+2      	; 0x24de <__stack+0x2df>
    24dc:	a2 c0       	rjmp	.+324    	; 0x2622 <__stack+0x423>
							if (!bBaseUpRampActFound){
    24de:	e5 96       	adiw	r28, 0x35	; 53
    24e0:	4f ad       	ldd	r20, Y+63	; 0x3f
    24e2:	e5 97       	sbiw	r28, 0x35	; 53
    24e4:	41 11       	cpse	r20, r1
    24e6:	33 c0       	rjmp	.+102    	; 0x254e <__stack+0x34f>
								if (distanceTraveled < 15){
    24e8:	20 e0       	ldi	r18, 0x00	; 0
    24ea:	30 e0       	ldi	r19, 0x00	; 0
    24ec:	40 e7       	ldi	r20, 0x70	; 112
    24ee:	51 e4       	ldi	r21, 0x41	; 65
    24f0:	c5 01       	movw	r24, r10
    24f2:	b4 01       	movw	r22, r8
    24f4:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    24f8:	88 23       	and	r24, r24
    24fa:	44 f4       	brge	.+16     	; 0x250c <__stack+0x30d>
									baseUpRampActuation++;
    24fc:	a7 96       	adiw	r28, 0x27	; 39
    24fe:	8f ad       	ldd	r24, Y+63	; 0x3f
    2500:	a7 97       	sbiw	r28, 0x27	; 39
    2502:	8f 5f       	subi	r24, 0xFF	; 255
    2504:	a7 96       	adiw	r28, 0x27	; 39
    2506:	8f af       	std	Y+63, r24	; 0x3f
    2508:	a7 97       	sbiw	r28, 0x27	; 39
    250a:	3e c0       	rjmp	.+124    	; 0x2588 <__stack+0x389>
								} else {
									bBaseUpRampActFound = TRUE;
									maxDriveActuation = baseUpRampActuation + 10;
    250c:	a7 96       	adiw	r28, 0x27	; 39
    250e:	9f ad       	ldd	r25, Y+63	; 0x3f
    2510:	a7 97       	sbiw	r28, 0x27	; 39
    2512:	96 5f       	subi	r25, 0xF6	; 246
    2514:	e3 96       	adiw	r28, 0x33	; 51
    2516:	9f af       	std	Y+63, r25	; 0x3f
    2518:	e3 97       	sbiw	r28, 0x33	; 51
									baseRotationSpeed = baseUpRampActuation;
									debug("bBaseUp: %i",baseUpRampActuation);
    251a:	1f 92       	push	r1
    251c:	a7 96       	adiw	r28, 0x27	; 39
    251e:	af ad       	ldd	r26, Y+63	; 0x3f
    2520:	a7 97       	sbiw	r28, 0x27	; 39
    2522:	af 93       	push	r26
    2524:	8e e1       	ldi	r24, 0x1E	; 30
    2526:	96 e0       	ldi	r25, 0x06	; 6
    2528:	9f 93       	push	r25
    252a:	8f 93       	push	r24
    252c:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <debug>
    2530:	0f 90       	pop	r0
    2532:	0f 90       	pop	r0
    2534:	0f 90       	pop	r0
    2536:	0f 90       	pop	r0
								if (distanceTraveled < 15){
									baseUpRampActuation++;
								} else {
									bBaseUpRampActFound = TRUE;
									maxDriveActuation = baseUpRampActuation + 10;
									baseRotationSpeed = baseUpRampActuation;
    2538:	a7 96       	adiw	r28, 0x27	; 39
    253a:	bf ad       	ldd	r27, Y+63	; 0x3f
    253c:	a7 97       	sbiw	r28, 0x27	; 39
    253e:	24 96       	adiw	r28, 0x04	; 4
    2540:	bf af       	std	Y+63, r27	; 0x3f
    2542:	24 97       	sbiw	r28, 0x04	; 4
						if (distanceTraveled >= 0 && distanceTraveled <= speedIncreaseThreshold){
							if (!bBaseUpRampActFound){
								if (distanceTraveled < 15){
									baseUpRampActuation++;
								} else {
									bBaseUpRampActFound = TRUE;
    2544:	21 e0       	ldi	r18, 0x01	; 1
    2546:	e5 96       	adiw	r28, 0x35	; 53
    2548:	2f af       	std	Y+63, r18	; 0x3f
    254a:	e5 97       	sbiw	r28, 0x35	; 53
    254c:	1d c0       	rjmp	.+58     	; 0x2588 <__stack+0x389>
									maxDriveActuation = baseUpRampActuation + 10;
									baseRotationSpeed = baseUpRampActuation;
									debug("bBaseUp: %i",baseUpRampActuation);
								}
							} else if (dLeft == 0 || dRight == 0){
    254e:	20 e0       	ldi	r18, 0x00	; 0
    2550:	30 e0       	ldi	r19, 0x00	; 0
    2552:	a9 01       	movw	r20, r18
    2554:	28 96       	adiw	r28, 0x08	; 8
    2556:	6c ad       	ldd	r22, Y+60	; 0x3c
    2558:	7d ad       	ldd	r23, Y+61	; 0x3d
    255a:	8e ad       	ldd	r24, Y+62	; 0x3e
    255c:	9f ad       	ldd	r25, Y+63	; 0x3f
    255e:	28 97       	sbiw	r28, 0x08	; 8
    2560:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2564:	88 23       	and	r24, r24
    2566:	69 f0       	breq	.+26     	; 0x2582 <__stack+0x383>
    2568:	20 e0       	ldi	r18, 0x00	; 0
    256a:	30 e0       	ldi	r19, 0x00	; 0
    256c:	a9 01       	movw	r20, r18
    256e:	2c 96       	adiw	r28, 0x0c	; 12
    2570:	6c ad       	ldd	r22, Y+60	; 0x3c
    2572:	7d ad       	ldd	r23, Y+61	; 0x3d
    2574:	8e ad       	ldd	r24, Y+62	; 0x3e
    2576:	9f ad       	ldd	r25, Y+63	; 0x3f
    2578:	2c 97       	sbiw	r28, 0x0c	; 12
    257a:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    257e:	81 11       	cpse	r24, r1
    2580:	03 c0       	rjmp	.+6      	; 0x2588 <__stack+0x389>
								stuckIncrement+=2;
    2582:	48 ad       	ldd	r20, Y+56	; 0x38
    2584:	4e 5f       	subi	r20, 0xFE	; 254
    2586:	48 af       	std	Y+56, r20	; 0x38
							} else {
								//stuckIncrement = 0;
							}
							//currentDriveActuation = baseUpRampActuation + stuckIncrement;
							
							float minUpDrive = baseUpRampActuation+stuckIncrement;
    2588:	88 ad       	ldd	r24, Y+56	; 0x38
    258a:	68 2f       	mov	r22, r24
    258c:	70 e0       	ldi	r23, 0x00	; 0
    258e:	a7 96       	adiw	r28, 0x27	; 39
    2590:	9f ad       	ldd	r25, Y+63	; 0x3f
    2592:	a7 97       	sbiw	r28, 0x27	; 39
    2594:	69 0f       	add	r22, r25
    2596:	71 1d       	adc	r23, r1
    2598:	07 2e       	mov	r0, r23
    259a:	00 0c       	add	r0, r0
    259c:	88 0b       	sbc	r24, r24
    259e:	99 0b       	sbc	r25, r25
    25a0:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    25a4:	2b 01       	movw	r4, r22
    25a6:	3c 01       	movw	r6, r24
							currentDriveActuation =	((((100-minUpDrive)/100)*(maxDriveActuation*shortDistIncRatio))*distanceTraveled/speedIncreaseThreshold) + (baseUpRampActuation+stuckIncrement);
    25a8:	9b 01       	movw	r18, r22
    25aa:	ac 01       	movw	r20, r24
    25ac:	60 e0       	ldi	r22, 0x00	; 0
    25ae:	70 e0       	ldi	r23, 0x00	; 0
    25b0:	88 ec       	ldi	r24, 0xC8	; 200
    25b2:	92 e4       	ldi	r25, 0x42	; 66
    25b4:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    25b8:	20 e0       	ldi	r18, 0x00	; 0
    25ba:	30 e0       	ldi	r19, 0x00	; 0
    25bc:	48 ec       	ldi	r20, 0xC8	; 200
    25be:	52 e4       	ldi	r21, 0x42	; 66
    25c0:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    25c4:	6b 01       	movw	r12, r22
    25c6:	7c 01       	movw	r14, r24
    25c8:	e3 96       	adiw	r28, 0x33	; 51
    25ca:	af ad       	ldd	r26, Y+63	; 0x3f
    25cc:	e3 97       	sbiw	r28, 0x33	; 51
    25ce:	6a 2f       	mov	r22, r26
    25d0:	70 e0       	ldi	r23, 0x00	; 0
    25d2:	80 e0       	ldi	r24, 0x00	; 0
    25d4:	90 e0       	ldi	r25, 0x00	; 0
    25d6:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    25da:	2b a1       	ldd	r18, Y+35	; 0x23
    25dc:	6c 96       	adiw	r28, 0x1c	; 28
    25de:	3f ad       	ldd	r19, Y+63	; 0x3f
    25e0:	6c 97       	sbiw	r28, 0x1c	; 28
    25e2:	6d 96       	adiw	r28, 0x1d	; 29
    25e4:	4f ad       	ldd	r20, Y+63	; 0x3f
    25e6:	6d 97       	sbiw	r28, 0x1d	; 29
    25e8:	6e 96       	adiw	r28, 0x1e	; 30
    25ea:	5f ad       	ldd	r21, Y+63	; 0x3f
    25ec:	6e 97       	sbiw	r28, 0x1e	; 30
    25ee:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    25f2:	9b 01       	movw	r18, r22
    25f4:	ac 01       	movw	r20, r24
    25f6:	c7 01       	movw	r24, r14
    25f8:	b6 01       	movw	r22, r12
    25fa:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    25fe:	a5 01       	movw	r20, r10
    2600:	94 01       	movw	r18, r8
    2602:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2606:	2f a1       	ldd	r18, Y+39	; 0x27
    2608:	38 a5       	ldd	r19, Y+40	; 0x28
    260a:	49 a5       	ldd	r20, Y+41	; 0x29
    260c:	5a a5       	ldd	r21, Y+42	; 0x2a
    260e:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    2612:	a3 01       	movw	r20, r6
    2614:	92 01       	movw	r18, r4
    2616:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    261a:	0e 94 53 35 	call	0x6aa6	; 0x6aa6 <__fixunssfsi>
    261e:	16 2f       	mov	r17, r22
						stuckRotLeft = 0;
						stuckRotRight = 0;
						float distanceTraveled = distanceStart-distance;
						
						// Ramp up
						if (distanceTraveled >= 0 && distanceTraveled <= speedIncreaseThreshold){
    2620:	b8 c0       	rjmp	.+368    	; 0x2792 <__stack+0x593>
							float minUpDrive = baseUpRampActuation+stuckIncrement;
							currentDriveActuation =	((((100-minUpDrive)/100)*(maxDriveActuation*shortDistIncRatio))*distanceTraveled/speedIncreaseThreshold) + (baseUpRampActuation+stuckIncrement);
						}
						
						// Ramp down
						else if (distance < speedDecreaseThreshold){
    2622:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2624:	38 a1       	ldd	r19, Y+32	; 0x20
    2626:	49 a1       	ldd	r20, Y+33	; 0x21
    2628:	5a a1       	ldd	r21, Y+34	; 0x22
    262a:	6b a9       	ldd	r22, Y+51	; 0x33
    262c:	7c a9       	ldd	r23, Y+52	; 0x34
    262e:	8d a9       	ldd	r24, Y+53	; 0x35
    2630:	9e a9       	ldd	r25, Y+54	; 0x36
    2632:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    2636:	18 16       	cp	r1, r24
    2638:	0c f0       	brlt	.+2      	; 0x263c <__stack+0x43d>
    263a:	a8 c0       	rjmp	.+336    	; 0x278c <__stack+0x58d>
							if (distance >50){
    263c:	20 e0       	ldi	r18, 0x00	; 0
    263e:	30 e0       	ldi	r19, 0x00	; 0
    2640:	48 e4       	ldi	r20, 0x48	; 72
    2642:	52 e4       	ldi	r21, 0x42	; 66
    2644:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2646:	78 a1       	ldd	r23, Y+32	; 0x20
    2648:	89 a1       	ldd	r24, Y+33	; 0x21
    264a:	9a a1       	ldd	r25, Y+34	; 0x22
    264c:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    2650:	18 16       	cp	r1, r24
    2652:	2c f5       	brge	.+74     	; 0x269e <__stack+0x49f>
								if (dLeft == 0 || dRight == 0){
    2654:	20 e0       	ldi	r18, 0x00	; 0
    2656:	30 e0       	ldi	r19, 0x00	; 0
    2658:	a9 01       	movw	r20, r18
    265a:	28 96       	adiw	r28, 0x08	; 8
    265c:	6c ad       	ldd	r22, Y+60	; 0x3c
    265e:	7d ad       	ldd	r23, Y+61	; 0x3d
    2660:	8e ad       	ldd	r24, Y+62	; 0x3e
    2662:	9f ad       	ldd	r25, Y+63	; 0x3f
    2664:	28 97       	sbiw	r28, 0x08	; 8
    2666:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    266a:	88 23       	and	r24, r24
    266c:	81 f0       	breq	.+32     	; 0x268e <__stack+0x48f>
    266e:	20 e0       	ldi	r18, 0x00	; 0
    2670:	30 e0       	ldi	r19, 0x00	; 0
    2672:	a9 01       	movw	r20, r18
    2674:	2c 96       	adiw	r28, 0x0c	; 12
    2676:	6c ad       	ldd	r22, Y+60	; 0x3c
    2678:	7d ad       	ldd	r23, Y+61	; 0x3d
    267a:	8e ad       	ldd	r24, Y+62	; 0x3e
    267c:	9f ad       	ldd	r25, Y+63	; 0x3f
    267e:	2c 97       	sbiw	r28, 0x0c	; 12
    2680:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2684:	81 11       	cpse	r24, r1
    2686:	05 c0       	rjmp	.+10     	; 0x2692 <__stack+0x493>
									stuckIncrement=2;
    2688:	b2 e0       	ldi	r27, 0x02	; 2
    268a:	b8 af       	std	Y+56, r27	; 0x38
    268c:	02 c0       	rjmp	.+4      	; 0x2692 <__stack+0x493>
    268e:	22 e0       	ldi	r18, 0x02	; 2
    2690:	28 af       	std	Y+56, r18	; 0x38
								} else {
									//stuckIncrement = 0;
								}
								currentDriveActuation = baseUpRampActuation + stuckIncrement;
    2692:	18 ad       	ldd	r17, Y+56	; 0x38
    2694:	a7 96       	adiw	r28, 0x27	; 39
    2696:	4f ad       	ldd	r20, Y+63	; 0x3f
    2698:	a7 97       	sbiw	r28, 0x27	; 39
    269a:	14 0f       	add	r17, r20
    269c:	7a c0       	rjmp	.+244    	; 0x2792 <__stack+0x593>
							} else {
								if (prevDist==distance){
    269e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    26a0:	38 a1       	ldd	r19, Y+32	; 0x20
    26a2:	49 a1       	ldd	r20, Y+33	; 0x21
    26a4:	5a a1       	ldd	r21, Y+34	; 0x22
    26a6:	63 96       	adiw	r28, 0x13	; 19
    26a8:	6f ad       	ldd	r22, Y+63	; 0x3f
    26aa:	63 97       	sbiw	r28, 0x13	; 19
    26ac:	64 96       	adiw	r28, 0x14	; 20
    26ae:	7f ad       	ldd	r23, Y+63	; 0x3f
    26b0:	64 97       	sbiw	r28, 0x14	; 20
    26b2:	65 96       	adiw	r28, 0x15	; 21
    26b4:	8f ad       	ldd	r24, Y+63	; 0x3f
    26b6:	65 97       	sbiw	r28, 0x15	; 21
    26b8:	66 96       	adiw	r28, 0x16	; 22
    26ba:	9f ad       	ldd	r25, Y+63	; 0x3f
    26bc:	66 97       	sbiw	r28, 0x16	; 22
    26be:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    26c2:	81 11       	cpse	r24, r1
    26c4:	0c c0       	rjmp	.+24     	; 0x26de <__stack+0x4df>
									stuckIncrement= baseUpRampActuation-baseDownRampActuation;
    26c6:	a7 96       	adiw	r28, 0x27	; 39
    26c8:	8f ad       	ldd	r24, Y+63	; 0x3f
    26ca:	a7 97       	sbiw	r28, 0x27	; 39
    26cc:	e4 96       	adiw	r28, 0x34	; 52
    26ce:	9f ad       	ldd	r25, Y+63	; 0x3f
    26d0:	e4 97       	sbiw	r28, 0x34	; 52
    26d2:	89 1b       	sub	r24, r25
    26d4:	88 af       	std	Y+56, r24	; 0x38
									baseDownRampActuation += 5;
    26d6:	9b 5f       	subi	r25, 0xFB	; 251
    26d8:	e4 96       	adiw	r28, 0x34	; 52
    26da:	9f af       	std	Y+63, r25	; 0x3f
    26dc:	e4 97       	sbiw	r28, 0x34	; 52
								} else {
									//stuckIncrement = 0;
								}
								float minDownDrive = (baseDownRampActuation)+stuckIncrement;
    26de:	a8 ad       	ldd	r26, Y+56	; 0x38
    26e0:	6a 2f       	mov	r22, r26
    26e2:	70 e0       	ldi	r23, 0x00	; 0
    26e4:	e4 96       	adiw	r28, 0x34	; 52
    26e6:	bf ad       	ldd	r27, Y+63	; 0x3f
    26e8:	e4 97       	sbiw	r28, 0x34	; 52
    26ea:	6b 0f       	add	r22, r27
    26ec:	71 1d       	adc	r23, r1
    26ee:	07 2e       	mov	r0, r23
    26f0:	00 0c       	add	r0, r0
    26f2:	88 0b       	sbc	r24, r24
    26f4:	99 0b       	sbc	r25, r25
    26f6:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    26fa:	4b 01       	movw	r8, r22
    26fc:	5c 01       	movw	r10, r24
								currentDriveActuation =	((((100-minDownDrive)/100)*(maxDriveActuation*shortDistDecRatio))*(distance/speedDecreaseThreshold)) + ((baseDownRampActuation)+stuckIncrement);
    26fe:	9b 01       	movw	r18, r22
    2700:	ac 01       	movw	r20, r24
    2702:	60 e0       	ldi	r22, 0x00	; 0
    2704:	70 e0       	ldi	r23, 0x00	; 0
    2706:	88 ec       	ldi	r24, 0xC8	; 200
    2708:	92 e4       	ldi	r25, 0x42	; 66
    270a:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    270e:	20 e0       	ldi	r18, 0x00	; 0
    2710:	30 e0       	ldi	r19, 0x00	; 0
    2712:	48 ec       	ldi	r20, 0xC8	; 200
    2714:	52 e4       	ldi	r21, 0x42	; 66
    2716:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    271a:	6b 01       	movw	r12, r22
    271c:	7c 01       	movw	r14, r24
    271e:	e3 96       	adiw	r28, 0x33	; 51
    2720:	2f ad       	ldd	r18, Y+63	; 0x3f
    2722:	e3 97       	sbiw	r28, 0x33	; 51
    2724:	62 2f       	mov	r22, r18
    2726:	70 e0       	ldi	r23, 0x00	; 0
    2728:	80 e0       	ldi	r24, 0x00	; 0
    272a:	90 e0       	ldi	r25, 0x00	; 0
    272c:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2730:	6f 96       	adiw	r28, 0x1f	; 31
    2732:	2f ad       	ldd	r18, Y+63	; 0x3f
    2734:	6f 97       	sbiw	r28, 0x1f	; 31
    2736:	a0 96       	adiw	r28, 0x20	; 32
    2738:	3f ad       	ldd	r19, Y+63	; 0x3f
    273a:	a0 97       	sbiw	r28, 0x20	; 32
    273c:	a1 96       	adiw	r28, 0x21	; 33
    273e:	4f ad       	ldd	r20, Y+63	; 0x3f
    2740:	a1 97       	sbiw	r28, 0x21	; 33
    2742:	a2 96       	adiw	r28, 0x22	; 34
    2744:	5f ad       	ldd	r21, Y+63	; 0x3f
    2746:	a2 97       	sbiw	r28, 0x22	; 34
    2748:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    274c:	9b 01       	movw	r18, r22
    274e:	ac 01       	movw	r20, r24
    2750:	c7 01       	movw	r24, r14
    2752:	b6 01       	movw	r22, r12
    2754:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2758:	6b 01       	movw	r12, r22
    275a:	7c 01       	movw	r14, r24
    275c:	2b a9       	ldd	r18, Y+51	; 0x33
    275e:	3c a9       	ldd	r19, Y+52	; 0x34
    2760:	4d a9       	ldd	r20, Y+53	; 0x35
    2762:	5e a9       	ldd	r21, Y+54	; 0x36
    2764:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2766:	78 a1       	ldd	r23, Y+32	; 0x20
    2768:	89 a1       	ldd	r24, Y+33	; 0x21
    276a:	9a a1       	ldd	r25, Y+34	; 0x22
    276c:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    2770:	9b 01       	movw	r18, r22
    2772:	ac 01       	movw	r20, r24
    2774:	c7 01       	movw	r24, r14
    2776:	b6 01       	movw	r22, r12
    2778:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    277c:	a5 01       	movw	r20, r10
    277e:	94 01       	movw	r18, r8
    2780:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    2784:	0e 94 53 35 	call	0x6aa6	; 0x6aa6 <__fixunssfsi>
    2788:	16 2f       	mov	r17, r22
    278a:	03 c0       	rjmp	.+6      	; 0x2792 <__stack+0x593>
							}
						} else	{
							currentDriveActuation = maxDriveActuation;
    278c:	e3 96       	adiw	r28, 0x33	; 51
    278e:	1f ad       	ldd	r17, Y+63	; 0x3f
    2790:	e3 97       	sbiw	r28, 0x33	; 51
							//currentDriveActuation = baseUpRampActuation;
						}
						
						if (thetaDiff >= 0){//Moving left
    2792:	8a 84       	ldd	r8, Y+10	; 0x0a
    2794:	9b 84       	ldd	r9, Y+11	; 0x0b
    2796:	ac 84       	ldd	r10, Y+12	; 0x0c
    2798:	bd 84       	ldd	r11, Y+13	; 0x0d
    279a:	20 e0       	ldi	r18, 0x00	; 0
    279c:	30 e0       	ldi	r19, 0x00	; 0
    279e:	a9 01       	movw	r20, r18
    27a0:	c5 01       	movw	r24, r10
    27a2:	b4 01       	movw	r22, r8
    27a4:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    27a8:	88 23       	and	r24, r24
    27aa:	0c f4       	brge	.+2      	; 0x27ae <__stack+0x5af>
    27ac:	54 c0       	rjmp	.+168    	; 0x2856 <__stack+0x657>
							LSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*leftIntError; //Simple PI controller for theta
    27ae:	01 2f       	mov	r16, r17
    27b0:	10 e0       	ldi	r17, 0x00	; 0
    27b2:	b8 01       	movw	r22, r16
    27b4:	01 2e       	mov	r0, r17
    27b6:	00 0c       	add	r0, r0
    27b8:	88 0b       	sbc	r24, r24
    27ba:	99 0b       	sbc	r25, r25
    27bc:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    27c0:	6b 01       	movw	r12, r22
    27c2:	7c 01       	movw	r14, r24
    27c4:	c5 01       	movw	r24, r10
    27c6:	b4 01       	movw	r22, r8
    27c8:	9f 77       	andi	r25, 0x7F	; 127
    27ca:	20 e0       	ldi	r18, 0x00	; 0
    27cc:	30 e0       	ldi	r19, 0x00	; 0
    27ce:	46 e1       	ldi	r20, 0x16	; 22
    27d0:	54 e4       	ldi	r21, 0x44	; 68
    27d2:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    27d6:	9b 01       	movw	r18, r22
    27d8:	ac 01       	movw	r20, r24
    27da:	c7 01       	movw	r24, r14
    27dc:	b6 01       	movw	r22, r12
    27de:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    27e2:	6b 01       	movw	r12, r22
    27e4:	7c 01       	movw	r14, r24
    27e6:	20 e0       	ldi	r18, 0x00	; 0
    27e8:	30 e0       	ldi	r19, 0x00	; 0
    27ea:	40 e2       	ldi	r20, 0x20	; 32
    27ec:	51 e4       	ldi	r21, 0x41	; 65
    27ee:	61 96       	adiw	r28, 0x11	; 17
    27f0:	6c ad       	ldd	r22, Y+60	; 0x3c
    27f2:	7d ad       	ldd	r23, Y+61	; 0x3d
    27f4:	8e ad       	ldd	r24, Y+62	; 0x3e
    27f6:	9f ad       	ldd	r25, Y+63	; 0x3f
    27f8:	61 97       	sbiw	r28, 0x11	; 17
    27fa:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    27fe:	9b 01       	movw	r18, r22
    2800:	ac 01       	movw	r20, r24
    2802:	c7 01       	movw	r24, r14
    2804:	b6 01       	movw	r22, r12
    2806:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    280a:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    280e:	7f 87       	std	Y+15, r23	; 0x0f
    2810:	6e 87       	std	Y+14, r22	; 0x0e
							
							//Saturation
							if (LSpeed > currentDriveActuation){
    2812:	8e 85       	ldd	r24, Y+14	; 0x0e
    2814:	9f 85       	ldd	r25, Y+15	; 0x0f
    2816:	08 17       	cp	r16, r24
    2818:	19 07       	cpc	r17, r25
    281a:	1c f4       	brge	.+6      	; 0x2822 <__stack+0x623>
								LSpeed = currentDriveActuation;
    281c:	1f 87       	std	Y+15, r17	; 0x0f
    281e:	0e 87       	std	Y+14, r16	; 0x0e
    2820:	06 c0       	rjmp	.+12     	; 0x282e <__stack+0x62f>
							}else if(LSpeed < 0){
    2822:	8e 85       	ldd	r24, Y+14	; 0x0e
    2824:	9f 85       	ldd	r25, Y+15	; 0x0f
    2826:	99 23       	and	r25, r25
    2828:	14 f4       	brge	.+4      	; 0x282e <__stack+0x62f>
								LSpeed = 0;
    282a:	1f 86       	std	Y+15, r1	; 0x0f
    282c:	1e 86       	std	Y+14, r1	; 0x0e
							}
							RSpeed = currentDriveActuation;
    282e:	19 8b       	std	Y+17, r17	; 0x11
    2830:	08 8b       	std	Y+16, r16	; 0x10
							if (dLeft == 0){
    2832:	20 e0       	ldi	r18, 0x00	; 0
    2834:	30 e0       	ldi	r19, 0x00	; 0
    2836:	a9 01       	movw	r20, r18
    2838:	28 96       	adiw	r28, 0x08	; 8
    283a:	6c ad       	ldd	r22, Y+60	; 0x3c
    283c:	7d ad       	ldd	r23, Y+61	; 0x3d
    283e:	8e ad       	ldd	r24, Y+62	; 0x3e
    2840:	9f ad       	ldd	r25, Y+63	; 0x3f
    2842:	28 97       	sbiw	r28, 0x08	; 8
    2844:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2848:	81 11       	cpse	r24, r1
    284a:	58 c0       	rjmp	.+176    	; 0x28fc <__stack+0x6fd>
								RSpeed = currentDriveActuation + 15;
    284c:	01 5f       	subi	r16, 0xF1	; 241
    284e:	1f 4f       	sbci	r17, 0xFF	; 255
    2850:	19 8b       	std	Y+17, r17	; 0x11
    2852:	08 8b       	std	Y+16, r16	; 0x10
    2854:	53 c0       	rjmp	.+166    	; 0x28fc <__stack+0x6fd>
							}
							
						}else{//Moving right
							RSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*rightIntError; //Simple PI controller for theta
    2856:	01 2f       	mov	r16, r17
    2858:	10 e0       	ldi	r17, 0x00	; 0
    285a:	b8 01       	movw	r22, r16
    285c:	01 2e       	mov	r0, r17
    285e:	00 0c       	add	r0, r0
    2860:	88 0b       	sbc	r24, r24
    2862:	99 0b       	sbc	r25, r25
    2864:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2868:	6b 01       	movw	r12, r22
    286a:	7c 01       	movw	r14, r24
    286c:	c5 01       	movw	r24, r10
    286e:	b4 01       	movw	r22, r8
    2870:	9f 77       	andi	r25, 0x7F	; 127
    2872:	20 e0       	ldi	r18, 0x00	; 0
    2874:	30 e0       	ldi	r19, 0x00	; 0
    2876:	46 e1       	ldi	r20, 0x16	; 22
    2878:	54 e4       	ldi	r21, 0x44	; 68
    287a:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    287e:	9b 01       	movw	r18, r22
    2880:	ac 01       	movw	r20, r24
    2882:	c7 01       	movw	r24, r14
    2884:	b6 01       	movw	r22, r12
    2886:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    288a:	6b 01       	movw	r12, r22
    288c:	7c 01       	movw	r14, r24
    288e:	20 e0       	ldi	r18, 0x00	; 0
    2890:	30 e0       	ldi	r19, 0x00	; 0
    2892:	40 e2       	ldi	r20, 0x20	; 32
    2894:	51 e4       	ldi	r21, 0x41	; 65
    2896:	6a 96       	adiw	r28, 0x1a	; 26
    2898:	6c ad       	ldd	r22, Y+60	; 0x3c
    289a:	7d ad       	ldd	r23, Y+61	; 0x3d
    289c:	8e ad       	ldd	r24, Y+62	; 0x3e
    289e:	9f ad       	ldd	r25, Y+63	; 0x3f
    28a0:	6a 97       	sbiw	r28, 0x1a	; 26
    28a2:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    28a6:	9b 01       	movw	r18, r22
    28a8:	ac 01       	movw	r20, r24
    28aa:	c7 01       	movw	r24, r14
    28ac:	b6 01       	movw	r22, r12
    28ae:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    28b2:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    28b6:	79 8b       	std	Y+17, r23	; 0x11
    28b8:	68 8b       	std	Y+16, r22	; 0x10
							
							//Saturation
							if (RSpeed > currentDriveActuation){
    28ba:	88 89       	ldd	r24, Y+16	; 0x10
    28bc:	99 89       	ldd	r25, Y+17	; 0x11
    28be:	08 17       	cp	r16, r24
    28c0:	19 07       	cpc	r17, r25
    28c2:	1c f4       	brge	.+6      	; 0x28ca <__stack+0x6cb>
								RSpeed = currentDriveActuation;
    28c4:	19 8b       	std	Y+17, r17	; 0x11
    28c6:	08 8b       	std	Y+16, r16	; 0x10
    28c8:	06 c0       	rjmp	.+12     	; 0x28d6 <__stack+0x6d7>
							}else if(RSpeed < 0){
    28ca:	88 89       	ldd	r24, Y+16	; 0x10
    28cc:	99 89       	ldd	r25, Y+17	; 0x11
    28ce:	99 23       	and	r25, r25
    28d0:	14 f4       	brge	.+4      	; 0x28d6 <__stack+0x6d7>
								RSpeed = 0;
    28d2:	19 8a       	std	Y+17, r1	; 0x11
    28d4:	18 8a       	std	Y+16, r1	; 0x10
							}
							LSpeed = currentDriveActuation;
    28d6:	1f 87       	std	Y+15, r17	; 0x0f
    28d8:	0e 87       	std	Y+14, r16	; 0x0e
							if (dRight == 0){
    28da:	20 e0       	ldi	r18, 0x00	; 0
    28dc:	30 e0       	ldi	r19, 0x00	; 0
    28de:	a9 01       	movw	r20, r18
    28e0:	2c 96       	adiw	r28, 0x0c	; 12
    28e2:	6c ad       	ldd	r22, Y+60	; 0x3c
    28e4:	7d ad       	ldd	r23, Y+61	; 0x3d
    28e6:	8e ad       	ldd	r24, Y+62	; 0x3e
    28e8:	9f ad       	ldd	r25, Y+63	; 0x3f
    28ea:	2c 97       	sbiw	r28, 0x0c	; 12
    28ec:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    28f0:	81 11       	cpse	r24, r1
    28f2:	04 c0       	rjmp	.+8      	; 0x28fc <__stack+0x6fd>
								LSpeed = currentDriveActuation + 15;
    28f4:	01 5f       	subi	r16, 0xF1	; 241
    28f6:	1f 4f       	sbci	r17, 0xFF	; 255
    28f8:	1f 87       	std	Y+15, r17	; 0x0f
    28fa:	0e 87       	std	Y+14, r16	; 0x0e
							}
						}
						
						leftIntError += thetaDiff;
    28fc:	ca 84       	ldd	r12, Y+10	; 0x0a
    28fe:	db 84       	ldd	r13, Y+11	; 0x0b
    2900:	ec 84       	ldd	r14, Y+12	; 0x0c
    2902:	fd 84       	ldd	r15, Y+13	; 0x0d
    2904:	a7 01       	movw	r20, r14
    2906:	96 01       	movw	r18, r12
    2908:	61 96       	adiw	r28, 0x11	; 17
    290a:	6c ad       	ldd	r22, Y+60	; 0x3c
    290c:	7d ad       	ldd	r23, Y+61	; 0x3d
    290e:	8e ad       	ldd	r24, Y+62	; 0x3e
    2910:	9f ad       	ldd	r25, Y+63	; 0x3f
    2912:	61 97       	sbiw	r28, 0x11	; 17
    2914:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    2918:	61 96       	adiw	r28, 0x11	; 17
    291a:	6c af       	std	Y+60, r22	; 0x3c
    291c:	7d af       	std	Y+61, r23	; 0x3d
    291e:	8e af       	std	Y+62, r24	; 0x3e
    2920:	9f af       	std	Y+63, r25	; 0x3f
    2922:	61 97       	sbiw	r28, 0x11	; 17
						rightIntError -= thetaDiff;
    2924:	a7 01       	movw	r20, r14
    2926:	96 01       	movw	r18, r12
    2928:	6a 96       	adiw	r28, 0x1a	; 26
    292a:	6c ad       	ldd	r22, Y+60	; 0x3c
    292c:	7d ad       	ldd	r23, Y+61	; 0x3d
    292e:	8e ad       	ldd	r24, Y+62	; 0x3e
    2930:	9f ad       	ldd	r25, Y+63	; 0x3f
    2932:	6a 97       	sbiw	r28, 0x1a	; 26
    2934:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    2938:	6a 96       	adiw	r28, 0x1a	; 26
    293a:	6c af       	std	Y+60, r22	; 0x3c
    293c:	7d af       	std	Y+61, r23	; 0x3d
    293e:	8e af       	std	Y+62, r24	; 0x3e
    2940:	9f af       	std	Y+63, r25	; 0x3f
    2942:	6a 97       	sbiw	r28, 0x1a	; 26
						
						
						gRightWheelDirection = motorRightForward;
    2944:	86 e0       	ldi	r24, 0x06	; 6
    2946:	8f 8b       	std	Y+23, r24	; 0x17
						gLeftWheelDirection = motorLeftForward;
    2948:	84 e0       	ldi	r24, 0x04	; 4
    294a:	8e 8b       	std	Y+22, r24	; 0x16
						lastMovement = moveForward;
    294c:	81 e0       	ldi	r24, 0x01	; 1
    294e:	89 87       	std	Y+9, r24	; 0x09
					idleSendt = FALSE;
				
					if (doneTurning){//Start forward movement
						//debug("Done Turning");
						stuckRotLeft = 0;
						stuckRotRight = 0;
    2950:	1a ae       	std	Y+58, r1	; 0x3a
				
					idleSendt = FALSE;
				
					if (doneTurning){//Start forward movement
						//debug("Done Turning");
						stuckRotLeft = 0;
    2952:	19 ae       	std	Y+57, r1	; 0x39
    2954:	4b c2       	rjmp	.+1174   	; 0x2dec <__stack+0xbed>
			
					}else{ //Turn within 1 degree of target
						
						// Make sure to reset stuck variables if we have gone past target:
						
						if (thetaDiff >= 0){//Rotating left
    2956:	8a 84       	ldd	r8, Y+10	; 0x0a
    2958:	9b 84       	ldd	r9, Y+11	; 0x0b
    295a:	ac 84       	ldd	r10, Y+12	; 0x0c
    295c:	bd 84       	ldd	r11, Y+13	; 0x0d
    295e:	20 e0       	ldi	r18, 0x00	; 0
    2960:	30 e0       	ldi	r19, 0x00	; 0
    2962:	a9 01       	movw	r20, r18
    2964:	c5 01       	movw	r24, r10
    2966:	b4 01       	movw	r22, r8
    2968:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    296c:	88 23       	and	r24, r24
    296e:	34 f0       	brlt	.+12     	; 0x297c <__stack+0x77d>
							if (lastMovement==moveClockwise){
    2970:	89 85       	ldd	r24, Y+9	; 0x09
    2972:	83 30       	cpi	r24, 0x03	; 3
    2974:	41 f4       	brne	.+16     	; 0x2986 <__stack+0x787>
								stuckRotLeft = 0;
								stuckRotRight = 0;
    2976:	1a ae       	std	Y+58, r1	; 0x3a
						
						// Make sure to reset stuck variables if we have gone past target:
						
						if (thetaDiff >= 0){//Rotating left
							if (lastMovement==moveClockwise){
								stuckRotLeft = 0;
    2978:	19 ae       	std	Y+57, r1	; 0x39
    297a:	05 c0       	rjmp	.+10     	; 0x2986 <__stack+0x787>
								stuckRotRight = 0;
							}
						}else{//Rotating right
							if (lastMovement==moveCounterClockwise){
    297c:	89 85       	ldd	r24, Y+9	; 0x09
    297e:	84 30       	cpi	r24, 0x04	; 4
    2980:	11 f4       	brne	.+4      	; 0x2986 <__stack+0x787>
								stuckRotLeft = 0;
								stuckRotRight = 0;
    2982:	1a ae       	std	Y+58, r1	; 0x3a
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}else{//Rotating right
							if (lastMovement==moveCounterClockwise){
								stuckRotLeft = 0;
    2984:	19 ae       	std	Y+57, r1	; 0x39
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
						thetaTraveled = StartDiff - fabs(thetaDiff);
    2986:	a5 01       	movw	r20, r10
    2988:	94 01       	movw	r18, r8
    298a:	5f 77       	andi	r21, 0x7F	; 127
    298c:	c7 01       	movw	r24, r14
    298e:	b6 01       	movw	r22, r12
    2990:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    2994:	6b 01       	movw	r12, r22
    2996:	7c 01       	movw	r14, r24
						if (!bBaseRotationSpeed ){
    2998:	a9 96       	adiw	r28, 0x29	; 41
    299a:	4f ad       	ldd	r20, Y+63	; 0x3f
    299c:	a9 97       	sbiw	r28, 0x29	; 41
    299e:	41 11       	cpse	r20, r1
    29a0:	28 c0       	rjmp	.+80     	; 0x29f2 <__stack+0x7f3>
							if ((thetaTraveled <= rotateThreshold/2) || bStuck) {
    29a2:	29 e1       	ldi	r18, 0x19	; 25
    29a4:	34 e0       	ldi	r19, 0x04	; 4
    29a6:	46 e8       	ldi	r20, 0x86	; 134
    29a8:	5e e3       	ldi	r21, 0x3E	; 62
    29aa:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    29ae:	18 16       	cp	r1, r24
    29b0:	2c f4       	brge	.+10     	; 0x29bc <__stack+0x7bd>
    29b2:	aa 96       	adiw	r28, 0x2a	; 42
    29b4:	8f ad       	ldd	r24, Y+63	; 0x3f
    29b6:	aa 97       	sbiw	r28, 0x2a	; 42
    29b8:	88 23       	and	r24, r24
    29ba:	41 f0       	breq	.+16     	; 0x29cc <__stack+0x7cd>
								baseRotationSpeed++;
    29bc:	24 96       	adiw	r28, 0x04	; 4
    29be:	9f ad       	ldd	r25, Y+63	; 0x3f
    29c0:	24 97       	sbiw	r28, 0x04	; 4
    29c2:	9f 5f       	subi	r25, 0xFF	; 255
    29c4:	24 96       	adiw	r28, 0x04	; 4
    29c6:	9f af       	std	Y+63, r25	; 0x3f
    29c8:	24 97       	sbiw	r28, 0x04	; 4
    29ca:	13 c0       	rjmp	.+38     	; 0x29f2 <__stack+0x7f3>
							} else {
								bBaseRotationSpeed = TRUE;
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
    29cc:	1f 92       	push	r1
    29ce:	24 96       	adiw	r28, 0x04	; 4
    29d0:	af ad       	ldd	r26, Y+63	; 0x3f
    29d2:	24 97       	sbiw	r28, 0x04	; 4
    29d4:	af 93       	push	r26
    29d6:	89 e4       	ldi	r24, 0x49	; 73
    29d8:	96 e0       	ldi	r25, 0x06	; 6
    29da:	9f 93       	push	r25
    29dc:	8f 93       	push	r24
    29de:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <debug>
    29e2:	0f 90       	pop	r0
    29e4:	0f 90       	pop	r0
    29e6:	0f 90       	pop	r0
    29e8:	0f 90       	pop	r0
						thetaTraveled = StartDiff - fabs(thetaDiff);
						if (!bBaseRotationSpeed ){
							if ((thetaTraveled <= rotateThreshold/2) || bStuck) {
								baseRotationSpeed++;
							} else {
								bBaseRotationSpeed = TRUE;
    29ea:	b1 e0       	ldi	r27, 0x01	; 1
    29ec:	a9 96       	adiw	r28, 0x29	; 41
    29ee:	bf af       	std	Y+63, r27	; 0x3f
    29f0:	a9 97       	sbiw	r28, 0x29	; 41
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
    29f2:	2d 96       	adiw	r28, 0x0d	; 13
    29f4:	2f ad       	ldd	r18, Y+63	; 0x3f
    29f6:	2d 97       	sbiw	r28, 0x0d	; 13
    29f8:	21 11       	cpse	r18, r1
    29fa:	0e c0       	rjmp	.+28     	; 0x2a18 <__stack+0x819>
    29fc:	20 e0       	ldi	r18, 0x00	; 0
    29fe:	30 e0       	ldi	r19, 0x00	; 0
    2a00:	a9 01       	movw	r20, r18
    2a02:	28 96       	adiw	r28, 0x08	; 8
    2a04:	6c ad       	ldd	r22, Y+60	; 0x3c
    2a06:	7d ad       	ldd	r23, Y+61	; 0x3d
    2a08:	8e ad       	ldd	r24, Y+62	; 0x3e
    2a0a:	9f ad       	ldd	r25, Y+63	; 0x3f
    2a0c:	28 97       	sbiw	r28, 0x08	; 8
    2a0e:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2a12:	88 23       	and	r24, r24
    2a14:	b9 f0       	breq	.+46     	; 0x2a44 <__stack+0x845>
    2a16:	4a c2       	rjmp	.+1172   	; 0x2eac <__stack+0xcad>
    2a18:	20 e0       	ldi	r18, 0x00	; 0
    2a1a:	30 e0       	ldi	r19, 0x00	; 0
    2a1c:	a9 01       	movw	r20, r18
    2a1e:	2c 96       	adiw	r28, 0x0c	; 12
    2a20:	6c ad       	ldd	r22, Y+60	; 0x3c
    2a22:	7d ad       	ldd	r23, Y+61	; 0x3d
    2a24:	8e ad       	ldd	r24, Y+62	; 0x3e
    2a26:	9f ad       	ldd	r25, Y+63	; 0x3f
    2a28:	2c 97       	sbiw	r28, 0x0c	; 12
    2a2a:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2a2e:	81 11       	cpse	r24, r1
    2a30:	3f c0       	rjmp	.+126    	; 0x2ab0 <__stack+0x8b1>
    2a32:	a9 96       	adiw	r28, 0x29	; 41
    2a34:	4f ad       	ldd	r20, Y+63	; 0x3f
    2a36:	a9 97       	sbiw	r28, 0x29	; 41
    2a38:	41 11       	cpse	r20, r1
    2a3a:	49 c2       	rjmp	.+1170   	; 0x2ece <__stack+0xccf>
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
							}
						} else {
							//stuckRotInc = 0;
							bStuck = FALSE;
    2a3c:	aa 96       	adiw	r28, 0x2a	; 42
    2a3e:	1f ae       	std	Y+63, r1	; 0x3f
    2a40:	aa 97       	sbiw	r28, 0x2a	; 42
    2a42:	39 c0       	rjmp	.+114    	; 0x2ab6 <__stack+0x8b7>
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
							if (dLeft == 0){
								stuckRotLeft++;
    2a44:	89 ad       	ldd	r24, Y+57	; 0x39
    2a46:	8f 5f       	subi	r24, 0xFF	; 255
    2a48:	89 af       	std	Y+57, r24	; 0x39
							}
							if (dRight == 0){
    2a4a:	20 e0       	ldi	r18, 0x00	; 0
    2a4c:	30 e0       	ldi	r19, 0x00	; 0
    2a4e:	a9 01       	movw	r20, r18
    2a50:	2c 96       	adiw	r28, 0x0c	; 12
    2a52:	6c ad       	ldd	r22, Y+60	; 0x3c
    2a54:	7d ad       	ldd	r23, Y+61	; 0x3d
    2a56:	8e ad       	ldd	r24, Y+62	; 0x3e
    2a58:	9f ad       	ldd	r25, Y+63	; 0x3f
    2a5a:	2c 97       	sbiw	r28, 0x0c	; 12
    2a5c:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2a60:	81 11       	cpse	r24, r1
    2a62:	03 c0       	rjmp	.+6      	; 0x2a6a <__stack+0x86b>
								stuckRotRight++;
    2a64:	9a ad       	ldd	r25, Y+58	; 0x3a
    2a66:	9f 5f       	subi	r25, 0xFF	; 255
    2a68:	9a af       	std	Y+58, r25	; 0x3a
							}
							//debug("#stuck: %i",stuckRotInc);
							if (stuckRotLeft > 10 || stuckRotRight > 10){
    2a6a:	a9 ad       	ldd	r26, Y+57	; 0x39
    2a6c:	ab 30       	cpi	r26, 0x0B	; 11
    2a6e:	18 f4       	brcc	.+6      	; 0x2a76 <__stack+0x877>
    2a70:	ba ad       	ldd	r27, Y+58	; 0x3a
    2a72:	bb 30       	cpi	r27, 0x0B	; 11
    2a74:	00 f1       	brcs	.+64     	; 0x2ab6 <__stack+0x8b7>
								bBaseRotationSpeed = FALSE;
								bStuck = TRUE;
								baseRotationSpeed += 10;
    2a76:	24 96       	adiw	r28, 0x04	; 4
    2a78:	2f ad       	ldd	r18, Y+63	; 0x3f
    2a7a:	24 97       	sbiw	r28, 0x04	; 4
    2a7c:	26 5f       	subi	r18, 0xF6	; 246
    2a7e:	24 96       	adiw	r28, 0x04	; 4
    2a80:	2f af       	std	Y+63, r18	; 0x3f
    2a82:	24 97       	sbiw	r28, 0x04	; 4
								stuckRotLeft = 0;
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
    2a84:	1f 92       	push	r1
    2a86:	2f 93       	push	r18
    2a88:	8a e2       	ldi	r24, 0x2A	; 42
    2a8a:	96 e0       	ldi	r25, 0x06	; 6
    2a8c:	9f 93       	push	r25
    2a8e:	8f 93       	push	r24
    2a90:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <debug>
    2a94:	0f 90       	pop	r0
    2a96:	0f 90       	pop	r0
    2a98:	0f 90       	pop	r0
    2a9a:	0f 90       	pop	r0
								stuckRotRight++;
							}
							//debug("#stuck: %i",stuckRotInc);
							if (stuckRotLeft > 10 || stuckRotRight > 10){
								bBaseRotationSpeed = FALSE;
								bStuck = TRUE;
    2a9c:	b1 e0       	ldi	r27, 0x01	; 1
    2a9e:	aa 96       	adiw	r28, 0x2a	; 42
    2aa0:	bf af       	std	Y+63, r27	; 0x3f
    2aa2:	aa 97       	sbiw	r28, 0x2a	; 42
							if (dRight == 0){
								stuckRotRight++;
							}
							//debug("#stuck: %i",stuckRotInc);
							if (stuckRotLeft > 10 || stuckRotRight > 10){
								bBaseRotationSpeed = FALSE;
    2aa4:	a9 96       	adiw	r28, 0x29	; 41
    2aa6:	1f ae       	std	Y+63, r1	; 0x3f
    2aa8:	a9 97       	sbiw	r28, 0x29	; 41
								bStuck = TRUE;
								baseRotationSpeed += 10;
								stuckRotLeft = 0;
								stuckRotRight = 0;
    2aaa:	1a ae       	std	Y+58, r1	; 0x3a
							//debug("#stuck: %i",stuckRotInc);
							if (stuckRotLeft > 10 || stuckRotRight > 10){
								bBaseRotationSpeed = FALSE;
								bStuck = TRUE;
								baseRotationSpeed += 10;
								stuckRotLeft = 0;
    2aac:	19 ae       	std	Y+57, r1	; 0x39
    2aae:	03 c0       	rjmp	.+6      	; 0x2ab6 <__stack+0x8b7>
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
							}
						} else {
							//stuckRotInc = 0;
							bStuck = FALSE;
    2ab0:	aa 96       	adiw	r28, 0x2a	; 42
    2ab2:	1f ae       	std	Y+63, r1	; 0x3f
    2ab4:	aa 97       	sbiw	r28, 0x2a	; 42
							//debug("stuck = 0");
						}
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
    2ab6:	2d 96       	adiw	r28, 0x0d	; 13
    2ab8:	2f ad       	ldd	r18, Y+63	; 0x3f
    2aba:	2d 97       	sbiw	r28, 0x0d	; 13
    2abc:	21 30       	cpi	r18, 0x01	; 1
    2abe:	a9 f4       	brne	.+42     	; 0x2aea <__stack+0x8eb>
    2ac0:	24 96       	adiw	r28, 0x04	; 4
    2ac2:	4f ad       	ldd	r20, Y+63	; 0x3f
    2ac4:	24 97       	sbiw	r28, 0x04	; 4
    2ac6:	45 36       	cpi	r20, 0x65	; 101
    2ac8:	80 f0       	brcs	.+32     	; 0x2aea <__stack+0x8eb>
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
    2aca:	1f 92       	push	r1
    2acc:	4f 93       	push	r20
    2ace:	8e e3       	ldi	r24, 0x3E	; 62
    2ad0:	96 e0       	ldi	r25, 0x06	; 6
    2ad2:	9f 93       	push	r25
    2ad4:	8f 93       	push	r24
    2ad6:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <debug>
    2ada:	0f 90       	pop	r0
    2adc:	0f 90       	pop	r0
    2ade:	0f 90       	pop	r0
    2ae0:	0f 90       	pop	r0
							baseRotationSpeed = 70;
    2ae2:	b6 e4       	ldi	r27, 0x46	; 70
    2ae4:	24 96       	adiw	r28, 0x04	; 4
    2ae6:	bf af       	std	Y+63, r27	; 0x3f
    2ae8:	24 97       	sbiw	r28, 0x04	; 4
						}
						newOrder = FALSE;
						if (thetaTraveled < (0.25 * StartDiff)) {
    2aea:	20 e0       	ldi	r18, 0x00	; 0
    2aec:	30 e0       	ldi	r19, 0x00	; 0
    2aee:	40 e8       	ldi	r20, 0x80	; 128
    2af0:	5e e3       	ldi	r21, 0x3E	; 62
    2af2:	68 8d       	ldd	r22, Y+24	; 0x18
    2af4:	79 8d       	ldd	r23, Y+25	; 0x19
    2af6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2af8:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2afa:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2afe:	9b 01       	movw	r18, r22
    2b00:	ac 01       	movw	r20, r24
    2b02:	c7 01       	movw	r24, r14
    2b04:	b6 01       	movw	r22, r12
    2b06:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2b0a:	88 23       	and	r24, r24
    2b0c:	0c f0       	brlt	.+2      	; 0x2b10 <__stack+0x911>
    2b0e:	c5 c0       	rjmp	.+394    	; 0x2c9a <__stack+0xa9b>
							if (!bBaseRotationSpeed){
    2b10:	a9 96       	adiw	r28, 0x29	; 41
    2b12:	2f ad       	ldd	r18, Y+63	; 0x3f
    2b14:	a9 97       	sbiw	r28, 0x29	; 41
    2b16:	21 11       	cpse	r18, r1
    2b18:	5f c0       	rjmp	.+190    	; 0x2bd8 <__stack+0x9d9>
								if (thetaDiff >= 0){//Rotating left
    2b1a:	20 e0       	ldi	r18, 0x00	; 0
    2b1c:	30 e0       	ldi	r19, 0x00	; 0
    2b1e:	a9 01       	movw	r20, r18
    2b20:	6a 85       	ldd	r22, Y+10	; 0x0a
    2b22:	7b 85       	ldd	r23, Y+11	; 0x0b
    2b24:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b26:	9d 85       	ldd	r25, Y+13	; 0x0d
    2b28:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    2b2c:	88 23       	and	r24, r24
    2b2e:	54 f1       	brlt	.+84     	; 0x2b84 <__stack+0x985>
									LSpeed = -(baseRotationSpeed + stuckRotLeft);
    2b30:	24 96       	adiw	r28, 0x04	; 4
    2b32:	4f ad       	ldd	r20, Y+63	; 0x3f
    2b34:	24 97       	sbiw	r28, 0x04	; 4
    2b36:	84 2f       	mov	r24, r20
    2b38:	90 e0       	ldi	r25, 0x00	; 0
    2b3a:	9c 01       	movw	r18, r24
    2b3c:	a9 ad       	ldd	r26, Y+57	; 0x39
    2b3e:	2a 0f       	add	r18, r26
    2b40:	31 1d       	adc	r19, r1
    2b42:	31 95       	neg	r19
    2b44:	21 95       	neg	r18
    2b46:	31 09       	sbc	r19, r1
    2b48:	3f 87       	std	Y+15, r19	; 0x0f
    2b4a:	2e 87       	std	Y+14, r18	; 0x0e
									gLeftWheelDirection = motorLeftBackward;
    2b4c:	25 e0       	ldi	r18, 0x05	; 5
    2b4e:	2e 8b       	std	Y+22, r18	; 0x16
									RSpeed = (baseRotationSpeed + stuckRotRight);
    2b50:	ba ad       	ldd	r27, Y+58	; 0x3a
    2b52:	8b 0f       	add	r24, r27
    2b54:	91 1d       	adc	r25, r1
    2b56:	99 8b       	std	Y+17, r25	; 0x11
    2b58:	88 8b       	std	Y+16, r24	; 0x10
									gRightWheelDirection = motorRightForward;
    2b5a:	86 e0       	ldi	r24, 0x06	; 6
    2b5c:	8f 8b       	std	Y+23, r24	; 0x17
									lastMovement = moveCounterClockwise;
    2b5e:	84 e0       	ldi	r24, 0x04	; 4
    2b60:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2b62:	2d 96       	adiw	r28, 0x0d	; 13
    2b64:	1f ae       	std	Y+63, r1	; 0x3f
    2b66:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2b68:	18 ae       	std	Y+56, r1	; 0x38
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2b6a:	6a 96       	adiw	r28, 0x1a	; 26
    2b6c:	1c ae       	std	Y+60, r1	; 0x3c
    2b6e:	1d ae       	std	Y+61, r1	; 0x3d
    2b70:	1e ae       	std	Y+62, r1	; 0x3e
    2b72:	1f ae       	std	Y+63, r1	; 0x3f
    2b74:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2b76:	61 96       	adiw	r28, 0x11	; 17
    2b78:	1c ae       	std	Y+60, r1	; 0x3c
    2b7a:	1d ae       	std	Y+61, r1	; 0x3d
    2b7c:	1e ae       	std	Y+62, r1	; 0x3e
    2b7e:	1f ae       	std	Y+63, r1	; 0x3f
    2b80:	61 97       	sbiw	r28, 0x11	; 17
    2b82:	34 c1       	rjmp	.+616    	; 0x2dec <__stack+0xbed>
									gLeftWheelDirection = motorLeftBackward;
									RSpeed = (baseRotationSpeed + stuckRotRight);
									gRightWheelDirection = motorRightForward;
									lastMovement = moveCounterClockwise;
								}else{//Rotating right
									LSpeed = (baseRotationSpeed + stuckRotLeft);
    2b84:	24 96       	adiw	r28, 0x04	; 4
    2b86:	2f ad       	ldd	r18, Y+63	; 0x3f
    2b88:	24 97       	sbiw	r28, 0x04	; 4
    2b8a:	82 2f       	mov	r24, r18
    2b8c:	90 e0       	ldi	r25, 0x00	; 0
    2b8e:	9c 01       	movw	r18, r24
    2b90:	49 ad       	ldd	r20, Y+57	; 0x39
    2b92:	24 0f       	add	r18, r20
    2b94:	31 1d       	adc	r19, r1
    2b96:	3f 87       	std	Y+15, r19	; 0x0f
    2b98:	2e 87       	std	Y+14, r18	; 0x0e
									gLeftWheelDirection = motorLeftForward;
    2b9a:	24 e0       	ldi	r18, 0x04	; 4
    2b9c:	2e 8b       	std	Y+22, r18	; 0x16
									RSpeed = -(baseRotationSpeed + stuckRotRight);
    2b9e:	aa ad       	ldd	r26, Y+58	; 0x3a
    2ba0:	8a 0f       	add	r24, r26
    2ba2:	91 1d       	adc	r25, r1
    2ba4:	91 95       	neg	r25
    2ba6:	81 95       	neg	r24
    2ba8:	91 09       	sbc	r25, r1
    2baa:	99 8b       	std	Y+17, r25	; 0x11
    2bac:	88 8b       	std	Y+16, r24	; 0x10
									gRightWheelDirection = motorRightBackward;
    2bae:	85 e0       	ldi	r24, 0x05	; 5
    2bb0:	8f 8b       	std	Y+23, r24	; 0x17
									lastMovement = moveClockwise;
    2bb2:	83 e0       	ldi	r24, 0x03	; 3
    2bb4:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2bb6:	2d 96       	adiw	r28, 0x0d	; 13
    2bb8:	1f ae       	std	Y+63, r1	; 0x3f
    2bba:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2bbc:	18 ae       	std	Y+56, r1	; 0x38
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2bbe:	6a 96       	adiw	r28, 0x1a	; 26
    2bc0:	1c ae       	std	Y+60, r1	; 0x3c
    2bc2:	1d ae       	std	Y+61, r1	; 0x3d
    2bc4:	1e ae       	std	Y+62, r1	; 0x3e
    2bc6:	1f ae       	std	Y+63, r1	; 0x3f
    2bc8:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2bca:	61 96       	adiw	r28, 0x11	; 17
    2bcc:	1c ae       	std	Y+60, r1	; 0x3c
    2bce:	1d ae       	std	Y+61, r1	; 0x3d
    2bd0:	1e ae       	std	Y+62, r1	; 0x3e
    2bd2:	1f ae       	std	Y+63, r1	; 0x3f
    2bd4:	61 97       	sbiw	r28, 0x11	; 17
    2bd6:	0a c1       	rjmp	.+532    	; 0x2dec <__stack+0xbed>
									RSpeed = -(baseRotationSpeed + stuckRotRight);
									gRightWheelDirection = motorRightBackward;
									lastMovement = moveClockwise;
								}
							} else {
								if (thetaDiff >= 0){//Rotating left
    2bd8:	20 e0       	ldi	r18, 0x00	; 0
    2bda:	30 e0       	ldi	r19, 0x00	; 0
    2bdc:	a9 01       	movw	r20, r18
    2bde:	6a 85       	ldd	r22, Y+10	; 0x0a
    2be0:	7b 85       	ldd	r23, Y+11	; 0x0b
    2be2:	8c 85       	ldd	r24, Y+12	; 0x0c
    2be4:	9d 85       	ldd	r25, Y+13	; 0x0d
    2be6:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    2bea:	88 23       	and	r24, r24
    2bec:	5c f1       	brlt	.+86     	; 0x2c44 <__stack+0xa45>
									LSpeed = -(baseRotationSpeed-10 + stuckRotLeft);
    2bee:	24 96       	adiw	r28, 0x04	; 4
    2bf0:	bf ad       	ldd	r27, Y+63	; 0x3f
    2bf2:	24 97       	sbiw	r28, 0x04	; 4
    2bf4:	8b 2f       	mov	r24, r27
    2bf6:	90 e0       	ldi	r25, 0x00	; 0
    2bf8:	0a 97       	sbiw	r24, 0x0a	; 10
    2bfa:	9c 01       	movw	r18, r24
    2bfc:	49 ad       	ldd	r20, Y+57	; 0x39
    2bfe:	24 0f       	add	r18, r20
    2c00:	31 1d       	adc	r19, r1
    2c02:	31 95       	neg	r19
    2c04:	21 95       	neg	r18
    2c06:	31 09       	sbc	r19, r1
    2c08:	3f 87       	std	Y+15, r19	; 0x0f
    2c0a:	2e 87       	std	Y+14, r18	; 0x0e
									gLeftWheelDirection = motorLeftBackward;
    2c0c:	25 e0       	ldi	r18, 0x05	; 5
    2c0e:	2e 8b       	std	Y+22, r18	; 0x16
									RSpeed = ((baseRotationSpeed-10) + stuckRotRight);
    2c10:	aa ad       	ldd	r26, Y+58	; 0x3a
    2c12:	8a 0f       	add	r24, r26
    2c14:	91 1d       	adc	r25, r1
    2c16:	99 8b       	std	Y+17, r25	; 0x11
    2c18:	88 8b       	std	Y+16, r24	; 0x10
									gRightWheelDirection = motorRightForward;
    2c1a:	86 e0       	ldi	r24, 0x06	; 6
    2c1c:	8f 8b       	std	Y+23, r24	; 0x17
									lastMovement = moveCounterClockwise;
    2c1e:	84 e0       	ldi	r24, 0x04	; 4
    2c20:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2c22:	2d 96       	adiw	r28, 0x0d	; 13
    2c24:	1f ae       	std	Y+63, r1	; 0x3f
    2c26:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2c28:	18 ae       	std	Y+56, r1	; 0x38
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2c2a:	6a 96       	adiw	r28, 0x1a	; 26
    2c2c:	1c ae       	std	Y+60, r1	; 0x3c
    2c2e:	1d ae       	std	Y+61, r1	; 0x3d
    2c30:	1e ae       	std	Y+62, r1	; 0x3e
    2c32:	1f ae       	std	Y+63, r1	; 0x3f
    2c34:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2c36:	61 96       	adiw	r28, 0x11	; 17
    2c38:	1c ae       	std	Y+60, r1	; 0x3c
    2c3a:	1d ae       	std	Y+61, r1	; 0x3d
    2c3c:	1e ae       	std	Y+62, r1	; 0x3e
    2c3e:	1f ae       	std	Y+63, r1	; 0x3f
    2c40:	61 97       	sbiw	r28, 0x11	; 17
    2c42:	d4 c0       	rjmp	.+424    	; 0x2dec <__stack+0xbed>
									gLeftWheelDirection = motorLeftBackward;
									RSpeed = ((baseRotationSpeed-10) + stuckRotRight);
									gRightWheelDirection = motorRightForward;
									lastMovement = moveCounterClockwise;
								}else{//Rotating right
									LSpeed = ((baseRotationSpeed-10) + stuckRotLeft);
    2c44:	24 96       	adiw	r28, 0x04	; 4
    2c46:	bf ad       	ldd	r27, Y+63	; 0x3f
    2c48:	24 97       	sbiw	r28, 0x04	; 4
    2c4a:	8b 2f       	mov	r24, r27
    2c4c:	90 e0       	ldi	r25, 0x00	; 0
    2c4e:	0a 97       	sbiw	r24, 0x0a	; 10
    2c50:	9c 01       	movw	r18, r24
    2c52:	49 ad       	ldd	r20, Y+57	; 0x39
    2c54:	24 0f       	add	r18, r20
    2c56:	31 1d       	adc	r19, r1
    2c58:	3f 87       	std	Y+15, r19	; 0x0f
    2c5a:	2e 87       	std	Y+14, r18	; 0x0e
									gLeftWheelDirection = motorLeftForward;
    2c5c:	24 e0       	ldi	r18, 0x04	; 4
    2c5e:	2e 8b       	std	Y+22, r18	; 0x16
									RSpeed = -((baseRotationSpeed-10) + stuckRotRight);
    2c60:	aa ad       	ldd	r26, Y+58	; 0x3a
    2c62:	8a 0f       	add	r24, r26
    2c64:	91 1d       	adc	r25, r1
    2c66:	91 95       	neg	r25
    2c68:	81 95       	neg	r24
    2c6a:	91 09       	sbc	r25, r1
    2c6c:	99 8b       	std	Y+17, r25	; 0x11
    2c6e:	88 8b       	std	Y+16, r24	; 0x10
									gRightWheelDirection = motorRightBackward;
    2c70:	85 e0       	ldi	r24, 0x05	; 5
    2c72:	8f 8b       	std	Y+23, r24	; 0x17
									lastMovement = moveClockwise;
    2c74:	83 e0       	ldi	r24, 0x03	; 3
    2c76:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2c78:	2d 96       	adiw	r28, 0x0d	; 13
    2c7a:	1f ae       	std	Y+63, r1	; 0x3f
    2c7c:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2c7e:	18 ae       	std	Y+56, r1	; 0x38
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2c80:	6a 96       	adiw	r28, 0x1a	; 26
    2c82:	1c ae       	std	Y+60, r1	; 0x3c
    2c84:	1d ae       	std	Y+61, r1	; 0x3d
    2c86:	1e ae       	std	Y+62, r1	; 0x3e
    2c88:	1f ae       	std	Y+63, r1	; 0x3f
    2c8a:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2c8c:	61 96       	adiw	r28, 0x11	; 17
    2c8e:	1c ae       	std	Y+60, r1	; 0x3c
    2c90:	1d ae       	std	Y+61, r1	; 0x3d
    2c92:	1e ae       	std	Y+62, r1	; 0x3e
    2c94:	1f ae       	std	Y+63, r1	; 0x3f
    2c96:	61 97       	sbiw	r28, 0x11	; 17
    2c98:	a9 c0       	rjmp	.+338    	; 0x2dec <__stack+0xbed>
									gRightWheelDirection = motorRightBackward;
									lastMovement = moveClockwise;
								}
							}
						} else {
							if (thetaDiff >= 0){//Rotating left
    2c9a:	ca 84       	ldd	r12, Y+10	; 0x0a
    2c9c:	db 84       	ldd	r13, Y+11	; 0x0b
    2c9e:	ec 84       	ldd	r14, Y+12	; 0x0c
    2ca0:	fd 84       	ldd	r15, Y+13	; 0x0d
    2ca2:	20 e0       	ldi	r18, 0x00	; 0
    2ca4:	30 e0       	ldi	r19, 0x00	; 0
    2ca6:	a9 01       	movw	r20, r18
    2ca8:	c7 01       	movw	r24, r14
    2caa:	b6 01       	movw	r22, r12
    2cac:	0e 94 8f 36 	call	0x6d1e	; 0x6d1e <__gesf2>
    2cb0:	88 23       	and	r24, r24
    2cb2:	0c f4       	brge	.+2      	; 0x2cb6 <__stack+0xab7>
    2cb4:	4e c0       	rjmp	.+156    	; 0x2d52 <__stack+0xb53>
								LSpeed = -(((baseRotationSpeed-30) + stuckRotLeft) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
    2cb6:	24 96       	adiw	r28, 0x04	; 4
    2cb8:	bf ad       	ldd	r27, Y+63	; 0x3f
    2cba:	24 97       	sbiw	r28, 0x04	; 4
    2cbc:	0b 2f       	mov	r16, r27
    2cbe:	10 e0       	ldi	r17, 0x00	; 0
    2cc0:	0e 51       	subi	r16, 0x1E	; 30
    2cc2:	11 09       	sbc	r17, r1
    2cc4:	c7 01       	movw	r24, r14
    2cc6:	b6 01       	movw	r22, r12
    2cc8:	9f 77       	andi	r25, 0x7F	; 127
    2cca:	24 ee       	ldi	r18, 0xE4	; 228
    2ccc:	37 eb       	ldi	r19, 0xB7	; 183
    2cce:	4b e4       	ldi	r20, 0x4B	; 75
    2cd0:	51 e4       	ldi	r21, 0x41	; 65
    2cd2:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2cd6:	6b 01       	movw	r12, r22
    2cd8:	7c 01       	movw	r14, r24
    2cda:	b8 01       	movw	r22, r16
    2cdc:	29 ad       	ldd	r18, Y+57	; 0x39
    2cde:	62 0f       	add	r22, r18
    2ce0:	71 1d       	adc	r23, r1
    2ce2:	07 2e       	mov	r0, r23
    2ce4:	00 0c       	add	r0, r0
    2ce6:	88 0b       	sbc	r24, r24
    2ce8:	99 0b       	sbc	r25, r25
    2cea:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2cee:	a7 01       	movw	r20, r14
    2cf0:	96 01       	movw	r18, r12
    2cf2:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    2cf6:	90 58       	subi	r25, 0x80	; 128
    2cf8:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    2cfc:	7f 87       	std	Y+15, r23	; 0x0f
    2cfe:	6e 87       	std	Y+14, r22	; 0x0e
								gLeftWheelDirection = motorLeftBackward;
    2d00:	85 e0       	ldi	r24, 0x05	; 5
    2d02:	8e 8b       	std	Y+22, r24	; 0x16
								RSpeed = (((baseRotationSpeed-30) + stuckRotRight) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
    2d04:	b8 01       	movw	r22, r16
    2d06:	4a ad       	ldd	r20, Y+58	; 0x3a
    2d08:	64 0f       	add	r22, r20
    2d0a:	71 1d       	adc	r23, r1
    2d0c:	07 2e       	mov	r0, r23
    2d0e:	00 0c       	add	r0, r0
    2d10:	88 0b       	sbc	r24, r24
    2d12:	99 0b       	sbc	r25, r25
    2d14:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2d18:	a7 01       	movw	r20, r14
    2d1a:	96 01       	movw	r18, r12
    2d1c:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    2d20:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    2d24:	79 8b       	std	Y+17, r23	; 0x11
    2d26:	68 8b       	std	Y+16, r22	; 0x10
								gRightWheelDirection = motorRightForward;
    2d28:	86 e0       	ldi	r24, 0x06	; 6
    2d2a:	8f 8b       	std	Y+23, r24	; 0x17
								lastMovement = moveCounterClockwise;
    2d2c:	84 e0       	ldi	r24, 0x04	; 4
    2d2e:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2d30:	2d 96       	adiw	r28, 0x0d	; 13
    2d32:	1f ae       	std	Y+63, r1	; 0x3f
    2d34:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2d36:	18 ae       	std	Y+56, r1	; 0x38
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2d38:	6a 96       	adiw	r28, 0x1a	; 26
    2d3a:	1c ae       	std	Y+60, r1	; 0x3c
    2d3c:	1d ae       	std	Y+61, r1	; 0x3d
    2d3e:	1e ae       	std	Y+62, r1	; 0x3e
    2d40:	1f ae       	std	Y+63, r1	; 0x3f
    2d42:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2d44:	61 96       	adiw	r28, 0x11	; 17
    2d46:	1c ae       	std	Y+60, r1	; 0x3c
    2d48:	1d ae       	std	Y+61, r1	; 0x3d
    2d4a:	1e ae       	std	Y+62, r1	; 0x3e
    2d4c:	1f ae       	std	Y+63, r1	; 0x3f
    2d4e:	61 97       	sbiw	r28, 0x11	; 17
    2d50:	4d c0       	rjmp	.+154    	; 0x2dec <__stack+0xbed>
								gLeftWheelDirection = motorLeftBackward;
								RSpeed = (((baseRotationSpeed-30) + stuckRotRight) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
								gRightWheelDirection = motorRightForward;
								lastMovement = moveCounterClockwise;
							}else{//Rotating right
								LSpeed = (((baseRotationSpeed-30) + stuckRotLeft) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
    2d52:	24 96       	adiw	r28, 0x04	; 4
    2d54:	8f ad       	ldd	r24, Y+63	; 0x3f
    2d56:	24 97       	sbiw	r28, 0x04	; 4
    2d58:	08 2f       	mov	r16, r24
    2d5a:	10 e0       	ldi	r17, 0x00	; 0
    2d5c:	0e 51       	subi	r16, 0x1E	; 30
    2d5e:	11 09       	sbc	r17, r1
    2d60:	c7 01       	movw	r24, r14
    2d62:	b6 01       	movw	r22, r12
    2d64:	9f 77       	andi	r25, 0x7F	; 127
    2d66:	24 ee       	ldi	r18, 0xE4	; 228
    2d68:	37 eb       	ldi	r19, 0xB7	; 183
    2d6a:	4b e4       	ldi	r20, 0x4B	; 75
    2d6c:	51 e4       	ldi	r21, 0x41	; 65
    2d6e:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2d72:	6b 01       	movw	r12, r22
    2d74:	7c 01       	movw	r14, r24
    2d76:	b8 01       	movw	r22, r16
    2d78:	99 ad       	ldd	r25, Y+57	; 0x39
    2d7a:	69 0f       	add	r22, r25
    2d7c:	71 1d       	adc	r23, r1
    2d7e:	07 2e       	mov	r0, r23
    2d80:	00 0c       	add	r0, r0
    2d82:	88 0b       	sbc	r24, r24
    2d84:	99 0b       	sbc	r25, r25
    2d86:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2d8a:	a7 01       	movw	r20, r14
    2d8c:	96 01       	movw	r18, r12
    2d8e:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    2d92:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    2d96:	7f 87       	std	Y+15, r23	; 0x0f
    2d98:	6e 87       	std	Y+14, r22	; 0x0e
								gLeftWheelDirection = motorLeftForward;
    2d9a:	84 e0       	ldi	r24, 0x04	; 4
    2d9c:	8e 8b       	std	Y+22, r24	; 0x16
								RSpeed = -(((baseRotationSpeed-30) + stuckRotRight) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
    2d9e:	b8 01       	movw	r22, r16
    2da0:	aa ad       	ldd	r26, Y+58	; 0x3a
    2da2:	6a 0f       	add	r22, r26
    2da4:	71 1d       	adc	r23, r1
    2da6:	07 2e       	mov	r0, r23
    2da8:	00 0c       	add	r0, r0
    2daa:	88 0b       	sbc	r24, r24
    2dac:	99 0b       	sbc	r25, r25
    2dae:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2db2:	a7 01       	movw	r20, r14
    2db4:	96 01       	movw	r18, r12
    2db6:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    2dba:	90 58       	subi	r25, 0x80	; 128
    2dbc:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    2dc0:	79 8b       	std	Y+17, r23	; 0x11
    2dc2:	68 8b       	std	Y+16, r22	; 0x10
								gRightWheelDirection = motorRightBackward;
    2dc4:	85 e0       	ldi	r24, 0x05	; 5
    2dc6:	8f 8b       	std	Y+23, r24	; 0x17
								lastMovement = moveClockwise;
    2dc8:	83 e0       	ldi	r24, 0x03	; 3
    2dca:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2dcc:	2d 96       	adiw	r28, 0x0d	; 13
    2dce:	1f ae       	std	Y+63, r1	; 0x3f
    2dd0:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2dd2:	18 ae       	std	Y+56, r1	; 0x38
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2dd4:	6a 96       	adiw	r28, 0x1a	; 26
    2dd6:	1c ae       	std	Y+60, r1	; 0x3c
    2dd8:	1d ae       	std	Y+61, r1	; 0x3d
    2dda:	1e ae       	std	Y+62, r1	; 0x3e
    2ddc:	1f ae       	std	Y+63, r1	; 0x3f
    2dde:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2de0:	61 96       	adiw	r28, 0x11	; 17
    2de2:	1c ae       	std	Y+60, r1	; 0x3c
    2de4:	1d ae       	std	Y+61, r1	; 0x3d
    2de6:	1e ae       	std	Y+62, r1	; 0x3e
    2de8:	1f ae       	std	Y+63, r1	; 0x3f
    2dea:	61 97       	sbiw	r28, 0x11	; 17
						rightIntError = 0;
					}
				
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
    2dec:	68 89       	ldd	r22, Y+16	; 0x10
    2dee:	79 89       	ldd	r23, Y+17	; 0x11
    2df0:	8e 85       	ldd	r24, Y+14	; 0x0e
    2df2:	9f 85       	ldd	r25, Y+15	; 0x0f
    2df4:	9e 01       	movw	r18, r28
    2df6:	29 5e       	subi	r18, 0xE9	; 233
    2df8:	3f 4f       	sbci	r19, 0xFF	; 255
    2dfa:	ae 01       	movw	r20, r28
    2dfc:	4a 5e       	subi	r20, 0xEA	; 234
    2dfe:	5f 4f       	sbci	r21, 0xFF	; 255
    2e00:	8c d3       	rcall	.+1816   	; 0x351a <vMotorMovementSwitch>
					//Simple speed controller as the robot nears the target
					blabla++;
					
					
				
					idleSendt = FALSE;
    2e02:	6b 96       	adiw	r28, 0x1b	; 27
    2e04:	1f ae       	std	Y+63, r1	; 0x3f
    2e06:	6b 97       	sbiw	r28, 0x1b	; 27
    2e08:	32 c0       	rjmp	.+100    	; 0x2e6e <__stack+0xc6f>
	
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
					*/
				}else{
					
					if (idleSendt == FALSE){
    2e0a:	6b 96       	adiw	r28, 0x1b	; 27
    2e0c:	bf ad       	ldd	r27, Y+63	; 0x3f
    2e0e:	6b 97       	sbiw	r28, 0x1b	; 27
    2e10:	b1 11       	cpse	r27, r1
    2e12:	06 c0       	rjmp	.+12     	; 0x2e20 <__stack+0xc21>
						send_idle();
    2e14:	0e 94 f6 24 	call	0x49ec	; 0x49ec <send_idle>
						//debug("xhat: %i, yhat: %i",xhat,yhat);
						idlesendtInc = 0;
						//vMotorMovementSwitch(-255,-255, &gLeftWheelDirection, &gRightWheelDirection);
						idleSendt = TRUE;
    2e18:	21 e0       	ldi	r18, 0x01	; 1
    2e1a:	6b 96       	adiw	r28, 0x1b	; 27
    2e1c:	2f af       	std	Y+63, r18	; 0x3f
    2e1e:	6b 97       	sbiw	r28, 0x1b	; 27
					}
					idlesendtInc++;
					if (prevDist < distance){
						//vMotorMovementSwitch(-baseUpRampActuation,-baseUpRampActuation, &gLeftWheelDirection, &gRightWheelDirection);
					}
					if (printInc==100 && starteds>0){
    2e20:	4f a9       	ldd	r20, Y+55	; 0x37
    2e22:	44 36       	cpi	r20, 0x64	; 100
    2e24:	f1 f4       	brne	.+60     	; 0x2e62 <__stack+0xc63>
    2e26:	a8 96       	adiw	r28, 0x28	; 40
    2e28:	8f ad       	ldd	r24, Y+63	; 0x3f
    2e2a:	a8 97       	sbiw	r28, 0x28	; 40
    2e2c:	88 23       	and	r24, r24
    2e2e:	c9 f0       	breq	.+50     	; 0x2e62 <__stack+0xc63>
						debug("xhat: %i, yhat: %i, theta: %f",xhat,yhat,thetahat);
    2e30:	9a a9       	ldd	r25, Y+50	; 0x32
    2e32:	9f 93       	push	r25
    2e34:	a9 a9       	ldd	r26, Y+49	; 0x31
    2e36:	af 93       	push	r26
    2e38:	b8 a9       	ldd	r27, Y+48	; 0x30
    2e3a:	bf 93       	push	r27
    2e3c:	2f a5       	ldd	r18, Y+47	; 0x2f
    2e3e:	2f 93       	push	r18
    2e40:	1f 93       	push	r17
    2e42:	0f 93       	push	r16
    2e44:	3f 92       	push	r3
    2e46:	2f 92       	push	r2
    2e48:	85 e5       	ldi	r24, 0x55	; 85
    2e4a:	96 e0       	ldi	r25, 0x06	; 6
    2e4c:	9f 93       	push	r25
    2e4e:	8f 93       	push	r24
    2e50:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <debug>
						printInc = 0;
    2e54:	0f b6       	in	r0, 0x3f	; 63
    2e56:	f8 94       	cli
    2e58:	de bf       	out	0x3e, r29	; 62
    2e5a:	0f be       	out	0x3f, r0	; 63
    2e5c:	cd bf       	out	0x3d, r28	; 61
    2e5e:	1f aa       	std	Y+55, r1	; 0x37
    2e60:	03 c0       	rjmp	.+6      	; 0x2e68 <__stack+0xc69>
					} else {
						printInc++;
    2e62:	9f a9       	ldd	r25, Y+55	; 0x37
    2e64:	9f 5f       	subi	r25, 0xFF	; 255
					}
					vMotorBrakeLeft();
    2e66:	9f ab       	std	Y+55, r25	; 0x37
					vMotorBrakeRight();
    2e68:	47 d3       	rcall	.+1678   	; 0x34f8 <vMotorBrakeLeft>
    2e6a:	4a d3       	rcall	.+1684   	; 0x3500 <vMotorBrakeRight>

					lastMovement = moveStop;
    2e6c:	19 86       	std	Y+9, r1	; 0x09
				}
				xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
    2e6e:	20 e0       	ldi	r18, 0x00	; 0
    2e70:	40 e0       	ldi	r20, 0x00	; 0
    2e72:	50 e0       	ldi	r21, 0x00	; 0
    2e74:	be 01       	movw	r22, r28
    2e76:	67 5f       	subi	r22, 0xF7	; 247
    2e78:	7f 4f       	sbci	r23, 0xFF	; 255
    2e7a:	80 91 21 1a 	lds	r24, 0x1A21	; 0x801a21 <scanStatusQ>
    2e7e:	90 91 22 1a 	lds	r25, 0x1A22	; 0x801a22 <scanStatusQ+0x1>
    2e82:	da d7       	rcall	.+4020   	; 0x3e38 <xQueueGenericSend>
				} 
				
				
				
				prevDist = distance;
				distance = (float)sqrt((xTargt-xhat)*(xTargt-xhat) + (yTargt-yhat)*(yTargt-yhat));
    2e84:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2e86:	63 96       	adiw	r28, 0x13	; 19
    2e88:	af af       	std	Y+63, r26	; 0x3f
    2e8a:	63 97       	sbiw	r28, 0x13	; 19
    2e8c:	b8 a1       	ldd	r27, Y+32	; 0x20
    2e8e:	64 96       	adiw	r28, 0x14	; 20
    2e90:	bf af       	std	Y+63, r27	; 0x3f
    2e92:	64 97       	sbiw	r28, 0x14	; 20
    2e94:	29 a1       	ldd	r18, Y+33	; 0x21
    2e96:	65 96       	adiw	r28, 0x15	; 21
    2e98:	2f af       	std	Y+63, r18	; 0x3f
    2e9a:	65 97       	sbiw	r28, 0x15	; 21
    2e9c:	4a a1       	ldd	r20, Y+34	; 0x22
    2e9e:	66 96       	adiw	r28, 0x16	; 22
    2ea0:	4f af       	std	Y+63, r20	; 0x3f
				xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
			} // No semaphore available, task is blocking
		} //if(gHandshook) end
		else{
			
			vMotorBrakeLeft();
    2ea2:	66 97       	sbiw	r28, 0x16	; 22
    2ea4:	1a c8       	rjmp	.-4044   	; 0x1eda <vMainPoseControllerTask+0x11c>
			vMotorBrakeRight();
    2ea6:	28 d3       	rcall	.+1616   	; 0x34f8 <vMotorBrakeLeft>
    2ea8:	2b d3       	rcall	.+1622   	; 0x3500 <vMotorBrakeRight>
    2eaa:	17 c8       	rjmp	.-4050   	; 0x1eda <vMainPoseControllerTask+0x11c>
								bBaseRotationSpeed = TRUE;
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
    2eac:	20 e0       	ldi	r18, 0x00	; 0
    2eae:	30 e0       	ldi	r19, 0x00	; 0
    2eb0:	a9 01       	movw	r20, r18
    2eb2:	2c 96       	adiw	r28, 0x0c	; 12
    2eb4:	6c ad       	ldd	r22, Y+60	; 0x3c
    2eb6:	7d ad       	ldd	r23, Y+61	; 0x3d
    2eb8:	8e ad       	ldd	r24, Y+62	; 0x3e
    2eba:	9f ad       	ldd	r25, Y+63	; 0x3f
    2ebc:	2c 97       	sbiw	r28, 0x0c	; 12
    2ebe:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2ec2:	88 23       	and	r24, r24
    2ec4:	91 f0       	breq	.+36     	; 0x2eea <__stack+0xceb>
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
							}
						} else {
							//stuckRotInc = 0;
							bStuck = FALSE;
    2ec6:	aa 96       	adiw	r28, 0x2a	; 42
    2ec8:	1f ae       	std	Y+63, r1	; 0x3f
    2eca:	aa 97       	sbiw	r28, 0x2a	; 42
    2ecc:	0e ce       	rjmp	.-996    	; 0x2aea <__stack+0x8eb>
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
							if (dLeft == 0){
    2ece:	20 e0       	ldi	r18, 0x00	; 0
    2ed0:	30 e0       	ldi	r19, 0x00	; 0
    2ed2:	a9 01       	movw	r20, r18
    2ed4:	28 96       	adiw	r28, 0x08	; 8
    2ed6:	6c ad       	ldd	r22, Y+60	; 0x3c
    2ed8:	7d ad       	ldd	r23, Y+61	; 0x3d
    2eda:	8e ad       	ldd	r24, Y+62	; 0x3e
    2edc:	9f ad       	ldd	r25, Y+63	; 0x3f
    2ede:	28 97       	sbiw	r28, 0x08	; 8
    2ee0:	0e 94 df 34 	call	0x69be	; 0x69be <__cmpsf2>
    2ee4:	81 11       	cpse	r24, r1
    2ee6:	be cd       	rjmp	.-1156   	; 0x2a64 <__stack+0x865>
    2ee8:	ad cd       	rjmp	.-1190   	; 0x2a44 <__stack+0x845>
								bBaseRotationSpeed = TRUE;
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
    2eea:	a9 96       	adiw	r28, 0x29	; 41
    2eec:	8f ad       	ldd	r24, Y+63	; 0x3f
    2eee:	a9 97       	sbiw	r28, 0x29	; 41
    2ef0:	81 11       	cpse	r24, r1
    2ef2:	b8 cd       	rjmp	.-1168   	; 0x2a64 <__stack+0x865>
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
							}
						} else {
							//stuckRotInc = 0;
							bStuck = FALSE;
    2ef4:	aa 96       	adiw	r28, 0x2a	; 42
    2ef6:	1f ae       	std	Y+63, r1	; 0x3f
    2ef8:	aa 97       	sbiw	r28, 0x2a	; 42
    2efa:	dd cd       	rjmp	.-1094   	; 0x2ab6 <__stack+0x8b7>

00002efc <vMainPoseEstimatorTask>:
		}
	}
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    2efc:	cf 93       	push	r28
    2efe:	df 93       	push	r29
    2f00:	cd b7       	in	r28, 0x3d	; 61
    2f02:	de b7       	in	r29, 0x3e	; 62
    2f04:	6e 97       	sbiw	r28, 0x1e	; 30
    2f06:	0f b6       	in	r0, 0x3f	; 63
    2f08:	f8 94       	cli
    2f0a:	de bf       	out	0x3e, r29	; 62
    2f0c:	0f be       	out	0x3f, r0	; 63
    2f0e:	cd bf       	out	0x3d, r28	; 61
    const TickType_t xDelay = PERIOD_ESTIMATOR_MS;
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;

    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    2f10:	19 82       	std	Y+1, r1	; 0x01
    2f12:	1a 82       	std	Y+2, r1	; 0x02
    2f14:	1b 82       	std	Y+3, r1	; 0x03
    2f16:	1c 82       	std	Y+4, r1	; 0x04
        uint8_t printerTellar = 0;     
    #endif
    
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    2f18:	0e 94 39 2d 	call	0x5a72	; 0x5a72 <xTaskGetTickCount>
    2f1c:	9e 83       	std	Y+6, r25	; 0x06
    2f1e:	8d 83       	std	Y+5, r24	; 0x05
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    2f20:	1b 86       	std	Y+11, r1	; 0x0b
    2f22:	1c 86       	std	Y+12, r1	; 0x0c
    2f24:	1d 86       	std	Y+13, r1	; 0x0d
    2f26:	1e 86       	std	Y+14, r1	; 0x0e

    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    2f28:	1b 8a       	std	Y+19, r1	; 0x13
    2f2a:	1c 8a       	std	Y+20, r1	; 0x14
    2f2c:	1d 8a       	std	Y+21, r1	; 0x15
    2f2e:	1e 8a       	std	Y+22, r1	; 0x16
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;

    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    2f30:	1f 86       	std	Y+15, r1	; 0x0f
    2f32:	18 8a       	std	Y+16, r1	; 0x10
    2f34:	19 8a       	std	Y+17, r1	; 0x11
    2f36:	1a 8a       	std	Y+18, r1	; 0x12
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    int16_t previous_ticksRight = 0;  
    2f38:	e1 2c       	mov	r14, r1
    2f3a:	f1 2c       	mov	r15, r1
	}
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    2f3c:	c1 2c       	mov	r12, r1
    2f3e:	d1 2c       	mov	r13, r1
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    
    while(1){
        // Loop
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    2f40:	68 e2       	ldi	r22, 0x28	; 40
    2f42:	70 e0       	ldi	r23, 0x00	; 0
    2f44:	ce 01       	movw	r24, r28
    2f46:	05 96       	adiw	r24, 0x05	; 5
    2f48:	0e 94 e3 27 	call	0x4fc6	; 0x4fc6 <vTaskDelayUntil>
        if (gHandshook){ // Check if we are ready    
    2f4c:	80 91 1c 1a 	lds	r24, 0x1A1C	; 0x801a1c <gHandshook>
    2f50:	88 23       	and	r24, r24
    2f52:	09 f4       	brne	.+2      	; 0x2f56 <vMainPoseEstimatorTask+0x5a>
    2f54:	1f c1       	rjmp	.+574    	; 0x3194 <vMainPoseEstimatorTask+0x298>
            int16_t leftWheelTicks = 0;
            int16_t rightWheelTicks = 0;
            float dRobot = 0;
			float dTheta = 0;
            // Get encoder data, protect the global tick variables
            xSemaphoreTake(xTickMutex, 15 / portTICK_PERIOD_MS);
    2f56:	20 e0       	ldi	r18, 0x00	; 0
    2f58:	4f e0       	ldi	r20, 0x0F	; 15
    2f5a:	50 e0       	ldi	r21, 0x00	; 0
    2f5c:	60 e0       	ldi	r22, 0x00	; 0
    2f5e:	70 e0       	ldi	r23, 0x00	; 0
    2f60:	80 91 85 1b 	lds	r24, 0x1B85	; 0x801b85 <xTickMutex>
    2f64:	90 91 86 1b 	lds	r25, 0x1B86	; 0x801b86 <xTickMutex+0x1>
    2f68:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
                leftWheelTicks = gLeftWheelTicks;
    2f6c:	20 90 07 1a 	lds	r2, 0x1A07	; 0x801a07 <gLeftWheelTicks>
    2f70:	30 90 08 1a 	lds	r3, 0x1A08	; 0x801a08 <gLeftWheelTicks+0x1>
                rightWheelTicks = gRightWheelTicks;
    2f74:	00 91 09 1a 	lds	r16, 0x1A09	; 0x801a09 <gRightWheelTicks>
    2f78:	10 91 0a 1a 	lds	r17, 0x1A0A	; 0x801a0a <gRightWheelTicks+0x1>
            xSemaphoreGive(xTickMutex);
    2f7c:	60 e0       	ldi	r22, 0x00	; 0
    2f7e:	70 e0       	ldi	r23, 0x00	; 0
    2f80:	80 91 85 1b 	lds	r24, 0x1B85	; 0x801b85 <xTickMutex>
    2f84:	90 91 86 1b 	lds	r25, 0x1B86	; 0x801b86 <xTickMutex+0x1>
    2f88:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
			
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
    2f8c:	b1 01       	movw	r22, r2
    2f8e:	6c 19       	sub	r22, r12
    2f90:	7d 09       	sbc	r23, r13
    2f92:	07 2e       	mov	r0, r23
    2f94:	00 0c       	add	r0, r0
    2f96:	88 0b       	sbc	r24, r24
    2f98:	99 0b       	sbc	r25, r25
    2f9a:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2f9e:	28 ef       	ldi	r18, 0xF8	; 248
    2fa0:	33 e5       	ldi	r19, 0x53	; 83
    2fa2:	43 ea       	ldi	r20, 0xA3	; 163
    2fa4:	5f e3       	ldi	r21, 0x3F	; 63
    2fa6:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2faa:	2b 01       	movw	r4, r22
    2fac:	3c 01       	movw	r6, r24
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
    2fae:	b8 01       	movw	r22, r16
    2fb0:	6e 19       	sub	r22, r14
    2fb2:	7f 09       	sbc	r23, r15
    2fb4:	07 2e       	mov	r0, r23
    2fb6:	00 0c       	add	r0, r0
    2fb8:	88 0b       	sbc	r24, r24
    2fba:	99 0b       	sbc	r25, r25
    2fbc:	0e 94 81 35 	call	0x6b02	; 0x6b02 <__floatsisf>
    2fc0:	28 ef       	ldi	r18, 0xF8	; 248
    2fc2:	33 e5       	ldi	r19, 0x53	; 83
    2fc4:	43 ea       	ldi	r20, 0xA3	; 163
    2fc6:	5f e3       	ldi	r21, 0x3F	; 63
    2fc8:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2fcc:	4b 01       	movw	r8, r22
    2fce:	5c 01       	movw	r10, r24
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
			
			
            dRobot = (dLeft + dRight) / 2;           
    2fd0:	9b 01       	movw	r18, r22
    2fd2:	ac 01       	movw	r20, r24
    2fd4:	c3 01       	movw	r24, r6
    2fd6:	b2 01       	movw	r22, r4
    2fd8:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    2fdc:	20 e0       	ldi	r18, 0x00	; 0
    2fde:	30 e0       	ldi	r19, 0x00	; 0
    2fe0:	40 e0       	ldi	r20, 0x00	; 0
    2fe2:	5f e3       	ldi	r21, 0x3F	; 63
    2fe4:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    2fe8:	6f 8b       	std	Y+23, r22	; 0x17
    2fea:	78 8f       	std	Y+24, r23	; 0x18
    2fec:	89 8f       	std	Y+25, r24	; 0x19
    2fee:	9a 8f       	std	Y+26, r25	; 0x1a
            dTheta = (dRight - dLeft) / WHEELBASE_MM; // Get angle from encoders, dervied from arch of circles formula
			 
            /* PREDICT */
            // Get gyro data:
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
    2ff0:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <fIMU_readFloatGyroZ>
    2ff4:	2b 85       	ldd	r18, Y+11	; 0x0b
    2ff6:	3c 85       	ldd	r19, Y+12	; 0x0c
    2ff8:	4d 85       	ldd	r20, Y+13	; 0x0d
    2ffa:	5e 85       	ldd	r21, Y+14	; 0x0e
    2ffc:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    3000:	6b 01       	movw	r12, r22
    3002:	7c 01       	movw	r14, r24
            gyrZ *= period_in_S * DEG2RAD; // Scale gyro measurement      
            
			
			
            // Fuse heading from sensors to predict heading:
            dTheta =  (1 - gyroWeight) * dTheta + gyroWeight * gyrZ;
    3004:	a3 01       	movw	r20, r6
    3006:	92 01       	movw	r18, r4
    3008:	c5 01       	movw	r24, r10
    300a:	b4 01       	movw	r22, r8
    300c:	0e 94 18 34 	call	0x6830	; 0x6830 <__subsf3>
    3010:	20 e0       	ldi	r18, 0x00	; 0
    3012:	30 e0       	ldi	r19, 0x00	; 0
    3014:	47 e1       	ldi	r20, 0x17	; 23
    3016:	53 e4       	ldi	r21, 0x43	; 67
    3018:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    301c:	20 e0       	ldi	r18, 0x00	; 0
    301e:	30 e0       	ldi	r19, 0x00	; 0
    3020:	40 e0       	ldi	r20, 0x00	; 0
    3022:	50 e0       	ldi	r21, 0x00	; 0
    3024:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    3028:	6f 83       	std	Y+7, r22	; 0x07
    302a:	78 87       	std	Y+8, r23	; 0x08
    302c:	89 87       	std	Y+9, r24	; 0x09
    302e:	9a 87       	std	Y+10, r25	; 0x0a
    3030:	24 ed       	ldi	r18, 0xD4	; 212
    3032:	32 e0       	ldi	r19, 0x02	; 2
    3034:	47 e3       	ldi	r20, 0x37	; 55
    3036:	5a e3       	ldi	r21, 0x3A	; 58
    3038:	c7 01       	movw	r24, r14
    303a:	b6 01       	movw	r22, r12
    303c:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    3040:	2f 81       	ldd	r18, Y+7	; 0x07
    3042:	38 85       	ldd	r19, Y+8	; 0x08
    3044:	49 85       	ldd	r20, Y+9	; 0x09
    3046:	5a 85       	ldd	r21, Y+10	; 0x0a
    3048:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    304c:	6f 83       	std	Y+7, r22	; 0x07
    304e:	78 87       	std	Y+8, r23	; 0x08
    3050:	89 87       	std	Y+9, r24	; 0x09
    3052:	9a 87       	std	Y+10, r25	; 0x0a
            
            
            // Estimate global X and Y pos
            // Todo; Include accelerator measurements to estimate position and handle wheel slippage
            predictedX = predictedX + (dRobot * cos(predictedTheta + 0.5 * dTheta)); 
    3054:	c9 80       	ldd	r12, Y+1	; 0x01
    3056:	da 80       	ldd	r13, Y+2	; 0x02
    3058:	eb 80       	ldd	r14, Y+3	; 0x03
    305a:	fc 80       	ldd	r15, Y+4	; 0x04
    305c:	20 e0       	ldi	r18, 0x00	; 0
    305e:	30 e0       	ldi	r19, 0x00	; 0
    3060:	40 e0       	ldi	r20, 0x00	; 0
    3062:	5f e3       	ldi	r21, 0x3F	; 63
    3064:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    3068:	a7 01       	movw	r20, r14
    306a:	96 01       	movw	r18, r12
    306c:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    3070:	6b 8f       	std	Y+27, r22	; 0x1b
    3072:	7c 8f       	std	Y+28, r23	; 0x1c
    3074:	8d 8f       	std	Y+29, r24	; 0x1d
    3076:	9e 8f       	std	Y+30, r25	; 0x1e
    3078:	0e 94 e3 34 	call	0x69c6	; 0x69c6 <cos>
    307c:	9b 01       	movw	r18, r22
    307e:	ac 01       	movw	r20, r24
    3080:	6f 89       	ldd	r22, Y+23	; 0x17
    3082:	78 8d       	ldd	r23, Y+24	; 0x18
    3084:	89 8d       	ldd	r24, Y+25	; 0x19
    3086:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3088:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    308c:	9b 01       	movw	r18, r22
    308e:	ac 01       	movw	r20, r24
    3090:	6f 85       	ldd	r22, Y+15	; 0x0f
    3092:	78 89       	ldd	r23, Y+16	; 0x10
    3094:	89 89       	ldd	r24, Y+17	; 0x11
    3096:	9a 89       	ldd	r25, Y+18	; 0x12
    3098:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    309c:	6f 87       	std	Y+15, r22	; 0x0f
    309e:	78 8b       	std	Y+16, r23	; 0x10
    30a0:	89 8b       	std	Y+17, r24	; 0x11
    30a2:	9a 8b       	std	Y+18, r25	; 0x12
            predictedY = predictedY + (dRobot * sin(predictedTheta + 0.5 * dTheta));
    30a4:	6b 8d       	ldd	r22, Y+27	; 0x1b
    30a6:	7c 8d       	ldd	r23, Y+28	; 0x1c
    30a8:	8d 8d       	ldd	r24, Y+29	; 0x1d
    30aa:	9e 8d       	ldd	r25, Y+30	; 0x1e
    30ac:	0e 94 fd 36 	call	0x6dfa	; 0x6dfa <sin>
    30b0:	9b 01       	movw	r18, r22
    30b2:	ac 01       	movw	r20, r24
    30b4:	6f 89       	ldd	r22, Y+23	; 0x17
    30b6:	78 8d       	ldd	r23, Y+24	; 0x18
    30b8:	89 8d       	ldd	r24, Y+25	; 0x19
    30ba:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30bc:	0e 94 9a 36 	call	0x6d34	; 0x6d34 <__mulsf3>
    30c0:	9b 01       	movw	r18, r22
    30c2:	ac 01       	movw	r20, r24
    30c4:	6b 89       	ldd	r22, Y+19	; 0x13
    30c6:	7c 89       	ldd	r23, Y+20	; 0x14
    30c8:	8d 89       	ldd	r24, Y+21	; 0x15
    30ca:	9e 89       	ldd	r25, Y+22	; 0x16
    30cc:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    30d0:	6b 8b       	std	Y+19, r22	; 0x13
    30d2:	7c 8b       	std	Y+20, r23	; 0x14
    30d4:	8d 8b       	std	Y+21, r24	; 0x15
    30d6:	9e 8b       	std	Y+22, r25	; 0x16

            // Predicted (a priori) state estimate for theta
            predictedTheta += dTheta;
    30d8:	a7 01       	movw	r20, r14
    30da:	96 01       	movw	r18, r12
    30dc:	6f 81       	ldd	r22, Y+7	; 0x07
    30de:	78 85       	ldd	r23, Y+8	; 0x08
    30e0:	89 85       	ldd	r24, Y+9	; 0x09
    30e2:	9a 85       	ldd	r25, Y+10	; 0x0a
    30e4:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    30e8:	69 83       	std	Y+1, r22	; 0x01
    30ea:	7a 83       	std	Y+2, r23	; 0x02
    30ec:	8b 83       	std	Y+3, r24	; 0x03
    30ee:	9c 83       	std	Y+4, r25	; 0x04
                //vLED_singleLow(ledYELLOW);
            }            
            //*/
           
            //predictedTheta  += kalmanGain*(error);
			vFunc_Inf2pi(&predictedTheta);            
    30f0:	ce 01       	movw	r24, r28
    30f2:	01 96       	adiw	r24, 0x01	; 1
    30f4:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
            
            // Updated (a posteriori) estimate covariance
            covariance_filter_predicted = (1 - kalmanGain) * covariance_filter_predicted;  

            // Update pose
            xSemaphoreTake(xPoseMutex, 15 / portTICK_PERIOD_MS);
    30f8:	20 e0       	ldi	r18, 0x00	; 0
    30fa:	4f e0       	ldi	r20, 0x0F	; 15
    30fc:	50 e0       	ldi	r21, 0x00	; 0
    30fe:	60 e0       	ldi	r22, 0x00	; 0
    3100:	70 e0       	ldi	r23, 0x00	; 0
    3102:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    3106:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    310a:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
                gTheta_hat = predictedTheta;
    310e:	89 81       	ldd	r24, Y+1	; 0x01
    3110:	9a 81       	ldd	r25, Y+2	; 0x02
    3112:	ab 81       	ldd	r26, Y+3	; 0x03
    3114:	bc 81       	ldd	r27, Y+4	; 0x04
    3116:	80 93 17 1a 	sts	0x1A17, r24	; 0x801a17 <gTheta_hat>
    311a:	90 93 18 1a 	sts	0x1A18, r25	; 0x801a18 <gTheta_hat+0x1>
    311e:	a0 93 19 1a 	sts	0x1A19, r26	; 0x801a19 <gTheta_hat+0x2>
    3122:	b0 93 1a 1a 	sts	0x1A1A, r27	; 0x801a1a <gTheta_hat+0x3>
                gX_hat = predictedX;
    3126:	6f 85       	ldd	r22, Y+15	; 0x0f
    3128:	78 89       	ldd	r23, Y+16	; 0x10
    312a:	89 89       	ldd	r24, Y+17	; 0x11
    312c:	9a 89       	ldd	r25, Y+18	; 0x12
    312e:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    3132:	70 93 16 1a 	sts	0x1A16, r23	; 0x801a16 <gX_hat+0x1>
    3136:	60 93 15 1a 	sts	0x1A15, r22	; 0x801a15 <gX_hat>
                gY_hat = predictedY;
    313a:	6b 89       	ldd	r22, Y+19	; 0x13
    313c:	7c 89       	ldd	r23, Y+20	; 0x14
    313e:	8d 89       	ldd	r24, Y+21	; 0x15
    3140:	9e 89       	ldd	r25, Y+22	; 0x16
    3142:	0e 94 4e 35 	call	0x6a9c	; 0x6a9c <__fixsfsi>
    3146:	70 93 14 1a 	sts	0x1A14, r23	; 0x801a14 <gY_hat+0x1>
    314a:	60 93 13 1a 	sts	0x1A13, r22	; 0x801a13 <gY_hat>
				gLeft = dLeft;
    314e:	40 92 0f 1a 	sts	0x1A0F, r4	; 0x801a0f <gLeft>
    3152:	50 92 10 1a 	sts	0x1A10, r5	; 0x801a10 <gLeft+0x1>
    3156:	60 92 11 1a 	sts	0x1A11, r6	; 0x801a11 <gLeft+0x2>
    315a:	70 92 12 1a 	sts	0x1A12, r7	; 0x801a12 <gLeft+0x3>
				gRight = dRight;
    315e:	80 92 0b 1a 	sts	0x1A0B, r8	; 0x801a0b <gRight>
    3162:	90 92 0c 1a 	sts	0x1A0C, r9	; 0x801a0c <gRight+0x1>
    3166:	a0 92 0d 1a 	sts	0x1A0D, r10	; 0x801a0d <gRight+0x2>
    316a:	b0 92 0e 1a 	sts	0x1A0E, r11	; 0x801a0e <gRight+0x3>
            xSemaphoreGive(xPoseMutex);
    316e:	60 e0       	ldi	r22, 0x00	; 0
    3170:	70 e0       	ldi	r23, 0x00	; 0
    3172:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    3176:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    317a:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
			
            // Send semaphore to controller
            xSemaphoreGive(xControllerBSem);
    317e:	60 e0       	ldi	r22, 0x00	; 0
    3180:	70 e0       	ldi	r23, 0x00	; 0
    3182:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <xControllerBSem>
    3186:	90 91 84 1b 	lds	r25, 0x1B84	; 0x801b84 <xControllerBSem+0x1>
    318a:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
            xSemaphoreGive(xTickMutex);
			
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
    318e:	78 01       	movw	r14, r16
                rightWheelTicks = gRightWheelTicks;
            xSemaphoreGive(xTickMutex);
			
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
    3190:	61 01       	movw	r12, r2
    3192:	d6 ce       	rjmp	.-596    	; 0x2f40 <vMainPoseEstimatorTask+0x44>
    3194:	05 e6       	ldi	r16, 0x65	; 101
    3196:	10 e0       	ldi	r17, 0x00	; 0
    3198:	81 2c       	mov	r8, r1
    319a:	91 2c       	mov	r9, r1
    319c:	a1 2c       	mov	r10, r1
    319e:	b1 2c       	mov	r11, r1
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
                gyro+= fIMU_readFloatGyroZ();
    31a0:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <fIMU_readFloatGyroZ>
    31a4:	9b 01       	movw	r18, r22
    31a6:	ac 01       	movw	r20, r24
    31a8:	68 2d       	mov	r22, r8
    31aa:	79 2d       	mov	r23, r9
    31ac:	8a 2d       	mov	r24, r10
    31ae:	9b 2d       	mov	r25, r11
    31b0:	0e 94 19 34 	call	0x6832	; 0x6832 <__addsf3>
    31b4:	86 2e       	mov	r8, r22
    31b6:	97 2e       	mov	r9, r23
    31b8:	a8 2e       	mov	r10, r24
    31ba:	b9 2e       	mov	r11, r25
    31bc:	01 50       	subi	r16, 0x01	; 1
    31be:	11 09       	sbc	r17, r1
        else{
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
    31c0:	79 f7       	brne	.-34     	; 0x31a0 <vMainPoseEstimatorTask+0x2a4>
                gyro+= fIMU_readFloatGyroZ();
            }
			gyroOffset = gyro / (float)i;   
    31c2:	20 e0       	ldi	r18, 0x00	; 0
    31c4:	30 e0       	ldi	r19, 0x00	; 0
    31c6:	4a ec       	ldi	r20, 0xCA	; 202
    31c8:	52 e4       	ldi	r21, 0x42	; 66
    31ca:	0e 94 e6 34 	call	0x69cc	; 0x69cc <__divsf3>
    31ce:	6b 87       	std	Y+11, r22	; 0x0b
    31d0:	7c 87       	std	Y+12, r23	; 0x0c
    31d2:	8d 87       	std	Y+13, r24	; 0x0d
    31d4:	9e 87       	std	Y+14, r25	; 0x0e
    31d6:	b4 ce       	rjmp	.-664    	; 0x2f40 <vMainPoseEstimatorTask+0x44>

000031d8 <vApplicationStackOverflowHook>:
}


/*  In case of stack overflow, disable all interrupts and handle it  */
void vApplicationStackOverflowHook(TaskHandle_t *pxTask, signed char *pcTaskName){
    cli();
    31d8:	f8 94       	cli
    31da:	ff cf       	rjmp	.-2      	; 0x31da <vApplicationStackOverflowHook+0x2>

000031dc <main>:
        //ledPORT ^= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    }// While(1) end
}

/*  Main function   */
int main(void){
    31dc:	cf 93       	push	r28
    31de:	df 93       	push	r29
    31e0:	1f 92       	push	r1
    31e2:	1f 92       	push	r1
    31e4:	cd b7       	in	r28, 0x3d	; 61
    31e6:	de b7       	in	r29, 0x3e	; 62
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */

	MCUCR &= ~(1<<JTD);
    31e8:	85 b7       	in	r24, 0x35	; 53
    31ea:	8f 77       	andi	r24, 0x7F	; 127
    31ec:	85 bf       	out	0x35, r24	; 53
	volatile size_t heap;
    vLED_init();
    31ee:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    31f2:	80 e0       	ldi	r24, 0x00	; 0
    31f4:	90 e0       	ldi	r25, 0x00	; 0
    31f6:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    31fa:	0e 94 36 33 	call	0x666c	; 0x666c <vUSART_init>
    network_init();
    31fe:	31 d2       	rcall	.+1122   	; 0x3662 <network_init>
    arq_init();
    3200:	0e 94 43 01 	call	0x286	; 0x286 <arq_init>
    simple_p_init(server_receiver);
    3204:	88 e2       	ldi	r24, 0x28	; 40
    3206:	94 e2       	ldi	r25, 0x24	; 36
    3208:	0e 94 26 26 	call	0x4c4c	; 0x4c4c <simple_p_init>
        debug("tictoc!\n");
        tic;
    #endif
	
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    320c:	80 e0       	ldi	r24, 0x00	; 0
    320e:	0e 94 9e 25 	call	0x4b3c	; 0x4b3c <vServo_init>
    /* Initialize sensors */
    vDistSens_init();
    3212:	0e 94 a5 07 	call	0xf4a	; 0xf4a <vDistSens_init>
    /* Initialize motor controller */
    vMotor_init();
    3216:	ed d0       	rcall	.+474    	; 0x33f2 <vMotor_init>
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        debug("IMU init..\n");
    #endif
    sIMU_begin(); 
    3218:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <sIMU_begin>
}*/
	
    
    /* Initialize RTOS utilities  */

	heap = xPortGetFreeHeapSize();
    321c:	0e 94 a1 09 	call	0x1342	; 0x1342 <xPortGetFreeHeapSize>
    3220:	9a 83       	std	Y+2, r25	; 0x02
    3222:	89 83       	std	Y+1, r24	; 0x01
    poseControllerQ = xQueueCreate(1, sizeof(struct sCartesian)); // For setpoints to controller
    3224:	40 e0       	ldi	r20, 0x00	; 0
    3226:	68 e0       	ldi	r22, 0x08	; 8
    3228:	81 e0       	ldi	r24, 0x01	; 1
    322a:	32 d4       	rcall	.+2148   	; 0x3a90 <xQueueGenericCreate>
    322c:	90 93 24 1a 	sts	0x1A24, r25	; 0x801a24 <poseControllerQ+0x1>
    3230:	80 93 23 1a 	sts	0x1A23, r24	; 0x801a23 <poseControllerQ>
    scanStatusQ = xQueueCreate(1,sizeof(uint8_t)); // For robot status
    3234:	40 e0       	ldi	r20, 0x00	; 0
    3236:	61 e0       	ldi	r22, 0x01	; 1
    3238:	81 e0       	ldi	r24, 0x01	; 1
    323a:	2a d4       	rcall	.+2132   	; 0x3a90 <xQueueGenericCreate>
    323c:	90 93 22 1a 	sts	0x1A22, r25	; 0x801a22 <scanStatusQ+0x1>
    3240:	80 93 21 1a 	sts	0x1A21, r24	; 0x801a21 <scanStatusQ>
    actuationQ = xQueueCreate(2,sizeof(uint8_t)); // To send variable actuation to motors
    3244:	40 e0       	ldi	r20, 0x00	; 0
    3246:	61 e0       	ldi	r22, 0x01	; 1
    3248:	82 e0       	ldi	r24, 0x02	; 2
    324a:	22 d4       	rcall	.+2116   	; 0x3a90 <xQueueGenericCreate>
    324c:	90 93 20 1a 	sts	0x1A20, r25	; 0x801a20 <actuationQ+0x1>
    3250:	80 93 1f 1a 	sts	0x1A1F, r24	; 0x801a1f <actuationQ>
    
    xPoseMutex = xSemaphoreCreateMutex(); // Global variables for robot pose. Only updated from estimator, accessed from many
    3254:	81 e0       	ldi	r24, 0x01	; 1
    3256:	6e d4       	rcall	.+2268   	; 0x3b34 <xQueueCreateMutex>
    3258:	90 93 8c 1b 	sts	0x1B8C, r25	; 0x801b8c <xPoseMutex+0x1>
    325c:	80 93 8b 1b 	sts	0x1B8B, r24	; 0x801b8b <xPoseMutex>
    xUartMutex = xSemaphoreCreateMutex(); // Protected printf with a mutex, may cause fragmented bytes if higher priority task want to print as well
    3260:	81 e0       	ldi	r24, 0x01	; 1
    3262:	68 d4       	rcall	.+2256   	; 0x3b34 <xQueueCreateMutex>
    3264:	90 93 88 1b 	sts	0x1B88, r25	; 0x801b88 <xUartMutex+0x1>
    3268:	80 93 87 1b 	sts	0x1B87, r24	; 0x801b87 <xUartMutex>
    xTickMutex = xSemaphoreCreateMutex(); // Global variable to hold robot tick values
    326c:	81 e0       	ldi	r24, 0x01	; 1
    326e:	62 d4       	rcall	.+2244   	; 0x3b34 <xQueueCreateMutex>
    3270:	90 93 86 1b 	sts	0x1B86, r25	; 0x801b86 <xTickMutex+0x1>
    3274:	80 93 85 1b 	sts	0x1B85, r24	; 0x801b85 <xTickMutex>
    
    xControllerBSem = xSemaphoreCreateBinary(); // Estimator to Controller synchronization
    3278:	43 e0       	ldi	r20, 0x03	; 3
    327a:	60 e0       	ldi	r22, 0x00	; 0
    327c:	81 e0       	ldi	r24, 0x01	; 1
    327e:	08 d4       	rcall	.+2064   	; 0x3a90 <xQueueGenericCreate>
    3280:	90 93 84 1b 	sts	0x1B84, r25	; 0x801b84 <xControllerBSem+0x1>
    3284:	80 93 83 1b 	sts	0x1B83, r24	; 0x801b83 <xControllerBSem>
    xCommandReadyBSem = xSemaphoreCreateBinary(); // uart ISR to comm task sync
    3288:	43 e0       	ldi	r20, 0x03	; 3
    328a:	60 e0       	ldi	r22, 0x00	; 0
    328c:	81 e0       	ldi	r24, 0x01	; 1
    328e:	00 d4       	rcall	.+2048   	; 0x3a90 <xQueueGenericCreate>
    3290:	90 93 8a 1b 	sts	0x1B8A, r25	; 0x801b8a <xCommandReadyBSem+0x1>
    3294:	80 93 89 1b 	sts	0x1B89, r24	; 0x801b89 <xCommandReadyBSem>
    3298:	a1 2c       	mov	r10, r1
    
    // Todo: Check return variable to ensure RTOS utilities were successfully initialized before continue
    
    xTaskCreate(vMainCommunicationTask, "Comm", 300, NULL, 3, NULL); // Dependant on ISR from UART, sends instructions to other tasks
    329a:	b1 2c       	mov	r11, r1
    329c:	c1 2c       	mov	r12, r1
    329e:	d1 2c       	mov	r13, r1
    32a0:	e1 2c       	mov	r14, r1
    32a2:	f1 2c       	mov	r15, r1
    32a4:	03 e0       	ldi	r16, 0x03	; 3
    32a6:	20 e0       	ldi	r18, 0x00	; 0
    32a8:	30 e0       	ldi	r19, 0x00	; 0
    32aa:	4c e2       	ldi	r20, 0x2C	; 44
    32ac:	51 e0       	ldi	r21, 0x01	; 1
    32ae:	63 e7       	ldi	r22, 0x73	; 115
    32b0:	76 e0       	ldi	r23, 0x06	; 6
    32b2:	88 eb       	ldi	r24, 0xB8	; 184
    32b4:	9c e0       	ldi	r25, 0x0C	; 12
    32b6:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <xTaskGenericCreate>
    32ba:	02 e0       	ldi	r16, 0x02	; 2
    xTaskCreate(vMainPoseControllerTask, "PoseCon", 400, NULL, 2, NULL); // Dependant on estimator, sends instructions to movement task
    32bc:	20 e0       	ldi	r18, 0x00	; 0
    32be:	30 e0       	ldi	r19, 0x00	; 0
    32c0:	40 e9       	ldi	r20, 0x90	; 144
    32c2:	51 e0       	ldi	r21, 0x01	; 1
    32c4:	68 e7       	ldi	r22, 0x78	; 120
    32c6:	76 e0       	ldi	r23, 0x06	; 6
    32c8:	8f ed       	ldi	r24, 0xDF	; 223
    32ca:	9e e0       	ldi	r25, 0x0E	; 14
    32cc:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <xTaskGenericCreate>
    32d0:	04 e0       	ldi	r16, 0x04	; 4
	xTaskCreate(vMainPoseEstimatorTask, "PoseEst", 350, NULL, 4, NULL); // Independent task, uses ticks from ISR
    32d2:	20 e0       	ldi	r18, 0x00	; 0
    32d4:	30 e0       	ldi	r19, 0x00	; 0
    32d6:	4e e5       	ldi	r20, 0x5E	; 94
    32d8:	51 e0       	ldi	r21, 0x01	; 1
    32da:	60 e8       	ldi	r22, 0x80	; 128
    32dc:	76 e0       	ldi	r23, 0x06	; 6
    32de:	8e e7       	ldi	r24, 0x7E	; 126
    32e0:	97 e1       	ldi	r25, 0x17	; 23
    32e2:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <xTaskGenericCreate>
    32e6:	01 e0       	ldi	r16, 0x01	; 1
    xTaskCreate(vMainSensorTowerTask,"Tower",300, NULL, 1, NULL); // Independent task, but use pose updates from estimator
    32e8:	20 e0       	ldi	r18, 0x00	; 0
    32ea:	30 e0       	ldi	r19, 0x00	; 0
    32ec:	4c e2       	ldi	r20, 0x2C	; 44
    32ee:	51 e0       	ldi	r21, 0x01	; 1
    32f0:	68 e8       	ldi	r22, 0x88	; 136
    32f2:	76 e0       	ldi	r23, 0x06	; 6
    32f4:	87 e7       	ldi	r24, 0x77	; 119
    32f6:	9d e0       	ldi	r25, 0x0D	; 13
    32f8:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <xTaskGenericCreate>
    32fc:	0e 94 a1 09 	call	0x1342	; 0x1342 <xPortGetFreeHeapSize>

	heap = xPortGetFreeHeapSize();
    3300:	9a 83       	std	Y+2, r25	; 0x02
    3302:	89 83       	std	Y+1, r24	; 0x01
    3304:	78 94       	sei

    sei();
    3306:	80 e0       	ldi	r24, 0x00	; 0
    vLED_singleLow(ledRED);
    3308:	90 e0       	ldi	r25, 0x00	; 0
    330a:	0e 94 14 0c 	call	0x1828	; 0x1828 <vLED_singleLow>
    330e:	0e 94 0b 2b 	call	0x5616	; 0x5616 <vTaskStartScheduler>
    #ifdef DEBUG
    debug("Starting scheduler ....\n");
    #endif
    /*  Start scheduler */
    vTaskStartScheduler();
    3312:	80 e0       	ldi	r24, 0x00	; 0
	
	
	vLED_singleHigh(ledRED);
    3314:	90 e0       	ldi	r25, 0x00	; 0
    3316:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <vLED_singleHigh>
    331a:	82 e0       	ldi	r24, 0x02	; 2
	//vLED_singleHigh(ledYELLOW);
	vLED_singleHigh(ledGREEN);
    331c:	90 e0       	ldi	r25, 0x00	; 0
    331e:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <vLED_singleHigh>
    3322:	0e e8       	ldi	r16, 0x8E	; 142
	
    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
        debug("RAM fail\n");
    3324:	16 e0       	ldi	r17, 0x06	; 6
    3326:	f8 94       	cli
	//vLED_singleHigh(ledYELLOW);
	vLED_singleHigh(ledGREEN);
	
    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
    3328:	1f 93       	push	r17
        debug("RAM fail\n");
    332a:	0f 93       	push	r16
    332c:	0e 94 1a 25 	call	0x4a34	; 0x4a34 <debug>
    3330:	0f 90       	pop	r0
    3332:	0f 90       	pop	r0
    3334:	f8 cf       	rjmp	.-16     	; 0x3326 <main+0x14a>

00003336 <__vector_3>:
    3336:	1f 92       	push	r1

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    3338:	0f 92       	push	r0
    333a:	0f b6       	in	r0, 0x3f	; 63
    333c:	0f 92       	push	r0
    333e:	11 24       	eor	r1, r1
    3340:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    3342:	80 91 1d 1a 	lds	r24, 0x1A1D	; 0x801a1d <gISR_leftWheelTicks>
    3346:	8f 5f       	subi	r24, 0xFF	; 255
    3348:	80 93 1d 1a 	sts	0x1A1D, r24	; 0x801a1d <gISR_leftWheelTicks>
}
    334c:	8f 91       	pop	r24
    334e:	0f 90       	pop	r0
    3350:	0f be       	out	0x3f, r0	; 63
    3352:	0f 90       	pop	r0
    3354:	1f 90       	pop	r1
    3356:	18 95       	reti

00003358 <__vector_4>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    3358:	1f 92       	push	r1
    335a:	0f 92       	push	r0
    335c:	0f b6       	in	r0, 0x3f	; 63
    335e:	0f 92       	push	r0
    3360:	11 24       	eor	r1, r1
    3362:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    3364:	80 91 1e 1a 	lds	r24, 0x1A1E	; 0x801a1e <gISR_rightWheelTicks>
    3368:	8f 5f       	subi	r24, 0xFF	; 255
    336a:	80 93 1e 1a 	sts	0x1A1E, r24	; 0x801a1e <gISR_rightWheelTicks>
}
    336e:	8f 91       	pop	r24
    3370:	0f 90       	pop	r0
    3372:	0f be       	out	0x3f, r0	; 63
    3374:	0f 90       	pop	r0
    3376:	1f 90       	pop	r1
    3378:	18 95       	reti

0000337a <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    337a:	1f 92       	push	r1
    337c:	0f 92       	push	r0
    337e:	0f b6       	in	r0, 0x3f	; 63
    3380:	0f 92       	push	r0
    3382:	11 24       	eor	r1, r1
    3384:	0b b6       	in	r0, 0x3b	; 59
    3386:	0f 92       	push	r0
    3388:	2f 93       	push	r18
    338a:	3f 93       	push	r19
    338c:	4f 93       	push	r20
    338e:	5f 93       	push	r21
    3390:	6f 93       	push	r22
    3392:	7f 93       	push	r23
    3394:	8f 93       	push	r24
    3396:	9f 93       	push	r25
    3398:	af 93       	push	r26
    339a:	bf 93       	push	r27
    339c:	ef 93       	push	r30
    339e:	ff 93       	push	r31
    if (nRFconnected){
    33a0:	64 9b       	sbis	0x0c, 4	; 12
    33a2:	0c c0       	rjmp	.+24     	; 0x33bc <__vector_5+0x42>
        // indicate we are connected
        //vLED_singleHigh(ledGREEN);
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    33a4:	10 92 1c 1a 	sts	0x1A1C, r1	; 0x801a1c <gHandshook>
        gPaused = FALSE;
    33a8:	10 92 1b 1a 	sts	0x1A1B, r1	; 0x801a1b <gPaused>
        //vLED_singleLow(ledGREEN);
        //vLED_singleLow(ledYELLOW);
        //vLED_singleLow(ledRED);
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    33ac:	60 e0       	ldi	r22, 0x00	; 0
    33ae:	70 e0       	ldi	r23, 0x00	; 0
    33b0:	80 91 89 1b 	lds	r24, 0x1B89	; 0x801b89 <xCommandReadyBSem>
    33b4:	90 91 8a 1b 	lds	r25, 0x1B8A	; 0x801b8a <xCommandReadyBSem+0x1>
    33b8:	0e 94 5d 22 	call	0x44ba	; 0x44ba <xQueueGiveFromISR>
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    33bc:	60 e0       	ldi	r22, 0x00	; 0
    33be:	70 e0       	ldi	r23, 0x00	; 0
    33c0:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <xControllerBSem>
    33c4:	90 91 84 1b 	lds	r25, 0x1B84	; 0x801b84 <xControllerBSem+0x1>
    33c8:	0e 94 5d 22 	call	0x44ba	; 0x44ba <xQueueGiveFromISR>
}
    33cc:	ff 91       	pop	r31
    33ce:	ef 91       	pop	r30
    33d0:	bf 91       	pop	r27
    33d2:	af 91       	pop	r26
    33d4:	9f 91       	pop	r25
    33d6:	8f 91       	pop	r24
    33d8:	7f 91       	pop	r23
    33da:	6f 91       	pop	r22
    33dc:	5f 91       	pop	r21
    33de:	4f 91       	pop	r20
    33e0:	3f 91       	pop	r19
    33e2:	2f 91       	pop	r18
    33e4:	0f 90       	pop	r0
    33e6:	0b be       	out	0x3b, r0	; 59
    33e8:	0f 90       	pop	r0
    33ea:	0f be       	out	0x3f, r0	; 63
    33ec:	0f 90       	pop	r0
    33ee:	1f 90       	pop	r1
    33f0:	18 95       	reti

000033f2 <vMotor_init>:

void vMotorGlideRight(){
    motorRightPWM = 0;
    //PORTH &= ~(1<<motorRightOn);
    PORTH &= ~(1<<motorRightForward);
    PORTH &= ~(1<<motorRightBackward);
    33f2:	e1 e0       	ldi	r30, 0x01	; 1
    33f4:	f1 e0       	ldi	r31, 0x01	; 1
    33f6:	80 81       	ld	r24, Z
    33f8:	80 63       	ori	r24, 0x30	; 48
    33fa:	80 83       	st	Z, r24
    33fc:	26 9a       	sbi	0x04, 6	; 4
    33fe:	84 b1       	in	r24, 0x04	; 4
    3400:	80 66       	ori	r24, 0x60	; 96
    3402:	84 b9       	out	0x04, r24	; 4
    3404:	27 9a       	sbi	0x04, 7	; 4
    3406:	2f 98       	cbi	0x05, 7	; 5
    3408:	2e 98       	cbi	0x05, 6	; 5
    340a:	85 b1       	in	r24, 0x05	; 5
    340c:	8f 79       	andi	r24, 0x9F	; 159
    340e:	85 b9       	out	0x05, r24	; 5
    3410:	e2 e0       	ldi	r30, 0x02	; 2
    3412:	f1 e0       	ldi	r31, 0x01	; 1
    3414:	80 81       	ld	r24, Z
    3416:	8f 7c       	andi	r24, 0xCF	; 207
    3418:	80 83       	st	Z, r24
    341a:	8a b1       	in	r24, 0x0a	; 10
    341c:	8a b9       	out	0x0a, r24	; 10
    341e:	8b b1       	in	r24, 0x0b	; 11
    3420:	8c 60       	ori	r24, 0x0C	; 12
    3422:	8b b9       	out	0x0b, r24	; 11
    3424:	6c 98       	cbi	0x0d, 4	; 13
    3426:	8d b3       	in	r24, 0x1d	; 29
    3428:	8d bb       	out	0x1d, r24	; 29
    342a:	e9 e6       	ldi	r30, 0x69	; 105
    342c:	f0 e0       	ldi	r31, 0x00	; 0
    342e:	80 81       	ld	r24, Z
    3430:	80 6f       	ori	r24, 0xF0	; 240
    3432:	80 83       	st	Z, r24
    3434:	ea e6       	ldi	r30, 0x6A	; 106
    3436:	f0 e0       	ldi	r31, 0x00	; 0
    3438:	80 81       	ld	r24, Z
    343a:	81 60       	ori	r24, 0x01	; 1
    343c:	80 83       	st	Z, r24
    343e:	8c e1       	ldi	r24, 0x1C	; 28
    3440:	8c bb       	out	0x1c, r24	; 28
    3442:	8d b3       	in	r24, 0x1d	; 29
    3444:	8c 61       	ori	r24, 0x1C	; 28
    3446:	8d bb       	out	0x1d, r24	; 29
    3448:	84 b5       	in	r24, 0x24	; 36
    344a:	80 68       	ori	r24, 0x80	; 128
    344c:	84 bd       	out	0x24, r24	; 36
    344e:	e0 e8       	ldi	r30, 0x80	; 128
    3450:	f0 e0       	ldi	r31, 0x00	; 0
    3452:	80 81       	ld	r24, Z
    3454:	80 62       	ori	r24, 0x20	; 32
    3456:	80 83       	st	Z, r24
    3458:	84 b5       	in	r24, 0x24	; 36
    345a:	83 60       	ori	r24, 0x03	; 3
    345c:	84 bd       	out	0x24, r24	; 36
    345e:	85 b5       	in	r24, 0x25	; 37
    3460:	85 bd       	out	0x25, r24	; 37
    3462:	80 81       	ld	r24, Z
    3464:	81 60       	ori	r24, 0x01	; 1
    3466:	80 83       	st	Z, r24
    3468:	a1 e8       	ldi	r26, 0x81	; 129
    346a:	b0 e0       	ldi	r27, 0x00	; 0
    346c:	8c 91       	ld	r24, X
    346e:	88 60       	ori	r24, 0x08	; 8
    3470:	8c 93       	st	X, r24
    3472:	85 b5       	in	r24, 0x25	; 37
    3474:	85 60       	ori	r24, 0x05	; 5
    3476:	85 bd       	out	0x25, r24	; 37
    3478:	8c 91       	ld	r24, X
    347a:	85 60       	ori	r24, 0x05	; 5
    347c:	8c 93       	st	X, r24
    347e:	80 81       	ld	r24, Z
    3480:	80 83       	st	Z, r24
    3482:	e0 eb       	ldi	r30, 0xB0	; 176
    3484:	f0 e0       	ldi	r31, 0x00	; 0
    3486:	80 81       	ld	r24, Z
    3488:	80 83       	st	Z, r24
    348a:	80 81       	ld	r24, Z
    348c:	80 83       	st	Z, r24
    348e:	e0 ea       	ldi	r30, 0xA0	; 160
    3490:	f0 e0       	ldi	r31, 0x00	; 0
    3492:	80 81       	ld	r24, Z
    3494:	80 83       	st	Z, r24
    3496:	08 95       	ret

00003498 <vMotorMoveLeftForward>:
    3498:	87 bd       	out	0x27, r24	; 39
    349a:	2c 9a       	sbi	0x05, 4	; 5
    349c:	2d 98       	cbi	0x05, 5	; 5
    349e:	84 e0       	ldi	r24, 0x04	; 4
    34a0:	fb 01       	movw	r30, r22
    34a2:	80 83       	st	Z, r24
    34a4:	08 95       	ret

000034a6 <vMotorMoveRightForward>:
    34a6:	90 e0       	ldi	r25, 0x00	; 0
    34a8:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    34ac:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    34b0:	e2 e0       	ldi	r30, 0x02	; 2
    34b2:	f1 e0       	ldi	r31, 0x01	; 1
    34b4:	80 81       	ld	r24, Z
    34b6:	80 64       	ori	r24, 0x40	; 64
    34b8:	80 83       	st	Z, r24
    34ba:	80 81       	ld	r24, Z
    34bc:	8f 7d       	andi	r24, 0xDF	; 223
    34be:	80 83       	st	Z, r24
    34c0:	86 e0       	ldi	r24, 0x06	; 6
    34c2:	fb 01       	movw	r30, r22
    34c4:	80 83       	st	Z, r24
    34c6:	08 95       	ret

000034c8 <vMotorMoveLeftBackward>:
    34c8:	87 bd       	out	0x27, r24	; 39
    34ca:	2c 98       	cbi	0x05, 4	; 5
    34cc:	2d 9a       	sbi	0x05, 5	; 5
    34ce:	85 e0       	ldi	r24, 0x05	; 5
    34d0:	fb 01       	movw	r30, r22
    34d2:	80 83       	st	Z, r24
    34d4:	08 95       	ret

000034d6 <vMotorMoveRightBackward>:
    34d6:	90 e0       	ldi	r25, 0x00	; 0
    34d8:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    34dc:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    34e0:	e2 e0       	ldi	r30, 0x02	; 2
    34e2:	f1 e0       	ldi	r31, 0x01	; 1
    34e4:	80 81       	ld	r24, Z
    34e6:	8f 7b       	andi	r24, 0xBF	; 191
    34e8:	80 83       	st	Z, r24
    34ea:	80 81       	ld	r24, Z
    34ec:	80 62       	ori	r24, 0x20	; 32
    34ee:	80 83       	st	Z, r24
    34f0:	85 e0       	ldi	r24, 0x05	; 5
    34f2:	fb 01       	movw	r30, r22
    34f4:	80 83       	st	Z, r24
    34f6:	08 95       	ret

000034f8 <vMotorBrakeLeft>:
    34f8:	17 bc       	out	0x27, r1	; 39
    34fa:	2c 98       	cbi	0x05, 4	; 5
    34fc:	2d 98       	cbi	0x05, 5	; 5
    34fe:	08 95       	ret

00003500 <vMotorBrakeRight>:
    3500:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    3504:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    3508:	e2 e0       	ldi	r30, 0x02	; 2
    350a:	f1 e0       	ldi	r31, 0x01	; 1
    350c:	80 81       	ld	r24, Z
    350e:	8f 7b       	andi	r24, 0xBF	; 191
    3510:	80 83       	st	Z, r24
    3512:	80 81       	ld	r24, Z
    3514:	8f 7d       	andi	r24, 0xDF	; 223
    3516:	80 83       	st	Z, r24
    3518:	08 95       	ret

0000351a <vMotorMovementSwitch>:
}

/* Switch for robot movement to abstract the logic away from main */

void vMotorMovementSwitch(int16_t leftSpeed, int16_t rightSpeed, uint8_t *leftWheelDirection, uint8_t *rightWheelDirection){
    351a:	0f 93       	push	r16
    351c:	1f 93       	push	r17
    351e:	cf 93       	push	r28
    3520:	df 93       	push	r29
    3522:	eb 01       	movw	r28, r22
    3524:	89 01       	movw	r16, r18
    if (leftSpeed > 0){
    3526:	18 16       	cp	r1, r24
    3528:	19 06       	cpc	r1, r25
    352a:	1c f4       	brge	.+6      	; 0x3532 <vMotorMovementSwitch+0x18>
		vMotorMoveLeftForward(leftSpeed, leftWheelDirection);
    352c:	ba 01       	movw	r22, r20
    352e:	b4 df       	rcall	.-152    	; 0x3498 <vMotorMoveLeftForward>
    3530:	07 c0       	rjmp	.+14     	; 0x3540 <vMotorMovementSwitch+0x26>
    }else if(leftSpeed < 0){
    3532:	99 23       	and	r25, r25
    3534:	24 f4       	brge	.+8      	; 0x353e <vMotorMovementSwitch+0x24>
		vMotorMoveLeftBackward(-leftSpeed,leftWheelDirection);
    3536:	ba 01       	movw	r22, r20
    3538:	81 95       	neg	r24
    353a:	c6 df       	rcall	.-116    	; 0x34c8 <vMotorMoveLeftBackward>
    }else{
		vMotorBrakeLeft();
    353c:	01 c0       	rjmp	.+2      	; 0x3540 <vMotorMovementSwitch+0x26>
    353e:	dc df       	rcall	.-72     	; 0x34f8 <vMotorBrakeLeft>
	}
	
	if (rightSpeed > 0) {
    3540:	1c 16       	cp	r1, r28
    3542:	1d 06       	cpc	r1, r29
		vMotorMoveRightForward(rightSpeed,rightWheelDirection);
    3544:	24 f4       	brge	.+8      	; 0x354e <vMotorMovementSwitch+0x34>
    3546:	b8 01       	movw	r22, r16
    3548:	8c 2f       	mov	r24, r28
    354a:	ad df       	rcall	.-166    	; 0x34a6 <vMotorMoveRightForward>
    354c:	08 c0       	rjmp	.+16     	; 0x355e <vMotorMovementSwitch+0x44>
	}else if (rightSpeed < 0) {
    354e:	dd 23       	and	r29, r29
		vMotorMoveRightBackward(-rightSpeed,rightWheelDirection);
    3550:	2c f4       	brge	.+10     	; 0x355c <vMotorMovementSwitch+0x42>
    3552:	b8 01       	movw	r22, r16
    3554:	8c 2f       	mov	r24, r28
    3556:	81 95       	neg	r24
    3558:	be df       	rcall	.-132    	; 0x34d6 <vMotorMoveRightBackward>
	}else {
		vMotorBrakeRight();
    355a:	01 c0       	rjmp	.+2      	; 0x355e <vMotorMovementSwitch+0x44>
    355c:	d1 df       	rcall	.-94     	; 0x3500 <vMotorBrakeRight>
	}
}
    355e:	df 91       	pop	r29
    3560:	cf 91       	pop	r28
    3562:	1f 91       	pop	r17
    3564:	0f 91       	pop	r16
    3566:	08 95       	ret

00003568 <vMotorEncoderLeftTickFromISR>:

/* Handle ISR ticks from encoder, Please note that we are losing accuracy here due to division */
void vMotorEncoderLeftTickFromISR(uint8_t wheelDirection, int16_t *leftWheelTicks, uint8_t leftEncoderTicks){
    switch (wheelDirection){
    3568:	84 30       	cpi	r24, 0x04	; 4
    356a:	19 f0       	breq	.+6      	; 0x3572 <vMotorEncoderLeftTickFromISR+0xa>
    356c:	85 30       	cpi	r24, 0x05	; 5
    356e:	49 f0       	breq	.+18     	; 0x3582 <vMotorEncoderLeftTickFromISR+0x1a>
    3570:	08 95       	ret
        case motorLeftForward:{
            *leftWheelTicks += leftEncoderTicks;
    3572:	fb 01       	movw	r30, r22
    3574:	80 81       	ld	r24, Z
    3576:	91 81       	ldd	r25, Z+1	; 0x01
    3578:	84 0f       	add	r24, r20
    357a:	91 1d       	adc	r25, r1
    357c:	91 83       	std	Z+1, r25	; 0x01
    357e:	80 83       	st	Z, r24
            break;
    3580:	08 95       	ret
        }
        case  motorLeftBackward:{
            *leftWheelTicks -= leftEncoderTicks;
    3582:	fb 01       	movw	r30, r22
    3584:	80 81       	ld	r24, Z
    3586:	91 81       	ldd	r25, Z+1	; 0x01
    3588:	84 1b       	sub	r24, r20
    358a:	91 09       	sbc	r25, r1
    358c:	91 83       	std	Z+1, r25	; 0x01
    358e:	80 83       	st	Z, r24
    3590:	08 95       	ret

00003592 <vMotorEncoderRightTickFromISR>:
        // We have a count when the robot is supposedly not moving.
        break;
    }
}
void vMotorEncoderRightTickFromISR(uint8_t wheelDirection, int16_t *rightWheelTicks, uint8_t rightEncoderTicks){
    switch (wheelDirection){
    3592:	85 30       	cpi	r24, 0x05	; 5
    3594:	51 f0       	breq	.+20     	; 0x35aa <vMotorEncoderRightTickFromISR+0x18>
    3596:	86 30       	cpi	r24, 0x06	; 6
    3598:	79 f4       	brne	.+30     	; 0x35b8 <vMotorEncoderRightTickFromISR+0x26>
        case motorRightForward:{
            *rightWheelTicks += rightEncoderTicks;
    359a:	fb 01       	movw	r30, r22
    359c:	80 81       	ld	r24, Z
    359e:	91 81       	ldd	r25, Z+1	; 0x01
    35a0:	84 0f       	add	r24, r20
    35a2:	91 1d       	adc	r25, r1
    35a4:	91 83       	std	Z+1, r25	; 0x01
    35a6:	80 83       	st	Z, r24
            break;
    35a8:	08 95       	ret
        }
        case  motorRightBackward:{
            *rightWheelTicks -= rightEncoderTicks;
    35aa:	fb 01       	movw	r30, r22
    35ac:	80 81       	ld	r24, Z
    35ae:	91 81       	ldd	r25, Z+1	; 0x01
    35b0:	84 1b       	sub	r24, r20
    35b2:	91 09       	sbc	r25, r1
    35b4:	91 83       	std	Z+1, r25	; 0x01
    35b6:	80 83       	st	Z, r24
    35b8:	08 95       	ret

000035ba <network_receive>:

uint8_t network_get_address(void) {
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint8_t len) {
    35ba:	ef 92       	push	r14
    35bc:	ff 92       	push	r15
    35be:	0f 93       	push	r16
    35c0:	1f 93       	push	r17
    35c2:	cf 93       	push	r28
    35c4:	df 93       	push	r29
    35c6:	7c 01       	movw	r14, r24
	uint8_t *decoded_data = pvPortMalloc(len);
    35c8:	c6 2f       	mov	r28, r22
    35ca:	d0 e0       	ldi	r29, 0x00	; 0
    35cc:	ce 01       	movw	r24, r28
    35ce:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    35d2:	8c 01       	movw	r16, r24
	cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    35d4:	9e 01       	movw	r18, r28
    35d6:	21 50       	subi	r18, 0x01	; 1
    35d8:	31 09       	sbc	r19, r1
    35da:	a7 01       	movw	r20, r14
    35dc:	be 01       	movw	r22, r28
    35de:	0e 94 04 07 	call	0xe08	; 0xe08 <cobs_decode>
	
	if(result.status != COBS_DECODE_OK) {
    35e2:	88 23       	and	r24, r24
    35e4:	21 f0       	breq	.+8      	; 0x35ee <network_receive+0x34>
		vPortFree(decoded_data);
    35e6:	c8 01       	movw	r24, r16
    35e8:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
		return;
    35ec:	33 c0       	rjmp	.+102    	; 0x3654 <network_receive+0x9a>
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint8_t len) {
	uint8_t *decoded_data = pvPortMalloc(len);
	cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    35ee:	86 2f       	mov	r24, r22
    35f0:	97 2f       	mov	r25, r23
    35f2:	ec 01       	movw	r28, r24
	
	if(result.status != COBS_DECODE_OK) {
		vPortFree(decoded_data);
		return;
	}
	if(decoded_data[result.out_len-1] != calculate_crc(decoded_data, result.out_len-1) ) {
    35f4:	f8 01       	movw	r30, r16
    35f6:	e8 0f       	add	r30, r24
    35f8:	f9 1f       	adc	r31, r25
    35fa:	31 97       	sbiw	r30, 0x01	; 1
    35fc:	f0 80       	ld	r15, Z
    35fe:	6f ef       	ldi	r22, 0xFF	; 255
    3600:	68 0f       	add	r22, r24
    3602:	c8 01       	movw	r24, r16
    3604:	0e 94 8e 07 	call	0xf1c	; 0xf1c <calculate_crc>
    3608:	f8 16       	cp	r15, r24
    360a:	21 f0       	breq	.+8      	; 0x3614 <network_receive+0x5a>
		vPortFree(decoded_data);
    360c:	c8 01       	movw	r24, r16
    360e:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
		return;
    3612:	20 c0       	rjmp	.+64     	; 0x3654 <network_receive+0x9a>
	}
	uint8_t receiver = decoded_data[0];
	uint8_t sender = decoded_data[1];
	uint8_t protocol = decoded_data[2];
	if(receiver != ADDRESS) {
    3614:	d8 01       	movw	r26, r16
    3616:	8c 91       	ld	r24, X
    3618:	83 30       	cpi	r24, 0x03	; 3
    361a:	21 f0       	breq	.+8      	; 0x3624 <network_receive+0x6a>
		vPortFree(decoded_data);
    361c:	c8 01       	movw	r24, r16
    361e:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
		return;
    3622:	18 c0       	rjmp	.+48     	; 0x3654 <network_receive+0x9a>
	}
	receive_callbacks[protocol](sender, decoded_data+3, result.out_len-4);
    3624:	ae 01       	movw	r20, r28
    3626:	44 50       	subi	r20, 0x04	; 4
    3628:	51 09       	sbc	r21, r1
    362a:	b8 01       	movw	r22, r16
    362c:	6d 5f       	subi	r22, 0xFD	; 253
    362e:	7f 4f       	sbci	r23, 0xFF	; 255
    3630:	d8 01       	movw	r26, r16
    3632:	12 96       	adiw	r26, 0x02	; 2
    3634:	ec 91       	ld	r30, X
    3636:	12 97       	sbiw	r26, 0x02	; 2
    3638:	f0 e0       	ldi	r31, 0x00	; 0
    363a:	ee 0f       	add	r30, r30
    363c:	ff 1f       	adc	r31, r31
    363e:	e9 55       	subi	r30, 0x59	; 89
    3640:	f4 4e       	sbci	r31, 0xE4	; 228
    3642:	01 90       	ld	r0, Z+
    3644:	f0 81       	ld	r31, Z
    3646:	e0 2d       	mov	r30, r0
    3648:	11 96       	adiw	r26, 0x01	; 1
    364a:	8c 91       	ld	r24, X
    364c:	19 95       	eicall
	vPortFree(decoded_data);
    364e:	c8 01       	movw	r24, r16
    3650:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
}
    3654:	df 91       	pop	r29
    3656:	cf 91       	pop	r28
    3658:	1f 91       	pop	r17
    365a:	0f 91       	pop	r16
    365c:	ff 90       	pop	r15
    365e:	ef 90       	pop	r14
    3660:	08 95       	ret

00003662 <network_init>:
void network_receive(uint8_t *frame, uint8_t len);

void (*receive_callbacks[10])(uint8_t, uint8_t*, uint16_t);

void network_init(void) {
  vUSART_set_receive_callback(network_receive);
    3662:	8d ed       	ldi	r24, 0xDD	; 221
    3664:	9a e1       	ldi	r25, 0x1A	; 26
    3666:	0c 94 a7 33 	jmp	0x674e	; 0x674e <vUSART_set_receive_callback>
    366a:	08 95       	ret

0000366c <network_set_callback>:
}

void network_set_callback(uint8_t protocol, void (*cb)(uint8_t, uint8_t*, uint16_t)) {
  if(protocol == PROTOCOL_ARQ || protocol == PROTOCOL_SIMPLE) receive_callbacks[protocol] = cb;
    366c:	82 30       	cpi	r24, 0x02	; 2
    366e:	40 f4       	brcc	.+16     	; 0x3680 <network_set_callback+0x14>
    3670:	e8 2f       	mov	r30, r24
    3672:	f0 e0       	ldi	r31, 0x00	; 0
    3674:	ee 0f       	add	r30, r30
    3676:	ff 1f       	adc	r31, r31
    3678:	e9 55       	subi	r30, 0x59	; 89
    367a:	f4 4e       	sbci	r31, 0xE4	; 228
    367c:	71 83       	std	Z+1, r23	; 0x01
    367e:	60 83       	st	Z, r22
    3680:	08 95       	ret

00003682 <network_send>:
}
    
uint8_t network_send(uint8_t remote_address, uint8_t protocol, uint8_t *data, uint16_t len) {
    3682:	8f 92       	push	r8
    3684:	9f 92       	push	r9
    3686:	af 92       	push	r10
    3688:	bf 92       	push	r11
    368a:	cf 92       	push	r12
    368c:	df 92       	push	r13
    368e:	ef 92       	push	r14
    3690:	ff 92       	push	r15
    3692:	0f 93       	push	r16
    3694:	1f 93       	push	r17
    3696:	cf 93       	push	r28
    3698:	df 93       	push	r29
    369a:	88 2e       	mov	r8, r24
    369c:	96 2e       	mov	r9, r22
    369e:	5a 01       	movw	r10, r20
    36a0:	89 01       	movw	r16, r18
  uint8_t *packet = pvPortMalloc(len+4);
    36a2:	69 01       	movw	r12, r18
    36a4:	84 e0       	ldi	r24, 0x04	; 4
    36a6:	c8 0e       	add	r12, r24
    36a8:	d1 1c       	adc	r13, r1
    36aa:	c6 01       	movw	r24, r12
    36ac:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    36b0:	ec 01       	movw	r28, r24
  uint8_t *encoded_data = pvPortMalloc(len+6);
    36b2:	c8 01       	movw	r24, r16
    36b4:	06 96       	adiw	r24, 0x06	; 6
    36b6:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    36ba:	7c 01       	movw	r14, r24
  if(packet == NULL || encoded_data == NULL) {
    36bc:	20 97       	sbiw	r28, 0x00	; 0
    36be:	11 f0       	breq	.+4      	; 0x36c4 <network_send+0x42>
    36c0:	89 2b       	or	r24, r25
    36c2:	41 f4       	brne	.+16     	; 0x36d4 <network_send+0x52>
    vPortFree(packet);
    36c4:	ce 01       	movw	r24, r28
    36c6:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    vPortFree(encoded_data);
    36ca:	c7 01       	movw	r24, r14
    36cc:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    return 0;
    36d0:	80 e0       	ldi	r24, 0x00	; 0
    36d2:	3c c0       	rjmp	.+120    	; 0x374c <network_send+0xca>
  }
  packet[0] = remote_address;
    36d4:	88 82       	st	Y, r8
  packet[1] = ADDRESS;
    36d6:	83 e0       	ldi	r24, 0x03	; 3
    36d8:	89 83       	std	Y+1, r24	; 0x01
  packet[2] = protocol;
    36da:	9a 82       	std	Y+2, r9	; 0x02
  memcpy(packet+3, data, len);
    36dc:	a8 01       	movw	r20, r16
    36de:	b5 01       	movw	r22, r10
    36e0:	ce 01       	movw	r24, r28
    36e2:	03 96       	adiw	r24, 0x03	; 3
    36e4:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
  packet[3+len] = calculate_crc(packet, 3+len);
    36e8:	58 01       	movw	r10, r16
    36ea:	e3 e0       	ldi	r30, 0x03	; 3
    36ec:	ae 0e       	add	r10, r30
    36ee:	b1 1c       	adc	r11, r1
    36f0:	ac 0e       	add	r10, r28
    36f2:	bd 1e       	adc	r11, r29
    36f4:	63 e0       	ldi	r22, 0x03	; 3
    36f6:	60 0f       	add	r22, r16
    36f8:	ce 01       	movw	r24, r28
    36fa:	0e 94 8e 07 	call	0xf1c	; 0xf1c <calculate_crc>
    36fe:	f5 01       	movw	r30, r10
    3700:	80 83       	st	Z, r24
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    3702:	b8 01       	movw	r22, r16
    3704:	6b 5f       	subi	r22, 0xFB	; 251
    3706:	7f 4f       	sbci	r23, 0xFF	; 255
    3708:	96 01       	movw	r18, r12
    370a:	ae 01       	movw	r20, r28
    370c:	c7 01       	movw	r24, r14
    370e:	0e 94 9e 06 	call	0xd3c	; 0xd3c <cobs_encode>
  if(result.status != COBS_ENCODE_OK) {
    3712:	88 23       	and	r24, r24
    3714:	41 f0       	breq	.+16     	; 0x3726 <network_send+0xa4>
    vPortFree(packet);
    3716:	ce 01       	movw	r24, r28
    3718:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    vPortFree(encoded_data);
    371c:	c7 01       	movw	r24, r14
    371e:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    return 0;
    3722:	80 e0       	ldi	r24, 0x00	; 0
    3724:	13 c0       	rjmp	.+38     	; 0x374c <network_send+0xca>
  packet[0] = remote_address;
  packet[1] = ADDRESS;
  packet[2] = protocol;
  memcpy(packet+3, data, len);
  packet[3+len] = calculate_crc(packet, 3+len);
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    3726:	86 2f       	mov	r24, r22
    3728:	97 2f       	mov	r25, r23
  if(result.status != COBS_ENCODE_OK) {
    vPortFree(packet);
    vPortFree(encoded_data);
    return 0;
  }
  encoded_data[result.out_len] = 0x00;
    372a:	f7 01       	movw	r30, r14
    372c:	e8 0f       	add	r30, r24
    372e:	f9 1f       	adc	r31, r25
    3730:	10 82       	st	Z, r1
  vUSART_send(encoded_data, result.out_len+1);
    3732:	bc 01       	movw	r22, r24
    3734:	6f 5f       	subi	r22, 0xFF	; 255
    3736:	7f 4f       	sbci	r23, 0xFF	; 255
    3738:	c7 01       	movw	r24, r14
    373a:	0e 94 83 33 	call	0x6706	; 0x6706 <vUSART_send>
  vPortFree(packet);
    373e:	ce 01       	movw	r24, r28
    3740:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  vPortFree(encoded_data);
    3744:	c7 01       	movw	r24, r14
    3746:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  return 1;
    374a:	81 e0       	ldi	r24, 0x01	; 1
}
    374c:	df 91       	pop	r29
    374e:	cf 91       	pop	r28
    3750:	1f 91       	pop	r17
    3752:	0f 91       	pop	r16
    3754:	ff 90       	pop	r15
    3756:	ef 90       	pop	r14
    3758:	df 90       	pop	r13
    375a:	cf 90       	pop	r12
    375c:	bf 90       	pop	r11
    375e:	af 90       	pop	r10
    3760:	9f 90       	pop	r9
    3762:	8f 90       	pop	r8
    3764:	08 95       	ret

00003766 <pxPortInitialiseStack>:
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    3766:	31 e1       	ldi	r19, 0x11	; 17
    3768:	fc 01       	movw	r30, r24
    376a:	30 83       	st	Z, r19
    376c:	31 97       	sbiw	r30, 0x01	; 1
    376e:	22 e2       	ldi	r18, 0x22	; 34
    3770:	20 83       	st	Z, r18
    3772:	31 97       	sbiw	r30, 0x01	; 1
    3774:	a3 e3       	ldi	r26, 0x33	; 51
    3776:	a0 83       	st	Z, r26
    3778:	31 97       	sbiw	r30, 0x01	; 1
    377a:	60 83       	st	Z, r22
    377c:	31 97       	sbiw	r30, 0x01	; 1
    377e:	70 83       	st	Z, r23
    3780:	31 97       	sbiw	r30, 0x01	; 1
    3782:	10 82       	st	Z, r1
    3784:	31 97       	sbiw	r30, 0x01	; 1
    3786:	10 82       	st	Z, r1
    3788:	31 97       	sbiw	r30, 0x01	; 1
    378a:	60 e8       	ldi	r22, 0x80	; 128
    378c:	60 83       	st	Z, r22
    378e:	31 97       	sbiw	r30, 0x01	; 1
    3790:	10 82       	st	Z, r1
    3792:	31 97       	sbiw	r30, 0x01	; 1
    3794:	10 82       	st	Z, r1
    3796:	31 97       	sbiw	r30, 0x01	; 1
    3798:	10 82       	st	Z, r1
    379a:	31 97       	sbiw	r30, 0x01	; 1
    379c:	62 e0       	ldi	r22, 0x02	; 2
    379e:	60 83       	st	Z, r22
    37a0:	31 97       	sbiw	r30, 0x01	; 1
    37a2:	63 e0       	ldi	r22, 0x03	; 3
    37a4:	60 83       	st	Z, r22
    37a6:	31 97       	sbiw	r30, 0x01	; 1
    37a8:	64 e0       	ldi	r22, 0x04	; 4
    37aa:	60 83       	st	Z, r22
    37ac:	31 97       	sbiw	r30, 0x01	; 1
    37ae:	65 e0       	ldi	r22, 0x05	; 5
    37b0:	60 83       	st	Z, r22
    37b2:	31 97       	sbiw	r30, 0x01	; 1
    37b4:	66 e0       	ldi	r22, 0x06	; 6
    37b6:	60 83       	st	Z, r22
    37b8:	31 97       	sbiw	r30, 0x01	; 1
    37ba:	67 e0       	ldi	r22, 0x07	; 7
    37bc:	60 83       	st	Z, r22
    37be:	31 97       	sbiw	r30, 0x01	; 1
    37c0:	68 e0       	ldi	r22, 0x08	; 8
    37c2:	60 83       	st	Z, r22
    37c4:	31 97       	sbiw	r30, 0x01	; 1
    37c6:	69 e0       	ldi	r22, 0x09	; 9
    37c8:	60 83       	st	Z, r22
    37ca:	31 97       	sbiw	r30, 0x01	; 1
    37cc:	60 e1       	ldi	r22, 0x10	; 16
    37ce:	60 83       	st	Z, r22
    37d0:	31 97       	sbiw	r30, 0x01	; 1
    37d2:	30 83       	st	Z, r19
    37d4:	31 97       	sbiw	r30, 0x01	; 1
    37d6:	32 e1       	ldi	r19, 0x12	; 18
    37d8:	30 83       	st	Z, r19
    37da:	31 97       	sbiw	r30, 0x01	; 1
    37dc:	33 e1       	ldi	r19, 0x13	; 19
    37de:	30 83       	st	Z, r19
    37e0:	31 97       	sbiw	r30, 0x01	; 1
    37e2:	34 e1       	ldi	r19, 0x14	; 20
    37e4:	30 83       	st	Z, r19
    37e6:	31 97       	sbiw	r30, 0x01	; 1
    37e8:	35 e1       	ldi	r19, 0x15	; 21
    37ea:	30 83       	st	Z, r19
    37ec:	31 97       	sbiw	r30, 0x01	; 1
    37ee:	36 e1       	ldi	r19, 0x16	; 22
    37f0:	30 83       	st	Z, r19
    37f2:	31 97       	sbiw	r30, 0x01	; 1
    37f4:	37 e1       	ldi	r19, 0x17	; 23
    37f6:	30 83       	st	Z, r19
    37f8:	31 97       	sbiw	r30, 0x01	; 1
    37fa:	38 e1       	ldi	r19, 0x18	; 24
    37fc:	30 83       	st	Z, r19
    37fe:	31 97       	sbiw	r30, 0x01	; 1
    3800:	39 e1       	ldi	r19, 0x19	; 25
    3802:	30 83       	st	Z, r19
    3804:	31 97       	sbiw	r30, 0x01	; 1
    3806:	30 e2       	ldi	r19, 0x20	; 32
    3808:	30 83       	st	Z, r19
    380a:	31 97       	sbiw	r30, 0x01	; 1
    380c:	31 e2       	ldi	r19, 0x21	; 33
    380e:	30 83       	st	Z, r19
    3810:	31 97       	sbiw	r30, 0x01	; 1
    3812:	20 83       	st	Z, r18
    3814:	31 97       	sbiw	r30, 0x01	; 1
    3816:	23 e2       	ldi	r18, 0x23	; 35
    3818:	20 83       	st	Z, r18
    381a:	31 97       	sbiw	r30, 0x01	; 1
    381c:	40 83       	st	Z, r20
    381e:	31 97       	sbiw	r30, 0x01	; 1
    3820:	50 83       	st	Z, r21
    3822:	31 97       	sbiw	r30, 0x01	; 1
    3824:	26 e2       	ldi	r18, 0x26	; 38
    3826:	20 83       	st	Z, r18
    3828:	31 97       	sbiw	r30, 0x01	; 1
    382a:	27 e2       	ldi	r18, 0x27	; 39
    382c:	20 83       	st	Z, r18
    382e:	31 97       	sbiw	r30, 0x01	; 1
    3830:	28 e2       	ldi	r18, 0x28	; 40
    3832:	20 83       	st	Z, r18
    3834:	31 97       	sbiw	r30, 0x01	; 1
    3836:	29 e2       	ldi	r18, 0x29	; 41
    3838:	20 83       	st	Z, r18
    383a:	31 97       	sbiw	r30, 0x01	; 1
    383c:	20 e3       	ldi	r18, 0x30	; 48
    383e:	20 83       	st	Z, r18
    3840:	31 97       	sbiw	r30, 0x01	; 1
    3842:	21 e3       	ldi	r18, 0x31	; 49
    3844:	20 83       	st	Z, r18
    3846:	89 97       	sbiw	r24, 0x29	; 41
    3848:	08 95       	ret

0000384a <xPortStartScheduler>:
    384a:	88 ee       	ldi	r24, 0xE8	; 232
    384c:	93 e0       	ldi	r25, 0x03	; 3
    384e:	90 93 bc 1b 	sts	0x1BBC, r25	; 0x801bbc <portTickRateHz+0x1>
    3852:	80 93 bb 1b 	sts	0x1BBB, r24	; 0x801bbb <portTickRateHz>
    3856:	90 93 be 1b 	sts	0x1BBE, r25	; 0x801bbe <ticksRemainingInSec+0x1>
    385a:	80 93 bd 1b 	sts	0x1BBD, r24	; 0x801bbd <ticksRemainingInSec>
    385e:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    3862:	89 ef       	ldi	r24, 0xF9	; 249
    3864:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
    3868:	8b e0       	ldi	r24, 0x0B	; 11
    386a:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    386e:	e1 e7       	ldi	r30, 0x71	; 113
    3870:	f0 e0       	ldi	r31, 0x00	; 0
    3872:	80 81       	ld	r24, Z
    3874:	82 60       	ori	r24, 0x02	; 2
    3876:	80 83       	st	Z, r24
    3878:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    387c:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    3880:	cd 91       	ld	r28, X+
    3882:	cd bf       	out	0x3d, r28	; 61
    3884:	dd 91       	ld	r29, X+
    3886:	de bf       	out	0x3e, r29	; 62
    3888:	ff 91       	pop	r31
    388a:	ef 91       	pop	r30
    388c:	df 91       	pop	r29
    388e:	cf 91       	pop	r28
    3890:	bf 91       	pop	r27
    3892:	af 91       	pop	r26
    3894:	9f 91       	pop	r25
    3896:	8f 91       	pop	r24
    3898:	7f 91       	pop	r23
    389a:	6f 91       	pop	r22
    389c:	5f 91       	pop	r21
    389e:	4f 91       	pop	r20
    38a0:	3f 91       	pop	r19
    38a2:	2f 91       	pop	r18
    38a4:	1f 91       	pop	r17
    38a6:	0f 91       	pop	r16
    38a8:	ff 90       	pop	r15
    38aa:	ef 90       	pop	r14
    38ac:	df 90       	pop	r13
    38ae:	cf 90       	pop	r12
    38b0:	bf 90       	pop	r11
    38b2:	af 90       	pop	r10
    38b4:	9f 90       	pop	r9
    38b6:	8f 90       	pop	r8
    38b8:	7f 90       	pop	r7
    38ba:	6f 90       	pop	r6
    38bc:	5f 90       	pop	r5
    38be:	4f 90       	pop	r4
    38c0:	3f 90       	pop	r3
    38c2:	2f 90       	pop	r2
    38c4:	1f 90       	pop	r1
    38c6:	0f 90       	pop	r0
    38c8:	0c be       	out	0x3c, r0	; 60
    38ca:	0f 90       	pop	r0
    38cc:	0b be       	out	0x3b, r0	; 59
    38ce:	0f 90       	pop	r0
    38d0:	0f be       	out	0x3f, r0	; 63
    38d2:	0f 90       	pop	r0
    38d4:	08 95       	ret
    38d6:	81 e0       	ldi	r24, 0x01	; 1
    38d8:	08 95       	ret

000038da <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    38da:	0f 92       	push	r0
    38dc:	0f b6       	in	r0, 0x3f	; 63
    38de:	f8 94       	cli
    38e0:	0f 92       	push	r0
    38e2:	0b b6       	in	r0, 0x3b	; 59
    38e4:	0f 92       	push	r0
    38e6:	0c b6       	in	r0, 0x3c	; 60
    38e8:	0f 92       	push	r0
    38ea:	1f 92       	push	r1
    38ec:	11 24       	eor	r1, r1
    38ee:	2f 92       	push	r2
    38f0:	3f 92       	push	r3
    38f2:	4f 92       	push	r4
    38f4:	5f 92       	push	r5
    38f6:	6f 92       	push	r6
    38f8:	7f 92       	push	r7
    38fa:	8f 92       	push	r8
    38fc:	9f 92       	push	r9
    38fe:	af 92       	push	r10
    3900:	bf 92       	push	r11
    3902:	cf 92       	push	r12
    3904:	df 92       	push	r13
    3906:	ef 92       	push	r14
    3908:	ff 92       	push	r15
    390a:	0f 93       	push	r16
    390c:	1f 93       	push	r17
    390e:	2f 93       	push	r18
    3910:	3f 93       	push	r19
    3912:	4f 93       	push	r20
    3914:	5f 93       	push	r21
    3916:	6f 93       	push	r22
    3918:	7f 93       	push	r23
    391a:	8f 93       	push	r24
    391c:	9f 93       	push	r25
    391e:	af 93       	push	r26
    3920:	bf 93       	push	r27
    3922:	cf 93       	push	r28
    3924:	df 93       	push	r29
    3926:	ef 93       	push	r30
    3928:	ff 93       	push	r31
    392a:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    392e:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    3932:	0d b6       	in	r0, 0x3d	; 61
    3934:	0d 92       	st	X+, r0
    3936:	0e b6       	in	r0, 0x3e	; 62
    3938:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    393a:	0e 94 04 2e 	call	0x5c08	; 0x5c08 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    393e:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    3942:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    3946:	cd 91       	ld	r28, X+
    3948:	cd bf       	out	0x3d, r28	; 61
    394a:	dd 91       	ld	r29, X+
    394c:	de bf       	out	0x3e, r29	; 62
    394e:	ff 91       	pop	r31
    3950:	ef 91       	pop	r30
    3952:	df 91       	pop	r29
    3954:	cf 91       	pop	r28
    3956:	bf 91       	pop	r27
    3958:	af 91       	pop	r26
    395a:	9f 91       	pop	r25
    395c:	8f 91       	pop	r24
    395e:	7f 91       	pop	r23
    3960:	6f 91       	pop	r22
    3962:	5f 91       	pop	r21
    3964:	4f 91       	pop	r20
    3966:	3f 91       	pop	r19
    3968:	2f 91       	pop	r18
    396a:	1f 91       	pop	r17
    396c:	0f 91       	pop	r16
    396e:	ff 90       	pop	r15
    3970:	ef 90       	pop	r14
    3972:	df 90       	pop	r13
    3974:	cf 90       	pop	r12
    3976:	bf 90       	pop	r11
    3978:	af 90       	pop	r10
    397a:	9f 90       	pop	r9
    397c:	8f 90       	pop	r8
    397e:	7f 90       	pop	r7
    3980:	6f 90       	pop	r6
    3982:	5f 90       	pop	r5
    3984:	4f 90       	pop	r4
    3986:	3f 90       	pop	r3
    3988:	2f 90       	pop	r2
    398a:	1f 90       	pop	r1
    398c:	0f 90       	pop	r0
    398e:	0c be       	out	0x3c, r0	; 60
    3990:	0f 90       	pop	r0
    3992:	0b be       	out	0x3b, r0	; 59
    3994:	0f 90       	pop	r0
    3996:	0f be       	out	0x3f, r0	; 63
    3998:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    399a:	08 95       	ret

0000399c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    399c:	0f 92       	push	r0
    399e:	0f b6       	in	r0, 0x3f	; 63
    39a0:	f8 94       	cli
    39a2:	0f 92       	push	r0
    39a4:	0b b6       	in	r0, 0x3b	; 59
    39a6:	0f 92       	push	r0
    39a8:	0c b6       	in	r0, 0x3c	; 60
    39aa:	0f 92       	push	r0
    39ac:	1f 92       	push	r1
    39ae:	11 24       	eor	r1, r1
    39b0:	2f 92       	push	r2
    39b2:	3f 92       	push	r3
    39b4:	4f 92       	push	r4
    39b6:	5f 92       	push	r5
    39b8:	6f 92       	push	r6
    39ba:	7f 92       	push	r7
    39bc:	8f 92       	push	r8
    39be:	9f 92       	push	r9
    39c0:	af 92       	push	r10
    39c2:	bf 92       	push	r11
    39c4:	cf 92       	push	r12
    39c6:	df 92       	push	r13
    39c8:	ef 92       	push	r14
    39ca:	ff 92       	push	r15
    39cc:	0f 93       	push	r16
    39ce:	1f 93       	push	r17
    39d0:	2f 93       	push	r18
    39d2:	3f 93       	push	r19
    39d4:	4f 93       	push	r20
    39d6:	5f 93       	push	r21
    39d8:	6f 93       	push	r22
    39da:	7f 93       	push	r23
    39dc:	8f 93       	push	r24
    39de:	9f 93       	push	r25
    39e0:	af 93       	push	r26
    39e2:	bf 93       	push	r27
    39e4:	cf 93       	push	r28
    39e6:	df 93       	push	r29
    39e8:	ef 93       	push	r30
    39ea:	ff 93       	push	r31
    39ec:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    39f0:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    39f4:	0d b6       	in	r0, 0x3d	; 61
    39f6:	0d 92       	st	X+, r0
    39f8:	0e b6       	in	r0, 0x3e	; 62
    39fa:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    39fc:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    39fe:	80 91 bd 1b 	lds	r24, 0x1BBD	; 0x801bbd <ticksRemainingInSec>
    3a02:	90 91 be 1b 	lds	r25, 0x1BBE	; 0x801bbe <ticksRemainingInSec+0x1>
    3a06:	01 97       	sbiw	r24, 0x01	; 1
    3a08:	90 93 be 1b 	sts	0x1BBE, r25	; 0x801bbe <ticksRemainingInSec+0x1>
    3a0c:	80 93 bd 1b 	sts	0x1BBD, r24	; 0x801bbd <ticksRemainingInSec>
    3a10:	89 2b       	or	r24, r25
    3a12:	41 f4       	brne	.+16     	; 0x3a24 <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    3a14:	80 91 bb 1b 	lds	r24, 0x1BBB	; 0x801bbb <portTickRateHz>
    3a18:	90 91 bc 1b 	lds	r25, 0x1BBC	; 0x801bbc <portTickRateHz+0x1>
    3a1c:	90 93 be 1b 	sts	0x1BBE, r25	; 0x801bbe <ticksRemainingInSec+0x1>
    3a20:	80 93 bd 1b 	sts	0x1BBD, r24	; 0x801bbd <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    3a24:	0e 94 43 2d 	call	0x5a86	; 0x5a86 <xTaskIncrementTick>
    3a28:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    3a2a:	0e 94 04 2e 	call	0x5c08	; 0x5c08 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    3a2e:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    3a32:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    3a36:	cd 91       	ld	r28, X+
    3a38:	cd bf       	out	0x3d, r28	; 61
    3a3a:	dd 91       	ld	r29, X+
    3a3c:	de bf       	out	0x3e, r29	; 62
    3a3e:	ff 91       	pop	r31
    3a40:	ef 91       	pop	r30
    3a42:	df 91       	pop	r29
    3a44:	cf 91       	pop	r28
    3a46:	bf 91       	pop	r27
    3a48:	af 91       	pop	r26
    3a4a:	9f 91       	pop	r25
    3a4c:	8f 91       	pop	r24
    3a4e:	7f 91       	pop	r23
    3a50:	6f 91       	pop	r22
    3a52:	5f 91       	pop	r21
    3a54:	4f 91       	pop	r20
    3a56:	3f 91       	pop	r19
    3a58:	2f 91       	pop	r18
    3a5a:	1f 91       	pop	r17
    3a5c:	0f 91       	pop	r16
    3a5e:	ff 90       	pop	r15
    3a60:	ef 90       	pop	r14
    3a62:	df 90       	pop	r13
    3a64:	cf 90       	pop	r12
    3a66:	bf 90       	pop	r11
    3a68:	af 90       	pop	r10
    3a6a:	9f 90       	pop	r9
    3a6c:	8f 90       	pop	r8
    3a6e:	7f 90       	pop	r7
    3a70:	6f 90       	pop	r6
    3a72:	5f 90       	pop	r5
    3a74:	4f 90       	pop	r4
    3a76:	3f 90       	pop	r3
    3a78:	2f 90       	pop	r2
    3a7a:	1f 90       	pop	r1
    3a7c:	0f 90       	pop	r0
    3a7e:	0c be       	out	0x3c, r0	; 60
    3a80:	0f 90       	pop	r0
    3a82:	0b be       	out	0x3b, r0	; 59
    3a84:	0f 90       	pop	r0
    3a86:	0f be       	out	0x3f, r0	; 63
    3a88:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3a8a:	08 95       	ret

00003a8c <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    3a8c:	87 df       	rcall	.-242    	; 0x399c <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    3a8e:	18 95       	reti

00003a90 <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3a90:	0f 93       	push	r16
    3a92:	1f 93       	push	r17
    3a94:	cf 93       	push	r28
    3a96:	df 93       	push	r29
    3a98:	08 2f       	mov	r16, r24
    3a9a:	16 2f       	mov	r17, r22
    3a9c:	66 23       	and	r22, r22
    3a9e:	09 f4       	brne	.+2      	; 0x3aa2 <xQueueGenericCreate+0x12>
    3aa0:	3b c0       	rjmp	.+118    	; 0x3b18 <xQueueGenericCreate+0x88>
    3aa2:	86 9f       	mul	r24, r22
    3aa4:	c0 01       	movw	r24, r0
    3aa6:	11 24       	eor	r1, r1
    3aa8:	80 96       	adiw	r24, 0x20	; 32
    3aaa:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3aae:	ec 01       	movw	r28, r24
    3ab0:	00 97       	sbiw	r24, 0x00	; 0
    3ab2:	21 f4       	brne	.+8      	; 0x3abc <xQueueGenericCreate+0x2c>
    3ab4:	39 c0       	rjmp	.+114    	; 0x3b28 <xQueueGenericCreate+0x98>
    3ab6:	d9 83       	std	Y+1, r29	; 0x01
    3ab8:	c8 83       	st	Y, r28
    3aba:	03 c0       	rjmp	.+6      	; 0x3ac2 <xQueueGenericCreate+0x32>
    3abc:	4f 96       	adiw	r24, 0x1f	; 31
    3abe:	99 83       	std	Y+1, r25	; 0x01
    3ac0:	88 83       	st	Y, r24
    3ac2:	0b 8f       	std	Y+27, r16	; 0x1b
    3ac4:	1c 8f       	std	Y+28, r17	; 0x1c
    3ac6:	0f b6       	in	r0, 0x3f	; 63
    3ac8:	f8 94       	cli
    3aca:	0f 92       	push	r0
    3acc:	48 81       	ld	r20, Y
    3ace:	59 81       	ldd	r21, Y+1	; 0x01
    3ad0:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3ad2:	30 e0       	ldi	r19, 0x00	; 0
    3ad4:	6b 8d       	ldd	r22, Y+27	; 0x1b
    3ad6:	62 9f       	mul	r22, r18
    3ad8:	c0 01       	movw	r24, r0
    3ada:	63 9f       	mul	r22, r19
    3adc:	90 0d       	add	r25, r0
    3ade:	11 24       	eor	r1, r1
    3ae0:	ba 01       	movw	r22, r20
    3ae2:	68 0f       	add	r22, r24
    3ae4:	79 1f       	adc	r23, r25
    3ae6:	7b 83       	std	Y+3, r23	; 0x03
    3ae8:	6a 83       	std	Y+2, r22	; 0x02
    3aea:	1a 8e       	std	Y+26, r1	; 0x1a
    3aec:	5d 83       	std	Y+5, r21	; 0x05
    3aee:	4c 83       	std	Y+4, r20	; 0x04
    3af0:	82 1b       	sub	r24, r18
    3af2:	93 0b       	sbc	r25, r19
    3af4:	84 0f       	add	r24, r20
    3af6:	95 1f       	adc	r25, r21
    3af8:	9f 83       	std	Y+7, r25	; 0x07
    3afa:	8e 83       	std	Y+6, r24	; 0x06
    3afc:	8f ef       	ldi	r24, 0xFF	; 255
    3afe:	8d 8f       	std	Y+29, r24	; 0x1d
    3b00:	8e 8f       	std	Y+30, r24	; 0x1e
    3b02:	ce 01       	movw	r24, r28
    3b04:	08 96       	adiw	r24, 0x08	; 8
    3b06:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    3b0a:	ce 01       	movw	r24, r28
    3b0c:	41 96       	adiw	r24, 0x11	; 17
    3b0e:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    3b12:	0f 90       	pop	r0
    3b14:	0f be       	out	0x3f, r0	; 63
    3b16:	08 c0       	rjmp	.+16     	; 0x3b28 <xQueueGenericCreate+0x98>
    3b18:	8f e1       	ldi	r24, 0x1F	; 31
    3b1a:	90 e0       	ldi	r25, 0x00	; 0
    3b1c:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3b20:	ec 01       	movw	r28, r24
    3b22:	89 2b       	or	r24, r25
    3b24:	09 f0       	breq	.+2      	; 0x3b28 <xQueueGenericCreate+0x98>
    3b26:	c7 cf       	rjmp	.-114    	; 0x3ab6 <xQueueGenericCreate+0x26>
    3b28:	ce 01       	movw	r24, r28
    3b2a:	df 91       	pop	r29
    3b2c:	cf 91       	pop	r28
    3b2e:	1f 91       	pop	r17
    3b30:	0f 91       	pop	r16
    3b32:	08 95       	ret

00003b34 <xQueueCreateMutex>:
    3b34:	9f 92       	push	r9
    3b36:	af 92       	push	r10
    3b38:	bf 92       	push	r11
    3b3a:	cf 92       	push	r12
    3b3c:	df 92       	push	r13
    3b3e:	ef 92       	push	r14
    3b40:	ff 92       	push	r15
    3b42:	0f 93       	push	r16
    3b44:	1f 93       	push	r17
    3b46:	cf 93       	push	r28
    3b48:	df 93       	push	r29
    3b4a:	00 d0       	rcall	.+0      	; 0x3b4c <xQueueCreateMutex+0x18>
    3b4c:	1f 92       	push	r1
    3b4e:	1f 92       	push	r1
    3b50:	cd b7       	in	r28, 0x3d	; 61
    3b52:	de b7       	in	r29, 0x3e	; 62
    3b54:	8f e1       	ldi	r24, 0x1F	; 31
    3b56:	90 e0       	ldi	r25, 0x00	; 0
    3b58:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3b5c:	8c 01       	movw	r16, r24
    3b5e:	00 97       	sbiw	r24, 0x00	; 0
    3b60:	09 f4       	brne	.+2      	; 0x3b64 <xQueueCreateMutex+0x30>
    3b62:	58 c1       	rjmp	.+688    	; 0x3e14 <xQueueCreateMutex+0x2e0>
    3b64:	fc 01       	movw	r30, r24
    3b66:	13 82       	std	Z+3, r1	; 0x03
    3b68:	12 82       	std	Z+2, r1	; 0x02
    3b6a:	11 82       	std	Z+1, r1	; 0x01
    3b6c:	10 82       	st	Z, r1
    3b6e:	15 82       	std	Z+5, r1	; 0x05
    3b70:	14 82       	std	Z+4, r1	; 0x04
    3b72:	17 82       	std	Z+7, r1	; 0x07
    3b74:	16 82       	std	Z+6, r1	; 0x06
    3b76:	12 8e       	std	Z+26, r1	; 0x1a
    3b78:	81 e0       	ldi	r24, 0x01	; 1
    3b7a:	83 8f       	std	Z+27, r24	; 0x1b
    3b7c:	14 8e       	std	Z+28, r1	; 0x1c
    3b7e:	8f ef       	ldi	r24, 0xFF	; 255
    3b80:	85 8f       	std	Z+29, r24	; 0x1d
    3b82:	86 8f       	std	Z+30, r24	; 0x1e
    3b84:	78 01       	movw	r14, r16
    3b86:	f8 e0       	ldi	r31, 0x08	; 8
    3b88:	ef 0e       	add	r14, r31
    3b8a:	f1 1c       	adc	r15, r1
    3b8c:	c7 01       	movw	r24, r14
    3b8e:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    3b92:	68 01       	movw	r12, r16
    3b94:	81 e1       	ldi	r24, 0x11	; 17
    3b96:	c8 0e       	add	r12, r24
    3b98:	d1 1c       	adc	r13, r1
    3b9a:	c6 01       	movw	r24, r12
    3b9c:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    3ba0:	1d 82       	std	Y+5, r1	; 0x05
    3ba2:	1c 82       	std	Y+4, r1	; 0x04
    3ba4:	a1 2c       	mov	r10, r1
    3ba6:	99 24       	eor	r9, r9
    3ba8:	93 94       	inc	r9
    3baa:	bb 24       	eor	r11, r11
    3bac:	ba 94       	dec	r11
    3bae:	0f b6       	in	r0, 0x3f	; 63
    3bb0:	f8 94       	cli
    3bb2:	0f 92       	push	r0
    3bb4:	f8 01       	movw	r30, r16
    3bb6:	92 8d       	ldd	r25, Z+26	; 0x1a
    3bb8:	83 8d       	ldd	r24, Z+27	; 0x1b
    3bba:	98 17       	cp	r25, r24
    3bbc:	f0 f4       	brcc	.+60     	; 0x3bfa <xQueueCreateMutex+0xc6>
    3bbe:	80 81       	ld	r24, Z
    3bc0:	91 81       	ldd	r25, Z+1	; 0x01
    3bc2:	89 2b       	or	r24, r25
    3bc4:	09 f0       	breq	.+2      	; 0x3bc8 <xQueueCreateMutex+0x94>
    3bc6:	1d c1       	rjmp	.+570    	; 0x3e02 <xQueueCreateMutex+0x2ce>
    3bc8:	82 81       	ldd	r24, Z+2	; 0x02
    3bca:	93 81       	ldd	r25, Z+3	; 0x03
    3bcc:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <xTaskPriorityDisinherit>
    3bd0:	f8 01       	movw	r30, r16
    3bd2:	13 82       	std	Z+3, r1	; 0x03
    3bd4:	12 82       	std	Z+2, r1	; 0x02
    3bd6:	92 8d       	ldd	r25, Z+26	; 0x1a
    3bd8:	9f 5f       	subi	r25, 0xFF	; 255
    3bda:	92 8f       	std	Z+26, r25	; 0x1a
    3bdc:	91 89       	ldd	r25, Z+17	; 0x11
    3bde:	99 23       	and	r25, r25
    3be0:	39 f0       	breq	.+14     	; 0x3bf0 <xQueueCreateMutex+0xbc>
    3be2:	c6 01       	movw	r24, r12
    3be4:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    3be8:	81 30       	cpi	r24, 0x01	; 1
    3bea:	21 f4       	brne	.+8      	; 0x3bf4 <xQueueCreateMutex+0xc0>
    3bec:	76 de       	rcall	.-788    	; 0x38da <vPortYield>
    3bee:	02 c0       	rjmp	.+4      	; 0x3bf4 <xQueueCreateMutex+0xc0>
    3bf0:	81 11       	cpse	r24, r1
    3bf2:	73 de       	rcall	.-794    	; 0x38da <vPortYield>
    3bf4:	0f 90       	pop	r0
    3bf6:	0f be       	out	0x3f, r0	; 63
    3bf8:	0d c1       	rjmp	.+538    	; 0x3e14 <xQueueCreateMutex+0x2e0>
    3bfa:	8c 81       	ldd	r24, Y+4	; 0x04
    3bfc:	9d 81       	ldd	r25, Y+5	; 0x05
    3bfe:	89 2b       	or	r24, r25
    3c00:	19 f4       	brne	.+6      	; 0x3c08 <xQueueCreateMutex+0xd4>
    3c02:	0f 90       	pop	r0
    3c04:	0f be       	out	0x3f, r0	; 63
    3c06:	06 c1       	rjmp	.+524    	; 0x3e14 <xQueueCreateMutex+0x2e0>
    3c08:	a1 10       	cpse	r10, r1
    3c0a:	05 c0       	rjmp	.+10     	; 0x3c16 <xQueueCreateMutex+0xe2>
    3c0c:	ce 01       	movw	r24, r28
    3c0e:	01 96       	adiw	r24, 0x01	; 1
    3c10:	0e 94 2f 2f 	call	0x5e5e	; 0x5e5e <vTaskSetTimeOutState>
    3c14:	a9 2c       	mov	r10, r9
    3c16:	0f 90       	pop	r0
    3c18:	0f be       	out	0x3f, r0	; 63
    3c1a:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <vTaskSuspendAll>
    3c1e:	0f b6       	in	r0, 0x3f	; 63
    3c20:	f8 94       	cli
    3c22:	0f 92       	push	r0
    3c24:	f8 01       	movw	r30, r16
    3c26:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c28:	8f 3f       	cpi	r24, 0xFF	; 255
    3c2a:	09 f4       	brne	.+2      	; 0x3c2e <xQueueCreateMutex+0xfa>
    3c2c:	15 8e       	std	Z+29, r1	; 0x1d
    3c2e:	f8 01       	movw	r30, r16
    3c30:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c32:	8f 3f       	cpi	r24, 0xFF	; 255
    3c34:	09 f4       	brne	.+2      	; 0x3c38 <xQueueCreateMutex+0x104>
    3c36:	16 8e       	std	Z+30, r1	; 0x1e
    3c38:	0f 90       	pop	r0
    3c3a:	0f be       	out	0x3f, r0	; 63
    3c3c:	be 01       	movw	r22, r28
    3c3e:	6c 5f       	subi	r22, 0xFC	; 252
    3c40:	7f 4f       	sbci	r23, 0xFF	; 255
    3c42:	ce 01       	movw	r24, r28
    3c44:	01 96       	adiw	r24, 0x01	; 1
    3c46:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <xTaskCheckForTimeOut>
    3c4a:	81 11       	cpse	r24, r1
    3c4c:	96 c0       	rjmp	.+300    	; 0x3d7a <xQueueCreateMutex+0x246>
    3c4e:	0f b6       	in	r0, 0x3f	; 63
    3c50:	f8 94       	cli
    3c52:	0f 92       	push	r0
    3c54:	f8 01       	movw	r30, r16
    3c56:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c58:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c5a:	0f 90       	pop	r0
    3c5c:	0f be       	out	0x3f, r0	; 63
    3c5e:	98 13       	cpse	r25, r24
    3c60:	4a c0       	rjmp	.+148    	; 0x3cf6 <xQueueCreateMutex+0x1c2>
    3c62:	6c 81       	ldd	r22, Y+4	; 0x04
    3c64:	7d 81       	ldd	r23, Y+5	; 0x05
    3c66:	c7 01       	movw	r24, r14
    3c68:	0e 94 8c 2e 	call	0x5d18	; 0x5d18 <vTaskPlaceOnEventList>
    3c6c:	0f b6       	in	r0, 0x3f	; 63
    3c6e:	f8 94       	cli
    3c70:	0f 92       	push	r0
    3c72:	f8 01       	movw	r30, r16
    3c74:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c76:	18 16       	cp	r1, r24
    3c78:	ac f4       	brge	.+42     	; 0x3ca4 <xQueueCreateMutex+0x170>
    3c7a:	81 89       	ldd	r24, Z+17	; 0x11
    3c7c:	81 11       	cpse	r24, r1
    3c7e:	05 c0       	rjmp	.+10     	; 0x3c8a <xQueueCreateMutex+0x156>
    3c80:	11 c0       	rjmp	.+34     	; 0x3ca4 <xQueueCreateMutex+0x170>
    3c82:	f8 01       	movw	r30, r16
    3c84:	81 89       	ldd	r24, Z+17	; 0x11
    3c86:	88 23       	and	r24, r24
    3c88:	69 f0       	breq	.+26     	; 0x3ca4 <xQueueCreateMutex+0x170>
    3c8a:	c6 01       	movw	r24, r12
    3c8c:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    3c90:	81 11       	cpse	r24, r1
    3c92:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    3c96:	f8 01       	movw	r30, r16
    3c98:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c9a:	81 50       	subi	r24, 0x01	; 1
    3c9c:	86 8f       	std	Z+30, r24	; 0x1e
    3c9e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ca0:	18 16       	cp	r1, r24
    3ca2:	7c f3       	brlt	.-34     	; 0x3c82 <xQueueCreateMutex+0x14e>
    3ca4:	f8 01       	movw	r30, r16
    3ca6:	b6 8e       	std	Z+30, r11	; 0x1e
    3ca8:	0f 90       	pop	r0
    3caa:	0f be       	out	0x3f, r0	; 63
    3cac:	0f b6       	in	r0, 0x3f	; 63
    3cae:	f8 94       	cli
    3cb0:	0f 92       	push	r0
    3cb2:	85 8d       	ldd	r24, Z+29	; 0x1d
    3cb4:	18 16       	cp	r1, r24
    3cb6:	ac f4       	brge	.+42     	; 0x3ce2 <xQueueCreateMutex+0x1ae>
    3cb8:	80 85       	ldd	r24, Z+8	; 0x08
    3cba:	81 11       	cpse	r24, r1
    3cbc:	05 c0       	rjmp	.+10     	; 0x3cc8 <xQueueCreateMutex+0x194>
    3cbe:	11 c0       	rjmp	.+34     	; 0x3ce2 <xQueueCreateMutex+0x1ae>
    3cc0:	f8 01       	movw	r30, r16
    3cc2:	80 85       	ldd	r24, Z+8	; 0x08
    3cc4:	88 23       	and	r24, r24
    3cc6:	69 f0       	breq	.+26     	; 0x3ce2 <xQueueCreateMutex+0x1ae>
    3cc8:	c7 01       	movw	r24, r14
    3cca:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    3cce:	81 11       	cpse	r24, r1
    3cd0:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    3cd4:	f8 01       	movw	r30, r16
    3cd6:	85 8d       	ldd	r24, Z+29	; 0x1d
    3cd8:	81 50       	subi	r24, 0x01	; 1
    3cda:	85 8f       	std	Z+29, r24	; 0x1d
    3cdc:	85 8d       	ldd	r24, Z+29	; 0x1d
    3cde:	18 16       	cp	r1, r24
    3ce0:	7c f3       	brlt	.-34     	; 0x3cc0 <xQueueCreateMutex+0x18c>
    3ce2:	f8 01       	movw	r30, r16
    3ce4:	b5 8e       	std	Z+29, r11	; 0x1d
    3ce6:	0f 90       	pop	r0
    3ce8:	0f be       	out	0x3f, r0	; 63
    3cea:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    3cee:	81 11       	cpse	r24, r1
    3cf0:	5e cf       	rjmp	.-324    	; 0x3bae <xQueueCreateMutex+0x7a>
    3cf2:	f3 dd       	rcall	.-1050   	; 0x38da <vPortYield>
    3cf4:	5c cf       	rjmp	.-328    	; 0x3bae <xQueueCreateMutex+0x7a>
    3cf6:	0f b6       	in	r0, 0x3f	; 63
    3cf8:	f8 94       	cli
    3cfa:	0f 92       	push	r0
    3cfc:	f8 01       	movw	r30, r16
    3cfe:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d00:	18 16       	cp	r1, r24
    3d02:	ac f4       	brge	.+42     	; 0x3d2e <xQueueCreateMutex+0x1fa>
    3d04:	81 89       	ldd	r24, Z+17	; 0x11
    3d06:	81 11       	cpse	r24, r1
    3d08:	05 c0       	rjmp	.+10     	; 0x3d14 <xQueueCreateMutex+0x1e0>
    3d0a:	11 c0       	rjmp	.+34     	; 0x3d2e <xQueueCreateMutex+0x1fa>
    3d0c:	f8 01       	movw	r30, r16
    3d0e:	81 89       	ldd	r24, Z+17	; 0x11
    3d10:	88 23       	and	r24, r24
    3d12:	69 f0       	breq	.+26     	; 0x3d2e <xQueueCreateMutex+0x1fa>
    3d14:	c6 01       	movw	r24, r12
    3d16:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    3d1a:	81 11       	cpse	r24, r1
    3d1c:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    3d20:	f8 01       	movw	r30, r16
    3d22:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d24:	81 50       	subi	r24, 0x01	; 1
    3d26:	86 8f       	std	Z+30, r24	; 0x1e
    3d28:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d2a:	18 16       	cp	r1, r24
    3d2c:	7c f3       	brlt	.-34     	; 0x3d0c <xQueueCreateMutex+0x1d8>
    3d2e:	f8 01       	movw	r30, r16
    3d30:	b6 8e       	std	Z+30, r11	; 0x1e
    3d32:	0f 90       	pop	r0
    3d34:	0f be       	out	0x3f, r0	; 63
    3d36:	0f b6       	in	r0, 0x3f	; 63
    3d38:	f8 94       	cli
    3d3a:	0f 92       	push	r0
    3d3c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d3e:	18 16       	cp	r1, r24
    3d40:	ac f4       	brge	.+42     	; 0x3d6c <xQueueCreateMutex+0x238>
    3d42:	80 85       	ldd	r24, Z+8	; 0x08
    3d44:	81 11       	cpse	r24, r1
    3d46:	05 c0       	rjmp	.+10     	; 0x3d52 <xQueueCreateMutex+0x21e>
    3d48:	11 c0       	rjmp	.+34     	; 0x3d6c <xQueueCreateMutex+0x238>
    3d4a:	f8 01       	movw	r30, r16
    3d4c:	80 85       	ldd	r24, Z+8	; 0x08
    3d4e:	88 23       	and	r24, r24
    3d50:	69 f0       	breq	.+26     	; 0x3d6c <xQueueCreateMutex+0x238>
    3d52:	c7 01       	movw	r24, r14
    3d54:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    3d58:	81 11       	cpse	r24, r1
    3d5a:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    3d5e:	f8 01       	movw	r30, r16
    3d60:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d62:	81 50       	subi	r24, 0x01	; 1
    3d64:	85 8f       	std	Z+29, r24	; 0x1d
    3d66:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d68:	18 16       	cp	r1, r24
    3d6a:	7c f3       	brlt	.-34     	; 0x3d4a <xQueueCreateMutex+0x216>
    3d6c:	f8 01       	movw	r30, r16
    3d6e:	b5 8e       	std	Z+29, r11	; 0x1d
    3d70:	0f 90       	pop	r0
    3d72:	0f be       	out	0x3f, r0	; 63
    3d74:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    3d78:	1a cf       	rjmp	.-460    	; 0x3bae <xQueueCreateMutex+0x7a>
    3d7a:	0f b6       	in	r0, 0x3f	; 63
    3d7c:	f8 94       	cli
    3d7e:	0f 92       	push	r0
    3d80:	f8 01       	movw	r30, r16
    3d82:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d84:	18 16       	cp	r1, r24
    3d86:	ac f4       	brge	.+42     	; 0x3db2 <xQueueCreateMutex+0x27e>
    3d88:	81 89       	ldd	r24, Z+17	; 0x11
    3d8a:	81 11       	cpse	r24, r1
    3d8c:	05 c0       	rjmp	.+10     	; 0x3d98 <xQueueCreateMutex+0x264>
    3d8e:	11 c0       	rjmp	.+34     	; 0x3db2 <xQueueCreateMutex+0x27e>
    3d90:	f8 01       	movw	r30, r16
    3d92:	81 89       	ldd	r24, Z+17	; 0x11
    3d94:	88 23       	and	r24, r24
    3d96:	69 f0       	breq	.+26     	; 0x3db2 <xQueueCreateMutex+0x27e>
    3d98:	c6 01       	movw	r24, r12
    3d9a:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    3d9e:	81 11       	cpse	r24, r1
    3da0:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    3da4:	f8 01       	movw	r30, r16
    3da6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3da8:	81 50       	subi	r24, 0x01	; 1
    3daa:	86 8f       	std	Z+30, r24	; 0x1e
    3dac:	86 8d       	ldd	r24, Z+30	; 0x1e
    3dae:	18 16       	cp	r1, r24
    3db0:	7c f3       	brlt	.-34     	; 0x3d90 <xQueueCreateMutex+0x25c>
    3db2:	8f ef       	ldi	r24, 0xFF	; 255
    3db4:	f8 01       	movw	r30, r16
    3db6:	86 8f       	std	Z+30, r24	; 0x1e
    3db8:	0f 90       	pop	r0
    3dba:	0f be       	out	0x3f, r0	; 63
    3dbc:	0f b6       	in	r0, 0x3f	; 63
    3dbe:	f8 94       	cli
    3dc0:	0f 92       	push	r0
    3dc2:	85 8d       	ldd	r24, Z+29	; 0x1d
    3dc4:	18 16       	cp	r1, r24
    3dc6:	ac f4       	brge	.+42     	; 0x3df2 <xQueueCreateMutex+0x2be>
    3dc8:	80 85       	ldd	r24, Z+8	; 0x08
    3dca:	81 11       	cpse	r24, r1
    3dcc:	05 c0       	rjmp	.+10     	; 0x3dd8 <xQueueCreateMutex+0x2a4>
    3dce:	11 c0       	rjmp	.+34     	; 0x3df2 <xQueueCreateMutex+0x2be>
    3dd0:	f8 01       	movw	r30, r16
    3dd2:	80 85       	ldd	r24, Z+8	; 0x08
    3dd4:	88 23       	and	r24, r24
    3dd6:	69 f0       	breq	.+26     	; 0x3df2 <xQueueCreateMutex+0x2be>
    3dd8:	c7 01       	movw	r24, r14
    3dda:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    3dde:	81 11       	cpse	r24, r1
    3de0:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    3de4:	f8 01       	movw	r30, r16
    3de6:	85 8d       	ldd	r24, Z+29	; 0x1d
    3de8:	81 50       	subi	r24, 0x01	; 1
    3dea:	85 8f       	std	Z+29, r24	; 0x1d
    3dec:	85 8d       	ldd	r24, Z+29	; 0x1d
    3dee:	18 16       	cp	r1, r24
    3df0:	7c f3       	brlt	.-34     	; 0x3dd0 <xQueueCreateMutex+0x29c>
    3df2:	8f ef       	ldi	r24, 0xFF	; 255
    3df4:	f8 01       	movw	r30, r16
    3df6:	85 8f       	std	Z+29, r24	; 0x1d
    3df8:	0f 90       	pop	r0
    3dfa:	0f be       	out	0x3f, r0	; 63
    3dfc:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    3e00:	09 c0       	rjmp	.+18     	; 0x3e14 <xQueueCreateMutex+0x2e0>
    3e02:	f8 01       	movw	r30, r16
    3e04:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e06:	8f 5f       	subi	r24, 0xFF	; 255
    3e08:	82 8f       	std	Z+26, r24	; 0x1a
    3e0a:	81 89       	ldd	r24, Z+17	; 0x11
    3e0c:	88 23       	and	r24, r24
    3e0e:	09 f4       	brne	.+2      	; 0x3e12 <xQueueCreateMutex+0x2de>
    3e10:	f1 ce       	rjmp	.-542    	; 0x3bf4 <xQueueCreateMutex+0xc0>
    3e12:	e7 ce       	rjmp	.-562    	; 0x3be2 <xQueueCreateMutex+0xae>
    3e14:	c8 01       	movw	r24, r16
    3e16:	0f 90       	pop	r0
    3e18:	0f 90       	pop	r0
    3e1a:	0f 90       	pop	r0
    3e1c:	0f 90       	pop	r0
    3e1e:	0f 90       	pop	r0
    3e20:	df 91       	pop	r29
    3e22:	cf 91       	pop	r28
    3e24:	1f 91       	pop	r17
    3e26:	0f 91       	pop	r16
    3e28:	ff 90       	pop	r15
    3e2a:	ef 90       	pop	r14
    3e2c:	df 90       	pop	r13
    3e2e:	cf 90       	pop	r12
    3e30:	bf 90       	pop	r11
    3e32:	af 90       	pop	r10
    3e34:	9f 90       	pop	r9
    3e36:	08 95       	ret

00003e38 <xQueueGenericSend>:
    3e38:	6f 92       	push	r6
    3e3a:	7f 92       	push	r7
    3e3c:	8f 92       	push	r8
    3e3e:	9f 92       	push	r9
    3e40:	af 92       	push	r10
    3e42:	bf 92       	push	r11
    3e44:	cf 92       	push	r12
    3e46:	df 92       	push	r13
    3e48:	ef 92       	push	r14
    3e4a:	ff 92       	push	r15
    3e4c:	0f 93       	push	r16
    3e4e:	1f 93       	push	r17
    3e50:	cf 93       	push	r28
    3e52:	df 93       	push	r29
    3e54:	00 d0       	rcall	.+0      	; 0x3e56 <xQueueGenericSend+0x1e>
    3e56:	1f 92       	push	r1
    3e58:	1f 92       	push	r1
    3e5a:	cd b7       	in	r28, 0x3d	; 61
    3e5c:	de b7       	in	r29, 0x3e	; 62
    3e5e:	8c 01       	movw	r16, r24
    3e60:	5b 01       	movw	r10, r22
    3e62:	5d 83       	std	Y+5, r21	; 0x05
    3e64:	4c 83       	std	Y+4, r20	; 0x04
    3e66:	72 2e       	mov	r7, r18
    3e68:	81 2c       	mov	r8, r1
    3e6a:	66 24       	eor	r6, r6
    3e6c:	63 94       	inc	r6
    3e6e:	99 24       	eor	r9, r9
    3e70:	9a 94       	dec	r9
    3e72:	7c 01       	movw	r14, r24
    3e74:	88 e0       	ldi	r24, 0x08	; 8
    3e76:	e8 0e       	add	r14, r24
    3e78:	f1 1c       	adc	r15, r1
    3e7a:	68 01       	movw	r12, r16
    3e7c:	e1 e1       	ldi	r30, 0x11	; 17
    3e7e:	ce 0e       	add	r12, r30
    3e80:	d1 1c       	adc	r13, r1
    3e82:	0f b6       	in	r0, 0x3f	; 63
    3e84:	f8 94       	cli
    3e86:	0f 92       	push	r0
    3e88:	f8 01       	movw	r30, r16
    3e8a:	92 8d       	ldd	r25, Z+26	; 0x1a
    3e8c:	83 8d       	ldd	r24, Z+27	; 0x1b
    3e8e:	98 17       	cp	r25, r24
    3e90:	20 f0       	brcs	.+8      	; 0x3e9a <xQueueGenericSend+0x62>
    3e92:	f2 e0       	ldi	r31, 0x02	; 2
    3e94:	7f 12       	cpse	r7, r31
    3e96:	6e c0       	rjmp	.+220    	; 0x3f74 <xQueueGenericSend+0x13c>
    3e98:	7d c1       	rjmp	.+762    	; 0x4194 <xQueueGenericSend+0x35c>
    3e9a:	f8 01       	movw	r30, r16
    3e9c:	44 8d       	ldd	r20, Z+28	; 0x1c
    3e9e:	41 11       	cpse	r20, r1
    3ea0:	15 c0       	rjmp	.+42     	; 0x3ecc <xQueueGenericSend+0x94>
    3ea2:	f8 01       	movw	r30, r16
    3ea4:	80 81       	ld	r24, Z
    3ea6:	91 81       	ldd	r25, Z+1	; 0x01
    3ea8:	89 2b       	or	r24, r25
    3eaa:	09 f0       	breq	.+2      	; 0x3eae <xQueueGenericSend+0x76>
    3eac:	79 c1       	rjmp	.+754    	; 0x41a0 <xQueueGenericSend+0x368>
    3eae:	82 81       	ldd	r24, Z+2	; 0x02
    3eb0:	93 81       	ldd	r25, Z+3	; 0x03
    3eb2:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <xTaskPriorityDisinherit>
    3eb6:	f8 01       	movw	r30, r16
    3eb8:	13 82       	std	Z+3, r1	; 0x03
    3eba:	12 82       	std	Z+2, r1	; 0x02
    3ebc:	92 8d       	ldd	r25, Z+26	; 0x1a
    3ebe:	9f 5f       	subi	r25, 0xFF	; 255
    3ec0:	92 8f       	std	Z+26, r25	; 0x1a
    3ec2:	91 89       	ldd	r25, Z+17	; 0x11
    3ec4:	99 23       	and	r25, r25
    3ec6:	09 f4       	brne	.+2      	; 0x3eca <xQueueGenericSend+0x92>
    3ec8:	4f c0       	rjmp	.+158    	; 0x3f68 <xQueueGenericSend+0x130>
    3eca:	46 c0       	rjmp	.+140    	; 0x3f58 <xQueueGenericSend+0x120>
    3ecc:	71 10       	cpse	r7, r1
    3ece:	1a c0       	rjmp	.+52     	; 0x3f04 <xQueueGenericSend+0xcc>
    3ed0:	50 e0       	ldi	r21, 0x00	; 0
    3ed2:	b5 01       	movw	r22, r10
    3ed4:	f8 01       	movw	r30, r16
    3ed6:	84 81       	ldd	r24, Z+4	; 0x04
    3ed8:	95 81       	ldd	r25, Z+5	; 0x05
    3eda:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    3ede:	f8 01       	movw	r30, r16
    3ee0:	24 8d       	ldd	r18, Z+28	; 0x1c
    3ee2:	84 81       	ldd	r24, Z+4	; 0x04
    3ee4:	95 81       	ldd	r25, Z+5	; 0x05
    3ee6:	82 0f       	add	r24, r18
    3ee8:	91 1d       	adc	r25, r1
    3eea:	95 83       	std	Z+5, r25	; 0x05
    3eec:	84 83       	std	Z+4, r24	; 0x04
    3eee:	22 81       	ldd	r18, Z+2	; 0x02
    3ef0:	33 81       	ldd	r19, Z+3	; 0x03
    3ef2:	82 17       	cp	r24, r18
    3ef4:	93 07       	cpc	r25, r19
    3ef6:	08 f4       	brcc	.+2      	; 0x3efa <xQueueGenericSend+0xc2>
    3ef8:	53 c1       	rjmp	.+678    	; 0x41a0 <xQueueGenericSend+0x368>
    3efa:	80 81       	ld	r24, Z
    3efc:	91 81       	ldd	r25, Z+1	; 0x01
    3efe:	95 83       	std	Z+5, r25	; 0x05
    3f00:	84 83       	std	Z+4, r24	; 0x04
    3f02:	4e c1       	rjmp	.+668    	; 0x41a0 <xQueueGenericSend+0x368>
    3f04:	50 e0       	ldi	r21, 0x00	; 0
    3f06:	b5 01       	movw	r22, r10
    3f08:	f8 01       	movw	r30, r16
    3f0a:	86 81       	ldd	r24, Z+6	; 0x06
    3f0c:	97 81       	ldd	r25, Z+7	; 0x07
    3f0e:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    3f12:	f8 01       	movw	r30, r16
    3f14:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f16:	90 e0       	ldi	r25, 0x00	; 0
    3f18:	91 95       	neg	r25
    3f1a:	81 95       	neg	r24
    3f1c:	91 09       	sbc	r25, r1
    3f1e:	26 81       	ldd	r18, Z+6	; 0x06
    3f20:	37 81       	ldd	r19, Z+7	; 0x07
    3f22:	28 0f       	add	r18, r24
    3f24:	39 1f       	adc	r19, r25
    3f26:	37 83       	std	Z+7, r19	; 0x07
    3f28:	26 83       	std	Z+6, r18	; 0x06
    3f2a:	40 81       	ld	r20, Z
    3f2c:	51 81       	ldd	r21, Z+1	; 0x01
    3f2e:	24 17       	cp	r18, r20
    3f30:	35 07       	cpc	r19, r21
    3f32:	30 f4       	brcc	.+12     	; 0x3f40 <xQueueGenericSend+0x108>
    3f34:	22 81       	ldd	r18, Z+2	; 0x02
    3f36:	33 81       	ldd	r19, Z+3	; 0x03
    3f38:	82 0f       	add	r24, r18
    3f3a:	93 1f       	adc	r25, r19
    3f3c:	97 83       	std	Z+7, r25	; 0x07
    3f3e:	86 83       	std	Z+6, r24	; 0x06
    3f40:	f2 e0       	ldi	r31, 0x02	; 2
    3f42:	7f 12       	cpse	r7, r31
    3f44:	2d c1       	rjmp	.+602    	; 0x41a0 <xQueueGenericSend+0x368>
    3f46:	f8 01       	movw	r30, r16
    3f48:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f4a:	88 23       	and	r24, r24
    3f4c:	09 f4       	brne	.+2      	; 0x3f50 <xQueueGenericSend+0x118>
    3f4e:	28 c1       	rjmp	.+592    	; 0x41a0 <xQueueGenericSend+0x368>
    3f50:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f52:	81 50       	subi	r24, 0x01	; 1
    3f54:	82 8f       	std	Z+26, r24	; 0x1a
    3f56:	24 c1       	rjmp	.+584    	; 0x41a0 <xQueueGenericSend+0x368>
    3f58:	c8 01       	movw	r24, r16
    3f5a:	41 96       	adiw	r24, 0x11	; 17
    3f5c:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    3f60:	81 30       	cpi	r24, 0x01	; 1
    3f62:	21 f4       	brne	.+8      	; 0x3f6c <xQueueGenericSend+0x134>
    3f64:	ba dc       	rcall	.-1676   	; 0x38da <vPortYield>
    3f66:	02 c0       	rjmp	.+4      	; 0x3f6c <xQueueGenericSend+0x134>
    3f68:	81 11       	cpse	r24, r1
    3f6a:	b7 dc       	rcall	.-1682   	; 0x38da <vPortYield>
    3f6c:	0f 90       	pop	r0
    3f6e:	0f be       	out	0x3f, r0	; 63
    3f70:	81 e0       	ldi	r24, 0x01	; 1
    3f72:	1e c1       	rjmp	.+572    	; 0x41b0 <xQueueGenericSend+0x378>
    3f74:	8c 81       	ldd	r24, Y+4	; 0x04
    3f76:	9d 81       	ldd	r25, Y+5	; 0x05
    3f78:	89 2b       	or	r24, r25
    3f7a:	21 f4       	brne	.+8      	; 0x3f84 <xQueueGenericSend+0x14c>
    3f7c:	0f 90       	pop	r0
    3f7e:	0f be       	out	0x3f, r0	; 63
    3f80:	80 e0       	ldi	r24, 0x00	; 0
    3f82:	16 c1       	rjmp	.+556    	; 0x41b0 <xQueueGenericSend+0x378>
    3f84:	81 10       	cpse	r8, r1
    3f86:	05 c0       	rjmp	.+10     	; 0x3f92 <xQueueGenericSend+0x15a>
    3f88:	ce 01       	movw	r24, r28
    3f8a:	01 96       	adiw	r24, 0x01	; 1
    3f8c:	0e 94 2f 2f 	call	0x5e5e	; 0x5e5e <vTaskSetTimeOutState>
    3f90:	86 2c       	mov	r8, r6
    3f92:	0f 90       	pop	r0
    3f94:	0f be       	out	0x3f, r0	; 63
    3f96:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <vTaskSuspendAll>
    3f9a:	0f b6       	in	r0, 0x3f	; 63
    3f9c:	f8 94       	cli
    3f9e:	0f 92       	push	r0
    3fa0:	f8 01       	movw	r30, r16
    3fa2:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fa4:	8f 3f       	cpi	r24, 0xFF	; 255
    3fa6:	09 f4       	brne	.+2      	; 0x3faa <xQueueGenericSend+0x172>
    3fa8:	15 8e       	std	Z+29, r1	; 0x1d
    3faa:	f8 01       	movw	r30, r16
    3fac:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fae:	8f 3f       	cpi	r24, 0xFF	; 255
    3fb0:	09 f4       	brne	.+2      	; 0x3fb4 <xQueueGenericSend+0x17c>
    3fb2:	16 8e       	std	Z+30, r1	; 0x1e
    3fb4:	0f 90       	pop	r0
    3fb6:	0f be       	out	0x3f, r0	; 63
    3fb8:	be 01       	movw	r22, r28
    3fba:	6c 5f       	subi	r22, 0xFC	; 252
    3fbc:	7f 4f       	sbci	r23, 0xFF	; 255
    3fbe:	ce 01       	movw	r24, r28
    3fc0:	01 96       	adiw	r24, 0x01	; 1
    3fc2:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <xTaskCheckForTimeOut>
    3fc6:	81 11       	cpse	r24, r1
    3fc8:	96 c0       	rjmp	.+300    	; 0x40f6 <xQueueGenericSend+0x2be>
    3fca:	0f b6       	in	r0, 0x3f	; 63
    3fcc:	f8 94       	cli
    3fce:	0f 92       	push	r0
    3fd0:	f8 01       	movw	r30, r16
    3fd2:	92 8d       	ldd	r25, Z+26	; 0x1a
    3fd4:	83 8d       	ldd	r24, Z+27	; 0x1b
    3fd6:	0f 90       	pop	r0
    3fd8:	0f be       	out	0x3f, r0	; 63
    3fda:	98 13       	cpse	r25, r24
    3fdc:	4a c0       	rjmp	.+148    	; 0x4072 <xQueueGenericSend+0x23a>
    3fde:	6c 81       	ldd	r22, Y+4	; 0x04
    3fe0:	7d 81       	ldd	r23, Y+5	; 0x05
    3fe2:	c7 01       	movw	r24, r14
    3fe4:	0e 94 8c 2e 	call	0x5d18	; 0x5d18 <vTaskPlaceOnEventList>
    3fe8:	0f b6       	in	r0, 0x3f	; 63
    3fea:	f8 94       	cli
    3fec:	0f 92       	push	r0
    3fee:	f8 01       	movw	r30, r16
    3ff0:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ff2:	18 16       	cp	r1, r24
    3ff4:	ac f4       	brge	.+42     	; 0x4020 <xQueueGenericSend+0x1e8>
    3ff6:	81 89       	ldd	r24, Z+17	; 0x11
    3ff8:	81 11       	cpse	r24, r1
    3ffa:	05 c0       	rjmp	.+10     	; 0x4006 <xQueueGenericSend+0x1ce>
    3ffc:	11 c0       	rjmp	.+34     	; 0x4020 <xQueueGenericSend+0x1e8>
    3ffe:	f8 01       	movw	r30, r16
    4000:	81 89       	ldd	r24, Z+17	; 0x11
    4002:	88 23       	and	r24, r24
    4004:	69 f0       	breq	.+26     	; 0x4020 <xQueueGenericSend+0x1e8>
    4006:	c6 01       	movw	r24, r12
    4008:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    400c:	81 11       	cpse	r24, r1
    400e:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    4012:	f8 01       	movw	r30, r16
    4014:	86 8d       	ldd	r24, Z+30	; 0x1e
    4016:	81 50       	subi	r24, 0x01	; 1
    4018:	86 8f       	std	Z+30, r24	; 0x1e
    401a:	86 8d       	ldd	r24, Z+30	; 0x1e
    401c:	18 16       	cp	r1, r24
    401e:	7c f3       	brlt	.-34     	; 0x3ffe <xQueueGenericSend+0x1c6>
    4020:	f8 01       	movw	r30, r16
    4022:	96 8e       	std	Z+30, r9	; 0x1e
    4024:	0f 90       	pop	r0
    4026:	0f be       	out	0x3f, r0	; 63
    4028:	0f b6       	in	r0, 0x3f	; 63
    402a:	f8 94       	cli
    402c:	0f 92       	push	r0
    402e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4030:	18 16       	cp	r1, r24
    4032:	ac f4       	brge	.+42     	; 0x405e <xQueueGenericSend+0x226>
    4034:	80 85       	ldd	r24, Z+8	; 0x08
    4036:	81 11       	cpse	r24, r1
    4038:	05 c0       	rjmp	.+10     	; 0x4044 <xQueueGenericSend+0x20c>
    403a:	11 c0       	rjmp	.+34     	; 0x405e <xQueueGenericSend+0x226>
    403c:	f8 01       	movw	r30, r16
    403e:	80 85       	ldd	r24, Z+8	; 0x08
    4040:	88 23       	and	r24, r24
    4042:	69 f0       	breq	.+26     	; 0x405e <xQueueGenericSend+0x226>
    4044:	c7 01       	movw	r24, r14
    4046:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    404a:	81 11       	cpse	r24, r1
    404c:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    4050:	f8 01       	movw	r30, r16
    4052:	85 8d       	ldd	r24, Z+29	; 0x1d
    4054:	81 50       	subi	r24, 0x01	; 1
    4056:	85 8f       	std	Z+29, r24	; 0x1d
    4058:	85 8d       	ldd	r24, Z+29	; 0x1d
    405a:	18 16       	cp	r1, r24
    405c:	7c f3       	brlt	.-34     	; 0x403c <xQueueGenericSend+0x204>
    405e:	f8 01       	movw	r30, r16
    4060:	95 8e       	std	Z+29, r9	; 0x1d
    4062:	0f 90       	pop	r0
    4064:	0f be       	out	0x3f, r0	; 63
    4066:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    406a:	81 11       	cpse	r24, r1
    406c:	0a cf       	rjmp	.-492    	; 0x3e82 <xQueueGenericSend+0x4a>
    406e:	35 dc       	rcall	.-1942   	; 0x38da <vPortYield>
    4070:	08 cf       	rjmp	.-496    	; 0x3e82 <xQueueGenericSend+0x4a>
    4072:	0f b6       	in	r0, 0x3f	; 63
    4074:	f8 94       	cli
    4076:	0f 92       	push	r0
    4078:	f8 01       	movw	r30, r16
    407a:	86 8d       	ldd	r24, Z+30	; 0x1e
    407c:	18 16       	cp	r1, r24
    407e:	ac f4       	brge	.+42     	; 0x40aa <xQueueGenericSend+0x272>
    4080:	81 89       	ldd	r24, Z+17	; 0x11
    4082:	81 11       	cpse	r24, r1
    4084:	05 c0       	rjmp	.+10     	; 0x4090 <xQueueGenericSend+0x258>
    4086:	11 c0       	rjmp	.+34     	; 0x40aa <xQueueGenericSend+0x272>
    4088:	f8 01       	movw	r30, r16
    408a:	81 89       	ldd	r24, Z+17	; 0x11
    408c:	88 23       	and	r24, r24
    408e:	69 f0       	breq	.+26     	; 0x40aa <xQueueGenericSend+0x272>
    4090:	c6 01       	movw	r24, r12
    4092:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    4096:	81 11       	cpse	r24, r1
    4098:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    409c:	f8 01       	movw	r30, r16
    409e:	86 8d       	ldd	r24, Z+30	; 0x1e
    40a0:	81 50       	subi	r24, 0x01	; 1
    40a2:	86 8f       	std	Z+30, r24	; 0x1e
    40a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    40a6:	18 16       	cp	r1, r24
    40a8:	7c f3       	brlt	.-34     	; 0x4088 <xQueueGenericSend+0x250>
    40aa:	f8 01       	movw	r30, r16
    40ac:	96 8e       	std	Z+30, r9	; 0x1e
    40ae:	0f 90       	pop	r0
    40b0:	0f be       	out	0x3f, r0	; 63
    40b2:	0f b6       	in	r0, 0x3f	; 63
    40b4:	f8 94       	cli
    40b6:	0f 92       	push	r0
    40b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    40ba:	18 16       	cp	r1, r24
    40bc:	ac f4       	brge	.+42     	; 0x40e8 <xQueueGenericSend+0x2b0>
    40be:	80 85       	ldd	r24, Z+8	; 0x08
    40c0:	81 11       	cpse	r24, r1
    40c2:	05 c0       	rjmp	.+10     	; 0x40ce <xQueueGenericSend+0x296>
    40c4:	11 c0       	rjmp	.+34     	; 0x40e8 <xQueueGenericSend+0x2b0>
    40c6:	f8 01       	movw	r30, r16
    40c8:	80 85       	ldd	r24, Z+8	; 0x08
    40ca:	88 23       	and	r24, r24
    40cc:	69 f0       	breq	.+26     	; 0x40e8 <xQueueGenericSend+0x2b0>
    40ce:	c7 01       	movw	r24, r14
    40d0:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    40d4:	81 11       	cpse	r24, r1
    40d6:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    40da:	f8 01       	movw	r30, r16
    40dc:	85 8d       	ldd	r24, Z+29	; 0x1d
    40de:	81 50       	subi	r24, 0x01	; 1
    40e0:	85 8f       	std	Z+29, r24	; 0x1d
    40e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    40e4:	18 16       	cp	r1, r24
    40e6:	7c f3       	brlt	.-34     	; 0x40c6 <xQueueGenericSend+0x28e>
    40e8:	f8 01       	movw	r30, r16
    40ea:	95 8e       	std	Z+29, r9	; 0x1d
    40ec:	0f 90       	pop	r0
    40ee:	0f be       	out	0x3f, r0	; 63
    40f0:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    40f4:	c6 ce       	rjmp	.-628    	; 0x3e82 <xQueueGenericSend+0x4a>
    40f6:	0f b6       	in	r0, 0x3f	; 63
    40f8:	f8 94       	cli
    40fa:	0f 92       	push	r0
    40fc:	f8 01       	movw	r30, r16
    40fe:	86 8d       	ldd	r24, Z+30	; 0x1e
    4100:	18 16       	cp	r1, r24
    4102:	d4 f4       	brge	.+52     	; 0x4138 <xQueueGenericSend+0x300>
    4104:	81 89       	ldd	r24, Z+17	; 0x11
    4106:	81 11       	cpse	r24, r1
    4108:	06 c0       	rjmp	.+12     	; 0x4116 <xQueueGenericSend+0x2de>
    410a:	16 c0       	rjmp	.+44     	; 0x4138 <xQueueGenericSend+0x300>
    410c:	f8 01       	movw	r30, r16
    410e:	81 89       	ldd	r24, Z+17	; 0x11
    4110:	81 11       	cpse	r24, r1
    4112:	05 c0       	rjmp	.+10     	; 0x411e <xQueueGenericSend+0x2e6>
    4114:	11 c0       	rjmp	.+34     	; 0x4138 <xQueueGenericSend+0x300>
    4116:	78 01       	movw	r14, r16
    4118:	f1 e1       	ldi	r31, 0x11	; 17
    411a:	ef 0e       	add	r14, r31
    411c:	f1 1c       	adc	r15, r1
    411e:	c7 01       	movw	r24, r14
    4120:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    4124:	81 11       	cpse	r24, r1
    4126:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    412a:	f8 01       	movw	r30, r16
    412c:	86 8d       	ldd	r24, Z+30	; 0x1e
    412e:	81 50       	subi	r24, 0x01	; 1
    4130:	86 8f       	std	Z+30, r24	; 0x1e
    4132:	86 8d       	ldd	r24, Z+30	; 0x1e
    4134:	18 16       	cp	r1, r24
    4136:	54 f3       	brlt	.-44     	; 0x410c <xQueueGenericSend+0x2d4>
    4138:	8f ef       	ldi	r24, 0xFF	; 255
    413a:	f8 01       	movw	r30, r16
    413c:	86 8f       	std	Z+30, r24	; 0x1e
    413e:	0f 90       	pop	r0
    4140:	0f be       	out	0x3f, r0	; 63
    4142:	0f b6       	in	r0, 0x3f	; 63
    4144:	f8 94       	cli
    4146:	0f 92       	push	r0
    4148:	85 8d       	ldd	r24, Z+29	; 0x1d
    414a:	18 16       	cp	r1, r24
    414c:	d4 f4       	brge	.+52     	; 0x4182 <xQueueGenericSend+0x34a>
    414e:	80 85       	ldd	r24, Z+8	; 0x08
    4150:	81 11       	cpse	r24, r1
    4152:	06 c0       	rjmp	.+12     	; 0x4160 <xQueueGenericSend+0x328>
    4154:	16 c0       	rjmp	.+44     	; 0x4182 <xQueueGenericSend+0x34a>
    4156:	f8 01       	movw	r30, r16
    4158:	80 85       	ldd	r24, Z+8	; 0x08
    415a:	81 11       	cpse	r24, r1
    415c:	05 c0       	rjmp	.+10     	; 0x4168 <xQueueGenericSend+0x330>
    415e:	11 c0       	rjmp	.+34     	; 0x4182 <xQueueGenericSend+0x34a>
    4160:	78 01       	movw	r14, r16
    4162:	f8 e0       	ldi	r31, 0x08	; 8
    4164:	ef 0e       	add	r14, r31
    4166:	f1 1c       	adc	r15, r1
    4168:	c7 01       	movw	r24, r14
    416a:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    416e:	81 11       	cpse	r24, r1
    4170:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    4174:	f8 01       	movw	r30, r16
    4176:	85 8d       	ldd	r24, Z+29	; 0x1d
    4178:	81 50       	subi	r24, 0x01	; 1
    417a:	85 8f       	std	Z+29, r24	; 0x1d
    417c:	85 8d       	ldd	r24, Z+29	; 0x1d
    417e:	18 16       	cp	r1, r24
    4180:	54 f3       	brlt	.-44     	; 0x4156 <xQueueGenericSend+0x31e>
    4182:	8f ef       	ldi	r24, 0xFF	; 255
    4184:	f8 01       	movw	r30, r16
    4186:	85 8f       	std	Z+29, r24	; 0x1d
    4188:	0f 90       	pop	r0
    418a:	0f be       	out	0x3f, r0	; 63
    418c:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    4190:	80 e0       	ldi	r24, 0x00	; 0
    4192:	0e c0       	rjmp	.+28     	; 0x41b0 <xQueueGenericSend+0x378>
    4194:	f8 01       	movw	r30, r16
    4196:	44 8d       	ldd	r20, Z+28	; 0x1c
    4198:	44 23       	and	r20, r20
    419a:	09 f4       	brne	.+2      	; 0x419e <xQueueGenericSend+0x366>
    419c:	82 ce       	rjmp	.-764    	; 0x3ea2 <xQueueGenericSend+0x6a>
    419e:	b2 ce       	rjmp	.-668    	; 0x3f04 <xQueueGenericSend+0xcc>
    41a0:	f8 01       	movw	r30, r16
    41a2:	82 8d       	ldd	r24, Z+26	; 0x1a
    41a4:	8f 5f       	subi	r24, 0xFF	; 255
    41a6:	82 8f       	std	Z+26, r24	; 0x1a
    41a8:	81 89       	ldd	r24, Z+17	; 0x11
    41aa:	81 11       	cpse	r24, r1
    41ac:	d5 ce       	rjmp	.-598    	; 0x3f58 <xQueueGenericSend+0x120>
    41ae:	de ce       	rjmp	.-580    	; 0x3f6c <xQueueGenericSend+0x134>
    41b0:	0f 90       	pop	r0
    41b2:	0f 90       	pop	r0
    41b4:	0f 90       	pop	r0
    41b6:	0f 90       	pop	r0
    41b8:	0f 90       	pop	r0
    41ba:	df 91       	pop	r29
    41bc:	cf 91       	pop	r28
    41be:	1f 91       	pop	r17
    41c0:	0f 91       	pop	r16
    41c2:	ff 90       	pop	r15
    41c4:	ef 90       	pop	r14
    41c6:	df 90       	pop	r13
    41c8:	cf 90       	pop	r12
    41ca:	bf 90       	pop	r11
    41cc:	af 90       	pop	r10
    41ce:	9f 90       	pop	r9
    41d0:	8f 90       	pop	r8
    41d2:	7f 90       	pop	r7
    41d4:	6f 90       	pop	r6
    41d6:	08 95       	ret

000041d8 <xQueueGive>:
    41d8:	9f 92       	push	r9
    41da:	af 92       	push	r10
    41dc:	bf 92       	push	r11
    41de:	cf 92       	push	r12
    41e0:	df 92       	push	r13
    41e2:	ef 92       	push	r14
    41e4:	ff 92       	push	r15
    41e6:	0f 93       	push	r16
    41e8:	1f 93       	push	r17
    41ea:	cf 93       	push	r28
    41ec:	df 93       	push	r29
    41ee:	00 d0       	rcall	.+0      	; 0x41f0 <xQueueGive+0x18>
    41f0:	1f 92       	push	r1
    41f2:	1f 92       	push	r1
    41f4:	cd b7       	in	r28, 0x3d	; 61
    41f6:	de b7       	in	r29, 0x3e	; 62
    41f8:	8c 01       	movw	r16, r24
    41fa:	7d 83       	std	Y+5, r23	; 0x05
    41fc:	6c 83       	std	Y+4, r22	; 0x04
    41fe:	a1 2c       	mov	r10, r1
    4200:	99 24       	eor	r9, r9
    4202:	93 94       	inc	r9
    4204:	bb 24       	eor	r11, r11
    4206:	ba 94       	dec	r11
    4208:	7c 01       	movw	r14, r24
    420a:	88 e0       	ldi	r24, 0x08	; 8
    420c:	e8 0e       	add	r14, r24
    420e:	f1 1c       	adc	r15, r1
    4210:	68 01       	movw	r12, r16
    4212:	e1 e1       	ldi	r30, 0x11	; 17
    4214:	ce 0e       	add	r12, r30
    4216:	d1 1c       	adc	r13, r1
    4218:	0f b6       	in	r0, 0x3f	; 63
    421a:	f8 94       	cli
    421c:	0f 92       	push	r0
    421e:	f8 01       	movw	r30, r16
    4220:	92 8d       	ldd	r25, Z+26	; 0x1a
    4222:	83 8d       	ldd	r24, Z+27	; 0x1b
    4224:	98 17       	cp	r25, r24
    4226:	00 f5       	brcc	.+64     	; 0x4268 <xQueueGive+0x90>
    4228:	80 81       	ld	r24, Z
    422a:	91 81       	ldd	r25, Z+1	; 0x01
    422c:	89 2b       	or	r24, r25
    422e:	09 f0       	breq	.+2      	; 0x4232 <xQueueGive+0x5a>
    4230:	2b c1       	rjmp	.+598    	; 0x4488 <xQueueGive+0x2b0>
    4232:	82 81       	ldd	r24, Z+2	; 0x02
    4234:	93 81       	ldd	r25, Z+3	; 0x03
    4236:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <xTaskPriorityDisinherit>
    423a:	f8 01       	movw	r30, r16
    423c:	13 82       	std	Z+3, r1	; 0x03
    423e:	12 82       	std	Z+2, r1	; 0x02
    4240:	92 8d       	ldd	r25, Z+26	; 0x1a
    4242:	9f 5f       	subi	r25, 0xFF	; 255
    4244:	92 8f       	std	Z+26, r25	; 0x1a
    4246:	91 89       	ldd	r25, Z+17	; 0x11
    4248:	99 23       	and	r25, r25
    424a:	41 f0       	breq	.+16     	; 0x425c <xQueueGive+0x84>
    424c:	c8 01       	movw	r24, r16
    424e:	41 96       	adiw	r24, 0x11	; 17
    4250:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    4254:	81 30       	cpi	r24, 0x01	; 1
    4256:	21 f4       	brne	.+8      	; 0x4260 <xQueueGive+0x88>
    4258:	40 db       	rcall	.-2432   	; 0x38da <vPortYield>
    425a:	02 c0       	rjmp	.+4      	; 0x4260 <xQueueGive+0x88>
    425c:	81 11       	cpse	r24, r1
    425e:	3d db       	rcall	.-2438   	; 0x38da <vPortYield>
    4260:	0f 90       	pop	r0
    4262:	0f be       	out	0x3f, r0	; 63
    4264:	81 e0       	ldi	r24, 0x01	; 1
    4266:	18 c1       	rjmp	.+560    	; 0x4498 <xQueueGive+0x2c0>
    4268:	8c 81       	ldd	r24, Y+4	; 0x04
    426a:	9d 81       	ldd	r25, Y+5	; 0x05
    426c:	89 2b       	or	r24, r25
    426e:	21 f4       	brne	.+8      	; 0x4278 <xQueueGive+0xa0>
    4270:	0f 90       	pop	r0
    4272:	0f be       	out	0x3f, r0	; 63
    4274:	80 e0       	ldi	r24, 0x00	; 0
    4276:	10 c1       	rjmp	.+544    	; 0x4498 <xQueueGive+0x2c0>
    4278:	a1 10       	cpse	r10, r1
    427a:	05 c0       	rjmp	.+10     	; 0x4286 <xQueueGive+0xae>
    427c:	ce 01       	movw	r24, r28
    427e:	01 96       	adiw	r24, 0x01	; 1
    4280:	0e 94 2f 2f 	call	0x5e5e	; 0x5e5e <vTaskSetTimeOutState>
    4284:	a9 2c       	mov	r10, r9
    4286:	0f 90       	pop	r0
    4288:	0f be       	out	0x3f, r0	; 63
    428a:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <vTaskSuspendAll>
    428e:	0f b6       	in	r0, 0x3f	; 63
    4290:	f8 94       	cli
    4292:	0f 92       	push	r0
    4294:	f8 01       	movw	r30, r16
    4296:	85 8d       	ldd	r24, Z+29	; 0x1d
    4298:	8f 3f       	cpi	r24, 0xFF	; 255
    429a:	09 f4       	brne	.+2      	; 0x429e <xQueueGive+0xc6>
    429c:	15 8e       	std	Z+29, r1	; 0x1d
    429e:	f8 01       	movw	r30, r16
    42a0:	86 8d       	ldd	r24, Z+30	; 0x1e
    42a2:	8f 3f       	cpi	r24, 0xFF	; 255
    42a4:	09 f4       	brne	.+2      	; 0x42a8 <xQueueGive+0xd0>
    42a6:	16 8e       	std	Z+30, r1	; 0x1e
    42a8:	0f 90       	pop	r0
    42aa:	0f be       	out	0x3f, r0	; 63
    42ac:	be 01       	movw	r22, r28
    42ae:	6c 5f       	subi	r22, 0xFC	; 252
    42b0:	7f 4f       	sbci	r23, 0xFF	; 255
    42b2:	ce 01       	movw	r24, r28
    42b4:	01 96       	adiw	r24, 0x01	; 1
    42b6:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <xTaskCheckForTimeOut>
    42ba:	81 11       	cpse	r24, r1
    42bc:	96 c0       	rjmp	.+300    	; 0x43ea <xQueueGive+0x212>
    42be:	0f b6       	in	r0, 0x3f	; 63
    42c0:	f8 94       	cli
    42c2:	0f 92       	push	r0
    42c4:	f8 01       	movw	r30, r16
    42c6:	92 8d       	ldd	r25, Z+26	; 0x1a
    42c8:	83 8d       	ldd	r24, Z+27	; 0x1b
    42ca:	0f 90       	pop	r0
    42cc:	0f be       	out	0x3f, r0	; 63
    42ce:	98 13       	cpse	r25, r24
    42d0:	4a c0       	rjmp	.+148    	; 0x4366 <xQueueGive+0x18e>
    42d2:	6c 81       	ldd	r22, Y+4	; 0x04
    42d4:	7d 81       	ldd	r23, Y+5	; 0x05
    42d6:	c7 01       	movw	r24, r14
    42d8:	0e 94 8c 2e 	call	0x5d18	; 0x5d18 <vTaskPlaceOnEventList>
    42dc:	0f b6       	in	r0, 0x3f	; 63
    42de:	f8 94       	cli
    42e0:	0f 92       	push	r0
    42e2:	f8 01       	movw	r30, r16
    42e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    42e6:	18 16       	cp	r1, r24
    42e8:	ac f4       	brge	.+42     	; 0x4314 <xQueueGive+0x13c>
    42ea:	81 89       	ldd	r24, Z+17	; 0x11
    42ec:	81 11       	cpse	r24, r1
    42ee:	05 c0       	rjmp	.+10     	; 0x42fa <xQueueGive+0x122>
    42f0:	11 c0       	rjmp	.+34     	; 0x4314 <xQueueGive+0x13c>
    42f2:	f8 01       	movw	r30, r16
    42f4:	81 89       	ldd	r24, Z+17	; 0x11
    42f6:	88 23       	and	r24, r24
    42f8:	69 f0       	breq	.+26     	; 0x4314 <xQueueGive+0x13c>
    42fa:	c6 01       	movw	r24, r12
    42fc:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    4300:	81 11       	cpse	r24, r1
    4302:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    4306:	f8 01       	movw	r30, r16
    4308:	86 8d       	ldd	r24, Z+30	; 0x1e
    430a:	81 50       	subi	r24, 0x01	; 1
    430c:	86 8f       	std	Z+30, r24	; 0x1e
    430e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4310:	18 16       	cp	r1, r24
    4312:	7c f3       	brlt	.-34     	; 0x42f2 <xQueueGive+0x11a>
    4314:	f8 01       	movw	r30, r16
    4316:	b6 8e       	std	Z+30, r11	; 0x1e
    4318:	0f 90       	pop	r0
    431a:	0f be       	out	0x3f, r0	; 63
    431c:	0f b6       	in	r0, 0x3f	; 63
    431e:	f8 94       	cli
    4320:	0f 92       	push	r0
    4322:	85 8d       	ldd	r24, Z+29	; 0x1d
    4324:	18 16       	cp	r1, r24
    4326:	ac f4       	brge	.+42     	; 0x4352 <xQueueGive+0x17a>
    4328:	80 85       	ldd	r24, Z+8	; 0x08
    432a:	81 11       	cpse	r24, r1
    432c:	05 c0       	rjmp	.+10     	; 0x4338 <xQueueGive+0x160>
    432e:	11 c0       	rjmp	.+34     	; 0x4352 <xQueueGive+0x17a>
    4330:	f8 01       	movw	r30, r16
    4332:	80 85       	ldd	r24, Z+8	; 0x08
    4334:	88 23       	and	r24, r24
    4336:	69 f0       	breq	.+26     	; 0x4352 <xQueueGive+0x17a>
    4338:	c7 01       	movw	r24, r14
    433a:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    433e:	81 11       	cpse	r24, r1
    4340:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    4344:	f8 01       	movw	r30, r16
    4346:	85 8d       	ldd	r24, Z+29	; 0x1d
    4348:	81 50       	subi	r24, 0x01	; 1
    434a:	85 8f       	std	Z+29, r24	; 0x1d
    434c:	85 8d       	ldd	r24, Z+29	; 0x1d
    434e:	18 16       	cp	r1, r24
    4350:	7c f3       	brlt	.-34     	; 0x4330 <xQueueGive+0x158>
    4352:	f8 01       	movw	r30, r16
    4354:	b5 8e       	std	Z+29, r11	; 0x1d
    4356:	0f 90       	pop	r0
    4358:	0f be       	out	0x3f, r0	; 63
    435a:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    435e:	81 11       	cpse	r24, r1
    4360:	5b cf       	rjmp	.-330    	; 0x4218 <xQueueGive+0x40>
    4362:	bb da       	rcall	.-2698   	; 0x38da <vPortYield>
    4364:	59 cf       	rjmp	.-334    	; 0x4218 <xQueueGive+0x40>
    4366:	0f b6       	in	r0, 0x3f	; 63
    4368:	f8 94       	cli
    436a:	0f 92       	push	r0
    436c:	f8 01       	movw	r30, r16
    436e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4370:	18 16       	cp	r1, r24
    4372:	ac f4       	brge	.+42     	; 0x439e <xQueueGive+0x1c6>
    4374:	81 89       	ldd	r24, Z+17	; 0x11
    4376:	81 11       	cpse	r24, r1
    4378:	05 c0       	rjmp	.+10     	; 0x4384 <xQueueGive+0x1ac>
    437a:	11 c0       	rjmp	.+34     	; 0x439e <xQueueGive+0x1c6>
    437c:	f8 01       	movw	r30, r16
    437e:	81 89       	ldd	r24, Z+17	; 0x11
    4380:	88 23       	and	r24, r24
    4382:	69 f0       	breq	.+26     	; 0x439e <xQueueGive+0x1c6>
    4384:	c6 01       	movw	r24, r12
    4386:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    438a:	81 11       	cpse	r24, r1
    438c:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    4390:	f8 01       	movw	r30, r16
    4392:	86 8d       	ldd	r24, Z+30	; 0x1e
    4394:	81 50       	subi	r24, 0x01	; 1
    4396:	86 8f       	std	Z+30, r24	; 0x1e
    4398:	86 8d       	ldd	r24, Z+30	; 0x1e
    439a:	18 16       	cp	r1, r24
    439c:	7c f3       	brlt	.-34     	; 0x437c <xQueueGive+0x1a4>
    439e:	f8 01       	movw	r30, r16
    43a0:	b6 8e       	std	Z+30, r11	; 0x1e
    43a2:	0f 90       	pop	r0
    43a4:	0f be       	out	0x3f, r0	; 63
    43a6:	0f b6       	in	r0, 0x3f	; 63
    43a8:	f8 94       	cli
    43aa:	0f 92       	push	r0
    43ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    43ae:	18 16       	cp	r1, r24
    43b0:	ac f4       	brge	.+42     	; 0x43dc <xQueueGive+0x204>
    43b2:	80 85       	ldd	r24, Z+8	; 0x08
    43b4:	81 11       	cpse	r24, r1
    43b6:	05 c0       	rjmp	.+10     	; 0x43c2 <xQueueGive+0x1ea>
    43b8:	11 c0       	rjmp	.+34     	; 0x43dc <xQueueGive+0x204>
    43ba:	f8 01       	movw	r30, r16
    43bc:	80 85       	ldd	r24, Z+8	; 0x08
    43be:	88 23       	and	r24, r24
    43c0:	69 f0       	breq	.+26     	; 0x43dc <xQueueGive+0x204>
    43c2:	c7 01       	movw	r24, r14
    43c4:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    43c8:	81 11       	cpse	r24, r1
    43ca:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    43ce:	f8 01       	movw	r30, r16
    43d0:	85 8d       	ldd	r24, Z+29	; 0x1d
    43d2:	81 50       	subi	r24, 0x01	; 1
    43d4:	85 8f       	std	Z+29, r24	; 0x1d
    43d6:	85 8d       	ldd	r24, Z+29	; 0x1d
    43d8:	18 16       	cp	r1, r24
    43da:	7c f3       	brlt	.-34     	; 0x43ba <xQueueGive+0x1e2>
    43dc:	f8 01       	movw	r30, r16
    43de:	b5 8e       	std	Z+29, r11	; 0x1d
    43e0:	0f 90       	pop	r0
    43e2:	0f be       	out	0x3f, r0	; 63
    43e4:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    43e8:	17 cf       	rjmp	.-466    	; 0x4218 <xQueueGive+0x40>
    43ea:	0f b6       	in	r0, 0x3f	; 63
    43ec:	f8 94       	cli
    43ee:	0f 92       	push	r0
    43f0:	f8 01       	movw	r30, r16
    43f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    43f4:	18 16       	cp	r1, r24
    43f6:	d4 f4       	brge	.+52     	; 0x442c <xQueueGive+0x254>
    43f8:	81 89       	ldd	r24, Z+17	; 0x11
    43fa:	81 11       	cpse	r24, r1
    43fc:	06 c0       	rjmp	.+12     	; 0x440a <xQueueGive+0x232>
    43fe:	16 c0       	rjmp	.+44     	; 0x442c <xQueueGive+0x254>
    4400:	f8 01       	movw	r30, r16
    4402:	81 89       	ldd	r24, Z+17	; 0x11
    4404:	81 11       	cpse	r24, r1
    4406:	05 c0       	rjmp	.+10     	; 0x4412 <xQueueGive+0x23a>
    4408:	11 c0       	rjmp	.+34     	; 0x442c <xQueueGive+0x254>
    440a:	78 01       	movw	r14, r16
    440c:	f1 e1       	ldi	r31, 0x11	; 17
    440e:	ef 0e       	add	r14, r31
    4410:	f1 1c       	adc	r15, r1
    4412:	c7 01       	movw	r24, r14
    4414:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    4418:	81 11       	cpse	r24, r1
    441a:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    441e:	f8 01       	movw	r30, r16
    4420:	86 8d       	ldd	r24, Z+30	; 0x1e
    4422:	81 50       	subi	r24, 0x01	; 1
    4424:	86 8f       	std	Z+30, r24	; 0x1e
    4426:	86 8d       	ldd	r24, Z+30	; 0x1e
    4428:	18 16       	cp	r1, r24
    442a:	54 f3       	brlt	.-44     	; 0x4400 <xQueueGive+0x228>
    442c:	8f ef       	ldi	r24, 0xFF	; 255
    442e:	f8 01       	movw	r30, r16
    4430:	86 8f       	std	Z+30, r24	; 0x1e
    4432:	0f 90       	pop	r0
    4434:	0f be       	out	0x3f, r0	; 63
    4436:	0f b6       	in	r0, 0x3f	; 63
    4438:	f8 94       	cli
    443a:	0f 92       	push	r0
    443c:	85 8d       	ldd	r24, Z+29	; 0x1d
    443e:	18 16       	cp	r1, r24
    4440:	d4 f4       	brge	.+52     	; 0x4476 <xQueueGive+0x29e>
    4442:	80 85       	ldd	r24, Z+8	; 0x08
    4444:	81 11       	cpse	r24, r1
    4446:	06 c0       	rjmp	.+12     	; 0x4454 <xQueueGive+0x27c>
    4448:	16 c0       	rjmp	.+44     	; 0x4476 <xQueueGive+0x29e>
    444a:	f8 01       	movw	r30, r16
    444c:	80 85       	ldd	r24, Z+8	; 0x08
    444e:	81 11       	cpse	r24, r1
    4450:	05 c0       	rjmp	.+10     	; 0x445c <xQueueGive+0x284>
    4452:	11 c0       	rjmp	.+34     	; 0x4476 <xQueueGive+0x29e>
    4454:	78 01       	movw	r14, r16
    4456:	f8 e0       	ldi	r31, 0x08	; 8
    4458:	ef 0e       	add	r14, r31
    445a:	f1 1c       	adc	r15, r1
    445c:	c7 01       	movw	r24, r14
    445e:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    4462:	81 11       	cpse	r24, r1
    4464:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
    4468:	f8 01       	movw	r30, r16
    446a:	85 8d       	ldd	r24, Z+29	; 0x1d
    446c:	81 50       	subi	r24, 0x01	; 1
    446e:	85 8f       	std	Z+29, r24	; 0x1d
    4470:	85 8d       	ldd	r24, Z+29	; 0x1d
    4472:	18 16       	cp	r1, r24
    4474:	54 f3       	brlt	.-44     	; 0x444a <xQueueGive+0x272>
    4476:	8f ef       	ldi	r24, 0xFF	; 255
    4478:	f8 01       	movw	r30, r16
    447a:	85 8f       	std	Z+29, r24	; 0x1d
    447c:	0f 90       	pop	r0
    447e:	0f be       	out	0x3f, r0	; 63
    4480:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    4484:	80 e0       	ldi	r24, 0x00	; 0
    4486:	08 c0       	rjmp	.+16     	; 0x4498 <xQueueGive+0x2c0>
    4488:	f8 01       	movw	r30, r16
    448a:	82 8d       	ldd	r24, Z+26	; 0x1a
    448c:	8f 5f       	subi	r24, 0xFF	; 255
    448e:	82 8f       	std	Z+26, r24	; 0x1a
    4490:	81 89       	ldd	r24, Z+17	; 0x11
    4492:	81 11       	cpse	r24, r1
    4494:	db ce       	rjmp	.-586    	; 0x424c <xQueueGive+0x74>
    4496:	e4 ce       	rjmp	.-568    	; 0x4260 <xQueueGive+0x88>
    4498:	0f 90       	pop	r0
    449a:	0f 90       	pop	r0
    449c:	0f 90       	pop	r0
    449e:	0f 90       	pop	r0
    44a0:	0f 90       	pop	r0
    44a2:	df 91       	pop	r29
    44a4:	cf 91       	pop	r28
    44a6:	1f 91       	pop	r17
    44a8:	0f 91       	pop	r16
    44aa:	ff 90       	pop	r15
    44ac:	ef 90       	pop	r14
    44ae:	df 90       	pop	r13
    44b0:	cf 90       	pop	r12
    44b2:	bf 90       	pop	r11
    44b4:	af 90       	pop	r10
    44b6:	9f 90       	pop	r9
    44b8:	08 95       	ret

000044ba <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    44ba:	cf 93       	push	r28
    44bc:	df 93       	push	r29
    44be:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    44c0:	92 8d       	ldd	r25, Z+26	; 0x1a
    44c2:	83 8d       	ldd	r24, Z+27	; 0x1b
    44c4:	98 17       	cp	r25, r24
    44c6:	d0 f4       	brcc	.+52     	; 0x44fc <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    44c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    44ca:	8f 5f       	subi	r24, 0xFF	; 255
    44cc:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    44ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    44d0:	8f 3f       	cpi	r24, 0xFF	; 255
    44d2:	79 f4       	brne	.+30     	; 0x44f2 <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    44d4:	81 89       	ldd	r24, Z+17	; 0x11
    44d6:	88 23       	and	r24, r24
    44d8:	99 f0       	breq	.+38     	; 0x4500 <xQueueGiveFromISR+0x46>
    44da:	eb 01       	movw	r28, r22
    44dc:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    44de:	41 96       	adiw	r24, 0x11	; 17
    44e0:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    44e4:	88 23       	and	r24, r24
    44e6:	71 f0       	breq	.+28     	; 0x4504 <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    44e8:	20 97       	sbiw	r28, 0x00	; 0
    44ea:	71 f0       	breq	.+28     	; 0x4508 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    44ec:	81 e0       	ldi	r24, 0x01	; 1
    44ee:	88 83       	st	Y, r24
    44f0:	0c c0       	rjmp	.+24     	; 0x450a <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    44f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    44f4:	8f 5f       	subi	r24, 0xFF	; 255
    44f6:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    44f8:	81 e0       	ldi	r24, 0x01	; 1
    44fa:	07 c0       	rjmp	.+14     	; 0x450a <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    44fc:	80 e0       	ldi	r24, 0x00	; 0
    44fe:	05 c0       	rjmp	.+10     	; 0x450a <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    4500:	81 e0       	ldi	r24, 0x01	; 1
    4502:	03 c0       	rjmp	.+6      	; 0x450a <xQueueGiveFromISR+0x50>
    4504:	81 e0       	ldi	r24, 0x01	; 1
    4506:	01 c0       	rjmp	.+2      	; 0x450a <xQueueGiveFromISR+0x50>
    4508:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    450a:	df 91       	pop	r29
    450c:	cf 91       	pop	r28
    450e:	08 95       	ret

00004510 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    4510:	6f 92       	push	r6
    4512:	7f 92       	push	r7
    4514:	8f 92       	push	r8
    4516:	9f 92       	push	r9
    4518:	af 92       	push	r10
    451a:	bf 92       	push	r11
    451c:	cf 92       	push	r12
    451e:	df 92       	push	r13
    4520:	ef 92       	push	r14
    4522:	ff 92       	push	r15
    4524:	0f 93       	push	r16
    4526:	1f 93       	push	r17
    4528:	cf 93       	push	r28
    452a:	df 93       	push	r29
    452c:	00 d0       	rcall	.+0      	; 0x452e <xQueueGenericReceive+0x1e>
    452e:	1f 92       	push	r1
    4530:	1f 92       	push	r1
    4532:	cd b7       	in	r28, 0x3d	; 61
    4534:	de b7       	in	r29, 0x3e	; 62
    4536:	8c 01       	movw	r16, r24
    4538:	5b 01       	movw	r10, r22
    453a:	5d 83       	std	Y+5, r21	; 0x05
    453c:	4c 83       	std	Y+4, r20	; 0x04
    453e:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    4540:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    4542:	77 24       	eor	r7, r7
    4544:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4546:	99 24       	eor	r9, r9
    4548:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    454a:	6c 01       	movw	r12, r24
    454c:	88 e0       	ldi	r24, 0x08	; 8
    454e:	c8 0e       	add	r12, r24
    4550:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4552:	78 01       	movw	r14, r16
    4554:	e1 e1       	ldi	r30, 0x11	; 17
    4556:	ee 0e       	add	r14, r30
    4558:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    455a:	0f b6       	in	r0, 0x3f	; 63
    455c:	f8 94       	cli
    455e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    4560:	f8 01       	movw	r30, r16
    4562:	82 8d       	ldd	r24, Z+26	; 0x1a
    4564:	88 23       	and	r24, r24
    4566:	09 f4       	brne	.+2      	; 0x456a <xQueueGenericReceive+0x5a>
    4568:	45 c0       	rjmp	.+138    	; 0x45f4 <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    456a:	e6 80       	ldd	r14, Z+6	; 0x06
    456c:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    456e:	44 8d       	ldd	r20, Z+28	; 0x1c
    4570:	44 23       	and	r20, r20
    4572:	a9 f0       	breq	.+42     	; 0x459e <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    4574:	50 e0       	ldi	r21, 0x00	; 0
    4576:	c7 01       	movw	r24, r14
    4578:	84 0f       	add	r24, r20
    457a:	95 1f       	adc	r25, r21
    457c:	97 83       	std	Z+7, r25	; 0x07
    457e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    4580:	22 81       	ldd	r18, Z+2	; 0x02
    4582:	33 81       	ldd	r19, Z+3	; 0x03
    4584:	82 17       	cp	r24, r18
    4586:	93 07       	cpc	r25, r19
    4588:	20 f0       	brcs	.+8      	; 0x4592 <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    458a:	80 81       	ld	r24, Z
    458c:	91 81       	ldd	r25, Z+1	; 0x01
    458e:	97 83       	std	Z+7, r25	; 0x07
    4590:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    4592:	f8 01       	movw	r30, r16
    4594:	66 81       	ldd	r22, Z+6	; 0x06
    4596:	77 81       	ldd	r23, Z+7	; 0x07
    4598:	c5 01       	movw	r24, r10
    459a:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    459e:	61 10       	cpse	r6, r1
    45a0:	19 c0       	rjmp	.+50     	; 0x45d4 <xQueueGenericReceive+0xc4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    45a2:	f8 01       	movw	r30, r16
    45a4:	82 8d       	ldd	r24, Z+26	; 0x1a
    45a6:	81 50       	subi	r24, 0x01	; 1
    45a8:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    45aa:	80 81       	ld	r24, Z
    45ac:	91 81       	ldd	r25, Z+1	; 0x01
    45ae:	89 2b       	or	r24, r25
    45b0:	29 f4       	brne	.+10     	; 0x45bc <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    45b2:	0e 94 20 30 	call	0x6040	; 0x6040 <pvTaskIncrementMutexHeldCount>
    45b6:	f8 01       	movw	r30, r16
    45b8:	93 83       	std	Z+3, r25	; 0x03
    45ba:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    45bc:	f8 01       	movw	r30, r16
    45be:	80 85       	ldd	r24, Z+8	; 0x08
    45c0:	88 23       	and	r24, r24
    45c2:	a1 f0       	breq	.+40     	; 0x45ec <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    45c4:	c8 01       	movw	r24, r16
    45c6:	08 96       	adiw	r24, 0x08	; 8
    45c8:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    45cc:	81 30       	cpi	r24, 0x01	; 1
    45ce:	71 f4       	brne	.+28     	; 0x45ec <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
    45d0:	84 d9       	rcall	.-3320   	; 0x38da <vPortYield>
    45d2:	0c c0       	rjmp	.+24     	; 0x45ec <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    45d4:	f8 01       	movw	r30, r16
    45d6:	f7 82       	std	Z+7, r15	; 0x07
    45d8:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    45da:	81 89       	ldd	r24, Z+17	; 0x11
    45dc:	88 23       	and	r24, r24
    45de:	31 f0       	breq	.+12     	; 0x45ec <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    45e0:	c8 01       	movw	r24, r16
    45e2:	41 96       	adiw	r24, 0x11	; 17
    45e4:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    45e8:	81 11       	cpse	r24, r1
    45ea:	77 d9       	rcall	.-3346   	; 0x38da <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    45ec:	0f 90       	pop	r0
    45ee:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    45f0:	81 e0       	ldi	r24, 0x01	; 1
    45f2:	1a c1       	rjmp	.+564    	; 0x4828 <xQueueGenericReceive+0x318>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    45f4:	8c 81       	ldd	r24, Y+4	; 0x04
    45f6:	9d 81       	ldd	r25, Y+5	; 0x05
    45f8:	89 2b       	or	r24, r25
    45fa:	21 f4       	brne	.+8      	; 0x4604 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    45fc:	0f 90       	pop	r0
    45fe:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    4600:	80 e0       	ldi	r24, 0x00	; 0
    4602:	12 c1       	rjmp	.+548    	; 0x4828 <xQueueGenericReceive+0x318>
				}
				else if( xEntryTimeSet == pdFALSE )
    4604:	81 10       	cpse	r8, r1
    4606:	05 c0       	rjmp	.+10     	; 0x4612 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4608:	ce 01       	movw	r24, r28
    460a:	01 96       	adiw	r24, 0x01	; 1
    460c:	0e 94 2f 2f 	call	0x5e5e	; 0x5e5e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    4610:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4612:	0f 90       	pop	r0
    4614:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4616:	0e 94 f8 2b 	call	0x57f0	; 0x57f0 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    461a:	0f b6       	in	r0, 0x3f	; 63
    461c:	f8 94       	cli
    461e:	0f 92       	push	r0
    4620:	f8 01       	movw	r30, r16
    4622:	85 8d       	ldd	r24, Z+29	; 0x1d
    4624:	8f 3f       	cpi	r24, 0xFF	; 255
    4626:	09 f4       	brne	.+2      	; 0x462a <xQueueGenericReceive+0x11a>
    4628:	15 8e       	std	Z+29, r1	; 0x1d
    462a:	f8 01       	movw	r30, r16
    462c:	86 8d       	ldd	r24, Z+30	; 0x1e
    462e:	8f 3f       	cpi	r24, 0xFF	; 255
    4630:	09 f4       	brne	.+2      	; 0x4634 <xQueueGenericReceive+0x124>
    4632:	16 8e       	std	Z+30, r1	; 0x1e
    4634:	0f 90       	pop	r0
    4636:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4638:	be 01       	movw	r22, r28
    463a:	6c 5f       	subi	r22, 0xFC	; 252
    463c:	7f 4f       	sbci	r23, 0xFF	; 255
    463e:	ce 01       	movw	r24, r28
    4640:	01 96       	adiw	r24, 0x01	; 1
    4642:	0e 94 3a 2f 	call	0x5e74	; 0x5e74 <xTaskCheckForTimeOut>
    4646:	81 11       	cpse	r24, r1
    4648:	a2 c0       	rjmp	.+324    	; 0x478e <xQueueGenericReceive+0x27e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    464a:	0f b6       	in	r0, 0x3f	; 63
    464c:	f8 94       	cli
    464e:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    4650:	f8 01       	movw	r30, r16
    4652:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    4654:	0f 90       	pop	r0
    4656:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4658:	81 11       	cpse	r24, r1
    465a:	57 c0       	rjmp	.+174    	; 0x470a <xQueueGenericReceive+0x1fa>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    465c:	80 81       	ld	r24, Z
    465e:	91 81       	ldd	r25, Z+1	; 0x01
    4660:	89 2b       	or	r24, r25
    4662:	49 f4       	brne	.+18     	; 0x4676 <xQueueGenericReceive+0x166>
					{
						taskENTER_CRITICAL();
    4664:	0f b6       	in	r0, 0x3f	; 63
    4666:	f8 94       	cli
    4668:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    466a:	82 81       	ldd	r24, Z+2	; 0x02
    466c:	93 81       	ldd	r25, Z+3	; 0x03
    466e:	0e 94 7e 2f 	call	0x5efc	; 0x5efc <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    4672:	0f 90       	pop	r0
    4674:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    4676:	6c 81       	ldd	r22, Y+4	; 0x04
    4678:	7d 81       	ldd	r23, Y+5	; 0x05
    467a:	c7 01       	movw	r24, r14
    467c:	0e 94 8c 2e 	call	0x5d18	; 0x5d18 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4680:	0f b6       	in	r0, 0x3f	; 63
    4682:	f8 94       	cli
    4684:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4686:	f8 01       	movw	r30, r16
    4688:	86 8d       	ldd	r24, Z+30	; 0x1e
    468a:	18 16       	cp	r1, r24
    468c:	ac f4       	brge	.+42     	; 0x46b8 <xQueueGenericReceive+0x1a8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    468e:	81 89       	ldd	r24, Z+17	; 0x11
    4690:	81 11       	cpse	r24, r1
    4692:	05 c0       	rjmp	.+10     	; 0x469e <xQueueGenericReceive+0x18e>
    4694:	11 c0       	rjmp	.+34     	; 0x46b8 <xQueueGenericReceive+0x1a8>
    4696:	f8 01       	movw	r30, r16
    4698:	81 89       	ldd	r24, Z+17	; 0x11
    469a:	88 23       	and	r24, r24
    469c:	69 f0       	breq	.+26     	; 0x46b8 <xQueueGenericReceive+0x1a8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    469e:	c7 01       	movw	r24, r14
    46a0:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    46a4:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    46a6:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    46aa:	f8 01       	movw	r30, r16
    46ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    46ae:	81 50       	subi	r24, 0x01	; 1
    46b0:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    46b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    46b4:	18 16       	cp	r1, r24
    46b6:	7c f3       	brlt	.-34     	; 0x4696 <xQueueGenericReceive+0x186>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    46b8:	f8 01       	movw	r30, r16
    46ba:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    46bc:	0f 90       	pop	r0
    46be:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    46c0:	0f b6       	in	r0, 0x3f	; 63
    46c2:	f8 94       	cli
    46c4:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    46c6:	85 8d       	ldd	r24, Z+29	; 0x1d
    46c8:	18 16       	cp	r1, r24
    46ca:	ac f4       	brge	.+42     	; 0x46f6 <xQueueGenericReceive+0x1e6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    46cc:	80 85       	ldd	r24, Z+8	; 0x08
    46ce:	81 11       	cpse	r24, r1
    46d0:	05 c0       	rjmp	.+10     	; 0x46dc <xQueueGenericReceive+0x1cc>
    46d2:	11 c0       	rjmp	.+34     	; 0x46f6 <xQueueGenericReceive+0x1e6>
    46d4:	f8 01       	movw	r30, r16
    46d6:	80 85       	ldd	r24, Z+8	; 0x08
    46d8:	88 23       	and	r24, r24
    46da:	69 f0       	breq	.+26     	; 0x46f6 <xQueueGenericReceive+0x1e6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    46dc:	c6 01       	movw	r24, r12
    46de:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    46e2:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    46e4:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    46e8:	f8 01       	movw	r30, r16
    46ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    46ec:	81 50       	subi	r24, 0x01	; 1
    46ee:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    46f0:	85 8d       	ldd	r24, Z+29	; 0x1d
    46f2:	18 16       	cp	r1, r24
    46f4:	7c f3       	brlt	.-34     	; 0x46d4 <xQueueGenericReceive+0x1c4>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    46f6:	f8 01       	movw	r30, r16
    46f8:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    46fa:	0f 90       	pop	r0
    46fc:	0f be       	out	0x3f, r0	; 63
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    46fe:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    4702:	81 11       	cpse	r24, r1
				{
					portYIELD_WITHIN_API();
    4704:	2a cf       	rjmp	.-428    	; 0x455a <xQueueGenericReceive+0x4a>
    4706:	e9 d8       	rcall	.-3630   	; 0x38da <vPortYield>
    4708:	28 cf       	rjmp	.-432    	; 0x455a <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    470a:	0f b6       	in	r0, 0x3f	; 63
    470c:	f8 94       	cli
    470e:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4710:	f8 01       	movw	r30, r16
    4712:	86 8d       	ldd	r24, Z+30	; 0x1e
    4714:	18 16       	cp	r1, r24
    4716:	ac f4       	brge	.+42     	; 0x4742 <xQueueGenericReceive+0x232>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4718:	81 89       	ldd	r24, Z+17	; 0x11
    471a:	81 11       	cpse	r24, r1
    471c:	05 c0       	rjmp	.+10     	; 0x4728 <xQueueGenericReceive+0x218>
    471e:	11 c0       	rjmp	.+34     	; 0x4742 <xQueueGenericReceive+0x232>
    4720:	f8 01       	movw	r30, r16
    4722:	81 89       	ldd	r24, Z+17	; 0x11
    4724:	88 23       	and	r24, r24
    4726:	69 f0       	breq	.+26     	; 0x4742 <xQueueGenericReceive+0x232>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4728:	c7 01       	movw	r24, r14
    472a:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    472e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    4730:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    4734:	f8 01       	movw	r30, r16
    4736:	86 8d       	ldd	r24, Z+30	; 0x1e
    4738:	81 50       	subi	r24, 0x01	; 1
    473a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    473c:	86 8d       	ldd	r24, Z+30	; 0x1e
    473e:	18 16       	cp	r1, r24
    4740:	7c f3       	brlt	.-34     	; 0x4720 <xQueueGenericReceive+0x210>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4742:	f8 01       	movw	r30, r16
    4744:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    4746:	0f 90       	pop	r0
    4748:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    474a:	0f b6       	in	r0, 0x3f	; 63
    474c:	f8 94       	cli
    474e:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4750:	85 8d       	ldd	r24, Z+29	; 0x1d
    4752:	18 16       	cp	r1, r24
    4754:	ac f4       	brge	.+42     	; 0x4780 <xQueueGenericReceive+0x270>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4756:	80 85       	ldd	r24, Z+8	; 0x08
    4758:	81 11       	cpse	r24, r1
    475a:	05 c0       	rjmp	.+10     	; 0x4766 <xQueueGenericReceive+0x256>
    475c:	11 c0       	rjmp	.+34     	; 0x4780 <xQueueGenericReceive+0x270>
    475e:	f8 01       	movw	r30, r16
    4760:	80 85       	ldd	r24, Z+8	; 0x08
    4762:	88 23       	and	r24, r24
    4764:	69 f0       	breq	.+26     	; 0x4780 <xQueueGenericReceive+0x270>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4766:	c6 01       	movw	r24, r12
    4768:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    476c:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    476e:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    4772:	f8 01       	movw	r30, r16
    4774:	85 8d       	ldd	r24, Z+29	; 0x1d
    4776:	81 50       	subi	r24, 0x01	; 1
    4778:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    477a:	85 8d       	ldd	r24, Z+29	; 0x1d
    477c:	18 16       	cp	r1, r24
    477e:	7c f3       	brlt	.-34     	; 0x475e <xQueueGenericReceive+0x24e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4780:	f8 01       	movw	r30, r16
    4782:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    4784:	0f 90       	pop	r0
    4786:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    4788:	0e 94 fe 2b 	call	0x57fc	; 0x57fc <xTaskResumeAll>
    478c:	e6 ce       	rjmp	.-564    	; 0x455a <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    478e:	0f b6       	in	r0, 0x3f	; 63
    4790:	f8 94       	cli
    4792:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4794:	f8 01       	movw	r30, r16
    4796:	86 8d       	ldd	r24, Z+30	; 0x1e
    4798:	18 16       	cp	r1, r24
    479a:	d4 f4       	brge	.+52     	; 0x47d0 <xQueueGenericReceive+0x2c0>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    479c:	81 89       	ldd	r24, Z+17	; 0x11
    479e:	81 11       	cpse	r24, r1
    47a0:	06 c0       	rjmp	.+12     	; 0x47ae <xQueueGenericReceive+0x29e>
    47a2:	16 c0       	rjmp	.+44     	; 0x47d0 <xQueueGenericReceive+0x2c0>
    47a4:	f8 01       	movw	r30, r16
    47a6:	81 89       	ldd	r24, Z+17	; 0x11
    47a8:	81 11       	cpse	r24, r1
    47aa:	05 c0       	rjmp	.+10     	; 0x47b6 <xQueueGenericReceive+0x2a6>
    47ac:	11 c0       	rjmp	.+34     	; 0x47d0 <xQueueGenericReceive+0x2c0>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    47ae:	78 01       	movw	r14, r16
    47b0:	f1 e1       	ldi	r31, 0x11	; 17
    47b2:	ef 0e       	add	r14, r31
    47b4:	f1 1c       	adc	r15, r1
    47b6:	c7 01       	movw	r24, r14
    47b8:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    47bc:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    47be:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    47c2:	f8 01       	movw	r30, r16
    47c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    47c6:	81 50       	subi	r24, 0x01	; 1
    47c8:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    47ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    47cc:	18 16       	cp	r1, r24
    47ce:	54 f3       	brlt	.-44     	; 0x47a4 <xQueueGenericReceive+0x294>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    47d0:	8f ef       	ldi	r24, 0xFF	; 255
    47d2:	f8 01       	movw	r30, r16
    47d4:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    47d6:	0f 90       	pop	r0
    47d8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    47da:	0f b6       	in	r0, 0x3f	; 63
    47dc:	f8 94       	cli
    47de:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    47e0:	85 8d       	ldd	r24, Z+29	; 0x1d
    47e2:	18 16       	cp	r1, r24
    47e4:	d4 f4       	brge	.+52     	; 0x481a <xQueueGenericReceive+0x30a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    47e6:	80 85       	ldd	r24, Z+8	; 0x08
    47e8:	81 11       	cpse	r24, r1
    47ea:	06 c0       	rjmp	.+12     	; 0x47f8 <xQueueGenericReceive+0x2e8>
    47ec:	16 c0       	rjmp	.+44     	; 0x481a <xQueueGenericReceive+0x30a>
    47ee:	f8 01       	movw	r30, r16
    47f0:	80 85       	ldd	r24, Z+8	; 0x08
    47f2:	81 11       	cpse	r24, r1
    47f4:	05 c0       	rjmp	.+10     	; 0x4800 <xQueueGenericReceive+0x2f0>
    47f6:	11 c0       	rjmp	.+34     	; 0x481a <xQueueGenericReceive+0x30a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    47f8:	78 01       	movw	r14, r16
    47fa:	f8 e0       	ldi	r31, 0x08	; 8
    47fc:	ef 0e       	add	r14, r31
    47fe:	f1 1c       	adc	r15, r1
    4800:	c7 01       	movw	r24, r14
    4802:	0e 94 e7 2e 	call	0x5dce	; 0x5dce <xTaskRemoveFromEventList>
    4806:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    4808:	0e 94 75 2f 	call	0x5eea	; 0x5eea <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    480c:	f8 01       	movw	r30, r16
    480e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4810:	81 50       	subi	r24, 0x01	; 1
    4812:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4814:	85 8d       	ldd	r24, Z+29	; 0x1d
    4816:	18 16       	cp	r1, r24
    4818:	54 f3       	brlt	.-44     	; 0x47ee <xQueueGenericReceive+0x2de>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    481a:	8f ef       	ldi	r24, 0xFF	; 255
    481c:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    481e:	85 8f       	std	Z+29, r24	; 0x1d
    4820:	0f 90       	pop	r0
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    4822:	0f be       	out	0x3f, r0	; 63
    4824:	eb d7       	rcall	.+4054   	; 0x57fc <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    4826:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    4828:	0f 90       	pop	r0
    482a:	0f 90       	pop	r0
    482c:	0f 90       	pop	r0
    482e:	0f 90       	pop	r0
    4830:	0f 90       	pop	r0
    4832:	df 91       	pop	r29
    4834:	cf 91       	pop	r28
    4836:	1f 91       	pop	r17
    4838:	0f 91       	pop	r16
    483a:	ff 90       	pop	r15
    483c:	ef 90       	pop	r14
    483e:	df 90       	pop	r13
    4840:	cf 90       	pop	r12
    4842:	bf 90       	pop	r11
    4844:	af 90       	pop	r10
    4846:	9f 90       	pop	r9
    4848:	8f 90       	pop	r8
    484a:	7f 90       	pop	r7
    484c:	6f 90       	pop	r6
    484e:	08 95       	ret

00004850 <server_receiver>:
  uint8_t status = TYPE_PING_RESPONSE;
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
  else simple_p_send(SERVER_ADDRESS, &status, 1);
}

void server_receiver(uint8_t *data, uint16_t len) {
    4850:	ab 01       	movw	r20, r22
  if(data == NULL) { // ARQ passes NULL to the callback when connection is lost
    4852:	00 97       	sbiw	r24, 0x00	; 0
    4854:	11 f4       	brne	.+4      	; 0x485a <server_receiver+0xa>
      gHandshook = 0;
    4856:	10 92 1c 1a 	sts	0x1A1C, r1	; 0x801a1c <gHandshook>
  }
  memcpy(&message_in, data, len);
    485a:	bc 01       	movw	r22, r24
    485c:	8d e8       	ldi	r24, 0x8D	; 141
    485e:	9b e1       	ldi	r25, 0x1B	; 27
    4860:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
  xSemaphoreGive(xCommandReadyBSem);
    4864:	60 e0       	ldi	r22, 0x00	; 0
    4866:	70 e0       	ldi	r23, 0x00	; 0
    4868:	80 91 89 1b 	lds	r24, 0x1B89	; 0x801b89 <xCommandReadyBSem>
    486c:	90 91 8a 1b 	lds	r25, 0x1B8A	; 0x801b8a <xCommandReadyBSem+0x1>
    4870:	b3 cc       	rjmp	.-1690   	; 0x41d8 <xQueueGive>
    4872:	08 95       	ret

00004874 <server_communication_init>:
#define TYPE_PING           8
#define TYPE_PING_RESPONSE  9
#define TYPE_DEBUG          10

void server_communication_init(void) {
  if(connected) return;
    4874:	80 91 25 1a 	lds	r24, 0x1A25	; 0x801a25 <connected>
    4878:	81 11       	cpse	r24, r1
    487a:	04 c0       	rjmp	.+8      	; 0x4884 <server_communication_init+0x10>
  server_connection = arq_new_connection();
    487c:	0e 94 60 01 	call	0x2c0	; 0x2c0 <arq_new_connection>
    4880:	80 93 bf 1b 	sts	0x1BBF, r24	; 0x801bbf <server_connection>
    4884:	08 95       	ret

00004886 <server_connect>:
}

uint8_t server_connect(void) {
  connected = arq_connect(server_connection, SERVER_ADDRESS, server_receiver, 1000);
    4886:	28 ee       	ldi	r18, 0xE8	; 232
    4888:	33 e0       	ldi	r19, 0x03	; 3
    488a:	48 e2       	ldi	r20, 0x28	; 40
    488c:	54 e2       	ldi	r21, 0x24	; 36
    488e:	60 e0       	ldi	r22, 0x00	; 0
    4890:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4894:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <arq_connect>
    4898:	80 93 25 1a 	sts	0x1A25, r24	; 0x801a25 <connected>
  return connected;
}
    489c:	08 95       	ret

0000489e <send_handshake>:

uint8_t send_handshake(void) {
    489e:	cf 93       	push	r28
    48a0:	df 93       	push	r29
    48a2:	cd b7       	in	r28, 0x3d	; 61
    48a4:	de b7       	in	r29, 0x3e	; 62
    48a6:	e4 97       	sbiw	r28, 0x34	; 52
    48a8:	0f b6       	in	r0, 0x3f	; 63
    48aa:	f8 94       	cli
    48ac:	de bf       	out	0x3e, r29	; 62
    48ae:	0f be       	out	0x3f, r0	; 63
    48b0:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return 0;
    48b2:	80 91 25 1a 	lds	r24, 0x1A25	; 0x801a25 <connected>
    48b6:	88 23       	and	r24, r24
    48b8:	09 f4       	brne	.+2      	; 0x48bc <send_handshake+0x1e>
    48ba:	4d c0       	rjmp	.+154    	; 0x4956 <send_handshake+0xb8>
  message_t msg;
  msg.type = TYPE_HANDSHAKE;
    48bc:	19 82       	std	Y+1, r1	; 0x01
  msg.message.handshake.name_length = ROBOT_NAME_LENGTH;
    48be:	83 e0       	ldi	r24, 0x03	; 3
    48c0:	8a 83       	std	Y+2, r24	; 0x02
  strcpy((char*)msg.message.handshake.name, ROBOT_NAME);
    48c2:	81 e4       	ldi	r24, 0x41	; 65
    48c4:	92 e5       	ldi	r25, 0x52	; 82
    48c6:	9c 83       	std	Y+4, r25	; 0x04
    48c8:	8b 83       	std	Y+3, r24	; 0x03
    48ca:	84 e4       	ldi	r24, 0x44	; 68
    48cc:	90 e0       	ldi	r25, 0x00	; 0
    48ce:	9e 83       	std	Y+6, r25	; 0x06
    48d0:	8d 83       	std	Y+5, r24	; 0x05
  msg.message.handshake.width = ROBOT_TOTAL_WIDTH_MM;
    48d2:	24 eb       	ldi	r18, 0xB4	; 180
    48d4:	30 e0       	ldi	r19, 0x00	; 0
    48d6:	3f 83       	std	Y+7, r19	; 0x07
    48d8:	2e 83       	std	Y+6, r18	; 0x06
  msg.message.handshake.length = ROBOT_TOTAL_LENGTH_MM;
    48da:	85 ef       	ldi	r24, 0xF5	; 245
    48dc:	90 e0       	ldi	r25, 0x00	; 0
    48de:	99 87       	std	Y+9, r25	; 0x09
    48e0:	88 87       	std	Y+8, r24	; 0x08
  msg.message.handshake.axel_offset = ROBOT_AXEL_OFFSET_MM;
    48e2:	88 e3       	ldi	r24, 0x38	; 56
    48e4:	8c 87       	std	Y+12, r24	; 0x0c
  msg.message.handshake.tower_offset_x = SENSOR_TOWER_OFFSET_X_MM;
    48e6:	8a 87       	std	Y+10, r24	; 0x0a
  msg.message.handshake.tower_offset_y = SENSOR_TOWER_OFFSET_Y_MM;
    48e8:	1b 86       	std	Y+11, r1	; 0x0b
  msg.message.handshake.sensor_offset1 = SENSOR_OFFSET_RADIUS_MM;
    48ea:	85 e1       	ldi	r24, 0x15	; 21
    48ec:	8d 87       	std	Y+13, r24	; 0x0d
  msg.message.handshake.sensor_offset2 = SENSOR_OFFSET_RADIUS_MM;
    48ee:	8e 87       	std	Y+14, r24	; 0x0e
  msg.message.handshake.sensor_offset3 = SENSOR_OFFSET_RADIUS_MM;
    48f0:	8f 87       	std	Y+15, r24	; 0x0f
  msg.message.handshake.sensor_offset4 = SENSOR_OFFSET_RADIUS_MM;
    48f2:	88 8b       	std	Y+16, r24	; 0x10
  msg.message.handshake.sensor_heading1 = SENSOR1_HEADING_DEG;
    48f4:	1a 8a       	std	Y+18, r1	; 0x12
    48f6:	19 8a       	std	Y+17, r1	; 0x11
  msg.message.handshake.sensor_heading2 = SENSOR2_HEADING_DEG;
    48f8:	8a e5       	ldi	r24, 0x5A	; 90
    48fa:	90 e0       	ldi	r25, 0x00	; 0
    48fc:	9c 8b       	std	Y+20, r25	; 0x14
    48fe:	8b 8b       	std	Y+19, r24	; 0x13
  msg.message.handshake.sensor_heading3 = SENSOR3_HEADING_DEG;
    4900:	3e 8b       	std	Y+22, r19	; 0x16
    4902:	2d 8b       	std	Y+21, r18	; 0x15
  msg.message.handshake.sensor_heading4 = SENSOR4_HEADING_DEG;
    4904:	8e e0       	ldi	r24, 0x0E	; 14
    4906:	91 e0       	ldi	r25, 0x01	; 1
    4908:	98 8f       	std	Y+24, r25	; 0x18
    490a:	8f 8b       	std	Y+23, r24	; 0x17
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
    490c:	88 ec       	ldi	r24, 0xC8	; 200
    490e:	90 e0       	ldi	r25, 0x00	; 0
    4910:	9a 8f       	std	Y+26, r25	; 0x1a
    4912:	89 8f       	std	Y+25, r24	; 0x19
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    4914:	8a e1       	ldi	r24, 0x1A	; 26
    4916:	fe 01       	movw	r30, r28
    4918:	31 96       	adiw	r30, 0x01	; 1
    491a:	de 01       	movw	r26, r28
    491c:	5b 96       	adiw	r26, 0x1b	; 27
    491e:	01 90       	ld	r0, Z+
    4920:	0d 92       	st	X+, r0
    4922:	8a 95       	dec	r24
    4924:	e1 f7       	brne	.-8      	; 0x491e <send_handshake+0x80>
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
    4926:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <use_arq>
    492a:	88 23       	and	r24, r24
    492c:	59 f0       	breq	.+22     	; 0x4944 <send_handshake+0xa6>
    492e:	4a e1       	ldi	r20, 0x1A	; 26
    4930:	50 e0       	ldi	r21, 0x00	; 0
    4932:	be 01       	movw	r22, r28
    4934:	65 5e       	subi	r22, 0xE5	; 229
    4936:	7f 4f       	sbci	r23, 0xFF	; 255
    4938:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    493c:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
  else simple_p_send(server_connection, data, sizeof(data));
  return 1;
    4940:	81 e0       	ldi	r24, 0x01	; 1
    4942:	09 c0       	rjmp	.+18     	; 0x4956 <send_handshake+0xb8>
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
  else simple_p_send(server_connection, data, sizeof(data));
    4944:	4a e1       	ldi	r20, 0x1A	; 26
    4946:	50 e0       	ldi	r21, 0x00	; 0
    4948:	be 01       	movw	r22, r28
    494a:	65 5e       	subi	r22, 0xE5	; 229
    494c:	7f 4f       	sbci	r23, 0xFF	; 255
    494e:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4952:	89 d1       	rcall	.+786    	; 0x4c66 <simple_p_send>
  return 1;
    4954:	81 e0       	ldi	r24, 0x01	; 1
}
    4956:	e4 96       	adiw	r28, 0x34	; 52
    4958:	0f b6       	in	r0, 0x3f	; 63
    495a:	f8 94       	cli
    495c:	de bf       	out	0x3e, r29	; 62
    495e:	0f be       	out	0x3f, r0	; 63
    4960:	cd bf       	out	0x3d, r28	; 61
    4962:	df 91       	pop	r29
    4964:	cf 91       	pop	r28
    4966:	08 95       	ret

00004968 <send_update>:

void send_update(int16_t x_cm, int16_t y_cm, int16_t heading_deg, int16_t towerAngle_deg, uint8_t S1_cm, uint8_t S2_cm, uint8_t S3_cm, uint8_t S4_cm){
    4968:	af 92       	push	r10
    496a:	cf 92       	push	r12
    496c:	ef 92       	push	r14
    496e:	0f 93       	push	r16
    4970:	cf 93       	push	r28
    4972:	df 93       	push	r29
    4974:	cd b7       	in	r28, 0x3d	; 61
    4976:	de b7       	in	r29, 0x3e	; 62
    4978:	2d 97       	sbiw	r28, 0x0d	; 13
    497a:	0f b6       	in	r0, 0x3f	; 63
    497c:	f8 94       	cli
    497e:	de bf       	out	0x3e, r29	; 62
    4980:	0f be       	out	0x3f, r0	; 63
    4982:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return;
    4984:	e0 91 25 1a 	lds	r30, 0x1A25	; 0x801a25 <connected>
    4988:	ee 23       	and	r30, r30
    498a:	19 f1       	breq	.+70     	; 0x49d2 <send_update+0x6a>
  msg.message.update.sensor1 = S1_cm;
  msg.message.update.sensor2 = S2_cm;
  msg.message.update.sensor3 = S3_cm;
  msg.message.update.sensor4 = S4_cm;
  uint8_t data[sizeof(update_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    498c:	e1 e0       	ldi	r30, 0x01	; 1
    498e:	e9 83       	std	Y+1, r30	; 0x01
    4990:	9b 83       	std	Y+3, r25	; 0x03
    4992:	8a 83       	std	Y+2, r24	; 0x02
    4994:	7d 83       	std	Y+5, r23	; 0x05
    4996:	6c 83       	std	Y+4, r22	; 0x04
    4998:	5f 83       	std	Y+7, r21	; 0x07
    499a:	4e 83       	std	Y+6, r20	; 0x06
    499c:	39 87       	std	Y+9, r19	; 0x09
    499e:	28 87       	std	Y+8, r18	; 0x08
    49a0:	0a 87       	std	Y+10, r16	; 0x0a
    49a2:	eb 86       	std	Y+11, r14	; 0x0b
    49a4:	cc 86       	std	Y+12, r12	; 0x0c
    49a6:	ad 86       	std	Y+13, r10	; 0x0d
  if(use_arq[TYPE_UPDATE]) arq_send(server_connection, data, sizeof(data));
    49a8:	80 91 01 06 	lds	r24, 0x0601	; 0x800601 <use_arq+0x1>
    49ac:	88 23       	and	r24, r24
    49ae:	51 f0       	breq	.+20     	; 0x49c4 <send_update+0x5c>
    49b0:	4d e0       	ldi	r20, 0x0D	; 13
    49b2:	50 e0       	ldi	r21, 0x00	; 0
    49b4:	be 01       	movw	r22, r28
    49b6:	6f 5f       	subi	r22, 0xFF	; 255
    49b8:	7f 4f       	sbci	r23, 0xFF	; 255
    49ba:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    49be:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    49c2:	07 c0       	rjmp	.+14     	; 0x49d2 <send_update+0x6a>
  else simple_p_send(SERVER_ADDRESS, data, sizeof(data));
    49c4:	4d e0       	ldi	r20, 0x0D	; 13
    49c6:	50 e0       	ldi	r21, 0x00	; 0
    49c8:	be 01       	movw	r22, r28
    49ca:	6f 5f       	subi	r22, 0xFF	; 255
    49cc:	7f 4f       	sbci	r23, 0xFF	; 255
    49ce:	80 e0       	ldi	r24, 0x00	; 0
    49d0:	4a d1       	rcall	.+660    	; 0x4c66 <simple_p_send>
}
    49d2:	2d 96       	adiw	r28, 0x0d	; 13
    49d4:	0f b6       	in	r0, 0x3f	; 63
    49d6:	f8 94       	cli
    49d8:	de bf       	out	0x3e, r29	; 62
    49da:	0f be       	out	0x3f, r0	; 63
    49dc:	cd bf       	out	0x3d, r28	; 61
    49de:	df 91       	pop	r29
    49e0:	cf 91       	pop	r28
    49e2:	0f 91       	pop	r16
    49e4:	ef 90       	pop	r14
    49e6:	cf 90       	pop	r12
    49e8:	af 90       	pop	r10
    49ea:	08 95       	ret

000049ec <send_idle>:

void send_idle(void) {
    49ec:	cf 93       	push	r28
    49ee:	df 93       	push	r29
    49f0:	1f 92       	push	r1
    49f2:	cd b7       	in	r28, 0x3d	; 61
    49f4:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    49f6:	80 91 25 1a 	lds	r24, 0x1A25	; 0x801a25 <connected>
    49fa:	88 23       	and	r24, r24
    49fc:	b9 f0       	breq	.+46     	; 0x4a2c <send_idle+0x40>
  uint8_t status = TYPE_IDLE;
    49fe:	83 e0       	ldi	r24, 0x03	; 3
    4a00:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_IDLE]) arq_send(server_connection, &status, 1);
    4a02:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <use_arq+0x3>
    4a06:	88 23       	and	r24, r24
    4a08:	51 f0       	breq	.+20     	; 0x4a1e <send_idle+0x32>
    4a0a:	41 e0       	ldi	r20, 0x01	; 1
    4a0c:	50 e0       	ldi	r21, 0x00	; 0
    4a0e:	be 01       	movw	r22, r28
    4a10:	6f 5f       	subi	r22, 0xFF	; 255
    4a12:	7f 4f       	sbci	r23, 0xFF	; 255
    4a14:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4a18:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4a1c:	07 c0       	rjmp	.+14     	; 0x4a2c <send_idle+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    4a1e:	41 e0       	ldi	r20, 0x01	; 1
    4a20:	50 e0       	ldi	r21, 0x00	; 0
    4a22:	be 01       	movw	r22, r28
    4a24:	6f 5f       	subi	r22, 0xFF	; 255
    4a26:	7f 4f       	sbci	r23, 0xFF	; 255
    4a28:	80 e0       	ldi	r24, 0x00	; 0
    4a2a:	1d d1       	rcall	.+570    	; 0x4c66 <simple_p_send>
}
    4a2c:	0f 90       	pop	r0
    4a2e:	df 91       	pop	r29
    4a30:	cf 91       	pop	r28
    4a32:	08 95       	ret

00004a34 <debug>:
void debug(const char *fmt, ...) {
    4a34:	cf 93       	push	r28
    4a36:	df 93       	push	r29
    4a38:	cd b7       	in	r28, 0x3d	; 61
    4a3a:	de b7       	in	r29, 0x3e	; 62
    4a3c:	c4 56       	subi	r28, 0x64	; 100
    4a3e:	d1 09       	sbc	r29, r1
    4a40:	0f b6       	in	r0, 0x3f	; 63
    4a42:	f8 94       	cli
    4a44:	de bf       	out	0x3e, r29	; 62
    4a46:	0f be       	out	0x3f, r0	; 63
    4a48:	cd bf       	out	0x3d, r28	; 61
    4a4a:	ae 01       	movw	r20, r28
    4a4c:	46 59       	subi	r20, 0x96	; 150
    4a4e:	5f 4f       	sbci	r21, 0xFF	; 255
    4a50:	fa 01       	movw	r30, r20
    4a52:	61 91       	ld	r22, Z+
    4a54:	71 91       	ld	r23, Z+
    4a56:	af 01       	movw	r20, r30
	uint8_t buf[100];
	va_list ap;
	buf[0] = TYPE_DEBUG;
    4a58:	8a e0       	ldi	r24, 0x0A	; 10
    4a5a:	89 83       	std	Y+1, r24	; 0x01
	va_start(ap, fmt);
	uint8_t ret = vsprintf((char*)buf+1, fmt, ap);
    4a5c:	ce 01       	movw	r24, r28
    4a5e:	02 96       	adiw	r24, 0x02	; 2
    4a60:	0e 94 67 3c 	call	0x78ce	; 0x78ce <vsprintf>
	va_end(ap);
	if (ret > 0) {
    4a64:	88 23       	and	r24, r24
    4a66:	c9 f0       	breq	.+50     	; 0x4a9a <debug+0x66>
		if(use_arq[TYPE_DEBUG]) arq_send(server_connection, buf, ret+1);
    4a68:	20 91 0a 06 	lds	r18, 0x060A	; 0x80060a <use_arq+0xa>
    4a6c:	22 23       	and	r18, r18
    4a6e:	61 f0       	breq	.+24     	; 0x4a88 <debug+0x54>
    4a70:	99 27       	eor	r25, r25
    4a72:	ac 01       	movw	r20, r24
    4a74:	4f 5f       	subi	r20, 0xFF	; 255
    4a76:	5f 4f       	sbci	r21, 0xFF	; 255
    4a78:	be 01       	movw	r22, r28
    4a7a:	6f 5f       	subi	r22, 0xFF	; 255
    4a7c:	7f 4f       	sbci	r23, 0xFF	; 255
    4a7e:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4a82:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4a86:	09 c0       	rjmp	.+18     	; 0x4a9a <debug+0x66>
		else simple_p_send(SERVER_ADDRESS, buf, ret+1);
    4a88:	99 27       	eor	r25, r25
    4a8a:	ac 01       	movw	r20, r24
    4a8c:	4f 5f       	subi	r20, 0xFF	; 255
    4a8e:	5f 4f       	sbci	r21, 0xFF	; 255
    4a90:	be 01       	movw	r22, r28
    4a92:	6f 5f       	subi	r22, 0xFF	; 255
    4a94:	7f 4f       	sbci	r23, 0xFF	; 255
    4a96:	80 e0       	ldi	r24, 0x00	; 0
    4a98:	e6 d0       	rcall	.+460    	; 0x4c66 <simple_p_send>
	}
}
    4a9a:	cc 59       	subi	r28, 0x9C	; 156
    4a9c:	df 4f       	sbci	r29, 0xFF	; 255
    4a9e:	0f b6       	in	r0, 0x3f	; 63
    4aa0:	f8 94       	cli
    4aa2:	de bf       	out	0x3e, r29	; 62
    4aa4:	0f be       	out	0x3f, r0	; 63
    4aa6:	cd bf       	out	0x3d, r28	; 61
    4aa8:	df 91       	pop	r29
    4aaa:	cf 91       	pop	r28
    4aac:	08 95       	ret

00004aae <send_ping_response>:

void send_ping_response(void) {
    4aae:	cf 93       	push	r28
    4ab0:	df 93       	push	r29
    4ab2:	1f 92       	push	r1
    4ab4:	cd b7       	in	r28, 0x3d	; 61
    4ab6:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    4ab8:	80 91 25 1a 	lds	r24, 0x1A25	; 0x801a25 <connected>
    4abc:	88 23       	and	r24, r24
    4abe:	b9 f0       	breq	.+46     	; 0x4aee <send_ping_response+0x40>
  uint8_t status = TYPE_PING_RESPONSE;
    4ac0:	89 e0       	ldi	r24, 0x09	; 9
    4ac2:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
    4ac4:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <use_arq+0x9>
    4ac8:	88 23       	and	r24, r24
    4aca:	51 f0       	breq	.+20     	; 0x4ae0 <send_ping_response+0x32>
    4acc:	41 e0       	ldi	r20, 0x01	; 1
    4ace:	50 e0       	ldi	r21, 0x00	; 0
    4ad0:	be 01       	movw	r22, r28
    4ad2:	6f 5f       	subi	r22, 0xFF	; 255
    4ad4:	7f 4f       	sbci	r23, 0xFF	; 255
    4ad6:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4ada:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4ade:	07 c0       	rjmp	.+14     	; 0x4aee <send_ping_response+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    4ae0:	41 e0       	ldi	r20, 0x01	; 1
    4ae2:	50 e0       	ldi	r21, 0x00	; 0
    4ae4:	be 01       	movw	r22, r28
    4ae6:	6f 5f       	subi	r22, 0xFF	; 255
    4ae8:	7f 4f       	sbci	r23, 0xFF	; 255
    4aea:	80 e0       	ldi	r24, 0x00	; 0
    4aec:	bc d0       	rcall	.+376    	; 0x4c66 <simple_p_send>
}
    4aee:	0f 90       	pop	r0
    4af0:	df 91       	pop	r29
    4af2:	cf 91       	pop	r28
    4af4:	08 95       	ret

00004af6 <vServo_setAngle>:

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
	//debug("vServo_setAngle: %i", ServoAngleDeg);
	/* Ensure feasible values */
	if (ServoAngleDeg >= 90){
    4af6:	8a 35       	cpi	r24, 0x5A	; 90
    4af8:	38 f0       	brcs	.+14     	; 0x4b08 <vServo_setAngle+0x12>
		ServoAngleDeg = 90;
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    4afa:	80 e9       	ldi	r24, 0x90	; 144
    4afc:	9b e0       	ldi	r25, 0x0B	; 11
    4afe:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    4b02:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    4b06:	08 95       	ret
	}
	else if(ServoAngleDeg <= 0){
    4b08:	81 11       	cpse	r24, r1
    4b0a:	07 c0       	rjmp	.+14     	; 0x4b1a <vServo_setAngle+0x24>
		ServoAngleDeg = 0;
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    4b0c:	8d e2       	ldi	r24, 0x2D	; 45
    4b0e:	95 e0       	ldi	r25, 0x05	; 5
    4b10:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    4b14:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    4b18:	08 95       	ret
	}
	else if (ServoAngleDeg>0 && ServoAngleDeg<90)
    4b1a:	9f ef       	ldi	r25, 0xFF	; 255
    4b1c:	98 0f       	add	r25, r24
    4b1e:	99 35       	cpi	r25, 0x59	; 89
    4b20:	60 f4       	brcc	.+24     	; 0x4b3a <vServo_setAngle+0x44>
	{
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    4b22:	e8 2f       	mov	r30, r24
    4b24:	f0 e0       	ldi	r31, 0x00	; 0
    4b26:	ee 0f       	add	r30, r30
    4b28:	ff 1f       	adc	r31, r31
    4b2a:	e8 56       	subi	r30, 0x68	; 104
    4b2c:	f9 4f       	sbci	r31, 0xF9	; 249
    4b2e:	80 81       	ld	r24, Z
    4b30:	91 81       	ldd	r25, Z+1	; 0x01
    4b32:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    4b36:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    4b3a:	08 95       	ret

00004b3c <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
	/* Clear OCnA/OCnB on Compare Match, set */
	/* OCnA/OCnB at BOTTOM (non-inverting mode) */
	/* Datasheet p.155 Table 17-4 */
	TCCR4A |= (1<<COM4B1) | (0<<COM4B0);
    4b3c:	a0 ea       	ldi	r26, 0xA0	; 160
    4b3e:	b0 e0       	ldi	r27, 0x00	; 0
    4b40:	9c 91       	ld	r25, X
    4b42:	90 62       	ori	r25, 0x20	; 32
    4b44:	9c 93       	st	X, r25
	
	/* Waveform generation mode 14: Fast PWM */
	/* top: ICRn, Update bottom, flag set on top */
	/* Datasheet p.145 Table 17-2 */
	
	TCCR4B |= (1<<WGM43) | (1<<WGM42);
    4b46:	e1 ea       	ldi	r30, 0xA1	; 161
    4b48:	f0 e0       	ldi	r31, 0x00	; 0
    4b4a:	90 81       	ld	r25, Z
    4b4c:	98 61       	ori	r25, 0x18	; 24
    4b4e:	90 83       	st	Z, r25
	TCCR4A |= (1<<WGM41) | (0<<WGM40);
    4b50:	9c 91       	ld	r25, X
    4b52:	92 60       	ori	r25, 0x02	; 2
    4b54:	9c 93       	st	X, r25

	/* Clock select bit description: */
	/* clkI/O/8 (From prescaler) - Datasheet p.157 Table 17-6*/

	TCCR4B |= (0<<CS42) | (1<<CS41) | (0<<CS40);
    4b56:	90 81       	ld	r25, Z
    4b58:	92 60       	ori	r25, 0x02	; 2
    4b5a:	90 83       	st	Z, r25
	
	/* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
	/* Datasheet p.125 */
	ICR4 = 39999; // 49999 for 20mhz, 39 999 for 16Mhz
    4b5c:	2f e3       	ldi	r18, 0x3F	; 63
    4b5e:	3c e9       	ldi	r19, 0x9C	; 156
    4b60:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>
    4b64:	20 93 a6 00 	sts	0x00A6, r18	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
	
	/*Port H Pin 7 as servo PWM Output (OC4B)*/
	servoReg |= (1<<servoPin);
    4b68:	e1 e0       	ldi	r30, 0x01	; 1
    4b6a:	f1 e0       	ldi	r31, 0x01	; 1
    4b6c:	90 81       	ld	r25, Z
    4b6e:	90 61       	ori	r25, 0x10	; 16
    4b70:	90 83       	st	Z, r25
	
	/*  Set angle to desired start angle (usually 0)*/
	vServo_setAngle(servoAngleDeg);
    4b72:	c1 cf       	rjmp	.-126    	; 0x4af6 <vServo_setAngle>
    4b74:	08 95       	ret

00004b76 <simple_p_reassembly>:
  vPortFree(part);
  return 1;
}


void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length) {
    4b76:	ef 92       	push	r14
    4b78:	ff 92       	push	r15
    4b7a:	0f 93       	push	r16
    4b7c:	1f 93       	push	r17
    4b7e:	cf 93       	push	r28
    4b80:	df 93       	push	r29
  uint8_t i;
  uint8_t id = 0xFF;
  uint8_t free = 0xFF;
  for(i=0;i<MAX_MESSAGES;i++) {
    if(messages[i].address == 0xFF && free == 0xFF) free = i;
    4b82:	90 91 27 1a 	lds	r25, 0x1A27	; 0x801a27 <messages+0x1>
    4b86:	9f 3f       	cpi	r25, 0xFF	; 255
    4b88:	11 f0       	breq	.+4      	; 0x4b8e <simple_p_reassembly+0x18>
    else if(messages[i].address == sender) {
    4b8a:	98 13       	cpse	r25, r24
    4b8c:	58 c0       	rjmp	.+176    	; 0x4c3e <simple_p_reassembly+0xc8>
  if(id == 0xFF && free == 0xFF) return; // Not room for any more messages, and none is stored for this address
  else if(id == 0xFF && free != 0xFF) { // Did not find any part messages from this sender, but there is room to store a new one
    id = free; 
  }
    
  if(data[0] == 0) { // First part of a new message
    4b8e:	fb 01       	movw	r30, r22
    4b90:	80 81       	ld	r24, Z
    4b92:	81 11       	cpse	r24, r1
    4b94:	05 c0       	rjmp	.+10     	; 0x4ba0 <simple_p_reassembly+0x2a>
    messages[id].num_received_bytes = 0;
    4b96:	10 92 29 1a 	sts	0x1A29, r1	; 0x801a29 <messages+0x3>
    4b9a:	10 92 28 1a 	sts	0x1A28, r1	; 0x801a28 <messages+0x2>
    4b9e:	0c c0       	rjmp	.+24     	; 0x4bb8 <simple_p_reassembly+0x42>
  } else if(data[0] != messages[id].next_part) {
    4ba0:	90 91 2a 1a 	lds	r25, 0x1A2A	; 0x801a2a <messages+0x4>
    4ba4:	89 17       	cp	r24, r25
    4ba6:	41 f0       	breq	.+16     	; 0x4bb8 <simple_p_reassembly+0x42>
    messages[id].next_part = 0;
    4ba8:	e6 e2       	ldi	r30, 0x26	; 38
    4baa:	fa e1       	ldi	r31, 0x1A	; 26
    4bac:	14 82       	std	Z+4, r1	; 0x04
    messages[id].num_received_bytes = 0;
    4bae:	13 82       	std	Z+3, r1	; 0x03
    4bb0:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    4bb2:	8f ef       	ldi	r24, 0xFF	; 255
    4bb4:	81 83       	std	Z+1, r24	; 0x01
    return;
    4bb6:	43 c0       	rjmp	.+134    	; 0x4c3e <simple_p_reassembly+0xc8>
  }

  if(messages[id].num_received_bytes + (length-2) > MAX_MESSAGE_SIZE) { // Message is larger than what can be handled, discard it
    4bb8:	80 91 28 1a 	lds	r24, 0x1A28	; 0x801a28 <messages+0x2>
    4bbc:	90 91 29 1a 	lds	r25, 0x1A29	; 0x801a29 <messages+0x3>
    4bc0:	9c 01       	movw	r18, r24
    4bc2:	22 50       	subi	r18, 0x02	; 2
    4bc4:	31 09       	sbc	r19, r1
    4bc6:	24 0f       	add	r18, r20
    4bc8:	35 1f       	adc	r19, r21
    4bca:	25 36       	cpi	r18, 0x65	; 101
    4bcc:	31 05       	cpc	r19, r1
    4bce:	40 f0       	brcs	.+16     	; 0x4be0 <simple_p_reassembly+0x6a>
    messages[id].num_received_bytes = 0;
    4bd0:	e6 e2       	ldi	r30, 0x26	; 38
    4bd2:	fa e1       	ldi	r31, 0x1A	; 26
    4bd4:	13 82       	std	Z+3, r1	; 0x03
    4bd6:	12 82       	std	Z+2, r1	; 0x02
    messages[id].next_part = 0;
    4bd8:	14 82       	std	Z+4, r1	; 0x04
    messages[id].address = 0xFF;
    4bda:	8f ef       	ldi	r24, 0xFF	; 255
    4bdc:	81 83       	std	Z+1, r24	; 0x01
    return;
    4bde:	2f c0       	rjmp	.+94     	; 0x4c3e <simple_p_reassembly+0xc8>
    4be0:	8a 01       	movw	r16, r20
    4be2:	eb 01       	movw	r28, r22
  }
  
  messages[id].next_part++;
    4be4:	0f 2e       	mov	r0, r31
    4be6:	f6 e2       	ldi	r31, 0x26	; 38
    4be8:	ef 2e       	mov	r14, r31
    4bea:	fa e1       	ldi	r31, 0x1A	; 26
    4bec:	ff 2e       	mov	r15, r31
    4bee:	f0 2d       	mov	r31, r0
    4bf0:	f7 01       	movw	r30, r14
    4bf2:	24 81       	ldd	r18, Z+4	; 0x04
    4bf4:	2f 5f       	subi	r18, 0xFF	; 255
    4bf6:	24 83       	std	Z+4, r18	; 0x04
  memcpy(messages[id].message+messages[id].num_received_bytes, data+2, length-2);
    4bf8:	42 50       	subi	r20, 0x02	; 2
    4bfa:	51 09       	sbc	r21, r1
    4bfc:	6e 5f       	subi	r22, 0xFE	; 254
    4bfe:	7f 4f       	sbci	r23, 0xFF	; 255
    4c00:	85 5d       	subi	r24, 0xD5	; 213
    4c02:	95 4e       	sbci	r25, 0xE5	; 229
    4c04:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
  messages[id].num_received_bytes += (length-2);
    4c08:	f7 01       	movw	r30, r14
    4c0a:	42 81       	ldd	r20, Z+2	; 0x02
    4c0c:	53 81       	ldd	r21, Z+3	; 0x03
    4c0e:	42 50       	subi	r20, 0x02	; 2
    4c10:	51 09       	sbc	r21, r1
    4c12:	ba 01       	movw	r22, r20
    4c14:	60 0f       	add	r22, r16
    4c16:	71 1f       	adc	r23, r17
    4c18:	73 83       	std	Z+3, r23	; 0x03
    4c1a:	62 83       	std	Z+2, r22	; 0x02
  
  if(data[0] == data[1]) {
    4c1c:	98 81       	ld	r25, Y
    4c1e:	89 81       	ldd	r24, Y+1	; 0x01
    4c20:	98 13       	cpse	r25, r24
    4c22:	0d c0       	rjmp	.+26     	; 0x4c3e <simple_p_reassembly+0xc8>
    callback_data_received(messages[id].message, messages[id].num_received_bytes);
    4c24:	e0 91 c0 1b 	lds	r30, 0x1BC0	; 0x801bc0 <callback_data_received>
    4c28:	f0 91 c1 1b 	lds	r31, 0x1BC1	; 0x801bc1 <callback_data_received+0x1>
    4c2c:	8b e2       	ldi	r24, 0x2B	; 43
    4c2e:	9a e1       	ldi	r25, 0x1A	; 26
    4c30:	19 95       	eicall
    messages[id].num_received_bytes = messages[id].next_part = 0;
    4c32:	f7 01       	movw	r30, r14
    4c34:	14 82       	std	Z+4, r1	; 0x04
    4c36:	13 82       	std	Z+3, r1	; 0x03
    4c38:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    4c3a:	8f ef       	ldi	r24, 0xFF	; 255
    4c3c:	81 83       	std	Z+1, r24	; 0x01
  }
    4c3e:	df 91       	pop	r29
    4c40:	cf 91       	pop	r28
    4c42:	1f 91       	pop	r17
    4c44:	0f 91       	pop	r16
    4c46:	ff 90       	pop	r15
    4c48:	ef 90       	pop	r14
    4c4a:	08 95       	ret

00004c4c <simple_p_init>:
void (*callback_data_received)(uint8_t*, uint16_t); 

void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length);

void simple_p_init(void (*cb)(uint8_t*, uint16_t)) {
  callback_data_received = cb;
    4c4c:	90 93 c1 1b 	sts	0x1BC1, r25	; 0x801bc1 <callback_data_received+0x1>
    4c50:	80 93 c0 1b 	sts	0x1BC0, r24	; 0x801bc0 <callback_data_received>
  uint8_t i;
  network_set_callback(PROTOCOL_SIMPLE, simple_p_reassembly);
    4c54:	6b eb       	ldi	r22, 0xBB	; 187
    4c56:	75 e2       	ldi	r23, 0x25	; 37
    4c58:	80 e0       	ldi	r24, 0x00	; 0
    4c5a:	0e 94 36 1b 	call	0x366c	; 0x366c <network_set_callback>
  for(i=0;i<MAX_MESSAGES;i++) {
    messages[i].address = 0xFF;
    4c5e:	8f ef       	ldi	r24, 0xFF	; 255
    4c60:	80 93 27 1a 	sts	0x1A27, r24	; 0x801a27 <messages+0x1>
    4c64:	08 95       	ret

00004c66 <simple_p_send>:
  }
}

uint8_t simple_p_send(uint8_t address, uint8_t *data, uint16_t length) {  
    4c66:	5f 92       	push	r5
    4c68:	6f 92       	push	r6
    4c6a:	7f 92       	push	r7
    4c6c:	8f 92       	push	r8
    4c6e:	9f 92       	push	r9
    4c70:	af 92       	push	r10
    4c72:	bf 92       	push	r11
    4c74:	cf 92       	push	r12
    4c76:	df 92       	push	r13
    4c78:	ef 92       	push	r14
    4c7a:	ff 92       	push	r15
    4c7c:	0f 93       	push	r16
    4c7e:	1f 93       	push	r17
    4c80:	cf 93       	push	r28
    4c82:	df 93       	push	r29
    4c84:	58 2e       	mov	r5, r24
    4c86:	5b 01       	movw	r10, r22
    4c88:	8a 01       	movw	r16, r20
  uint16_t tmp;
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
    4c8a:	8c e2       	ldi	r24, 0x2C	; 44
    4c8c:	90 e0       	ldi	r25, 0x00	; 0
    4c8e:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4c92:	7c 01       	movw	r14, r24
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
    4c94:	98 01       	movw	r18, r16
    4c96:	36 95       	lsr	r19
    4c98:	27 95       	ror	r18
    4c9a:	ad e0       	ldi	r26, 0x0D	; 13
    4c9c:	b3 ec       	ldi	r27, 0xC3	; 195
    4c9e:	0e 94 0a 3b 	call	0x7614	; 0x7614 <__umulhisi3>
    4ca2:	92 95       	swap	r25
    4ca4:	82 95       	swap	r24
    4ca6:	8f 70       	andi	r24, 0x0F	; 15
    4ca8:	89 27       	eor	r24, r25
    4caa:	9f 70       	andi	r25, 0x0F	; 15
    4cac:	89 27       	eor	r24, r25
    4cae:	4a e2       	ldi	r20, 0x2A	; 42
    4cb0:	48 9f       	mul	r20, r24
    4cb2:	90 01       	movw	r18, r0
    4cb4:	49 9f       	mul	r20, r25
    4cb6:	30 0d       	add	r19, r0
    4cb8:	11 24       	eor	r1, r1
    4cba:	41 e0       	ldi	r20, 0x01	; 1
    4cbc:	02 17       	cp	r16, r18
    4cbe:	13 07       	cpc	r17, r19
    4cc0:	09 f4       	brne	.+2      	; 0x4cc4 <simple_p_send+0x5e>
    4cc2:	40 e0       	ldi	r20, 0x00	; 0
    4cc4:	98 01       	movw	r18, r16
    4cc6:	36 95       	lsr	r19
    4cc8:	27 95       	ror	r18
    4cca:	ad e0       	ldi	r26, 0x0D	; 13
    4ccc:	b3 ec       	ldi	r27, 0xC3	; 195
    4cce:	0e 94 0a 3b 	call	0x7614	; 0x7614 <__umulhisi3>
    4cd2:	92 95       	swap	r25
    4cd4:	82 95       	swap	r24
    4cd6:	8f 70       	andi	r24, 0x0F	; 15
    4cd8:	89 27       	eor	r24, r25
    4cda:	9f 70       	andi	r25, 0x0F	; 15
    4cdc:	89 27       	eor	r24, r25
    4cde:	84 0f       	add	r24, r20
  while(remaining > 0) {
    4ce0:	01 15       	cp	r16, r1
    4ce2:	11 05       	cpc	r17, r1
    4ce4:	59 f1       	breq	.+86     	; 0x4d3c <simple_p_send+0xd6>
    4ce6:	90 e0       	ldi	r25, 0x00	; 0
    4ce8:	c1 2c       	mov	r12, r1
    4cea:	d1 2c       	mov	r13, r1
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    part[1] = number_of_parts-1;
    4cec:	66 24       	eor	r6, r6
    4cee:	6a 94       	dec	r6
    4cf0:	68 0e       	add	r6, r24
    memcpy(part+2, data+offset, tmp);
    4cf2:	47 01       	movw	r8, r14
    4cf4:	82 e0       	ldi	r24, 0x02	; 2
    4cf6:	88 0e       	add	r8, r24
    4cf8:	91 1c       	adc	r9, r1
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    4cfa:	e8 01       	movw	r28, r16
    4cfc:	0b 32       	cpi	r16, 0x2B	; 43
    4cfe:	11 05       	cpc	r17, r1
    4d00:	10 f0       	brcs	.+4      	; 0x4d06 <simple_p_send+0xa0>
    4d02:	ca e2       	ldi	r28, 0x2A	; 42
    4d04:	d0 e0       	ldi	r29, 0x00	; 0
    part[0] = part_number++;
    4d06:	77 24       	eor	r7, r7
    4d08:	73 94       	inc	r7
    4d0a:	79 0e       	add	r7, r25
    4d0c:	f7 01       	movw	r30, r14
    4d0e:	90 83       	st	Z, r25
    part[1] = number_of_parts-1;
    4d10:	61 82       	std	Z+1, r6	; 0x01
    memcpy(part+2, data+offset, tmp);
    4d12:	b5 01       	movw	r22, r10
    4d14:	6c 0d       	add	r22, r12
    4d16:	7d 1d       	adc	r23, r13
    4d18:	ae 01       	movw	r20, r28
    4d1a:	c4 01       	movw	r24, r8
    4d1c:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    4d20:	9e 01       	movw	r18, r28
    4d22:	2e 5f       	subi	r18, 0xFE	; 254
    4d24:	3f 4f       	sbci	r19, 0xFF	; 255
    4d26:	a7 01       	movw	r20, r14
    4d28:	60 e0       	ldi	r22, 0x00	; 0
    4d2a:	85 2d       	mov	r24, r5
    4d2c:	0e 94 41 1b 	call	0x3682	; 0x3682 <network_send>
    offset += tmp;
    4d30:	cc 0e       	add	r12, r28
    4d32:	dd 1e       	adc	r13, r29
    remaining -= tmp;
    4d34:	0c 1b       	sub	r16, r28
    4d36:	1d 0b       	sbc	r17, r29
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    4d38:	97 2d       	mov	r25, r7
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    4d3a:	f9 f6       	brne	.-66     	; 0x4cfa <simple_p_send+0x94>
    memcpy(part+2, data+offset, tmp);
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    offset += tmp;
    remaining -= tmp;
  }
  vPortFree(part);
    4d3c:	c7 01       	movw	r24, r14
    4d3e:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  return 1;
}
    4d42:	81 e0       	ldi	r24, 0x01	; 1
    4d44:	df 91       	pop	r29
    4d46:	cf 91       	pop	r28
    4d48:	1f 91       	pop	r17
    4d4a:	0f 91       	pop	r16
    4d4c:	ff 90       	pop	r15
    4d4e:	ef 90       	pop	r14
    4d50:	df 90       	pop	r13
    4d52:	cf 90       	pop	r12
    4d54:	bf 90       	pop	r11
    4d56:	af 90       	pop	r10
    4d58:	9f 90       	pop	r9
    4d5a:	8f 90       	pop	r8
    4d5c:	7f 90       	pop	r7
    4d5e:	6f 90       	pop	r6
    4d60:	5f 90       	pop	r5
    4d62:	08 95       	ret

00004d64 <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    4d64:	84 b1       	in	r24, 0x04	; 4
    4d66:	87 60       	ori	r24, 0x07	; 7
    4d68:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    4d6a:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    4d6c:	8c b5       	in	r24, 0x2c	; 44
    4d6e:	81 60       	ori	r24, 0x01	; 1
    4d70:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    4d72:	8c b5       	in	r24, 0x2c	; 44
    4d74:	8c 65       	ori	r24, 0x5C	; 92
    4d76:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    4d78:	8c b5       	in	r24, 0x2c	; 44
    4d7a:	8f 7d       	andi	r24, 0xDF	; 223
    4d7c:	8c bd       	out	0x2c, r24	; 44
    4d7e:	08 95       	ret

00004d80 <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    4d80:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    4d82:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    4d84:	0d b4       	in	r0, 0x2d	; 45
    4d86:	07 fe       	sbrs	r0, 7
    4d88:	fd cf       	rjmp	.-6      	; 0x4d84 <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    4d8a:	8e b5       	in	r24, 0x2e	; 46
}
    4d8c:	08 95       	ret

00004d8e <xTaskGenericCreate>:
    4d8e:	4f 92       	push	r4
    4d90:	5f 92       	push	r5
    4d92:	6f 92       	push	r6
    4d94:	7f 92       	push	r7
    4d96:	8f 92       	push	r8
    4d98:	9f 92       	push	r9
    4d9a:	af 92       	push	r10
    4d9c:	bf 92       	push	r11
    4d9e:	cf 92       	push	r12
    4da0:	df 92       	push	r13
    4da2:	ef 92       	push	r14
    4da4:	ff 92       	push	r15
    4da6:	0f 93       	push	r16
    4da8:	1f 93       	push	r17
    4daa:	cf 93       	push	r28
    4dac:	df 93       	push	r29
    4dae:	4c 01       	movw	r8, r24
    4db0:	eb 01       	movw	r28, r22
    4db2:	5a 01       	movw	r10, r20
    4db4:	29 01       	movw	r4, r18
    4db6:	c1 14       	cp	r12, r1
    4db8:	d1 04       	cpc	r13, r1
    4dba:	39 f4       	brne	.+14     	; 0x4dca <xTaskGenericCreate+0x3c>
    4dbc:	ca 01       	movw	r24, r20
    4dbe:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4dc2:	6c 01       	movw	r12, r24
    4dc4:	89 2b       	or	r24, r25
    4dc6:	09 f4       	brne	.+2      	; 0x4dca <xTaskGenericCreate+0x3c>
    4dc8:	ec c0       	rjmp	.+472    	; 0x4fa2 <xTaskGenericCreate+0x214>
    4dca:	88 e2       	ldi	r24, 0x28	; 40
    4dcc:	90 e0       	ldi	r25, 0x00	; 0
    4dce:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4dd2:	3c 01       	movw	r6, r24
    4dd4:	00 97       	sbiw	r24, 0x00	; 0
    4dd6:	b9 f0       	breq	.+46     	; 0x4e06 <xTaskGenericCreate+0x78>
    4dd8:	fc 01       	movw	r30, r24
    4dda:	d0 8e       	std	Z+24, r13	; 0x18
    4ddc:	c7 8a       	std	Z+23, r12	; 0x17
    4dde:	a5 01       	movw	r20, r10
    4de0:	65 ea       	ldi	r22, 0xA5	; 165
    4de2:	70 e0       	ldi	r23, 0x00	; 0
    4de4:	c6 01       	movw	r24, r12
    4de6:	0e 94 19 3c 	call	0x7832	; 0x7832 <memset>
    4dea:	f1 e0       	ldi	r31, 0x01	; 1
    4dec:	af 1a       	sub	r10, r31
    4dee:	b1 08       	sbc	r11, r1
    4df0:	f3 01       	movw	r30, r6
    4df2:	87 89       	ldd	r24, Z+23	; 0x17
    4df4:	90 8d       	ldd	r25, Z+24	; 0x18
    4df6:	a8 0e       	add	r10, r24
    4df8:	b9 1e       	adc	r11, r25
    4dfa:	88 81       	ld	r24, Y
    4dfc:	81 8f       	std	Z+25, r24	; 0x19
    4dfe:	88 81       	ld	r24, Y
    4e00:	81 11       	cpse	r24, r1
    4e02:	05 c0       	rjmp	.+10     	; 0x4e0e <xTaskGenericCreate+0x80>
    4e04:	14 c0       	rjmp	.+40     	; 0x4e2e <xTaskGenericCreate+0xa0>
    4e06:	c6 01       	movw	r24, r12
    4e08:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    4e0c:	ca c0       	rjmp	.+404    	; 0x4fa2 <xTaskGenericCreate+0x214>
    4e0e:	d3 01       	movw	r26, r6
    4e10:	5a 96       	adiw	r26, 0x1a	; 26
    4e12:	fe 01       	movw	r30, r28
    4e14:	31 96       	adiw	r30, 0x01	; 1
    4e16:	9e 01       	movw	r18, r28
    4e18:	28 5f       	subi	r18, 0xF8	; 248
    4e1a:	3f 4f       	sbci	r19, 0xFF	; 255
    4e1c:	ef 01       	movw	r28, r30
    4e1e:	81 91       	ld	r24, Z+
    4e20:	8d 93       	st	X+, r24
    4e22:	88 81       	ld	r24, Y
    4e24:	88 23       	and	r24, r24
    4e26:	19 f0       	breq	.+6      	; 0x4e2e <xTaskGenericCreate+0xa0>
    4e28:	2e 17       	cp	r18, r30
    4e2a:	3f 07       	cpc	r19, r31
    4e2c:	b9 f7       	brne	.-18     	; 0x4e1c <xTaskGenericCreate+0x8e>
    4e2e:	f3 01       	movw	r30, r6
    4e30:	10 a2       	std	Z+32, r1	; 0x20
    4e32:	10 2f       	mov	r17, r16
    4e34:	06 30       	cpi	r16, 0x06	; 6
    4e36:	08 f0       	brcs	.+2      	; 0x4e3a <xTaskGenericCreate+0xac>
    4e38:	15 e0       	ldi	r17, 0x05	; 5
    4e3a:	f3 01       	movw	r30, r6
    4e3c:	16 8b       	std	Z+22, r17	; 0x16
    4e3e:	11 a3       	std	Z+33, r17	; 0x21
    4e40:	12 a2       	std	Z+34, r1	; 0x22
    4e42:	e3 01       	movw	r28, r6
    4e44:	22 96       	adiw	r28, 0x02	; 2
    4e46:	ce 01       	movw	r24, r28
    4e48:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialiseItem>
    4e4c:	c3 01       	movw	r24, r6
    4e4e:	0c 96       	adiw	r24, 0x0c	; 12
    4e50:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialiseItem>
    4e54:	f3 01       	movw	r30, r6
    4e56:	71 86       	std	Z+9, r7	; 0x09
    4e58:	60 86       	std	Z+8, r6	; 0x08
    4e5a:	86 e0       	ldi	r24, 0x06	; 6
    4e5c:	90 e0       	ldi	r25, 0x00	; 0
    4e5e:	81 1b       	sub	r24, r17
    4e60:	91 09       	sbc	r25, r1
    4e62:	95 87       	std	Z+13, r25	; 0x0d
    4e64:	84 87       	std	Z+12, r24	; 0x0c
    4e66:	73 8a       	std	Z+19, r7	; 0x13
    4e68:	62 8a       	std	Z+18, r6	; 0x12
    4e6a:	13 a2       	std	Z+35, r1	; 0x23
    4e6c:	14 a2       	std	Z+36, r1	; 0x24
    4e6e:	15 a2       	std	Z+37, r1	; 0x25
    4e70:	16 a2       	std	Z+38, r1	; 0x26
    4e72:	17 a2       	std	Z+39, r1	; 0x27
    4e74:	a2 01       	movw	r20, r4
    4e76:	b4 01       	movw	r22, r8
    4e78:	c5 01       	movw	r24, r10
    4e7a:	0e 94 b3 1b 	call	0x3766	; 0x3766 <pxPortInitialiseStack>
    4e7e:	f3 01       	movw	r30, r6
    4e80:	91 83       	std	Z+1, r25	; 0x01
    4e82:	80 83       	st	Z, r24
    4e84:	e1 14       	cp	r14, r1
    4e86:	f1 04       	cpc	r15, r1
    4e88:	19 f0       	breq	.+6      	; 0x4e90 <xTaskGenericCreate+0x102>
    4e8a:	f7 01       	movw	r30, r14
    4e8c:	71 82       	std	Z+1, r7	; 0x01
    4e8e:	60 82       	st	Z, r6
    4e90:	0f b6       	in	r0, 0x3f	; 63
    4e92:	f8 94       	cli
    4e94:	0f 92       	push	r0
    4e96:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    4e9a:	8f 5f       	subi	r24, 0xFF	; 255
    4e9c:	80 93 9a 1a 	sts	0x1A9A, r24	; 0x801a9a <uxCurrentNumberOfTasks>
    4ea0:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    4ea4:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    4ea8:	89 2b       	or	r24, r25
    4eaa:	d9 f5       	brne	.+118    	; 0x4f22 <xTaskGenericCreate+0x194>
    4eac:	70 92 fa 1a 	sts	0x1AFA, r7	; 0x801afa <pxCurrentTCB+0x1>
    4eb0:	60 92 f9 1a 	sts	0x1AF9, r6	; 0x801af9 <pxCurrentTCB>
    4eb4:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    4eb8:	81 30       	cpi	r24, 0x01	; 1
    4eba:	09 f0       	breq	.+2      	; 0x4ebe <xTaskGenericCreate+0x130>
    4ebc:	41 c0       	rjmp	.+130    	; 0x4f40 <xTaskGenericCreate+0x1b2>
    4ebe:	0f 2e       	mov	r0, r31
    4ec0:	f3 ec       	ldi	r31, 0xC3	; 195
    4ec2:	ef 2e       	mov	r14, r31
    4ec4:	fa e1       	ldi	r31, 0x1A	; 26
    4ec6:	ff 2e       	mov	r15, r31
    4ec8:	f0 2d       	mov	r31, r0
    4eca:	0f 2e       	mov	r0, r31
    4ecc:	f9 ef       	ldi	r31, 0xF9	; 249
    4ece:	cf 2e       	mov	r12, r31
    4ed0:	fa e1       	ldi	r31, 0x1A	; 26
    4ed2:	df 2e       	mov	r13, r31
    4ed4:	f0 2d       	mov	r31, r0
    4ed6:	c7 01       	movw	r24, r14
    4ed8:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4edc:	f9 e0       	ldi	r31, 0x09	; 9
    4ede:	ef 0e       	add	r14, r31
    4ee0:	f1 1c       	adc	r15, r1
    4ee2:	ec 14       	cp	r14, r12
    4ee4:	fd 04       	cpc	r15, r13
    4ee6:	b9 f7       	brne	.-18     	; 0x4ed6 <xTaskGenericCreate+0x148>
    4ee8:	8a eb       	ldi	r24, 0xBA	; 186
    4eea:	9a e1       	ldi	r25, 0x1A	; 26
    4eec:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4ef0:	81 eb       	ldi	r24, 0xB1	; 177
    4ef2:	9a e1       	ldi	r25, 0x1A	; 26
    4ef4:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4ef8:	84 ea       	ldi	r24, 0xA4	; 164
    4efa:	9a e1       	ldi	r25, 0x1A	; 26
    4efc:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4f00:	8b e9       	ldi	r24, 0x9B	; 155
    4f02:	9a e1       	ldi	r25, 0x1A	; 26
    4f04:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4f08:	8a eb       	ldi	r24, 0xBA	; 186
    4f0a:	9a e1       	ldi	r25, 0x1A	; 26
    4f0c:	90 93 b0 1a 	sts	0x1AB0, r25	; 0x801ab0 <pxDelayedTaskList+0x1>
    4f10:	80 93 af 1a 	sts	0x1AAF, r24	; 0x801aaf <pxDelayedTaskList>
    4f14:	81 eb       	ldi	r24, 0xB1	; 177
    4f16:	9a e1       	ldi	r25, 0x1A	; 26
    4f18:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    4f1c:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    4f20:	0f c0       	rjmp	.+30     	; 0x4f40 <xTaskGenericCreate+0x1b2>
    4f22:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <xSchedulerRunning>
    4f26:	81 11       	cpse	r24, r1
    4f28:	0b c0       	rjmp	.+22     	; 0x4f40 <xTaskGenericCreate+0x1b2>
    4f2a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    4f2e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    4f32:	86 89       	ldd	r24, Z+22	; 0x16
    4f34:	08 17       	cp	r16, r24
    4f36:	20 f0       	brcs	.+8      	; 0x4f40 <xTaskGenericCreate+0x1b2>
    4f38:	70 92 fa 1a 	sts	0x1AFA, r7	; 0x801afa <pxCurrentTCB+0x1>
    4f3c:	60 92 f9 1a 	sts	0x1AF9, r6	; 0x801af9 <pxCurrentTCB>
    4f40:	80 91 92 1a 	lds	r24, 0x1A92	; 0x801a92 <uxTaskNumber>
    4f44:	8f 5f       	subi	r24, 0xFF	; 255
    4f46:	80 93 92 1a 	sts	0x1A92, r24	; 0x801a92 <uxTaskNumber>
    4f4a:	f3 01       	movw	r30, r6
    4f4c:	86 89       	ldd	r24, Z+22	; 0x16
    4f4e:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    4f52:	98 17       	cp	r25, r24
    4f54:	10 f4       	brcc	.+4      	; 0x4f5a <xTaskGenericCreate+0x1cc>
    4f56:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    4f5a:	90 e0       	ldi	r25, 0x00	; 0
    4f5c:	9c 01       	movw	r18, r24
    4f5e:	22 0f       	add	r18, r18
    4f60:	33 1f       	adc	r19, r19
    4f62:	22 0f       	add	r18, r18
    4f64:	33 1f       	adc	r19, r19
    4f66:	22 0f       	add	r18, r18
    4f68:	33 1f       	adc	r19, r19
    4f6a:	82 0f       	add	r24, r18
    4f6c:	93 1f       	adc	r25, r19
    4f6e:	be 01       	movw	r22, r28
    4f70:	8d 53       	subi	r24, 0x3D	; 61
    4f72:	95 4e       	sbci	r25, 0xE5	; 229
    4f74:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    4f78:	0f 90       	pop	r0
    4f7a:	0f be       	out	0x3f, r0	; 63
    4f7c:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <xSchedulerRunning>
    4f80:	88 23       	and	r24, r24
    4f82:	59 f0       	breq	.+22     	; 0x4f9a <xTaskGenericCreate+0x20c>
    4f84:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    4f88:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    4f8c:	86 89       	ldd	r24, Z+22	; 0x16
    4f8e:	80 17       	cp	r24, r16
    4f90:	30 f4       	brcc	.+12     	; 0x4f9e <xTaskGenericCreate+0x210>
    4f92:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    4f96:	81 e0       	ldi	r24, 0x01	; 1
    4f98:	05 c0       	rjmp	.+10     	; 0x4fa4 <xTaskGenericCreate+0x216>
    4f9a:	81 e0       	ldi	r24, 0x01	; 1
    4f9c:	03 c0       	rjmp	.+6      	; 0x4fa4 <xTaskGenericCreate+0x216>
    4f9e:	81 e0       	ldi	r24, 0x01	; 1
    4fa0:	01 c0       	rjmp	.+2      	; 0x4fa4 <xTaskGenericCreate+0x216>
    4fa2:	8f ef       	ldi	r24, 0xFF	; 255
    4fa4:	df 91       	pop	r29
    4fa6:	cf 91       	pop	r28
    4fa8:	1f 91       	pop	r17
    4faa:	0f 91       	pop	r16
    4fac:	ff 90       	pop	r15
    4fae:	ef 90       	pop	r14
    4fb0:	df 90       	pop	r13
    4fb2:	cf 90       	pop	r12
    4fb4:	bf 90       	pop	r11
    4fb6:	af 90       	pop	r10
    4fb8:	9f 90       	pop	r9
    4fba:	8f 90       	pop	r8
    4fbc:	7f 90       	pop	r7
    4fbe:	6f 90       	pop	r6
    4fc0:	5f 90       	pop	r5
    4fc2:	4f 90       	pop	r4
    4fc4:	08 95       	ret

00004fc6 <vTaskDelayUntil>:
    4fc6:	9f 92       	push	r9
    4fc8:	af 92       	push	r10
    4fca:	bf 92       	push	r11
    4fcc:	cf 92       	push	r12
    4fce:	df 92       	push	r13
    4fd0:	ef 92       	push	r14
    4fd2:	ff 92       	push	r15
    4fd4:	0f 93       	push	r16
    4fd6:	1f 93       	push	r17
    4fd8:	cf 93       	push	r28
    4fda:	df 93       	push	r29
    4fdc:	fc 01       	movw	r30, r24
    4fde:	90 91 8f 1a 	lds	r25, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    4fe2:	9f 5f       	subi	r25, 0xFF	; 255
    4fe4:	90 93 8f 1a 	sts	0x1A8F, r25	; 0x801a8f <uxSchedulerSuspended>
    4fe8:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    4fec:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    4ff0:	20 81       	ld	r18, Z
    4ff2:	31 81       	ldd	r19, Z+1	; 0x01
    4ff4:	e9 01       	movw	r28, r18
    4ff6:	c6 0f       	add	r28, r22
    4ff8:	d7 1f       	adc	r29, r23
    4ffa:	82 17       	cp	r24, r18
    4ffc:	93 07       	cpc	r25, r19
    4ffe:	58 f4       	brcc	.+22     	; 0x5016 <vTaskDelayUntil+0x50>
    5000:	c2 17       	cp	r28, r18
    5002:	d3 07       	cpc	r29, r19
    5004:	08 f0       	brcs	.+2      	; 0x5008 <vTaskDelayUntil+0x42>
    5006:	6e c1       	rjmp	.+732    	; 0x52e4 <vTaskDelayUntil+0x31e>
    5008:	d1 83       	std	Z+1, r29	; 0x01
    500a:	c0 83       	st	Z, r28
    500c:	8c 17       	cp	r24, r28
    500e:	9d 07       	cpc	r25, r29
    5010:	08 f0       	brcs	.+2      	; 0x5014 <vTaskDelayUntil+0x4e>
    5012:	42 c0       	rjmp	.+132    	; 0x5098 <vTaskDelayUntil+0xd2>
    5014:	09 c0       	rjmp	.+18     	; 0x5028 <vTaskDelayUntil+0x62>
    5016:	c2 17       	cp	r28, r18
    5018:	d3 07       	cpc	r29, r19
    501a:	08 f4       	brcc	.+2      	; 0x501e <vTaskDelayUntil+0x58>
    501c:	60 c1       	rjmp	.+704    	; 0x52de <vTaskDelayUntil+0x318>
    501e:	8c 17       	cp	r24, r28
    5020:	9d 07       	cpc	r25, r29
    5022:	08 f4       	brcc	.+2      	; 0x5026 <vTaskDelayUntil+0x60>
    5024:	5c c1       	rjmp	.+696    	; 0x52de <vTaskDelayUntil+0x318>
    5026:	5e c1       	rjmp	.+700    	; 0x52e4 <vTaskDelayUntil+0x31e>
    5028:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    502c:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5030:	02 96       	adiw	r24, 0x02	; 2
    5032:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5036:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    503a:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    503e:	d3 83       	std	Z+3, r29	; 0x03
    5040:	c2 83       	std	Z+2, r28	; 0x02
    5042:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5046:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    504a:	c8 17       	cp	r28, r24
    504c:	d9 07       	cpc	r29, r25
    504e:	68 f4       	brcc	.+26     	; 0x506a <vTaskDelayUntil+0xa4>
    5050:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5054:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5058:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    505c:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5060:	6e 5f       	subi	r22, 0xFE	; 254
    5062:	7f 4f       	sbci	r23, 0xFF	; 255
    5064:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5068:	17 c0       	rjmp	.+46     	; 0x5098 <vTaskDelayUntil+0xd2>
    506a:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    506e:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5072:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5076:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    507a:	6e 5f       	subi	r22, 0xFE	; 254
    507c:	7f 4f       	sbci	r23, 0xFF	; 255
    507e:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5082:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    5086:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    508a:	c8 17       	cp	r28, r24
    508c:	d9 07       	cpc	r29, r25
    508e:	20 f4       	brcc	.+8      	; 0x5098 <vTaskDelayUntil+0xd2>
    5090:	d0 93 91 1a 	sts	0x1A91, r29	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5094:	c0 93 90 1a 	sts	0x1A90, r28	; 0x801a90 <xNextTaskUnblockTime>
    5098:	0f b6       	in	r0, 0x3f	; 63
    509a:	f8 94       	cli
    509c:	0f 92       	push	r0
    509e:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    50a2:	81 50       	subi	r24, 0x01	; 1
    50a4:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <uxSchedulerSuspended>
    50a8:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    50ac:	81 11       	cpse	r24, r1
    50ae:	0d c1       	rjmp	.+538    	; 0x52ca <vTaskDelayUntil+0x304>
    50b0:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    50b4:	81 11       	cpse	r24, r1
    50b6:	33 c0       	rjmp	.+102    	; 0x511e <vTaskDelayUntil+0x158>
    50b8:	0b c1       	rjmp	.+534    	; 0x52d0 <vTaskDelayUntil+0x30a>
    50ba:	d7 01       	movw	r26, r14
    50bc:	15 96       	adiw	r26, 0x05	; 5
    50be:	ed 91       	ld	r30, X+
    50c0:	fc 91       	ld	r31, X
    50c2:	16 97       	sbiw	r26, 0x06	; 6
    50c4:	c6 81       	ldd	r28, Z+6	; 0x06
    50c6:	d7 81       	ldd	r29, Z+7	; 0x07
    50c8:	ce 01       	movw	r24, r28
    50ca:	0c 96       	adiw	r24, 0x0c	; 12
    50cc:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    50d0:	8e 01       	movw	r16, r28
    50d2:	0e 5f       	subi	r16, 0xFE	; 254
    50d4:	1f 4f       	sbci	r17, 0xFF	; 255
    50d6:	c8 01       	movw	r24, r16
    50d8:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    50dc:	8e 89       	ldd	r24, Y+22	; 0x16
    50de:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    50e2:	98 17       	cp	r25, r24
    50e4:	10 f4       	brcc	.+4      	; 0x50ea <vTaskDelayUntil+0x124>
    50e6:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    50ea:	90 e0       	ldi	r25, 0x00	; 0
    50ec:	9c 01       	movw	r18, r24
    50ee:	22 0f       	add	r18, r18
    50f0:	33 1f       	adc	r19, r19
    50f2:	22 0f       	add	r18, r18
    50f4:	33 1f       	adc	r19, r19
    50f6:	22 0f       	add	r18, r18
    50f8:	33 1f       	adc	r19, r19
    50fa:	82 0f       	add	r24, r18
    50fc:	93 1f       	adc	r25, r19
    50fe:	b8 01       	movw	r22, r16
    5100:	8d 53       	subi	r24, 0x3D	; 61
    5102:	95 4e       	sbci	r25, 0xE5	; 229
    5104:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5108:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    510c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5110:	9e 89       	ldd	r25, Y+22	; 0x16
    5112:	86 89       	ldd	r24, Z+22	; 0x16
    5114:	98 17       	cp	r25, r24
    5116:	58 f0       	brcs	.+22     	; 0x512e <vTaskDelayUntil+0x168>
    5118:	d0 92 94 1a 	sts	0x1A94, r13	; 0x801a94 <xYieldPending>
    511c:	08 c0       	rjmp	.+16     	; 0x512e <vTaskDelayUntil+0x168>
    511e:	0f 2e       	mov	r0, r31
    5120:	f4 ea       	ldi	r31, 0xA4	; 164
    5122:	ef 2e       	mov	r14, r31
    5124:	fa e1       	ldi	r31, 0x1A	; 26
    5126:	ff 2e       	mov	r15, r31
    5128:	f0 2d       	mov	r31, r0
    512a:	dd 24       	eor	r13, r13
    512c:	d3 94       	inc	r13
    512e:	f7 01       	movw	r30, r14
    5130:	80 81       	ld	r24, Z
    5132:	81 11       	cpse	r24, r1
    5134:	c2 cf       	rjmp	.-124    	; 0x50ba <vTaskDelayUntil+0xf4>
    5136:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    513a:	88 23       	and	r24, r24
    513c:	09 f4       	brne	.+2      	; 0x5140 <vTaskDelayUntil+0x17a>
    513e:	bd c0       	rjmp	.+378    	; 0x52ba <vTaskDelayUntil+0x2f4>
    5140:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5144:	88 23       	and	r24, r24
    5146:	09 f4       	brne	.+2      	; 0x514a <vTaskDelayUntil+0x184>
    5148:	b8 c0       	rjmp	.+368    	; 0x52ba <vTaskDelayUntil+0x2f4>
    514a:	91 2c       	mov	r9, r1
    514c:	bb 24       	eor	r11, r11
    514e:	b3 94       	inc	r11
    5150:	cc 24       	eor	r12, r12
    5152:	ca 94       	dec	r12
    5154:	dc 2c       	mov	r13, r12
    5156:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    515a:	81 11       	cpse	r24, r1
    515c:	98 c0       	rjmp	.+304    	; 0x528e <vTaskDelayUntil+0x2c8>
    515e:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5162:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5166:	01 96       	adiw	r24, 0x01	; 1
    5168:	90 93 99 1a 	sts	0x1A99, r25	; 0x801a99 <xTickCount+0x1>
    516c:	80 93 98 1a 	sts	0x1A98, r24	; 0x801a98 <xTickCount>
    5170:	e0 90 98 1a 	lds	r14, 0x1A98	; 0x801a98 <xTickCount>
    5174:	f0 90 99 1a 	lds	r15, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5178:	e1 14       	cp	r14, r1
    517a:	f1 04       	cpc	r15, r1
    517c:	89 f5       	brne	.+98     	; 0x51e0 <vTaskDelayUntil+0x21a>
    517e:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5182:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5186:	20 91 ad 1a 	lds	r18, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    518a:	30 91 ae 1a 	lds	r19, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    518e:	30 93 b0 1a 	sts	0x1AB0, r19	; 0x801ab0 <pxDelayedTaskList+0x1>
    5192:	20 93 af 1a 	sts	0x1AAF, r18	; 0x801aaf <pxDelayedTaskList>
    5196:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    519a:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    519e:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    51a2:	8f 5f       	subi	r24, 0xFF	; 255
    51a4:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <xNumOfOverflows>
    51a8:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    51ac:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    51b0:	80 81       	ld	r24, Z
    51b2:	81 11       	cpse	r24, r1
    51b4:	05 c0       	rjmp	.+10     	; 0x51c0 <vTaskDelayUntil+0x1fa>
    51b6:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    51ba:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    51be:	10 c0       	rjmp	.+32     	; 0x51e0 <vTaskDelayUntil+0x21a>
    51c0:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    51c4:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    51c8:	05 80       	ldd	r0, Z+5	; 0x05
    51ca:	f6 81       	ldd	r31, Z+6	; 0x06
    51cc:	e0 2d       	mov	r30, r0
    51ce:	06 80       	ldd	r0, Z+6	; 0x06
    51d0:	f7 81       	ldd	r31, Z+7	; 0x07
    51d2:	e0 2d       	mov	r30, r0
    51d4:	82 81       	ldd	r24, Z+2	; 0x02
    51d6:	93 81       	ldd	r25, Z+3	; 0x03
    51d8:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    51dc:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    51e0:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    51e4:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    51e8:	e8 16       	cp	r14, r24
    51ea:	f9 06       	cpc	r15, r25
    51ec:	08 f4       	brcc	.+2      	; 0x51f0 <vTaskDelayUntil+0x22a>
    51ee:	7d c0       	rjmp	.+250    	; 0x52ea <vTaskDelayUntil+0x324>
    51f0:	a9 2c       	mov	r10, r9
    51f2:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    51f6:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    51fa:	80 81       	ld	r24, Z
    51fc:	81 11       	cpse	r24, r1
    51fe:	05 c0       	rjmp	.+10     	; 0x520a <vTaskDelayUntil+0x244>
    5200:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5204:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    5208:	48 c0       	rjmp	.+144    	; 0x529a <vTaskDelayUntil+0x2d4>
    520a:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    520e:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5212:	05 80       	ldd	r0, Z+5	; 0x05
    5214:	f6 81       	ldd	r31, Z+6	; 0x06
    5216:	e0 2d       	mov	r30, r0
    5218:	c6 81       	ldd	r28, Z+6	; 0x06
    521a:	d7 81       	ldd	r29, Z+7	; 0x07
    521c:	8a 81       	ldd	r24, Y+2	; 0x02
    521e:	9b 81       	ldd	r25, Y+3	; 0x03
    5220:	e8 16       	cp	r14, r24
    5222:	f9 06       	cpc	r15, r25
    5224:	28 f4       	brcc	.+10     	; 0x5230 <vTaskDelayUntil+0x26a>
    5226:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    522a:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    522e:	35 c0       	rjmp	.+106    	; 0x529a <vTaskDelayUntil+0x2d4>
    5230:	8e 01       	movw	r16, r28
    5232:	0e 5f       	subi	r16, 0xFE	; 254
    5234:	1f 4f       	sbci	r17, 0xFF	; 255
    5236:	c8 01       	movw	r24, r16
    5238:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    523c:	8c 89       	ldd	r24, Y+20	; 0x14
    523e:	9d 89       	ldd	r25, Y+21	; 0x15
    5240:	89 2b       	or	r24, r25
    5242:	21 f0       	breq	.+8      	; 0x524c <vTaskDelayUntil+0x286>
    5244:	ce 01       	movw	r24, r28
    5246:	0c 96       	adiw	r24, 0x0c	; 12
    5248:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    524c:	8e 89       	ldd	r24, Y+22	; 0x16
    524e:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5252:	98 17       	cp	r25, r24
    5254:	10 f4       	brcc	.+4      	; 0x525a <vTaskDelayUntil+0x294>
    5256:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    525a:	90 e0       	ldi	r25, 0x00	; 0
    525c:	9c 01       	movw	r18, r24
    525e:	22 0f       	add	r18, r18
    5260:	33 1f       	adc	r19, r19
    5262:	22 0f       	add	r18, r18
    5264:	33 1f       	adc	r19, r19
    5266:	22 0f       	add	r18, r18
    5268:	33 1f       	adc	r19, r19
    526a:	82 0f       	add	r24, r18
    526c:	93 1f       	adc	r25, r19
    526e:	b8 01       	movw	r22, r16
    5270:	8d 53       	subi	r24, 0x3D	; 61
    5272:	95 4e       	sbci	r25, 0xE5	; 229
    5274:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5278:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    527c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5280:	9e 89       	ldd	r25, Y+22	; 0x16
    5282:	86 89       	ldd	r24, Z+22	; 0x16
    5284:	98 17       	cp	r25, r24
    5286:	08 f4       	brcc	.+2      	; 0x528a <vTaskDelayUntil+0x2c4>
    5288:	b4 cf       	rjmp	.-152    	; 0x51f2 <vTaskDelayUntil+0x22c>
    528a:	ab 2c       	mov	r10, r11
    528c:	b2 cf       	rjmp	.-156    	; 0x51f2 <vTaskDelayUntil+0x22c>
    528e:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5292:	8f 5f       	subi	r24, 0xFF	; 255
    5294:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    5298:	28 c0       	rjmp	.+80     	; 0x52ea <vTaskDelayUntil+0x324>
    529a:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    529e:	81 11       	cpse	r24, r1
    52a0:	01 c0       	rjmp	.+2      	; 0x52a4 <vTaskDelayUntil+0x2de>
    52a2:	a1 10       	cpse	r10, r1
    52a4:	b0 92 94 1a 	sts	0x1A94, r11	; 0x801a94 <xYieldPending>
    52a8:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    52ac:	81 50       	subi	r24, 0x01	; 1
    52ae:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    52b2:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    52b6:	81 11       	cpse	r24, r1
    52b8:	4e cf       	rjmp	.-356    	; 0x5156 <vTaskDelayUntil+0x190>
    52ba:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    52be:	81 30       	cpi	r24, 0x01	; 1
    52c0:	31 f4       	brne	.+12     	; 0x52ce <vTaskDelayUntil+0x308>
    52c2:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    52c6:	81 e0       	ldi	r24, 0x01	; 1
    52c8:	03 c0       	rjmp	.+6      	; 0x52d0 <vTaskDelayUntil+0x30a>
    52ca:	80 e0       	ldi	r24, 0x00	; 0
    52cc:	01 c0       	rjmp	.+2      	; 0x52d0 <vTaskDelayUntil+0x30a>
    52ce:	80 e0       	ldi	r24, 0x00	; 0
    52d0:	0f 90       	pop	r0
    52d2:	0f be       	out	0x3f, r0	; 63
    52d4:	81 11       	cpse	r24, r1
    52d6:	0e c0       	rjmp	.+28     	; 0x52f4 <vTaskDelayUntil+0x32e>
    52d8:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    52dc:	0b c0       	rjmp	.+22     	; 0x52f4 <vTaskDelayUntil+0x32e>
    52de:	d1 83       	std	Z+1, r29	; 0x01
    52e0:	c0 83       	st	Z, r28
    52e2:	a2 ce       	rjmp	.-700    	; 0x5028 <vTaskDelayUntil+0x62>
    52e4:	d1 83       	std	Z+1, r29	; 0x01
    52e6:	c0 83       	st	Z, r28
    52e8:	d7 ce       	rjmp	.-594    	; 0x5098 <vTaskDelayUntil+0xd2>
    52ea:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    52ee:	81 11       	cpse	r24, r1
    52f0:	d9 cf       	rjmp	.-78     	; 0x52a4 <vTaskDelayUntil+0x2de>
    52f2:	da cf       	rjmp	.-76     	; 0x52a8 <vTaskDelayUntil+0x2e2>
    52f4:	df 91       	pop	r29
    52f6:	cf 91       	pop	r28
    52f8:	1f 91       	pop	r17
    52fa:	0f 91       	pop	r16
    52fc:	ff 90       	pop	r15
    52fe:	ef 90       	pop	r14
    5300:	df 90       	pop	r13
    5302:	cf 90       	pop	r12
    5304:	bf 90       	pop	r11
    5306:	af 90       	pop	r10
    5308:	9f 90       	pop	r9
    530a:	08 95       	ret

0000530c <vTaskDelay>:
    530c:	9f 92       	push	r9
    530e:	af 92       	push	r10
    5310:	bf 92       	push	r11
    5312:	cf 92       	push	r12
    5314:	df 92       	push	r13
    5316:	ef 92       	push	r14
    5318:	ff 92       	push	r15
    531a:	0f 93       	push	r16
    531c:	1f 93       	push	r17
    531e:	cf 93       	push	r28
    5320:	df 93       	push	r29
    5322:	00 97       	sbiw	r24, 0x00	; 0
    5324:	09 f4       	brne	.+2      	; 0x5328 <vTaskDelay+0x1c>
    5326:	63 c1       	rjmp	.+710    	; 0x55ee <vTaskDelay+0x2e2>
    5328:	20 91 8f 1a 	lds	r18, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    532c:	2f 5f       	subi	r18, 0xFF	; 255
    532e:	20 93 8f 1a 	sts	0x1A8F, r18	; 0x801a8f <uxSchedulerSuspended>
    5332:	c0 91 98 1a 	lds	r28, 0x1A98	; 0x801a98 <xTickCount>
    5336:	d0 91 99 1a 	lds	r29, 0x1A99	; 0x801a99 <xTickCount+0x1>
    533a:	c8 0f       	add	r28, r24
    533c:	d9 1f       	adc	r29, r25
    533e:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5342:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5346:	02 96       	adiw	r24, 0x02	; 2
    5348:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    534c:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5350:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5354:	d3 83       	std	Z+3, r29	; 0x03
    5356:	c2 83       	std	Z+2, r28	; 0x02
    5358:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    535c:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5360:	c8 17       	cp	r28, r24
    5362:	d9 07       	cpc	r29, r25
    5364:	68 f4       	brcc	.+26     	; 0x5380 <vTaskDelay+0x74>
    5366:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    536a:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    536e:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    5372:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5376:	6e 5f       	subi	r22, 0xFE	; 254
    5378:	7f 4f       	sbci	r23, 0xFF	; 255
    537a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    537e:	17 c0       	rjmp	.+46     	; 0x53ae <vTaskDelay+0xa2>
    5380:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5384:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5388:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    538c:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5390:	6e 5f       	subi	r22, 0xFE	; 254
    5392:	7f 4f       	sbci	r23, 0xFF	; 255
    5394:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5398:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    539c:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    53a0:	c8 17       	cp	r28, r24
    53a2:	d9 07       	cpc	r29, r25
    53a4:	20 f4       	brcc	.+8      	; 0x53ae <vTaskDelay+0xa2>
    53a6:	d0 93 91 1a 	sts	0x1A91, r29	; 0x801a91 <xNextTaskUnblockTime+0x1>
    53aa:	c0 93 90 1a 	sts	0x1A90, r28	; 0x801a90 <xNextTaskUnblockTime>
    53ae:	0f b6       	in	r0, 0x3f	; 63
    53b0:	f8 94       	cli
    53b2:	0f 92       	push	r0
    53b4:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    53b8:	81 50       	subi	r24, 0x01	; 1
    53ba:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <uxSchedulerSuspended>
    53be:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    53c2:	81 11       	cpse	r24, r1
    53c4:	0d c1       	rjmp	.+538    	; 0x55e0 <vTaskDelay+0x2d4>
    53c6:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    53ca:	81 11       	cpse	r24, r1
    53cc:	33 c0       	rjmp	.+102    	; 0x5434 <vTaskDelay+0x128>
    53ce:	0b c1       	rjmp	.+534    	; 0x55e6 <vTaskDelay+0x2da>
    53d0:	d7 01       	movw	r26, r14
    53d2:	15 96       	adiw	r26, 0x05	; 5
    53d4:	ed 91       	ld	r30, X+
    53d6:	fc 91       	ld	r31, X
    53d8:	16 97       	sbiw	r26, 0x06	; 6
    53da:	c6 81       	ldd	r28, Z+6	; 0x06
    53dc:	d7 81       	ldd	r29, Z+7	; 0x07
    53de:	ce 01       	movw	r24, r28
    53e0:	0c 96       	adiw	r24, 0x0c	; 12
    53e2:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    53e6:	8e 01       	movw	r16, r28
    53e8:	0e 5f       	subi	r16, 0xFE	; 254
    53ea:	1f 4f       	sbci	r17, 0xFF	; 255
    53ec:	c8 01       	movw	r24, r16
    53ee:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    53f2:	8e 89       	ldd	r24, Y+22	; 0x16
    53f4:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    53f8:	98 17       	cp	r25, r24
    53fa:	10 f4       	brcc	.+4      	; 0x5400 <vTaskDelay+0xf4>
    53fc:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5400:	90 e0       	ldi	r25, 0x00	; 0
    5402:	9c 01       	movw	r18, r24
    5404:	22 0f       	add	r18, r18
    5406:	33 1f       	adc	r19, r19
    5408:	22 0f       	add	r18, r18
    540a:	33 1f       	adc	r19, r19
    540c:	22 0f       	add	r18, r18
    540e:	33 1f       	adc	r19, r19
    5410:	82 0f       	add	r24, r18
    5412:	93 1f       	adc	r25, r19
    5414:	b8 01       	movw	r22, r16
    5416:	8d 53       	subi	r24, 0x3D	; 61
    5418:	95 4e       	sbci	r25, 0xE5	; 229
    541a:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    541e:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5422:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5426:	9e 89       	ldd	r25, Y+22	; 0x16
    5428:	86 89       	ldd	r24, Z+22	; 0x16
    542a:	98 17       	cp	r25, r24
    542c:	58 f0       	brcs	.+22     	; 0x5444 <vTaskDelay+0x138>
    542e:	d0 92 94 1a 	sts	0x1A94, r13	; 0x801a94 <xYieldPending>
    5432:	08 c0       	rjmp	.+16     	; 0x5444 <vTaskDelay+0x138>
    5434:	0f 2e       	mov	r0, r31
    5436:	f4 ea       	ldi	r31, 0xA4	; 164
    5438:	ef 2e       	mov	r14, r31
    543a:	fa e1       	ldi	r31, 0x1A	; 26
    543c:	ff 2e       	mov	r15, r31
    543e:	f0 2d       	mov	r31, r0
    5440:	dd 24       	eor	r13, r13
    5442:	d3 94       	inc	r13
    5444:	f7 01       	movw	r30, r14
    5446:	80 81       	ld	r24, Z
    5448:	81 11       	cpse	r24, r1
    544a:	c2 cf       	rjmp	.-124    	; 0x53d0 <vTaskDelay+0xc4>
    544c:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5450:	88 23       	and	r24, r24
    5452:	09 f4       	brne	.+2      	; 0x5456 <vTaskDelay+0x14a>
    5454:	bd c0       	rjmp	.+378    	; 0x55d0 <vTaskDelay+0x2c4>
    5456:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    545a:	88 23       	and	r24, r24
    545c:	09 f4       	brne	.+2      	; 0x5460 <vTaskDelay+0x154>
    545e:	b8 c0       	rjmp	.+368    	; 0x55d0 <vTaskDelay+0x2c4>
    5460:	91 2c       	mov	r9, r1
    5462:	bb 24       	eor	r11, r11
    5464:	b3 94       	inc	r11
    5466:	cc 24       	eor	r12, r12
    5468:	ca 94       	dec	r12
    546a:	dc 2c       	mov	r13, r12
    546c:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5470:	81 11       	cpse	r24, r1
    5472:	98 c0       	rjmp	.+304    	; 0x55a4 <vTaskDelay+0x298>
    5474:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5478:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    547c:	01 96       	adiw	r24, 0x01	; 1
    547e:	90 93 99 1a 	sts	0x1A99, r25	; 0x801a99 <xTickCount+0x1>
    5482:	80 93 98 1a 	sts	0x1A98, r24	; 0x801a98 <xTickCount>
    5486:	e0 90 98 1a 	lds	r14, 0x1A98	; 0x801a98 <xTickCount>
    548a:	f0 90 99 1a 	lds	r15, 0x1A99	; 0x801a99 <xTickCount+0x1>
    548e:	e1 14       	cp	r14, r1
    5490:	f1 04       	cpc	r15, r1
    5492:	89 f5       	brne	.+98     	; 0x54f6 <vTaskDelay+0x1ea>
    5494:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5498:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    549c:	20 91 ad 1a 	lds	r18, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    54a0:	30 91 ae 1a 	lds	r19, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    54a4:	30 93 b0 1a 	sts	0x1AB0, r19	; 0x801ab0 <pxDelayedTaskList+0x1>
    54a8:	20 93 af 1a 	sts	0x1AAF, r18	; 0x801aaf <pxDelayedTaskList>
    54ac:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    54b0:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    54b4:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    54b8:	8f 5f       	subi	r24, 0xFF	; 255
    54ba:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <xNumOfOverflows>
    54be:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    54c2:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    54c6:	80 81       	ld	r24, Z
    54c8:	81 11       	cpse	r24, r1
    54ca:	05 c0       	rjmp	.+10     	; 0x54d6 <vTaskDelay+0x1ca>
    54cc:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    54d0:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    54d4:	10 c0       	rjmp	.+32     	; 0x54f6 <vTaskDelay+0x1ea>
    54d6:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    54da:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    54de:	05 80       	ldd	r0, Z+5	; 0x05
    54e0:	f6 81       	ldd	r31, Z+6	; 0x06
    54e2:	e0 2d       	mov	r30, r0
    54e4:	06 80       	ldd	r0, Z+6	; 0x06
    54e6:	f7 81       	ldd	r31, Z+7	; 0x07
    54e8:	e0 2d       	mov	r30, r0
    54ea:	82 81       	ldd	r24, Z+2	; 0x02
    54ec:	93 81       	ldd	r25, Z+3	; 0x03
    54ee:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    54f2:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    54f6:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    54fa:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    54fe:	e8 16       	cp	r14, r24
    5500:	f9 06       	cpc	r15, r25
    5502:	08 f4       	brcc	.+2      	; 0x5506 <vTaskDelay+0x1fa>
    5504:	77 c0       	rjmp	.+238    	; 0x55f4 <vTaskDelay+0x2e8>
    5506:	a9 2c       	mov	r10, r9
    5508:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    550c:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5510:	80 81       	ld	r24, Z
    5512:	81 11       	cpse	r24, r1
    5514:	05 c0       	rjmp	.+10     	; 0x5520 <vTaskDelay+0x214>
    5516:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    551a:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    551e:	48 c0       	rjmp	.+144    	; 0x55b0 <vTaskDelay+0x2a4>
    5520:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5524:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5528:	05 80       	ldd	r0, Z+5	; 0x05
    552a:	f6 81       	ldd	r31, Z+6	; 0x06
    552c:	e0 2d       	mov	r30, r0
    552e:	c6 81       	ldd	r28, Z+6	; 0x06
    5530:	d7 81       	ldd	r29, Z+7	; 0x07
    5532:	8a 81       	ldd	r24, Y+2	; 0x02
    5534:	9b 81       	ldd	r25, Y+3	; 0x03
    5536:	e8 16       	cp	r14, r24
    5538:	f9 06       	cpc	r15, r25
    553a:	28 f4       	brcc	.+10     	; 0x5546 <vTaskDelay+0x23a>
    553c:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5540:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5544:	35 c0       	rjmp	.+106    	; 0x55b0 <vTaskDelay+0x2a4>
    5546:	8e 01       	movw	r16, r28
    5548:	0e 5f       	subi	r16, 0xFE	; 254
    554a:	1f 4f       	sbci	r17, 0xFF	; 255
    554c:	c8 01       	movw	r24, r16
    554e:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5552:	8c 89       	ldd	r24, Y+20	; 0x14
    5554:	9d 89       	ldd	r25, Y+21	; 0x15
    5556:	89 2b       	or	r24, r25
    5558:	21 f0       	breq	.+8      	; 0x5562 <vTaskDelay+0x256>
    555a:	ce 01       	movw	r24, r28
    555c:	0c 96       	adiw	r24, 0x0c	; 12
    555e:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5562:	8e 89       	ldd	r24, Y+22	; 0x16
    5564:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5568:	98 17       	cp	r25, r24
    556a:	10 f4       	brcc	.+4      	; 0x5570 <vTaskDelay+0x264>
    556c:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5570:	90 e0       	ldi	r25, 0x00	; 0
    5572:	9c 01       	movw	r18, r24
    5574:	22 0f       	add	r18, r18
    5576:	33 1f       	adc	r19, r19
    5578:	22 0f       	add	r18, r18
    557a:	33 1f       	adc	r19, r19
    557c:	22 0f       	add	r18, r18
    557e:	33 1f       	adc	r19, r19
    5580:	82 0f       	add	r24, r18
    5582:	93 1f       	adc	r25, r19
    5584:	b8 01       	movw	r22, r16
    5586:	8d 53       	subi	r24, 0x3D	; 61
    5588:	95 4e       	sbci	r25, 0xE5	; 229
    558a:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    558e:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5592:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5596:	9e 89       	ldd	r25, Y+22	; 0x16
    5598:	86 89       	ldd	r24, Z+22	; 0x16
    559a:	98 17       	cp	r25, r24
    559c:	08 f4       	brcc	.+2      	; 0x55a0 <vTaskDelay+0x294>
    559e:	b4 cf       	rjmp	.-152    	; 0x5508 <vTaskDelay+0x1fc>
    55a0:	ab 2c       	mov	r10, r11
    55a2:	b2 cf       	rjmp	.-156    	; 0x5508 <vTaskDelay+0x1fc>
    55a4:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    55a8:	8f 5f       	subi	r24, 0xFF	; 255
    55aa:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    55ae:	22 c0       	rjmp	.+68     	; 0x55f4 <vTaskDelay+0x2e8>
    55b0:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    55b4:	81 11       	cpse	r24, r1
    55b6:	01 c0       	rjmp	.+2      	; 0x55ba <vTaskDelay+0x2ae>
    55b8:	a1 10       	cpse	r10, r1
    55ba:	b0 92 94 1a 	sts	0x1A94, r11	; 0x801a94 <xYieldPending>
    55be:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    55c2:	81 50       	subi	r24, 0x01	; 1
    55c4:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    55c8:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    55cc:	81 11       	cpse	r24, r1
    55ce:	4e cf       	rjmp	.-356    	; 0x546c <vTaskDelay+0x160>
    55d0:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    55d4:	81 30       	cpi	r24, 0x01	; 1
    55d6:	31 f4       	brne	.+12     	; 0x55e4 <vTaskDelay+0x2d8>
    55d8:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    55dc:	81 e0       	ldi	r24, 0x01	; 1
    55de:	03 c0       	rjmp	.+6      	; 0x55e6 <vTaskDelay+0x2da>
    55e0:	80 e0       	ldi	r24, 0x00	; 0
    55e2:	01 c0       	rjmp	.+2      	; 0x55e6 <vTaskDelay+0x2da>
    55e4:	80 e0       	ldi	r24, 0x00	; 0
    55e6:	0f 90       	pop	r0
    55e8:	0f be       	out	0x3f, r0	; 63
    55ea:	81 11       	cpse	r24, r1
    55ec:	08 c0       	rjmp	.+16     	; 0x55fe <vTaskDelay+0x2f2>
    55ee:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    55f2:	05 c0       	rjmp	.+10     	; 0x55fe <vTaskDelay+0x2f2>
    55f4:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    55f8:	81 11       	cpse	r24, r1
    55fa:	df cf       	rjmp	.-66     	; 0x55ba <vTaskDelay+0x2ae>
    55fc:	e0 cf       	rjmp	.-64     	; 0x55be <vTaskDelay+0x2b2>
    55fe:	df 91       	pop	r29
    5600:	cf 91       	pop	r28
    5602:	1f 91       	pop	r17
    5604:	0f 91       	pop	r16
    5606:	ff 90       	pop	r15
    5608:	ef 90       	pop	r14
    560a:	df 90       	pop	r13
    560c:	cf 90       	pop	r12
    560e:	bf 90       	pop	r11
    5610:	af 90       	pop	r10
    5612:	9f 90       	pop	r9
    5614:	08 95       	ret

00005616 <vTaskStartScheduler>:
    5616:	cf 92       	push	r12
    5618:	df 92       	push	r13
    561a:	ef 92       	push	r14
    561c:	ff 92       	push	r15
    561e:	0f 93       	push	r16
    5620:	1f 93       	push	r17
    5622:	cf 93       	push	r28
    5624:	df 93       	push	r29
    5626:	85 e5       	ldi	r24, 0x55	; 85
    5628:	90 e0       	ldi	r25, 0x00	; 0
    562a:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    562e:	8c 01       	movw	r16, r24
    5630:	89 2b       	or	r24, r25
    5632:	09 f4       	brne	.+2      	; 0x5636 <vTaskStartScheduler+0x20>
    5634:	d4 c0       	rjmp	.+424    	; 0x57de <vTaskStartScheduler+0x1c8>
    5636:	88 e2       	ldi	r24, 0x28	; 40
    5638:	90 e0       	ldi	r25, 0x00	; 0
    563a:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    563e:	ec 01       	movw	r28, r24
    5640:	89 2b       	or	r24, r25
    5642:	b1 f0       	breq	.+44     	; 0x5670 <vTaskStartScheduler+0x5a>
    5644:	18 8f       	std	Y+24, r17	; 0x18
    5646:	0f 8b       	std	Y+23, r16	; 0x17
    5648:	45 e5       	ldi	r20, 0x55	; 85
    564a:	50 e0       	ldi	r21, 0x00	; 0
    564c:	65 ea       	ldi	r22, 0xA5	; 165
    564e:	70 e0       	ldi	r23, 0x00	; 0
    5650:	c8 01       	movw	r24, r16
    5652:	0e 94 19 3c 	call	0x7832	; 0x7832 <memset>
    5656:	0f 89       	ldd	r16, Y+23	; 0x17
    5658:	18 8d       	ldd	r17, Y+24	; 0x18
    565a:	0c 5a       	subi	r16, 0xAC	; 172
    565c:	1f 4f       	sbci	r17, 0xFF	; 255
    565e:	89 e4       	ldi	r24, 0x49	; 73
    5660:	89 8f       	std	Y+25, r24	; 0x19
    5662:	ef e4       	ldi	r30, 0x4F	; 79
    5664:	f7 e0       	ldi	r31, 0x07	; 7
    5666:	de 01       	movw	r26, r28
    5668:	5a 96       	adiw	r26, 0x1a	; 26
    566a:	26 e5       	ldi	r18, 0x56	; 86
    566c:	37 e0       	ldi	r19, 0x07	; 7
    566e:	04 c0       	rjmp	.+8      	; 0x5678 <vTaskStartScheduler+0x62>
    5670:	c8 01       	movw	r24, r16
    5672:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    5676:	b3 c0       	rjmp	.+358    	; 0x57de <vTaskStartScheduler+0x1c8>
    5678:	81 91       	ld	r24, Z+
    567a:	8d 93       	st	X+, r24
    567c:	88 23       	and	r24, r24
    567e:	19 f0       	breq	.+6      	; 0x5686 <vTaskStartScheduler+0x70>
    5680:	2e 17       	cp	r18, r30
    5682:	3f 07       	cpc	r19, r31
    5684:	c9 f7       	brne	.-14     	; 0x5678 <vTaskStartScheduler+0x62>
    5686:	18 a2       	std	Y+32, r1	; 0x20
    5688:	1e 8a       	std	Y+22, r1	; 0x16
    568a:	19 a2       	std	Y+33, r1	; 0x21
    568c:	1a a2       	std	Y+34, r1	; 0x22
    568e:	7e 01       	movw	r14, r28
    5690:	82 e0       	ldi	r24, 0x02	; 2
    5692:	e8 0e       	add	r14, r24
    5694:	f1 1c       	adc	r15, r1
    5696:	c7 01       	movw	r24, r14
    5698:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialiseItem>
    569c:	ce 01       	movw	r24, r28
    569e:	0c 96       	adiw	r24, 0x0c	; 12
    56a0:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialiseItem>
    56a4:	d9 87       	std	Y+9, r29	; 0x09
    56a6:	c8 87       	std	Y+8, r28	; 0x08
    56a8:	86 e0       	ldi	r24, 0x06	; 6
    56aa:	90 e0       	ldi	r25, 0x00	; 0
    56ac:	9d 87       	std	Y+13, r25	; 0x0d
    56ae:	8c 87       	std	Y+12, r24	; 0x0c
    56b0:	db 8b       	std	Y+19, r29	; 0x13
    56b2:	ca 8b       	std	Y+18, r28	; 0x12
    56b4:	1b a2       	std	Y+35, r1	; 0x23
    56b6:	1c a2       	std	Y+36, r1	; 0x24
    56b8:	1d a2       	std	Y+37, r1	; 0x25
    56ba:	1e a2       	std	Y+38, r1	; 0x26
    56bc:	1f a2       	std	Y+39, r1	; 0x27
    56be:	40 e0       	ldi	r20, 0x00	; 0
    56c0:	50 e0       	ldi	r21, 0x00	; 0
    56c2:	69 e1       	ldi	r22, 0x19	; 25
    56c4:	71 e0       	ldi	r23, 0x01	; 1
    56c6:	c8 01       	movw	r24, r16
    56c8:	0e 94 b3 1b 	call	0x3766	; 0x3766 <pxPortInitialiseStack>
    56cc:	99 83       	std	Y+1, r25	; 0x01
    56ce:	88 83       	st	Y, r24
    56d0:	0f b6       	in	r0, 0x3f	; 63
    56d2:	f8 94       	cli
    56d4:	0f 92       	push	r0
    56d6:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    56da:	8f 5f       	subi	r24, 0xFF	; 255
    56dc:	80 93 9a 1a 	sts	0x1A9A, r24	; 0x801a9a <uxCurrentNumberOfTasks>
    56e0:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    56e4:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    56e8:	89 2b       	or	r24, r25
    56ea:	a9 f5       	brne	.+106    	; 0x5756 <vTaskStartScheduler+0x140>
    56ec:	d0 93 fa 1a 	sts	0x1AFA, r29	; 0x801afa <pxCurrentTCB+0x1>
    56f0:	c0 93 f9 1a 	sts	0x1AF9, r28	; 0x801af9 <pxCurrentTCB>
    56f4:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    56f8:	81 30       	cpi	r24, 0x01	; 1
    56fa:	e1 f5       	brne	.+120    	; 0x5774 <vTaskStartScheduler+0x15e>
    56fc:	03 ec       	ldi	r16, 0xC3	; 195
    56fe:	1a e1       	ldi	r17, 0x1A	; 26
    5700:	0f 2e       	mov	r0, r31
    5702:	f9 ef       	ldi	r31, 0xF9	; 249
    5704:	cf 2e       	mov	r12, r31
    5706:	fa e1       	ldi	r31, 0x1A	; 26
    5708:	df 2e       	mov	r13, r31
    570a:	f0 2d       	mov	r31, r0
    570c:	c8 01       	movw	r24, r16
    570e:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    5712:	07 5f       	subi	r16, 0xF7	; 247
    5714:	1f 4f       	sbci	r17, 0xFF	; 255
    5716:	c0 16       	cp	r12, r16
    5718:	d1 06       	cpc	r13, r17
    571a:	c1 f7       	brne	.-16     	; 0x570c <vTaskStartScheduler+0xf6>
    571c:	8a eb       	ldi	r24, 0xBA	; 186
    571e:	9a e1       	ldi	r25, 0x1A	; 26
    5720:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    5724:	81 eb       	ldi	r24, 0xB1	; 177
    5726:	9a e1       	ldi	r25, 0x1A	; 26
    5728:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    572c:	84 ea       	ldi	r24, 0xA4	; 164
    572e:	9a e1       	ldi	r25, 0x1A	; 26
    5730:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    5734:	8b e9       	ldi	r24, 0x9B	; 155
    5736:	9a e1       	ldi	r25, 0x1A	; 26
    5738:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    573c:	8a eb       	ldi	r24, 0xBA	; 186
    573e:	9a e1       	ldi	r25, 0x1A	; 26
    5740:	90 93 b0 1a 	sts	0x1AB0, r25	; 0x801ab0 <pxDelayedTaskList+0x1>
    5744:	80 93 af 1a 	sts	0x1AAF, r24	; 0x801aaf <pxDelayedTaskList>
    5748:	81 eb       	ldi	r24, 0xB1	; 177
    574a:	9a e1       	ldi	r25, 0x1A	; 26
    574c:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5750:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    5754:	0f c0       	rjmp	.+30     	; 0x5774 <vTaskStartScheduler+0x15e>
    5756:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <xSchedulerRunning>
    575a:	81 11       	cpse	r24, r1
    575c:	0b c0       	rjmp	.+22     	; 0x5774 <vTaskStartScheduler+0x15e>
    575e:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5762:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5766:	86 89       	ldd	r24, Z+22	; 0x16
    5768:	81 11       	cpse	r24, r1
    576a:	04 c0       	rjmp	.+8      	; 0x5774 <vTaskStartScheduler+0x15e>
    576c:	d0 93 fa 1a 	sts	0x1AFA, r29	; 0x801afa <pxCurrentTCB+0x1>
    5770:	c0 93 f9 1a 	sts	0x1AF9, r28	; 0x801af9 <pxCurrentTCB>
    5774:	80 91 92 1a 	lds	r24, 0x1A92	; 0x801a92 <uxTaskNumber>
    5778:	8f 5f       	subi	r24, 0xFF	; 255
    577a:	80 93 92 1a 	sts	0x1A92, r24	; 0x801a92 <uxTaskNumber>
    577e:	8e 89       	ldd	r24, Y+22	; 0x16
    5780:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5784:	98 17       	cp	r25, r24
    5786:	10 f4       	brcc	.+4      	; 0x578c <vTaskStartScheduler+0x176>
    5788:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    578c:	90 e0       	ldi	r25, 0x00	; 0
    578e:	9c 01       	movw	r18, r24
    5790:	22 0f       	add	r18, r18
    5792:	33 1f       	adc	r19, r19
    5794:	22 0f       	add	r18, r18
    5796:	33 1f       	adc	r19, r19
    5798:	22 0f       	add	r18, r18
    579a:	33 1f       	adc	r19, r19
    579c:	82 0f       	add	r24, r18
    579e:	93 1f       	adc	r25, r19
    57a0:	b7 01       	movw	r22, r14
    57a2:	8d 53       	subi	r24, 0x3D	; 61
    57a4:	95 4e       	sbci	r25, 0xE5	; 229
    57a6:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    57aa:	0f 90       	pop	r0
    57ac:	0f be       	out	0x3f, r0	; 63
    57ae:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <xSchedulerRunning>
    57b2:	88 23       	and	r24, r24
    57b4:	21 f0       	breq	.+8      	; 0x57be <vTaskStartScheduler+0x1a8>
    57b6:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    57ba:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    57be:	f8 94       	cli
    57c0:	8f ef       	ldi	r24, 0xFF	; 255
    57c2:	9f ef       	ldi	r25, 0xFF	; 255
    57c4:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    57c8:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    57cc:	81 e0       	ldi	r24, 0x01	; 1
    57ce:	80 93 96 1a 	sts	0x1A96, r24	; 0x801a96 <xSchedulerRunning>
    57d2:	10 92 99 1a 	sts	0x1A99, r1	; 0x801a99 <xTickCount+0x1>
    57d6:	10 92 98 1a 	sts	0x1A98, r1	; 0x801a98 <xTickCount>
    57da:	0e 94 25 1c 	call	0x384a	; 0x384a <xPortStartScheduler>
    57de:	df 91       	pop	r29
    57e0:	cf 91       	pop	r28
    57e2:	1f 91       	pop	r17
    57e4:	0f 91       	pop	r16
    57e6:	ff 90       	pop	r15
    57e8:	ef 90       	pop	r14
    57ea:	df 90       	pop	r13
    57ec:	cf 90       	pop	r12
    57ee:	08 95       	ret

000057f0 <vTaskSuspendAll>:
    57f0:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    57f4:	8f 5f       	subi	r24, 0xFF	; 255
    57f6:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <uxSchedulerSuspended>
    57fa:	08 95       	ret

000057fc <xTaskResumeAll>:
    57fc:	9f 92       	push	r9
    57fe:	af 92       	push	r10
    5800:	bf 92       	push	r11
    5802:	cf 92       	push	r12
    5804:	df 92       	push	r13
    5806:	ef 92       	push	r14
    5808:	ff 92       	push	r15
    580a:	0f 93       	push	r16
    580c:	1f 93       	push	r17
    580e:	cf 93       	push	r28
    5810:	df 93       	push	r29
    5812:	0f b6       	in	r0, 0x3f	; 63
    5814:	f8 94       	cli
    5816:	0f 92       	push	r0
    5818:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    581c:	81 50       	subi	r24, 0x01	; 1
    581e:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <uxSchedulerSuspended>
    5822:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5826:	81 11       	cpse	r24, r1
    5828:	0d c1       	rjmp	.+538    	; 0x5a44 <xTaskResumeAll+0x248>
    582a:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    582e:	81 11       	cpse	r24, r1
    5830:	33 c0       	rjmp	.+102    	; 0x5898 <xTaskResumeAll+0x9c>
    5832:	0b c1       	rjmp	.+534    	; 0x5a4a <xTaskResumeAll+0x24e>
    5834:	d7 01       	movw	r26, r14
    5836:	15 96       	adiw	r26, 0x05	; 5
    5838:	ed 91       	ld	r30, X+
    583a:	fc 91       	ld	r31, X
    583c:	16 97       	sbiw	r26, 0x06	; 6
    583e:	c6 81       	ldd	r28, Z+6	; 0x06
    5840:	d7 81       	ldd	r29, Z+7	; 0x07
    5842:	ce 01       	movw	r24, r28
    5844:	0c 96       	adiw	r24, 0x0c	; 12
    5846:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    584a:	8e 01       	movw	r16, r28
    584c:	0e 5f       	subi	r16, 0xFE	; 254
    584e:	1f 4f       	sbci	r17, 0xFF	; 255
    5850:	c8 01       	movw	r24, r16
    5852:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5856:	8e 89       	ldd	r24, Y+22	; 0x16
    5858:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    585c:	98 17       	cp	r25, r24
    585e:	10 f4       	brcc	.+4      	; 0x5864 <xTaskResumeAll+0x68>
    5860:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5864:	90 e0       	ldi	r25, 0x00	; 0
    5866:	9c 01       	movw	r18, r24
    5868:	22 0f       	add	r18, r18
    586a:	33 1f       	adc	r19, r19
    586c:	22 0f       	add	r18, r18
    586e:	33 1f       	adc	r19, r19
    5870:	22 0f       	add	r18, r18
    5872:	33 1f       	adc	r19, r19
    5874:	82 0f       	add	r24, r18
    5876:	93 1f       	adc	r25, r19
    5878:	b8 01       	movw	r22, r16
    587a:	8d 53       	subi	r24, 0x3D	; 61
    587c:	95 4e       	sbci	r25, 0xE5	; 229
    587e:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5882:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5886:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    588a:	9e 89       	ldd	r25, Y+22	; 0x16
    588c:	86 89       	ldd	r24, Z+22	; 0x16
    588e:	98 17       	cp	r25, r24
    5890:	58 f0       	brcs	.+22     	; 0x58a8 <xTaskResumeAll+0xac>
    5892:	d0 92 94 1a 	sts	0x1A94, r13	; 0x801a94 <xYieldPending>
    5896:	08 c0       	rjmp	.+16     	; 0x58a8 <xTaskResumeAll+0xac>
    5898:	0f 2e       	mov	r0, r31
    589a:	f4 ea       	ldi	r31, 0xA4	; 164
    589c:	ef 2e       	mov	r14, r31
    589e:	fa e1       	ldi	r31, 0x1A	; 26
    58a0:	ff 2e       	mov	r15, r31
    58a2:	f0 2d       	mov	r31, r0
    58a4:	dd 24       	eor	r13, r13
    58a6:	d3 94       	inc	r13
    58a8:	f7 01       	movw	r30, r14
    58aa:	80 81       	ld	r24, Z
    58ac:	81 11       	cpse	r24, r1
    58ae:	c2 cf       	rjmp	.-124    	; 0x5834 <xTaskResumeAll+0x38>
    58b0:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    58b4:	88 23       	and	r24, r24
    58b6:	09 f4       	brne	.+2      	; 0x58ba <xTaskResumeAll+0xbe>
    58b8:	bd c0       	rjmp	.+378    	; 0x5a34 <xTaskResumeAll+0x238>
    58ba:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    58be:	88 23       	and	r24, r24
    58c0:	09 f4       	brne	.+2      	; 0x58c4 <xTaskResumeAll+0xc8>
    58c2:	b8 c0       	rjmp	.+368    	; 0x5a34 <xTaskResumeAll+0x238>
    58c4:	91 2c       	mov	r9, r1
    58c6:	bb 24       	eor	r11, r11
    58c8:	b3 94       	inc	r11
    58ca:	cc 24       	eor	r12, r12
    58cc:	ca 94       	dec	r12
    58ce:	dc 2c       	mov	r13, r12
    58d0:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    58d4:	81 11       	cpse	r24, r1
    58d6:	98 c0       	rjmp	.+304    	; 0x5a08 <xTaskResumeAll+0x20c>
    58d8:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    58dc:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    58e0:	01 96       	adiw	r24, 0x01	; 1
    58e2:	90 93 99 1a 	sts	0x1A99, r25	; 0x801a99 <xTickCount+0x1>
    58e6:	80 93 98 1a 	sts	0x1A98, r24	; 0x801a98 <xTickCount>
    58ea:	e0 90 98 1a 	lds	r14, 0x1A98	; 0x801a98 <xTickCount>
    58ee:	f0 90 99 1a 	lds	r15, 0x1A99	; 0x801a99 <xTickCount+0x1>
    58f2:	e1 14       	cp	r14, r1
    58f4:	f1 04       	cpc	r15, r1
    58f6:	89 f5       	brne	.+98     	; 0x595a <xTaskResumeAll+0x15e>
    58f8:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    58fc:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5900:	20 91 ad 1a 	lds	r18, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    5904:	30 91 ae 1a 	lds	r19, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5908:	30 93 b0 1a 	sts	0x1AB0, r19	; 0x801ab0 <pxDelayedTaskList+0x1>
    590c:	20 93 af 1a 	sts	0x1AAF, r18	; 0x801aaf <pxDelayedTaskList>
    5910:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5914:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    5918:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    591c:	8f 5f       	subi	r24, 0xFF	; 255
    591e:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <xNumOfOverflows>
    5922:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5926:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    592a:	80 81       	ld	r24, Z
    592c:	81 11       	cpse	r24, r1
    592e:	05 c0       	rjmp	.+10     	; 0x593a <xTaskResumeAll+0x13e>
    5930:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5934:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    5938:	10 c0       	rjmp	.+32     	; 0x595a <xTaskResumeAll+0x15e>
    593a:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    593e:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5942:	05 80       	ldd	r0, Z+5	; 0x05
    5944:	f6 81       	ldd	r31, Z+6	; 0x06
    5946:	e0 2d       	mov	r30, r0
    5948:	06 80       	ldd	r0, Z+6	; 0x06
    594a:	f7 81       	ldd	r31, Z+7	; 0x07
    594c:	e0 2d       	mov	r30, r0
    594e:	82 81       	ldd	r24, Z+2	; 0x02
    5950:	93 81       	ldd	r25, Z+3	; 0x03
    5952:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5956:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    595a:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    595e:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5962:	e8 16       	cp	r14, r24
    5964:	f9 06       	cpc	r15, r25
    5966:	08 f4       	brcc	.+2      	; 0x596a <xTaskResumeAll+0x16e>
    5968:	73 c0       	rjmp	.+230    	; 0x5a50 <xTaskResumeAll+0x254>
    596a:	a9 2c       	mov	r10, r9
    596c:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5970:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5974:	80 81       	ld	r24, Z
    5976:	81 11       	cpse	r24, r1
    5978:	05 c0       	rjmp	.+10     	; 0x5984 <xTaskResumeAll+0x188>
    597a:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    597e:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    5982:	48 c0       	rjmp	.+144    	; 0x5a14 <xTaskResumeAll+0x218>
    5984:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5988:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    598c:	05 80       	ldd	r0, Z+5	; 0x05
    598e:	f6 81       	ldd	r31, Z+6	; 0x06
    5990:	e0 2d       	mov	r30, r0
    5992:	c6 81       	ldd	r28, Z+6	; 0x06
    5994:	d7 81       	ldd	r29, Z+7	; 0x07
    5996:	8a 81       	ldd	r24, Y+2	; 0x02
    5998:	9b 81       	ldd	r25, Y+3	; 0x03
    599a:	e8 16       	cp	r14, r24
    599c:	f9 06       	cpc	r15, r25
    599e:	28 f4       	brcc	.+10     	; 0x59aa <xTaskResumeAll+0x1ae>
    59a0:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    59a4:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    59a8:	35 c0       	rjmp	.+106    	; 0x5a14 <xTaskResumeAll+0x218>
    59aa:	8e 01       	movw	r16, r28
    59ac:	0e 5f       	subi	r16, 0xFE	; 254
    59ae:	1f 4f       	sbci	r17, 0xFF	; 255
    59b0:	c8 01       	movw	r24, r16
    59b2:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    59b6:	8c 89       	ldd	r24, Y+20	; 0x14
    59b8:	9d 89       	ldd	r25, Y+21	; 0x15
    59ba:	89 2b       	or	r24, r25
    59bc:	21 f0       	breq	.+8      	; 0x59c6 <xTaskResumeAll+0x1ca>
    59be:	ce 01       	movw	r24, r28
    59c0:	0c 96       	adiw	r24, 0x0c	; 12
    59c2:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    59c6:	8e 89       	ldd	r24, Y+22	; 0x16
    59c8:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    59cc:	98 17       	cp	r25, r24
    59ce:	10 f4       	brcc	.+4      	; 0x59d4 <xTaskResumeAll+0x1d8>
    59d0:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    59d4:	90 e0       	ldi	r25, 0x00	; 0
    59d6:	9c 01       	movw	r18, r24
    59d8:	22 0f       	add	r18, r18
    59da:	33 1f       	adc	r19, r19
    59dc:	22 0f       	add	r18, r18
    59de:	33 1f       	adc	r19, r19
    59e0:	22 0f       	add	r18, r18
    59e2:	33 1f       	adc	r19, r19
    59e4:	82 0f       	add	r24, r18
    59e6:	93 1f       	adc	r25, r19
    59e8:	b8 01       	movw	r22, r16
    59ea:	8d 53       	subi	r24, 0x3D	; 61
    59ec:	95 4e       	sbci	r25, 0xE5	; 229
    59ee:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    59f2:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    59f6:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    59fa:	9e 89       	ldd	r25, Y+22	; 0x16
    59fc:	86 89       	ldd	r24, Z+22	; 0x16
    59fe:	98 17       	cp	r25, r24
    5a00:	08 f4       	brcc	.+2      	; 0x5a04 <xTaskResumeAll+0x208>
    5a02:	b4 cf       	rjmp	.-152    	; 0x596c <xTaskResumeAll+0x170>
    5a04:	ab 2c       	mov	r10, r11
    5a06:	b2 cf       	rjmp	.-156    	; 0x596c <xTaskResumeAll+0x170>
    5a08:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5a0c:	8f 5f       	subi	r24, 0xFF	; 255
    5a0e:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    5a12:	1e c0       	rjmp	.+60     	; 0x5a50 <xTaskResumeAll+0x254>
    5a14:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5a18:	81 11       	cpse	r24, r1
    5a1a:	01 c0       	rjmp	.+2      	; 0x5a1e <xTaskResumeAll+0x222>
    5a1c:	a1 10       	cpse	r10, r1
    5a1e:	b0 92 94 1a 	sts	0x1A94, r11	; 0x801a94 <xYieldPending>
    5a22:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5a26:	81 50       	subi	r24, 0x01	; 1
    5a28:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    5a2c:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5a30:	81 11       	cpse	r24, r1
    5a32:	4e cf       	rjmp	.-356    	; 0x58d0 <xTaskResumeAll+0xd4>
    5a34:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5a38:	81 30       	cpi	r24, 0x01	; 1
    5a3a:	31 f4       	brne	.+12     	; 0x5a48 <xTaskResumeAll+0x24c>
    5a3c:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    5a40:	81 e0       	ldi	r24, 0x01	; 1
    5a42:	03 c0       	rjmp	.+6      	; 0x5a4a <xTaskResumeAll+0x24e>
    5a44:	80 e0       	ldi	r24, 0x00	; 0
    5a46:	01 c0       	rjmp	.+2      	; 0x5a4a <xTaskResumeAll+0x24e>
    5a48:	80 e0       	ldi	r24, 0x00	; 0
    5a4a:	0f 90       	pop	r0
    5a4c:	0f be       	out	0x3f, r0	; 63
    5a4e:	05 c0       	rjmp	.+10     	; 0x5a5a <xTaskResumeAll+0x25e>
    5a50:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5a54:	81 11       	cpse	r24, r1
    5a56:	e3 cf       	rjmp	.-58     	; 0x5a1e <xTaskResumeAll+0x222>
    5a58:	e4 cf       	rjmp	.-56     	; 0x5a22 <xTaskResumeAll+0x226>
    5a5a:	df 91       	pop	r29
    5a5c:	cf 91       	pop	r28
    5a5e:	1f 91       	pop	r17
    5a60:	0f 91       	pop	r16
    5a62:	ff 90       	pop	r15
    5a64:	ef 90       	pop	r14
    5a66:	df 90       	pop	r13
    5a68:	cf 90       	pop	r12
    5a6a:	bf 90       	pop	r11
    5a6c:	af 90       	pop	r10
    5a6e:	9f 90       	pop	r9
    5a70:	08 95       	ret

00005a72 <xTaskGetTickCount>:
    5a72:	0f b6       	in	r0, 0x3f	; 63
    5a74:	f8 94       	cli
    5a76:	0f 92       	push	r0
    5a78:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5a7c:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5a80:	0f 90       	pop	r0
    5a82:	0f be       	out	0x3f, r0	; 63
    5a84:	08 95       	ret

00005a86 <xTaskIncrementTick>:
    5a86:	cf 92       	push	r12
    5a88:	df 92       	push	r13
    5a8a:	ef 92       	push	r14
    5a8c:	ff 92       	push	r15
    5a8e:	0f 93       	push	r16
    5a90:	1f 93       	push	r17
    5a92:	cf 93       	push	r28
    5a94:	df 93       	push	r29
    5a96:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5a9a:	81 11       	cpse	r24, r1
    5a9c:	9f c0       	rjmp	.+318    	; 0x5bdc <xTaskIncrementTick+0x156>
    5a9e:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5aa2:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5aa6:	01 96       	adiw	r24, 0x01	; 1
    5aa8:	90 93 99 1a 	sts	0x1A99, r25	; 0x801a99 <xTickCount+0x1>
    5aac:	80 93 98 1a 	sts	0x1A98, r24	; 0x801a98 <xTickCount>
    5ab0:	e0 90 98 1a 	lds	r14, 0x1A98	; 0x801a98 <xTickCount>
    5ab4:	f0 90 99 1a 	lds	r15, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5ab8:	e1 14       	cp	r14, r1
    5aba:	f1 04       	cpc	r15, r1
    5abc:	99 f5       	brne	.+102    	; 0x5b24 <xTaskIncrementTick+0x9e>
    5abe:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5ac2:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5ac6:	20 91 ad 1a 	lds	r18, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    5aca:	30 91 ae 1a 	lds	r19, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5ace:	30 93 b0 1a 	sts	0x1AB0, r19	; 0x801ab0 <pxDelayedTaskList+0x1>
    5ad2:	20 93 af 1a 	sts	0x1AAF, r18	; 0x801aaf <pxDelayedTaskList>
    5ad6:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5ada:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    5ade:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    5ae2:	8f 5f       	subi	r24, 0xFF	; 255
    5ae4:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <xNumOfOverflows>
    5ae8:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5aec:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5af0:	80 81       	ld	r24, Z
    5af2:	81 11       	cpse	r24, r1
    5af4:	07 c0       	rjmp	.+14     	; 0x5b04 <xTaskIncrementTick+0x7e>
    5af6:	8f ef       	ldi	r24, 0xFF	; 255
    5af8:	9f ef       	ldi	r25, 0xFF	; 255
    5afa:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5afe:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5b02:	10 c0       	rjmp	.+32     	; 0x5b24 <xTaskIncrementTick+0x9e>
    5b04:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5b08:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b0c:	05 80       	ldd	r0, Z+5	; 0x05
    5b0e:	f6 81       	ldd	r31, Z+6	; 0x06
    5b10:	e0 2d       	mov	r30, r0
    5b12:	06 80       	ldd	r0, Z+6	; 0x06
    5b14:	f7 81       	ldd	r31, Z+7	; 0x07
    5b16:	e0 2d       	mov	r30, r0
    5b18:	82 81       	ldd	r24, Z+2	; 0x02
    5b1a:	93 81       	ldd	r25, Z+3	; 0x03
    5b1c:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5b20:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5b24:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    5b28:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5b2c:	e8 16       	cp	r14, r24
    5b2e:	f9 06       	cpc	r15, r25
    5b30:	10 f4       	brcc	.+4      	; 0x5b36 <xTaskIncrementTick+0xb0>
    5b32:	d1 2c       	mov	r13, r1
    5b34:	59 c0       	rjmp	.+178    	; 0x5be8 <xTaskIncrementTick+0x162>
    5b36:	d1 2c       	mov	r13, r1
    5b38:	cc 24       	eor	r12, r12
    5b3a:	c3 94       	inc	r12
    5b3c:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5b40:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b44:	80 81       	ld	r24, Z
    5b46:	81 11       	cpse	r24, r1
    5b48:	07 c0       	rjmp	.+14     	; 0x5b58 <xTaskIncrementTick+0xd2>
    5b4a:	8f ef       	ldi	r24, 0xFF	; 255
    5b4c:	9f ef       	ldi	r25, 0xFF	; 255
    5b4e:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5b52:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5b56:	48 c0       	rjmp	.+144    	; 0x5be8 <xTaskIncrementTick+0x162>
    5b58:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5b5c:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b60:	05 80       	ldd	r0, Z+5	; 0x05
    5b62:	f6 81       	ldd	r31, Z+6	; 0x06
    5b64:	e0 2d       	mov	r30, r0
    5b66:	c6 81       	ldd	r28, Z+6	; 0x06
    5b68:	d7 81       	ldd	r29, Z+7	; 0x07
    5b6a:	8a 81       	ldd	r24, Y+2	; 0x02
    5b6c:	9b 81       	ldd	r25, Y+3	; 0x03
    5b6e:	e8 16       	cp	r14, r24
    5b70:	f9 06       	cpc	r15, r25
    5b72:	28 f4       	brcc	.+10     	; 0x5b7e <xTaskIncrementTick+0xf8>
    5b74:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5b78:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5b7c:	35 c0       	rjmp	.+106    	; 0x5be8 <xTaskIncrementTick+0x162>
    5b7e:	8e 01       	movw	r16, r28
    5b80:	0e 5f       	subi	r16, 0xFE	; 254
    5b82:	1f 4f       	sbci	r17, 0xFF	; 255
    5b84:	c8 01       	movw	r24, r16
    5b86:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5b8a:	8c 89       	ldd	r24, Y+20	; 0x14
    5b8c:	9d 89       	ldd	r25, Y+21	; 0x15
    5b8e:	89 2b       	or	r24, r25
    5b90:	21 f0       	breq	.+8      	; 0x5b9a <xTaskIncrementTick+0x114>
    5b92:	ce 01       	movw	r24, r28
    5b94:	0c 96       	adiw	r24, 0x0c	; 12
    5b96:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5b9a:	8e 89       	ldd	r24, Y+22	; 0x16
    5b9c:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5ba0:	98 17       	cp	r25, r24
    5ba2:	10 f4       	brcc	.+4      	; 0x5ba8 <xTaskIncrementTick+0x122>
    5ba4:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5ba8:	90 e0       	ldi	r25, 0x00	; 0
    5baa:	9c 01       	movw	r18, r24
    5bac:	22 0f       	add	r18, r18
    5bae:	33 1f       	adc	r19, r19
    5bb0:	22 0f       	add	r18, r18
    5bb2:	33 1f       	adc	r19, r19
    5bb4:	22 0f       	add	r18, r18
    5bb6:	33 1f       	adc	r19, r19
    5bb8:	82 0f       	add	r24, r18
    5bba:	93 1f       	adc	r25, r19
    5bbc:	b8 01       	movw	r22, r16
    5bbe:	8d 53       	subi	r24, 0x3D	; 61
    5bc0:	95 4e       	sbci	r25, 0xE5	; 229
    5bc2:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5bc6:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5bca:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5bce:	9e 89       	ldd	r25, Y+22	; 0x16
    5bd0:	86 89       	ldd	r24, Z+22	; 0x16
    5bd2:	98 17       	cp	r25, r24
    5bd4:	08 f4       	brcc	.+2      	; 0x5bd8 <xTaskIncrementTick+0x152>
    5bd6:	b2 cf       	rjmp	.-156    	; 0x5b3c <xTaskIncrementTick+0xb6>
    5bd8:	dc 2c       	mov	r13, r12
    5bda:	b0 cf       	rjmp	.-160    	; 0x5b3c <xTaskIncrementTick+0xb6>
    5bdc:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5be0:	8f 5f       	subi	r24, 0xFF	; 255
    5be2:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    5be6:	d1 2c       	mov	r13, r1
    5be8:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5bec:	88 23       	and	r24, r24
    5bee:	11 f0       	breq	.+4      	; 0x5bf4 <xTaskIncrementTick+0x16e>
    5bf0:	dd 24       	eor	r13, r13
    5bf2:	d3 94       	inc	r13
    5bf4:	8d 2d       	mov	r24, r13
    5bf6:	df 91       	pop	r29
    5bf8:	cf 91       	pop	r28
    5bfa:	1f 91       	pop	r17
    5bfc:	0f 91       	pop	r16
    5bfe:	ff 90       	pop	r15
    5c00:	ef 90       	pop	r14
    5c02:	df 90       	pop	r13
    5c04:	cf 90       	pop	r12
    5c06:	08 95       	ret

00005c08 <vTaskSwitchContext>:
    5c08:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5c0c:	88 23       	and	r24, r24
    5c0e:	21 f0       	breq	.+8      	; 0x5c18 <vTaskSwitchContext+0x10>
    5c10:	81 e0       	ldi	r24, 0x01	; 1
    5c12:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xYieldPending>
    5c16:	08 95       	ret
    5c18:	10 92 94 1a 	sts	0x1A94, r1	; 0x801a94 <xYieldPending>
    5c1c:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c20:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c24:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c28:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c2c:	2d 91       	ld	r18, X+
    5c2e:	3c 91       	ld	r19, X
    5c30:	87 89       	ldd	r24, Z+23	; 0x17
    5c32:	90 8d       	ldd	r25, Z+24	; 0x18
    5c34:	82 17       	cp	r24, r18
    5c36:	93 07       	cpc	r25, r19
    5c38:	60 f0       	brcs	.+24     	; 0x5c52 <vTaskSwitchContext+0x4a>
    5c3a:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c3e:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c42:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c46:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c4a:	67 5e       	subi	r22, 0xE7	; 231
    5c4c:	7f 4f       	sbci	r23, 0xFF	; 255
    5c4e:	0e 94 ec 18 	call	0x31d8	; 0x31d8 <vApplicationStackOverflowHook>
    5c52:	80 91 97 1a 	lds	r24, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5c56:	90 e0       	ldi	r25, 0x00	; 0
    5c58:	fc 01       	movw	r30, r24
    5c5a:	ee 0f       	add	r30, r30
    5c5c:	ff 1f       	adc	r31, r31
    5c5e:	ee 0f       	add	r30, r30
    5c60:	ff 1f       	adc	r31, r31
    5c62:	ee 0f       	add	r30, r30
    5c64:	ff 1f       	adc	r31, r31
    5c66:	8e 0f       	add	r24, r30
    5c68:	9f 1f       	adc	r25, r31
    5c6a:	fc 01       	movw	r30, r24
    5c6c:	ed 53       	subi	r30, 0x3D	; 61
    5c6e:	f5 4e       	sbci	r31, 0xE5	; 229
    5c70:	80 81       	ld	r24, Z
    5c72:	81 11       	cpse	r24, r1
    5c74:	17 c0       	rjmp	.+46     	; 0x5ca4 <vTaskSwitchContext+0x9c>
    5c76:	80 91 97 1a 	lds	r24, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5c7a:	81 50       	subi	r24, 0x01	; 1
    5c7c:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5c80:	80 91 97 1a 	lds	r24, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5c84:	90 e0       	ldi	r25, 0x00	; 0
    5c86:	fc 01       	movw	r30, r24
    5c88:	ee 0f       	add	r30, r30
    5c8a:	ff 1f       	adc	r31, r31
    5c8c:	ee 0f       	add	r30, r30
    5c8e:	ff 1f       	adc	r31, r31
    5c90:	ee 0f       	add	r30, r30
    5c92:	ff 1f       	adc	r31, r31
    5c94:	8e 0f       	add	r24, r30
    5c96:	9f 1f       	adc	r25, r31
    5c98:	fc 01       	movw	r30, r24
    5c9a:	ed 53       	subi	r30, 0x3D	; 61
    5c9c:	f5 4e       	sbci	r31, 0xE5	; 229
    5c9e:	80 81       	ld	r24, Z
    5ca0:	88 23       	and	r24, r24
    5ca2:	49 f3       	breq	.-46     	; 0x5c76 <vTaskSwitchContext+0x6e>
    5ca4:	80 91 97 1a 	lds	r24, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5ca8:	90 e0       	ldi	r25, 0x00	; 0
    5caa:	9c 01       	movw	r18, r24
    5cac:	22 0f       	add	r18, r18
    5cae:	33 1f       	adc	r19, r19
    5cb0:	22 0f       	add	r18, r18
    5cb2:	33 1f       	adc	r19, r19
    5cb4:	22 0f       	add	r18, r18
    5cb6:	33 1f       	adc	r19, r19
    5cb8:	28 0f       	add	r18, r24
    5cba:	39 1f       	adc	r19, r25
    5cbc:	d9 01       	movw	r26, r18
    5cbe:	ad 53       	subi	r26, 0x3D	; 61
    5cc0:	b5 4e       	sbci	r27, 0xE5	; 229
    5cc2:	11 96       	adiw	r26, 0x01	; 1
    5cc4:	ed 91       	ld	r30, X+
    5cc6:	fc 91       	ld	r31, X
    5cc8:	12 97       	sbiw	r26, 0x02	; 2
    5cca:	02 80       	ldd	r0, Z+2	; 0x02
    5ccc:	f3 81       	ldd	r31, Z+3	; 0x03
    5cce:	e0 2d       	mov	r30, r0
    5cd0:	12 96       	adiw	r26, 0x02	; 2
    5cd2:	fc 93       	st	X, r31
    5cd4:	ee 93       	st	-X, r30
    5cd6:	11 97       	sbiw	r26, 0x01	; 1
    5cd8:	2a 53       	subi	r18, 0x3A	; 58
    5cda:	35 4e       	sbci	r19, 0xE5	; 229
    5cdc:	e2 17       	cp	r30, r18
    5cde:	f3 07       	cpc	r31, r19
    5ce0:	29 f4       	brne	.+10     	; 0x5cec <vTaskSwitchContext+0xe4>
    5ce2:	22 81       	ldd	r18, Z+2	; 0x02
    5ce4:	33 81       	ldd	r19, Z+3	; 0x03
    5ce6:	fd 01       	movw	r30, r26
    5ce8:	32 83       	std	Z+2, r19	; 0x02
    5cea:	21 83       	std	Z+1, r18	; 0x01
    5cec:	fc 01       	movw	r30, r24
    5cee:	ee 0f       	add	r30, r30
    5cf0:	ff 1f       	adc	r31, r31
    5cf2:	ee 0f       	add	r30, r30
    5cf4:	ff 1f       	adc	r31, r31
    5cf6:	ee 0f       	add	r30, r30
    5cf8:	ff 1f       	adc	r31, r31
    5cfa:	8e 0f       	add	r24, r30
    5cfc:	9f 1f       	adc	r25, r31
    5cfe:	fc 01       	movw	r30, r24
    5d00:	ed 53       	subi	r30, 0x3D	; 61
    5d02:	f5 4e       	sbci	r31, 0xE5	; 229
    5d04:	01 80       	ldd	r0, Z+1	; 0x01
    5d06:	f2 81       	ldd	r31, Z+2	; 0x02
    5d08:	e0 2d       	mov	r30, r0
    5d0a:	86 81       	ldd	r24, Z+6	; 0x06
    5d0c:	97 81       	ldd	r25, Z+7	; 0x07
    5d0e:	90 93 fa 1a 	sts	0x1AFA, r25	; 0x801afa <pxCurrentTCB+0x1>
    5d12:	80 93 f9 1a 	sts	0x1AF9, r24	; 0x801af9 <pxCurrentTCB>
    5d16:	08 95       	ret

00005d18 <vTaskPlaceOnEventList>:
    5d18:	cf 93       	push	r28
    5d1a:	df 93       	push	r29
    5d1c:	eb 01       	movw	r28, r22
    5d1e:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d22:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5d26:	64 5f       	subi	r22, 0xF4	; 244
    5d28:	7f 4f       	sbci	r23, 0xFF	; 255
    5d2a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5d2e:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d32:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5d36:	02 96       	adiw	r24, 0x02	; 2
    5d38:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5d3c:	cf 3f       	cpi	r28, 0xFF	; 255
    5d3e:	8f ef       	ldi	r24, 0xFF	; 255
    5d40:	d8 07       	cpc	r29, r24
    5d42:	59 f4       	brne	.+22     	; 0x5d5a <vTaskPlaceOnEventList+0x42>
    5d44:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d48:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5d4c:	6e 5f       	subi	r22, 0xFE	; 254
    5d4e:	7f 4f       	sbci	r23, 0xFF	; 255
    5d50:	8b e9       	ldi	r24, 0x9B	; 155
    5d52:	9a e1       	ldi	r25, 0x1A	; 26
    5d54:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5d58:	37 c0       	rjmp	.+110    	; 0x5dc8 <vTaskPlaceOnEventList+0xb0>
    5d5a:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5d5e:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5d62:	c8 0f       	add	r28, r24
    5d64:	d9 1f       	adc	r29, r25
    5d66:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d6a:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5d6e:	d3 83       	std	Z+3, r29	; 0x03
    5d70:	c2 83       	std	Z+2, r28	; 0x02
    5d72:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5d76:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5d7a:	c8 17       	cp	r28, r24
    5d7c:	d9 07       	cpc	r29, r25
    5d7e:	68 f4       	brcc	.+26     	; 0x5d9a <vTaskPlaceOnEventList+0x82>
    5d80:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d84:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5d88:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    5d8c:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5d90:	6e 5f       	subi	r22, 0xFE	; 254
    5d92:	7f 4f       	sbci	r23, 0xFF	; 255
    5d94:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5d98:	17 c0       	rjmp	.+46     	; 0x5dc8 <vTaskPlaceOnEventList+0xb0>
    5d9a:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d9e:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5da2:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5da6:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5daa:	6e 5f       	subi	r22, 0xFE	; 254
    5dac:	7f 4f       	sbci	r23, 0xFF	; 255
    5dae:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5db2:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    5db6:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5dba:	c8 17       	cp	r28, r24
    5dbc:	d9 07       	cpc	r29, r25
    5dbe:	20 f4       	brcc	.+8      	; 0x5dc8 <vTaskPlaceOnEventList+0xb0>
    5dc0:	d0 93 91 1a 	sts	0x1A91, r29	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5dc4:	c0 93 90 1a 	sts	0x1A90, r28	; 0x801a90 <xNextTaskUnblockTime>
    5dc8:	df 91       	pop	r29
    5dca:	cf 91       	pop	r28
    5dcc:	08 95       	ret

00005dce <xTaskRemoveFromEventList>:
    5dce:	0f 93       	push	r16
    5dd0:	1f 93       	push	r17
    5dd2:	cf 93       	push	r28
    5dd4:	df 93       	push	r29
    5dd6:	dc 01       	movw	r26, r24
    5dd8:	15 96       	adiw	r26, 0x05	; 5
    5dda:	ed 91       	ld	r30, X+
    5ddc:	fc 91       	ld	r31, X
    5dde:	16 97       	sbiw	r26, 0x06	; 6
    5de0:	c6 81       	ldd	r28, Z+6	; 0x06
    5de2:	d7 81       	ldd	r29, Z+7	; 0x07
    5de4:	8e 01       	movw	r16, r28
    5de6:	04 5f       	subi	r16, 0xF4	; 244
    5de8:	1f 4f       	sbci	r17, 0xFF	; 255
    5dea:	c8 01       	movw	r24, r16
    5dec:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5df0:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5df4:	81 11       	cpse	r24, r1
    5df6:	1c c0       	rjmp	.+56     	; 0x5e30 <xTaskRemoveFromEventList+0x62>
    5df8:	0a 50       	subi	r16, 0x0A	; 10
    5dfa:	11 09       	sbc	r17, r1
    5dfc:	c8 01       	movw	r24, r16
    5dfe:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5e02:	8e 89       	ldd	r24, Y+22	; 0x16
    5e04:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5e08:	98 17       	cp	r25, r24
    5e0a:	10 f4       	brcc	.+4      	; 0x5e10 <xTaskRemoveFromEventList+0x42>
    5e0c:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5e10:	90 e0       	ldi	r25, 0x00	; 0
    5e12:	9c 01       	movw	r18, r24
    5e14:	22 0f       	add	r18, r18
    5e16:	33 1f       	adc	r19, r19
    5e18:	22 0f       	add	r18, r18
    5e1a:	33 1f       	adc	r19, r19
    5e1c:	22 0f       	add	r18, r18
    5e1e:	33 1f       	adc	r19, r19
    5e20:	82 0f       	add	r24, r18
    5e22:	93 1f       	adc	r25, r19
    5e24:	b8 01       	movw	r22, r16
    5e26:	8d 53       	subi	r24, 0x3D	; 61
    5e28:	95 4e       	sbci	r25, 0xE5	; 229
    5e2a:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5e2e:	05 c0       	rjmp	.+10     	; 0x5e3a <xTaskRemoveFromEventList+0x6c>
    5e30:	b8 01       	movw	r22, r16
    5e32:	84 ea       	ldi	r24, 0xA4	; 164
    5e34:	9a e1       	ldi	r25, 0x1A	; 26
    5e36:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5e3a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5e3e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5e42:	9e 89       	ldd	r25, Y+22	; 0x16
    5e44:	86 89       	ldd	r24, Z+22	; 0x16
    5e46:	89 17       	cp	r24, r25
    5e48:	20 f4       	brcc	.+8      	; 0x5e52 <xTaskRemoveFromEventList+0x84>
    5e4a:	81 e0       	ldi	r24, 0x01	; 1
    5e4c:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xYieldPending>
    5e50:	01 c0       	rjmp	.+2      	; 0x5e54 <xTaskRemoveFromEventList+0x86>
    5e52:	80 e0       	ldi	r24, 0x00	; 0
    5e54:	df 91       	pop	r29
    5e56:	cf 91       	pop	r28
    5e58:	1f 91       	pop	r17
    5e5a:	0f 91       	pop	r16
    5e5c:	08 95       	ret

00005e5e <vTaskSetTimeOutState>:
    5e5e:	20 91 93 1a 	lds	r18, 0x1A93	; 0x801a93 <xNumOfOverflows>
    5e62:	fc 01       	movw	r30, r24
    5e64:	20 83       	st	Z, r18
    5e66:	20 91 98 1a 	lds	r18, 0x1A98	; 0x801a98 <xTickCount>
    5e6a:	30 91 99 1a 	lds	r19, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5e6e:	32 83       	std	Z+2, r19	; 0x02
    5e70:	21 83       	std	Z+1, r18	; 0x01
    5e72:	08 95       	ret

00005e74 <xTaskCheckForTimeOut>:
    5e74:	fc 01       	movw	r30, r24
    5e76:	0f b6       	in	r0, 0x3f	; 63
    5e78:	f8 94       	cli
    5e7a:	0f 92       	push	r0
    5e7c:	20 91 98 1a 	lds	r18, 0x1A98	; 0x801a98 <xTickCount>
    5e80:	30 91 99 1a 	lds	r19, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5e84:	db 01       	movw	r26, r22
    5e86:	8d 91       	ld	r24, X+
    5e88:	9c 91       	ld	r25, X
    5e8a:	8f 3f       	cpi	r24, 0xFF	; 255
    5e8c:	bf ef       	ldi	r27, 0xFF	; 255
    5e8e:	9b 07       	cpc	r25, r27
    5e90:	21 f1       	breq	.+72     	; 0x5eda <xTaskCheckForTimeOut+0x66>
    5e92:	40 91 93 1a 	lds	r20, 0x1A93	; 0x801a93 <xNumOfOverflows>
    5e96:	50 81       	ld	r21, Z
    5e98:	54 17       	cp	r21, r20
    5e9a:	29 f0       	breq	.+10     	; 0x5ea6 <xTaskCheckForTimeOut+0x32>
    5e9c:	41 81       	ldd	r20, Z+1	; 0x01
    5e9e:	52 81       	ldd	r21, Z+2	; 0x02
    5ea0:	24 17       	cp	r18, r20
    5ea2:	35 07       	cpc	r19, r21
    5ea4:	e0 f4       	brcc	.+56     	; 0x5ede <xTaskCheckForTimeOut+0x6a>
    5ea6:	41 81       	ldd	r20, Z+1	; 0x01
    5ea8:	52 81       	ldd	r21, Z+2	; 0x02
    5eaa:	d9 01       	movw	r26, r18
    5eac:	a4 1b       	sub	r26, r20
    5eae:	b5 0b       	sbc	r27, r21
    5eb0:	a8 17       	cp	r26, r24
    5eb2:	b9 07       	cpc	r27, r25
    5eb4:	b0 f4       	brcc	.+44     	; 0x5ee2 <xTaskCheckForTimeOut+0x6e>
    5eb6:	42 1b       	sub	r20, r18
    5eb8:	53 0b       	sbc	r21, r19
    5eba:	84 0f       	add	r24, r20
    5ebc:	95 1f       	adc	r25, r21
    5ebe:	db 01       	movw	r26, r22
    5ec0:	8d 93       	st	X+, r24
    5ec2:	9c 93       	st	X, r25
    5ec4:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    5ec8:	80 83       	st	Z, r24
    5eca:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5ece:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5ed2:	92 83       	std	Z+2, r25	; 0x02
    5ed4:	81 83       	std	Z+1, r24	; 0x01
    5ed6:	80 e0       	ldi	r24, 0x00	; 0
    5ed8:	05 c0       	rjmp	.+10     	; 0x5ee4 <xTaskCheckForTimeOut+0x70>
    5eda:	80 e0       	ldi	r24, 0x00	; 0
    5edc:	03 c0       	rjmp	.+6      	; 0x5ee4 <xTaskCheckForTimeOut+0x70>
    5ede:	81 e0       	ldi	r24, 0x01	; 1
    5ee0:	01 c0       	rjmp	.+2      	; 0x5ee4 <xTaskCheckForTimeOut+0x70>
    5ee2:	81 e0       	ldi	r24, 0x01	; 1
    5ee4:	0f 90       	pop	r0
    5ee6:	0f be       	out	0x3f, r0	; 63
    5ee8:	08 95       	ret

00005eea <vTaskMissedYield>:
    5eea:	81 e0       	ldi	r24, 0x01	; 1
    5eec:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xYieldPending>
    5ef0:	08 95       	ret

00005ef2 <xTaskGetCurrentTaskHandle>:
    5ef2:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5ef6:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5efa:	08 95       	ret

00005efc <vTaskPriorityInherit>:
    5efc:	0f 93       	push	r16
    5efe:	1f 93       	push	r17
    5f00:	cf 93       	push	r28
    5f02:	df 93       	push	r29
    5f04:	fc 01       	movw	r30, r24
    5f06:	89 2b       	or	r24, r25
    5f08:	09 f4       	brne	.+2      	; 0x5f0c <vTaskPriorityInherit+0x10>
    5f0a:	55 c0       	rjmp	.+170    	; 0x5fb6 <vTaskPriorityInherit+0xba>
    5f0c:	26 89       	ldd	r18, Z+22	; 0x16
    5f0e:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5f12:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5f16:	56 96       	adiw	r26, 0x16	; 22
    5f18:	8c 91       	ld	r24, X
    5f1a:	28 17       	cp	r18, r24
    5f1c:	08 f0       	brcs	.+2      	; 0x5f20 <vTaskPriorityInherit+0x24>
    5f1e:	4b c0       	rjmp	.+150    	; 0x5fb6 <vTaskPriorityInherit+0xba>
    5f20:	84 85       	ldd	r24, Z+12	; 0x0c
    5f22:	95 85       	ldd	r25, Z+13	; 0x0d
    5f24:	99 23       	and	r25, r25
    5f26:	64 f0       	brlt	.+24     	; 0x5f40 <vTaskPriorityInherit+0x44>
    5f28:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5f2c:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5f30:	56 96       	adiw	r26, 0x16	; 22
    5f32:	3c 91       	ld	r19, X
    5f34:	86 e0       	ldi	r24, 0x06	; 6
    5f36:	90 e0       	ldi	r25, 0x00	; 0
    5f38:	83 1b       	sub	r24, r19
    5f3a:	91 09       	sbc	r25, r1
    5f3c:	95 87       	std	Z+13, r25	; 0x0d
    5f3e:	84 87       	std	Z+12, r24	; 0x0c
    5f40:	30 e0       	ldi	r19, 0x00	; 0
    5f42:	c9 01       	movw	r24, r18
    5f44:	88 0f       	add	r24, r24
    5f46:	99 1f       	adc	r25, r25
    5f48:	88 0f       	add	r24, r24
    5f4a:	99 1f       	adc	r25, r25
    5f4c:	88 0f       	add	r24, r24
    5f4e:	99 1f       	adc	r25, r25
    5f50:	28 0f       	add	r18, r24
    5f52:	39 1f       	adc	r19, r25
    5f54:	2d 53       	subi	r18, 0x3D	; 61
    5f56:	35 4e       	sbci	r19, 0xE5	; 229
    5f58:	82 85       	ldd	r24, Z+10	; 0x0a
    5f5a:	93 85       	ldd	r25, Z+11	; 0x0b
    5f5c:	82 17       	cp	r24, r18
    5f5e:	93 07       	cpc	r25, r19
    5f60:	19 f5       	brne	.+70     	; 0x5fa8 <vTaskPriorityInherit+0xac>
    5f62:	8f 01       	movw	r16, r30
    5f64:	ef 01       	movw	r28, r30
    5f66:	22 96       	adiw	r28, 0x02	; 2
    5f68:	ce 01       	movw	r24, r28
    5f6a:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5f6e:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5f72:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5f76:	86 89       	ldd	r24, Z+22	; 0x16
    5f78:	f8 01       	movw	r30, r16
    5f7a:	86 8b       	std	Z+22, r24	; 0x16
    5f7c:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5f80:	98 17       	cp	r25, r24
    5f82:	10 f4       	brcc	.+4      	; 0x5f88 <vTaskPriorityInherit+0x8c>
    5f84:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5f88:	90 e0       	ldi	r25, 0x00	; 0
    5f8a:	9c 01       	movw	r18, r24
    5f8c:	22 0f       	add	r18, r18
    5f8e:	33 1f       	adc	r19, r19
    5f90:	22 0f       	add	r18, r18
    5f92:	33 1f       	adc	r19, r19
    5f94:	22 0f       	add	r18, r18
    5f96:	33 1f       	adc	r19, r19
    5f98:	82 0f       	add	r24, r18
    5f9a:	93 1f       	adc	r25, r19
    5f9c:	be 01       	movw	r22, r28
    5f9e:	8d 53       	subi	r24, 0x3D	; 61
    5fa0:	95 4e       	sbci	r25, 0xE5	; 229
    5fa2:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5fa6:	07 c0       	rjmp	.+14     	; 0x5fb6 <vTaskPriorityInherit+0xba>
    5fa8:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5fac:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5fb0:	56 96       	adiw	r26, 0x16	; 22
    5fb2:	8c 91       	ld	r24, X
    5fb4:	86 8b       	std	Z+22, r24	; 0x16
    5fb6:	df 91       	pop	r29
    5fb8:	cf 91       	pop	r28
    5fba:	1f 91       	pop	r17
    5fbc:	0f 91       	pop	r16
    5fbe:	08 95       	ret

00005fc0 <xTaskPriorityDisinherit>:
    5fc0:	0f 93       	push	r16
    5fc2:	1f 93       	push	r17
    5fc4:	cf 93       	push	r28
    5fc6:	df 93       	push	r29
    5fc8:	fc 01       	movw	r30, r24
    5fca:	89 2b       	or	r24, r25
    5fcc:	79 f1       	breq	.+94     	; 0x602c <xTaskPriorityDisinherit+0x6c>
    5fce:	82 a1       	ldd	r24, Z+34	; 0x22
    5fd0:	81 50       	subi	r24, 0x01	; 1
    5fd2:	82 a3       	std	Z+34, r24	; 0x22
    5fd4:	26 89       	ldd	r18, Z+22	; 0x16
    5fd6:	91 a1       	ldd	r25, Z+33	; 0x21
    5fd8:	29 17       	cp	r18, r25
    5fda:	51 f1       	breq	.+84     	; 0x6030 <xTaskPriorityDisinherit+0x70>
    5fdc:	81 11       	cpse	r24, r1
    5fde:	2a c0       	rjmp	.+84     	; 0x6034 <xTaskPriorityDisinherit+0x74>
    5fe0:	ef 01       	movw	r28, r30
    5fe2:	8f 01       	movw	r16, r30
    5fe4:	0e 5f       	subi	r16, 0xFE	; 254
    5fe6:	1f 4f       	sbci	r17, 0xFF	; 255
    5fe8:	c8 01       	movw	r24, r16
    5fea:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5fee:	89 a1       	ldd	r24, Y+33	; 0x21
    5ff0:	8e 8b       	std	Y+22, r24	; 0x16
    5ff2:	26 e0       	ldi	r18, 0x06	; 6
    5ff4:	30 e0       	ldi	r19, 0x00	; 0
    5ff6:	28 1b       	sub	r18, r24
    5ff8:	31 09       	sbc	r19, r1
    5ffa:	3d 87       	std	Y+13, r19	; 0x0d
    5ffc:	2c 87       	std	Y+12, r18	; 0x0c
    5ffe:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    6002:	98 17       	cp	r25, r24
    6004:	10 f4       	brcc	.+4      	; 0x600a <xTaskPriorityDisinherit+0x4a>
    6006:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    600a:	90 e0       	ldi	r25, 0x00	; 0
    600c:	9c 01       	movw	r18, r24
    600e:	22 0f       	add	r18, r18
    6010:	33 1f       	adc	r19, r19
    6012:	22 0f       	add	r18, r18
    6014:	33 1f       	adc	r19, r19
    6016:	22 0f       	add	r18, r18
    6018:	33 1f       	adc	r19, r19
    601a:	82 0f       	add	r24, r18
    601c:	93 1f       	adc	r25, r19
    601e:	b8 01       	movw	r22, r16
    6020:	8d 53       	subi	r24, 0x3D	; 61
    6022:	95 4e       	sbci	r25, 0xE5	; 229
    6024:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    6028:	81 e0       	ldi	r24, 0x01	; 1
    602a:	05 c0       	rjmp	.+10     	; 0x6036 <xTaskPriorityDisinherit+0x76>
    602c:	80 e0       	ldi	r24, 0x00	; 0
    602e:	03 c0       	rjmp	.+6      	; 0x6036 <xTaskPriorityDisinherit+0x76>
    6030:	80 e0       	ldi	r24, 0x00	; 0
    6032:	01 c0       	rjmp	.+2      	; 0x6036 <xTaskPriorityDisinherit+0x76>
    6034:	80 e0       	ldi	r24, 0x00	; 0
    6036:	df 91       	pop	r29
    6038:	cf 91       	pop	r28
    603a:	1f 91       	pop	r17
    603c:	0f 91       	pop	r16
    603e:	08 95       	ret

00006040 <pvTaskIncrementMutexHeldCount>:
    6040:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6044:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6048:	89 2b       	or	r24, r25
    604a:	39 f0       	breq	.+14     	; 0x605a <pvTaskIncrementMutexHeldCount+0x1a>
    604c:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6050:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6054:	82 a1       	ldd	r24, Z+34	; 0x22
    6056:	8f 5f       	subi	r24, 0xFF	; 255
    6058:	82 a3       	std	Z+34, r24	; 0x22
    605a:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    605e:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6062:	08 95       	ret

00006064 <ulTaskNotifyTake>:
    6064:	0f 93       	push	r16
    6066:	1f 93       	push	r17
    6068:	cf 93       	push	r28
    606a:	df 93       	push	r29
    606c:	18 2f       	mov	r17, r24
    606e:	eb 01       	movw	r28, r22
    6070:	0f b6       	in	r0, 0x3f	; 63
    6072:	f8 94       	cli
    6074:	0f 92       	push	r0
    6076:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    607a:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    607e:	83 a1       	ldd	r24, Z+35	; 0x23
    6080:	94 a1       	ldd	r25, Z+36	; 0x24
    6082:	a5 a1       	ldd	r26, Z+37	; 0x25
    6084:	b6 a1       	ldd	r27, Z+38	; 0x26
    6086:	89 2b       	or	r24, r25
    6088:	8a 2b       	or	r24, r26
    608a:	8b 2b       	or	r24, r27
    608c:	09 f0       	breq	.+2      	; 0x6090 <ulTaskNotifyTake+0x2c>
    608e:	58 c0       	rjmp	.+176    	; 0x6140 <ulTaskNotifyTake+0xdc>
    6090:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6094:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6098:	81 e0       	ldi	r24, 0x01	; 1
    609a:	87 a3       	std	Z+39, r24	; 0x27
    609c:	20 97       	sbiw	r28, 0x00	; 0
    609e:	09 f4       	brne	.+2      	; 0x60a2 <ulTaskNotifyTake+0x3e>
    60a0:	4f c0       	rjmp	.+158    	; 0x6140 <ulTaskNotifyTake+0xdc>
    60a2:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    60a6:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60aa:	02 96       	adiw	r24, 0x02	; 2
    60ac:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    60b0:	cf 3f       	cpi	r28, 0xFF	; 255
    60b2:	8f ef       	ldi	r24, 0xFF	; 255
    60b4:	d8 07       	cpc	r29, r24
    60b6:	59 f4       	brne	.+22     	; 0x60ce <ulTaskNotifyTake+0x6a>
    60b8:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    60bc:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60c0:	6e 5f       	subi	r22, 0xFE	; 254
    60c2:	7f 4f       	sbci	r23, 0xFF	; 255
    60c4:	8b e9       	ldi	r24, 0x9B	; 155
    60c6:	9a e1       	ldi	r25, 0x1A	; 26
    60c8:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    60cc:	37 c0       	rjmp	.+110    	; 0x613c <ulTaskNotifyTake+0xd8>
    60ce:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    60d2:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    60d6:	c8 0f       	add	r28, r24
    60d8:	d9 1f       	adc	r29, r25
    60da:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    60de:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60e2:	d3 83       	std	Z+3, r29	; 0x03
    60e4:	c2 83       	std	Z+2, r28	; 0x02
    60e6:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    60ea:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    60ee:	c8 17       	cp	r28, r24
    60f0:	d9 07       	cpc	r29, r25
    60f2:	68 f4       	brcc	.+26     	; 0x610e <ulTaskNotifyTake+0xaa>
    60f4:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    60f8:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60fc:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    6100:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    6104:	6e 5f       	subi	r22, 0xFE	; 254
    6106:	7f 4f       	sbci	r23, 0xFF	; 255
    6108:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    610c:	17 c0       	rjmp	.+46     	; 0x613c <ulTaskNotifyTake+0xd8>
    610e:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6112:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6116:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    611a:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    611e:	6e 5f       	subi	r22, 0xFE	; 254
    6120:	7f 4f       	sbci	r23, 0xFF	; 255
    6122:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    6126:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    612a:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    612e:	c8 17       	cp	r28, r24
    6130:	d9 07       	cpc	r29, r25
    6132:	20 f4       	brcc	.+8      	; 0x613c <ulTaskNotifyTake+0xd8>
    6134:	d0 93 91 1a 	sts	0x1A91, r29	; 0x801a91 <xNextTaskUnblockTime+0x1>
    6138:	c0 93 90 1a 	sts	0x1A90, r28	; 0x801a90 <xNextTaskUnblockTime>
    613c:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    6140:	0f 90       	pop	r0
    6142:	0f be       	out	0x3f, r0	; 63
    6144:	0f b6       	in	r0, 0x3f	; 63
    6146:	f8 94       	cli
    6148:	0f 92       	push	r0
    614a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    614e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6152:	63 a1       	ldd	r22, Z+35	; 0x23
    6154:	74 a1       	ldd	r23, Z+36	; 0x24
    6156:	85 a1       	ldd	r24, Z+37	; 0x25
    6158:	96 a1       	ldd	r25, Z+38	; 0x26
    615a:	61 15       	cp	r22, r1
    615c:	71 05       	cpc	r23, r1
    615e:	81 05       	cpc	r24, r1
    6160:	91 05       	cpc	r25, r1
    6162:	d9 f0       	breq	.+54     	; 0x619a <ulTaskNotifyTake+0x136>
    6164:	11 23       	and	r17, r17
    6166:	49 f0       	breq	.+18     	; 0x617a <ulTaskNotifyTake+0x116>
    6168:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    616c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6170:	13 a2       	std	Z+35, r1	; 0x23
    6172:	14 a2       	std	Z+36, r1	; 0x24
    6174:	15 a2       	std	Z+37, r1	; 0x25
    6176:	16 a2       	std	Z+38, r1	; 0x26
    6178:	10 c0       	rjmp	.+32     	; 0x619a <ulTaskNotifyTake+0x136>
    617a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    617e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6182:	03 a1       	ldd	r16, Z+35	; 0x23
    6184:	14 a1       	ldd	r17, Z+36	; 0x24
    6186:	25 a1       	ldd	r18, Z+37	; 0x25
    6188:	36 a1       	ldd	r19, Z+38	; 0x26
    618a:	01 50       	subi	r16, 0x01	; 1
    618c:	11 09       	sbc	r17, r1
    618e:	21 09       	sbc	r18, r1
    6190:	31 09       	sbc	r19, r1
    6192:	03 a3       	std	Z+35, r16	; 0x23
    6194:	14 a3       	std	Z+36, r17	; 0x24
    6196:	25 a3       	std	Z+37, r18	; 0x25
    6198:	36 a3       	std	Z+38, r19	; 0x26
    619a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    619e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    61a2:	17 a2       	std	Z+39, r1	; 0x27
    61a4:	0f 90       	pop	r0
    61a6:	0f be       	out	0x3f, r0	; 63
    61a8:	df 91       	pop	r29
    61aa:	cf 91       	pop	r28
    61ac:	1f 91       	pop	r17
    61ae:	0f 91       	pop	r16
    61b0:	08 95       	ret

000061b2 <xTaskNotifyWait>:
    61b2:	4f 92       	push	r4
    61b4:	5f 92       	push	r5
    61b6:	6f 92       	push	r6
    61b8:	7f 92       	push	r7
    61ba:	8f 92       	push	r8
    61bc:	9f 92       	push	r9
    61be:	af 92       	push	r10
    61c0:	bf 92       	push	r11
    61c2:	ef 92       	push	r14
    61c4:	ff 92       	push	r15
    61c6:	0f 93       	push	r16
    61c8:	1f 93       	push	r17
    61ca:	49 01       	movw	r8, r18
    61cc:	5a 01       	movw	r10, r20
    61ce:	0f b6       	in	r0, 0x3f	; 63
    61d0:	f8 94       	cli
    61d2:	0f 92       	push	r0
    61d4:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    61d8:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    61dc:	27 a1       	ldd	r18, Z+39	; 0x27
    61de:	22 30       	cpi	r18, 0x02	; 2
    61e0:	09 f4       	brne	.+2      	; 0x61e4 <xTaskNotifyWait+0x32>
    61e2:	6f c0       	rjmp	.+222    	; 0x62c2 <xTaskNotifyWait+0x110>
    61e4:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    61e8:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    61ec:	43 a0       	ldd	r4, Z+35	; 0x23
    61ee:	54 a0       	ldd	r5, Z+36	; 0x24
    61f0:	65 a0       	ldd	r6, Z+37	; 0x25
    61f2:	76 a0       	ldd	r7, Z+38	; 0x26
    61f4:	dc 01       	movw	r26, r24
    61f6:	cb 01       	movw	r24, r22
    61f8:	80 95       	com	r24
    61fa:	90 95       	com	r25
    61fc:	a0 95       	com	r26
    61fe:	b0 95       	com	r27
    6200:	84 21       	and	r24, r4
    6202:	95 21       	and	r25, r5
    6204:	a6 21       	and	r26, r6
    6206:	b7 21       	and	r27, r7
    6208:	83 a3       	std	Z+35, r24	; 0x23
    620a:	94 a3       	std	Z+36, r25	; 0x24
    620c:	a5 a3       	std	Z+37, r26	; 0x25
    620e:	b6 a3       	std	Z+38, r27	; 0x26
    6210:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6214:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6218:	81 e0       	ldi	r24, 0x01	; 1
    621a:	87 a3       	std	Z+39, r24	; 0x27
    621c:	e1 14       	cp	r14, r1
    621e:	f1 04       	cpc	r15, r1
    6220:	09 f4       	brne	.+2      	; 0x6224 <xTaskNotifyWait+0x72>
    6222:	4f c0       	rjmp	.+158    	; 0x62c2 <xTaskNotifyWait+0x110>
    6224:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6228:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    622c:	02 96       	adiw	r24, 0x02	; 2
    622e:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    6232:	8f ef       	ldi	r24, 0xFF	; 255
    6234:	e8 16       	cp	r14, r24
    6236:	f8 06       	cpc	r15, r24
    6238:	59 f4       	brne	.+22     	; 0x6250 <xTaskNotifyWait+0x9e>
    623a:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    623e:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6242:	6e 5f       	subi	r22, 0xFE	; 254
    6244:	7f 4f       	sbci	r23, 0xFF	; 255
    6246:	8b e9       	ldi	r24, 0x9B	; 155
    6248:	9a e1       	ldi	r25, 0x1A	; 26
    624a:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    624e:	37 c0       	rjmp	.+110    	; 0x62be <xTaskNotifyWait+0x10c>
    6250:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    6254:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    6258:	e8 0e       	add	r14, r24
    625a:	f9 1e       	adc	r15, r25
    625c:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6260:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6264:	f3 82       	std	Z+3, r15	; 0x03
    6266:	e2 82       	std	Z+2, r14	; 0x02
    6268:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    626c:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    6270:	e8 16       	cp	r14, r24
    6272:	f9 06       	cpc	r15, r25
    6274:	68 f4       	brcc	.+26     	; 0x6290 <xTaskNotifyWait+0xde>
    6276:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    627a:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    627e:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    6282:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    6286:	6e 5f       	subi	r22, 0xFE	; 254
    6288:	7f 4f       	sbci	r23, 0xFF	; 255
    628a:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    628e:	17 c0       	rjmp	.+46     	; 0x62be <xTaskNotifyWait+0x10c>
    6290:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6294:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6298:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    629c:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    62a0:	6e 5f       	subi	r22, 0xFE	; 254
    62a2:	7f 4f       	sbci	r23, 0xFF	; 255
    62a4:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    62a8:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    62ac:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    62b0:	e8 16       	cp	r14, r24
    62b2:	f9 06       	cpc	r15, r25
    62b4:	20 f4       	brcc	.+8      	; 0x62be <xTaskNotifyWait+0x10c>
    62b6:	f0 92 91 1a 	sts	0x1A91, r15	; 0x801a91 <xNextTaskUnblockTime+0x1>
    62ba:	e0 92 90 1a 	sts	0x1A90, r14	; 0x801a90 <xNextTaskUnblockTime>
    62be:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    62c2:	0f 90       	pop	r0
    62c4:	0f be       	out	0x3f, r0	; 63
    62c6:	0f b6       	in	r0, 0x3f	; 63
    62c8:	f8 94       	cli
    62ca:	0f 92       	push	r0
    62cc:	01 15       	cp	r16, r1
    62ce:	11 05       	cpc	r17, r1
    62d0:	69 f0       	breq	.+26     	; 0x62ec <xTaskNotifyWait+0x13a>
    62d2:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    62d6:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    62da:	83 a1       	ldd	r24, Z+35	; 0x23
    62dc:	94 a1       	ldd	r25, Z+36	; 0x24
    62de:	a5 a1       	ldd	r26, Z+37	; 0x25
    62e0:	b6 a1       	ldd	r27, Z+38	; 0x26
    62e2:	f8 01       	movw	r30, r16
    62e4:	80 83       	st	Z, r24
    62e6:	91 83       	std	Z+1, r25	; 0x01
    62e8:	a2 83       	std	Z+2, r26	; 0x02
    62ea:	b3 83       	std	Z+3, r27	; 0x03
    62ec:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    62f0:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    62f4:	87 a1       	ldd	r24, Z+39	; 0x27
    62f6:	81 30       	cpi	r24, 0x01	; 1
    62f8:	b1 f0       	breq	.+44     	; 0x6326 <xTaskNotifyWait+0x174>
    62fa:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    62fe:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6302:	83 a1       	ldd	r24, Z+35	; 0x23
    6304:	94 a1       	ldd	r25, Z+36	; 0x24
    6306:	a5 a1       	ldd	r26, Z+37	; 0x25
    6308:	b6 a1       	ldd	r27, Z+38	; 0x26
    630a:	80 94       	com	r8
    630c:	90 94       	com	r9
    630e:	a0 94       	com	r10
    6310:	b0 94       	com	r11
    6312:	88 22       	and	r8, r24
    6314:	99 22       	and	r9, r25
    6316:	aa 22       	and	r10, r26
    6318:	bb 22       	and	r11, r27
    631a:	83 a2       	std	Z+35, r8	; 0x23
    631c:	94 a2       	std	Z+36, r9	; 0x24
    631e:	a5 a2       	std	Z+37, r10	; 0x25
    6320:	b6 a2       	std	Z+38, r11	; 0x26
    6322:	81 e0       	ldi	r24, 0x01	; 1
    6324:	01 c0       	rjmp	.+2      	; 0x6328 <xTaskNotifyWait+0x176>
    6326:	80 e0       	ldi	r24, 0x00	; 0
    6328:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    632c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6330:	17 a2       	std	Z+39, r1	; 0x27
    6332:	0f 90       	pop	r0
    6334:	0f be       	out	0x3f, r0	; 63
    6336:	1f 91       	pop	r17
    6338:	0f 91       	pop	r16
    633a:	ff 90       	pop	r15
    633c:	ef 90       	pop	r14
    633e:	bf 90       	pop	r11
    6340:	af 90       	pop	r10
    6342:	9f 90       	pop	r9
    6344:	8f 90       	pop	r8
    6346:	7f 90       	pop	r7
    6348:	6f 90       	pop	r6
    634a:	5f 90       	pop	r5
    634c:	4f 90       	pop	r4
    634e:	08 95       	ret

00006350 <xTaskGenericNotify>:
    6350:	0f 93       	push	r16
    6352:	1f 93       	push	r17
    6354:	cf 93       	push	r28
    6356:	df 93       	push	r29
    6358:	fc 01       	movw	r30, r24
    635a:	0f b6       	in	r0, 0x3f	; 63
    635c:	f8 94       	cli
    635e:	0f 92       	push	r0
    6360:	01 15       	cp	r16, r1
    6362:	11 05       	cpc	r17, r1
    6364:	49 f0       	breq	.+18     	; 0x6378 <xTaskGenericNotify+0x28>
    6366:	83 a1       	ldd	r24, Z+35	; 0x23
    6368:	94 a1       	ldd	r25, Z+36	; 0x24
    636a:	a5 a1       	ldd	r26, Z+37	; 0x25
    636c:	b6 a1       	ldd	r27, Z+38	; 0x26
    636e:	e8 01       	movw	r28, r16
    6370:	88 83       	st	Y, r24
    6372:	99 83       	std	Y+1, r25	; 0x01
    6374:	aa 83       	std	Y+2, r26	; 0x02
    6376:	bb 83       	std	Y+3, r27	; 0x03
    6378:	87 a1       	ldd	r24, Z+39	; 0x27
    637a:	92 e0       	ldi	r25, 0x02	; 2
    637c:	97 a3       	std	Z+39, r25	; 0x27
    637e:	22 30       	cpi	r18, 0x02	; 2
    6380:	b1 f0       	breq	.+44     	; 0x63ae <xTaskGenericNotify+0x5e>
    6382:	18 f4       	brcc	.+6      	; 0x638a <xTaskGenericNotify+0x3a>
    6384:	21 30       	cpi	r18, 0x01	; 1
    6386:	31 f0       	breq	.+12     	; 0x6394 <xTaskGenericNotify+0x44>
    6388:	2a c0       	rjmp	.+84     	; 0x63de <xTaskGenericNotify+0x8e>
    638a:	23 30       	cpi	r18, 0x03	; 3
    638c:	e9 f0       	breq	.+58     	; 0x63c8 <xTaskGenericNotify+0x78>
    638e:	24 30       	cpi	r18, 0x04	; 4
    6390:	01 f1       	breq	.+64     	; 0x63d2 <xTaskGenericNotify+0x82>
    6392:	25 c0       	rjmp	.+74     	; 0x63de <xTaskGenericNotify+0x8e>
    6394:	03 a1       	ldd	r16, Z+35	; 0x23
    6396:	14 a1       	ldd	r17, Z+36	; 0x24
    6398:	25 a1       	ldd	r18, Z+37	; 0x25
    639a:	36 a1       	ldd	r19, Z+38	; 0x26
    639c:	40 2b       	or	r20, r16
    639e:	51 2b       	or	r21, r17
    63a0:	62 2b       	or	r22, r18
    63a2:	73 2b       	or	r23, r19
    63a4:	43 a3       	std	Z+35, r20	; 0x23
    63a6:	54 a3       	std	Z+36, r21	; 0x24
    63a8:	65 a3       	std	Z+37, r22	; 0x25
    63aa:	76 a3       	std	Z+38, r23	; 0x26
    63ac:	18 c0       	rjmp	.+48     	; 0x63de <xTaskGenericNotify+0x8e>
    63ae:	43 a1       	ldd	r20, Z+35	; 0x23
    63b0:	54 a1       	ldd	r21, Z+36	; 0x24
    63b2:	65 a1       	ldd	r22, Z+37	; 0x25
    63b4:	76 a1       	ldd	r23, Z+38	; 0x26
    63b6:	4f 5f       	subi	r20, 0xFF	; 255
    63b8:	5f 4f       	sbci	r21, 0xFF	; 255
    63ba:	6f 4f       	sbci	r22, 0xFF	; 255
    63bc:	7f 4f       	sbci	r23, 0xFF	; 255
    63be:	43 a3       	std	Z+35, r20	; 0x23
    63c0:	54 a3       	std	Z+36, r21	; 0x24
    63c2:	65 a3       	std	Z+37, r22	; 0x25
    63c4:	76 a3       	std	Z+38, r23	; 0x26
    63c6:	0b c0       	rjmp	.+22     	; 0x63de <xTaskGenericNotify+0x8e>
    63c8:	43 a3       	std	Z+35, r20	; 0x23
    63ca:	54 a3       	std	Z+36, r21	; 0x24
    63cc:	65 a3       	std	Z+37, r22	; 0x25
    63ce:	76 a3       	std	Z+38, r23	; 0x26
    63d0:	06 c0       	rjmp	.+12     	; 0x63de <xTaskGenericNotify+0x8e>
    63d2:	82 30       	cpi	r24, 0x02	; 2
    63d4:	79 f1       	breq	.+94     	; 0x6434 <xTaskGenericNotify+0xe4>
    63d6:	43 a3       	std	Z+35, r20	; 0x23
    63d8:	54 a3       	std	Z+36, r21	; 0x24
    63da:	65 a3       	std	Z+37, r22	; 0x25
    63dc:	76 a3       	std	Z+38, r23	; 0x26
    63de:	81 30       	cpi	r24, 0x01	; 1
    63e0:	59 f5       	brne	.+86     	; 0x6438 <xTaskGenericNotify+0xe8>
    63e2:	ef 01       	movw	r28, r30
    63e4:	8f 01       	movw	r16, r30
    63e6:	0e 5f       	subi	r16, 0xFE	; 254
    63e8:	1f 4f       	sbci	r17, 0xFF	; 255
    63ea:	c8 01       	movw	r24, r16
    63ec:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    63f0:	8e 89       	ldd	r24, Y+22	; 0x16
    63f2:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    63f6:	98 17       	cp	r25, r24
    63f8:	10 f4       	brcc	.+4      	; 0x63fe <xTaskGenericNotify+0xae>
    63fa:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    63fe:	90 e0       	ldi	r25, 0x00	; 0
    6400:	9c 01       	movw	r18, r24
    6402:	22 0f       	add	r18, r18
    6404:	33 1f       	adc	r19, r19
    6406:	22 0f       	add	r18, r18
    6408:	33 1f       	adc	r19, r19
    640a:	22 0f       	add	r18, r18
    640c:	33 1f       	adc	r19, r19
    640e:	82 0f       	add	r24, r18
    6410:	93 1f       	adc	r25, r19
    6412:	b8 01       	movw	r22, r16
    6414:	8d 53       	subi	r24, 0x3D	; 61
    6416:	95 4e       	sbci	r25, 0xE5	; 229
    6418:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    641c:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6420:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6424:	9e 89       	ldd	r25, Y+22	; 0x16
    6426:	86 89       	ldd	r24, Z+22	; 0x16
    6428:	89 17       	cp	r24, r25
    642a:	40 f4       	brcc	.+16     	; 0x643c <xTaskGenericNotify+0xec>
    642c:	0e 94 6d 1c 	call	0x38da	; 0x38da <vPortYield>
    6430:	81 e0       	ldi	r24, 0x01	; 1
    6432:	05 c0       	rjmp	.+10     	; 0x643e <xTaskGenericNotify+0xee>
    6434:	80 e0       	ldi	r24, 0x00	; 0
    6436:	03 c0       	rjmp	.+6      	; 0x643e <xTaskGenericNotify+0xee>
    6438:	81 e0       	ldi	r24, 0x01	; 1
    643a:	01 c0       	rjmp	.+2      	; 0x643e <xTaskGenericNotify+0xee>
    643c:	81 e0       	ldi	r24, 0x01	; 1
    643e:	0f 90       	pop	r0
    6440:	0f be       	out	0x3f, r0	; 63
    6442:	df 91       	pop	r29
    6444:	cf 91       	pop	r28
    6446:	1f 91       	pop	r17
    6448:	0f 91       	pop	r16
    644a:	08 95       	ret

0000644c <xTaskGenericNotifyFromISR>:
    644c:	ef 92       	push	r14
    644e:	ff 92       	push	r15
    6450:	0f 93       	push	r16
    6452:	1f 93       	push	r17
    6454:	cf 93       	push	r28
    6456:	df 93       	push	r29
    6458:	fc 01       	movw	r30, r24
    645a:	01 15       	cp	r16, r1
    645c:	11 05       	cpc	r17, r1
    645e:	49 f0       	breq	.+18     	; 0x6472 <xTaskGenericNotifyFromISR+0x26>
    6460:	83 a1       	ldd	r24, Z+35	; 0x23
    6462:	94 a1       	ldd	r25, Z+36	; 0x24
    6464:	a5 a1       	ldd	r26, Z+37	; 0x25
    6466:	b6 a1       	ldd	r27, Z+38	; 0x26
    6468:	e8 01       	movw	r28, r16
    646a:	88 83       	st	Y, r24
    646c:	99 83       	std	Y+1, r25	; 0x01
    646e:	aa 83       	std	Y+2, r26	; 0x02
    6470:	bb 83       	std	Y+3, r27	; 0x03
    6472:	87 a1       	ldd	r24, Z+39	; 0x27
    6474:	92 e0       	ldi	r25, 0x02	; 2
    6476:	97 a3       	std	Z+39, r25	; 0x27
    6478:	22 30       	cpi	r18, 0x02	; 2
    647a:	b1 f0       	breq	.+44     	; 0x64a8 <xTaskGenericNotifyFromISR+0x5c>
    647c:	18 f4       	brcc	.+6      	; 0x6484 <xTaskGenericNotifyFromISR+0x38>
    647e:	21 30       	cpi	r18, 0x01	; 1
    6480:	31 f0       	breq	.+12     	; 0x648e <xTaskGenericNotifyFromISR+0x42>
    6482:	2a c0       	rjmp	.+84     	; 0x64d8 <xTaskGenericNotifyFromISR+0x8c>
    6484:	23 30       	cpi	r18, 0x03	; 3
    6486:	e9 f0       	breq	.+58     	; 0x64c2 <xTaskGenericNotifyFromISR+0x76>
    6488:	24 30       	cpi	r18, 0x04	; 4
    648a:	01 f1       	breq	.+64     	; 0x64cc <xTaskGenericNotifyFromISR+0x80>
    648c:	25 c0       	rjmp	.+74     	; 0x64d8 <xTaskGenericNotifyFromISR+0x8c>
    648e:	03 a1       	ldd	r16, Z+35	; 0x23
    6490:	14 a1       	ldd	r17, Z+36	; 0x24
    6492:	25 a1       	ldd	r18, Z+37	; 0x25
    6494:	36 a1       	ldd	r19, Z+38	; 0x26
    6496:	40 2b       	or	r20, r16
    6498:	51 2b       	or	r21, r17
    649a:	62 2b       	or	r22, r18
    649c:	73 2b       	or	r23, r19
    649e:	43 a3       	std	Z+35, r20	; 0x23
    64a0:	54 a3       	std	Z+36, r21	; 0x24
    64a2:	65 a3       	std	Z+37, r22	; 0x25
    64a4:	76 a3       	std	Z+38, r23	; 0x26
    64a6:	18 c0       	rjmp	.+48     	; 0x64d8 <xTaskGenericNotifyFromISR+0x8c>
    64a8:	43 a1       	ldd	r20, Z+35	; 0x23
    64aa:	54 a1       	ldd	r21, Z+36	; 0x24
    64ac:	65 a1       	ldd	r22, Z+37	; 0x25
    64ae:	76 a1       	ldd	r23, Z+38	; 0x26
    64b0:	4f 5f       	subi	r20, 0xFF	; 255
    64b2:	5f 4f       	sbci	r21, 0xFF	; 255
    64b4:	6f 4f       	sbci	r22, 0xFF	; 255
    64b6:	7f 4f       	sbci	r23, 0xFF	; 255
    64b8:	43 a3       	std	Z+35, r20	; 0x23
    64ba:	54 a3       	std	Z+36, r21	; 0x24
    64bc:	65 a3       	std	Z+37, r22	; 0x25
    64be:	76 a3       	std	Z+38, r23	; 0x26
    64c0:	0b c0       	rjmp	.+22     	; 0x64d8 <xTaskGenericNotifyFromISR+0x8c>
    64c2:	43 a3       	std	Z+35, r20	; 0x23
    64c4:	54 a3       	std	Z+36, r21	; 0x24
    64c6:	65 a3       	std	Z+37, r22	; 0x25
    64c8:	76 a3       	std	Z+38, r23	; 0x26
    64ca:	06 c0       	rjmp	.+12     	; 0x64d8 <xTaskGenericNotifyFromISR+0x8c>
    64cc:	82 30       	cpi	r24, 0x02	; 2
    64ce:	f1 f1       	breq	.+124    	; 0x654c <xTaskGenericNotifyFromISR+0x100>
    64d0:	43 a3       	std	Z+35, r20	; 0x23
    64d2:	54 a3       	std	Z+36, r21	; 0x24
    64d4:	65 a3       	std	Z+37, r22	; 0x25
    64d6:	76 a3       	std	Z+38, r23	; 0x26
    64d8:	81 30       	cpi	r24, 0x01	; 1
    64da:	d1 f5       	brne	.+116    	; 0x6550 <xTaskGenericNotifyFromISR+0x104>
    64dc:	ef 01       	movw	r28, r30
    64de:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    64e2:	81 11       	cpse	r24, r1
    64e4:	1d c0       	rjmp	.+58     	; 0x6520 <xTaskGenericNotifyFromISR+0xd4>
    64e6:	8f 01       	movw	r16, r30
    64e8:	0e 5f       	subi	r16, 0xFE	; 254
    64ea:	1f 4f       	sbci	r17, 0xFF	; 255
    64ec:	c8 01       	movw	r24, r16
    64ee:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    64f2:	8e 89       	ldd	r24, Y+22	; 0x16
    64f4:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    64f8:	98 17       	cp	r25, r24
    64fa:	10 f4       	brcc	.+4      	; 0x6500 <xTaskGenericNotifyFromISR+0xb4>
    64fc:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    6500:	90 e0       	ldi	r25, 0x00	; 0
    6502:	9c 01       	movw	r18, r24
    6504:	22 0f       	add	r18, r18
    6506:	33 1f       	adc	r19, r19
    6508:	22 0f       	add	r18, r18
    650a:	33 1f       	adc	r19, r19
    650c:	22 0f       	add	r18, r18
    650e:	33 1f       	adc	r19, r19
    6510:	82 0f       	add	r24, r18
    6512:	93 1f       	adc	r25, r19
    6514:	b8 01       	movw	r22, r16
    6516:	8d 53       	subi	r24, 0x3D	; 61
    6518:	95 4e       	sbci	r25, 0xE5	; 229
    651a:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    651e:	07 c0       	rjmp	.+14     	; 0x652e <xTaskGenericNotifyFromISR+0xe2>
    6520:	bf 01       	movw	r22, r30
    6522:	64 5f       	subi	r22, 0xF4	; 244
    6524:	7f 4f       	sbci	r23, 0xFF	; 255
    6526:	84 ea       	ldi	r24, 0xA4	; 164
    6528:	9a e1       	ldi	r25, 0x1A	; 26
    652a:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    652e:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6532:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6536:	9e 89       	ldd	r25, Y+22	; 0x16
    6538:	86 89       	ldd	r24, Z+22	; 0x16
    653a:	89 17       	cp	r24, r25
    653c:	58 f4       	brcc	.+22     	; 0x6554 <xTaskGenericNotifyFromISR+0x108>
    653e:	e1 14       	cp	r14, r1
    6540:	f1 04       	cpc	r15, r1
    6542:	51 f0       	breq	.+20     	; 0x6558 <xTaskGenericNotifyFromISR+0x10c>
    6544:	81 e0       	ldi	r24, 0x01	; 1
    6546:	f7 01       	movw	r30, r14
    6548:	80 83       	st	Z, r24
    654a:	07 c0       	rjmp	.+14     	; 0x655a <xTaskGenericNotifyFromISR+0x10e>
    654c:	80 e0       	ldi	r24, 0x00	; 0
    654e:	05 c0       	rjmp	.+10     	; 0x655a <xTaskGenericNotifyFromISR+0x10e>
    6550:	81 e0       	ldi	r24, 0x01	; 1
    6552:	03 c0       	rjmp	.+6      	; 0x655a <xTaskGenericNotifyFromISR+0x10e>
    6554:	81 e0       	ldi	r24, 0x01	; 1
    6556:	01 c0       	rjmp	.+2      	; 0x655a <xTaskGenericNotifyFromISR+0x10e>
    6558:	81 e0       	ldi	r24, 0x01	; 1
    655a:	df 91       	pop	r29
    655c:	cf 91       	pop	r28
    655e:	1f 91       	pop	r17
    6560:	0f 91       	pop	r16
    6562:	ff 90       	pop	r15
    6564:	ef 90       	pop	r14
    6566:	08 95       	ret

00006568 <xTaskNotifyStateClear>:

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    6568:	00 97       	sbiw	r24, 0x00	; 0
    656a:	21 f4       	brne	.+8      	; 0x6574 <xTaskNotifyStateClear+0xc>
    656c:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6570:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    6574:	0f b6       	in	r0, 0x3f	; 63
    6576:	f8 94       	cli
    6578:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    657a:	fc 01       	movw	r30, r24
    657c:	27 a1       	ldd	r18, Z+39	; 0x27
    657e:	22 30       	cpi	r18, 0x02	; 2
    6580:	19 f4       	brne	.+6      	; 0x6588 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    6582:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    6584:	81 e0       	ldi	r24, 0x01	; 1
    6586:	01 c0       	rjmp	.+2      	; 0x658a <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    6588:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    658a:	0f 90       	pop	r0
    658c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    658e:	08 95       	ret

00006590 <vFrameReaderTask>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint8_t)) {
	receive_callback = cb;
}

void vFrameReaderTask( void *pvParameters ){
    6590:	cf 93       	push	r28
    6592:	df 93       	push	r29
    6594:	00 d0       	rcall	.+0      	; 0x6596 <vFrameReaderTask+0x6>
    6596:	1f 92       	push	r1
    6598:	cd b7       	in	r28, 0x3d	; 61
    659a:	de b7       	in	r29, 0x3e	; 62
	frame_receiver = xTaskGetCurrentTaskHandle();
    659c:	aa dc       	rcall	.-1708   	; 0x5ef2 <xTaskGetCurrentTaskHandle>
    659e:	90 93 62 1b 	sts	0x1B62, r25	; 0x801b62 <frame_receiver+0x1>
    65a2:	80 93 61 1b 	sts	0x1B61, r24	; 0x801b61 <frame_receiver>
	uint32_t notification_value = 0;
    65a6:	19 82       	std	Y+1, r1	; 0x01
    65a8:	1a 82       	std	Y+2, r1	; 0x02
    65aa:	1b 82       	std	Y+3, r1	; 0x03
    65ac:	1c 82       	std	Y+4, r1	; 0x04
	while(1){
		xTaskNotifyWait(0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);
    65ae:	ee 24       	eor	r14, r14
    65b0:	ea 94       	dec	r14
    65b2:	fe 2c       	mov	r15, r14
    65b4:	8e 01       	movw	r16, r28
    65b6:	0f 5f       	subi	r16, 0xFF	; 255
    65b8:	1f 4f       	sbci	r17, 0xFF	; 255
    65ba:	2f ef       	ldi	r18, 0xFF	; 255
    65bc:	3f ef       	ldi	r19, 0xFF	; 255
    65be:	a9 01       	movw	r20, r18
    65c0:	6f ef       	ldi	r22, 0xFF	; 255
    65c2:	7f ef       	ldi	r23, 0xFF	; 255
    65c4:	cb 01       	movw	r24, r22
    65c6:	f5 dd       	rcall	.-1046   	; 0x61b2 <xTaskNotifyWait>
		if(receive_callback != NULL) receive_callback(receive_buffer, (uint8_t)notification_value);
    65c8:	e0 91 c2 1b 	lds	r30, 0x1BC2	; 0x801bc2 <receive_callback>
    65cc:	f0 91 c3 1b 	lds	r31, 0x1BC3	; 0x801bc3 <receive_callback+0x1>
    65d0:	30 97       	sbiw	r30, 0x00	; 0
    65d2:	69 f3       	breq	.-38     	; 0x65ae <vFrameReaderTask+0x1e>
    65d4:	69 81       	ldd	r22, Y+1	; 0x01
    65d6:	84 ec       	ldi	r24, 0xC4	; 196
    65d8:	9b e1       	ldi	r25, 0x1B	; 27
    65da:	19 95       	eicall
    65dc:	e8 cf       	rjmp	.-48     	; 0x65ae <vFrameReaderTask+0x1e>

000065de <vUartSendTask>:
	}
}

void vUartSendTask(void *pvParamters) {
    65de:	cf 93       	push	r28
    65e0:	df 93       	push	r29
    65e2:	cd b7       	in	r28, 0x3d	; 61
    65e4:	de b7       	in	r29, 0x3e	; 62
    65e6:	c4 56       	subi	r28, 0x64	; 100
    65e8:	d1 09       	sbc	r29, r1
    65ea:	0f b6       	in	r0, 0x3f	; 63
    65ec:	f8 94       	cli
    65ee:	de bf       	out	0x3e, r29	; 62
    65f0:	0f be       	out	0x3f, r0	; 63
    65f2:	cd bf       	out	0x3d, r28	; 61
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    65f4:	00 ed       	ldi	r16, 0xD0	; 208
    65f6:	10 e0       	ldi	r17, 0x00	; 0
				UDR2 = data[i];
    65f8:	0f 2e       	mov	r0, r31
    65fa:	f6 ed       	ldi	r31, 0xD6	; 214
    65fc:	ef 2e       	mov	r14, r31
    65fe:	f1 2c       	mov	r15, r1
    6600:	f0 2d       	mov	r31, r0
void vUartSendTask(void *pvParamters) {
	uint8_t data[100];
	uint16_t num;
	uint16_t i;
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
    6602:	20 e0       	ldi	r18, 0x00	; 0
    6604:	4f ef       	ldi	r20, 0xFF	; 255
    6606:	5f ef       	ldi	r21, 0xFF	; 255
    6608:	60 e0       	ldi	r22, 0x00	; 0
    660a:	70 e0       	ldi	r23, 0x00	; 0
    660c:	80 91 87 1b 	lds	r24, 0x1B87	; 0x801b87 <xUartMutex>
    6610:	90 91 88 1b 	lds	r25, 0x1B88	; 0x801b88 <xUartMutex+0x1>
    6614:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
    6618:	24 e6       	ldi	r18, 0x64	; 100
    661a:	30 e0       	ldi	r19, 0x00	; 0
    661c:	40 e0       	ldi	r20, 0x00	; 0
    661e:	be 01       	movw	r22, r28
    6620:	6f 5f       	subi	r22, 0xFF	; 255
    6622:	7f 4f       	sbci	r23, 0xFF	; 255
    6624:	88 e2       	ldi	r24, 0x28	; 40
    6626:	9c e1       	ldi	r25, 0x1C	; 28
    6628:	0e 94 a2 05 	call	0xb44	; 0xb44 <buffer_remove_token>
    662c:	6c 01       	movw	r12, r24
		xSemaphoreGive(xUartMutex);
    662e:	60 e0       	ldi	r22, 0x00	; 0
    6630:	70 e0       	ldi	r23, 0x00	; 0
    6632:	80 91 87 1b 	lds	r24, 0x1B87	; 0x801b87 <xUartMutex>
    6636:	90 91 88 1b 	lds	r25, 0x1B88	; 0x801b88 <xUartMutex+0x1>
    663a:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
		if(num>0) {
    663e:	c1 14       	cp	r12, r1
    6640:	d1 04       	cpc	r13, r1
    6642:	79 f0       	breq	.+30     	; 0x6662 <vUartSendTask+0x84>
    6644:	fe 01       	movw	r30, r28
    6646:	31 96       	adiw	r30, 0x01	; 1
    6648:	9f 01       	movw	r18, r30
    664a:	2c 0d       	add	r18, r12
    664c:	3d 1d       	adc	r19, r13
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    664e:	d8 01       	movw	r26, r16
    6650:	8c 91       	ld	r24, X
    6652:	85 ff       	sbrs	r24, 5
    6654:	fc cf       	rjmp	.-8      	; 0x664e <vUartSendTask+0x70>
				UDR2 = data[i];
    6656:	81 91       	ld	r24, Z+
    6658:	d7 01       	movw	r26, r14
    665a:	8c 93       	st	X, r24
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
    665c:	2e 17       	cp	r18, r30
    665e:	3f 07       	cpc	r19, r31
    6660:	b1 f7       	brne	.-20     	; 0x664e <vUartSendTask+0x70>
				while ( !( UCSR2A & (1<<UDRE2)) );
				UDR2 = data[i];
			}
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
    6662:	8a e0       	ldi	r24, 0x0A	; 10
    6664:	90 e0       	ldi	r25, 0x00	; 0
    6666:	0e 94 86 29 	call	0x530c	; 0x530c <vTaskDelay>
	}
    666a:	cb cf       	rjmp	.-106    	; 0x6602 <vUartSendTask+0x24>

0000666c <vUSART_init>:
/************************************************************************/
//Initialize USART driver, note that RXD0/TXD0 (PD0/PD1) is used
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    666c:	af 92       	push	r10
    666e:	bf 92       	push	r11
    6670:	cf 92       	push	r12
    6672:	df 92       	push	r13
    6674:	ef 92       	push	r14
    6676:	ff 92       	push	r15
    6678:	0f 93       	push	r16
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    667a:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    667e:	89 e1       	ldi	r24, 0x19	; 25
    6680:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    6684:	80 ee       	ldi	r24, 0xE0	; 224
    6686:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    668a:	88 e9       	ldi	r24, 0x98	; 152
    668c:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    6690:	e2 ed       	ldi	r30, 0xD2	; 210
    6692:	f0 e0       	ldi	r31, 0x00	; 0
    6694:	86 e0       	ldi	r24, 0x06	; 6
    6696:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    6698:	80 81       	ld	r24, Z
    669a:	80 83       	st	Z, r24

	uint8_t *buf = pvPortMalloc(100);
    669c:	84 e6       	ldi	r24, 0x64	; 100
    669e:	90 e0       	ldi	r25, 0x00	; 0
    66a0:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
	buffer_init(&send_buffer, buf, 100);
    66a4:	44 e6       	ldi	r20, 0x64	; 100
    66a6:	50 e0       	ldi	r21, 0x00	; 0
    66a8:	bc 01       	movw	r22, r24
    66aa:	88 e2       	ldi	r24, 0x28	; 40
    66ac:	9c e1       	ldi	r25, 0x1C	; 28
    66ae:	0e 94 2c 05 	call	0xa58	; 0xa58 <buffer_init>
	xTaskCreate(vFrameReaderTask, "FrameReader", 300, NULL, 4, NULL);
    66b2:	a1 2c       	mov	r10, r1
    66b4:	b1 2c       	mov	r11, r1
    66b6:	c1 2c       	mov	r12, r1
    66b8:	d1 2c       	mov	r13, r1
    66ba:	e1 2c       	mov	r14, r1
    66bc:	f1 2c       	mov	r15, r1
    66be:	04 e0       	ldi	r16, 0x04	; 4
    66c0:	20 e0       	ldi	r18, 0x00	; 0
    66c2:	30 e0       	ldi	r19, 0x00	; 0
    66c4:	4c e2       	ldi	r20, 0x2C	; 44
    66c6:	51 e0       	ldi	r21, 0x01	; 1
    66c8:	63 e5       	ldi	r22, 0x53	; 83
    66ca:	77 e0       	ldi	r23, 0x07	; 7
    66cc:	88 ec       	ldi	r24, 0xC8	; 200
    66ce:	92 e3       	ldi	r25, 0x32	; 50
    66d0:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <xTaskGenericCreate>
	xTaskCreate(vUartSendTask, "UartSendTask", 300, NULL, 4, NULL);
    66d4:	20 e0       	ldi	r18, 0x00	; 0
    66d6:	30 e0       	ldi	r19, 0x00	; 0
    66d8:	4c e2       	ldi	r20, 0x2C	; 44
    66da:	51 e0       	ldi	r21, 0x01	; 1
    66dc:	6f e5       	ldi	r22, 0x5F	; 95
    66de:	77 e0       	ldi	r23, 0x07	; 7
    66e0:	8f ee       	ldi	r24, 0xEF	; 239
    66e2:	92 e3       	ldi	r25, 0x32	; 50
    66e4:	0e 94 c7 26 	call	0x4d8e	; 0x4d8e <xTaskGenericCreate>
	
	xUartMutex = xSemaphoreCreateMutex();
    66e8:	81 e0       	ldi	r24, 0x01	; 1
    66ea:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <xQueueCreateMutex>
    66ee:	90 93 88 1b 	sts	0x1B88, r25	; 0x801b88 <xUartMutex+0x1>
    66f2:	80 93 87 1b 	sts	0x1B87, r24	; 0x801b87 <xUartMutex>
}
    66f6:	0f 91       	pop	r16
    66f8:	ff 90       	pop	r15
    66fa:	ef 90       	pop	r14
    66fc:	df 90       	pop	r13
    66fe:	cf 90       	pop	r12
    6700:	bf 90       	pop	r11
    6702:	af 90       	pop	r10
    6704:	08 95       	ret

00006706 <vUSART_send>:




void vUSART_send(uint8_t *data, uint16_t len) {
    6706:	0f 93       	push	r16
    6708:	1f 93       	push	r17
    670a:	cf 93       	push	r28
    670c:	df 93       	push	r29
    670e:	ec 01       	movw	r28, r24
    6710:	8b 01       	movw	r16, r22
	xSemaphoreTake(xUartMutex, portMAX_DELAY);
    6712:	20 e0       	ldi	r18, 0x00	; 0
    6714:	4f ef       	ldi	r20, 0xFF	; 255
    6716:	5f ef       	ldi	r21, 0xFF	; 255
    6718:	60 e0       	ldi	r22, 0x00	; 0
    671a:	70 e0       	ldi	r23, 0x00	; 0
    671c:	80 91 87 1b 	lds	r24, 0x1B87	; 0x801b87 <xUartMutex>
    6720:	90 91 88 1b 	lds	r25, 0x1B88	; 0x801b88 <xUartMutex+0x1>
    6724:	0e 94 88 22 	call	0x4510	; 0x4510 <xQueueGenericReceive>
	buffer_append(&send_buffer, data, len);
    6728:	a8 01       	movw	r20, r16
    672a:	be 01       	movw	r22, r28
    672c:	88 e2       	ldi	r24, 0x28	; 40
    672e:	9c e1       	ldi	r25, 0x1C	; 28
    6730:	0e 94 3e 05 	call	0xa7c	; 0xa7c <buffer_append>
	xSemaphoreGive(xUartMutex);
    6734:	60 e0       	ldi	r22, 0x00	; 0
    6736:	70 e0       	ldi	r23, 0x00	; 0
    6738:	80 91 87 1b 	lds	r24, 0x1B87	; 0x801b87 <xUartMutex>
    673c:	90 91 88 1b 	lds	r25, 0x1B88	; 0x801b88 <xUartMutex+0x1>
    6740:	0e 94 ec 20 	call	0x41d8	; 0x41d8 <xQueueGive>
}
    6744:	df 91       	pop	r29
    6746:	cf 91       	pop	r28
    6748:	1f 91       	pop	r17
    674a:	0f 91       	pop	r16
    674c:	08 95       	ret

0000674e <vUSART_set_receive_callback>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint8_t)) {
	receive_callback = cb;
    674e:	90 93 c3 1b 	sts	0x1BC3, r25	; 0x801bc3 <receive_callback+0x1>
    6752:	80 93 c2 1b 	sts	0x1BC2, r24	; 0x801bc2 <receive_callback>
    6756:	08 95       	ret

00006758 <__vector_51>:
		vTaskDelay(10*portTICK_PERIOD_MS);
	}
}


ISR(USART2_RX_vect){
    6758:	1f 92       	push	r1
    675a:	0f 92       	push	r0
    675c:	0f b6       	in	r0, 0x3f	; 63
    675e:	0f 92       	push	r0
    6760:	11 24       	eor	r1, r1
    6762:	0b b6       	in	r0, 0x3b	; 59
    6764:	0f 92       	push	r0
    6766:	cf 92       	push	r12
    6768:	df 92       	push	r13
    676a:	ef 92       	push	r14
    676c:	ff 92       	push	r15
    676e:	0f 93       	push	r16
    6770:	1f 93       	push	r17
    6772:	2f 93       	push	r18
    6774:	3f 93       	push	r19
    6776:	4f 93       	push	r20
    6778:	5f 93       	push	r21
    677a:	6f 93       	push	r22
    677c:	7f 93       	push	r23
    677e:	8f 93       	push	r24
    6780:	9f 93       	push	r25
    6782:	af 93       	push	r26
    6784:	bf 93       	push	r27
    6786:	cf 93       	push	r28
    6788:	df 93       	push	r29
    678a:	ef 93       	push	r30
    678c:	ff 93       	push	r31
	static uint8_t input_buffer[100];
	static uint16_t input_index = 0;
	input_buffer[input_index++] = UDR2;
    678e:	80 91 5f 1b 	lds	r24, 0x1B5F	; 0x801b5f <input_index.2398>
    6792:	90 91 60 1b 	lds	r25, 0x1B60	; 0x801b60 <input_index.2398+0x1>
    6796:	ec 01       	movw	r28, r24
    6798:	21 96       	adiw	r28, 0x01	; 1
    679a:	d0 93 60 1b 	sts	0x1B60, r29	; 0x801b60 <input_index.2398+0x1>
    679e:	c0 93 5f 1b 	sts	0x1B5F, r28	; 0x801b5f <input_index.2398>
    67a2:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    67a6:	fc 01       	movw	r30, r24
    67a8:	e5 50       	subi	r30, 0x05	; 5
    67aa:	f5 4e       	sbci	r31, 0xE5	; 229
    67ac:	20 83       	st	Z, r18
	if(input_buffer[input_index-1] == 0x00) {
    67ae:	21 11       	cpse	r18, r1
    67b0:	1d c0       	rjmp	.+58     	; 0x67ec <__vector_51+0x94>
		if(frame_receiver != NULL) {
    67b2:	c0 90 61 1b 	lds	r12, 0x1B61	; 0x801b61 <frame_receiver>
    67b6:	d0 90 62 1b 	lds	r13, 0x1B62	; 0x801b62 <frame_receiver+0x1>
    67ba:	c1 14       	cp	r12, r1
    67bc:	d1 04       	cpc	r13, r1
    67be:	89 f0       	breq	.+34     	; 0x67e2 <__vector_51+0x8a>
			memcpy(receive_buffer, input_buffer, input_index);
    67c0:	ae 01       	movw	r20, r28
    67c2:	6b ef       	ldi	r22, 0xFB	; 251
    67c4:	7a e1       	ldi	r23, 0x1A	; 26
    67c6:	84 ec       	ldi	r24, 0xC4	; 196
    67c8:	9b e1       	ldi	r25, 0x1B	; 27
    67ca:	0e 94 10 3c 	call	0x7820	; 0x7820 <memcpy>
			xTaskNotifyFromISR(frame_receiver, input_index, eSetValueWithoutOverwrite, NULL);
    67ce:	ae 01       	movw	r20, r28
    67d0:	60 e0       	ldi	r22, 0x00	; 0
    67d2:	70 e0       	ldi	r23, 0x00	; 0
    67d4:	e1 2c       	mov	r14, r1
    67d6:	f1 2c       	mov	r15, r1
    67d8:	00 e0       	ldi	r16, 0x00	; 0
    67da:	10 e0       	ldi	r17, 0x00	; 0
    67dc:	24 e0       	ldi	r18, 0x04	; 4
    67de:	c6 01       	movw	r24, r12
    67e0:	35 de       	rcall	.-918    	; 0x644c <xTaskGenericNotifyFromISR>
		}
		input_index = 0;
    67e2:	10 92 60 1b 	sts	0x1B60, r1	; 0x801b60 <input_index.2398+0x1>
    67e6:	10 92 5f 1b 	sts	0x1B5F, r1	; 0x801b5f <input_index.2398>
    67ea:	07 c0       	rjmp	.+14     	; 0x67fa <__vector_51+0xa2>
	}
	if(input_index > 100) input_index = 0; // Something went wrong, received too many bytes
    67ec:	c5 36       	cpi	r28, 0x65	; 101
    67ee:	d1 05       	cpc	r29, r1
    67f0:	20 f0       	brcs	.+8      	; 0x67fa <__vector_51+0xa2>
    67f2:	10 92 60 1b 	sts	0x1B60, r1	; 0x801b60 <input_index.2398+0x1>
    67f6:	10 92 5f 1b 	sts	0x1B5F, r1	; 0x801b5f <input_index.2398>
    67fa:	ff 91       	pop	r31
    67fc:	ef 91       	pop	r30
    67fe:	df 91       	pop	r29
    6800:	cf 91       	pop	r28
    6802:	bf 91       	pop	r27
    6804:	af 91       	pop	r26
    6806:	9f 91       	pop	r25
    6808:	8f 91       	pop	r24
    680a:	7f 91       	pop	r23
    680c:	6f 91       	pop	r22
    680e:	5f 91       	pop	r21
    6810:	4f 91       	pop	r20
    6812:	3f 91       	pop	r19
    6814:	2f 91       	pop	r18
    6816:	1f 91       	pop	r17
    6818:	0f 91       	pop	r16
    681a:	ff 90       	pop	r15
    681c:	ef 90       	pop	r14
    681e:	df 90       	pop	r13
    6820:	cf 90       	pop	r12
    6822:	0f 90       	pop	r0
    6824:	0b be       	out	0x3b, r0	; 59
    6826:	0f 90       	pop	r0
    6828:	0f be       	out	0x3f, r0	; 63
    682a:	0f 90       	pop	r0
    682c:	1f 90       	pop	r1
    682e:	18 95       	reti

00006830 <__subsf3>:
    6830:	50 58       	subi	r21, 0x80	; 128

00006832 <__addsf3>:
    6832:	bb 27       	eor	r27, r27
    6834:	aa 27       	eor	r26, r26
    6836:	0e d0       	rcall	.+28     	; 0x6854 <__addsf3x>
    6838:	27 c2       	rjmp	.+1102   	; 0x6c88 <__fp_round>
    683a:	f0 d1       	rcall	.+992    	; 0x6c1c <__fp_pscA>
    683c:	30 f0       	brcs	.+12     	; 0x684a <__addsf3+0x18>
    683e:	f5 d1       	rcall	.+1002   	; 0x6c2a <__fp_pscB>
    6840:	20 f0       	brcs	.+8      	; 0x684a <__addsf3+0x18>
    6842:	31 f4       	brne	.+12     	; 0x6850 <__addsf3+0x1e>
    6844:	9f 3f       	cpi	r25, 0xFF	; 255
    6846:	11 f4       	brne	.+4      	; 0x684c <__addsf3+0x1a>
    6848:	1e f4       	brtc	.+6      	; 0x6850 <__addsf3+0x1e>
    684a:	c0 c1       	rjmp	.+896    	; 0x6bcc <__fp_nan>
    684c:	0e f4       	brtc	.+2      	; 0x6850 <__addsf3+0x1e>
    684e:	e0 95       	com	r30
    6850:	e7 fb       	bst	r30, 7
    6852:	b6 c1       	rjmp	.+876    	; 0x6bc0 <__fp_inf>

00006854 <__addsf3x>:
    6854:	e9 2f       	mov	r30, r25
    6856:	3a d2       	rcall	.+1140   	; 0x6ccc <__fp_split3>
    6858:	80 f3       	brcs	.-32     	; 0x683a <__addsf3+0x8>
    685a:	ba 17       	cp	r27, r26
    685c:	62 07       	cpc	r22, r18
    685e:	73 07       	cpc	r23, r19
    6860:	84 07       	cpc	r24, r20
    6862:	95 07       	cpc	r25, r21
    6864:	18 f0       	brcs	.+6      	; 0x686c <__addsf3x+0x18>
    6866:	71 f4       	brne	.+28     	; 0x6884 <__addsf3x+0x30>
    6868:	9e f5       	brtc	.+102    	; 0x68d0 <__addsf3x+0x7c>
    686a:	52 c2       	rjmp	.+1188   	; 0x6d10 <__fp_zero>
    686c:	0e f4       	brtc	.+2      	; 0x6870 <__addsf3x+0x1c>
    686e:	e0 95       	com	r30
    6870:	0b 2e       	mov	r0, r27
    6872:	ba 2f       	mov	r27, r26
    6874:	a0 2d       	mov	r26, r0
    6876:	0b 01       	movw	r0, r22
    6878:	b9 01       	movw	r22, r18
    687a:	90 01       	movw	r18, r0
    687c:	0c 01       	movw	r0, r24
    687e:	ca 01       	movw	r24, r20
    6880:	a0 01       	movw	r20, r0
    6882:	11 24       	eor	r1, r1
    6884:	ff 27       	eor	r31, r31
    6886:	59 1b       	sub	r21, r25
    6888:	99 f0       	breq	.+38     	; 0x68b0 <__addsf3x+0x5c>
    688a:	59 3f       	cpi	r21, 0xF9	; 249
    688c:	50 f4       	brcc	.+20     	; 0x68a2 <__addsf3x+0x4e>
    688e:	50 3e       	cpi	r21, 0xE0	; 224
    6890:	68 f1       	brcs	.+90     	; 0x68ec <__addsf3x+0x98>
    6892:	1a 16       	cp	r1, r26
    6894:	f0 40       	sbci	r31, 0x00	; 0
    6896:	a2 2f       	mov	r26, r18
    6898:	23 2f       	mov	r18, r19
    689a:	34 2f       	mov	r19, r20
    689c:	44 27       	eor	r20, r20
    689e:	58 5f       	subi	r21, 0xF8	; 248
    68a0:	f3 cf       	rjmp	.-26     	; 0x6888 <__addsf3x+0x34>
    68a2:	46 95       	lsr	r20
    68a4:	37 95       	ror	r19
    68a6:	27 95       	ror	r18
    68a8:	a7 95       	ror	r26
    68aa:	f0 40       	sbci	r31, 0x00	; 0
    68ac:	53 95       	inc	r21
    68ae:	c9 f7       	brne	.-14     	; 0x68a2 <__addsf3x+0x4e>
    68b0:	7e f4       	brtc	.+30     	; 0x68d0 <__addsf3x+0x7c>
    68b2:	1f 16       	cp	r1, r31
    68b4:	ba 0b       	sbc	r27, r26
    68b6:	62 0b       	sbc	r22, r18
    68b8:	73 0b       	sbc	r23, r19
    68ba:	84 0b       	sbc	r24, r20
    68bc:	ba f0       	brmi	.+46     	; 0x68ec <__addsf3x+0x98>
    68be:	91 50       	subi	r25, 0x01	; 1
    68c0:	a1 f0       	breq	.+40     	; 0x68ea <__addsf3x+0x96>
    68c2:	ff 0f       	add	r31, r31
    68c4:	bb 1f       	adc	r27, r27
    68c6:	66 1f       	adc	r22, r22
    68c8:	77 1f       	adc	r23, r23
    68ca:	88 1f       	adc	r24, r24
    68cc:	c2 f7       	brpl	.-16     	; 0x68be <__addsf3x+0x6a>
    68ce:	0e c0       	rjmp	.+28     	; 0x68ec <__addsf3x+0x98>
    68d0:	ba 0f       	add	r27, r26
    68d2:	62 1f       	adc	r22, r18
    68d4:	73 1f       	adc	r23, r19
    68d6:	84 1f       	adc	r24, r20
    68d8:	48 f4       	brcc	.+18     	; 0x68ec <__addsf3x+0x98>
    68da:	87 95       	ror	r24
    68dc:	77 95       	ror	r23
    68de:	67 95       	ror	r22
    68e0:	b7 95       	ror	r27
    68e2:	f7 95       	ror	r31
    68e4:	9e 3f       	cpi	r25, 0xFE	; 254
    68e6:	08 f0       	brcs	.+2      	; 0x68ea <__addsf3x+0x96>
    68e8:	b3 cf       	rjmp	.-154    	; 0x6850 <__addsf3+0x1e>
    68ea:	93 95       	inc	r25
    68ec:	88 0f       	add	r24, r24
    68ee:	08 f0       	brcs	.+2      	; 0x68f2 <__addsf3x+0x9e>
    68f0:	99 27       	eor	r25, r25
    68f2:	ee 0f       	add	r30, r30
    68f4:	97 95       	ror	r25
    68f6:	87 95       	ror	r24
    68f8:	08 95       	ret
    68fa:	90 d1       	rcall	.+800    	; 0x6c1c <__fp_pscA>
    68fc:	58 f0       	brcs	.+22     	; 0x6914 <__addsf3x+0xc0>
    68fe:	80 e8       	ldi	r24, 0x80	; 128
    6900:	91 e0       	ldi	r25, 0x01	; 1
    6902:	09 f4       	brne	.+2      	; 0x6906 <__addsf3x+0xb2>
    6904:	9e ef       	ldi	r25, 0xFE	; 254
    6906:	91 d1       	rcall	.+802    	; 0x6c2a <__fp_pscB>
    6908:	28 f0       	brcs	.+10     	; 0x6914 <__addsf3x+0xc0>
    690a:	40 e8       	ldi	r20, 0x80	; 128
    690c:	51 e0       	ldi	r21, 0x01	; 1
    690e:	59 f4       	brne	.+22     	; 0x6926 <atan2+0xe>
    6910:	5e ef       	ldi	r21, 0xFE	; 254
    6912:	09 c0       	rjmp	.+18     	; 0x6926 <atan2+0xe>
    6914:	5b c1       	rjmp	.+694    	; 0x6bcc <__fp_nan>
    6916:	fc c1       	rjmp	.+1016   	; 0x6d10 <__fp_zero>

00006918 <atan2>:
    6918:	e9 2f       	mov	r30, r25
    691a:	e0 78       	andi	r30, 0x80	; 128
    691c:	d7 d1       	rcall	.+942    	; 0x6ccc <__fp_split3>
    691e:	68 f3       	brcs	.-38     	; 0x68fa <__addsf3x+0xa6>
    6920:	09 2e       	mov	r0, r25
    6922:	05 2a       	or	r0, r21
    6924:	c1 f3       	breq	.-16     	; 0x6916 <__addsf3x+0xc2>
    6926:	26 17       	cp	r18, r22
    6928:	37 07       	cpc	r19, r23
    692a:	48 07       	cpc	r20, r24
    692c:	59 07       	cpc	r21, r25
    692e:	38 f0       	brcs	.+14     	; 0x693e <atan2+0x26>
    6930:	0e 2e       	mov	r0, r30
    6932:	07 f8       	bld	r0, 7
    6934:	e0 25       	eor	r30, r0
    6936:	69 f0       	breq	.+26     	; 0x6952 <atan2+0x3a>
    6938:	e0 25       	eor	r30, r0
    693a:	e0 64       	ori	r30, 0x40	; 64
    693c:	0a c0       	rjmp	.+20     	; 0x6952 <atan2+0x3a>
    693e:	ef 63       	ori	r30, 0x3F	; 63
    6940:	07 f8       	bld	r0, 7
    6942:	00 94       	com	r0
    6944:	07 fa       	bst	r0, 7
    6946:	db 01       	movw	r26, r22
    6948:	b9 01       	movw	r22, r18
    694a:	9d 01       	movw	r18, r26
    694c:	dc 01       	movw	r26, r24
    694e:	ca 01       	movw	r24, r20
    6950:	ad 01       	movw	r20, r26
    6952:	ef 93       	push	r30
    6954:	4a d0       	rcall	.+148    	; 0x69ea <__divsf3_pse>
    6956:	98 d1       	rcall	.+816    	; 0x6c88 <__fp_round>
    6958:	0a d0       	rcall	.+20     	; 0x696e <atan>
    695a:	5f 91       	pop	r21
    695c:	55 23       	and	r21, r21
    695e:	31 f0       	breq	.+12     	; 0x696c <atan2+0x54>
    6960:	2b ed       	ldi	r18, 0xDB	; 219
    6962:	3f e0       	ldi	r19, 0x0F	; 15
    6964:	49 e4       	ldi	r20, 0x49	; 73
    6966:	50 fd       	sbrc	r21, 0
    6968:	49 ec       	ldi	r20, 0xC9	; 201
    696a:	63 cf       	rjmp	.-314    	; 0x6832 <__addsf3>
    696c:	08 95       	ret

0000696e <atan>:
    696e:	df 93       	push	r29
    6970:	dd 27       	eor	r29, r29
    6972:	b9 2f       	mov	r27, r25
    6974:	bf 77       	andi	r27, 0x7F	; 127
    6976:	40 e8       	ldi	r20, 0x80	; 128
    6978:	5f e3       	ldi	r21, 0x3F	; 63
    697a:	16 16       	cp	r1, r22
    697c:	17 06       	cpc	r1, r23
    697e:	48 07       	cpc	r20, r24
    6980:	5b 07       	cpc	r21, r27
    6982:	10 f4       	brcc	.+4      	; 0x6988 <atan+0x1a>
    6984:	d9 2f       	mov	r29, r25
    6986:	cf d1       	rcall	.+926    	; 0x6d26 <inverse>
    6988:	9f 93       	push	r25
    698a:	8f 93       	push	r24
    698c:	7f 93       	push	r23
    698e:	6f 93       	push	r22
    6990:	7c d2       	rcall	.+1272   	; 0x6e8a <square>
    6992:	e4 ee       	ldi	r30, 0xE4	; 228
    6994:	f0 e0       	ldi	r31, 0x00	; 0
    6996:	1d d1       	rcall	.+570    	; 0x6bd2 <__fp_powser>
    6998:	77 d1       	rcall	.+750    	; 0x6c88 <__fp_round>
    699a:	2f 91       	pop	r18
    699c:	3f 91       	pop	r19
    699e:	4f 91       	pop	r20
    69a0:	5f 91       	pop	r21
    69a2:	d4 d1       	rcall	.+936    	; 0x6d4c <__mulsf3x>
    69a4:	dd 23       	and	r29, r29
    69a6:	49 f0       	breq	.+18     	; 0x69ba <atan+0x4c>
    69a8:	90 58       	subi	r25, 0x80	; 128
    69aa:	a2 ea       	ldi	r26, 0xA2	; 162
    69ac:	2a ed       	ldi	r18, 0xDA	; 218
    69ae:	3f e0       	ldi	r19, 0x0F	; 15
    69b0:	49 ec       	ldi	r20, 0xC9	; 201
    69b2:	5f e3       	ldi	r21, 0x3F	; 63
    69b4:	d0 78       	andi	r29, 0x80	; 128
    69b6:	5d 27       	eor	r21, r29
    69b8:	4d df       	rcall	.-358    	; 0x6854 <__addsf3x>
    69ba:	df 91       	pop	r29
    69bc:	65 c1       	rjmp	.+714    	; 0x6c88 <__fp_round>

000069be <__cmpsf2>:
    69be:	dc d0       	rcall	.+440    	; 0x6b78 <__fp_cmp>
    69c0:	08 f4       	brcc	.+2      	; 0x69c4 <__cmpsf2+0x6>
    69c2:	81 e0       	ldi	r24, 0x01	; 1
    69c4:	08 95       	ret

000069c6 <cos>:
    69c6:	39 d1       	rcall	.+626    	; 0x6c3a <__fp_rempio2>
    69c8:	e3 95       	inc	r30
    69ca:	6f c1       	rjmp	.+734    	; 0x6caa <__fp_sinus>

000069cc <__divsf3>:
    69cc:	0c d0       	rcall	.+24     	; 0x69e6 <__divsf3x>
    69ce:	5c c1       	rjmp	.+696    	; 0x6c88 <__fp_round>
    69d0:	2c d1       	rcall	.+600    	; 0x6c2a <__fp_pscB>
    69d2:	40 f0       	brcs	.+16     	; 0x69e4 <__divsf3+0x18>
    69d4:	23 d1       	rcall	.+582    	; 0x6c1c <__fp_pscA>
    69d6:	30 f0       	brcs	.+12     	; 0x69e4 <__divsf3+0x18>
    69d8:	21 f4       	brne	.+8      	; 0x69e2 <__divsf3+0x16>
    69da:	5f 3f       	cpi	r21, 0xFF	; 255
    69dc:	19 f0       	breq	.+6      	; 0x69e4 <__divsf3+0x18>
    69de:	f0 c0       	rjmp	.+480    	; 0x6bc0 <__fp_inf>
    69e0:	51 11       	cpse	r21, r1
    69e2:	97 c1       	rjmp	.+814    	; 0x6d12 <__fp_szero>
    69e4:	f3 c0       	rjmp	.+486    	; 0x6bcc <__fp_nan>

000069e6 <__divsf3x>:
    69e6:	72 d1       	rcall	.+740    	; 0x6ccc <__fp_split3>
    69e8:	98 f3       	brcs	.-26     	; 0x69d0 <__divsf3+0x4>

000069ea <__divsf3_pse>:
    69ea:	99 23       	and	r25, r25
    69ec:	c9 f3       	breq	.-14     	; 0x69e0 <__divsf3+0x14>
    69ee:	55 23       	and	r21, r21
    69f0:	b1 f3       	breq	.-20     	; 0x69de <__divsf3+0x12>
    69f2:	95 1b       	sub	r25, r21
    69f4:	55 0b       	sbc	r21, r21
    69f6:	bb 27       	eor	r27, r27
    69f8:	aa 27       	eor	r26, r26
    69fa:	62 17       	cp	r22, r18
    69fc:	73 07       	cpc	r23, r19
    69fe:	84 07       	cpc	r24, r20
    6a00:	38 f0       	brcs	.+14     	; 0x6a10 <__divsf3_pse+0x26>
    6a02:	9f 5f       	subi	r25, 0xFF	; 255
    6a04:	5f 4f       	sbci	r21, 0xFF	; 255
    6a06:	22 0f       	add	r18, r18
    6a08:	33 1f       	adc	r19, r19
    6a0a:	44 1f       	adc	r20, r20
    6a0c:	aa 1f       	adc	r26, r26
    6a0e:	a9 f3       	breq	.-22     	; 0x69fa <__divsf3_pse+0x10>
    6a10:	33 d0       	rcall	.+102    	; 0x6a78 <__divsf3_pse+0x8e>
    6a12:	0e 2e       	mov	r0, r30
    6a14:	3a f0       	brmi	.+14     	; 0x6a24 <__divsf3_pse+0x3a>
    6a16:	e0 e8       	ldi	r30, 0x80	; 128
    6a18:	30 d0       	rcall	.+96     	; 0x6a7a <__divsf3_pse+0x90>
    6a1a:	91 50       	subi	r25, 0x01	; 1
    6a1c:	50 40       	sbci	r21, 0x00	; 0
    6a1e:	e6 95       	lsr	r30
    6a20:	00 1c       	adc	r0, r0
    6a22:	ca f7       	brpl	.-14     	; 0x6a16 <__divsf3_pse+0x2c>
    6a24:	29 d0       	rcall	.+82     	; 0x6a78 <__divsf3_pse+0x8e>
    6a26:	fe 2f       	mov	r31, r30
    6a28:	27 d0       	rcall	.+78     	; 0x6a78 <__divsf3_pse+0x8e>
    6a2a:	66 0f       	add	r22, r22
    6a2c:	77 1f       	adc	r23, r23
    6a2e:	88 1f       	adc	r24, r24
    6a30:	bb 1f       	adc	r27, r27
    6a32:	26 17       	cp	r18, r22
    6a34:	37 07       	cpc	r19, r23
    6a36:	48 07       	cpc	r20, r24
    6a38:	ab 07       	cpc	r26, r27
    6a3a:	b0 e8       	ldi	r27, 0x80	; 128
    6a3c:	09 f0       	breq	.+2      	; 0x6a40 <__divsf3_pse+0x56>
    6a3e:	bb 0b       	sbc	r27, r27
    6a40:	80 2d       	mov	r24, r0
    6a42:	bf 01       	movw	r22, r30
    6a44:	ff 27       	eor	r31, r31
    6a46:	93 58       	subi	r25, 0x83	; 131
    6a48:	5f 4f       	sbci	r21, 0xFF	; 255
    6a4a:	2a f0       	brmi	.+10     	; 0x6a56 <__divsf3_pse+0x6c>
    6a4c:	9e 3f       	cpi	r25, 0xFE	; 254
    6a4e:	51 05       	cpc	r21, r1
    6a50:	68 f0       	brcs	.+26     	; 0x6a6c <__divsf3_pse+0x82>
    6a52:	b6 c0       	rjmp	.+364    	; 0x6bc0 <__fp_inf>
    6a54:	5e c1       	rjmp	.+700    	; 0x6d12 <__fp_szero>
    6a56:	5f 3f       	cpi	r21, 0xFF	; 255
    6a58:	ec f3       	brlt	.-6      	; 0x6a54 <__divsf3_pse+0x6a>
    6a5a:	98 3e       	cpi	r25, 0xE8	; 232
    6a5c:	dc f3       	brlt	.-10     	; 0x6a54 <__divsf3_pse+0x6a>
    6a5e:	86 95       	lsr	r24
    6a60:	77 95       	ror	r23
    6a62:	67 95       	ror	r22
    6a64:	b7 95       	ror	r27
    6a66:	f7 95       	ror	r31
    6a68:	9f 5f       	subi	r25, 0xFF	; 255
    6a6a:	c9 f7       	brne	.-14     	; 0x6a5e <__divsf3_pse+0x74>
    6a6c:	88 0f       	add	r24, r24
    6a6e:	91 1d       	adc	r25, r1
    6a70:	96 95       	lsr	r25
    6a72:	87 95       	ror	r24
    6a74:	97 f9       	bld	r25, 7
    6a76:	08 95       	ret
    6a78:	e1 e0       	ldi	r30, 0x01	; 1
    6a7a:	66 0f       	add	r22, r22
    6a7c:	77 1f       	adc	r23, r23
    6a7e:	88 1f       	adc	r24, r24
    6a80:	bb 1f       	adc	r27, r27
    6a82:	62 17       	cp	r22, r18
    6a84:	73 07       	cpc	r23, r19
    6a86:	84 07       	cpc	r24, r20
    6a88:	ba 07       	cpc	r27, r26
    6a8a:	20 f0       	brcs	.+8      	; 0x6a94 <__divsf3_pse+0xaa>
    6a8c:	62 1b       	sub	r22, r18
    6a8e:	73 0b       	sbc	r23, r19
    6a90:	84 0b       	sbc	r24, r20
    6a92:	ba 0b       	sbc	r27, r26
    6a94:	ee 1f       	adc	r30, r30
    6a96:	88 f7       	brcc	.-30     	; 0x6a7a <__divsf3_pse+0x90>
    6a98:	e0 95       	com	r30
    6a9a:	08 95       	ret

00006a9c <__fixsfsi>:
    6a9c:	04 d0       	rcall	.+8      	; 0x6aa6 <__fixunssfsi>
    6a9e:	68 94       	set
    6aa0:	b1 11       	cpse	r27, r1
    6aa2:	37 c1       	rjmp	.+622    	; 0x6d12 <__fp_szero>
    6aa4:	08 95       	ret

00006aa6 <__fixunssfsi>:
    6aa6:	1a d1       	rcall	.+564    	; 0x6cdc <__fp_splitA>
    6aa8:	88 f0       	brcs	.+34     	; 0x6acc <__fixunssfsi+0x26>
    6aaa:	9f 57       	subi	r25, 0x7F	; 127
    6aac:	90 f0       	brcs	.+36     	; 0x6ad2 <__fixunssfsi+0x2c>
    6aae:	b9 2f       	mov	r27, r25
    6ab0:	99 27       	eor	r25, r25
    6ab2:	b7 51       	subi	r27, 0x17	; 23
    6ab4:	a0 f0       	brcs	.+40     	; 0x6ade <__fixunssfsi+0x38>
    6ab6:	d1 f0       	breq	.+52     	; 0x6aec <__fixunssfsi+0x46>
    6ab8:	66 0f       	add	r22, r22
    6aba:	77 1f       	adc	r23, r23
    6abc:	88 1f       	adc	r24, r24
    6abe:	99 1f       	adc	r25, r25
    6ac0:	1a f0       	brmi	.+6      	; 0x6ac8 <__fixunssfsi+0x22>
    6ac2:	ba 95       	dec	r27
    6ac4:	c9 f7       	brne	.-14     	; 0x6ab8 <__fixunssfsi+0x12>
    6ac6:	12 c0       	rjmp	.+36     	; 0x6aec <__fixunssfsi+0x46>
    6ac8:	b1 30       	cpi	r27, 0x01	; 1
    6aca:	81 f0       	breq	.+32     	; 0x6aec <__fixunssfsi+0x46>
    6acc:	21 d1       	rcall	.+578    	; 0x6d10 <__fp_zero>
    6ace:	b1 e0       	ldi	r27, 0x01	; 1
    6ad0:	08 95       	ret
    6ad2:	1e c1       	rjmp	.+572    	; 0x6d10 <__fp_zero>
    6ad4:	67 2f       	mov	r22, r23
    6ad6:	78 2f       	mov	r23, r24
    6ad8:	88 27       	eor	r24, r24
    6ada:	b8 5f       	subi	r27, 0xF8	; 248
    6adc:	39 f0       	breq	.+14     	; 0x6aec <__fixunssfsi+0x46>
    6ade:	b9 3f       	cpi	r27, 0xF9	; 249
    6ae0:	cc f3       	brlt	.-14     	; 0x6ad4 <__fixunssfsi+0x2e>
    6ae2:	86 95       	lsr	r24
    6ae4:	77 95       	ror	r23
    6ae6:	67 95       	ror	r22
    6ae8:	b3 95       	inc	r27
    6aea:	d9 f7       	brne	.-10     	; 0x6ae2 <__fixunssfsi+0x3c>
    6aec:	3e f4       	brtc	.+14     	; 0x6afc <__fixunssfsi+0x56>
    6aee:	90 95       	com	r25
    6af0:	80 95       	com	r24
    6af2:	70 95       	com	r23
    6af4:	61 95       	neg	r22
    6af6:	7f 4f       	sbci	r23, 0xFF	; 255
    6af8:	8f 4f       	sbci	r24, 0xFF	; 255
    6afa:	9f 4f       	sbci	r25, 0xFF	; 255
    6afc:	08 95       	ret

00006afe <__floatunsisf>:
    6afe:	e8 94       	clt
    6b00:	09 c0       	rjmp	.+18     	; 0x6b14 <__floatsisf+0x12>

00006b02 <__floatsisf>:
    6b02:	97 fb       	bst	r25, 7
    6b04:	3e f4       	brtc	.+14     	; 0x6b14 <__floatsisf+0x12>
    6b06:	90 95       	com	r25
    6b08:	80 95       	com	r24
    6b0a:	70 95       	com	r23
    6b0c:	61 95       	neg	r22
    6b0e:	7f 4f       	sbci	r23, 0xFF	; 255
    6b10:	8f 4f       	sbci	r24, 0xFF	; 255
    6b12:	9f 4f       	sbci	r25, 0xFF	; 255
    6b14:	99 23       	and	r25, r25
    6b16:	a9 f0       	breq	.+42     	; 0x6b42 <__floatsisf+0x40>
    6b18:	f9 2f       	mov	r31, r25
    6b1a:	96 e9       	ldi	r25, 0x96	; 150
    6b1c:	bb 27       	eor	r27, r27
    6b1e:	93 95       	inc	r25
    6b20:	f6 95       	lsr	r31
    6b22:	87 95       	ror	r24
    6b24:	77 95       	ror	r23
    6b26:	67 95       	ror	r22
    6b28:	b7 95       	ror	r27
    6b2a:	f1 11       	cpse	r31, r1
    6b2c:	f8 cf       	rjmp	.-16     	; 0x6b1e <__floatsisf+0x1c>
    6b2e:	fa f4       	brpl	.+62     	; 0x6b6e <__floatsisf+0x6c>
    6b30:	bb 0f       	add	r27, r27
    6b32:	11 f4       	brne	.+4      	; 0x6b38 <__floatsisf+0x36>
    6b34:	60 ff       	sbrs	r22, 0
    6b36:	1b c0       	rjmp	.+54     	; 0x6b6e <__floatsisf+0x6c>
    6b38:	6f 5f       	subi	r22, 0xFF	; 255
    6b3a:	7f 4f       	sbci	r23, 0xFF	; 255
    6b3c:	8f 4f       	sbci	r24, 0xFF	; 255
    6b3e:	9f 4f       	sbci	r25, 0xFF	; 255
    6b40:	16 c0       	rjmp	.+44     	; 0x6b6e <__floatsisf+0x6c>
    6b42:	88 23       	and	r24, r24
    6b44:	11 f0       	breq	.+4      	; 0x6b4a <__floatsisf+0x48>
    6b46:	96 e9       	ldi	r25, 0x96	; 150
    6b48:	11 c0       	rjmp	.+34     	; 0x6b6c <__floatsisf+0x6a>
    6b4a:	77 23       	and	r23, r23
    6b4c:	21 f0       	breq	.+8      	; 0x6b56 <__floatsisf+0x54>
    6b4e:	9e e8       	ldi	r25, 0x8E	; 142
    6b50:	87 2f       	mov	r24, r23
    6b52:	76 2f       	mov	r23, r22
    6b54:	05 c0       	rjmp	.+10     	; 0x6b60 <__floatsisf+0x5e>
    6b56:	66 23       	and	r22, r22
    6b58:	71 f0       	breq	.+28     	; 0x6b76 <__floatsisf+0x74>
    6b5a:	96 e8       	ldi	r25, 0x86	; 134
    6b5c:	86 2f       	mov	r24, r22
    6b5e:	70 e0       	ldi	r23, 0x00	; 0
    6b60:	60 e0       	ldi	r22, 0x00	; 0
    6b62:	2a f0       	brmi	.+10     	; 0x6b6e <__floatsisf+0x6c>
    6b64:	9a 95       	dec	r25
    6b66:	66 0f       	add	r22, r22
    6b68:	77 1f       	adc	r23, r23
    6b6a:	88 1f       	adc	r24, r24
    6b6c:	da f7       	brpl	.-10     	; 0x6b64 <__floatsisf+0x62>
    6b6e:	88 0f       	add	r24, r24
    6b70:	96 95       	lsr	r25
    6b72:	87 95       	ror	r24
    6b74:	97 f9       	bld	r25, 7
    6b76:	08 95       	ret

00006b78 <__fp_cmp>:
    6b78:	99 0f       	add	r25, r25
    6b7a:	00 08       	sbc	r0, r0
    6b7c:	55 0f       	add	r21, r21
    6b7e:	aa 0b       	sbc	r26, r26
    6b80:	e0 e8       	ldi	r30, 0x80	; 128
    6b82:	fe ef       	ldi	r31, 0xFE	; 254
    6b84:	16 16       	cp	r1, r22
    6b86:	17 06       	cpc	r1, r23
    6b88:	e8 07       	cpc	r30, r24
    6b8a:	f9 07       	cpc	r31, r25
    6b8c:	c0 f0       	brcs	.+48     	; 0x6bbe <__fp_cmp+0x46>
    6b8e:	12 16       	cp	r1, r18
    6b90:	13 06       	cpc	r1, r19
    6b92:	e4 07       	cpc	r30, r20
    6b94:	f5 07       	cpc	r31, r21
    6b96:	98 f0       	brcs	.+38     	; 0x6bbe <__fp_cmp+0x46>
    6b98:	62 1b       	sub	r22, r18
    6b9a:	73 0b       	sbc	r23, r19
    6b9c:	84 0b       	sbc	r24, r20
    6b9e:	95 0b       	sbc	r25, r21
    6ba0:	39 f4       	brne	.+14     	; 0x6bb0 <__fp_cmp+0x38>
    6ba2:	0a 26       	eor	r0, r26
    6ba4:	61 f0       	breq	.+24     	; 0x6bbe <__fp_cmp+0x46>
    6ba6:	23 2b       	or	r18, r19
    6ba8:	24 2b       	or	r18, r20
    6baa:	25 2b       	or	r18, r21
    6bac:	21 f4       	brne	.+8      	; 0x6bb6 <__fp_cmp+0x3e>
    6bae:	08 95       	ret
    6bb0:	0a 26       	eor	r0, r26
    6bb2:	09 f4       	brne	.+2      	; 0x6bb6 <__fp_cmp+0x3e>
    6bb4:	a1 40       	sbci	r26, 0x01	; 1
    6bb6:	a6 95       	lsr	r26
    6bb8:	8f ef       	ldi	r24, 0xFF	; 255
    6bba:	81 1d       	adc	r24, r1
    6bbc:	81 1d       	adc	r24, r1
    6bbe:	08 95       	ret

00006bc0 <__fp_inf>:
    6bc0:	97 f9       	bld	r25, 7
    6bc2:	9f 67       	ori	r25, 0x7F	; 127
    6bc4:	80 e8       	ldi	r24, 0x80	; 128
    6bc6:	70 e0       	ldi	r23, 0x00	; 0
    6bc8:	60 e0       	ldi	r22, 0x00	; 0
    6bca:	08 95       	ret

00006bcc <__fp_nan>:
    6bcc:	9f ef       	ldi	r25, 0xFF	; 255
    6bce:	80 ec       	ldi	r24, 0xC0	; 192
    6bd0:	08 95       	ret

00006bd2 <__fp_powser>:
    6bd2:	df 93       	push	r29
    6bd4:	cf 93       	push	r28
    6bd6:	1f 93       	push	r17
    6bd8:	0f 93       	push	r16
    6bda:	ff 92       	push	r15
    6bdc:	ef 92       	push	r14
    6bde:	df 92       	push	r13
    6be0:	7b 01       	movw	r14, r22
    6be2:	8c 01       	movw	r16, r24
    6be4:	68 94       	set
    6be6:	05 c0       	rjmp	.+10     	; 0x6bf2 <__fp_powser+0x20>
    6be8:	da 2e       	mov	r13, r26
    6bea:	ef 01       	movw	r28, r30
    6bec:	af d0       	rcall	.+350    	; 0x6d4c <__mulsf3x>
    6bee:	fe 01       	movw	r30, r28
    6bf0:	e8 94       	clt
    6bf2:	a5 91       	lpm	r26, Z+
    6bf4:	25 91       	lpm	r18, Z+
    6bf6:	35 91       	lpm	r19, Z+
    6bf8:	45 91       	lpm	r20, Z+
    6bfa:	55 91       	lpm	r21, Z+
    6bfc:	ae f3       	brts	.-22     	; 0x6be8 <__fp_powser+0x16>
    6bfe:	ef 01       	movw	r28, r30
    6c00:	29 de       	rcall	.-942    	; 0x6854 <__addsf3x>
    6c02:	fe 01       	movw	r30, r28
    6c04:	97 01       	movw	r18, r14
    6c06:	a8 01       	movw	r20, r16
    6c08:	da 94       	dec	r13
    6c0a:	79 f7       	brne	.-34     	; 0x6bea <__fp_powser+0x18>
    6c0c:	df 90       	pop	r13
    6c0e:	ef 90       	pop	r14
    6c10:	ff 90       	pop	r15
    6c12:	0f 91       	pop	r16
    6c14:	1f 91       	pop	r17
    6c16:	cf 91       	pop	r28
    6c18:	df 91       	pop	r29
    6c1a:	08 95       	ret

00006c1c <__fp_pscA>:
    6c1c:	00 24       	eor	r0, r0
    6c1e:	0a 94       	dec	r0
    6c20:	16 16       	cp	r1, r22
    6c22:	17 06       	cpc	r1, r23
    6c24:	18 06       	cpc	r1, r24
    6c26:	09 06       	cpc	r0, r25
    6c28:	08 95       	ret

00006c2a <__fp_pscB>:
    6c2a:	00 24       	eor	r0, r0
    6c2c:	0a 94       	dec	r0
    6c2e:	12 16       	cp	r1, r18
    6c30:	13 06       	cpc	r1, r19
    6c32:	14 06       	cpc	r1, r20
    6c34:	05 06       	cpc	r0, r21
    6c36:	08 95       	ret
    6c38:	c9 cf       	rjmp	.-110    	; 0x6bcc <__fp_nan>

00006c3a <__fp_rempio2>:
    6c3a:	50 d0       	rcall	.+160    	; 0x6cdc <__fp_splitA>
    6c3c:	e8 f3       	brcs	.-6      	; 0x6c38 <__fp_pscB+0xe>
    6c3e:	e8 94       	clt
    6c40:	e0 e0       	ldi	r30, 0x00	; 0
    6c42:	bb 27       	eor	r27, r27
    6c44:	9f 57       	subi	r25, 0x7F	; 127
    6c46:	f0 f0       	brcs	.+60     	; 0x6c84 <__fp_rempio2+0x4a>
    6c48:	2a ed       	ldi	r18, 0xDA	; 218
    6c4a:	3f e0       	ldi	r19, 0x0F	; 15
    6c4c:	49 ec       	ldi	r20, 0xC9	; 201
    6c4e:	06 c0       	rjmp	.+12     	; 0x6c5c <__fp_rempio2+0x22>
    6c50:	ee 0f       	add	r30, r30
    6c52:	bb 0f       	add	r27, r27
    6c54:	66 1f       	adc	r22, r22
    6c56:	77 1f       	adc	r23, r23
    6c58:	88 1f       	adc	r24, r24
    6c5a:	28 f0       	brcs	.+10     	; 0x6c66 <__fp_rempio2+0x2c>
    6c5c:	b2 3a       	cpi	r27, 0xA2	; 162
    6c5e:	62 07       	cpc	r22, r18
    6c60:	73 07       	cpc	r23, r19
    6c62:	84 07       	cpc	r24, r20
    6c64:	28 f0       	brcs	.+10     	; 0x6c70 <__fp_rempio2+0x36>
    6c66:	b2 5a       	subi	r27, 0xA2	; 162
    6c68:	62 0b       	sbc	r22, r18
    6c6a:	73 0b       	sbc	r23, r19
    6c6c:	84 0b       	sbc	r24, r20
    6c6e:	e3 95       	inc	r30
    6c70:	9a 95       	dec	r25
    6c72:	72 f7       	brpl	.-36     	; 0x6c50 <__fp_rempio2+0x16>
    6c74:	80 38       	cpi	r24, 0x80	; 128
    6c76:	30 f4       	brcc	.+12     	; 0x6c84 <__fp_rempio2+0x4a>
    6c78:	9a 95       	dec	r25
    6c7a:	bb 0f       	add	r27, r27
    6c7c:	66 1f       	adc	r22, r22
    6c7e:	77 1f       	adc	r23, r23
    6c80:	88 1f       	adc	r24, r24
    6c82:	d2 f7       	brpl	.-12     	; 0x6c78 <__fp_rempio2+0x3e>
    6c84:	90 48       	sbci	r25, 0x80	; 128
    6c86:	06 c1       	rjmp	.+524    	; 0x6e94 <__fp_mpack_finite>

00006c88 <__fp_round>:
    6c88:	09 2e       	mov	r0, r25
    6c8a:	03 94       	inc	r0
    6c8c:	00 0c       	add	r0, r0
    6c8e:	11 f4       	brne	.+4      	; 0x6c94 <__fp_round+0xc>
    6c90:	88 23       	and	r24, r24
    6c92:	52 f0       	brmi	.+20     	; 0x6ca8 <__fp_round+0x20>
    6c94:	bb 0f       	add	r27, r27
    6c96:	40 f4       	brcc	.+16     	; 0x6ca8 <__fp_round+0x20>
    6c98:	bf 2b       	or	r27, r31
    6c9a:	11 f4       	brne	.+4      	; 0x6ca0 <__fp_round+0x18>
    6c9c:	60 ff       	sbrs	r22, 0
    6c9e:	04 c0       	rjmp	.+8      	; 0x6ca8 <__fp_round+0x20>
    6ca0:	6f 5f       	subi	r22, 0xFF	; 255
    6ca2:	7f 4f       	sbci	r23, 0xFF	; 255
    6ca4:	8f 4f       	sbci	r24, 0xFF	; 255
    6ca6:	9f 4f       	sbci	r25, 0xFF	; 255
    6ca8:	08 95       	ret

00006caa <__fp_sinus>:
    6caa:	ef 93       	push	r30
    6cac:	e0 ff       	sbrs	r30, 0
    6cae:	06 c0       	rjmp	.+12     	; 0x6cbc <__fp_sinus+0x12>
    6cb0:	a2 ea       	ldi	r26, 0xA2	; 162
    6cb2:	2a ed       	ldi	r18, 0xDA	; 218
    6cb4:	3f e0       	ldi	r19, 0x0F	; 15
    6cb6:	49 ec       	ldi	r20, 0xC9	; 201
    6cb8:	5f eb       	ldi	r21, 0xBF	; 191
    6cba:	cc dd       	rcall	.-1128   	; 0x6854 <__addsf3x>
    6cbc:	e5 df       	rcall	.-54     	; 0x6c88 <__fp_round>
    6cbe:	0f 90       	pop	r0
    6cc0:	03 94       	inc	r0
    6cc2:	01 fc       	sbrc	r0, 1
    6cc4:	90 58       	subi	r25, 0x80	; 128
    6cc6:	e1 e1       	ldi	r30, 0x11	; 17
    6cc8:	f1 e0       	ldi	r31, 0x01	; 1
    6cca:	f7 c0       	rjmp	.+494    	; 0x6eba <__fp_powsodd>

00006ccc <__fp_split3>:
    6ccc:	57 fd       	sbrc	r21, 7
    6cce:	90 58       	subi	r25, 0x80	; 128
    6cd0:	44 0f       	add	r20, r20
    6cd2:	55 1f       	adc	r21, r21
    6cd4:	59 f0       	breq	.+22     	; 0x6cec <__fp_splitA+0x10>
    6cd6:	5f 3f       	cpi	r21, 0xFF	; 255
    6cd8:	71 f0       	breq	.+28     	; 0x6cf6 <__fp_splitA+0x1a>
    6cda:	47 95       	ror	r20

00006cdc <__fp_splitA>:
    6cdc:	88 0f       	add	r24, r24
    6cde:	97 fb       	bst	r25, 7
    6ce0:	99 1f       	adc	r25, r25
    6ce2:	61 f0       	breq	.+24     	; 0x6cfc <__fp_splitA+0x20>
    6ce4:	9f 3f       	cpi	r25, 0xFF	; 255
    6ce6:	79 f0       	breq	.+30     	; 0x6d06 <__fp_splitA+0x2a>
    6ce8:	87 95       	ror	r24
    6cea:	08 95       	ret
    6cec:	12 16       	cp	r1, r18
    6cee:	13 06       	cpc	r1, r19
    6cf0:	14 06       	cpc	r1, r20
    6cf2:	55 1f       	adc	r21, r21
    6cf4:	f2 cf       	rjmp	.-28     	; 0x6cda <__fp_split3+0xe>
    6cf6:	46 95       	lsr	r20
    6cf8:	f1 df       	rcall	.-30     	; 0x6cdc <__fp_splitA>
    6cfa:	08 c0       	rjmp	.+16     	; 0x6d0c <__fp_splitA+0x30>
    6cfc:	16 16       	cp	r1, r22
    6cfe:	17 06       	cpc	r1, r23
    6d00:	18 06       	cpc	r1, r24
    6d02:	99 1f       	adc	r25, r25
    6d04:	f1 cf       	rjmp	.-30     	; 0x6ce8 <__fp_splitA+0xc>
    6d06:	86 95       	lsr	r24
    6d08:	71 05       	cpc	r23, r1
    6d0a:	61 05       	cpc	r22, r1
    6d0c:	08 94       	sec
    6d0e:	08 95       	ret

00006d10 <__fp_zero>:
    6d10:	e8 94       	clt

00006d12 <__fp_szero>:
    6d12:	bb 27       	eor	r27, r27
    6d14:	66 27       	eor	r22, r22
    6d16:	77 27       	eor	r23, r23
    6d18:	cb 01       	movw	r24, r22
    6d1a:	97 f9       	bld	r25, 7
    6d1c:	08 95       	ret

00006d1e <__gesf2>:
    6d1e:	2c df       	rcall	.-424    	; 0x6b78 <__fp_cmp>
    6d20:	08 f4       	brcc	.+2      	; 0x6d24 <__gesf2+0x6>
    6d22:	8f ef       	ldi	r24, 0xFF	; 255
    6d24:	08 95       	ret

00006d26 <inverse>:
    6d26:	9b 01       	movw	r18, r22
    6d28:	ac 01       	movw	r20, r24
    6d2a:	60 e0       	ldi	r22, 0x00	; 0
    6d2c:	70 e0       	ldi	r23, 0x00	; 0
    6d2e:	80 e8       	ldi	r24, 0x80	; 128
    6d30:	9f e3       	ldi	r25, 0x3F	; 63
    6d32:	4c ce       	rjmp	.-872    	; 0x69cc <__divsf3>

00006d34 <__mulsf3>:
    6d34:	0b d0       	rcall	.+22     	; 0x6d4c <__mulsf3x>
    6d36:	a8 cf       	rjmp	.-176    	; 0x6c88 <__fp_round>
    6d38:	71 df       	rcall	.-286    	; 0x6c1c <__fp_pscA>
    6d3a:	28 f0       	brcs	.+10     	; 0x6d46 <__mulsf3+0x12>
    6d3c:	76 df       	rcall	.-276    	; 0x6c2a <__fp_pscB>
    6d3e:	18 f0       	brcs	.+6      	; 0x6d46 <__mulsf3+0x12>
    6d40:	95 23       	and	r25, r21
    6d42:	09 f0       	breq	.+2      	; 0x6d46 <__mulsf3+0x12>
    6d44:	3d cf       	rjmp	.-390    	; 0x6bc0 <__fp_inf>
    6d46:	42 cf       	rjmp	.-380    	; 0x6bcc <__fp_nan>
    6d48:	11 24       	eor	r1, r1
    6d4a:	e3 cf       	rjmp	.-58     	; 0x6d12 <__fp_szero>

00006d4c <__mulsf3x>:
    6d4c:	bf df       	rcall	.-130    	; 0x6ccc <__fp_split3>
    6d4e:	a0 f3       	brcs	.-24     	; 0x6d38 <__mulsf3+0x4>

00006d50 <__mulsf3_pse>:
    6d50:	95 9f       	mul	r25, r21
    6d52:	d1 f3       	breq	.-12     	; 0x6d48 <__mulsf3+0x14>
    6d54:	95 0f       	add	r25, r21
    6d56:	50 e0       	ldi	r21, 0x00	; 0
    6d58:	55 1f       	adc	r21, r21
    6d5a:	62 9f       	mul	r22, r18
    6d5c:	f0 01       	movw	r30, r0
    6d5e:	72 9f       	mul	r23, r18
    6d60:	bb 27       	eor	r27, r27
    6d62:	f0 0d       	add	r31, r0
    6d64:	b1 1d       	adc	r27, r1
    6d66:	63 9f       	mul	r22, r19
    6d68:	aa 27       	eor	r26, r26
    6d6a:	f0 0d       	add	r31, r0
    6d6c:	b1 1d       	adc	r27, r1
    6d6e:	aa 1f       	adc	r26, r26
    6d70:	64 9f       	mul	r22, r20
    6d72:	66 27       	eor	r22, r22
    6d74:	b0 0d       	add	r27, r0
    6d76:	a1 1d       	adc	r26, r1
    6d78:	66 1f       	adc	r22, r22
    6d7a:	82 9f       	mul	r24, r18
    6d7c:	22 27       	eor	r18, r18
    6d7e:	b0 0d       	add	r27, r0
    6d80:	a1 1d       	adc	r26, r1
    6d82:	62 1f       	adc	r22, r18
    6d84:	73 9f       	mul	r23, r19
    6d86:	b0 0d       	add	r27, r0
    6d88:	a1 1d       	adc	r26, r1
    6d8a:	62 1f       	adc	r22, r18
    6d8c:	83 9f       	mul	r24, r19
    6d8e:	a0 0d       	add	r26, r0
    6d90:	61 1d       	adc	r22, r1
    6d92:	22 1f       	adc	r18, r18
    6d94:	74 9f       	mul	r23, r20
    6d96:	33 27       	eor	r19, r19
    6d98:	a0 0d       	add	r26, r0
    6d9a:	61 1d       	adc	r22, r1
    6d9c:	23 1f       	adc	r18, r19
    6d9e:	84 9f       	mul	r24, r20
    6da0:	60 0d       	add	r22, r0
    6da2:	21 1d       	adc	r18, r1
    6da4:	82 2f       	mov	r24, r18
    6da6:	76 2f       	mov	r23, r22
    6da8:	6a 2f       	mov	r22, r26
    6daa:	11 24       	eor	r1, r1
    6dac:	9f 57       	subi	r25, 0x7F	; 127
    6dae:	50 40       	sbci	r21, 0x00	; 0
    6db0:	8a f0       	brmi	.+34     	; 0x6dd4 <__mulsf3_pse+0x84>
    6db2:	e1 f0       	breq	.+56     	; 0x6dec <__mulsf3_pse+0x9c>
    6db4:	88 23       	and	r24, r24
    6db6:	4a f0       	brmi	.+18     	; 0x6dca <__mulsf3_pse+0x7a>
    6db8:	ee 0f       	add	r30, r30
    6dba:	ff 1f       	adc	r31, r31
    6dbc:	bb 1f       	adc	r27, r27
    6dbe:	66 1f       	adc	r22, r22
    6dc0:	77 1f       	adc	r23, r23
    6dc2:	88 1f       	adc	r24, r24
    6dc4:	91 50       	subi	r25, 0x01	; 1
    6dc6:	50 40       	sbci	r21, 0x00	; 0
    6dc8:	a9 f7       	brne	.-22     	; 0x6db4 <__mulsf3_pse+0x64>
    6dca:	9e 3f       	cpi	r25, 0xFE	; 254
    6dcc:	51 05       	cpc	r21, r1
    6dce:	70 f0       	brcs	.+28     	; 0x6dec <__mulsf3_pse+0x9c>
    6dd0:	f7 ce       	rjmp	.-530    	; 0x6bc0 <__fp_inf>
    6dd2:	9f cf       	rjmp	.-194    	; 0x6d12 <__fp_szero>
    6dd4:	5f 3f       	cpi	r21, 0xFF	; 255
    6dd6:	ec f3       	brlt	.-6      	; 0x6dd2 <__mulsf3_pse+0x82>
    6dd8:	98 3e       	cpi	r25, 0xE8	; 232
    6dda:	dc f3       	brlt	.-10     	; 0x6dd2 <__mulsf3_pse+0x82>
    6ddc:	86 95       	lsr	r24
    6dde:	77 95       	ror	r23
    6de0:	67 95       	ror	r22
    6de2:	b7 95       	ror	r27
    6de4:	f7 95       	ror	r31
    6de6:	e7 95       	ror	r30
    6de8:	9f 5f       	subi	r25, 0xFF	; 255
    6dea:	c1 f7       	brne	.-16     	; 0x6ddc <__mulsf3_pse+0x8c>
    6dec:	fe 2b       	or	r31, r30
    6dee:	88 0f       	add	r24, r24
    6df0:	91 1d       	adc	r25, r1
    6df2:	96 95       	lsr	r25
    6df4:	87 95       	ror	r24
    6df6:	97 f9       	bld	r25, 7
    6df8:	08 95       	ret

00006dfa <sin>:
    6dfa:	9f 93       	push	r25
    6dfc:	1e df       	rcall	.-452    	; 0x6c3a <__fp_rempio2>
    6dfe:	0f 90       	pop	r0
    6e00:	07 fc       	sbrc	r0, 7
    6e02:	ee 5f       	subi	r30, 0xFE	; 254
    6e04:	52 cf       	rjmp	.-348    	; 0x6caa <__fp_sinus>
    6e06:	11 f4       	brne	.+4      	; 0x6e0c <sin+0x12>
    6e08:	0e f4       	brtc	.+2      	; 0x6e0c <sin+0x12>
    6e0a:	e0 ce       	rjmp	.-576    	; 0x6bcc <__fp_nan>
    6e0c:	41 c0       	rjmp	.+130    	; 0x6e90 <__fp_mpack>

00006e0e <sqrt>:
    6e0e:	66 df       	rcall	.-308    	; 0x6cdc <__fp_splitA>
    6e10:	d0 f3       	brcs	.-12     	; 0x6e06 <sin+0xc>
    6e12:	99 23       	and	r25, r25
    6e14:	d9 f3       	breq	.-10     	; 0x6e0c <sin+0x12>
    6e16:	ce f3       	brts	.-14     	; 0x6e0a <sin+0x10>
    6e18:	9f 57       	subi	r25, 0x7F	; 127
    6e1a:	55 0b       	sbc	r21, r21
    6e1c:	87 ff       	sbrs	r24, 7
    6e1e:	46 d0       	rcall	.+140    	; 0x6eac <__fp_norm2>
    6e20:	00 24       	eor	r0, r0
    6e22:	a0 e6       	ldi	r26, 0x60	; 96
    6e24:	40 ea       	ldi	r20, 0xA0	; 160
    6e26:	90 01       	movw	r18, r0
    6e28:	80 58       	subi	r24, 0x80	; 128
    6e2a:	56 95       	lsr	r21
    6e2c:	97 95       	ror	r25
    6e2e:	28 f4       	brcc	.+10     	; 0x6e3a <sqrt+0x2c>
    6e30:	80 5c       	subi	r24, 0xC0	; 192
    6e32:	66 0f       	add	r22, r22
    6e34:	77 1f       	adc	r23, r23
    6e36:	88 1f       	adc	r24, r24
    6e38:	20 f0       	brcs	.+8      	; 0x6e42 <sqrt+0x34>
    6e3a:	26 17       	cp	r18, r22
    6e3c:	37 07       	cpc	r19, r23
    6e3e:	48 07       	cpc	r20, r24
    6e40:	30 f4       	brcc	.+12     	; 0x6e4e <sqrt+0x40>
    6e42:	62 1b       	sub	r22, r18
    6e44:	73 0b       	sbc	r23, r19
    6e46:	84 0b       	sbc	r24, r20
    6e48:	20 29       	or	r18, r0
    6e4a:	31 29       	or	r19, r1
    6e4c:	4a 2b       	or	r20, r26
    6e4e:	a6 95       	lsr	r26
    6e50:	17 94       	ror	r1
    6e52:	07 94       	ror	r0
    6e54:	20 25       	eor	r18, r0
    6e56:	31 25       	eor	r19, r1
    6e58:	4a 27       	eor	r20, r26
    6e5a:	58 f7       	brcc	.-42     	; 0x6e32 <sqrt+0x24>
    6e5c:	66 0f       	add	r22, r22
    6e5e:	77 1f       	adc	r23, r23
    6e60:	88 1f       	adc	r24, r24
    6e62:	20 f0       	brcs	.+8      	; 0x6e6c <sqrt+0x5e>
    6e64:	26 17       	cp	r18, r22
    6e66:	37 07       	cpc	r19, r23
    6e68:	48 07       	cpc	r20, r24
    6e6a:	30 f4       	brcc	.+12     	; 0x6e78 <sqrt+0x6a>
    6e6c:	62 0b       	sbc	r22, r18
    6e6e:	73 0b       	sbc	r23, r19
    6e70:	84 0b       	sbc	r24, r20
    6e72:	20 0d       	add	r18, r0
    6e74:	31 1d       	adc	r19, r1
    6e76:	41 1d       	adc	r20, r1
    6e78:	a0 95       	com	r26
    6e7a:	81 f7       	brne	.-32     	; 0x6e5c <sqrt+0x4e>
    6e7c:	b9 01       	movw	r22, r18
    6e7e:	84 2f       	mov	r24, r20
    6e80:	91 58       	subi	r25, 0x81	; 129
    6e82:	88 0f       	add	r24, r24
    6e84:	96 95       	lsr	r25
    6e86:	87 95       	ror	r24
    6e88:	08 95       	ret

00006e8a <square>:
    6e8a:	9b 01       	movw	r18, r22
    6e8c:	ac 01       	movw	r20, r24
    6e8e:	52 cf       	rjmp	.-348    	; 0x6d34 <__mulsf3>

00006e90 <__fp_mpack>:
    6e90:	9f 3f       	cpi	r25, 0xFF	; 255
    6e92:	31 f0       	breq	.+12     	; 0x6ea0 <__fp_mpack_finite+0xc>

00006e94 <__fp_mpack_finite>:
    6e94:	91 50       	subi	r25, 0x01	; 1
    6e96:	20 f4       	brcc	.+8      	; 0x6ea0 <__fp_mpack_finite+0xc>
    6e98:	87 95       	ror	r24
    6e9a:	77 95       	ror	r23
    6e9c:	67 95       	ror	r22
    6e9e:	b7 95       	ror	r27
    6ea0:	88 0f       	add	r24, r24
    6ea2:	91 1d       	adc	r25, r1
    6ea4:	96 95       	lsr	r25
    6ea6:	87 95       	ror	r24
    6ea8:	97 f9       	bld	r25, 7
    6eaa:	08 95       	ret

00006eac <__fp_norm2>:
    6eac:	91 50       	subi	r25, 0x01	; 1
    6eae:	50 40       	sbci	r21, 0x00	; 0
    6eb0:	66 0f       	add	r22, r22
    6eb2:	77 1f       	adc	r23, r23
    6eb4:	88 1f       	adc	r24, r24
    6eb6:	d2 f7       	brpl	.-12     	; 0x6eac <__fp_norm2>
    6eb8:	08 95       	ret

00006eba <__fp_powsodd>:
    6eba:	9f 93       	push	r25
    6ebc:	8f 93       	push	r24
    6ebe:	7f 93       	push	r23
    6ec0:	6f 93       	push	r22
    6ec2:	ff 93       	push	r31
    6ec4:	ef 93       	push	r30
    6ec6:	9b 01       	movw	r18, r22
    6ec8:	ac 01       	movw	r20, r24
    6eca:	34 df       	rcall	.-408    	; 0x6d34 <__mulsf3>
    6ecc:	ef 91       	pop	r30
    6ece:	ff 91       	pop	r31
    6ed0:	80 de       	rcall	.-768    	; 0x6bd2 <__fp_powser>
    6ed2:	2f 91       	pop	r18
    6ed4:	3f 91       	pop	r19
    6ed6:	4f 91       	pop	r20
    6ed8:	5f 91       	pop	r21
    6eda:	2c cf       	rjmp	.-424    	; 0x6d34 <__mulsf3>

00006edc <vfprintf>:
    6edc:	2f 92       	push	r2
    6ede:	3f 92       	push	r3
    6ee0:	4f 92       	push	r4
    6ee2:	5f 92       	push	r5
    6ee4:	6f 92       	push	r6
    6ee6:	7f 92       	push	r7
    6ee8:	8f 92       	push	r8
    6eea:	9f 92       	push	r9
    6eec:	af 92       	push	r10
    6eee:	bf 92       	push	r11
    6ef0:	cf 92       	push	r12
    6ef2:	df 92       	push	r13
    6ef4:	ef 92       	push	r14
    6ef6:	ff 92       	push	r15
    6ef8:	0f 93       	push	r16
    6efa:	1f 93       	push	r17
    6efc:	cf 93       	push	r28
    6efe:	df 93       	push	r29
    6f00:	cd b7       	in	r28, 0x3d	; 61
    6f02:	de b7       	in	r29, 0x3e	; 62
    6f04:	60 97       	sbiw	r28, 0x10	; 16
    6f06:	0f b6       	in	r0, 0x3f	; 63
    6f08:	f8 94       	cli
    6f0a:	de bf       	out	0x3e, r29	; 62
    6f0c:	0f be       	out	0x3f, r0	; 63
    6f0e:	cd bf       	out	0x3d, r28	; 61
    6f10:	7c 01       	movw	r14, r24
    6f12:	1b 01       	movw	r2, r22
    6f14:	6a 01       	movw	r12, r20
    6f16:	fc 01       	movw	r30, r24
    6f18:	17 82       	std	Z+7, r1	; 0x07
    6f1a:	16 82       	std	Z+6, r1	; 0x06
    6f1c:	83 81       	ldd	r24, Z+3	; 0x03
    6f1e:	81 ff       	sbrs	r24, 1
    6f20:	2a c3       	rjmp	.+1620   	; 0x7576 <vfprintf+0x69a>
    6f22:	9e 01       	movw	r18, r28
    6f24:	2f 5f       	subi	r18, 0xFF	; 255
    6f26:	3f 4f       	sbci	r19, 0xFF	; 255
    6f28:	39 01       	movw	r6, r18
    6f2a:	f7 01       	movw	r30, r14
    6f2c:	93 81       	ldd	r25, Z+3	; 0x03
    6f2e:	f1 01       	movw	r30, r2
    6f30:	93 fd       	sbrc	r25, 3
    6f32:	85 91       	lpm	r24, Z+
    6f34:	93 ff       	sbrs	r25, 3
    6f36:	81 91       	ld	r24, Z+
    6f38:	1f 01       	movw	r2, r30
    6f3a:	88 23       	and	r24, r24
    6f3c:	09 f4       	brne	.+2      	; 0x6f40 <vfprintf+0x64>
    6f3e:	17 c3       	rjmp	.+1582   	; 0x756e <vfprintf+0x692>
    6f40:	85 32       	cpi	r24, 0x25	; 37
    6f42:	39 f4       	brne	.+14     	; 0x6f52 <vfprintf+0x76>
    6f44:	93 fd       	sbrc	r25, 3
    6f46:	85 91       	lpm	r24, Z+
    6f48:	93 ff       	sbrs	r25, 3
    6f4a:	81 91       	ld	r24, Z+
    6f4c:	1f 01       	movw	r2, r30
    6f4e:	85 32       	cpi	r24, 0x25	; 37
    6f50:	31 f4       	brne	.+12     	; 0x6f5e <vfprintf+0x82>
    6f52:	b7 01       	movw	r22, r14
    6f54:	90 e0       	ldi	r25, 0x00	; 0
    6f56:	7f d4       	rcall	.+2302   	; 0x7856 <fputc>
    6f58:	56 01       	movw	r10, r12
    6f5a:	65 01       	movw	r12, r10
    6f5c:	e6 cf       	rjmp	.-52     	; 0x6f2a <vfprintf+0x4e>
    6f5e:	10 e0       	ldi	r17, 0x00	; 0
    6f60:	51 2c       	mov	r5, r1
    6f62:	91 2c       	mov	r9, r1
    6f64:	ff e1       	ldi	r31, 0x1F	; 31
    6f66:	f9 15       	cp	r31, r9
    6f68:	d8 f0       	brcs	.+54     	; 0x6fa0 <vfprintf+0xc4>
    6f6a:	8b 32       	cpi	r24, 0x2B	; 43
    6f6c:	79 f0       	breq	.+30     	; 0x6f8c <vfprintf+0xb0>
    6f6e:	38 f4       	brcc	.+14     	; 0x6f7e <vfprintf+0xa2>
    6f70:	80 32       	cpi	r24, 0x20	; 32
    6f72:	79 f0       	breq	.+30     	; 0x6f92 <vfprintf+0xb6>
    6f74:	83 32       	cpi	r24, 0x23	; 35
    6f76:	a1 f4       	brne	.+40     	; 0x6fa0 <vfprintf+0xc4>
    6f78:	f9 2d       	mov	r31, r9
    6f7a:	f0 61       	ori	r31, 0x10	; 16
    6f7c:	2e c0       	rjmp	.+92     	; 0x6fda <vfprintf+0xfe>
    6f7e:	8d 32       	cpi	r24, 0x2D	; 45
    6f80:	61 f0       	breq	.+24     	; 0x6f9a <vfprintf+0xbe>
    6f82:	80 33       	cpi	r24, 0x30	; 48
    6f84:	69 f4       	brne	.+26     	; 0x6fa0 <vfprintf+0xc4>
    6f86:	29 2d       	mov	r18, r9
    6f88:	21 60       	ori	r18, 0x01	; 1
    6f8a:	2d c0       	rjmp	.+90     	; 0x6fe6 <vfprintf+0x10a>
    6f8c:	39 2d       	mov	r19, r9
    6f8e:	32 60       	ori	r19, 0x02	; 2
    6f90:	93 2e       	mov	r9, r19
    6f92:	89 2d       	mov	r24, r9
    6f94:	84 60       	ori	r24, 0x04	; 4
    6f96:	98 2e       	mov	r9, r24
    6f98:	2a c0       	rjmp	.+84     	; 0x6fee <vfprintf+0x112>
    6f9a:	e9 2d       	mov	r30, r9
    6f9c:	e8 60       	ori	r30, 0x08	; 8
    6f9e:	15 c0       	rjmp	.+42     	; 0x6fca <vfprintf+0xee>
    6fa0:	97 fc       	sbrc	r9, 7
    6fa2:	2d c0       	rjmp	.+90     	; 0x6ffe <vfprintf+0x122>
    6fa4:	20 ed       	ldi	r18, 0xD0	; 208
    6fa6:	28 0f       	add	r18, r24
    6fa8:	2a 30       	cpi	r18, 0x0A	; 10
    6faa:	88 f4       	brcc	.+34     	; 0x6fce <vfprintf+0xf2>
    6fac:	96 fe       	sbrs	r9, 6
    6fae:	06 c0       	rjmp	.+12     	; 0x6fbc <vfprintf+0xe0>
    6fb0:	3a e0       	ldi	r19, 0x0A	; 10
    6fb2:	13 9f       	mul	r17, r19
    6fb4:	20 0d       	add	r18, r0
    6fb6:	11 24       	eor	r1, r1
    6fb8:	12 2f       	mov	r17, r18
    6fba:	19 c0       	rjmp	.+50     	; 0x6fee <vfprintf+0x112>
    6fbc:	8a e0       	ldi	r24, 0x0A	; 10
    6fbe:	58 9e       	mul	r5, r24
    6fc0:	20 0d       	add	r18, r0
    6fc2:	11 24       	eor	r1, r1
    6fc4:	52 2e       	mov	r5, r18
    6fc6:	e9 2d       	mov	r30, r9
    6fc8:	e0 62       	ori	r30, 0x20	; 32
    6fca:	9e 2e       	mov	r9, r30
    6fcc:	10 c0       	rjmp	.+32     	; 0x6fee <vfprintf+0x112>
    6fce:	8e 32       	cpi	r24, 0x2E	; 46
    6fd0:	31 f4       	brne	.+12     	; 0x6fde <vfprintf+0x102>
    6fd2:	96 fc       	sbrc	r9, 6
    6fd4:	cc c2       	rjmp	.+1432   	; 0x756e <vfprintf+0x692>
    6fd6:	f9 2d       	mov	r31, r9
    6fd8:	f0 64       	ori	r31, 0x40	; 64
    6fda:	9f 2e       	mov	r9, r31
    6fdc:	08 c0       	rjmp	.+16     	; 0x6fee <vfprintf+0x112>
    6fde:	8c 36       	cpi	r24, 0x6C	; 108
    6fe0:	21 f4       	brne	.+8      	; 0x6fea <vfprintf+0x10e>
    6fe2:	29 2d       	mov	r18, r9
    6fe4:	20 68       	ori	r18, 0x80	; 128
    6fe6:	92 2e       	mov	r9, r18
    6fe8:	02 c0       	rjmp	.+4      	; 0x6fee <vfprintf+0x112>
    6fea:	88 36       	cpi	r24, 0x68	; 104
    6fec:	41 f4       	brne	.+16     	; 0x6ffe <vfprintf+0x122>
    6fee:	f1 01       	movw	r30, r2
    6ff0:	93 fd       	sbrc	r25, 3
    6ff2:	85 91       	lpm	r24, Z+
    6ff4:	93 ff       	sbrs	r25, 3
    6ff6:	81 91       	ld	r24, Z+
    6ff8:	1f 01       	movw	r2, r30
    6ffa:	81 11       	cpse	r24, r1
    6ffc:	b3 cf       	rjmp	.-154    	; 0x6f64 <vfprintf+0x88>
    6ffe:	9b eb       	ldi	r25, 0xBB	; 187
    7000:	98 0f       	add	r25, r24
    7002:	93 30       	cpi	r25, 0x03	; 3
    7004:	20 f4       	brcc	.+8      	; 0x700e <vfprintf+0x132>
    7006:	99 2d       	mov	r25, r9
    7008:	90 61       	ori	r25, 0x10	; 16
    700a:	80 5e       	subi	r24, 0xE0	; 224
    700c:	07 c0       	rjmp	.+14     	; 0x701c <vfprintf+0x140>
    700e:	9b e9       	ldi	r25, 0x9B	; 155
    7010:	98 0f       	add	r25, r24
    7012:	93 30       	cpi	r25, 0x03	; 3
    7014:	08 f0       	brcs	.+2      	; 0x7018 <vfprintf+0x13c>
    7016:	59 c1       	rjmp	.+690    	; 0x72ca <vfprintf+0x3ee>
    7018:	99 2d       	mov	r25, r9
    701a:	9f 7e       	andi	r25, 0xEF	; 239
    701c:	96 ff       	sbrs	r25, 6
    701e:	16 e0       	ldi	r17, 0x06	; 6
    7020:	9f 73       	andi	r25, 0x3F	; 63
    7022:	99 2e       	mov	r9, r25
    7024:	85 36       	cpi	r24, 0x65	; 101
    7026:	19 f4       	brne	.+6      	; 0x702e <vfprintf+0x152>
    7028:	90 64       	ori	r25, 0x40	; 64
    702a:	99 2e       	mov	r9, r25
    702c:	08 c0       	rjmp	.+16     	; 0x703e <vfprintf+0x162>
    702e:	86 36       	cpi	r24, 0x66	; 102
    7030:	21 f4       	brne	.+8      	; 0x703a <vfprintf+0x15e>
    7032:	39 2f       	mov	r19, r25
    7034:	30 68       	ori	r19, 0x80	; 128
    7036:	93 2e       	mov	r9, r19
    7038:	02 c0       	rjmp	.+4      	; 0x703e <vfprintf+0x162>
    703a:	11 11       	cpse	r17, r1
    703c:	11 50       	subi	r17, 0x01	; 1
    703e:	97 fe       	sbrs	r9, 7
    7040:	07 c0       	rjmp	.+14     	; 0x7050 <vfprintf+0x174>
    7042:	1c 33       	cpi	r17, 0x3C	; 60
    7044:	50 f4       	brcc	.+20     	; 0x705a <vfprintf+0x17e>
    7046:	44 24       	eor	r4, r4
    7048:	43 94       	inc	r4
    704a:	41 0e       	add	r4, r17
    704c:	27 e0       	ldi	r18, 0x07	; 7
    704e:	0b c0       	rjmp	.+22     	; 0x7066 <vfprintf+0x18a>
    7050:	18 30       	cpi	r17, 0x08	; 8
    7052:	38 f0       	brcs	.+14     	; 0x7062 <vfprintf+0x186>
    7054:	27 e0       	ldi	r18, 0x07	; 7
    7056:	17 e0       	ldi	r17, 0x07	; 7
    7058:	05 c0       	rjmp	.+10     	; 0x7064 <vfprintf+0x188>
    705a:	27 e0       	ldi	r18, 0x07	; 7
    705c:	9c e3       	ldi	r25, 0x3C	; 60
    705e:	49 2e       	mov	r4, r25
    7060:	02 c0       	rjmp	.+4      	; 0x7066 <vfprintf+0x18a>
    7062:	21 2f       	mov	r18, r17
    7064:	41 2c       	mov	r4, r1
    7066:	56 01       	movw	r10, r12
    7068:	84 e0       	ldi	r24, 0x04	; 4
    706a:	a8 0e       	add	r10, r24
    706c:	b1 1c       	adc	r11, r1
    706e:	f6 01       	movw	r30, r12
    7070:	60 81       	ld	r22, Z
    7072:	71 81       	ldd	r23, Z+1	; 0x01
    7074:	82 81       	ldd	r24, Z+2	; 0x02
    7076:	93 81       	ldd	r25, Z+3	; 0x03
    7078:	04 2d       	mov	r16, r4
    707a:	a3 01       	movw	r20, r6
    707c:	ee d2       	rcall	.+1500   	; 0x765a <__ftoa_engine>
    707e:	6c 01       	movw	r12, r24
    7080:	f9 81       	ldd	r31, Y+1	; 0x01
    7082:	fc 87       	std	Y+12, r31	; 0x0c
    7084:	f0 ff       	sbrs	r31, 0
    7086:	02 c0       	rjmp	.+4      	; 0x708c <vfprintf+0x1b0>
    7088:	f3 ff       	sbrs	r31, 3
    708a:	06 c0       	rjmp	.+12     	; 0x7098 <vfprintf+0x1bc>
    708c:	91 fc       	sbrc	r9, 1
    708e:	06 c0       	rjmp	.+12     	; 0x709c <vfprintf+0x1c0>
    7090:	92 fe       	sbrs	r9, 2
    7092:	06 c0       	rjmp	.+12     	; 0x70a0 <vfprintf+0x1c4>
    7094:	00 e2       	ldi	r16, 0x20	; 32
    7096:	05 c0       	rjmp	.+10     	; 0x70a2 <vfprintf+0x1c6>
    7098:	0d e2       	ldi	r16, 0x2D	; 45
    709a:	03 c0       	rjmp	.+6      	; 0x70a2 <vfprintf+0x1c6>
    709c:	0b e2       	ldi	r16, 0x2B	; 43
    709e:	01 c0       	rjmp	.+2      	; 0x70a2 <vfprintf+0x1c6>
    70a0:	00 e0       	ldi	r16, 0x00	; 0
    70a2:	8c 85       	ldd	r24, Y+12	; 0x0c
    70a4:	8c 70       	andi	r24, 0x0C	; 12
    70a6:	19 f0       	breq	.+6      	; 0x70ae <vfprintf+0x1d2>
    70a8:	01 11       	cpse	r16, r1
    70aa:	43 c2       	rjmp	.+1158   	; 0x7532 <vfprintf+0x656>
    70ac:	80 c2       	rjmp	.+1280   	; 0x75ae <vfprintf+0x6d2>
    70ae:	97 fe       	sbrs	r9, 7
    70b0:	10 c0       	rjmp	.+32     	; 0x70d2 <vfprintf+0x1f6>
    70b2:	4c 0c       	add	r4, r12
    70b4:	fc 85       	ldd	r31, Y+12	; 0x0c
    70b6:	f4 ff       	sbrs	r31, 4
    70b8:	04 c0       	rjmp	.+8      	; 0x70c2 <vfprintf+0x1e6>
    70ba:	8a 81       	ldd	r24, Y+2	; 0x02
    70bc:	81 33       	cpi	r24, 0x31	; 49
    70be:	09 f4       	brne	.+2      	; 0x70c2 <vfprintf+0x1e6>
    70c0:	4a 94       	dec	r4
    70c2:	14 14       	cp	r1, r4
    70c4:	74 f5       	brge	.+92     	; 0x7122 <vfprintf+0x246>
    70c6:	28 e0       	ldi	r18, 0x08	; 8
    70c8:	24 15       	cp	r18, r4
    70ca:	78 f5       	brcc	.+94     	; 0x712a <vfprintf+0x24e>
    70cc:	88 e0       	ldi	r24, 0x08	; 8
    70ce:	48 2e       	mov	r4, r24
    70d0:	2c c0       	rjmp	.+88     	; 0x712a <vfprintf+0x24e>
    70d2:	96 fc       	sbrc	r9, 6
    70d4:	2a c0       	rjmp	.+84     	; 0x712a <vfprintf+0x24e>
    70d6:	81 2f       	mov	r24, r17
    70d8:	90 e0       	ldi	r25, 0x00	; 0
    70da:	8c 15       	cp	r24, r12
    70dc:	9d 05       	cpc	r25, r13
    70de:	9c f0       	brlt	.+38     	; 0x7106 <vfprintf+0x22a>
    70e0:	3c ef       	ldi	r19, 0xFC	; 252
    70e2:	c3 16       	cp	r12, r19
    70e4:	3f ef       	ldi	r19, 0xFF	; 255
    70e6:	d3 06       	cpc	r13, r19
    70e8:	74 f0       	brlt	.+28     	; 0x7106 <vfprintf+0x22a>
    70ea:	89 2d       	mov	r24, r9
    70ec:	80 68       	ori	r24, 0x80	; 128
    70ee:	98 2e       	mov	r9, r24
    70f0:	0a c0       	rjmp	.+20     	; 0x7106 <vfprintf+0x22a>
    70f2:	e2 e0       	ldi	r30, 0x02	; 2
    70f4:	f0 e0       	ldi	r31, 0x00	; 0
    70f6:	ec 0f       	add	r30, r28
    70f8:	fd 1f       	adc	r31, r29
    70fa:	e1 0f       	add	r30, r17
    70fc:	f1 1d       	adc	r31, r1
    70fe:	80 81       	ld	r24, Z
    7100:	80 33       	cpi	r24, 0x30	; 48
    7102:	19 f4       	brne	.+6      	; 0x710a <vfprintf+0x22e>
    7104:	11 50       	subi	r17, 0x01	; 1
    7106:	11 11       	cpse	r17, r1
    7108:	f4 cf       	rjmp	.-24     	; 0x70f2 <vfprintf+0x216>
    710a:	97 fe       	sbrs	r9, 7
    710c:	0e c0       	rjmp	.+28     	; 0x712a <vfprintf+0x24e>
    710e:	44 24       	eor	r4, r4
    7110:	43 94       	inc	r4
    7112:	41 0e       	add	r4, r17
    7114:	81 2f       	mov	r24, r17
    7116:	90 e0       	ldi	r25, 0x00	; 0
    7118:	c8 16       	cp	r12, r24
    711a:	d9 06       	cpc	r13, r25
    711c:	2c f4       	brge	.+10     	; 0x7128 <vfprintf+0x24c>
    711e:	1c 19       	sub	r17, r12
    7120:	04 c0       	rjmp	.+8      	; 0x712a <vfprintf+0x24e>
    7122:	44 24       	eor	r4, r4
    7124:	43 94       	inc	r4
    7126:	01 c0       	rjmp	.+2      	; 0x712a <vfprintf+0x24e>
    7128:	10 e0       	ldi	r17, 0x00	; 0
    712a:	97 fe       	sbrs	r9, 7
    712c:	06 c0       	rjmp	.+12     	; 0x713a <vfprintf+0x25e>
    712e:	1c 14       	cp	r1, r12
    7130:	1d 04       	cpc	r1, r13
    7132:	34 f4       	brge	.+12     	; 0x7140 <vfprintf+0x264>
    7134:	c6 01       	movw	r24, r12
    7136:	01 96       	adiw	r24, 0x01	; 1
    7138:	05 c0       	rjmp	.+10     	; 0x7144 <vfprintf+0x268>
    713a:	85 e0       	ldi	r24, 0x05	; 5
    713c:	90 e0       	ldi	r25, 0x00	; 0
    713e:	02 c0       	rjmp	.+4      	; 0x7144 <vfprintf+0x268>
    7140:	81 e0       	ldi	r24, 0x01	; 1
    7142:	90 e0       	ldi	r25, 0x00	; 0
    7144:	01 11       	cpse	r16, r1
    7146:	01 96       	adiw	r24, 0x01	; 1
    7148:	11 23       	and	r17, r17
    714a:	31 f0       	breq	.+12     	; 0x7158 <vfprintf+0x27c>
    714c:	21 2f       	mov	r18, r17
    714e:	30 e0       	ldi	r19, 0x00	; 0
    7150:	2f 5f       	subi	r18, 0xFF	; 255
    7152:	3f 4f       	sbci	r19, 0xFF	; 255
    7154:	82 0f       	add	r24, r18
    7156:	93 1f       	adc	r25, r19
    7158:	25 2d       	mov	r18, r5
    715a:	30 e0       	ldi	r19, 0x00	; 0
    715c:	82 17       	cp	r24, r18
    715e:	93 07       	cpc	r25, r19
    7160:	14 f4       	brge	.+4      	; 0x7166 <vfprintf+0x28a>
    7162:	58 1a       	sub	r5, r24
    7164:	01 c0       	rjmp	.+2      	; 0x7168 <vfprintf+0x28c>
    7166:	51 2c       	mov	r5, r1
    7168:	89 2d       	mov	r24, r9
    716a:	89 70       	andi	r24, 0x09	; 9
    716c:	41 f4       	brne	.+16     	; 0x717e <vfprintf+0x2a2>
    716e:	55 20       	and	r5, r5
    7170:	31 f0       	breq	.+12     	; 0x717e <vfprintf+0x2a2>
    7172:	b7 01       	movw	r22, r14
    7174:	80 e2       	ldi	r24, 0x20	; 32
    7176:	90 e0       	ldi	r25, 0x00	; 0
    7178:	6e d3       	rcall	.+1756   	; 0x7856 <fputc>
    717a:	5a 94       	dec	r5
    717c:	f8 cf       	rjmp	.-16     	; 0x716e <vfprintf+0x292>
    717e:	00 23       	and	r16, r16
    7180:	21 f0       	breq	.+8      	; 0x718a <vfprintf+0x2ae>
    7182:	b7 01       	movw	r22, r14
    7184:	80 2f       	mov	r24, r16
    7186:	90 e0       	ldi	r25, 0x00	; 0
    7188:	66 d3       	rcall	.+1740   	; 0x7856 <fputc>
    718a:	93 fc       	sbrc	r9, 3
    718c:	08 c0       	rjmp	.+16     	; 0x719e <vfprintf+0x2c2>
    718e:	55 20       	and	r5, r5
    7190:	31 f0       	breq	.+12     	; 0x719e <vfprintf+0x2c2>
    7192:	b7 01       	movw	r22, r14
    7194:	80 e3       	ldi	r24, 0x30	; 48
    7196:	90 e0       	ldi	r25, 0x00	; 0
    7198:	5e d3       	rcall	.+1724   	; 0x7856 <fputc>
    719a:	5a 94       	dec	r5
    719c:	f8 cf       	rjmp	.-16     	; 0x718e <vfprintf+0x2b2>
    719e:	97 fe       	sbrs	r9, 7
    71a0:	4a c0       	rjmp	.+148    	; 0x7236 <vfprintf+0x35a>
    71a2:	46 01       	movw	r8, r12
    71a4:	d7 fe       	sbrs	r13, 7
    71a6:	02 c0       	rjmp	.+4      	; 0x71ac <vfprintf+0x2d0>
    71a8:	81 2c       	mov	r8, r1
    71aa:	91 2c       	mov	r9, r1
    71ac:	c6 01       	movw	r24, r12
    71ae:	88 19       	sub	r24, r8
    71b0:	99 09       	sbc	r25, r9
    71b2:	f3 01       	movw	r30, r6
    71b4:	e8 0f       	add	r30, r24
    71b6:	f9 1f       	adc	r31, r25
    71b8:	fe 87       	std	Y+14, r31	; 0x0e
    71ba:	ed 87       	std	Y+13, r30	; 0x0d
    71bc:	96 01       	movw	r18, r12
    71be:	24 19       	sub	r18, r4
    71c0:	31 09       	sbc	r19, r1
    71c2:	38 8b       	std	Y+16, r19	; 0x10
    71c4:	2f 87       	std	Y+15, r18	; 0x0f
    71c6:	01 2f       	mov	r16, r17
    71c8:	10 e0       	ldi	r17, 0x00	; 0
    71ca:	11 95       	neg	r17
    71cc:	01 95       	neg	r16
    71ce:	11 09       	sbc	r17, r1
    71d0:	3f ef       	ldi	r19, 0xFF	; 255
    71d2:	83 16       	cp	r8, r19
    71d4:	93 06       	cpc	r9, r19
    71d6:	21 f4       	brne	.+8      	; 0x71e0 <vfprintf+0x304>
    71d8:	b7 01       	movw	r22, r14
    71da:	8e e2       	ldi	r24, 0x2E	; 46
    71dc:	90 e0       	ldi	r25, 0x00	; 0
    71de:	3b d3       	rcall	.+1654   	; 0x7856 <fputc>
    71e0:	c8 14       	cp	r12, r8
    71e2:	d9 04       	cpc	r13, r9
    71e4:	4c f0       	brlt	.+18     	; 0x71f8 <vfprintf+0x31c>
    71e6:	8f 85       	ldd	r24, Y+15	; 0x0f
    71e8:	98 89       	ldd	r25, Y+16	; 0x10
    71ea:	88 15       	cp	r24, r8
    71ec:	99 05       	cpc	r25, r9
    71ee:	24 f4       	brge	.+8      	; 0x71f8 <vfprintf+0x31c>
    71f0:	ed 85       	ldd	r30, Y+13	; 0x0d
    71f2:	fe 85       	ldd	r31, Y+14	; 0x0e
    71f4:	81 81       	ldd	r24, Z+1	; 0x01
    71f6:	01 c0       	rjmp	.+2      	; 0x71fa <vfprintf+0x31e>
    71f8:	80 e3       	ldi	r24, 0x30	; 48
    71fa:	f1 e0       	ldi	r31, 0x01	; 1
    71fc:	8f 1a       	sub	r8, r31
    71fe:	91 08       	sbc	r9, r1
    7200:	2d 85       	ldd	r18, Y+13	; 0x0d
    7202:	3e 85       	ldd	r19, Y+14	; 0x0e
    7204:	2f 5f       	subi	r18, 0xFF	; 255
    7206:	3f 4f       	sbci	r19, 0xFF	; 255
    7208:	3e 87       	std	Y+14, r19	; 0x0e
    720a:	2d 87       	std	Y+13, r18	; 0x0d
    720c:	80 16       	cp	r8, r16
    720e:	91 06       	cpc	r9, r17
    7210:	24 f0       	brlt	.+8      	; 0x721a <vfprintf+0x33e>
    7212:	b7 01       	movw	r22, r14
    7214:	90 e0       	ldi	r25, 0x00	; 0
    7216:	1f d3       	rcall	.+1598   	; 0x7856 <fputc>
    7218:	db cf       	rjmp	.-74     	; 0x71d0 <vfprintf+0x2f4>
    721a:	c8 14       	cp	r12, r8
    721c:	d9 04       	cpc	r13, r9
    721e:	41 f4       	brne	.+16     	; 0x7230 <vfprintf+0x354>
    7220:	9a 81       	ldd	r25, Y+2	; 0x02
    7222:	96 33       	cpi	r25, 0x36	; 54
    7224:	20 f4       	brcc	.+8      	; 0x722e <vfprintf+0x352>
    7226:	95 33       	cpi	r25, 0x35	; 53
    7228:	19 f4       	brne	.+6      	; 0x7230 <vfprintf+0x354>
    722a:	3c 85       	ldd	r19, Y+12	; 0x0c
    722c:	34 ff       	sbrs	r19, 4
    722e:	81 e3       	ldi	r24, 0x31	; 49
    7230:	b7 01       	movw	r22, r14
    7232:	90 e0       	ldi	r25, 0x00	; 0
    7234:	48 c0       	rjmp	.+144    	; 0x72c6 <vfprintf+0x3ea>
    7236:	8a 81       	ldd	r24, Y+2	; 0x02
    7238:	81 33       	cpi	r24, 0x31	; 49
    723a:	19 f0       	breq	.+6      	; 0x7242 <vfprintf+0x366>
    723c:	9c 85       	ldd	r25, Y+12	; 0x0c
    723e:	9f 7e       	andi	r25, 0xEF	; 239
    7240:	9c 87       	std	Y+12, r25	; 0x0c
    7242:	b7 01       	movw	r22, r14
    7244:	90 e0       	ldi	r25, 0x00	; 0
    7246:	07 d3       	rcall	.+1550   	; 0x7856 <fputc>
    7248:	11 11       	cpse	r17, r1
    724a:	05 c0       	rjmp	.+10     	; 0x7256 <vfprintf+0x37a>
    724c:	94 fc       	sbrc	r9, 4
    724e:	16 c0       	rjmp	.+44     	; 0x727c <vfprintf+0x3a0>
    7250:	85 e6       	ldi	r24, 0x65	; 101
    7252:	90 e0       	ldi	r25, 0x00	; 0
    7254:	15 c0       	rjmp	.+42     	; 0x7280 <vfprintf+0x3a4>
    7256:	b7 01       	movw	r22, r14
    7258:	8e e2       	ldi	r24, 0x2E	; 46
    725a:	90 e0       	ldi	r25, 0x00	; 0
    725c:	fc d2       	rcall	.+1528   	; 0x7856 <fputc>
    725e:	1e 5f       	subi	r17, 0xFE	; 254
    7260:	82 e0       	ldi	r24, 0x02	; 2
    7262:	01 e0       	ldi	r16, 0x01	; 1
    7264:	08 0f       	add	r16, r24
    7266:	f3 01       	movw	r30, r6
    7268:	e8 0f       	add	r30, r24
    726a:	f1 1d       	adc	r31, r1
    726c:	80 81       	ld	r24, Z
    726e:	b7 01       	movw	r22, r14
    7270:	90 e0       	ldi	r25, 0x00	; 0
    7272:	f1 d2       	rcall	.+1506   	; 0x7856 <fputc>
    7274:	80 2f       	mov	r24, r16
    7276:	01 13       	cpse	r16, r17
    7278:	f4 cf       	rjmp	.-24     	; 0x7262 <vfprintf+0x386>
    727a:	e8 cf       	rjmp	.-48     	; 0x724c <vfprintf+0x370>
    727c:	85 e4       	ldi	r24, 0x45	; 69
    727e:	90 e0       	ldi	r25, 0x00	; 0
    7280:	b7 01       	movw	r22, r14
    7282:	e9 d2       	rcall	.+1490   	; 0x7856 <fputc>
    7284:	d7 fc       	sbrc	r13, 7
    7286:	06 c0       	rjmp	.+12     	; 0x7294 <vfprintf+0x3b8>
    7288:	c1 14       	cp	r12, r1
    728a:	d1 04       	cpc	r13, r1
    728c:	41 f4       	brne	.+16     	; 0x729e <vfprintf+0x3c2>
    728e:	ec 85       	ldd	r30, Y+12	; 0x0c
    7290:	e4 ff       	sbrs	r30, 4
    7292:	05 c0       	rjmp	.+10     	; 0x729e <vfprintf+0x3c2>
    7294:	d1 94       	neg	r13
    7296:	c1 94       	neg	r12
    7298:	d1 08       	sbc	r13, r1
    729a:	8d e2       	ldi	r24, 0x2D	; 45
    729c:	01 c0       	rjmp	.+2      	; 0x72a0 <vfprintf+0x3c4>
    729e:	8b e2       	ldi	r24, 0x2B	; 43
    72a0:	b7 01       	movw	r22, r14
    72a2:	90 e0       	ldi	r25, 0x00	; 0
    72a4:	d8 d2       	rcall	.+1456   	; 0x7856 <fputc>
    72a6:	80 e3       	ldi	r24, 0x30	; 48
    72a8:	2a e0       	ldi	r18, 0x0A	; 10
    72aa:	c2 16       	cp	r12, r18
    72ac:	d1 04       	cpc	r13, r1
    72ae:	2c f0       	brlt	.+10     	; 0x72ba <vfprintf+0x3de>
    72b0:	8f 5f       	subi	r24, 0xFF	; 255
    72b2:	fa e0       	ldi	r31, 0x0A	; 10
    72b4:	cf 1a       	sub	r12, r31
    72b6:	d1 08       	sbc	r13, r1
    72b8:	f7 cf       	rjmp	.-18     	; 0x72a8 <vfprintf+0x3cc>
    72ba:	b7 01       	movw	r22, r14
    72bc:	90 e0       	ldi	r25, 0x00	; 0
    72be:	cb d2       	rcall	.+1430   	; 0x7856 <fputc>
    72c0:	b7 01       	movw	r22, r14
    72c2:	c6 01       	movw	r24, r12
    72c4:	c0 96       	adiw	r24, 0x30	; 48
    72c6:	c7 d2       	rcall	.+1422   	; 0x7856 <fputc>
    72c8:	49 c1       	rjmp	.+658    	; 0x755c <vfprintf+0x680>
    72ca:	83 36       	cpi	r24, 0x63	; 99
    72cc:	31 f0       	breq	.+12     	; 0x72da <vfprintf+0x3fe>
    72ce:	83 37       	cpi	r24, 0x73	; 115
    72d0:	79 f0       	breq	.+30     	; 0x72f0 <vfprintf+0x414>
    72d2:	83 35       	cpi	r24, 0x53	; 83
    72d4:	09 f0       	breq	.+2      	; 0x72d8 <vfprintf+0x3fc>
    72d6:	52 c0       	rjmp	.+164    	; 0x737c <vfprintf+0x4a0>
    72d8:	1f c0       	rjmp	.+62     	; 0x7318 <vfprintf+0x43c>
    72da:	56 01       	movw	r10, r12
    72dc:	32 e0       	ldi	r19, 0x02	; 2
    72de:	a3 0e       	add	r10, r19
    72e0:	b1 1c       	adc	r11, r1
    72e2:	f6 01       	movw	r30, r12
    72e4:	80 81       	ld	r24, Z
    72e6:	89 83       	std	Y+1, r24	; 0x01
    72e8:	01 e0       	ldi	r16, 0x01	; 1
    72ea:	10 e0       	ldi	r17, 0x00	; 0
    72ec:	63 01       	movw	r12, r6
    72ee:	11 c0       	rjmp	.+34     	; 0x7312 <vfprintf+0x436>
    72f0:	56 01       	movw	r10, r12
    72f2:	f2 e0       	ldi	r31, 0x02	; 2
    72f4:	af 0e       	add	r10, r31
    72f6:	b1 1c       	adc	r11, r1
    72f8:	f6 01       	movw	r30, r12
    72fa:	c0 80       	ld	r12, Z
    72fc:	d1 80       	ldd	r13, Z+1	; 0x01
    72fe:	96 fe       	sbrs	r9, 6
    7300:	03 c0       	rjmp	.+6      	; 0x7308 <vfprintf+0x42c>
    7302:	61 2f       	mov	r22, r17
    7304:	70 e0       	ldi	r23, 0x00	; 0
    7306:	02 c0       	rjmp	.+4      	; 0x730c <vfprintf+0x430>
    7308:	6f ef       	ldi	r22, 0xFF	; 255
    730a:	7f ef       	ldi	r23, 0xFF	; 255
    730c:	c6 01       	movw	r24, r12
    730e:	98 d2       	rcall	.+1328   	; 0x7840 <strnlen>
    7310:	8c 01       	movw	r16, r24
    7312:	f9 2d       	mov	r31, r9
    7314:	ff 77       	andi	r31, 0x7F	; 127
    7316:	13 c0       	rjmp	.+38     	; 0x733e <vfprintf+0x462>
    7318:	56 01       	movw	r10, r12
    731a:	22 e0       	ldi	r18, 0x02	; 2
    731c:	a2 0e       	add	r10, r18
    731e:	b1 1c       	adc	r11, r1
    7320:	f6 01       	movw	r30, r12
    7322:	c0 80       	ld	r12, Z
    7324:	d1 80       	ldd	r13, Z+1	; 0x01
    7326:	96 fe       	sbrs	r9, 6
    7328:	03 c0       	rjmp	.+6      	; 0x7330 <vfprintf+0x454>
    732a:	61 2f       	mov	r22, r17
    732c:	70 e0       	ldi	r23, 0x00	; 0
    732e:	02 c0       	rjmp	.+4      	; 0x7334 <vfprintf+0x458>
    7330:	6f ef       	ldi	r22, 0xFF	; 255
    7332:	7f ef       	ldi	r23, 0xFF	; 255
    7334:	c6 01       	movw	r24, r12
    7336:	69 d2       	rcall	.+1234   	; 0x780a <strnlen_P>
    7338:	8c 01       	movw	r16, r24
    733a:	f9 2d       	mov	r31, r9
    733c:	f0 68       	ori	r31, 0x80	; 128
    733e:	9f 2e       	mov	r9, r31
    7340:	f3 fd       	sbrc	r31, 3
    7342:	18 c0       	rjmp	.+48     	; 0x7374 <vfprintf+0x498>
    7344:	85 2d       	mov	r24, r5
    7346:	90 e0       	ldi	r25, 0x00	; 0
    7348:	08 17       	cp	r16, r24
    734a:	19 07       	cpc	r17, r25
    734c:	98 f4       	brcc	.+38     	; 0x7374 <vfprintf+0x498>
    734e:	b7 01       	movw	r22, r14
    7350:	80 e2       	ldi	r24, 0x20	; 32
    7352:	90 e0       	ldi	r25, 0x00	; 0
    7354:	80 d2       	rcall	.+1280   	; 0x7856 <fputc>
    7356:	5a 94       	dec	r5
    7358:	f5 cf       	rjmp	.-22     	; 0x7344 <vfprintf+0x468>
    735a:	f6 01       	movw	r30, r12
    735c:	97 fc       	sbrc	r9, 7
    735e:	85 91       	lpm	r24, Z+
    7360:	97 fe       	sbrs	r9, 7
    7362:	81 91       	ld	r24, Z+
    7364:	6f 01       	movw	r12, r30
    7366:	b7 01       	movw	r22, r14
    7368:	90 e0       	ldi	r25, 0x00	; 0
    736a:	75 d2       	rcall	.+1258   	; 0x7856 <fputc>
    736c:	51 10       	cpse	r5, r1
    736e:	5a 94       	dec	r5
    7370:	01 50       	subi	r16, 0x01	; 1
    7372:	11 09       	sbc	r17, r1
    7374:	01 15       	cp	r16, r1
    7376:	11 05       	cpc	r17, r1
    7378:	81 f7       	brne	.-32     	; 0x735a <vfprintf+0x47e>
    737a:	f0 c0       	rjmp	.+480    	; 0x755c <vfprintf+0x680>
    737c:	84 36       	cpi	r24, 0x64	; 100
    737e:	11 f0       	breq	.+4      	; 0x7384 <vfprintf+0x4a8>
    7380:	89 36       	cpi	r24, 0x69	; 105
    7382:	59 f5       	brne	.+86     	; 0x73da <vfprintf+0x4fe>
    7384:	56 01       	movw	r10, r12
    7386:	97 fe       	sbrs	r9, 7
    7388:	09 c0       	rjmp	.+18     	; 0x739c <vfprintf+0x4c0>
    738a:	24 e0       	ldi	r18, 0x04	; 4
    738c:	a2 0e       	add	r10, r18
    738e:	b1 1c       	adc	r11, r1
    7390:	f6 01       	movw	r30, r12
    7392:	60 81       	ld	r22, Z
    7394:	71 81       	ldd	r23, Z+1	; 0x01
    7396:	82 81       	ldd	r24, Z+2	; 0x02
    7398:	93 81       	ldd	r25, Z+3	; 0x03
    739a:	0a c0       	rjmp	.+20     	; 0x73b0 <vfprintf+0x4d4>
    739c:	f2 e0       	ldi	r31, 0x02	; 2
    739e:	af 0e       	add	r10, r31
    73a0:	b1 1c       	adc	r11, r1
    73a2:	f6 01       	movw	r30, r12
    73a4:	60 81       	ld	r22, Z
    73a6:	71 81       	ldd	r23, Z+1	; 0x01
    73a8:	07 2e       	mov	r0, r23
    73aa:	00 0c       	add	r0, r0
    73ac:	88 0b       	sbc	r24, r24
    73ae:	99 0b       	sbc	r25, r25
    73b0:	f9 2d       	mov	r31, r9
    73b2:	ff 76       	andi	r31, 0x6F	; 111
    73b4:	9f 2e       	mov	r9, r31
    73b6:	97 ff       	sbrs	r25, 7
    73b8:	09 c0       	rjmp	.+18     	; 0x73cc <vfprintf+0x4f0>
    73ba:	90 95       	com	r25
    73bc:	80 95       	com	r24
    73be:	70 95       	com	r23
    73c0:	61 95       	neg	r22
    73c2:	7f 4f       	sbci	r23, 0xFF	; 255
    73c4:	8f 4f       	sbci	r24, 0xFF	; 255
    73c6:	9f 4f       	sbci	r25, 0xFF	; 255
    73c8:	f0 68       	ori	r31, 0x80	; 128
    73ca:	9f 2e       	mov	r9, r31
    73cc:	2a e0       	ldi	r18, 0x0A	; 10
    73ce:	30 e0       	ldi	r19, 0x00	; 0
    73d0:	a3 01       	movw	r20, r6
    73d2:	a5 d2       	rcall	.+1354   	; 0x791e <__ultoa_invert>
    73d4:	c8 2e       	mov	r12, r24
    73d6:	c6 18       	sub	r12, r6
    73d8:	3e c0       	rjmp	.+124    	; 0x7456 <vfprintf+0x57a>
    73da:	09 2d       	mov	r16, r9
    73dc:	85 37       	cpi	r24, 0x75	; 117
    73de:	21 f4       	brne	.+8      	; 0x73e8 <vfprintf+0x50c>
    73e0:	0f 7e       	andi	r16, 0xEF	; 239
    73e2:	2a e0       	ldi	r18, 0x0A	; 10
    73e4:	30 e0       	ldi	r19, 0x00	; 0
    73e6:	1d c0       	rjmp	.+58     	; 0x7422 <vfprintf+0x546>
    73e8:	09 7f       	andi	r16, 0xF9	; 249
    73ea:	8f 36       	cpi	r24, 0x6F	; 111
    73ec:	91 f0       	breq	.+36     	; 0x7412 <vfprintf+0x536>
    73ee:	18 f4       	brcc	.+6      	; 0x73f6 <vfprintf+0x51a>
    73f0:	88 35       	cpi	r24, 0x58	; 88
    73f2:	59 f0       	breq	.+22     	; 0x740a <vfprintf+0x52e>
    73f4:	bc c0       	rjmp	.+376    	; 0x756e <vfprintf+0x692>
    73f6:	80 37       	cpi	r24, 0x70	; 112
    73f8:	19 f0       	breq	.+6      	; 0x7400 <vfprintf+0x524>
    73fa:	88 37       	cpi	r24, 0x78	; 120
    73fc:	11 f0       	breq	.+4      	; 0x7402 <vfprintf+0x526>
    73fe:	b7 c0       	rjmp	.+366    	; 0x756e <vfprintf+0x692>
    7400:	00 61       	ori	r16, 0x10	; 16
    7402:	04 ff       	sbrs	r16, 4
    7404:	09 c0       	rjmp	.+18     	; 0x7418 <vfprintf+0x53c>
    7406:	04 60       	ori	r16, 0x04	; 4
    7408:	07 c0       	rjmp	.+14     	; 0x7418 <vfprintf+0x53c>
    740a:	94 fe       	sbrs	r9, 4
    740c:	08 c0       	rjmp	.+16     	; 0x741e <vfprintf+0x542>
    740e:	06 60       	ori	r16, 0x06	; 6
    7410:	06 c0       	rjmp	.+12     	; 0x741e <vfprintf+0x542>
    7412:	28 e0       	ldi	r18, 0x08	; 8
    7414:	30 e0       	ldi	r19, 0x00	; 0
    7416:	05 c0       	rjmp	.+10     	; 0x7422 <vfprintf+0x546>
    7418:	20 e1       	ldi	r18, 0x10	; 16
    741a:	30 e0       	ldi	r19, 0x00	; 0
    741c:	02 c0       	rjmp	.+4      	; 0x7422 <vfprintf+0x546>
    741e:	20 e1       	ldi	r18, 0x10	; 16
    7420:	32 e0       	ldi	r19, 0x02	; 2
    7422:	56 01       	movw	r10, r12
    7424:	07 ff       	sbrs	r16, 7
    7426:	09 c0       	rjmp	.+18     	; 0x743a <vfprintf+0x55e>
    7428:	84 e0       	ldi	r24, 0x04	; 4
    742a:	a8 0e       	add	r10, r24
    742c:	b1 1c       	adc	r11, r1
    742e:	f6 01       	movw	r30, r12
    7430:	60 81       	ld	r22, Z
    7432:	71 81       	ldd	r23, Z+1	; 0x01
    7434:	82 81       	ldd	r24, Z+2	; 0x02
    7436:	93 81       	ldd	r25, Z+3	; 0x03
    7438:	08 c0       	rjmp	.+16     	; 0x744a <vfprintf+0x56e>
    743a:	f2 e0       	ldi	r31, 0x02	; 2
    743c:	af 0e       	add	r10, r31
    743e:	b1 1c       	adc	r11, r1
    7440:	f6 01       	movw	r30, r12
    7442:	60 81       	ld	r22, Z
    7444:	71 81       	ldd	r23, Z+1	; 0x01
    7446:	80 e0       	ldi	r24, 0x00	; 0
    7448:	90 e0       	ldi	r25, 0x00	; 0
    744a:	a3 01       	movw	r20, r6
    744c:	68 d2       	rcall	.+1232   	; 0x791e <__ultoa_invert>
    744e:	c8 2e       	mov	r12, r24
    7450:	c6 18       	sub	r12, r6
    7452:	0f 77       	andi	r16, 0x7F	; 127
    7454:	90 2e       	mov	r9, r16
    7456:	96 fe       	sbrs	r9, 6
    7458:	0b c0       	rjmp	.+22     	; 0x7470 <vfprintf+0x594>
    745a:	09 2d       	mov	r16, r9
    745c:	0e 7f       	andi	r16, 0xFE	; 254
    745e:	c1 16       	cp	r12, r17
    7460:	50 f4       	brcc	.+20     	; 0x7476 <vfprintf+0x59a>
    7462:	94 fe       	sbrs	r9, 4
    7464:	0a c0       	rjmp	.+20     	; 0x747a <vfprintf+0x59e>
    7466:	92 fc       	sbrc	r9, 2
    7468:	08 c0       	rjmp	.+16     	; 0x747a <vfprintf+0x59e>
    746a:	09 2d       	mov	r16, r9
    746c:	0e 7e       	andi	r16, 0xEE	; 238
    746e:	05 c0       	rjmp	.+10     	; 0x747a <vfprintf+0x59e>
    7470:	dc 2c       	mov	r13, r12
    7472:	09 2d       	mov	r16, r9
    7474:	03 c0       	rjmp	.+6      	; 0x747c <vfprintf+0x5a0>
    7476:	dc 2c       	mov	r13, r12
    7478:	01 c0       	rjmp	.+2      	; 0x747c <vfprintf+0x5a0>
    747a:	d1 2e       	mov	r13, r17
    747c:	04 ff       	sbrs	r16, 4
    747e:	0d c0       	rjmp	.+26     	; 0x749a <vfprintf+0x5be>
    7480:	fe 01       	movw	r30, r28
    7482:	ec 0d       	add	r30, r12
    7484:	f1 1d       	adc	r31, r1
    7486:	80 81       	ld	r24, Z
    7488:	80 33       	cpi	r24, 0x30	; 48
    748a:	11 f4       	brne	.+4      	; 0x7490 <vfprintf+0x5b4>
    748c:	09 7e       	andi	r16, 0xE9	; 233
    748e:	09 c0       	rjmp	.+18     	; 0x74a2 <vfprintf+0x5c6>
    7490:	02 ff       	sbrs	r16, 2
    7492:	06 c0       	rjmp	.+12     	; 0x74a0 <vfprintf+0x5c4>
    7494:	d3 94       	inc	r13
    7496:	d3 94       	inc	r13
    7498:	04 c0       	rjmp	.+8      	; 0x74a2 <vfprintf+0x5c6>
    749a:	80 2f       	mov	r24, r16
    749c:	86 78       	andi	r24, 0x86	; 134
    749e:	09 f0       	breq	.+2      	; 0x74a2 <vfprintf+0x5c6>
    74a0:	d3 94       	inc	r13
    74a2:	03 fd       	sbrc	r16, 3
    74a4:	10 c0       	rjmp	.+32     	; 0x74c6 <vfprintf+0x5ea>
    74a6:	00 ff       	sbrs	r16, 0
    74a8:	06 c0       	rjmp	.+12     	; 0x74b6 <vfprintf+0x5da>
    74aa:	1c 2d       	mov	r17, r12
    74ac:	d5 14       	cp	r13, r5
    74ae:	78 f4       	brcc	.+30     	; 0x74ce <vfprintf+0x5f2>
    74b0:	15 0d       	add	r17, r5
    74b2:	1d 19       	sub	r17, r13
    74b4:	0c c0       	rjmp	.+24     	; 0x74ce <vfprintf+0x5f2>
    74b6:	d5 14       	cp	r13, r5
    74b8:	50 f4       	brcc	.+20     	; 0x74ce <vfprintf+0x5f2>
    74ba:	b7 01       	movw	r22, r14
    74bc:	80 e2       	ldi	r24, 0x20	; 32
    74be:	90 e0       	ldi	r25, 0x00	; 0
    74c0:	ca d1       	rcall	.+916    	; 0x7856 <fputc>
    74c2:	d3 94       	inc	r13
    74c4:	f8 cf       	rjmp	.-16     	; 0x74b6 <vfprintf+0x5da>
    74c6:	d5 14       	cp	r13, r5
    74c8:	10 f4       	brcc	.+4      	; 0x74ce <vfprintf+0x5f2>
    74ca:	5d 18       	sub	r5, r13
    74cc:	01 c0       	rjmp	.+2      	; 0x74d0 <vfprintf+0x5f4>
    74ce:	51 2c       	mov	r5, r1
    74d0:	04 ff       	sbrs	r16, 4
    74d2:	0f c0       	rjmp	.+30     	; 0x74f2 <vfprintf+0x616>
    74d4:	b7 01       	movw	r22, r14
    74d6:	80 e3       	ldi	r24, 0x30	; 48
    74d8:	90 e0       	ldi	r25, 0x00	; 0
    74da:	bd d1       	rcall	.+890    	; 0x7856 <fputc>
    74dc:	02 ff       	sbrs	r16, 2
    74de:	16 c0       	rjmp	.+44     	; 0x750c <vfprintf+0x630>
    74e0:	01 fd       	sbrc	r16, 1
    74e2:	03 c0       	rjmp	.+6      	; 0x74ea <vfprintf+0x60e>
    74e4:	88 e7       	ldi	r24, 0x78	; 120
    74e6:	90 e0       	ldi	r25, 0x00	; 0
    74e8:	02 c0       	rjmp	.+4      	; 0x74ee <vfprintf+0x612>
    74ea:	88 e5       	ldi	r24, 0x58	; 88
    74ec:	90 e0       	ldi	r25, 0x00	; 0
    74ee:	b7 01       	movw	r22, r14
    74f0:	0c c0       	rjmp	.+24     	; 0x750a <vfprintf+0x62e>
    74f2:	80 2f       	mov	r24, r16
    74f4:	86 78       	andi	r24, 0x86	; 134
    74f6:	51 f0       	breq	.+20     	; 0x750c <vfprintf+0x630>
    74f8:	01 ff       	sbrs	r16, 1
    74fa:	02 c0       	rjmp	.+4      	; 0x7500 <vfprintf+0x624>
    74fc:	8b e2       	ldi	r24, 0x2B	; 43
    74fe:	01 c0       	rjmp	.+2      	; 0x7502 <vfprintf+0x626>
    7500:	80 e2       	ldi	r24, 0x20	; 32
    7502:	07 fd       	sbrc	r16, 7
    7504:	8d e2       	ldi	r24, 0x2D	; 45
    7506:	b7 01       	movw	r22, r14
    7508:	90 e0       	ldi	r25, 0x00	; 0
    750a:	a5 d1       	rcall	.+842    	; 0x7856 <fputc>
    750c:	c1 16       	cp	r12, r17
    750e:	30 f4       	brcc	.+12     	; 0x751c <vfprintf+0x640>
    7510:	b7 01       	movw	r22, r14
    7512:	80 e3       	ldi	r24, 0x30	; 48
    7514:	90 e0       	ldi	r25, 0x00	; 0
    7516:	9f d1       	rcall	.+830    	; 0x7856 <fputc>
    7518:	11 50       	subi	r17, 0x01	; 1
    751a:	f8 cf       	rjmp	.-16     	; 0x750c <vfprintf+0x630>
    751c:	ca 94       	dec	r12
    751e:	f3 01       	movw	r30, r6
    7520:	ec 0d       	add	r30, r12
    7522:	f1 1d       	adc	r31, r1
    7524:	80 81       	ld	r24, Z
    7526:	b7 01       	movw	r22, r14
    7528:	90 e0       	ldi	r25, 0x00	; 0
    752a:	95 d1       	rcall	.+810    	; 0x7856 <fputc>
    752c:	c1 10       	cpse	r12, r1
    752e:	f6 cf       	rjmp	.-20     	; 0x751c <vfprintf+0x640>
    7530:	15 c0       	rjmp	.+42     	; 0x755c <vfprintf+0x680>
    7532:	f4 e0       	ldi	r31, 0x04	; 4
    7534:	f5 15       	cp	r31, r5
    7536:	50 f5       	brcc	.+84     	; 0x758c <vfprintf+0x6b0>
    7538:	84 e0       	ldi	r24, 0x04	; 4
    753a:	58 1a       	sub	r5, r24
    753c:	93 fe       	sbrs	r9, 3
    753e:	1e c0       	rjmp	.+60     	; 0x757c <vfprintf+0x6a0>
    7540:	01 11       	cpse	r16, r1
    7542:	25 c0       	rjmp	.+74     	; 0x758e <vfprintf+0x6b2>
    7544:	2c 85       	ldd	r18, Y+12	; 0x0c
    7546:	23 ff       	sbrs	r18, 3
    7548:	27 c0       	rjmp	.+78     	; 0x7598 <vfprintf+0x6bc>
    754a:	00 e3       	ldi	r16, 0x30	; 48
    754c:	11 e0       	ldi	r17, 0x01	; 1
    754e:	39 2d       	mov	r19, r9
    7550:	30 71       	andi	r19, 0x10	; 16
    7552:	93 2e       	mov	r9, r19
    7554:	f8 01       	movw	r30, r16
    7556:	84 91       	lpm	r24, Z
    7558:	81 11       	cpse	r24, r1
    755a:	21 c0       	rjmp	.+66     	; 0x759e <vfprintf+0x6c2>
    755c:	55 20       	and	r5, r5
    755e:	09 f4       	brne	.+2      	; 0x7562 <vfprintf+0x686>
    7560:	fc cc       	rjmp	.-1544   	; 0x6f5a <vfprintf+0x7e>
    7562:	b7 01       	movw	r22, r14
    7564:	80 e2       	ldi	r24, 0x20	; 32
    7566:	90 e0       	ldi	r25, 0x00	; 0
    7568:	76 d1       	rcall	.+748    	; 0x7856 <fputc>
    756a:	5a 94       	dec	r5
    756c:	f7 cf       	rjmp	.-18     	; 0x755c <vfprintf+0x680>
    756e:	f7 01       	movw	r30, r14
    7570:	86 81       	ldd	r24, Z+6	; 0x06
    7572:	97 81       	ldd	r25, Z+7	; 0x07
    7574:	23 c0       	rjmp	.+70     	; 0x75bc <vfprintf+0x6e0>
    7576:	8f ef       	ldi	r24, 0xFF	; 255
    7578:	9f ef       	ldi	r25, 0xFF	; 255
    757a:	20 c0       	rjmp	.+64     	; 0x75bc <vfprintf+0x6e0>
    757c:	b7 01       	movw	r22, r14
    757e:	80 e2       	ldi	r24, 0x20	; 32
    7580:	90 e0       	ldi	r25, 0x00	; 0
    7582:	69 d1       	rcall	.+722    	; 0x7856 <fputc>
    7584:	5a 94       	dec	r5
    7586:	51 10       	cpse	r5, r1
    7588:	f9 cf       	rjmp	.-14     	; 0x757c <vfprintf+0x6a0>
    758a:	da cf       	rjmp	.-76     	; 0x7540 <vfprintf+0x664>
    758c:	51 2c       	mov	r5, r1
    758e:	b7 01       	movw	r22, r14
    7590:	80 2f       	mov	r24, r16
    7592:	90 e0       	ldi	r25, 0x00	; 0
    7594:	60 d1       	rcall	.+704    	; 0x7856 <fputc>
    7596:	d6 cf       	rjmp	.-84     	; 0x7544 <vfprintf+0x668>
    7598:	04 e3       	ldi	r16, 0x34	; 52
    759a:	11 e0       	ldi	r17, 0x01	; 1
    759c:	d8 cf       	rjmp	.-80     	; 0x754e <vfprintf+0x672>
    759e:	91 10       	cpse	r9, r1
    75a0:	80 52       	subi	r24, 0x20	; 32
    75a2:	b7 01       	movw	r22, r14
    75a4:	90 e0       	ldi	r25, 0x00	; 0
    75a6:	57 d1       	rcall	.+686    	; 0x7856 <fputc>
    75a8:	0f 5f       	subi	r16, 0xFF	; 255
    75aa:	1f 4f       	sbci	r17, 0xFF	; 255
    75ac:	d3 cf       	rjmp	.-90     	; 0x7554 <vfprintf+0x678>
    75ae:	23 e0       	ldi	r18, 0x03	; 3
    75b0:	25 15       	cp	r18, r5
    75b2:	10 f4       	brcc	.+4      	; 0x75b8 <vfprintf+0x6dc>
    75b4:	83 e0       	ldi	r24, 0x03	; 3
    75b6:	c1 cf       	rjmp	.-126    	; 0x753a <vfprintf+0x65e>
    75b8:	51 2c       	mov	r5, r1
    75ba:	c4 cf       	rjmp	.-120    	; 0x7544 <vfprintf+0x668>
    75bc:	60 96       	adiw	r28, 0x10	; 16
    75be:	0f b6       	in	r0, 0x3f	; 63
    75c0:	f8 94       	cli
    75c2:	de bf       	out	0x3e, r29	; 62
    75c4:	0f be       	out	0x3f, r0	; 63
    75c6:	cd bf       	out	0x3d, r28	; 61
    75c8:	df 91       	pop	r29
    75ca:	cf 91       	pop	r28
    75cc:	1f 91       	pop	r17
    75ce:	0f 91       	pop	r16
    75d0:	ff 90       	pop	r15
    75d2:	ef 90       	pop	r14
    75d4:	df 90       	pop	r13
    75d6:	cf 90       	pop	r12
    75d8:	bf 90       	pop	r11
    75da:	af 90       	pop	r10
    75dc:	9f 90       	pop	r9
    75de:	8f 90       	pop	r8
    75e0:	7f 90       	pop	r7
    75e2:	6f 90       	pop	r6
    75e4:	5f 90       	pop	r5
    75e6:	4f 90       	pop	r4
    75e8:	3f 90       	pop	r3
    75ea:	2f 90       	pop	r2
    75ec:	08 95       	ret

000075ee <__divmodhi4>:
    75ee:	97 fb       	bst	r25, 7
    75f0:	07 2e       	mov	r0, r23
    75f2:	16 f4       	brtc	.+4      	; 0x75f8 <__divmodhi4+0xa>
    75f4:	00 94       	com	r0
    75f6:	06 d0       	rcall	.+12     	; 0x7604 <__divmodhi4_neg1>
    75f8:	77 fd       	sbrc	r23, 7
    75fa:	08 d0       	rcall	.+16     	; 0x760c <__divmodhi4_neg2>
    75fc:	1a d0       	rcall	.+52     	; 0x7632 <__udivmodhi4>
    75fe:	07 fc       	sbrc	r0, 7
    7600:	05 d0       	rcall	.+10     	; 0x760c <__divmodhi4_neg2>
    7602:	3e f4       	brtc	.+14     	; 0x7612 <__divmodhi4_exit>

00007604 <__divmodhi4_neg1>:
    7604:	90 95       	com	r25
    7606:	81 95       	neg	r24
    7608:	9f 4f       	sbci	r25, 0xFF	; 255
    760a:	08 95       	ret

0000760c <__divmodhi4_neg2>:
    760c:	70 95       	com	r23
    760e:	61 95       	neg	r22
    7610:	7f 4f       	sbci	r23, 0xFF	; 255

00007612 <__divmodhi4_exit>:
    7612:	08 95       	ret

00007614 <__umulhisi3>:
    7614:	a2 9f       	mul	r26, r18
    7616:	b0 01       	movw	r22, r0
    7618:	b3 9f       	mul	r27, r19
    761a:	c0 01       	movw	r24, r0
    761c:	a3 9f       	mul	r26, r19
    761e:	70 0d       	add	r23, r0
    7620:	81 1d       	adc	r24, r1
    7622:	11 24       	eor	r1, r1
    7624:	91 1d       	adc	r25, r1
    7626:	b2 9f       	mul	r27, r18
    7628:	70 0d       	add	r23, r0
    762a:	81 1d       	adc	r24, r1
    762c:	11 24       	eor	r1, r1
    762e:	91 1d       	adc	r25, r1
    7630:	08 95       	ret

00007632 <__udivmodhi4>:
    7632:	aa 1b       	sub	r26, r26
    7634:	bb 1b       	sub	r27, r27
    7636:	51 e1       	ldi	r21, 0x11	; 17
    7638:	07 c0       	rjmp	.+14     	; 0x7648 <__udivmodhi4_ep>

0000763a <__udivmodhi4_loop>:
    763a:	aa 1f       	adc	r26, r26
    763c:	bb 1f       	adc	r27, r27
    763e:	a6 17       	cp	r26, r22
    7640:	b7 07       	cpc	r27, r23
    7642:	10 f0       	brcs	.+4      	; 0x7648 <__udivmodhi4_ep>
    7644:	a6 1b       	sub	r26, r22
    7646:	b7 0b       	sbc	r27, r23

00007648 <__udivmodhi4_ep>:
    7648:	88 1f       	adc	r24, r24
    764a:	99 1f       	adc	r25, r25
    764c:	5a 95       	dec	r21
    764e:	a9 f7       	brne	.-22     	; 0x763a <__udivmodhi4_loop>
    7650:	80 95       	com	r24
    7652:	90 95       	com	r25
    7654:	bc 01       	movw	r22, r24
    7656:	cd 01       	movw	r24, r26
    7658:	08 95       	ret

0000765a <__ftoa_engine>:
    765a:	28 30       	cpi	r18, 0x08	; 8
    765c:	08 f0       	brcs	.+2      	; 0x7660 <__ftoa_engine+0x6>
    765e:	27 e0       	ldi	r18, 0x07	; 7
    7660:	33 27       	eor	r19, r19
    7662:	da 01       	movw	r26, r20
    7664:	99 0f       	add	r25, r25
    7666:	31 1d       	adc	r19, r1
    7668:	87 fd       	sbrc	r24, 7
    766a:	91 60       	ori	r25, 0x01	; 1
    766c:	00 96       	adiw	r24, 0x00	; 0
    766e:	61 05       	cpc	r22, r1
    7670:	71 05       	cpc	r23, r1
    7672:	39 f4       	brne	.+14     	; 0x7682 <__ftoa_engine+0x28>
    7674:	32 60       	ori	r19, 0x02	; 2
    7676:	2e 5f       	subi	r18, 0xFE	; 254
    7678:	3d 93       	st	X+, r19
    767a:	30 e3       	ldi	r19, 0x30	; 48
    767c:	2a 95       	dec	r18
    767e:	e1 f7       	brne	.-8      	; 0x7678 <__ftoa_engine+0x1e>
    7680:	08 95       	ret
    7682:	9f 3f       	cpi	r25, 0xFF	; 255
    7684:	30 f0       	brcs	.+12     	; 0x7692 <__ftoa_engine+0x38>
    7686:	80 38       	cpi	r24, 0x80	; 128
    7688:	71 05       	cpc	r23, r1
    768a:	61 05       	cpc	r22, r1
    768c:	09 f0       	breq	.+2      	; 0x7690 <__ftoa_engine+0x36>
    768e:	3c 5f       	subi	r19, 0xFC	; 252
    7690:	3c 5f       	subi	r19, 0xFC	; 252
    7692:	3d 93       	st	X+, r19
    7694:	91 30       	cpi	r25, 0x01	; 1
    7696:	08 f0       	brcs	.+2      	; 0x769a <__ftoa_engine+0x40>
    7698:	80 68       	ori	r24, 0x80	; 128
    769a:	91 1d       	adc	r25, r1
    769c:	df 93       	push	r29
    769e:	cf 93       	push	r28
    76a0:	1f 93       	push	r17
    76a2:	0f 93       	push	r16
    76a4:	ff 92       	push	r15
    76a6:	ef 92       	push	r14
    76a8:	19 2f       	mov	r17, r25
    76aa:	98 7f       	andi	r25, 0xF8	; 248
    76ac:	96 95       	lsr	r25
    76ae:	e9 2f       	mov	r30, r25
    76b0:	96 95       	lsr	r25
    76b2:	96 95       	lsr	r25
    76b4:	e9 0f       	add	r30, r25
    76b6:	ff 27       	eor	r31, r31
    76b8:	ee 56       	subi	r30, 0x6E	; 110
    76ba:	fe 4f       	sbci	r31, 0xFE	; 254
    76bc:	99 27       	eor	r25, r25
    76be:	33 27       	eor	r19, r19
    76c0:	ee 24       	eor	r14, r14
    76c2:	ff 24       	eor	r15, r15
    76c4:	a7 01       	movw	r20, r14
    76c6:	e7 01       	movw	r28, r14
    76c8:	05 90       	lpm	r0, Z+
    76ca:	08 94       	sec
    76cc:	07 94       	ror	r0
    76ce:	28 f4       	brcc	.+10     	; 0x76da <__ftoa_engine+0x80>
    76d0:	36 0f       	add	r19, r22
    76d2:	e7 1e       	adc	r14, r23
    76d4:	f8 1e       	adc	r15, r24
    76d6:	49 1f       	adc	r20, r25
    76d8:	51 1d       	adc	r21, r1
    76da:	66 0f       	add	r22, r22
    76dc:	77 1f       	adc	r23, r23
    76de:	88 1f       	adc	r24, r24
    76e0:	99 1f       	adc	r25, r25
    76e2:	06 94       	lsr	r0
    76e4:	a1 f7       	brne	.-24     	; 0x76ce <__ftoa_engine+0x74>
    76e6:	05 90       	lpm	r0, Z+
    76e8:	07 94       	ror	r0
    76ea:	28 f4       	brcc	.+10     	; 0x76f6 <__ftoa_engine+0x9c>
    76ec:	e7 0e       	add	r14, r23
    76ee:	f8 1e       	adc	r15, r24
    76f0:	49 1f       	adc	r20, r25
    76f2:	56 1f       	adc	r21, r22
    76f4:	c1 1d       	adc	r28, r1
    76f6:	77 0f       	add	r23, r23
    76f8:	88 1f       	adc	r24, r24
    76fa:	99 1f       	adc	r25, r25
    76fc:	66 1f       	adc	r22, r22
    76fe:	06 94       	lsr	r0
    7700:	a1 f7       	brne	.-24     	; 0x76ea <__ftoa_engine+0x90>
    7702:	05 90       	lpm	r0, Z+
    7704:	07 94       	ror	r0
    7706:	28 f4       	brcc	.+10     	; 0x7712 <__ftoa_engine+0xb8>
    7708:	f8 0e       	add	r15, r24
    770a:	49 1f       	adc	r20, r25
    770c:	56 1f       	adc	r21, r22
    770e:	c7 1f       	adc	r28, r23
    7710:	d1 1d       	adc	r29, r1
    7712:	88 0f       	add	r24, r24
    7714:	99 1f       	adc	r25, r25
    7716:	66 1f       	adc	r22, r22
    7718:	77 1f       	adc	r23, r23
    771a:	06 94       	lsr	r0
    771c:	a1 f7       	brne	.-24     	; 0x7706 <__ftoa_engine+0xac>
    771e:	05 90       	lpm	r0, Z+
    7720:	07 94       	ror	r0
    7722:	20 f4       	brcc	.+8      	; 0x772c <__ftoa_engine+0xd2>
    7724:	49 0f       	add	r20, r25
    7726:	56 1f       	adc	r21, r22
    7728:	c7 1f       	adc	r28, r23
    772a:	d8 1f       	adc	r29, r24
    772c:	99 0f       	add	r25, r25
    772e:	66 1f       	adc	r22, r22
    7730:	77 1f       	adc	r23, r23
    7732:	88 1f       	adc	r24, r24
    7734:	06 94       	lsr	r0
    7736:	a9 f7       	brne	.-22     	; 0x7722 <__ftoa_engine+0xc8>
    7738:	84 91       	lpm	r24, Z
    773a:	10 95       	com	r17
    773c:	17 70       	andi	r17, 0x07	; 7
    773e:	41 f0       	breq	.+16     	; 0x7750 <__ftoa_engine+0xf6>
    7740:	d6 95       	lsr	r29
    7742:	c7 95       	ror	r28
    7744:	57 95       	ror	r21
    7746:	47 95       	ror	r20
    7748:	f7 94       	ror	r15
    774a:	e7 94       	ror	r14
    774c:	1a 95       	dec	r17
    774e:	c1 f7       	brne	.-16     	; 0x7740 <__ftoa_engine+0xe6>
    7750:	e8 e3       	ldi	r30, 0x38	; 56
    7752:	f1 e0       	ldi	r31, 0x01	; 1
    7754:	68 94       	set
    7756:	15 90       	lpm	r1, Z+
    7758:	15 91       	lpm	r17, Z+
    775a:	35 91       	lpm	r19, Z+
    775c:	65 91       	lpm	r22, Z+
    775e:	95 91       	lpm	r25, Z+
    7760:	05 90       	lpm	r0, Z+
    7762:	7f e2       	ldi	r23, 0x2F	; 47
    7764:	73 95       	inc	r23
    7766:	e1 18       	sub	r14, r1
    7768:	f1 0a       	sbc	r15, r17
    776a:	43 0b       	sbc	r20, r19
    776c:	56 0b       	sbc	r21, r22
    776e:	c9 0b       	sbc	r28, r25
    7770:	d0 09       	sbc	r29, r0
    7772:	c0 f7       	brcc	.-16     	; 0x7764 <__ftoa_engine+0x10a>
    7774:	e1 0c       	add	r14, r1
    7776:	f1 1e       	adc	r15, r17
    7778:	43 1f       	adc	r20, r19
    777a:	56 1f       	adc	r21, r22
    777c:	c9 1f       	adc	r28, r25
    777e:	d0 1d       	adc	r29, r0
    7780:	7e f4       	brtc	.+30     	; 0x77a0 <__ftoa_engine+0x146>
    7782:	70 33       	cpi	r23, 0x30	; 48
    7784:	11 f4       	brne	.+4      	; 0x778a <__ftoa_engine+0x130>
    7786:	8a 95       	dec	r24
    7788:	e6 cf       	rjmp	.-52     	; 0x7756 <__ftoa_engine+0xfc>
    778a:	e8 94       	clt
    778c:	01 50       	subi	r16, 0x01	; 1
    778e:	30 f0       	brcs	.+12     	; 0x779c <__ftoa_engine+0x142>
    7790:	08 0f       	add	r16, r24
    7792:	0a f4       	brpl	.+2      	; 0x7796 <__ftoa_engine+0x13c>
    7794:	00 27       	eor	r16, r16
    7796:	02 17       	cp	r16, r18
    7798:	08 f4       	brcc	.+2      	; 0x779c <__ftoa_engine+0x142>
    779a:	20 2f       	mov	r18, r16
    779c:	23 95       	inc	r18
    779e:	02 2f       	mov	r16, r18
    77a0:	7a 33       	cpi	r23, 0x3A	; 58
    77a2:	28 f0       	brcs	.+10     	; 0x77ae <__ftoa_engine+0x154>
    77a4:	79 e3       	ldi	r23, 0x39	; 57
    77a6:	7d 93       	st	X+, r23
    77a8:	2a 95       	dec	r18
    77aa:	e9 f7       	brne	.-6      	; 0x77a6 <__ftoa_engine+0x14c>
    77ac:	10 c0       	rjmp	.+32     	; 0x77ce <__ftoa_engine+0x174>
    77ae:	7d 93       	st	X+, r23
    77b0:	2a 95       	dec	r18
    77b2:	89 f6       	brne	.-94     	; 0x7756 <__ftoa_engine+0xfc>
    77b4:	06 94       	lsr	r0
    77b6:	97 95       	ror	r25
    77b8:	67 95       	ror	r22
    77ba:	37 95       	ror	r19
    77bc:	17 95       	ror	r17
    77be:	17 94       	ror	r1
    77c0:	e1 18       	sub	r14, r1
    77c2:	f1 0a       	sbc	r15, r17
    77c4:	43 0b       	sbc	r20, r19
    77c6:	56 0b       	sbc	r21, r22
    77c8:	c9 0b       	sbc	r28, r25
    77ca:	d0 09       	sbc	r29, r0
    77cc:	98 f0       	brcs	.+38     	; 0x77f4 <__ftoa_engine+0x19a>
    77ce:	23 95       	inc	r18
    77d0:	7e 91       	ld	r23, -X
    77d2:	73 95       	inc	r23
    77d4:	7a 33       	cpi	r23, 0x3A	; 58
    77d6:	08 f0       	brcs	.+2      	; 0x77da <__ftoa_engine+0x180>
    77d8:	70 e3       	ldi	r23, 0x30	; 48
    77da:	7c 93       	st	X, r23
    77dc:	20 13       	cpse	r18, r16
    77de:	b8 f7       	brcc	.-18     	; 0x77ce <__ftoa_engine+0x174>
    77e0:	7e 91       	ld	r23, -X
    77e2:	70 61       	ori	r23, 0x10	; 16
    77e4:	7d 93       	st	X+, r23
    77e6:	30 f0       	brcs	.+12     	; 0x77f4 <__ftoa_engine+0x19a>
    77e8:	83 95       	inc	r24
    77ea:	71 e3       	ldi	r23, 0x31	; 49
    77ec:	7d 93       	st	X+, r23
    77ee:	70 e3       	ldi	r23, 0x30	; 48
    77f0:	2a 95       	dec	r18
    77f2:	e1 f7       	brne	.-8      	; 0x77ec <__ftoa_engine+0x192>
    77f4:	11 24       	eor	r1, r1
    77f6:	ef 90       	pop	r14
    77f8:	ff 90       	pop	r15
    77fa:	0f 91       	pop	r16
    77fc:	1f 91       	pop	r17
    77fe:	cf 91       	pop	r28
    7800:	df 91       	pop	r29
    7802:	99 27       	eor	r25, r25
    7804:	87 fd       	sbrc	r24, 7
    7806:	90 95       	com	r25
    7808:	08 95       	ret

0000780a <strnlen_P>:
    780a:	fc 01       	movw	r30, r24
    780c:	05 90       	lpm	r0, Z+
    780e:	61 50       	subi	r22, 0x01	; 1
    7810:	70 40       	sbci	r23, 0x00	; 0
    7812:	01 10       	cpse	r0, r1
    7814:	d8 f7       	brcc	.-10     	; 0x780c <strnlen_P+0x2>
    7816:	80 95       	com	r24
    7818:	90 95       	com	r25
    781a:	8e 0f       	add	r24, r30
    781c:	9f 1f       	adc	r25, r31
    781e:	08 95       	ret

00007820 <memcpy>:
    7820:	fb 01       	movw	r30, r22
    7822:	dc 01       	movw	r26, r24
    7824:	02 c0       	rjmp	.+4      	; 0x782a <memcpy+0xa>
    7826:	01 90       	ld	r0, Z+
    7828:	0d 92       	st	X+, r0
    782a:	41 50       	subi	r20, 0x01	; 1
    782c:	50 40       	sbci	r21, 0x00	; 0
    782e:	d8 f7       	brcc	.-10     	; 0x7826 <memcpy+0x6>
    7830:	08 95       	ret

00007832 <memset>:
    7832:	dc 01       	movw	r26, r24
    7834:	01 c0       	rjmp	.+2      	; 0x7838 <memset+0x6>
    7836:	6d 93       	st	X+, r22
    7838:	41 50       	subi	r20, 0x01	; 1
    783a:	50 40       	sbci	r21, 0x00	; 0
    783c:	e0 f7       	brcc	.-8      	; 0x7836 <memset+0x4>
    783e:	08 95       	ret

00007840 <strnlen>:
    7840:	fc 01       	movw	r30, r24
    7842:	61 50       	subi	r22, 0x01	; 1
    7844:	70 40       	sbci	r23, 0x00	; 0
    7846:	01 90       	ld	r0, Z+
    7848:	01 10       	cpse	r0, r1
    784a:	d8 f7       	brcc	.-10     	; 0x7842 <strnlen+0x2>
    784c:	80 95       	com	r24
    784e:	90 95       	com	r25
    7850:	8e 0f       	add	r24, r30
    7852:	9f 1f       	adc	r25, r31
    7854:	08 95       	ret

00007856 <fputc>:
    7856:	0f 93       	push	r16
    7858:	1f 93       	push	r17
    785a:	cf 93       	push	r28
    785c:	df 93       	push	r29
    785e:	fb 01       	movw	r30, r22
    7860:	23 81       	ldd	r18, Z+3	; 0x03
    7862:	21 fd       	sbrc	r18, 1
    7864:	03 c0       	rjmp	.+6      	; 0x786c <fputc+0x16>
    7866:	8f ef       	ldi	r24, 0xFF	; 255
    7868:	9f ef       	ldi	r25, 0xFF	; 255
    786a:	2c c0       	rjmp	.+88     	; 0x78c4 <fputc+0x6e>
    786c:	22 ff       	sbrs	r18, 2
    786e:	16 c0       	rjmp	.+44     	; 0x789c <fputc+0x46>
    7870:	46 81       	ldd	r20, Z+6	; 0x06
    7872:	57 81       	ldd	r21, Z+7	; 0x07
    7874:	24 81       	ldd	r18, Z+4	; 0x04
    7876:	35 81       	ldd	r19, Z+5	; 0x05
    7878:	42 17       	cp	r20, r18
    787a:	53 07       	cpc	r21, r19
    787c:	44 f4       	brge	.+16     	; 0x788e <fputc+0x38>
    787e:	a0 81       	ld	r26, Z
    7880:	b1 81       	ldd	r27, Z+1	; 0x01
    7882:	9d 01       	movw	r18, r26
    7884:	2f 5f       	subi	r18, 0xFF	; 255
    7886:	3f 4f       	sbci	r19, 0xFF	; 255
    7888:	31 83       	std	Z+1, r19	; 0x01
    788a:	20 83       	st	Z, r18
    788c:	8c 93       	st	X, r24
    788e:	26 81       	ldd	r18, Z+6	; 0x06
    7890:	37 81       	ldd	r19, Z+7	; 0x07
    7892:	2f 5f       	subi	r18, 0xFF	; 255
    7894:	3f 4f       	sbci	r19, 0xFF	; 255
    7896:	37 83       	std	Z+7, r19	; 0x07
    7898:	26 83       	std	Z+6, r18	; 0x06
    789a:	14 c0       	rjmp	.+40     	; 0x78c4 <fputc+0x6e>
    789c:	8b 01       	movw	r16, r22
    789e:	ec 01       	movw	r28, r24
    78a0:	fb 01       	movw	r30, r22
    78a2:	00 84       	ldd	r0, Z+8	; 0x08
    78a4:	f1 85       	ldd	r31, Z+9	; 0x09
    78a6:	e0 2d       	mov	r30, r0
    78a8:	19 95       	eicall
    78aa:	89 2b       	or	r24, r25
    78ac:	e1 f6       	brne	.-72     	; 0x7866 <fputc+0x10>
    78ae:	d8 01       	movw	r26, r16
    78b0:	16 96       	adiw	r26, 0x06	; 6
    78b2:	8d 91       	ld	r24, X+
    78b4:	9c 91       	ld	r25, X
    78b6:	17 97       	sbiw	r26, 0x07	; 7
    78b8:	01 96       	adiw	r24, 0x01	; 1
    78ba:	17 96       	adiw	r26, 0x07	; 7
    78bc:	9c 93       	st	X, r25
    78be:	8e 93       	st	-X, r24
    78c0:	16 97       	sbiw	r26, 0x06	; 6
    78c2:	ce 01       	movw	r24, r28
    78c4:	df 91       	pop	r29
    78c6:	cf 91       	pop	r28
    78c8:	1f 91       	pop	r17
    78ca:	0f 91       	pop	r16
    78cc:	08 95       	ret

000078ce <vsprintf>:
    78ce:	0f 93       	push	r16
    78d0:	1f 93       	push	r17
    78d2:	cf 93       	push	r28
    78d4:	df 93       	push	r29
    78d6:	cd b7       	in	r28, 0x3d	; 61
    78d8:	de b7       	in	r29, 0x3e	; 62
    78da:	2e 97       	sbiw	r28, 0x0e	; 14
    78dc:	0f b6       	in	r0, 0x3f	; 63
    78de:	f8 94       	cli
    78e0:	de bf       	out	0x3e, r29	; 62
    78e2:	0f be       	out	0x3f, r0	; 63
    78e4:	cd bf       	out	0x3d, r28	; 61
    78e6:	8c 01       	movw	r16, r24
    78e8:	86 e0       	ldi	r24, 0x06	; 6
    78ea:	8c 83       	std	Y+4, r24	; 0x04
    78ec:	1a 83       	std	Y+2, r17	; 0x02
    78ee:	09 83       	std	Y+1, r16	; 0x01
    78f0:	8f ef       	ldi	r24, 0xFF	; 255
    78f2:	9f e7       	ldi	r25, 0x7F	; 127
    78f4:	9e 83       	std	Y+6, r25	; 0x06
    78f6:	8d 83       	std	Y+5, r24	; 0x05
    78f8:	ce 01       	movw	r24, r28
    78fa:	01 96       	adiw	r24, 0x01	; 1
    78fc:	ef da       	rcall	.-2594   	; 0x6edc <vfprintf>
    78fe:	ef 81       	ldd	r30, Y+7	; 0x07
    7900:	f8 85       	ldd	r31, Y+8	; 0x08
    7902:	e0 0f       	add	r30, r16
    7904:	f1 1f       	adc	r31, r17
    7906:	10 82       	st	Z, r1
    7908:	2e 96       	adiw	r28, 0x0e	; 14
    790a:	0f b6       	in	r0, 0x3f	; 63
    790c:	f8 94       	cli
    790e:	de bf       	out	0x3e, r29	; 62
    7910:	0f be       	out	0x3f, r0	; 63
    7912:	cd bf       	out	0x3d, r28	; 61
    7914:	df 91       	pop	r29
    7916:	cf 91       	pop	r28
    7918:	1f 91       	pop	r17
    791a:	0f 91       	pop	r16
    791c:	08 95       	ret

0000791e <__ultoa_invert>:
    791e:	fa 01       	movw	r30, r20
    7920:	aa 27       	eor	r26, r26
    7922:	28 30       	cpi	r18, 0x08	; 8
    7924:	51 f1       	breq	.+84     	; 0x797a <__ultoa_invert+0x5c>
    7926:	20 31       	cpi	r18, 0x10	; 16
    7928:	81 f1       	breq	.+96     	; 0x798a <__ultoa_invert+0x6c>
    792a:	e8 94       	clt
    792c:	6f 93       	push	r22
    792e:	6e 7f       	andi	r22, 0xFE	; 254
    7930:	6e 5f       	subi	r22, 0xFE	; 254
    7932:	7f 4f       	sbci	r23, 0xFF	; 255
    7934:	8f 4f       	sbci	r24, 0xFF	; 255
    7936:	9f 4f       	sbci	r25, 0xFF	; 255
    7938:	af 4f       	sbci	r26, 0xFF	; 255
    793a:	b1 e0       	ldi	r27, 0x01	; 1
    793c:	3e d0       	rcall	.+124    	; 0x79ba <__ultoa_invert+0x9c>
    793e:	b4 e0       	ldi	r27, 0x04	; 4
    7940:	3c d0       	rcall	.+120    	; 0x79ba <__ultoa_invert+0x9c>
    7942:	67 0f       	add	r22, r23
    7944:	78 1f       	adc	r23, r24
    7946:	89 1f       	adc	r24, r25
    7948:	9a 1f       	adc	r25, r26
    794a:	a1 1d       	adc	r26, r1
    794c:	68 0f       	add	r22, r24
    794e:	79 1f       	adc	r23, r25
    7950:	8a 1f       	adc	r24, r26
    7952:	91 1d       	adc	r25, r1
    7954:	a1 1d       	adc	r26, r1
    7956:	6a 0f       	add	r22, r26
    7958:	71 1d       	adc	r23, r1
    795a:	81 1d       	adc	r24, r1
    795c:	91 1d       	adc	r25, r1
    795e:	a1 1d       	adc	r26, r1
    7960:	20 d0       	rcall	.+64     	; 0x79a2 <__ultoa_invert+0x84>
    7962:	09 f4       	brne	.+2      	; 0x7966 <__ultoa_invert+0x48>
    7964:	68 94       	set
    7966:	3f 91       	pop	r19
    7968:	2a e0       	ldi	r18, 0x0A	; 10
    796a:	26 9f       	mul	r18, r22
    796c:	11 24       	eor	r1, r1
    796e:	30 19       	sub	r19, r0
    7970:	30 5d       	subi	r19, 0xD0	; 208
    7972:	31 93       	st	Z+, r19
    7974:	de f6       	brtc	.-74     	; 0x792c <__ultoa_invert+0xe>
    7976:	cf 01       	movw	r24, r30
    7978:	08 95       	ret
    797a:	46 2f       	mov	r20, r22
    797c:	47 70       	andi	r20, 0x07	; 7
    797e:	40 5d       	subi	r20, 0xD0	; 208
    7980:	41 93       	st	Z+, r20
    7982:	b3 e0       	ldi	r27, 0x03	; 3
    7984:	0f d0       	rcall	.+30     	; 0x79a4 <__ultoa_invert+0x86>
    7986:	c9 f7       	brne	.-14     	; 0x797a <__ultoa_invert+0x5c>
    7988:	f6 cf       	rjmp	.-20     	; 0x7976 <__ultoa_invert+0x58>
    798a:	46 2f       	mov	r20, r22
    798c:	4f 70       	andi	r20, 0x0F	; 15
    798e:	40 5d       	subi	r20, 0xD0	; 208
    7990:	4a 33       	cpi	r20, 0x3A	; 58
    7992:	18 f0       	brcs	.+6      	; 0x799a <__ultoa_invert+0x7c>
    7994:	49 5d       	subi	r20, 0xD9	; 217
    7996:	31 fd       	sbrc	r19, 1
    7998:	40 52       	subi	r20, 0x20	; 32
    799a:	41 93       	st	Z+, r20
    799c:	02 d0       	rcall	.+4      	; 0x79a2 <__ultoa_invert+0x84>
    799e:	a9 f7       	brne	.-22     	; 0x798a <__ultoa_invert+0x6c>
    79a0:	ea cf       	rjmp	.-44     	; 0x7976 <__ultoa_invert+0x58>
    79a2:	b4 e0       	ldi	r27, 0x04	; 4
    79a4:	a6 95       	lsr	r26
    79a6:	97 95       	ror	r25
    79a8:	87 95       	ror	r24
    79aa:	77 95       	ror	r23
    79ac:	67 95       	ror	r22
    79ae:	ba 95       	dec	r27
    79b0:	c9 f7       	brne	.-14     	; 0x79a4 <__ultoa_invert+0x86>
    79b2:	00 97       	sbiw	r24, 0x00	; 0
    79b4:	61 05       	cpc	r22, r1
    79b6:	71 05       	cpc	r23, r1
    79b8:	08 95       	ret
    79ba:	9b 01       	movw	r18, r22
    79bc:	ac 01       	movw	r20, r24
    79be:	0a 2e       	mov	r0, r26
    79c0:	06 94       	lsr	r0
    79c2:	57 95       	ror	r21
    79c4:	47 95       	ror	r20
    79c6:	37 95       	ror	r19
    79c8:	27 95       	ror	r18
    79ca:	ba 95       	dec	r27
    79cc:	c9 f7       	brne	.-14     	; 0x79c0 <__ultoa_invert+0xa2>
    79ce:	62 0f       	add	r22, r18
    79d0:	73 1f       	adc	r23, r19
    79d2:	84 1f       	adc	r24, r20
    79d4:	95 1f       	adc	r25, r21
    79d6:	a0 1d       	adc	r26, r0
    79d8:	08 95       	ret

000079da <_exit>:
    79da:	f8 94       	cli

000079dc <__stop_program>:
    79dc:	ff cf       	rjmp	.-2      	; 0x79dc <__stop_program>
