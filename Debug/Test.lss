
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000104  00800200  00005ae6  00005b7a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00005ae6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000014ba  00800304  00800304  00005c7e  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00005c7e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00005cdc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000780  00000000  00000000  00005d1c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a61d  00000000  00000000  0000649c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000021b2  00000000  00000000  00010ab9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005f92  00000000  00000000  00012c6b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000192c  00000000  00000000  00018c00  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002edb  00000000  00000000  0001a52c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000ad0b  00000000  00000000  0001d407  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000850  00000000  00000000  00028112  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	fa c0       	rjmp	.+500    	; 0x1f6 <__ctors_end>
       2:	00 00       	nop
       4:	19 c1       	rjmp	.+562    	; 0x238 <__bad_interrupt>
       6:	00 00       	nop
       8:	17 c1       	rjmp	.+558    	; 0x238 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 50 0d 	jmp	0x1aa0	; 0x1aa0 <__vector_3>
      10:	0c 94 3f 0d 	jmp	0x1a7e	; 0x1a7e <__vector_4>
      14:	0c 94 61 0d 	jmp	0x1ac2	; 0x1ac2 <__vector_5>
      18:	0f c1       	rjmp	.+542    	; 0x238 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	0d c1       	rjmp	.+538    	; 0x238 <__bad_interrupt>
      1e:	00 00       	nop
      20:	0b c1       	rjmp	.+534    	; 0x238 <__bad_interrupt>
      22:	00 00       	nop
      24:	09 c1       	rjmp	.+530    	; 0x238 <__bad_interrupt>
      26:	00 00       	nop
      28:	07 c1       	rjmp	.+526    	; 0x238 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	05 c1       	rjmp	.+522    	; 0x238 <__bad_interrupt>
      2e:	00 00       	nop
      30:	03 c1       	rjmp	.+518    	; 0x238 <__bad_interrupt>
      32:	00 00       	nop
      34:	01 c1       	rjmp	.+514    	; 0x238 <__bad_interrupt>
      36:	00 00       	nop
      38:	ff c0       	rjmp	.+510    	; 0x238 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	fd c0       	rjmp	.+506    	; 0x238 <__bad_interrupt>
      3e:	00 00       	nop
      40:	fb c0       	rjmp	.+502    	; 0x238 <__bad_interrupt>
      42:	00 00       	nop
      44:	f9 c0       	rjmp	.+498    	; 0x238 <__bad_interrupt>
      46:	00 00       	nop
      48:	f7 c0       	rjmp	.+494    	; 0x238 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	f5 c0       	rjmp	.+490    	; 0x238 <__bad_interrupt>
      4e:	00 00       	nop
      50:	f3 c0       	rjmp	.+486    	; 0x238 <__bad_interrupt>
      52:	00 00       	nop
      54:	f1 c0       	rjmp	.+482    	; 0x238 <__bad_interrupt>
      56:	00 00       	nop
      58:	ef c0       	rjmp	.+478    	; 0x238 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	ed c0       	rjmp	.+474    	; 0x238 <__bad_interrupt>
      5e:	00 00       	nop
      60:	eb c0       	rjmp	.+470    	; 0x238 <__bad_interrupt>
      62:	00 00       	nop
      64:	e9 c0       	rjmp	.+466    	; 0x238 <__bad_interrupt>
      66:	00 00       	nop
      68:	e7 c0       	rjmp	.+462    	; 0x238 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	e5 c0       	rjmp	.+458    	; 0x238 <__bad_interrupt>
      6e:	00 00       	nop
      70:	e3 c0       	rjmp	.+454    	; 0x238 <__bad_interrupt>
      72:	00 00       	nop
      74:	e1 c0       	rjmp	.+450    	; 0x238 <__bad_interrupt>
      76:	00 00       	nop
      78:	df c0       	rjmp	.+446    	; 0x238 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	dd c0       	rjmp	.+442    	; 0x238 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 5b 10 	jmp	0x20b6	; 0x20b6 <__vector_32>
      84:	d9 c0       	rjmp	.+434    	; 0x238 <__bad_interrupt>
      86:	00 00       	nop
      88:	d7 c0       	rjmp	.+430    	; 0x238 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	d5 c0       	rjmp	.+426    	; 0x238 <__bad_interrupt>
      8e:	00 00       	nop
      90:	d3 c0       	rjmp	.+422    	; 0x238 <__bad_interrupt>
      92:	00 00       	nop
      94:	d1 c0       	rjmp	.+418    	; 0x238 <__bad_interrupt>
      96:	00 00       	nop
      98:	cf c0       	rjmp	.+414    	; 0x238 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	cd c0       	rjmp	.+410    	; 0x238 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	cb c0       	rjmp	.+406    	; 0x238 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c9 c0       	rjmp	.+402    	; 0x238 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	c7 c0       	rjmp	.+398    	; 0x238 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	c5 c0       	rjmp	.+394    	; 0x238 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	c3 c0       	rjmp	.+390    	; 0x238 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	c1 c0       	rjmp	.+386    	; 0x238 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	bf c0       	rjmp	.+382    	; 0x238 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	bd c0       	rjmp	.+378    	; 0x238 <__bad_interrupt>
      be:	00 00       	nop
      c0:	bb c0       	rjmp	.+374    	; 0x238 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b9 c0       	rjmp	.+370    	; 0x238 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	b7 c0       	rjmp	.+366    	; 0x238 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 33 26 	jmp	0x4c66	; 0x4c66 <__vector_51>
      d0:	b3 c0       	rjmp	.+358    	; 0x238 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	b1 c0       	rjmp	.+354    	; 0x238 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	af c0       	rjmp	.+350    	; 0x238 <__bad_interrupt>
      da:	00 00       	nop
      dc:	ad c0       	rjmp	.+346    	; 0x238 <__bad_interrupt>
      de:	00 00       	nop
      e0:	ab c0       	rjmp	.+342    	; 0x238 <__bad_interrupt>
	...

000000e4 <__trampolines_end>:
      e4:	6e 61       	ori	r22, 0x1E	; 30
      e6:	6e 00       	.word	0x006e	; ????

000000e8 <__c.2332>:
      e8:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
      f8:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     108:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     118:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     128:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     138:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     148:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     158:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     168:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     178:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     188:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     198:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1a8:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     1b8:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     1c8:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     1d8:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

000001e6 <prvIdleTask>:
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     1e6:	cb e4       	ldi	r28, 0x4B	; 75
     1e8:	d6 e1       	ldi	r29, 0x16	; 22
     1ea:	88 81       	ld	r24, Y
     1ec:	82 30       	cpi	r24, 0x02	; 2
     1ee:	f0 f3       	brcs	.-4      	; 0x1ec <prvIdleTask+0x6>
     1f0:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
     1f4:	fa cf       	rjmp	.-12     	; 0x1ea <prvIdleTask+0x4>

000001f6 <__ctors_end>:
     1f6:	11 24       	eor	r1, r1
     1f8:	1f be       	out	0x3f, r1	; 63
     1fa:	cf ef       	ldi	r28, 0xFF	; 255
     1fc:	d1 e2       	ldi	r29, 0x21	; 33
     1fe:	de bf       	out	0x3e, r29	; 62
     200:	cd bf       	out	0x3d, r28	; 61
     202:	00 e0       	ldi	r16, 0x00	; 0
     204:	0c bf       	out	0x3c, r16	; 60

00000206 <__do_copy_data>:
     206:	13 e0       	ldi	r17, 0x03	; 3
     208:	a0 e0       	ldi	r26, 0x00	; 0
     20a:	b2 e0       	ldi	r27, 0x02	; 2
     20c:	e6 ee       	ldi	r30, 0xE6	; 230
     20e:	fa e5       	ldi	r31, 0x5A	; 90
     210:	00 e0       	ldi	r16, 0x00	; 0
     212:	0b bf       	out	0x3b, r16	; 59
     214:	02 c0       	rjmp	.+4      	; 0x21a <__do_copy_data+0x14>
     216:	07 90       	elpm	r0, Z+
     218:	0d 92       	st	X+, r0
     21a:	a4 30       	cpi	r26, 0x04	; 4
     21c:	b1 07       	cpc	r27, r17
     21e:	d9 f7       	brne	.-10     	; 0x216 <__do_copy_data+0x10>

00000220 <__do_clear_bss>:
     220:	27 e1       	ldi	r18, 0x17	; 23
     222:	a4 e0       	ldi	r26, 0x04	; 4
     224:	b3 e0       	ldi	r27, 0x03	; 3
     226:	01 c0       	rjmp	.+2      	; 0x22a <.do_clear_bss_start>

00000228 <.do_clear_bss_loop>:
     228:	1d 92       	st	X+, r1

0000022a <.do_clear_bss_start>:
     22a:	ae 3b       	cpi	r26, 0xBE	; 190
     22c:	b2 07       	cpc	r27, r18
     22e:	e1 f7       	brne	.-8      	; 0x228 <.do_clear_bss_loop>
     230:	0e 94 b2 0c 	call	0x1964	; 0x1964 <main>
     234:	0c 94 71 2d 	jmp	0x5ae2	; 0x5ae2 <_exit>

00000238 <__bad_interrupt>:
     238:	e3 ce       	rjmp	.-570    	; 0x0 <__vectors>

0000023a <arq_init>:
  return len;
}

uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}
     23a:	cf 93       	push	r28
     23c:	df 93       	push	r29
     23e:	65 e1       	ldi	r22, 0x15	; 21
     240:	74 e0       	ldi	r23, 0x04	; 4
     242:	81 e0       	ldi	r24, 0x01	; 1
     244:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <network_set_callback>
     248:	10 92 05 03 	sts	0x0305, r1	; 0x800305 <__data_end+0x1>
     24c:	10 92 04 03 	sts	0x0304, r1	; 0x800304 <__data_end>
     250:	c6 e0       	ldi	r28, 0x06	; 6
     252:	d3 e0       	ldi	r29, 0x03	; 3
     254:	8d e8       	ldi	r24, 0x8D	; 141
     256:	fe 01       	movw	r30, r28
     258:	11 92       	st	Z+, r1
     25a:	8a 95       	dec	r24
     25c:	e9 f7       	brne	.-6      	; 0x258 <arq_init+0x1e>
     25e:	81 e0       	ldi	r24, 0x01	; 1
     260:	0e 94 ad 10 	call	0x215a	; 0x215a <xQueueCreateMutex>
     264:	90 93 90 03 	sts	0x0390, r25	; 0x800390 <connections+0x8a>
     268:	80 93 8f 03 	sts	0x038F, r24	; 0x80038f <connections+0x89>
     26c:	18 82       	st	Y, r1
     26e:	df 91       	pop	r29
     270:	cf 91       	pop	r28
     272:	08 95       	ret

00000274 <arq_new_connection>:
     274:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <connections>
     278:	81 11       	cpse	r24, r1
     27a:	16 c0       	rjmp	.+44     	; 0x2a8 <arq_new_connection+0x34>
     27c:	e6 e0       	ldi	r30, 0x06	; 6
     27e:	f3 e0       	ldi	r31, 0x03	; 3
     280:	16 8e       	std	Z+30, r1	; 0x1e
     282:	15 8e       	std	Z+29, r1	; 0x1d
     284:	16 8a       	std	Z+22, r1	; 0x16
     286:	15 8a       	std	Z+21, r1	; 0x15
     288:	14 a2       	std	Z+36, r1	; 0x24
     28a:	13 a2       	std	Z+35, r1	; 0x23
     28c:	12 a2       	std	Z+34, r1	; 0x22
     28e:	11 a2       	std	Z+33, r1	; 0x21
     290:	17 8e       	std	Z+31, r1	; 0x1f
     292:	14 8e       	std	Z+28, r1	; 0x1c
     294:	12 8e       	std	Z+26, r1	; 0x1a
     296:	11 8e       	std	Z+25, r1	; 0x19
     298:	13 8e       	std	Z+27, r1	; 0x1b
     29a:	10 92 92 03 	sts	0x0392, r1	; 0x800392 <connections+0x8c>
     29e:	10 92 91 03 	sts	0x0391, r1	; 0x800391 <connections+0x8b>
     2a2:	91 e0       	ldi	r25, 0x01	; 1
     2a4:	90 83       	st	Z, r25
     2a6:	08 95       	ret
     2a8:	8f ef       	ldi	r24, 0xFF	; 255
     2aa:	08 95       	ret

000002ac <arq_connect>:
     2ac:	cf 92       	push	r12
     2ae:	df 92       	push	r13
     2b0:	ef 92       	push	r14
     2b2:	ff 92       	push	r15
     2b4:	0f 93       	push	r16
     2b6:	1f 93       	push	r17
     2b8:	cf 93       	push	r28
     2ba:	df 93       	push	r29
     2bc:	1f 92       	push	r1
     2be:	cd b7       	in	r28, 0x3d	; 61
     2c0:	de b7       	in	r29, 0x3e	; 62
     2c2:	69 01       	movw	r12, r18
     2c4:	e8 2e       	mov	r14, r24
     2c6:	f1 2c       	mov	r15, r1
     2c8:	9d e8       	ldi	r25, 0x8D	; 141
     2ca:	89 9f       	mul	r24, r25
     2cc:	80 01       	movw	r16, r0
     2ce:	11 24       	eor	r1, r1
     2d0:	0a 5f       	subi	r16, 0xFA	; 250
     2d2:	1c 4f       	sbci	r17, 0xFC	; 252
     2d4:	83 e0       	ldi	r24, 0x03	; 3
     2d6:	f8 01       	movw	r30, r16
     2d8:	80 83       	st	Z, r24
     2da:	50 8f       	std	Z+24, r21	; 0x18
     2dc:	47 8b       	std	Z+23, r20	; 0x17
     2de:	60 a3       	std	Z+32, r22	; 0x20
     2e0:	82 e0       	ldi	r24, 0x02	; 2
     2e2:	89 83       	std	Y+1, r24	; 0x01
     2e4:	0e 94 ff 21 	call	0x43fe	; 0x43fe <xTaskGetCurrentTaskHandle>
     2e8:	f8 01       	movw	r30, r16
     2ea:	e5 57       	subi	r30, 0x75	; 117
     2ec:	ff 4f       	sbci	r31, 0xFF	; 255
     2ee:	91 83       	std	Z+1, r25	; 0x01
     2f0:	80 83       	st	Z, r24
     2f2:	0e 94 3a 25 	call	0x4a74	; 0x4a74 <xTaskNotifyStateClear>
     2f6:	21 e0       	ldi	r18, 0x01	; 1
     2f8:	30 e0       	ldi	r19, 0x00	; 0
     2fa:	ae 01       	movw	r20, r28
     2fc:	4f 5f       	subi	r20, 0xFF	; 255
     2fe:	5f 4f       	sbci	r21, 0xFF	; 255
     300:	61 e0       	ldi	r22, 0x01	; 1
     302:	f8 01       	movw	r30, r16
     304:	80 a1       	ldd	r24, Z+32	; 0x20
     306:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <network_send>
     30a:	b6 01       	movw	r22, r12
     30c:	81 e0       	ldi	r24, 0x01	; 1
     30e:	0e 94 b8 22 	call	0x4570	; 0x4570 <ulTaskNotifyTake>
     312:	67 2b       	or	r22, r23
     314:	68 2b       	or	r22, r24
     316:	69 2b       	or	r22, r25
     318:	61 f4       	brne	.+24     	; 0x332 <arq_connect+0x86>
     31a:	8d e8       	ldi	r24, 0x8D	; 141
     31c:	8e 9d       	mul	r24, r14
     31e:	f0 01       	movw	r30, r0
     320:	8f 9d       	mul	r24, r15
     322:	f0 0d       	add	r31, r0
     324:	11 24       	eor	r1, r1
     326:	ea 5f       	subi	r30, 0xFA	; 250
     328:	fc 4f       	sbci	r31, 0xFC	; 252
     32a:	81 e0       	ldi	r24, 0x01	; 1
     32c:	80 83       	st	Z, r24
     32e:	80 e0       	ldi	r24, 0x00	; 0
     330:	2e c0       	rjmp	.+92     	; 0x38e <arq_connect+0xe2>
     332:	80 e0       	ldi	r24, 0x00	; 0
     334:	91 e0       	ldi	r25, 0x01	; 1
     336:	42 d6       	rcall	.+3204   	; 0xfbc <pvPortMalloc>
     338:	00 97       	sbiw	r24, 0x00	; 0
     33a:	31 f1       	breq	.+76     	; 0x388 <arq_connect+0xdc>
     33c:	4d e8       	ldi	r20, 0x8D	; 141
     33e:	4e 9d       	mul	r20, r14
     340:	90 01       	movw	r18, r0
     342:	4f 9d       	mul	r20, r15
     344:	30 0d       	add	r19, r0
     346:	11 24       	eor	r1, r1
     348:	40 e0       	ldi	r20, 0x00	; 0
     34a:	51 e0       	ldi	r21, 0x01	; 1
     34c:	bc 01       	movw	r22, r24
     34e:	c9 01       	movw	r24, r18
     350:	89 5f       	subi	r24, 0xF9	; 249
     352:	9c 4f       	sbci	r25, 0xFC	; 252
     354:	5b d3       	rcall	.+1718   	; 0xa0c <buffer_init>
     356:	84 e1       	ldi	r24, 0x14	; 20
     358:	90 e0       	ldi	r25, 0x00	; 0
     35a:	30 d6       	rcall	.+3168   	; 0xfbc <pvPortMalloc>
     35c:	00 97       	sbiw	r24, 0x00	; 0
     35e:	b1 f0       	breq	.+44     	; 0x38c <arq_connect+0xe0>
     360:	2d e8       	ldi	r18, 0x8D	; 141
     362:	2e 9d       	mul	r18, r14
     364:	80 01       	movw	r16, r0
     366:	2f 9d       	mul	r18, r15
     368:	10 0d       	add	r17, r0
     36a:	11 24       	eor	r1, r1
     36c:	44 e1       	ldi	r20, 0x14	; 20
     36e:	50 e0       	ldi	r21, 0x00	; 0
     370:	bc 01       	movw	r22, r24
     372:	c8 01       	movw	r24, r16
     374:	8f 5e       	subi	r24, 0xEF	; 239
     376:	9c 4f       	sbci	r25, 0xFC	; 252
     378:	49 d3       	rcall	.+1682   	; 0xa0c <buffer_init>
     37a:	f8 01       	movw	r30, r16
     37c:	ea 5f       	subi	r30, 0xFA	; 250
     37e:	fc 4f       	sbci	r31, 0xFC	; 252
     380:	82 e0       	ldi	r24, 0x02	; 2
     382:	80 83       	st	Z, r24
     384:	81 e0       	ldi	r24, 0x01	; 1
     386:	03 c0       	rjmp	.+6      	; 0x38e <arq_connect+0xe2>
     388:	8f ef       	ldi	r24, 0xFF	; 255
     38a:	01 c0       	rjmp	.+2      	; 0x38e <arq_connect+0xe2>
     38c:	8f ef       	ldi	r24, 0xFF	; 255
     38e:	0f 90       	pop	r0
     390:	df 91       	pop	r29
     392:	cf 91       	pop	r28
     394:	1f 91       	pop	r17
     396:	0f 91       	pop	r16
     398:	ff 90       	pop	r15
     39a:	ef 90       	pop	r14
     39c:	df 90       	pop	r13
     39e:	cf 90       	pop	r12
     3a0:	08 95       	ret

000003a2 <arq_close_connection>:
     3a2:	cf 93       	push	r28
     3a4:	df 93       	push	r29
     3a6:	81 11       	cpse	r24, r1
     3a8:	34 c0       	rjmp	.+104    	; 0x412 <__FUSE_REGION_LENGTH__+0x12>
     3aa:	20 e0       	ldi	r18, 0x00	; 0
     3ac:	4f ef       	ldi	r20, 0xFF	; 255
     3ae:	5f ef       	ldi	r21, 0xFF	; 255
     3b0:	60 e0       	ldi	r22, 0x00	; 0
     3b2:	70 e0       	ldi	r23, 0x00	; 0
     3b4:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     3b8:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     3bc:	0e 94 99 15 	call	0x2b32	; 0x2b32 <xQueueGenericReceive>
     3c0:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <connections>
     3c4:	82 30       	cpi	r24, 0x02	; 2
     3c6:	51 f0       	breq	.+20     	; 0x3dc <arq_close_connection+0x3a>
     3c8:	60 e0       	ldi	r22, 0x00	; 0
     3ca:	70 e0       	ldi	r23, 0x00	; 0
     3cc:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     3d0:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     3d4:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
     3d8:	80 e0       	ldi	r24, 0x00	; 0
     3da:	1c c0       	rjmp	.+56     	; 0x414 <__FUSE_REGION_LENGTH__+0x14>
     3dc:	c6 e0       	ldi	r28, 0x06	; 6
     3de:	d3 e0       	ldi	r29, 0x03	; 3
     3e0:	89 81       	ldd	r24, Y+1	; 0x01
     3e2:	9a 81       	ldd	r25, Y+2	; 0x02
     3e4:	f5 d6       	rcall	.+3562   	; 0x11d0 <vPortFree>
     3e6:	8b 85       	ldd	r24, Y+11	; 0x0b
     3e8:	9c 85       	ldd	r25, Y+12	; 0x0c
     3ea:	f2 d6       	rcall	.+3556   	; 0x11d0 <vPortFree>
     3ec:	81 e0       	ldi	r24, 0x01	; 1
     3ee:	88 83       	st	Y, r24
     3f0:	ef 89       	ldd	r30, Y+23	; 0x17
     3f2:	f8 8d       	ldd	r31, Y+24	; 0x18
     3f4:	60 e0       	ldi	r22, 0x00	; 0
     3f6:	70 e0       	ldi	r23, 0x00	; 0
     3f8:	80 e0       	ldi	r24, 0x00	; 0
     3fa:	90 e0       	ldi	r25, 0x00	; 0
     3fc:	19 95       	eicall
     3fe:	60 e0       	ldi	r22, 0x00	; 0
     400:	70 e0       	ldi	r23, 0x00	; 0
     402:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     406:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     40a:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
     40e:	81 e0       	ldi	r24, 0x01	; 1
     410:	01 c0       	rjmp	.+2      	; 0x414 <__FUSE_REGION_LENGTH__+0x14>
     412:	80 e0       	ldi	r24, 0x00	; 0
     414:	df 91       	pop	r29
     416:	cf 91       	pop	r28
     418:	08 95       	ret

0000041a <arq_send>:
     41a:	ef 92       	push	r14
     41c:	ff 92       	push	r15
     41e:	0f 93       	push	r16
     420:	1f 93       	push	r17
     422:	cf 93       	push	r28
     424:	df 93       	push	r29
     426:	00 d0       	rcall	.+0      	; 0x428 <arq_send+0xe>
     428:	1f 92       	push	r1
     42a:	cd b7       	in	r28, 0x3d	; 61
     42c:	de b7       	in	r29, 0x3e	; 62
     42e:	5c 83       	std	Y+4, r21	; 0x04
     430:	4b 83       	std	Y+3, r20	; 0x03
     432:	81 11       	cpse	r24, r1
     434:	7b c0       	rjmp	.+246    	; 0x52c <arq_send+0x112>
     436:	7b 01       	movw	r14, r22
     438:	20 e0       	ldi	r18, 0x00	; 0
     43a:	4f ef       	ldi	r20, 0xFF	; 255
     43c:	5f ef       	ldi	r21, 0xFF	; 255
     43e:	60 e0       	ldi	r22, 0x00	; 0
     440:	70 e0       	ldi	r23, 0x00	; 0
     442:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     446:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     44a:	0e 94 99 15 	call	0x2b32	; 0x2b32 <xQueueGenericReceive>
     44e:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <connections>
     452:	82 30       	cpi	r24, 0x02	; 2
     454:	51 f4       	brne	.+20     	; 0x46a <arq_send+0x50>
     456:	e1 14       	cp	r14, r1
     458:	f1 04       	cpc	r15, r1
     45a:	39 f0       	breq	.+14     	; 0x46a <arq_send+0x50>
     45c:	0b 81       	ldd	r16, Y+3	; 0x03
     45e:	1c 81       	ldd	r17, Y+4	; 0x04
     460:	c8 01       	movw	r24, r16
     462:	01 97       	sbiw	r24, 0x01	; 1
     464:	84 36       	cpi	r24, 0x64	; 100
     466:	91 05       	cpc	r25, r1
     468:	50 f0       	brcs	.+20     	; 0x47e <arq_send+0x64>
     46a:	60 e0       	ldi	r22, 0x00	; 0
     46c:	70 e0       	ldi	r23, 0x00	; 0
     46e:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     472:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     476:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
     47a:	80 e0       	ldi	r24, 0x00	; 0
     47c:	58 c0       	rjmp	.+176    	; 0x52e <arq_send+0x114>
     47e:	0e 5f       	subi	r16, 0xFE	; 254
     480:	1f 4f       	sbci	r17, 0xFF	; 255
     482:	20 91 0f 03 	lds	r18, 0x030F	; 0x80030f <connections+0x9>
     486:	30 91 10 03 	lds	r19, 0x0310	; 0x800310 <connections+0xa>
     48a:	80 e0       	ldi	r24, 0x00	; 0
     48c:	91 e0       	ldi	r25, 0x01	; 1
     48e:	82 1b       	sub	r24, r18
     490:	93 0b       	sbc	r25, r19
     492:	08 17       	cp	r16, r24
     494:	19 07       	cpc	r17, r25
     496:	08 f0       	brcs	.+2      	; 0x49a <arq_send+0x80>
     498:	3f c0       	rjmp	.+126    	; 0x518 <arq_send+0xfe>
     49a:	20 91 19 03 	lds	r18, 0x0319	; 0x800319 <connections+0x13>
     49e:	30 91 1a 03 	lds	r19, 0x031A	; 0x80031a <connections+0x14>
     4a2:	84 e1       	ldi	r24, 0x14	; 20
     4a4:	90 e0       	ldi	r25, 0x00	; 0
     4a6:	82 1b       	sub	r24, r18
     4a8:	93 0b       	sbc	r25, r19
     4aa:	02 97       	sbiw	r24, 0x02	; 2
     4ac:	a8 f1       	brcs	.+106    	; 0x518 <arq_send+0xfe>
     4ae:	8a e2       	ldi	r24, 0x2A	; 42
     4b0:	90 e0       	ldi	r25, 0x00	; 0
     4b2:	9a 83       	std	Y+2, r25	; 0x02
     4b4:	89 83       	std	Y+1, r24	; 0x01
     4b6:	42 e0       	ldi	r20, 0x02	; 2
     4b8:	50 e0       	ldi	r21, 0x00	; 0
     4ba:	be 01       	movw	r22, r28
     4bc:	6d 5f       	subi	r22, 0xFD	; 253
     4be:	7f 4f       	sbci	r23, 0xFF	; 255
     4c0:	87 e0       	ldi	r24, 0x07	; 7
     4c2:	93 e0       	ldi	r25, 0x03	; 3
     4c4:	b5 d2       	rcall	.+1386   	; 0xa30 <buffer_append>
     4c6:	4b 81       	ldd	r20, Y+3	; 0x03
     4c8:	5c 81       	ldd	r21, Y+4	; 0x04
     4ca:	b7 01       	movw	r22, r14
     4cc:	87 e0       	ldi	r24, 0x07	; 7
     4ce:	93 e0       	ldi	r25, 0x03	; 3
     4d0:	af d2       	rcall	.+1374   	; 0xa30 <buffer_append>
     4d2:	01 15       	cp	r16, r1
     4d4:	11 05       	cpc	r17, r1
     4d6:	b1 f0       	breq	.+44     	; 0x504 <arq_send+0xea>
     4d8:	90 2f       	mov	r25, r16
     4da:	81 2f       	mov	r24, r17
     4dc:	0b 32       	cpi	r16, 0x2B	; 43
     4de:	11 05       	cpc	r17, r1
     4e0:	10 f0       	brcs	.+4      	; 0x4e6 <arq_send+0xcc>
     4e2:	9a e2       	ldi	r25, 0x2A	; 42
     4e4:	80 e0       	ldi	r24, 0x00	; 0
     4e6:	99 83       	std	Y+1, r25	; 0x01
     4e8:	8a 83       	std	Y+2, r24	; 0x02
     4ea:	42 e0       	ldi	r20, 0x02	; 2
     4ec:	50 e0       	ldi	r21, 0x00	; 0
     4ee:	be 01       	movw	r22, r28
     4f0:	6f 5f       	subi	r22, 0xFF	; 255
     4f2:	7f 4f       	sbci	r23, 0xFF	; 255
     4f4:	81 e1       	ldi	r24, 0x11	; 17
     4f6:	93 e0       	ldi	r25, 0x03	; 3
     4f8:	9b d2       	rcall	.+1334   	; 0xa30 <buffer_append>
     4fa:	89 81       	ldd	r24, Y+1	; 0x01
     4fc:	9a 81       	ldd	r25, Y+2	; 0x02
     4fe:	08 1b       	sub	r16, r24
     500:	19 0b       	sbc	r17, r25
     502:	51 f7       	brne	.-44     	; 0x4d8 <arq_send+0xbe>
     504:	60 e0       	ldi	r22, 0x00	; 0
     506:	70 e0       	ldi	r23, 0x00	; 0
     508:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     50c:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     510:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
     514:	8b 81       	ldd	r24, Y+3	; 0x03
     516:	0b c0       	rjmp	.+22     	; 0x52e <arq_send+0x114>
     518:	60 e0       	ldi	r22, 0x00	; 0
     51a:	70 e0       	ldi	r23, 0x00	; 0
     51c:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     520:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     524:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
     528:	80 e0       	ldi	r24, 0x00	; 0
     52a:	01 c0       	rjmp	.+2      	; 0x52e <arq_send+0x114>
     52c:	80 e0       	ldi	r24, 0x00	; 0
     52e:	0f 90       	pop	r0
     530:	0f 90       	pop	r0
     532:	0f 90       	pop	r0
     534:	0f 90       	pop	r0
     536:	df 91       	pop	r29
     538:	cf 91       	pop	r28
     53a:	1f 91       	pop	r17
     53c:	0f 91       	pop	r16
     53e:	ff 90       	pop	r15
     540:	ef 90       	pop	r14
     542:	08 95       	ret

00000544 <arq_send_ack>:

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
     544:	cf 93       	push	r28
     546:	df 93       	push	r29
     548:	1f 92       	push	r1
     54a:	1f 92       	push	r1
     54c:	cd b7       	in	r28, 0x3d	; 61
     54e:	de b7       	in	r29, 0x3e	; 62
  if(id >= MAX_CONNECTIONS) return 0;
     550:	81 11       	cpse	r24, r1
     552:	14 c0       	rjmp	.+40     	; 0x57c <arq_send_ack+0x38>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
     554:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <connections>
     558:	82 30       	cpi	r24, 0x02	; 2
     55a:	91 f4       	brne	.+36     	; 0x580 <arq_send_ack+0x3c>
     55c:	66 23       	and	r22, r22
     55e:	94 f0       	brlt	.+36     	; 0x584 <arq_send_ack+0x40>
    return 0;
  }
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
     560:	81 e0       	ldi	r24, 0x01	; 1
     562:	89 83       	std	Y+1, r24	; 0x01
  data[1] = sequence_number;
     564:	6a 83       	std	Y+2, r22	; 0x02
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
     566:	22 e0       	ldi	r18, 0x02	; 2
     568:	30 e0       	ldi	r19, 0x00	; 0
     56a:	ae 01       	movw	r20, r28
     56c:	4f 5f       	subi	r20, 0xFF	; 255
     56e:	5f 4f       	sbci	r21, 0xFF	; 255
     570:	61 e0       	ldi	r22, 0x01	; 1
     572:	80 91 26 03 	lds	r24, 0x0326	; 0x800326 <connections+0x20>
     576:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <network_send>
     57a:	05 c0       	rjmp	.+10     	; 0x586 <arq_send_ack+0x42>
uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
  if(id >= MAX_CONNECTIONS) return 0;
     57c:	80 e0       	ldi	r24, 0x00	; 0
     57e:	03 c0       	rjmp	.+6      	; 0x586 <arq_send_ack+0x42>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
    return 0;
     580:	80 e0       	ldi	r24, 0x00	; 0
     582:	01 c0       	rjmp	.+2      	; 0x586 <arq_send_ack+0x42>
     584:	80 e0       	ldi	r24, 0x00	; 0
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}
     586:	0f 90       	pop	r0
     588:	0f 90       	pop	r0
     58a:	df 91       	pop	r29
     58c:	cf 91       	pop	r28
     58e:	08 95       	ret

00000590 <sender>:
/  When the transmit window has available space, it removes segments from the send buffer 
/  and sends them. It also increments a retransmit timer and timeout timer. When the retransmit timer
/  expires the function resends all the segments in the transmit window. On timeout the connection is
/  closed. 
*/
void sender(arq_connection id) { 
     590:	af 92       	push	r10
     592:	bf 92       	push	r11
     594:	cf 92       	push	r12
     596:	df 92       	push	r13
     598:	ef 92       	push	r14
     59a:	ff 92       	push	r15
     59c:	0f 93       	push	r16
     59e:	1f 93       	push	r17
     5a0:	cf 93       	push	r28
     5a2:	df 93       	push	r29
     5a4:	cd b7       	in	r28, 0x3d	; 61
     5a6:	de b7       	in	r29, 0x3e	; 62
     5a8:	ae 97       	sbiw	r28, 0x2e	; 46
     5aa:	0f b6       	in	r0, 0x3f	; 63
     5ac:	f8 94       	cli
     5ae:	de bf       	out	0x3e, r29	; 62
     5b0:	0f be       	out	0x3f, r0	; 63
     5b2:	cd bf       	out	0x3d, r28	; 61
  if(id >= MAX_CONNECTIONS) return;
     5b4:	81 11       	cpse	r24, r1
     5b6:	db c0       	rjmp	.+438    	; 0x76e <sender+0x1de>
  arq_connection_t *con = &connections[id];
  if(con->status == STATUS_NONE) return;
     5b8:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <connections>
     5bc:	88 23       	and	r24, r24
     5be:	09 f4       	brne	.+2      	; 0x5c2 <sender+0x32>
     5c0:	d6 c0       	rjmp	.+428    	; 0x76e <sender+0x1de>
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     5c2:	20 e0       	ldi	r18, 0x00	; 0
     5c4:	4f ef       	ldi	r20, 0xFF	; 255
     5c6:	5f ef       	ldi	r21, 0xFF	; 255
     5c8:	60 e0       	ldi	r22, 0x00	; 0
     5ca:	70 e0       	ldi	r23, 0x00	; 0
     5cc:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     5d0:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     5d4:	0e 94 99 15 	call	0x2b32	; 0x2b32 <xQueueGenericReceive>
  
  if(con->status != STATUS_CONNECTED) {
     5d8:	80 91 06 03 	lds	r24, 0x0306	; 0x800306 <connections>
     5dc:	82 30       	cpi	r24, 0x02	; 2
     5de:	49 f0       	breq	.+18     	; 0x5f2 <sender+0x62>
    xSemaphoreGive(con->mutex);
     5e0:	60 e0       	ldi	r22, 0x00	; 0
     5e2:	70 e0       	ldi	r23, 0x00	; 0
     5e4:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     5e8:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     5ec:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
    return;
     5f0:	be c0       	rjmp	.+380    	; 0x76e <sender+0x1de>
  }

  if(con->timer_started) {
     5f2:	80 91 25 03 	lds	r24, 0x0325	; 0x800325 <connections+0x1f>
     5f6:	88 23       	and	r24, r24
     5f8:	09 f4       	brne	.+2      	; 0x5fc <sender+0x6c>
     5fa:	62 c0       	rjmp	.+196    	; 0x6c0 <sender+0x130>
    con->timeout += 10;
     5fc:	e6 e0       	ldi	r30, 0x06	; 6
     5fe:	f3 e0       	ldi	r31, 0x03	; 3
     600:	85 8d       	ldd	r24, Z+29	; 0x1d
     602:	96 8d       	ldd	r25, Z+30	; 0x1e
     604:	0a 96       	adiw	r24, 0x0a	; 10
     606:	96 8f       	std	Z+30, r25	; 0x1e
     608:	85 8f       	std	Z+29, r24	; 0x1d
    con->timer += 10;
     60a:	24 8d       	ldd	r18, Z+28	; 0x1c
     60c:	26 5f       	subi	r18, 0xF6	; 246
     60e:	24 8f       	std	Z+28, r18	; 0x1c
    if(con->timeout > LOST_CONNECTION_TIMEOUT_MS) { 
     610:	89 3e       	cpi	r24, 0xE9	; 233
     612:	93 40       	sbci	r25, 0x03	; 3
     614:	58 f0       	brcs	.+22     	; 0x62c <sender+0x9c>
      xSemaphoreGive(con->mutex);
     616:	60 e0       	ldi	r22, 0x00	; 0
     618:	70 e0       	ldi	r23, 0x00	; 0
     61a:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     61e:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     622:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
      arq_close_connection(id);
     626:	80 e0       	ldi	r24, 0x00	; 0
     628:	bc de       	rcall	.-648    	; 0x3a2 <arq_close_connection>
      return;
     62a:	a1 c0       	rjmp	.+322    	; 0x76e <sender+0x1de>
    }
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
     62c:	29 3c       	cpi	r18, 0xC9	; 201
     62e:	08 f4       	brcc	.+2      	; 0x632 <sender+0xa2>
     630:	47 c0       	rjmp	.+142    	; 0x6c0 <sender+0x130>
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
     632:	e6 e0       	ldi	r30, 0x06	; 6
     634:	f3 e0       	ldi	r31, 0x03	; 3
     636:	07 81       	ldd	r16, Z+7	; 0x07
     638:	10 85       	ldd	r17, Z+8	; 0x08
      uint16_t len = 0;
     63a:	1e a6       	std	Y+46, r1	; 0x2e
     63c:	1d a6       	std	Y+45, r1	; 0x2d
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
     63e:	a1 8c       	ldd	r10, Z+25	; 0x19
     640:	83 8d       	ldd	r24, Z+27	; 0x1b
     642:	a8 1a       	sub	r10, r24
     644:	8a 2d       	mov	r24, r10
     646:	8f 77       	andi	r24, 0x7F	; 127
     648:	a8 2e       	mov	r10, r24
      while(i < resend_count) {
     64a:	c1 f1       	breq	.+112    	; 0x6bc <sender+0x12c>
     64c:	c1 2c       	mov	r12, r1
     64e:	d1 2c       	mov	r13, r1
     650:	b1 2c       	mov	r11, r1
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
        data[1] = (con->sequence_base+i) & 127; 
     652:	7f 01       	movw	r14, r30
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
     654:	19 82       	std	Y+1, r1	; 0x01
        data[1] = (con->sequence_base+i) & 127; 
     656:	f7 01       	movw	r30, r14
     658:	83 8d       	ldd	r24, Z+27	; 0x1b
     65a:	8b 0d       	add	r24, r11
     65c:	8f 77       	andi	r24, 0x7F	; 127
     65e:	8a 83       	std	Y+2, r24	; 0x02
        buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*i, 2);
     660:	41 89       	ldd	r20, Z+17	; 0x11
     662:	52 89       	ldd	r21, Z+18	; 0x12
     664:	4c 0d       	add	r20, r12
     666:	5d 1d       	adc	r21, r13
     668:	22 e0       	ldi	r18, 0x02	; 2
     66a:	30 e0       	ldi	r19, 0x00	; 0
     66c:	be 01       	movw	r22, r28
     66e:	63 5d       	subi	r22, 0xD3	; 211
     670:	7f 4f       	sbci	r23, 0xFF	; 255
     672:	81 e1       	ldi	r24, 0x11	; 17
     674:	93 e0       	ldi	r25, 0x03	; 3
     676:	8b d2       	rcall	.+1302   	; 0xb8e <buffer_read>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
     678:	2d a5       	ldd	r18, Y+45	; 0x2d
     67a:	3e a5       	ldd	r19, Y+46	; 0x2e
     67c:	a8 01       	movw	r20, r16
     67e:	be 01       	movw	r22, r28
     680:	6d 5f       	subi	r22, 0xFD	; 253
     682:	7f 4f       	sbci	r23, 0xFF	; 255
     684:	87 e0       	ldi	r24, 0x07	; 7
     686:	93 e0       	ldi	r25, 0x03	; 3
     688:	82 d2       	rcall	.+1284   	; 0xb8e <buffer_read>
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
     68a:	2d a5       	ldd	r18, Y+45	; 0x2d
     68c:	3e a5       	ldd	r19, Y+46	; 0x2e
     68e:	02 0f       	add	r16, r18
     690:	13 1f       	adc	r17, r19
     692:	f7 01       	movw	r30, r14
     694:	83 81       	ldd	r24, Z+3	; 0x03
     696:	94 81       	ldd	r25, Z+4	; 0x04
     698:	01 97       	sbiw	r24, 0x01	; 1
     69a:	08 23       	and	r16, r24
     69c:	19 23       	and	r17, r25
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     69e:	2e 5f       	subi	r18, 0xFE	; 254
     6a0:	3f 4f       	sbci	r19, 0xFF	; 255
     6a2:	ae 01       	movw	r20, r28
     6a4:	4f 5f       	subi	r20, 0xFF	; 255
     6a6:	5f 4f       	sbci	r21, 0xFF	; 255
     6a8:	61 e0       	ldi	r22, 0x01	; 1
     6aa:	80 a1       	ldd	r24, Z+32	; 0x20
     6ac:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <network_send>
        ++i;
     6b0:	b3 94       	inc	r11
     6b2:	f2 e0       	ldi	r31, 0x02	; 2
     6b4:	cf 0e       	add	r12, r31
     6b6:	d1 1c       	adc	r13, r1
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
     6b8:	ab 10       	cpse	r10, r11
     6ba:	cc cf       	rjmp	.-104    	; 0x654 <sender+0xc4>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
        ++i;
      }
      con->timer = 0;
     6bc:	10 92 22 03 	sts	0x0322, r1	; 0x800322 <connections+0x1c>
    }
  }
  if( ((con->sequence_number-con->sequence_base) & 127) < WINDOW_SIZE && con->send_buffer.head != con->send_buffer_window_end) {
     6c0:	e6 e0       	ldi	r30, 0x06	; 6
     6c2:	f3 e0       	ldi	r31, 0x03	; 3
     6c4:	81 8d       	ldd	r24, Z+25	; 0x19
     6c6:	48 2f       	mov	r20, r24
     6c8:	50 e0       	ldi	r21, 0x00	; 0
     6ca:	93 8d       	ldd	r25, Z+27	; 0x1b
     6cc:	49 1b       	sub	r20, r25
     6ce:	51 09       	sbc	r21, r1
     6d0:	4f 77       	andi	r20, 0x7F	; 127
     6d2:	55 27       	eor	r21, r21
     6d4:	44 30       	cpi	r20, 0x04	; 4
     6d6:	51 05       	cpc	r21, r1
     6d8:	0c f0       	brlt	.+2      	; 0x6dc <sender+0x14c>
     6da:	41 c0       	rjmp	.+130    	; 0x75e <sender+0x1ce>
     6dc:	65 81       	ldd	r22, Z+5	; 0x05
     6de:	76 81       	ldd	r23, Z+6	; 0x06
     6e0:	25 89       	ldd	r18, Z+21	; 0x15
     6e2:	36 89       	ldd	r19, Z+22	; 0x16
     6e4:	62 17       	cp	r22, r18
     6e6:	73 07       	cpc	r23, r19
     6e8:	d1 f1       	breq	.+116    	; 0x75e <sender+0x1ce>
    uint8_t data[MAX_PAYLOAD_SIZE];
    uint16_t len;
    data[0] = TYPE_DATA;
     6ea:	19 82       	std	Y+1, r1	; 0x01
    data[1] = con->sequence_number;
     6ec:	8a 83       	std	Y+2, r24	; 0x02
    buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*((con->sequence_number-con->sequence_base) & 127), 2);
     6ee:	8f 01       	movw	r16, r30
     6f0:	44 0f       	add	r20, r20
     6f2:	55 1f       	adc	r21, r21
     6f4:	81 89       	ldd	r24, Z+17	; 0x11
     6f6:	92 89       	ldd	r25, Z+18	; 0x12
     6f8:	48 0f       	add	r20, r24
     6fa:	59 1f       	adc	r21, r25
     6fc:	22 e0       	ldi	r18, 0x02	; 2
     6fe:	30 e0       	ldi	r19, 0x00	; 0
     700:	be 01       	movw	r22, r28
     702:	63 5d       	subi	r22, 0xD3	; 211
     704:	7f 4f       	sbci	r23, 0xFF	; 255
     706:	81 e1       	ldi	r24, 0x11	; 17
     708:	93 e0       	ldi	r25, 0x03	; 3
     70a:	41 d2       	rcall	.+1154   	; 0xb8e <buffer_read>
    buffer_read(&con->send_buffer, &data[2], con->send_buffer_window_end, len);
     70c:	2d a5       	ldd	r18, Y+45	; 0x2d
     70e:	3e a5       	ldd	r19, Y+46	; 0x2e
     710:	f8 01       	movw	r30, r16
     712:	45 89       	ldd	r20, Z+21	; 0x15
     714:	56 89       	ldd	r21, Z+22	; 0x16
     716:	be 01       	movw	r22, r28
     718:	6d 5f       	subi	r22, 0xFD	; 253
     71a:	7f 4f       	sbci	r23, 0xFF	; 255
     71c:	87 e0       	ldi	r24, 0x07	; 7
     71e:	93 e0       	ldi	r25, 0x03	; 3
     720:	36 d2       	rcall	.+1132   	; 0xb8e <buffer_read>
    con->send_buffer_window_end = (con->send_buffer_window_end+len) & (con->send_buffer.capacity-1);
     722:	2d a5       	ldd	r18, Y+45	; 0x2d
     724:	3e a5       	ldd	r19, Y+46	; 0x2e
     726:	f8 01       	movw	r30, r16
     728:	85 89       	ldd	r24, Z+21	; 0x15
     72a:	96 89       	ldd	r25, Z+22	; 0x16
     72c:	a9 01       	movw	r20, r18
     72e:	48 0f       	add	r20, r24
     730:	59 1f       	adc	r21, r25
     732:	83 81       	ldd	r24, Z+3	; 0x03
     734:	94 81       	ldd	r25, Z+4	; 0x04
     736:	01 97       	sbiw	r24, 0x01	; 1
     738:	84 23       	and	r24, r20
     73a:	95 23       	and	r25, r21
     73c:	96 8b       	std	Z+22, r25	; 0x16
     73e:	85 8b       	std	Z+21, r24	; 0x15
    con->timer_started = 1;
     740:	81 e0       	ldi	r24, 0x01	; 1
     742:	87 8f       	std	Z+31, r24	; 0x1f
    con->sequence_number = (con->sequence_number+1) & 127;
     744:	81 8d       	ldd	r24, Z+25	; 0x19
     746:	8f 5f       	subi	r24, 0xFF	; 255
     748:	8f 77       	andi	r24, 0x7F	; 127
     74a:	81 8f       	std	Z+25, r24	; 0x19
    network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     74c:	2e 5f       	subi	r18, 0xFE	; 254
     74e:	3f 4f       	sbci	r19, 0xFF	; 255
     750:	ae 01       	movw	r20, r28
     752:	4f 5f       	subi	r20, 0xFF	; 255
     754:	5f 4f       	sbci	r21, 0xFF	; 255
     756:	61 e0       	ldi	r22, 0x01	; 1
     758:	80 a1       	ldd	r24, Z+32	; 0x20
     75a:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <network_send>
  } 
  
  xSemaphoreGive(con->mutex);
     75e:	60 e0       	ldi	r22, 0x00	; 0
     760:	70 e0       	ldi	r23, 0x00	; 0
     762:	80 91 8f 03 	lds	r24, 0x038F	; 0x80038f <connections+0x89>
     766:	90 91 90 03 	lds	r25, 0x0390	; 0x800390 <connections+0x8a>
     76a:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
}
     76e:	ae 96       	adiw	r28, 0x2e	; 46
     770:	0f b6       	in	r0, 0x3f	; 63
     772:	f8 94       	cli
     774:	de bf       	out	0x3e, r29	; 62
     776:	0f be       	out	0x3f, r0	; 63
     778:	cd bf       	out	0x3d, r28	; 61
     77a:	df 91       	pop	r29
     77c:	cf 91       	pop	r28
     77e:	1f 91       	pop	r17
     780:	0f 91       	pop	r16
     782:	ff 90       	pop	r15
     784:	ef 90       	pop	r14
     786:	df 90       	pop	r13
     788:	cf 90       	pop	r12
     78a:	bf 90       	pop	r11
     78c:	af 90       	pop	r10
     78e:	08 95       	ret

00000790 <arq_reassembly>:

void arq_reassembly(arq_connection id, uint8_t *data, uint16_t len) { 
     790:	0f 93       	push	r16
     792:	1f 93       	push	r17
     794:	cf 93       	push	r28
     796:	df 93       	push	r29
     798:	ea 01       	movw	r28, r20
  if(id >= MAX_CONNECTIONS) return;
     79a:	81 11       	cpse	r24, r1
     79c:	41 c0       	rjmp	.+130    	; 0x820 <arq_reassembly+0x90>
  
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
     79e:	80 91 29 03 	lds	r24, 0x0329	; 0x800329 <connections+0x23>
     7a2:	90 91 2a 03 	lds	r25, 0x032A	; 0x80032a <connections+0x24>
     7a6:	89 2b       	or	r24, r25
     7a8:	99 f4       	brne	.+38     	; 0x7d0 <arq_reassembly+0x40>
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
     7aa:	db 01       	movw	r26, r22
     7ac:	11 96       	adiw	r26, 0x01	; 1
     7ae:	8c 91       	ld	r24, X
     7b0:	11 97       	sbiw	r26, 0x01	; 1
     7b2:	90 e0       	ldi	r25, 0x00	; 0
     7b4:	98 2f       	mov	r25, r24
     7b6:	88 27       	eor	r24, r24
     7b8:	2c 91       	ld	r18, X
     7ba:	82 2b       	or	r24, r18
     7bc:	90 93 2a 03 	sts	0x032A, r25	; 0x80032a <connections+0x24>
     7c0:	80 93 29 03 	sts	0x0329, r24	; 0x800329 <connections+0x23>
    len-=2; // Remove the header from the length, left with the length of the payload
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
     7c4:	85 36       	cpi	r24, 0x65	; 101
     7c6:	91 05       	cpc	r25, r1
     7c8:	58 f5       	brcc	.+86     	; 0x820 <arq_reassembly+0x90>
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
    len-=2; // Remove the header from the length, left with the length of the payload
     7ca:	22 97       	sbiw	r28, 0x02	; 2
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
     7cc:	6e 5f       	subi	r22, 0xFE	; 254
     7ce:	7f 4f       	sbci	r23, 0xFF	; 255
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
      return;
    }
  } 
  memcpy(con->message+con->num_received_bytes, data, len);
     7d0:	06 e0       	ldi	r16, 0x06	; 6
     7d2:	13 e0       	ldi	r17, 0x03	; 3
     7d4:	f8 01       	movw	r30, r16
     7d6:	81 a1       	ldd	r24, Z+33	; 0x21
     7d8:	92 a1       	ldd	r25, Z+34	; 0x22
     7da:	ae 01       	movw	r20, r28
     7dc:	85 5d       	subi	r24, 0xD5	; 213
     7de:	9c 4f       	sbci	r25, 0xFC	; 252
     7e0:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
  con->num_received_bytes += len;
     7e4:	d8 01       	movw	r26, r16
     7e6:	91 96       	adiw	r26, 0x21	; 33
     7e8:	6d 91       	ld	r22, X+
     7ea:	7c 91       	ld	r23, X
     7ec:	92 97       	sbiw	r26, 0x22	; 34
     7ee:	6c 0f       	add	r22, r28
     7f0:	7d 1f       	adc	r23, r29
     7f2:	92 96       	adiw	r26, 0x22	; 34
     7f4:	7c 93       	st	X, r23
     7f6:	6e 93       	st	-X, r22
     7f8:	91 97       	sbiw	r26, 0x21	; 33
  
  if(con->num_received_bytes == con->receive_message_length) {
     7fa:	93 96       	adiw	r26, 0x23	; 35
     7fc:	8d 91       	ld	r24, X+
     7fe:	9c 91       	ld	r25, X
     800:	94 97       	sbiw	r26, 0x24	; 36
     802:	68 17       	cp	r22, r24
     804:	79 07       	cpc	r23, r25
     806:	61 f4       	brne	.+24     	; 0x820 <arq_reassembly+0x90>
    con->callback_data_received(con->message, con->num_received_bytes);
     808:	57 96       	adiw	r26, 0x17	; 23
     80a:	ed 91       	ld	r30, X+
     80c:	fc 91       	ld	r31, X
     80e:	58 97       	sbiw	r26, 0x18	; 24
     810:	8b e2       	ldi	r24, 0x2B	; 43
     812:	93 e0       	ldi	r25, 0x03	; 3
     814:	19 95       	eicall
    con->num_received_bytes = con->receive_message_length = 0;
     816:	f8 01       	movw	r30, r16
     818:	14 a2       	std	Z+36, r1	; 0x24
     81a:	13 a2       	std	Z+35, r1	; 0x23
     81c:	12 a2       	std	Z+34, r1	; 0x22
     81e:	11 a2       	std	Z+33, r1	; 0x21
  }
}
     820:	df 91       	pop	r29
     822:	cf 91       	pop	r28
     824:	1f 91       	pop	r17
     826:	0f 91       	pop	r16
     828:	08 95       	ret

0000082a <receiver>:
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
     82a:	9f 92       	push	r9
     82c:	af 92       	push	r10
     82e:	bf 92       	push	r11
     830:	cf 92       	push	r12
     832:	df 92       	push	r13
     834:	ef 92       	push	r14
     836:	ff 92       	push	r15
     838:	0f 93       	push	r16
     83a:	1f 93       	push	r17
     83c:	cf 93       	push	r28
     83e:	df 93       	push	r29
     840:	1f 92       	push	r1
     842:	cd b7       	in	r28, 0x3d	; 61
     844:	de b7       	in	r29, 0x3e	; 62
     846:	8b 01       	movw	r16, r22
     848:	5a 01       	movw	r10, r20
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
     84a:	90 91 26 03 	lds	r25, 0x0326	; 0x800326 <connections+0x20>
     84e:	98 13       	cpse	r25, r24
     850:	b8 c0       	rjmp	.+368    	; 0x9c2 <receiver+0x198>
     852:	90 91 06 03 	lds	r25, 0x0306	; 0x800306 <connections>
     856:	99 23       	and	r25, r25
     858:	09 f4       	brne	.+2      	; 0x85c <receiver+0x32>
     85a:	b3 c0       	rjmp	.+358    	; 0x9c2 <receiver+0x198>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     85c:	fb 01       	movw	r30, r22
     85e:	d0 80       	ld	r13, Z
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
      con = &connections[i];
     860:	0f 2e       	mov	r0, r31
     862:	f6 e0       	ldi	r31, 0x06	; 6
     864:	ef 2e       	mov	r14, r31
     866:	f3 e0       	ldi	r31, 0x03	; 3
     868:	ff 2e       	mov	r15, r31
     86a:	f0 2d       	mov	r31, r0
     86c:	13 c0       	rjmp	.+38     	; 0x894 <receiver+0x6a>
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
  if(con == NULL && type == TYPE_SYN && listening_task != NULL) {
     86e:	e0 91 04 03 	lds	r30, 0x0304	; 0x800304 <__data_end>
     872:	f0 91 05 03 	lds	r31, 0x0305	; 0x800305 <__data_end+0x1>
     876:	30 97       	sbiw	r30, 0x00	; 0
     878:	59 f0       	breq	.+22     	; 0x890 <receiver+0x66>
    xTaskNotify(listening_task, address, eSetValueWithOverwrite);
     87a:	48 2f       	mov	r20, r24
     87c:	50 e0       	ldi	r21, 0x00	; 0
     87e:	60 e0       	ldi	r22, 0x00	; 0
     880:	70 e0       	ldi	r23, 0x00	; 0
     882:	00 e0       	ldi	r16, 0x00	; 0
     884:	10 e0       	ldi	r17, 0x00	; 0
     886:	23 e0       	ldi	r18, 0x03	; 3
     888:	cf 01       	movw	r24, r30
     88a:	0e 94 2e 24 	call	0x485c	; 0x485c <xTaskGenericNotify>
    return;
     88e:	aa c0       	rjmp	.+340    	; 0x9e4 <receiver+0x1ba>
     890:	e1 2c       	mov	r14, r1
     892:	f1 2c       	mov	r15, r1
  }
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     894:	20 e0       	ldi	r18, 0x00	; 0
     896:	4f ef       	ldi	r20, 0xFF	; 255
     898:	5f ef       	ldi	r21, 0xFF	; 255
     89a:	60 e0       	ldi	r22, 0x00	; 0
     89c:	70 e0       	ldi	r23, 0x00	; 0
     89e:	f7 01       	movw	r30, r14
     8a0:	e7 57       	subi	r30, 0x77	; 119
     8a2:	ff 4f       	sbci	r31, 0xFF	; 255
     8a4:	80 81       	ld	r24, Z
     8a6:	91 81       	ldd	r25, Z+1	; 0x01
     8a8:	0e 94 99 15 	call	0x2b32	; 0x2b32 <xQueueGenericReceive>
  
  if(con->status == STATUS_CLOSED || con->status == STATUS_NONE || len == 0 || data == NULL) {
     8ac:	f7 01       	movw	r30, r14
     8ae:	80 81       	ld	r24, Z
     8b0:	82 30       	cpi	r24, 0x02	; 2
     8b2:	30 f0       	brcs	.+12     	; 0x8c0 <receiver+0x96>
     8b4:	a1 14       	cp	r10, r1
     8b6:	b1 04       	cpc	r11, r1
     8b8:	19 f0       	breq	.+6      	; 0x8c0 <receiver+0x96>
     8ba:	01 15       	cp	r16, r1
     8bc:	11 05       	cpc	r17, r1
     8be:	51 f4       	brne	.+20     	; 0x8d4 <receiver+0xaa>
    xSemaphoreGive(con->mutex);
     8c0:	f7 01       	movw	r30, r14
     8c2:	e7 57       	subi	r30, 0x77	; 119
     8c4:	ff 4f       	sbci	r31, 0xFF	; 255
     8c6:	60 e0       	ldi	r22, 0x00	; 0
     8c8:	70 e0       	ldi	r23, 0x00	; 0
     8ca:	80 81       	ld	r24, Z
     8cc:	91 81       	ldd	r25, Z+1	; 0x01
     8ce:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
    return;
     8d2:	88 c0       	rjmp	.+272    	; 0x9e4 <receiver+0x1ba>
  }
  
  if(con->status == STATUS_CONNECTING && type == TYPE_SYNACK) {
     8d4:	83 30       	cpi	r24, 0x03	; 3
     8d6:	21 f5       	brne	.+72     	; 0x920 <receiver+0xf6>
     8d8:	f3 e0       	ldi	r31, 0x03	; 3
     8da:	df 12       	cpse	r13, r31
     8dc:	21 c0       	rjmp	.+66     	; 0x920 <receiver+0xf6>
    if(con->blocked_task != NULL) {
     8de:	f7 01       	movw	r30, r14
     8e0:	e5 57       	subi	r30, 0x75	; 117
     8e2:	ff 4f       	sbci	r31, 0xFF	; 255
     8e4:	80 81       	ld	r24, Z
     8e6:	91 81       	ldd	r25, Z+1	; 0x01
     8e8:	00 97       	sbiw	r24, 0x00	; 0
     8ea:	81 f0       	breq	.+32     	; 0x90c <receiver+0xe2>
      xTaskNotifyGive(con->blocked_task);
     8ec:	00 e0       	ldi	r16, 0x00	; 0
     8ee:	10 e0       	ldi	r17, 0x00	; 0
     8f0:	22 e0       	ldi	r18, 0x02	; 2
     8f2:	40 e0       	ldi	r20, 0x00	; 0
     8f4:	50 e0       	ldi	r21, 0x00	; 0
     8f6:	ba 01       	movw	r22, r20
     8f8:	0e 94 2e 24 	call	0x485c	; 0x485c <xTaskGenericNotify>
      con->blocked_task = NULL;
     8fc:	f7 01       	movw	r30, r14
     8fe:	e5 57       	subi	r30, 0x75	; 117
     900:	ff 4f       	sbci	r31, 0xFF	; 255
     902:	11 82       	std	Z+1, r1	; 0x01
     904:	10 82       	st	Z, r1
      arq_send_ack(id, 0x00);
     906:	60 e0       	ldi	r22, 0x00	; 0
     908:	80 e0       	ldi	r24, 0x00	; 0
     90a:	1c de       	rcall	.-968    	; 0x544 <arq_send_ack>
    }
    
    xSemaphoreGive(con->mutex);
     90c:	f7 01       	movw	r30, r14
     90e:	e7 57       	subi	r30, 0x77	; 119
     910:	ff 4f       	sbci	r31, 0xFF	; 255
     912:	60 e0       	ldi	r22, 0x00	; 0
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	80 81       	ld	r24, Z
     918:	91 81       	ldd	r25, Z+1	; 0x01
     91a:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
    return;
     91e:	62 c0       	rjmp	.+196    	; 0x9e4 <receiver+0x1ba>
  }
  
  uint8_t sequence = data[1];
     920:	f8 01       	movw	r30, r16
     922:	c1 80       	ldd	r12, Z+1	; 0x01
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
     924:	dd 20       	and	r13, r13
     926:	09 f4       	brne	.+2      	; 0x92a <receiver+0x100>
     928:	52 c0       	rjmp	.+164    	; 0x9ce <receiver+0x1a4>
     92a:	f4 e0       	ldi	r31, 0x04	; 4
     92c:	df 12       	cpse	r13, r31
     92e:	13 c0       	rjmp	.+38     	; 0x956 <receiver+0x12c>
     930:	53 c0       	rjmp	.+166    	; 0x9d8 <receiver+0x1ae>
    if(sequence == con->request_number) {
      if(type == TYPE_DATA) arq_reassembly(id, &data[2], len-2);
     932:	a5 01       	movw	r20, r10
     934:	42 50       	subi	r20, 0x02	; 2
     936:	51 09       	sbc	r21, r1
     938:	b8 01       	movw	r22, r16
     93a:	6e 5f       	subi	r22, 0xFE	; 254
     93c:	7f 4f       	sbci	r23, 0xFF	; 255
     93e:	80 e0       	ldi	r24, 0x00	; 0
     940:	27 df       	rcall	.-434    	; 0x790 <arq_reassembly>
      con->request_number = (con->request_number+1) & 127;
     942:	f7 01       	movw	r30, r14
     944:	82 8d       	ldd	r24, Z+26	; 0x1a
     946:	8f 5f       	subi	r24, 0xFF	; 255
     948:	8f 77       	andi	r24, 0x7F	; 127
     94a:	82 8f       	std	Z+26, r24	; 0x1a
    }
    arq_send_ack(id, con->request_number);
     94c:	f7 01       	movw	r30, r14
     94e:	62 8d       	ldd	r22, Z+26	; 0x1a
     950:	80 e0       	ldi	r24, 0x00	; 0
     952:	f8 dd       	rcall	.-1040   	; 0x544 <arq_send_ack>
     954:	2c c0       	rjmp	.+88     	; 0x9ae <receiver+0x184>
  } else if(type == TYPE_ACK) {
     956:	f1 e0       	ldi	r31, 0x01	; 1
     958:	df 12       	cpse	r13, r31
     95a:	29 c0       	rjmp	.+82     	; 0x9ae <receiver+0x184>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
     95c:	f7 01       	movw	r30, r14
     95e:	83 8d       	ldd	r24, Z+27	; 0x1b
     960:	fc 2d       	mov	r31, r12
     962:	f8 1b       	sub	r31, r24
     964:	8f 2f       	mov	r24, r31
     966:	8f 77       	andi	r24, 0x7F	; 127
     968:	98 2e       	mov	r9, r24
    if(count != 0) {
     96a:	09 f1       	breq	.+66     	; 0x9ae <receiver+0x184>
     96c:	d1 2c       	mov	r13, r1
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     96e:	57 01       	movw	r10, r14
     970:	8b e0       	ldi	r24, 0x0B	; 11
     972:	a8 0e       	add	r10, r24
     974:	b1 1c       	adc	r11, r1
        buffer_remove(&con->send_buffer, NULL, len);
     976:	87 01       	movw	r16, r14
     978:	0f 5f       	subi	r16, 0xFF	; 255
     97a:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     97c:	42 e0       	ldi	r20, 0x02	; 2
     97e:	50 e0       	ldi	r21, 0x00	; 0
     980:	be 01       	movw	r22, r28
     982:	6f 5f       	subi	r22, 0xFF	; 255
     984:	7f 4f       	sbci	r23, 0xFF	; 255
     986:	c5 01       	movw	r24, r10
     988:	50 d1       	rcall	.+672    	; 0xc2a <buffer_remove>
        buffer_remove(&con->send_buffer, NULL, len);
     98a:	49 81       	ldd	r20, Y+1	; 0x01
     98c:	50 e0       	ldi	r21, 0x00	; 0
     98e:	60 e0       	ldi	r22, 0x00	; 0
     990:	70 e0       	ldi	r23, 0x00	; 0
     992:	c8 01       	movw	r24, r16
     994:	4a d1       	rcall	.+660    	; 0xc2a <buffer_remove>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
     996:	d3 94       	inc	r13
     998:	9d 10       	cpse	r9, r13
     99a:	f0 cf       	rjmp	.-32     	; 0x97c <receiver+0x152>
        buffer_remove(&con->segment_lengths, &len, 2);
        buffer_remove(&con->send_buffer, NULL, len);
      }
      con->sequence_base = sequence;
     99c:	f7 01       	movw	r30, r14
     99e:	c3 8e       	std	Z+27, r12	; 0x1b

      con->timer = 0;
     9a0:	14 8e       	std	Z+28, r1	; 0x1c
      con->timeout = 0;
     9a2:	16 8e       	std	Z+30, r1	; 0x1e
     9a4:	15 8e       	std	Z+29, r1	; 0x1d
      if(con->sequence_base == con->sequence_number) con->timer_started = 0; // No more un-acked packets
     9a6:	81 8d       	ldd	r24, Z+25	; 0x19
     9a8:	c8 12       	cpse	r12, r24
     9aa:	01 c0       	rjmp	.+2      	; 0x9ae <receiver+0x184>
     9ac:	17 8e       	std	Z+31, r1	; 0x1f
    }
  }
  
  xSemaphoreGive(con->mutex);
     9ae:	f7 01       	movw	r30, r14
     9b0:	e7 57       	subi	r30, 0x77	; 119
     9b2:	ff 4f       	sbci	r31, 0xFF	; 255
     9b4:	60 e0       	ldi	r22, 0x00	; 0
     9b6:	70 e0       	ldi	r23, 0x00	; 0
     9b8:	80 81       	ld	r24, Z
     9ba:	91 81       	ldd	r25, Z+1	; 0x01
     9bc:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
     9c0:	11 c0       	rjmp	.+34     	; 0x9e4 <receiver+0x1ba>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     9c2:	f8 01       	movw	r30, r16
     9c4:	d0 80       	ld	r13, Z
  
  if(con == NULL && type != TYPE_SYN) return;
     9c6:	f2 e0       	ldi	r31, 0x02	; 2
     9c8:	df 12       	cpse	r13, r31
     9ca:	0c c0       	rjmp	.+24     	; 0x9e4 <receiver+0x1ba>
     9cc:	50 cf       	rjmp	.-352    	; 0x86e <receiver+0x44>
    return;
  }
  
  uint8_t sequence = data[1];
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
    if(sequence == con->request_number) {
     9ce:	f7 01       	movw	r30, r14
     9d0:	82 8d       	ldd	r24, Z+26	; 0x1a
     9d2:	c8 12       	cpse	r12, r24
     9d4:	bb cf       	rjmp	.-138    	; 0x94c <receiver+0x122>
     9d6:	ad cf       	rjmp	.-166    	; 0x932 <receiver+0x108>
     9d8:	f7 01       	movw	r30, r14
     9da:	82 8d       	ldd	r24, Z+26	; 0x1a
     9dc:	c8 16       	cp	r12, r24
     9de:	09 f4       	brne	.+2      	; 0x9e2 <receiver+0x1b8>
     9e0:	b0 cf       	rjmp	.-160    	; 0x942 <receiver+0x118>
     9e2:	b4 cf       	rjmp	.-152    	; 0x94c <receiver+0x122>
    }
  }
  
  xSemaphoreGive(con->mutex);
  
}
     9e4:	0f 90       	pop	r0
     9e6:	df 91       	pop	r29
     9e8:	cf 91       	pop	r28
     9ea:	1f 91       	pop	r17
     9ec:	0f 91       	pop	r16
     9ee:	ff 90       	pop	r15
     9f0:	ef 90       	pop	r14
     9f2:	df 90       	pop	r13
     9f4:	cf 90       	pop	r12
     9f6:	bf 90       	pop	r11
     9f8:	af 90       	pop	r10
     9fa:	9f 90       	pop	r9
     9fc:	08 95       	ret

000009fe <vARQTask>:
void vARQTask(void *pvParamters) {
  uint8_t i;
  
  while(1) {
    for(i=0;i<MAX_CONNECTIONS;i++) {
		sender(i);
     9fe:	80 e0       	ldi	r24, 0x00	; 0
     a00:	c7 dd       	rcall	.-1138   	; 0x590 <sender>
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
     a02:	8a e0       	ldi	r24, 0x0A	; 10
     a04:	90 e0       	ldi	r25, 0x00	; 0
     a06:	0e 94 15 1c 	call	0x382a	; 0x382a <vTaskDelay>
     a0a:	f9 cf       	rjmp	.-14     	; 0x9fe <vARQTask>

00000a0c <buffer_init>:
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
     a0c:	fc 01       	movw	r30, r24
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a0e:	61 15       	cp	r22, r1
     a10:	71 05       	cpc	r23, r1
     a12:	61 f0       	breq	.+24     	; 0xa2c <buffer_init+0x20>
  b->buf = buf;
     a14:	71 83       	std	Z+1, r23	; 0x01
     a16:	60 83       	st	Z, r22
  b->capacity = size;
     a18:	53 83       	std	Z+3, r21	; 0x03
     a1a:	42 83       	std	Z+2, r20	; 0x02
  b->head = b->tail = b->len = 0;
     a1c:	11 86       	std	Z+9, r1	; 0x09
     a1e:	10 86       	std	Z+8, r1	; 0x08
     a20:	17 82       	std	Z+7, r1	; 0x07
     a22:	16 82       	std	Z+6, r1	; 0x06
     a24:	15 82       	std	Z+5, r1	; 0x05
     a26:	14 82       	std	Z+4, r1	; 0x04
  return 1;
     a28:	81 e0       	ldi	r24, 0x01	; 1
     a2a:	08 95       	ret
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a2c:	80 e0       	ldi	r24, 0x00	; 0
  b->buf = buf;
  b->capacity = size;
  b->head = b->tail = b->len = 0;
  return 1;
}
     a2e:	08 95       	ret

00000a30 <buffer_append>:

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
     a30:	ef 92       	push	r14
     a32:	ff 92       	push	r15
     a34:	0f 93       	push	r16
     a36:	1f 93       	push	r17
     a38:	cf 93       	push	r28
     a3a:	df 93       	push	r29
     a3c:	ec 01       	movw	r28, r24
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     a3e:	2a 81       	ldd	r18, Y+2	; 0x02
     a40:	3b 81       	ldd	r19, Y+3	; 0x03
     a42:	88 85       	ldd	r24, Y+8	; 0x08
     a44:	99 85       	ldd	r25, Y+9	; 0x09
     a46:	f9 01       	movw	r30, r18
     a48:	e8 1b       	sub	r30, r24
     a4a:	f9 0b       	sbc	r31, r25
     a4c:	e4 17       	cp	r30, r20
     a4e:	f5 07       	cpc	r31, r21
     a50:	08 f4       	brcc	.+2      	; 0xa54 <buffer_append+0x24>
     a52:	49 c0       	rjmp	.+146    	; 0xae6 <buffer_append+0xb6>
     a54:	8a 01       	movw	r16, r20
     a56:	7b 01       	movw	r14, r22
  if(len < b->capacity - b->head) {
     a58:	8c 81       	ldd	r24, Y+4	; 0x04
     a5a:	9d 81       	ldd	r25, Y+5	; 0x05
     a5c:	a9 01       	movw	r20, r18
     a5e:	48 1b       	sub	r20, r24
     a60:	59 0b       	sbc	r21, r25
     a62:	04 17       	cp	r16, r20
     a64:	15 07       	cpc	r17, r21
     a66:	a8 f4       	brcc	.+42     	; 0xa92 <buffer_append+0x62>
    memcpy(b->buf+b->head, data, len);
     a68:	28 81       	ld	r18, Y
     a6a:	39 81       	ldd	r19, Y+1	; 0x01
     a6c:	a8 01       	movw	r20, r16
     a6e:	82 0f       	add	r24, r18
     a70:	93 1f       	adc	r25, r19
     a72:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    b->head += len;
     a76:	8c 81       	ldd	r24, Y+4	; 0x04
     a78:	9d 81       	ldd	r25, Y+5	; 0x05
     a7a:	80 0f       	add	r24, r16
     a7c:	91 1f       	adc	r25, r17
     a7e:	9d 83       	std	Y+5, r25	; 0x05
     a80:	8c 83       	std	Y+4, r24	; 0x04
    if(b->head == b->capacity) b->head = 0;
     a82:	2a 81       	ldd	r18, Y+2	; 0x02
     a84:	3b 81       	ldd	r19, Y+3	; 0x03
     a86:	82 17       	cp	r24, r18
     a88:	93 07       	cpc	r25, r19
     a8a:	21 f5       	brne	.+72     	; 0xad4 <buffer_append+0xa4>
     a8c:	1d 82       	std	Y+5, r1	; 0x05
     a8e:	1c 82       	std	Y+4, r1	; 0x04
     a90:	21 c0       	rjmp	.+66     	; 0xad4 <buffer_append+0xa4>
  } else {
    memcpy(b->buf+b->head, data, (b->capacity - b->head) );
     a92:	28 81       	ld	r18, Y
     a94:	39 81       	ldd	r19, Y+1	; 0x01
     a96:	82 0f       	add	r24, r18
     a98:	93 1f       	adc	r25, r19
     a9a:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
     a9e:	8c 81       	ldd	r24, Y+4	; 0x04
     aa0:	9d 81       	ldd	r25, Y+5	; 0x05
     aa2:	6a 81       	ldd	r22, Y+2	; 0x02
     aa4:	7b 81       	ldd	r23, Y+3	; 0x03
     aa6:	ac 01       	movw	r20, r24
     aa8:	46 1b       	sub	r20, r22
     aaa:	57 0b       	sbc	r21, r23
     aac:	40 0f       	add	r20, r16
     aae:	51 1f       	adc	r21, r17
     ab0:	68 1b       	sub	r22, r24
     ab2:	79 0b       	sbc	r23, r25
     ab4:	6e 0d       	add	r22, r14
     ab6:	7f 1d       	adc	r23, r15
     ab8:	88 81       	ld	r24, Y
     aba:	99 81       	ldd	r25, Y+1	; 0x01
     abc:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    b->head = len-(b->capacity - b->head);
     ac0:	8c 81       	ldd	r24, Y+4	; 0x04
     ac2:	9d 81       	ldd	r25, Y+5	; 0x05
     ac4:	2a 81       	ldd	r18, Y+2	; 0x02
     ac6:	3b 81       	ldd	r19, Y+3	; 0x03
     ac8:	82 1b       	sub	r24, r18
     aca:	93 0b       	sbc	r25, r19
     acc:	80 0f       	add	r24, r16
     ace:	91 1f       	adc	r25, r17
     ad0:	9d 83       	std	Y+5, r25	; 0x05
     ad2:	8c 83       	std	Y+4, r24	; 0x04
  }
  b->len += len;
     ad4:	48 85       	ldd	r20, Y+8	; 0x08
     ad6:	59 85       	ldd	r21, Y+9	; 0x09
     ad8:	04 0f       	add	r16, r20
     ada:	15 1f       	adc	r17, r21
     adc:	19 87       	std	Y+9, r17	; 0x09
     ade:	08 87       	std	Y+8, r16	; 0x08
  return 1;
     ae0:	81 e0       	ldi	r24, 0x01	; 1
     ae2:	90 e0       	ldi	r25, 0x00	; 0
     ae4:	02 c0       	rjmp	.+4      	; 0xaea <buffer_append+0xba>
  b->head = b->tail = b->len = 0;
  return 1;
}

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     ae6:	80 e0       	ldi	r24, 0x00	; 0
     ae8:	90 e0       	ldi	r25, 0x00	; 0
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
    b->head = len-(b->capacity - b->head);
  }
  b->len += len;
  return 1;
}
     aea:	df 91       	pop	r29
     aec:	cf 91       	pop	r28
     aee:	1f 91       	pop	r17
     af0:	0f 91       	pop	r16
     af2:	ff 90       	pop	r15
     af4:	ef 90       	pop	r14
     af6:	08 95       	ret

00000af8 <buffer_remove_token>:

//This reads bytes from the buffer until token is found, or nbytes is reached
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
     af8:	0f 93       	push	r16
     afa:	1f 93       	push	r17
     afc:	cf 93       	push	r28
     afe:	df 93       	push	r29
     b00:	fc 01       	movw	r30, r24
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     b02:	21 15       	cp	r18, r1
     b04:	31 05       	cpc	r19, r1
     b06:	c9 f1       	breq	.+114    	; 0xb7a <buffer_remove_token+0x82>
    if( b->tail != b->head ){ //see if any data is available
     b08:	a6 81       	ldd	r26, Z+6	; 0x06
     b0a:	b7 81       	ldd	r27, Z+7	; 0x07
     b0c:	84 81       	ldd	r24, Z+4	; 0x04
     b0e:	95 81       	ldd	r25, Z+5	; 0x05
     b10:	a8 17       	cp	r26, r24
     b12:	b9 07       	cpc	r27, r25
     b14:	a9 f1       	breq	.+106    	; 0xb80 <buffer_remove_token+0x88>
     b16:	c6 2f       	mov	r28, r22
     b18:	d7 2f       	mov	r29, r23
     b1a:	80 e0       	ldi	r24, 0x00	; 0
     b1c:	90 e0       	ldi	r25, 0x00	; 0
     b1e:	07 c0       	rjmp	.+14     	; 0xb2e <buffer_remove_token+0x36>
     b20:	a6 81       	ldd	r26, Z+6	; 0x06
     b22:	b7 81       	ldd	r27, Z+7	; 0x07
     b24:	64 81       	ldd	r22, Z+4	; 0x04
     b26:	75 81       	ldd	r23, Z+5	; 0x05
     b28:	a6 17       	cp	r26, r22
     b2a:	b7 07       	cpc	r27, r23
     b2c:	59 f1       	breq	.+86     	; 0xb84 <buffer_remove_token+0x8c>
      *p++ = b->buf[b->tail];  //grab a byte from the buffer
     b2e:	60 81       	ld	r22, Z
     b30:	71 81       	ldd	r23, Z+1	; 0x01
     b32:	a6 0f       	add	r26, r22
     b34:	b7 1f       	adc	r27, r23
     b36:	5c 91       	ld	r21, X
     b38:	8e 01       	movw	r16, r28
     b3a:	58 83       	st	Y, r21
      b->tail++;  //increment the tail
     b3c:	66 81       	ldd	r22, Z+6	; 0x06
     b3e:	77 81       	ldd	r23, Z+7	; 0x07
     b40:	6f 5f       	subi	r22, 0xFF	; 255
     b42:	7f 4f       	sbci	r23, 0xFF	; 255
     b44:	77 83       	std	Z+7, r23	; 0x07
     b46:	66 83       	std	Z+6, r22	; 0x06
      b->len--;
     b48:	a0 85       	ldd	r26, Z+8	; 0x08
     b4a:	b1 85       	ldd	r27, Z+9	; 0x09
     b4c:	11 97       	sbiw	r26, 0x01	; 1
     b4e:	b1 87       	std	Z+9, r27	; 0x09
     b50:	a0 87       	std	Z+8, r26	; 0x08
      if( b->tail == b->capacity ){  //check for wrap-around
     b52:	a2 81       	ldd	r26, Z+2	; 0x02
     b54:	b3 81       	ldd	r27, Z+3	; 0x03
     b56:	6a 17       	cp	r22, r26
     b58:	7b 07       	cpc	r23, r27
     b5a:	11 f4       	brne	.+4      	; 0xb60 <buffer_remove_token+0x68>
        b->tail = 0;
     b5c:	17 82       	std	Z+7, r1	; 0x07
     b5e:	16 82       	std	Z+6, r1	; 0x06
     b60:	21 96       	adiw	r28, 0x01	; 1
      }
      if(*(p-1) == token) return i+1;
     b62:	d8 01       	movw	r26, r16
     b64:	5c 91       	ld	r21, X
     b66:	54 13       	cpse	r21, r20
     b68:	02 c0       	rjmp	.+4      	; 0xb6e <buffer_remove_token+0x76>
     b6a:	01 96       	adiw	r24, 0x01	; 1
     b6c:	0b c0       	rjmp	.+22     	; 0xb84 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     b6e:	01 96       	adiw	r24, 0x01	; 1
     b70:	28 17       	cp	r18, r24
     b72:	39 07       	cpc	r19, r25
     b74:	a9 f6       	brne	.-86     	; 0xb20 <buffer_remove_token+0x28>
      if(*(p-1) == token) return i+1;
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
     b76:	c9 01       	movw	r24, r18
     b78:	05 c0       	rjmp	.+10     	; 0xb84 <buffer_remove_token+0x8c>
     b7a:	80 e0       	ldi	r24, 0x00	; 0
     b7c:	90 e0       	ldi	r25, 0x00	; 0
     b7e:	02 c0       	rjmp	.+4      	; 0xb84 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     b80:	80 e0       	ldi	r24, 0x00	; 0
     b82:	90 e0       	ldi	r25, 0x00	; 0
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
}
     b84:	df 91       	pop	r29
     b86:	cf 91       	pop	r28
     b88:	1f 91       	pop	r17
     b8a:	0f 91       	pop	r16
     b8c:	08 95       	ret

00000b8e <buffer_read>:
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
     b8e:	cf 92       	push	r12
     b90:	df 92       	push	r13
     b92:	ef 92       	push	r14
     b94:	ff 92       	push	r15
     b96:	0f 93       	push	r16
     b98:	1f 93       	push	r17
     b9a:	cf 93       	push	r28
     b9c:	df 93       	push	r29
     b9e:	7c 01       	movw	r14, r24
     ba0:	6b 01       	movw	r12, r22
     ba2:	ea 01       	movw	r28, r20
     ba4:	89 01       	movw	r16, r18
  if(data == NULL) return 0;
     ba6:	67 2b       	or	r22, r23
     ba8:	a9 f1       	breq	.+106    	; 0xc14 <buffer_read+0x86>
  if(idx >= b->capacity) idx -= b->capacity;
     baa:	fc 01       	movw	r30, r24
     bac:	42 81       	ldd	r20, Z+2	; 0x02
     bae:	53 81       	ldd	r21, Z+3	; 0x03
     bb0:	c4 17       	cp	r28, r20
     bb2:	d5 07       	cpc	r29, r21
     bb4:	10 f0       	brcs	.+4      	; 0xbba <buffer_read+0x2c>
     bb6:	c4 1b       	sub	r28, r20
     bb8:	d5 0b       	sbc	r29, r21
  if(b->capacity - idx >= len) {
     bba:	4c 1b       	sub	r20, r28
     bbc:	5d 0b       	sbc	r21, r29
     bbe:	40 17       	cp	r20, r16
     bc0:	51 07       	cpc	r21, r17
     bc2:	60 f0       	brcs	.+24     	; 0xbdc <buffer_read+0x4e>
    memcpy(data, b->buf+idx, len);
     bc4:	f7 01       	movw	r30, r14
     bc6:	60 81       	ld	r22, Z
     bc8:	71 81       	ldd	r23, Z+1	; 0x01
     bca:	6c 0f       	add	r22, r28
     bcc:	7d 1f       	adc	r23, r29
     bce:	a8 01       	movw	r20, r16
     bd0:	c6 01       	movw	r24, r12
     bd2:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
     bd6:	80 2f       	mov	r24, r16
     bd8:	91 2f       	mov	r25, r17
     bda:	1e c0       	rjmp	.+60     	; 0xc18 <buffer_read+0x8a>
  if(data == NULL) return 0;
  if(idx >= b->capacity) idx -= b->capacity;
  if(b->capacity - idx >= len) {
    memcpy(data, b->buf+idx, len);
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
     bdc:	f7 01       	movw	r30, r14
     bde:	60 81       	ld	r22, Z
     be0:	71 81       	ldd	r23, Z+1	; 0x01
     be2:	6c 0f       	add	r22, r28
     be4:	7d 1f       	adc	r23, r29
     be6:	c6 01       	movw	r24, r12
     be8:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
     bec:	f7 01       	movw	r30, r14
     bee:	22 81       	ldd	r18, Z+2	; 0x02
     bf0:	33 81       	ldd	r19, Z+3	; 0x03
     bf2:	c9 01       	movw	r24, r18
     bf4:	8c 1b       	sub	r24, r28
     bf6:	9d 0b       	sbc	r25, r29
     bf8:	a8 01       	movw	r20, r16
     bfa:	42 1b       	sub	r20, r18
     bfc:	53 0b       	sbc	r21, r19
     bfe:	4c 0f       	add	r20, r28
     c00:	5d 1f       	adc	r21, r29
     c02:	60 81       	ld	r22, Z
     c04:	71 81       	ldd	r23, Z+1	; 0x01
     c06:	8c 0d       	add	r24, r12
     c08:	9d 1d       	adc	r25, r13
     c0a:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
  }
  return len;
     c0e:	80 2f       	mov	r24, r16
     c10:	91 2f       	mov	r25, r17
     c12:	02 c0       	rjmp	.+4      	; 0xc18 <buffer_read+0x8a>
  }
  return nbytes;
}
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
  if(data == NULL) return 0;
     c14:	80 e0       	ldi	r24, 0x00	; 0
     c16:	90 e0       	ldi	r25, 0x00	; 0
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
}
     c18:	df 91       	pop	r29
     c1a:	cf 91       	pop	r28
     c1c:	1f 91       	pop	r17
     c1e:	0f 91       	pop	r16
     c20:	ff 90       	pop	r15
     c22:	ef 90       	pop	r14
     c24:	df 90       	pop	r13
     c26:	cf 90       	pop	r12
     c28:	08 95       	ret

00000c2a <buffer_remove>:

//Remove 'len' bytes from the buffer and add them to 'data'
uint16_t buffer_remove(buffer_t *b, uint8_t *data, uint16_t len) {
     c2a:	ef 92       	push	r14
     c2c:	ff 92       	push	r15
     c2e:	0f 93       	push	r16
     c30:	1f 93       	push	r17
     c32:	cf 93       	push	r28
     c34:	df 93       	push	r29
     c36:	ec 01       	movw	r28, r24
     c38:	7b 01       	movw	r14, r22
  if(len > b->len) len = b->len;
     c3a:	08 85       	ldd	r16, Y+8	; 0x08
     c3c:	19 85       	ldd	r17, Y+9	; 0x09
     c3e:	40 17       	cp	r20, r16
     c40:	51 07       	cpc	r21, r17
     c42:	08 f4       	brcc	.+2      	; 0xc46 <buffer_remove+0x1c>
     c44:	8a 01       	movw	r16, r20
  if(b->capacity - b->tail >= len) {
     c46:	8e 81       	ldd	r24, Y+6	; 0x06
     c48:	9f 81       	ldd	r25, Y+7	; 0x07
     c4a:	4a 81       	ldd	r20, Y+2	; 0x02
     c4c:	5b 81       	ldd	r21, Y+3	; 0x03
     c4e:	48 1b       	sub	r20, r24
     c50:	59 0b       	sbc	r21, r25
     c52:	40 17       	cp	r20, r16
     c54:	51 07       	cpc	r21, r17
     c56:	c8 f0       	brcs	.+50     	; 0xc8a <buffer_remove+0x60>
    if(data != NULL) memcpy(data, b->buf+b->tail, len);
     c58:	e1 14       	cp	r14, r1
     c5a:	f1 04       	cpc	r15, r1
     c5c:	41 f0       	breq	.+16     	; 0xc6e <buffer_remove+0x44>
     c5e:	68 81       	ld	r22, Y
     c60:	79 81       	ldd	r23, Y+1	; 0x01
     c62:	68 0f       	add	r22, r24
     c64:	79 1f       	adc	r23, r25
     c66:	a8 01       	movw	r20, r16
     c68:	c7 01       	movw	r24, r14
     c6a:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    b->tail = b->tail + len;
     c6e:	8e 81       	ldd	r24, Y+6	; 0x06
     c70:	9f 81       	ldd	r25, Y+7	; 0x07
     c72:	80 0f       	add	r24, r16
     c74:	91 1f       	adc	r25, r17
     c76:	9f 83       	std	Y+7, r25	; 0x07
     c78:	8e 83       	std	Y+6, r24	; 0x06
    if(b->tail == b->capacity) b->tail = 0;
     c7a:	2a 81       	ldd	r18, Y+2	; 0x02
     c7c:	3b 81       	ldd	r19, Y+3	; 0x03
     c7e:	82 17       	cp	r24, r18
     c80:	93 07       	cpc	r25, r19
     c82:	41 f5       	brne	.+80     	; 0xcd4 <buffer_remove+0xaa>
     c84:	1f 82       	std	Y+7, r1	; 0x07
     c86:	1e 82       	std	Y+6, r1	; 0x06
     c88:	25 c0       	rjmp	.+74     	; 0xcd4 <buffer_remove+0xaa>
  } else {
    if(data != NULL) {
     c8a:	e1 14       	cp	r14, r1
     c8c:	f1 04       	cpc	r15, r1
     c8e:	c1 f0       	breq	.+48     	; 0xcc0 <buffer_remove+0x96>
      memcpy(data, b->buf+b->tail, b->capacity - b->tail);
     c90:	68 81       	ld	r22, Y
     c92:	79 81       	ldd	r23, Y+1	; 0x01
     c94:	68 0f       	add	r22, r24
     c96:	79 1f       	adc	r23, r25
     c98:	c7 01       	movw	r24, r14
     c9a:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
      memcpy(data + (b->capacity - b->tail), b->buf, len - (b->capacity - b->tail) );
     c9e:	4e 81       	ldd	r20, Y+6	; 0x06
     ca0:	5f 81       	ldd	r21, Y+7	; 0x07
     ca2:	2a 81       	ldd	r18, Y+2	; 0x02
     ca4:	3b 81       	ldd	r19, Y+3	; 0x03
     ca6:	c9 01       	movw	r24, r18
     ca8:	84 1b       	sub	r24, r20
     caa:	95 0b       	sbc	r25, r21
     cac:	42 1b       	sub	r20, r18
     cae:	53 0b       	sbc	r21, r19
     cb0:	40 0f       	add	r20, r16
     cb2:	51 1f       	adc	r21, r17
     cb4:	68 81       	ld	r22, Y
     cb6:	79 81       	ldd	r23, Y+1	; 0x01
     cb8:	8e 0d       	add	r24, r14
     cba:	9f 1d       	adc	r25, r15
     cbc:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    }
    b->tail = len - (b->capacity - b->tail);
     cc0:	8e 81       	ldd	r24, Y+6	; 0x06
     cc2:	9f 81       	ldd	r25, Y+7	; 0x07
     cc4:	2a 81       	ldd	r18, Y+2	; 0x02
     cc6:	3b 81       	ldd	r19, Y+3	; 0x03
     cc8:	82 1b       	sub	r24, r18
     cca:	93 0b       	sbc	r25, r19
     ccc:	80 0f       	add	r24, r16
     cce:	91 1f       	adc	r25, r17
     cd0:	9f 83       	std	Y+7, r25	; 0x07
     cd2:	8e 83       	std	Y+6, r24	; 0x06
  }
  b->len -= len;
     cd4:	88 85       	ldd	r24, Y+8	; 0x08
     cd6:	99 85       	ldd	r25, Y+9	; 0x09
     cd8:	80 1b       	sub	r24, r16
     cda:	91 0b       	sbc	r25, r17
     cdc:	99 87       	std	Y+9, r25	; 0x09
     cde:	88 87       	std	Y+8, r24	; 0x08
  return len;
     ce0:	c8 01       	movw	r24, r16
     ce2:	df 91       	pop	r29
     ce4:	cf 91       	pop	r28
     ce6:	1f 91       	pop	r17
     ce8:	0f 91       	pop	r16
     cea:	ff 90       	pop	r15
     cec:	ef 90       	pop	r14
     cee:	08 95       	ret

00000cf0 <cobs_encode>:
/*****************************************************************************
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     cf0:	ef 92       	push	r14
     cf2:	ff 92       	push	r15
     cf4:	0f 93       	push	r16
     cf6:	1f 93       	push	r17
     cf8:	cf 93       	push	r28
     cfa:	df 93       	push	r29
     cfc:	7c 01       	movw	r14, r24
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     cfe:	68 0f       	add	r22, r24
     d00:	79 1f       	adc	r23, r25
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
     d02:	fc 01       	movw	r30, r24
     d04:	31 96       	adiw	r30, 0x01	; 1
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     d06:	00 97       	sbiw	r24, 0x00	; 0
     d08:	19 f0       	breq	.+6      	; 0xd10 <cobs_encode+0x20>
     d0a:	41 15       	cp	r20, r1
     d0c:	51 05       	cpc	r21, r1
     d0e:	21 f4       	brne	.+8      	; 0xd18 <cobs_encode+0x28>
    {
        result.status = COBS_ENCODE_NULL_POINTER;
        return result;
     d10:	60 e0       	ldi	r22, 0x00	; 0
     d12:	70 e0       	ldi	r23, 0x00	; 0
     d14:	81 e0       	ldi	r24, 0x01	; 1
     d16:	4b c0       	rjmp	.+150    	; 0xdae <cobs_encode+0xbe>
    }

    if (src_len != 0)
     d18:	21 15       	cp	r18, r1
     d1a:	31 05       	cpc	r19, r1
     d1c:	59 f1       	breq	.+86     	; 0xd74 <cobs_encode+0x84>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d1e:	e6 17       	cp	r30, r22
     d20:	f7 07       	cpc	r31, r23
     d22:	60 f5       	brcc	.+88     	; 0xd7c <cobs_encode+0x8c>
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     d24:	8a 01       	movw	r16, r20
     d26:	02 0f       	add	r16, r18
     d28:	13 1f       	adc	r17, r19
     d2a:	da 01       	movw	r26, r20
     d2c:	ec 01       	movw	r28, r24
     d2e:	91 e0       	ldi	r25, 0x01	; 1
                }
                if (search_len == 0xFF)
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     d30:	2f ef       	ldi	r18, 0xFF	; 255
     d32:	04 c0       	rjmp	.+8      	; 0xd3c <cobs_encode+0x4c>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     d34:	fa 01       	movw	r30, r20
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d36:	e6 17       	cp	r30, r22
     d38:	f7 07       	cpc	r31, r23
     d3a:	20 f5       	brcc	.+72     	; 0xd84 <cobs_encode+0x94>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
                break;
            }

            src_byte = *src_ptr++;
     d3c:	3d 91       	ld	r19, X+
            if (src_byte == 0)
     d3e:	31 11       	cpse	r19, r1
     d40:	0a c0       	rjmp	.+20     	; 0xd56 <cobs_encode+0x66>
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
     d42:	98 83       	st	Y, r25
                dst_code_write_ptr = dst_write_ptr++;
     d44:	cf 01       	movw	r24, r30
     d46:	01 96       	adiw	r24, 0x01	; 1
                search_len = 1;
                if (src_ptr >= src_end_ptr)
     d48:	a0 17       	cp	r26, r16
     d4a:	b1 07       	cpc	r27, r17
     d4c:	e8 f4       	brcc	.+58     	; 0xd88 <cobs_encode+0x98>
     d4e:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     d50:	fc 01       	movw	r30, r24
                search_len = 1;
     d52:	91 e0       	ldi	r25, 0x01	; 1
     d54:	f0 cf       	rjmp	.-32     	; 0xd36 <cobs_encode+0x46>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     d56:	af 01       	movw	r20, r30
     d58:	4f 5f       	subi	r20, 0xFF	; 255
     d5a:	5f 4f       	sbci	r21, 0xFF	; 255
     d5c:	30 83       	st	Z, r19
                search_len++;
     d5e:	9f 5f       	subi	r25, 0xFF	; 255
                if (src_ptr >= src_end_ptr)
     d60:	a0 17       	cp	r26, r16
     d62:	b1 07       	cpc	r27, r17
     d64:	b0 f4       	brcc	.+44     	; 0xd92 <cobs_encode+0xa2>
                {
                    break;
                }
                if (search_len == 0xFF)
     d66:	9f 3f       	cpi	r25, 0xFF	; 255
     d68:	29 f7       	brne	.-54     	; 0xd34 <cobs_encode+0x44>
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     d6a:	28 83       	st	Y, r18
                    dst_code_write_ptr = dst_write_ptr++;
     d6c:	32 96       	adiw	r30, 0x02	; 2
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     d6e:	ea 01       	movw	r28, r20
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
                    dst_code_write_ptr = dst_write_ptr++;
                    search_len = 1;
     d70:	91 e0       	ldi	r25, 0x01	; 1
     d72:	e1 cf       	rjmp	.-62     	; 0xd36 <cobs_encode+0x46>
cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
     d74:	ec 01       	movw	r28, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     d76:	80 e0       	ldi	r24, 0x00	; 0
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;
     d78:	91 e0       	ldi	r25, 0x01	; 1
     d7a:	0d c0       	rjmp	.+26     	; 0xd96 <cobs_encode+0xa6>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d7c:	ec 01       	movw	r28, r24
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     d7e:	82 e0       	ldi	r24, 0x02	; 2
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d80:	91 e0       	ldi	r25, 0x01	; 1
     d82:	09 c0       	rjmp	.+18     	; 0xd96 <cobs_encode+0xa6>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     d84:	82 e0       	ldi	r24, 0x02	; 2
     d86:	07 c0       	rjmp	.+14     	; 0xd96 <cobs_encode+0xa6>
     d88:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     d8a:	fc 01       	movw	r30, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     d8c:	80 e0       	ldi	r24, 0x00	; 0
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
                search_len = 1;
     d8e:	91 e0       	ldi	r25, 0x01	; 1
     d90:	02 c0       	rjmp	.+4      	; 0xd96 <cobs_encode+0xa6>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     d92:	fa 01       	movw	r30, r20
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     d94:	80 e0       	ldi	r24, 0x00	; 0

    /* We've reached the end of the source data (or possibly run out of output buffer)
     * Finalise the remaining output. In particular, write the code (length) byte.
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
     d96:	c6 17       	cp	r28, r22
     d98:	d7 07       	cpc	r29, r23
     d9a:	18 f4       	brcc	.+6      	; 0xda2 <cobs_encode+0xb2>
        dst_write_ptr = dst_buf_end_ptr;
    }
    else
    {
        /* Write the last code (length) byte. */
        *dst_code_write_ptr = search_len;
     d9c:	98 83       	st	Y, r25
     d9e:	bf 01       	movw	r22, r30
     da0:	01 c0       	rjmp	.+2      	; 0xda4 <cobs_encode+0xb4>
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
    {
        /* We've run out of output buffer to write the code byte. */
        result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     da2:	82 e0       	ldi	r24, 0x02	; 2
    }

    /* Calculate the output length, from the value of dst_code_write_ptr */
    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     da4:	9b 01       	movw	r18, r22
     da6:	2e 19       	sub	r18, r14
     da8:	3f 09       	sbc	r19, r15
     daa:	62 2f       	mov	r22, r18
     dac:	73 2f       	mov	r23, r19
}
     dae:	df 91       	pop	r29
     db0:	cf 91       	pop	r28
     db2:	1f 91       	pop	r17
     db4:	0f 91       	pop	r16
     db6:	ff 90       	pop	r15
     db8:	ef 90       	pop	r14
     dba:	08 95       	ret

00000dbc <cobs_decode>:


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     dbc:	af 92       	push	r10
     dbe:	bf 92       	push	r11
     dc0:	cf 92       	push	r12
     dc2:	df 92       	push	r13
     dc4:	ef 92       	push	r14
     dc6:	ff 92       	push	r15
     dc8:	0f 93       	push	r16
     dca:	1f 93       	push	r17
     dcc:	cf 93       	push	r28
     dce:	df 93       	push	r29
     dd0:	7c 01       	movw	r14, r24
     dd2:	da 01       	movw	r26, r20
    uint8_t             i;
    uint8_t             len_code;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     dd4:	00 97       	sbiw	r24, 0x00	; 0
     dd6:	11 f0       	breq	.+4      	; 0xddc <cobs_decode+0x20>
     dd8:	10 97       	sbiw	r26, 0x00	; 0
     dda:	21 f4       	brne	.+8      	; 0xde4 <cobs_decode+0x28>
    {
        result.status = COBS_DECODE_NULL_POINTER;
        return result;
     ddc:	60 e0       	ldi	r22, 0x00	; 0
     dde:	70 e0       	ldi	r23, 0x00	; 0
     de0:	81 e0       	ldi	r24, 0x01	; 1
     de2:	5f c0       	rjmp	.+190    	; 0xea2 <cobs_decode+0xe6>
    }

    if (src_len != 0)
     de4:	21 15       	cp	r18, r1
     de6:	31 05       	cpc	r19, r1
     de8:	09 f4       	brne	.+2      	; 0xdec <cobs_decode+0x30>
     dea:	4b c0       	rjmp	.+150    	; 0xe82 <cobs_decode+0xc6>


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     dec:	6a 01       	movw	r12, r20
     dee:	c2 0e       	add	r12, r18
     df0:	d3 1e       	adc	r13, r19
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     df2:	5c 01       	movw	r10, r24
     df4:	a6 0e       	add	r10, r22
     df6:	b7 1e       	adc	r11, r23
     df8:	8c 01       	movw	r16, r24
     dfa:	50 e0       	ldi	r21, 0x00	; 0
     dfc:	01 c0       	rjmp	.+2      	; 0xe00 <cobs_decode+0x44>
                src_byte = *src_ptr++;
                if (src_byte == 0)
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
     dfe:	8f 01       	movw	r16, r30

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     e00:	ed 01       	movw	r28, r26
     e02:	21 96       	adiw	r28, 0x01	; 1
     e04:	7c 91       	ld	r23, X
            if (len_code == 0)
     e06:	71 11       	cpse	r23, r1
     e08:	03 c0       	rjmp	.+6      	; 0xe10 <cobs_decode+0x54>
            {
                result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e0a:	54 60       	ori	r21, 0x04	; 4
                break;
     e0c:	f8 01       	movw	r30, r16
     e0e:	3d c0       	rjmp	.+122    	; 0xe8a <cobs_decode+0xce>
            }
            len_code--;
     e10:	71 50       	subi	r23, 0x01	; 1

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
     e12:	c6 01       	movw	r24, r12
     e14:	8c 1b       	sub	r24, r28
     e16:	9d 0b       	sbc	r25, r29
            if (len_code > remaining_bytes)
     e18:	27 2f       	mov	r18, r23
     e1a:	30 e0       	ldi	r19, 0x00	; 0
     e1c:	82 17       	cp	r24, r18
     e1e:	93 07       	cpc	r25, r19
     e20:	10 f4       	brcc	.+4      	; 0xe26 <cobs_decode+0x6a>
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
                len_code = remaining_bytes;
     e22:	78 2f       	mov	r23, r24

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
     e24:	58 60       	ori	r21, 0x08	; 8
                len_code = remaining_bytes;
            }

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
     e26:	c5 01       	movw	r24, r10
     e28:	80 1b       	sub	r24, r16
     e2a:	91 0b       	sbc	r25, r17
            if (len_code > remaining_bytes)
     e2c:	27 2f       	mov	r18, r23
     e2e:	30 e0       	ldi	r19, 0x00	; 0
     e30:	82 17       	cp	r24, r18
     e32:	93 07       	cpc	r25, r19
     e34:	10 f4       	brcc	.+4      	; 0xe3a <cobs_decode+0x7e>
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
     e36:	78 2f       	mov	r23, r24

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     e38:	52 60       	ori	r21, 0x02	; 2
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e3a:	77 23       	and	r23, r23
     e3c:	61 f1       	breq	.+88     	; 0xe96 <cobs_decode+0xda>
     e3e:	de 01       	movw	r26, r28
     e40:	f8 01       	movw	r30, r16
     e42:	97 2f       	mov	r25, r23
            {
                src_byte = *src_ptr++;
     e44:	3d 91       	ld	r19, X+
                if (src_byte == 0)
     e46:	31 11       	cpse	r19, r1
     e48:	01 c0       	rjmp	.+2      	; 0xe4c <cobs_decode+0x90>
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e4a:	54 60       	ori	r21, 0x04	; 4
                }
                *dst_write_ptr++ = src_byte;
     e4c:	31 93       	st	Z+, r19
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e4e:	91 50       	subi	r25, 0x01	; 1
     e50:	c9 f7       	brne	.-14     	; 0xe44 <cobs_decode+0x88>
     e52:	ef ef       	ldi	r30, 0xFF	; 255
     e54:	e7 0f       	add	r30, r23
     e56:	f0 e0       	ldi	r31, 0x00	; 0
     e58:	31 96       	adiw	r30, 0x01	; 1
     e5a:	de 01       	movw	r26, r28
     e5c:	ae 0f       	add	r26, r30
     e5e:	bf 1f       	adc	r27, r31
     e60:	e0 0f       	add	r30, r16
     e62:	f1 1f       	adc	r31, r17
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     e64:	ac 15       	cp	r26, r12
     e66:	bd 05       	cpc	r27, r13
     e68:	80 f4       	brcc	.+32     	; 0xe8a <cobs_decode+0xce>
            {
                break;
            }

            /* Add a zero to the end */
            if (len_code != 0xFE)
     e6a:	7e 3f       	cpi	r23, 0xFE	; 254
     e6c:	41 f2       	breq	.-112    	; 0xdfe <cobs_decode+0x42>
            {
                if (dst_write_ptr >= dst_buf_end_ptr)
     e6e:	ea 15       	cp	r30, r10
     e70:	fb 05       	cpc	r31, r11
     e72:	10 f0       	brcs	.+4      	; 0xe78 <cobs_decode+0xbc>
                {
                    result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     e74:	52 60       	ori	r21, 0x02	; 2
                    break;
     e76:	09 c0       	rjmp	.+18     	; 0xe8a <cobs_decode+0xce>
                }
                *dst_write_ptr++ = 0;
     e78:	8f 01       	movw	r16, r30
     e7a:	0f 5f       	subi	r16, 0xFF	; 255
     e7c:	1f 4f       	sbci	r17, 0xFF	; 255
     e7e:	10 82       	st	Z, r1
     e80:	bf cf       	rjmp	.-130    	; 0xe00 <cobs_decode+0x44>
cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_write_ptr       = dst_buf_ptr;
     e82:	fc 01       	movw	r30, r24
}


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
     e84:	50 e0       	ldi	r21, 0x00	; 0
     e86:	01 c0       	rjmp	.+2      	; 0xe8a <cobs_decode+0xce>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     e88:	f8 01       	movw	r30, r16
        }
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     e8a:	ee 19       	sub	r30, r14
     e8c:	ff 09       	sbc	r31, r15
     e8e:	6e 2f       	mov	r22, r30
     e90:	7f 2f       	mov	r23, r31
     e92:	85 2f       	mov	r24, r21
     e94:	06 c0       	rjmp	.+12     	; 0xea2 <cobs_decode+0xe6>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     e96:	cc 15       	cp	r28, r12
     e98:	dd 05       	cpc	r29, r13
     e9a:	b0 f7       	brcc	.-20     	; 0xe88 <cobs_decode+0xcc>
     e9c:	f8 01       	movw	r30, r16

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     e9e:	de 01       	movw	r26, r28
     ea0:	e6 cf       	rjmp	.-52     	; 0xe6e <cobs_decode+0xb2>
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
}
     ea2:	df 91       	pop	r29
     ea4:	cf 91       	pop	r28
     ea6:	1f 91       	pop	r17
     ea8:	0f 91       	pop	r16
     eaa:	ff 90       	pop	r15
     eac:	ef 90       	pop	r14
     eae:	df 90       	pop	r13
     eb0:	cf 90       	pop	r12
     eb2:	bf 90       	pop	r11
     eb4:	af 90       	pop	r10
     eb6:	08 95       	ret

00000eb8 <crc_ibutton_update>:
  return crc;
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
     eb8:	86 27       	eor	r24, r22
     eba:	98 e0       	ldi	r25, 0x08	; 8
  for (i = 0; i < 8; i++) {
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
     ebc:	2c e8       	ldi	r18, 0x8C	; 140
     ebe:	80 ff       	sbrs	r24, 0
     ec0:	03 c0       	rjmp	.+6      	; 0xec8 <crc_ibutton_update+0x10>
     ec2:	86 95       	lsr	r24
     ec4:	82 27       	eor	r24, r18
     ec6:	01 c0       	rjmp	.+2      	; 0xeca <crc_ibutton_update+0x12>
    else crc >>= 1;
     ec8:	86 95       	lsr	r24
     eca:	91 50       	subi	r25, 0x01	; 1
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
  for (i = 0; i < 8; i++) {
     ecc:	c1 f7       	brne	.-16     	; 0xebe <crc_ibutton_update+0x6>
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
    else crc >>= 1;
  }
  return crc;
     ece:	08 95       	ret

00000ed0 <calculate_crc>:

#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
     ed0:	0f 93       	push	r16
     ed2:	1f 93       	push	r17
     ed4:	cf 93       	push	r28
     ed6:	df 93       	push	r29
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
     ed8:	66 23       	and	r22, r22
     eda:	59 f0       	breq	.+22     	; 0xef2 <calculate_crc+0x22>
     edc:	8c 01       	movw	r16, r24
     ede:	ec 01       	movw	r28, r24
     ee0:	06 0f       	add	r16, r22
     ee2:	11 1d       	adc	r17, r1
     ee4:	80 e0       	ldi	r24, 0x00	; 0
    crc = crc_ibutton_update(crc, data[i]);
     ee6:	69 91       	ld	r22, Y+
     ee8:	e7 df       	rcall	.-50     	; 0xeb8 <crc_ibutton_update>
char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
     eea:	0c 17       	cp	r16, r28
     eec:	1d 07       	cpc	r17, r29
     eee:	d9 f7       	brne	.-10     	; 0xee6 <calculate_crc+0x16>
     ef0:	01 c0       	rjmp	.+2      	; 0xef4 <calculate_crc+0x24>
#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
     ef2:	80 e0       	ldi	r24, 0x00	; 0
  int i;
  for(i=0;i<len;i++) {
    crc = crc_ibutton_update(crc, data[i]);
  }
  return crc;
}
     ef4:	df 91       	pop	r29
     ef6:	cf 91       	pop	r28
     ef8:	1f 91       	pop	r17
     efa:	0f 91       	pop	r16
     efc:	08 95       	ret

00000efe <vDistSens_init>:
};

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
     efe:	80 b3       	in	r24, 0x10	; 16
     f00:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     f02:	ec e7       	ldi	r30, 0x7C	; 124
     f04:	f0 e0       	ldi	r31, 0x00	; 0
     f06:	80 81       	ld	r24, Z
     f08:	80 6c       	ori	r24, 0xC0	; 192
     f0a:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
     f0c:	ea e7       	ldi	r30, 0x7A	; 122
     f0e:	f0 e0       	ldi	r31, 0x00	; 0
     f10:	80 81       	ld	r24, Z
     f12:	80 68       	ori	r24, 0x80	; 128
     f14:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
     f16:	80 81       	ld	r24, Z
     f18:	84 60       	ori	r24, 0x04	; 4
     f1a:	80 83       	st	Z, r24
     f1c:	08 95       	ret

00000f1e <vFunc_Inf2pi>:
#include <string.h>
#include <math.h>
#include <stdlib.h>

/* Take any angle and put it inside -pi,pi */
void vFunc_Inf2pi(float *angle_in_radians){
     f1e:	cf 92       	push	r12
     f20:	df 92       	push	r13
     f22:	ef 92       	push	r14
     f24:	ff 92       	push	r15
     f26:	cf 93       	push	r28
     f28:	df 93       	push	r29
     f2a:	ec 01       	movw	r28, r24
    do{
        if (*angle_in_radians > M_PI) *angle_in_radians -= 2*M_PI;
     f2c:	c8 80       	ld	r12, Y
     f2e:	d9 80       	ldd	r13, Y+1	; 0x01
     f30:	ea 80       	ldd	r14, Y+2	; 0x02
     f32:	fb 80       	ldd	r15, Y+3	; 0x03
     f34:	2b ed       	ldi	r18, 0xDB	; 219
     f36:	3f e0       	ldi	r19, 0x0F	; 15
     f38:	49 e4       	ldi	r20, 0x49	; 73
     f3a:	50 e4       	ldi	r21, 0x40	; 64
     f3c:	c7 01       	movw	r24, r14
     f3e:	b6 01       	movw	r22, r12
     f40:	0e 94 b9 27 	call	0x4f72	; 0x4f72 <__gesf2>
     f44:	18 16       	cp	r1, r24
     f46:	6c f4       	brge	.+26     	; 0xf62 <vFunc_Inf2pi+0x44>
     f48:	2b ed       	ldi	r18, 0xDB	; 219
     f4a:	3f e0       	ldi	r19, 0x0F	; 15
     f4c:	49 ec       	ldi	r20, 0xC9	; 201
     f4e:	50 e4       	ldi	r21, 0x40	; 64
     f50:	c7 01       	movw	r24, r14
     f52:	b6 01       	movw	r22, r12
     f54:	0e 94 9e 26 	call	0x4d3c	; 0x4d3c <__subsf3>
     f58:	68 83       	st	Y, r22
     f5a:	79 83       	std	Y+1, r23	; 0x01
     f5c:	8a 83       	std	Y+2, r24	; 0x02
     f5e:	9b 83       	std	Y+3, r25	; 0x03
     f60:	16 c0       	rjmp	.+44     	; 0xf8e <vFunc_Inf2pi+0x70>
        else if (*angle_in_radians < -M_PI) *angle_in_radians += 2*M_PI;
     f62:	2b ed       	ldi	r18, 0xDB	; 219
     f64:	3f e0       	ldi	r19, 0x0F	; 15
     f66:	49 e4       	ldi	r20, 0x49	; 73
     f68:	50 ec       	ldi	r21, 0xC0	; 192
     f6a:	c7 01       	movw	r24, r14
     f6c:	b6 01       	movw	r22, r12
     f6e:	0e 94 03 27 	call	0x4e06	; 0x4e06 <__cmpsf2>
     f72:	88 23       	and	r24, r24
     f74:	64 f4       	brge	.+24     	; 0xf8e <vFunc_Inf2pi+0x70>
     f76:	2b ed       	ldi	r18, 0xDB	; 219
     f78:	3f e0       	ldi	r19, 0x0F	; 15
     f7a:	49 ec       	ldi	r20, 0xC9	; 201
     f7c:	50 e4       	ldi	r21, 0x40	; 64
     f7e:	c7 01       	movw	r24, r14
     f80:	b6 01       	movw	r22, r12
     f82:	0e 94 9f 26 	call	0x4d3e	; 0x4d3e <__addsf3>
     f86:	68 83       	st	Y, r22
     f88:	79 83       	std	Y+1, r23	; 0x01
     f8a:	8a 83       	std	Y+2, r24	; 0x02
     f8c:	9b 83       	std	Y+3, r25	; 0x03
    } while (fabs(*angle_in_radians) > M_PI);
     f8e:	88 81       	ld	r24, Y
     f90:	99 81       	ldd	r25, Y+1	; 0x01
     f92:	aa 81       	ldd	r26, Y+2	; 0x02
     f94:	bb 81       	ldd	r27, Y+3	; 0x03
     f96:	bc 01       	movw	r22, r24
     f98:	cd 01       	movw	r24, r26
     f9a:	9f 77       	andi	r25, 0x7F	; 127
     f9c:	2b ed       	ldi	r18, 0xDB	; 219
     f9e:	3f e0       	ldi	r19, 0x0F	; 15
     fa0:	49 e4       	ldi	r20, 0x49	; 73
     fa2:	50 e4       	ldi	r21, 0x40	; 64
     fa4:	0e 94 b9 27 	call	0x4f72	; 0x4f72 <__gesf2>
     fa8:	18 16       	cp	r1, r24
     faa:	0c f4       	brge	.+2      	; 0xfae <vFunc_Inf2pi+0x90>
     fac:	bf cf       	rjmp	.-130    	; 0xf2c <vFunc_Inf2pi+0xe>
}
     fae:	df 91       	pop	r29
     fb0:	cf 91       	pop	r28
     fb2:	ff 90       	pop	r15
     fb4:	ef 90       	pop	r14
     fb6:	df 90       	pop	r13
     fb8:	cf 90       	pop	r12
     fba:	08 95       	ret

00000fbc <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     fbc:	ef 92       	push	r14
     fbe:	ff 92       	push	r15
     fc0:	0f 93       	push	r16
     fc2:	1f 93       	push	r17
     fc4:	cf 93       	push	r28
     fc6:	df 93       	push	r29
     fc8:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     fca:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     fce:	80 91 99 03 	lds	r24, 0x0399	; 0x800399 <pxEnd>
     fd2:	90 91 9a 03 	lds	r25, 0x039A	; 0x80039a <pxEnd+0x1>
     fd6:	89 2b       	or	r24, r25
     fd8:	41 f5       	brne	.+80     	; 0x102a <pvPortMalloc+0x6e>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     fda:	eb e9       	ldi	r30, 0x9B	; 155
     fdc:	f3 e0       	ldi	r31, 0x03	; 3
     fde:	af e9       	ldi	r26, 0x9F	; 159
     fe0:	b3 e0       	ldi	r27, 0x03	; 3
     fe2:	b1 83       	std	Z+1, r27	; 0x01
     fe4:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     fe6:	13 82       	std	Z+3, r1	; 0x03
     fe8:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     fea:	eb e9       	ldi	r30, 0x9B	; 155
     fec:	f5 e1       	ldi	r31, 0x15	; 21
     fee:	f0 93 9a 03 	sts	0x039A, r31	; 0x80039a <pxEnd+0x1>
     ff2:	e0 93 99 03 	sts	0x0399, r30	; 0x800399 <pxEnd>
	pxEnd->xBlockSize = 0;
     ff6:	13 82       	std	Z+3, r1	; 0x03
     ff8:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     ffa:	11 82       	std	Z+1, r1	; 0x01
     ffc:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     ffe:	8c ef       	ldi	r24, 0xFC	; 252
    1000:	91 e1       	ldi	r25, 0x11	; 17
    1002:	13 96       	adiw	r26, 0x03	; 3
    1004:	9c 93       	st	X, r25
    1006:	8e 93       	st	-X, r24
    1008:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    100a:	ed 93       	st	X+, r30
    100c:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    100e:	90 93 96 03 	sts	0x0396, r25	; 0x800396 <xMinimumEverFreeBytesRemaining+0x1>
    1012:	80 93 95 03 	sts	0x0395, r24	; 0x800395 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1016:	90 93 98 03 	sts	0x0398, r25	; 0x800398 <xFreeBytesRemaining+0x1>
    101a:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    101e:	80 e0       	ldi	r24, 0x00	; 0
    1020:	90 e8       	ldi	r25, 0x80	; 128
    1022:	90 93 94 03 	sts	0x0394, r25	; 0x800394 <xBlockAllocatedBit+0x1>
    1026:	80 93 93 03 	sts	0x0393, r24	; 0x800393 <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    102a:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <xBlockAllocatedBit>
    102e:	90 91 94 03 	lds	r25, 0x0394	; 0x800394 <xBlockAllocatedBit+0x1>
    1032:	8c 23       	and	r24, r28
    1034:	9d 23       	and	r25, r29
    1036:	89 2b       	or	r24, r25
    1038:	09 f0       	breq	.+2      	; 0x103c <pvPortMalloc+0x80>
    103a:	b2 c0       	rjmp	.+356    	; 0x11a0 <pvPortMalloc+0x1e4>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    103c:	20 97       	sbiw	r28, 0x00	; 0
    103e:	09 f4       	brne	.+2      	; 0x1042 <pvPortMalloc+0x86>
    1040:	b2 c0       	rjmp	.+356    	; 0x11a6 <pvPortMalloc+0x1ea>
			{
				xWantedSize += xHeapStructSize;
    1042:	ae 01       	movw	r20, r28
    1044:	4c 5f       	subi	r20, 0xFC	; 252
    1046:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1048:	09 f4       	brne	.+2      	; 0x104c <pvPortMalloc+0x90>
    104a:	b0 c0       	rjmp	.+352    	; 0x11ac <pvPortMalloc+0x1f0>
    104c:	80 91 97 03 	lds	r24, 0x0397	; 0x800397 <xFreeBytesRemaining>
    1050:	90 91 98 03 	lds	r25, 0x0398	; 0x800398 <xFreeBytesRemaining+0x1>
    1054:	84 17       	cp	r24, r20
    1056:	95 07       	cpc	r25, r21
    1058:	08 f4       	brcc	.+2      	; 0x105c <pvPortMalloc+0xa0>
    105a:	ab c0       	rjmp	.+342    	; 0x11b2 <pvPortMalloc+0x1f6>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    105c:	e0 91 9b 03 	lds	r30, 0x039B	; 0x80039b <xStart>
    1060:	f0 91 9c 03 	lds	r31, 0x039C	; 0x80039c <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    1064:	ab e9       	ldi	r26, 0x9B	; 155
    1066:	b3 e0       	ldi	r27, 0x03	; 3
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1068:	02 c0       	rjmp	.+4      	; 0x106e <pvPortMalloc+0xb2>
    106a:	df 01       	movw	r26, r30
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    106c:	f9 01       	movw	r30, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    106e:	22 81       	ldd	r18, Z+2	; 0x02
    1070:	33 81       	ldd	r19, Z+3	; 0x03
    1072:	24 17       	cp	r18, r20
    1074:	35 07       	cpc	r19, r21
    1076:	28 f4       	brcc	.+10     	; 0x1082 <pvPortMalloc+0xc6>
    1078:	20 81       	ld	r18, Z
    107a:	31 81       	ldd	r19, Z+1	; 0x01
    107c:	21 15       	cp	r18, r1
    107e:	31 05       	cpc	r19, r1
    1080:	a1 f7       	brne	.-24     	; 0x106a <pvPortMalloc+0xae>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    1082:	60 91 99 03 	lds	r22, 0x0399	; 0x800399 <pxEnd>
    1086:	70 91 9a 03 	lds	r23, 0x039A	; 0x80039a <pxEnd+0x1>
    108a:	e6 17       	cp	r30, r22
    108c:	f7 07       	cpc	r31, r23
    108e:	09 f4       	brne	.+2      	; 0x1092 <pvPortMalloc+0xd6>
    1090:	93 c0       	rjmp	.+294    	; 0x11b8 <pvPortMalloc+0x1fc>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    1092:	cd 91       	ld	r28, X+
    1094:	dc 91       	ld	r29, X
    1096:	11 97       	sbiw	r26, 0x01	; 1
    1098:	7e 01       	movw	r14, r28
    109a:	84 e0       	ldi	r24, 0x04	; 4
    109c:	e8 0e       	add	r14, r24
    109e:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    10a0:	80 81       	ld	r24, Z
    10a2:	91 81       	ldd	r25, Z+1	; 0x01
    10a4:	8d 93       	st	X+, r24
    10a6:	9c 93       	st	X, r25

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    10a8:	82 81       	ldd	r24, Z+2	; 0x02
    10aa:	93 81       	ldd	r25, Z+3	; 0x03
    10ac:	84 1b       	sub	r24, r20
    10ae:	95 0b       	sbc	r25, r21
    10b0:	89 30       	cpi	r24, 0x09	; 9
    10b2:	91 05       	cpc	r25, r1
    10b4:	08 f4       	brcc	.+2      	; 0x10b8 <pvPortMalloc+0xfc>
    10b6:	52 c0       	rjmp	.+164    	; 0x115c <pvPortMalloc+0x1a0>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    10b8:	9f 01       	movw	r18, r30
    10ba:	24 0f       	add	r18, r20
    10bc:	35 1f       	adc	r19, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    10be:	d9 01       	movw	r26, r18
    10c0:	13 96       	adiw	r26, 0x03	; 3
    10c2:	9c 93       	st	X, r25
    10c4:	8e 93       	st	-X, r24
    10c6:	12 97       	sbiw	r26, 0x02	; 2
						pxBlock->xBlockSize = xWantedSize;
    10c8:	53 83       	std	Z+3, r21	; 0x03
    10ca:	42 83       	std	Z+2, r20	; 0x02
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    10cc:	ab e9       	ldi	r26, 0x9B	; 155
    10ce:	b3 e0       	ldi	r27, 0x03	; 3
    10d0:	01 c0       	rjmp	.+2      	; 0x10d4 <pvPortMalloc+0x118>
    10d2:	dc 01       	movw	r26, r24
    10d4:	8d 91       	ld	r24, X+
    10d6:	9c 91       	ld	r25, X
    10d8:	11 97       	sbiw	r26, 0x01	; 1
    10da:	82 17       	cp	r24, r18
    10dc:	93 07       	cpc	r25, r19
    10de:	c8 f3       	brcs	.-14     	; 0x10d2 <pvPortMalloc+0x116>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    10e0:	12 96       	adiw	r26, 0x02	; 2
    10e2:	4d 91       	ld	r20, X+
    10e4:	5c 91       	ld	r21, X
    10e6:	13 97       	sbiw	r26, 0x03	; 3
    10e8:	8d 01       	movw	r16, r26
    10ea:	04 0f       	add	r16, r20
    10ec:	15 1f       	adc	r17, r21
    10ee:	20 17       	cp	r18, r16
    10f0:	31 07       	cpc	r19, r17
    10f2:	51 f4       	brne	.+20     	; 0x1108 <pvPortMalloc+0x14c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    10f4:	e9 01       	movw	r28, r18
    10f6:	2a 81       	ldd	r18, Y+2	; 0x02
    10f8:	3b 81       	ldd	r19, Y+3	; 0x03
    10fa:	42 0f       	add	r20, r18
    10fc:	53 1f       	adc	r21, r19
    10fe:	13 96       	adiw	r26, 0x03	; 3
    1100:	5c 93       	st	X, r21
    1102:	4e 93       	st	-X, r20
    1104:	12 97       	sbiw	r26, 0x02	; 2
    1106:	9d 01       	movw	r18, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    1108:	e9 01       	movw	r28, r18
    110a:	4a 81       	ldd	r20, Y+2	; 0x02
    110c:	5b 81       	ldd	r21, Y+3	; 0x03
    110e:	89 01       	movw	r16, r18
    1110:	04 0f       	add	r16, r20
    1112:	15 1f       	adc	r17, r21
    1114:	80 17       	cp	r24, r16
    1116:	91 07       	cpc	r25, r17
    1118:	c9 f4       	brne	.+50     	; 0x114c <pvPortMalloc+0x190>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    111a:	60 17       	cp	r22, r16
    111c:	71 07       	cpc	r23, r17
    111e:	91 f0       	breq	.+36     	; 0x1144 <pvPortMalloc+0x188>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    1120:	e8 01       	movw	r28, r16
    1122:	8a 81       	ldd	r24, Y+2	; 0x02
    1124:	9b 81       	ldd	r25, Y+3	; 0x03
    1126:	48 0f       	add	r20, r24
    1128:	59 1f       	adc	r21, r25
    112a:	e9 01       	movw	r28, r18
    112c:	5b 83       	std	Y+3, r21	; 0x03
    112e:	4a 83       	std	Y+2, r20	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1130:	8d 91       	ld	r24, X+
    1132:	9c 91       	ld	r25, X
    1134:	11 97       	sbiw	r26, 0x01	; 1
    1136:	ec 01       	movw	r28, r24
    1138:	88 81       	ld	r24, Y
    113a:	99 81       	ldd	r25, Y+1	; 0x01
    113c:	e9 01       	movw	r28, r18
    113e:	99 83       	std	Y+1, r25	; 0x01
    1140:	88 83       	st	Y, r24
    1142:	07 c0       	rjmp	.+14     	; 0x1152 <pvPortMalloc+0x196>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    1144:	e9 01       	movw	r28, r18
    1146:	79 83       	std	Y+1, r23	; 0x01
    1148:	68 83       	st	Y, r22
    114a:	03 c0       	rjmp	.+6      	; 0x1152 <pvPortMalloc+0x196>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    114c:	e9 01       	movw	r28, r18
    114e:	99 83       	std	Y+1, r25	; 0x01
    1150:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    1152:	a2 17       	cp	r26, r18
    1154:	b3 07       	cpc	r27, r19
    1156:	11 f0       	breq	.+4      	; 0x115c <pvPortMalloc+0x1a0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    1158:	2d 93       	st	X+, r18
    115a:	3c 93       	st	X, r19
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    115c:	22 81       	ldd	r18, Z+2	; 0x02
    115e:	33 81       	ldd	r19, Z+3	; 0x03
    1160:	80 91 97 03 	lds	r24, 0x0397	; 0x800397 <xFreeBytesRemaining>
    1164:	90 91 98 03 	lds	r25, 0x0398	; 0x800398 <xFreeBytesRemaining+0x1>
    1168:	82 1b       	sub	r24, r18
    116a:	93 0b       	sbc	r25, r19
    116c:	90 93 98 03 	sts	0x0398, r25	; 0x800398 <xFreeBytesRemaining+0x1>
    1170:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    1174:	40 91 95 03 	lds	r20, 0x0395	; 0x800395 <xMinimumEverFreeBytesRemaining>
    1178:	50 91 96 03 	lds	r21, 0x0396	; 0x800396 <xMinimumEverFreeBytesRemaining+0x1>
    117c:	84 17       	cp	r24, r20
    117e:	95 07       	cpc	r25, r21
    1180:	20 f4       	brcc	.+8      	; 0x118a <pvPortMalloc+0x1ce>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1182:	90 93 96 03 	sts	0x0396, r25	; 0x800396 <xMinimumEverFreeBytesRemaining+0x1>
    1186:	80 93 95 03 	sts	0x0395, r24	; 0x800395 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    118a:	80 91 93 03 	lds	r24, 0x0393	; 0x800393 <xBlockAllocatedBit>
    118e:	90 91 94 03 	lds	r25, 0x0394	; 0x800394 <xBlockAllocatedBit+0x1>
    1192:	28 2b       	or	r18, r24
    1194:	39 2b       	or	r19, r25
    1196:	33 83       	std	Z+3, r19	; 0x03
    1198:	22 83       	std	Z+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    119a:	11 82       	std	Z+1, r1	; 0x01
    119c:	10 82       	st	Z, r1
    119e:	0e c0       	rjmp	.+28     	; 0x11bc <pvPortMalloc+0x200>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    11a0:	e1 2c       	mov	r14, r1
    11a2:	f1 2c       	mov	r15, r1
    11a4:	0b c0       	rjmp	.+22     	; 0x11bc <pvPortMalloc+0x200>
    11a6:	e1 2c       	mov	r14, r1
    11a8:	f1 2c       	mov	r15, r1
    11aa:	08 c0       	rjmp	.+16     	; 0x11bc <pvPortMalloc+0x200>
    11ac:	e1 2c       	mov	r14, r1
    11ae:	f1 2c       	mov	r15, r1
    11b0:	05 c0       	rjmp	.+10     	; 0x11bc <pvPortMalloc+0x200>
    11b2:	e1 2c       	mov	r14, r1
    11b4:	f1 2c       	mov	r15, r1
    11b6:	02 c0       	rjmp	.+4      	; 0x11bc <pvPortMalloc+0x200>
    11b8:	e1 2c       	mov	r14, r1
    11ba:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    11bc:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    11c0:	c7 01       	movw	r24, r14
    11c2:	df 91       	pop	r29
    11c4:	cf 91       	pop	r28
    11c6:	1f 91       	pop	r17
    11c8:	0f 91       	pop	r16
    11ca:	ff 90       	pop	r15
    11cc:	ef 90       	pop	r14
    11ce:	08 95       	ret

000011d0 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    11d0:	cf 93       	push	r28
    11d2:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    11d4:	00 97       	sbiw	r24, 0x00	; 0
    11d6:	09 f4       	brne	.+2      	; 0x11da <vPortFree+0xa>
    11d8:	68 c0       	rjmp	.+208    	; 0x12aa <vPortFree+0xda>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    11da:	fc 01       	movw	r30, r24
    11dc:	34 97       	sbiw	r30, 0x04	; 4
    11de:	22 81       	ldd	r18, Z+2	; 0x02
    11e0:	33 81       	ldd	r19, Z+3	; 0x03
    11e2:	40 91 93 03 	lds	r20, 0x0393	; 0x800393 <xBlockAllocatedBit>
    11e6:	50 91 94 03 	lds	r21, 0x0394	; 0x800394 <xBlockAllocatedBit+0x1>
    11ea:	b9 01       	movw	r22, r18
    11ec:	64 23       	and	r22, r20
    11ee:	75 23       	and	r23, r21
    11f0:	67 2b       	or	r22, r23
    11f2:	09 f4       	brne	.+2      	; 0x11f6 <vPortFree+0x26>
    11f4:	5a c0       	rjmp	.+180    	; 0x12aa <vPortFree+0xda>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    11f6:	60 81       	ld	r22, Z
    11f8:	71 81       	ldd	r23, Z+1	; 0x01
    11fa:	67 2b       	or	r22, r23
    11fc:	09 f0       	breq	.+2      	; 0x1200 <vPortFree+0x30>
    11fe:	55 c0       	rjmp	.+170    	; 0x12aa <vPortFree+0xda>

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    1200:	ef 01       	movw	r28, r30
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    1202:	40 95       	com	r20
    1204:	50 95       	com	r21
    1206:	24 23       	and	r18, r20
    1208:	35 23       	and	r19, r21
    120a:	33 83       	std	Z+3, r19	; 0x03
    120c:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    120e:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    1212:	4a 81       	ldd	r20, Y+2	; 0x02
    1214:	5b 81       	ldd	r21, Y+3	; 0x03
    1216:	80 91 97 03 	lds	r24, 0x0397	; 0x800397 <xFreeBytesRemaining>
    121a:	90 91 98 03 	lds	r25, 0x0398	; 0x800398 <xFreeBytesRemaining+0x1>
    121e:	84 0f       	add	r24, r20
    1220:	95 1f       	adc	r25, r21
    1222:	90 93 98 03 	sts	0x0398, r25	; 0x800398 <xFreeBytesRemaining+0x1>
    1226:	80 93 97 03 	sts	0x0397, r24	; 0x800397 <xFreeBytesRemaining>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    122a:	eb e9       	ldi	r30, 0x9B	; 155
    122c:	f3 e0       	ldi	r31, 0x03	; 3
    122e:	01 c0       	rjmp	.+2      	; 0x1232 <vPortFree+0x62>
    1230:	fc 01       	movw	r30, r24
    1232:	80 81       	ld	r24, Z
    1234:	91 81       	ldd	r25, Z+1	; 0x01
    1236:	8c 17       	cp	r24, r28
    1238:	9d 07       	cpc	r25, r29
    123a:	d0 f3       	brcs	.-12     	; 0x1230 <vPortFree+0x60>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    123c:	22 81       	ldd	r18, Z+2	; 0x02
    123e:	33 81       	ldd	r19, Z+3	; 0x03
    1240:	bf 01       	movw	r22, r30
    1242:	62 0f       	add	r22, r18
    1244:	73 1f       	adc	r23, r19
    1246:	c6 17       	cp	r28, r22
    1248:	d7 07       	cpc	r29, r23
    124a:	29 f4       	brne	.+10     	; 0x1256 <vPortFree+0x86>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    124c:	24 0f       	add	r18, r20
    124e:	35 1f       	adc	r19, r21
    1250:	33 83       	std	Z+3, r19	; 0x03
    1252:	22 83       	std	Z+2, r18	; 0x02
    1254:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    1256:	2a 81       	ldd	r18, Y+2	; 0x02
    1258:	3b 81       	ldd	r19, Y+3	; 0x03
    125a:	de 01       	movw	r26, r28
    125c:	a2 0f       	add	r26, r18
    125e:	b3 1f       	adc	r27, r19
    1260:	8a 17       	cp	r24, r26
    1262:	9b 07       	cpc	r25, r27
    1264:	c9 f4       	brne	.+50     	; 0x1298 <vPortFree+0xc8>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    1266:	80 91 99 03 	lds	r24, 0x0399	; 0x800399 <pxEnd>
    126a:	90 91 9a 03 	lds	r25, 0x039A	; 0x80039a <pxEnd+0x1>
    126e:	a8 17       	cp	r26, r24
    1270:	b9 07       	cpc	r27, r25
    1272:	79 f0       	breq	.+30     	; 0x1292 <vPortFree+0xc2>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    1274:	12 96       	adiw	r26, 0x02	; 2
    1276:	8d 91       	ld	r24, X+
    1278:	9c 91       	ld	r25, X
    127a:	13 97       	sbiw	r26, 0x03	; 3
    127c:	28 0f       	add	r18, r24
    127e:	39 1f       	adc	r19, r25
    1280:	3b 83       	std	Y+3, r19	; 0x03
    1282:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1284:	a0 81       	ld	r26, Z
    1286:	b1 81       	ldd	r27, Z+1	; 0x01
    1288:	8d 91       	ld	r24, X+
    128a:	9c 91       	ld	r25, X
    128c:	99 83       	std	Y+1, r25	; 0x01
    128e:	88 83       	st	Y, r24
    1290:	05 c0       	rjmp	.+10     	; 0x129c <vPortFree+0xcc>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    1292:	b9 83       	std	Y+1, r27	; 0x01
    1294:	a8 83       	st	Y, r26
    1296:	02 c0       	rjmp	.+4      	; 0x129c <vPortFree+0xcc>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    1298:	99 83       	std	Y+1, r25	; 0x01
    129a:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    129c:	ec 17       	cp	r30, r28
    129e:	fd 07       	cpc	r31, r29
    12a0:	11 f0       	breq	.+4      	; 0x12a6 <vPortFree+0xd6>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    12a2:	d1 83       	std	Z+1, r29	; 0x01
    12a4:	c0 83       	st	Z, r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
    12a6:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    12aa:	df 91       	pop	r29
    12ac:	cf 91       	pop	r28
    12ae:	08 95       	ret

000012b0 <sIMU_readRegister>:
    int16_t tempBuffer = (myBuffer[1] << 8);
    int16_t output = (int16_t)myBuffer[0] | tempBuffer;
    
    *outputPointer = output;
    return returnError;
}
    12b0:	cf 93       	push	r28
    12b2:	df 93       	push	r29
    12b4:	ec 01       	movw	r28, r24
    12b6:	28 98       	cbi	0x05, 0	; 5
    12b8:	86 2f       	mov	r24, r22
    12ba:	80 68       	ori	r24, 0x80	; 128
    12bc:	0e 94 57 19 	call	0x32ae	; 0x32ae <ui8SPI_MasterTransmit>
    12c0:	80 e0       	ldi	r24, 0x00	; 0
    12c2:	0e 94 57 19 	call	0x32ae	; 0x32ae <ui8SPI_MasterTransmit>
    12c6:	28 9a       	sbi	0x05, 0	; 5
    12c8:	8f 3f       	cpi	r24, 0xFF	; 255
    12ca:	11 f4       	brne	.+4      	; 0x12d0 <sIMU_readRegister+0x20>
    12cc:	95 e0       	ldi	r25, 0x05	; 5
    12ce:	01 c0       	rjmp	.+2      	; 0x12d2 <sIMU_readRegister+0x22>
    12d0:	90 e0       	ldi	r25, 0x00	; 0
    12d2:	88 83       	st	Y, r24
    12d4:	89 2f       	mov	r24, r25
    12d6:	df 91       	pop	r29
    12d8:	cf 91       	pop	r28
    12da:	08 95       	ret

000012dc <sIMU_Init>:
    12dc:	cf 93       	push	r28
    12de:	df 93       	push	r29
    12e0:	1f 92       	push	r1
    12e2:	1f 92       	push	r1
    12e4:	cd b7       	in	r28, 0x3d	; 61
    12e6:	de b7       	in	r29, 0x3e	; 62
    12e8:	eb ee       	ldi	r30, 0xEB	; 235
    12ea:	f6 e1       	ldi	r31, 0x16	; 22
    12ec:	81 e0       	ldi	r24, 0x01	; 1
    12ee:	80 83       	st	Z, r24
    12f0:	24 ef       	ldi	r18, 0xF4	; 244
    12f2:	31 e0       	ldi	r19, 0x01	; 1
    12f4:	32 83       	std	Z+2, r19	; 0x02
    12f6:	21 83       	std	Z+1, r18	; 0x01
    12f8:	22 e8       	ldi	r18, 0x82	; 130
    12fa:	36 e0       	ldi	r19, 0x06	; 6
    12fc:	34 83       	std	Z+4, r19	; 0x04
    12fe:	23 83       	std	Z+3, r18	; 0x03
    1300:	20 e9       	ldi	r18, 0x90	; 144
    1302:	31 e0       	ldi	r19, 0x01	; 1
    1304:	36 83       	std	Z+6, r19	; 0x06
    1306:	25 83       	std	Z+5, r18	; 0x05
    1308:	17 82       	std	Z+7, r1	; 0x07
    130a:	10 86       	std	Z+8, r1	; 0x08
    130c:	81 87       	std	Z+9, r24	; 0x09
    130e:	82 87       	std	Z+10, r24	; 0x0a
    1310:	20 e1       	ldi	r18, 0x10	; 16
    1312:	30 e0       	ldi	r19, 0x00	; 0
    1314:	34 87       	std	Z+12, r19	; 0x0c
    1316:	23 87       	std	Z+11, r18	; 0x0b
    1318:	2d e0       	ldi	r18, 0x0D	; 13
    131a:	30 e0       	ldi	r19, 0x00	; 0
    131c:	36 87       	std	Z+14, r19	; 0x0e
    131e:	25 87       	std	Z+13, r18	; 0x0d
    1320:	22 e3       	ldi	r18, 0x32	; 50
    1322:	30 e0       	ldi	r19, 0x00	; 0
    1324:	30 8b       	std	Z+16, r19	; 0x10
    1326:	27 87       	std	Z+15, r18	; 0x0f
    1328:	11 8a       	std	Z+17, r1	; 0x11
    132a:	12 8a       	std	Z+18, r1	; 0x12
    132c:	83 8b       	std	Z+19, r24	; 0x13
    132e:	84 8b       	std	Z+20, r24	; 0x14
    1330:	88 eb       	ldi	r24, 0xB8	; 184
    1332:	9b e0       	ldi	r25, 0x0B	; 11
    1334:	96 8b       	std	Z+22, r25	; 0x16
    1336:	85 8b       	std	Z+21, r24	; 0x15
    1338:	8a e0       	ldi	r24, 0x0A	; 10
    133a:	90 e0       	ldi	r25, 0x00	; 0
    133c:	90 8f       	std	Z+24, r25	; 0x18
    133e:	87 8b       	std	Z+23, r24	; 0x17
    1340:	11 8e       	std	Z+25, r1	; 0x19
    1342:	10 92 06 17 	sts	0x1706, r1	; 0x801706 <allOnesCounter+0x1>
    1346:	10 92 05 17 	sts	0x1705, r1	; 0x801705 <allOnesCounter>
    134a:	10 92 08 17 	sts	0x1708, r1	; 0x801708 <nonSuccessCounter+0x1>
    134e:	10 92 07 17 	sts	0x1707, r1	; 0x801707 <nonSuccessCounter>
    1352:	0e 94 49 19 	call	0x3292	; 0x3292 <vSPI_MasterInit>
    1356:	20 9a       	sbi	0x04, 0	; 4
    1358:	28 9a       	sbi	0x05, 0	; 5
    135a:	19 82       	std	Y+1, r1	; 0x01
    135c:	20 e1       	ldi	r18, 0x10	; 16
    135e:	37 e2       	ldi	r19, 0x27	; 39
    1360:	89 81       	ldd	r24, Y+1	; 0x01
    1362:	8f 5f       	subi	r24, 0xFF	; 255
    1364:	89 83       	std	Y+1, r24	; 0x01
    1366:	21 50       	subi	r18, 0x01	; 1
    1368:	31 09       	sbc	r19, r1
    136a:	d1 f7       	brne	.-12     	; 0x1360 <sIMU_Init+0x84>
    136c:	6f e0       	ldi	r22, 0x0F	; 15
    136e:	ce 01       	movw	r24, r28
    1370:	02 96       	adiw	r24, 0x02	; 2
    1372:	9e df       	rcall	.-196    	; 0x12b0 <sIMU_readRegister>
    1374:	8a 81       	ldd	r24, Y+2	; 0x02
    1376:	89 36       	cpi	r24, 0x69	; 105
    1378:	c9 f7       	brne	.-14     	; 0x136c <sIMU_Init+0x90>
    137a:	80 e0       	ldi	r24, 0x00	; 0
    137c:	0f 90       	pop	r0
    137e:	0f 90       	pop	r0
    1380:	df 91       	pop	r29
    1382:	cf 91       	pop	r28
    1384:	08 95       	ret

00001386 <sIMU_writeRegister>:
//  Parameters:
//    offset -- register to write
//    dataToWrite -- 8 bit data to write to register
//
//****************************************************************************//
status_t sIMU_writeRegister(uint8_t offset, uint8_t dataToWrite ){
    1386:	cf 93       	push	r28
    1388:	c6 2f       	mov	r28, r22
    status_t returnError = IMU_SUCCESS;

    // take the chip select low to select the device:
    PORTB &= ~(1<<IMU_SS);
    138a:	28 98       	cbi	0x05, 0	; 5
    // send the device the register you want to read:
    ui8SPI_MasterTransmit(offset);
    138c:	0e 94 57 19 	call	0x32ae	; 0x32ae <ui8SPI_MasterTransmit>
    // send a value of 0 to read the first byte returned:
    ui8SPI_MasterTransmit(dataToWrite);
    1390:	8c 2f       	mov	r24, r28
    1392:	0e 94 57 19 	call	0x32ae	; 0x32ae <ui8SPI_MasterTransmit>
    // decrement the number of bytes left to read:
    // take the chip select high to de-select:
    PORTB |= (1<<IMU_SS);
    1396:	28 9a       	sbi	0x05, 0	; 5
    return returnError;
}
    1398:	80 e0       	ldi	r24, 0x00	; 0
    139a:	cf 91       	pop	r28
    139c:	08 95       	ret

0000139e <sIMU_begin>:
//  This uses the stored SensorSettings to start the IMU
//  Use statements such as 
//  "myIMU.settings.accelEnabled = 1;" to configure before calling .begin();
//
//****************************************************************************//
status_t sIMU_begin(){
    139e:	1f 93       	push	r17
    13a0:	cf 93       	push	r28
    13a2:	df 93       	push	r29
    13a4:	1f 92       	push	r1
    13a6:	1f 92       	push	r1
    13a8:	cd b7       	in	r28, 0x3d	; 61
    13aa:	de b7       	in	r29, 0x3e	; 62
    //Check the settings structure values to determine how to setup the device
    uint8_t dataToWrite = 0;  //Temporary variable
    13ac:	19 82       	std	Y+1, r1	; 0x01

    //Initialize the IMU and the SPI driver
    status_t returnError = sIMU_Init();
    13ae:	96 df       	rcall	.-212    	; 0x12dc <sIMU_Init>
    13b0:	18 2f       	mov	r17, r24

    //Setup the accelerometer******************************
    dataToWrite = 0; //Start Fresh!
    13b2:	19 82       	std	Y+1, r1	; 0x01
    if ( settings.accelEnabled == 1) {
    13b4:	80 91 f4 16 	lds	r24, 0x16F4	; 0x8016f4 <settings+0x9>
    13b8:	81 30       	cpi	r24, 0x01	; 1
    13ba:	09 f0       	breq	.+2      	; 0x13be <sIMU_begin+0x20>
    13bc:	83 c0       	rjmp	.+262    	; 0x14c4 <sIMU_begin+0x126>
        //Build config reg
        //First patch in filter bandwidth
        switch (settings.accelBandWidth) {
    13be:	80 91 fa 16 	lds	r24, 0x16FA	; 0x8016fa <settings+0xf>
    13c2:	90 91 fb 16 	lds	r25, 0x16FB	; 0x8016fb <settings+0x10>
    13c6:	84 36       	cpi	r24, 0x64	; 100
    13c8:	91 05       	cpc	r25, r1
    13ca:	41 f0       	breq	.+16     	; 0x13dc <sIMU_begin+0x3e>
    13cc:	88 3c       	cpi	r24, 0xC8	; 200
    13ce:	91 05       	cpc	r25, r1
    13d0:	41 f0       	breq	.+16     	; 0x13e2 <sIMU_begin+0x44>
    13d2:	c2 97       	sbiw	r24, 0x32	; 50
    13d4:	41 f4       	brne	.+16     	; 0x13e6 <sIMU_begin+0x48>
            case 50:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_50Hz;
    13d6:	83 e0       	ldi	r24, 0x03	; 3
    13d8:	89 83       	std	Y+1, r24	; 0x01
            break;
    13da:	05 c0       	rjmp	.+10     	; 0x13e6 <sIMU_begin+0x48>
            case 100:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_100Hz;
    13dc:	82 e0       	ldi	r24, 0x02	; 2
    13de:	89 83       	std	Y+1, r24	; 0x01
            break;
    13e0:	02 c0       	rjmp	.+4      	; 0x13e6 <sIMU_begin+0x48>
            case 200:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_200Hz;
    13e2:	81 e0       	ldi	r24, 0x01	; 1
    13e4:	89 83       	std	Y+1, r24	; 0x01
            case 400:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_400Hz;
            break;
        }
        //Next, patch in full scale
        switch (settings.accelRange) {
    13e6:	80 91 f6 16 	lds	r24, 0x16F6	; 0x8016f6 <settings+0xb>
    13ea:	90 91 f7 16 	lds	r25, 0x16F7	; 0x8016f7 <settings+0xc>
    13ee:	84 30       	cpi	r24, 0x04	; 4
    13f0:	91 05       	cpc	r25, r1
    13f2:	31 f0       	breq	.+12     	; 0x1400 <sIMU_begin+0x62>
    13f4:	88 30       	cpi	r24, 0x08	; 8
    13f6:	91 05       	cpc	r25, r1
    13f8:	39 f0       	breq	.+14     	; 0x1408 <sIMU_begin+0x6a>
    13fa:	02 97       	sbiw	r24, 0x02	; 2
    13fc:	49 f4       	brne	.+18     	; 0x1410 <sIMU_begin+0x72>
    13fe:	0b c0       	rjmp	.+22     	; 0x1416 <sIMU_begin+0x78>
            case 2:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_2g;
            break;
            case 4:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_4g;
    1400:	89 81       	ldd	r24, Y+1	; 0x01
    1402:	88 60       	ori	r24, 0x08	; 8
    1404:	89 83       	std	Y+1, r24	; 0x01
            break;
    1406:	07 c0       	rjmp	.+14     	; 0x1416 <sIMU_begin+0x78>
            case 8:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_8g;
    1408:	89 81       	ldd	r24, Y+1	; 0x01
    140a:	8c 60       	ori	r24, 0x0C	; 12
    140c:	89 83       	std	Y+1, r24	; 0x01
            break;
    140e:	03 c0       	rjmp	.+6      	; 0x1416 <sIMU_begin+0x78>
            default:  //set default case to 16(max)
            case 16:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_16g;
    1410:	89 81       	ldd	r24, Y+1	; 0x01
    1412:	84 60       	ori	r24, 0x04	; 4
    1414:	89 83       	std	Y+1, r24	; 0x01
            break;
        }
        //Lastly, patch in accelerometer ODR
        switch (settings.accelSampleRate) {
    1416:	80 91 f8 16 	lds	r24, 0x16F8	; 0x8016f8 <settings+0xd>
    141a:	90 91 f9 16 	lds	r25, 0x16F9	; 0x8016f9 <settings+0xe>
    141e:	80 3a       	cpi	r24, 0xA0	; 160
    1420:	21 e0       	ldi	r18, 0x01	; 1
    1422:	92 07       	cpc	r25, r18
    1424:	c1 f1       	breq	.+112    	; 0x1496 <sIMU_begin+0xf8>
    1426:	70 f4       	brcc	.+28     	; 0x1444 <sIMU_begin+0xa6>
    1428:	8a 31       	cpi	r24, 0x1A	; 26
    142a:	91 05       	cpc	r25, r1
    142c:	21 f1       	breq	.+72     	; 0x1476 <sIMU_begin+0xd8>
    142e:	18 f4       	brcc	.+6      	; 0x1436 <sIMU_begin+0x98>
    1430:	0d 97       	sbiw	r24, 0x0d	; 13
    1432:	e9 f0       	breq	.+58     	; 0x146e <sIMU_begin+0xd0>
    1434:	28 c0       	rjmp	.+80     	; 0x1486 <sIMU_begin+0xe8>
    1436:	84 33       	cpi	r24, 0x34	; 52
    1438:	91 05       	cpc	r25, r1
    143a:	09 f1       	breq	.+66     	; 0x147e <sIMU_begin+0xe0>
    143c:	80 3d       	cpi	r24, 0xD0	; 208
    143e:	91 05       	cpc	r25, r1
    1440:	31 f1       	breq	.+76     	; 0x148e <sIMU_begin+0xf0>
    1442:	21 c0       	rjmp	.+66     	; 0x1486 <sIMU_begin+0xe8>
    1444:	82 30       	cpi	r24, 0x02	; 2
    1446:	2d e0       	ldi	r18, 0x0D	; 13
    1448:	92 07       	cpc	r25, r18
    144a:	89 f1       	breq	.+98     	; 0x14ae <sIMU_begin+0x110>
    144c:	40 f4       	brcc	.+16     	; 0x145e <sIMU_begin+0xc0>
    144e:	81 34       	cpi	r24, 0x41	; 65
    1450:	23 e0       	ldi	r18, 0x03	; 3
    1452:	92 07       	cpc	r25, r18
    1454:	21 f1       	breq	.+72     	; 0x149e <sIMU_begin+0x100>
    1456:	8c 37       	cpi	r24, 0x7C	; 124
    1458:	96 40       	sbci	r25, 0x06	; 6
    145a:	29 f1       	breq	.+74     	; 0x14a6 <sIMU_begin+0x108>
    145c:	14 c0       	rjmp	.+40     	; 0x1486 <sIMU_begin+0xe8>
    145e:	84 30       	cpi	r24, 0x04	; 4
    1460:	2a e1       	ldi	r18, 0x1A	; 26
    1462:	92 07       	cpc	r25, r18
    1464:	41 f1       	breq	.+80     	; 0x14b6 <sIMU_begin+0x118>
    1466:	82 31       	cpi	r24, 0x12	; 18
    1468:	94 43       	sbci	r25, 0x34	; 52
    146a:	49 f1       	breq	.+82     	; 0x14be <sIMU_begin+0x120>
    146c:	0c c0       	rjmp	.+24     	; 0x1486 <sIMU_begin+0xe8>
            case 13:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_13Hz;
    146e:	89 81       	ldd	r24, Y+1	; 0x01
    1470:	80 61       	ori	r24, 0x10	; 16
    1472:	89 83       	std	Y+1, r24	; 0x01
            break;
    1474:	27 c0       	rjmp	.+78     	; 0x14c4 <sIMU_begin+0x126>
            case 26:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_26Hz;
    1476:	89 81       	ldd	r24, Y+1	; 0x01
    1478:	80 62       	ori	r24, 0x20	; 32
    147a:	89 83       	std	Y+1, r24	; 0x01
            break;
    147c:	23 c0       	rjmp	.+70     	; 0x14c4 <sIMU_begin+0x126>
            case 52:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_52Hz;
    147e:	89 81       	ldd	r24, Y+1	; 0x01
    1480:	80 63       	ori	r24, 0x30	; 48
    1482:	89 83       	std	Y+1, r24	; 0x01
            break;
    1484:	1f c0       	rjmp	.+62     	; 0x14c4 <sIMU_begin+0x126>
            default:  //Set default to 104
            case 104:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_104Hz;
    1486:	89 81       	ldd	r24, Y+1	; 0x01
    1488:	80 64       	ori	r24, 0x40	; 64
    148a:	89 83       	std	Y+1, r24	; 0x01
            break;
    148c:	1b c0       	rjmp	.+54     	; 0x14c4 <sIMU_begin+0x126>
            case 208:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_208Hz;
    148e:	89 81       	ldd	r24, Y+1	; 0x01
    1490:	80 65       	ori	r24, 0x50	; 80
    1492:	89 83       	std	Y+1, r24	; 0x01
            break;
    1494:	17 c0       	rjmp	.+46     	; 0x14c4 <sIMU_begin+0x126>
            case 416:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_416Hz;
    1496:	89 81       	ldd	r24, Y+1	; 0x01
    1498:	80 66       	ori	r24, 0x60	; 96
    149a:	89 83       	std	Y+1, r24	; 0x01
            break;
    149c:	13 c0       	rjmp	.+38     	; 0x14c4 <sIMU_begin+0x126>
            case 833:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_833Hz;
    149e:	89 81       	ldd	r24, Y+1	; 0x01
    14a0:	80 67       	ori	r24, 0x70	; 112
    14a2:	89 83       	std	Y+1, r24	; 0x01
            break;
    14a4:	0f c0       	rjmp	.+30     	; 0x14c4 <sIMU_begin+0x126>
            case 1660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_1660Hz;
    14a6:	89 81       	ldd	r24, Y+1	; 0x01
    14a8:	80 68       	ori	r24, 0x80	; 128
    14aa:	89 83       	std	Y+1, r24	; 0x01
            break;
    14ac:	0b c0       	rjmp	.+22     	; 0x14c4 <sIMU_begin+0x126>
            case 3330:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_3330Hz;
    14ae:	89 81       	ldd	r24, Y+1	; 0x01
    14b0:	80 69       	ori	r24, 0x90	; 144
    14b2:	89 83       	std	Y+1, r24	; 0x01
            break;
    14b4:	07 c0       	rjmp	.+14     	; 0x14c4 <sIMU_begin+0x126>
            case 6660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_6660Hz;
    14b6:	89 81       	ldd	r24, Y+1	; 0x01
    14b8:	80 6a       	ori	r24, 0xA0	; 160
    14ba:	89 83       	std	Y+1, r24	; 0x01
            break;
    14bc:	03 c0       	rjmp	.+6      	; 0x14c4 <sIMU_begin+0x126>
            case 13330:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_13330Hz;
    14be:	89 81       	ldd	r24, Y+1	; 0x01
    14c0:	80 6b       	ori	r24, 0xB0	; 176
    14c2:	89 83       	std	Y+1, r24	; 0x01
    {
        //dataToWrite already = 0 (powerdown);
    }

    //Now, write the patched together data
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL1_XL, dataToWrite);
    14c4:	69 81       	ldd	r22, Y+1	; 0x01
    14c6:	80 e1       	ldi	r24, 0x10	; 16
    14c8:	5e df       	rcall	.-324    	; 0x1386 <sIMU_writeRegister>

    //Set the ODR bit
    sIMU_readRegister(&dataToWrite, LSM6DS3_ACC_GYRO_CTRL4_C);
    14ca:	63 e1       	ldi	r22, 0x13	; 19
    14cc:	ce 01       	movw	r24, r28
    14ce:	01 96       	adiw	r24, 0x01	; 1
    14d0:	ef de       	rcall	.-546    	; 0x12b0 <sIMU_readRegister>
    dataToWrite &= ~((uint8_t)LSM6DS3_ACC_GYRO_BW_SCAL_ODR_ENABLED);
    14d2:	89 81       	ldd	r24, Y+1	; 0x01
    14d4:	8f 77       	andi	r24, 0x7F	; 127
    14d6:	89 83       	std	Y+1, r24	; 0x01
    if ( settings.accelODROff == 1) {
    14d8:	90 91 f5 16 	lds	r25, 0x16F5	; 0x8016f5 <settings+0xa>
    14dc:	91 30       	cpi	r25, 0x01	; 1
    14de:	11 f4       	brne	.+4      	; 0x14e4 <sIMU_begin+0x146>
        dataToWrite |= LSM6DS3_ACC_GYRO_BW_SCAL_ODR_ENABLED;
    14e0:	80 68       	ori	r24, 0x80	; 128
    }
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL4_C, dataToWrite);
    14e2:	89 83       	std	Y+1, r24	; 0x01
    14e4:	69 81       	ldd	r22, Y+1	; 0x01
    14e6:	83 e1       	ldi	r24, 0x13	; 19
    14e8:	4e df       	rcall	.-356    	; 0x1386 <sIMU_writeRegister>

    //Setup the gyroscope**********************************************
    dataToWrite = 0; //Start Fresh!
    14ea:	19 82       	std	Y+1, r1	; 0x01
    if ( settings.gyroEnabled == 1) {
    14ec:	80 91 eb 16 	lds	r24, 0x16EB	; 0x8016eb <settings>
    14f0:	81 30       	cpi	r24, 0x01	; 1
    14f2:	09 f0       	breq	.+2      	; 0x14f6 <sIMU_begin+0x158>
    14f4:	5b c0       	rjmp	.+182    	; 0x15ac <sIMU_begin+0x20e>
        //Build config reg
        //First, patch in full scale
        switch (settings.gyroRange) {
    14f6:	80 91 ec 16 	lds	r24, 0x16EC	; 0x8016ec <settings+0x1>
    14fa:	90 91 ed 16 	lds	r25, 0x16ED	; 0x8016ed <settings+0x2>
    14fe:	85 3f       	cpi	r24, 0xF5	; 245
    1500:	91 05       	cpc	r25, r1
    1502:	c1 f0       	breq	.+48     	; 0x1534 <sIMU_begin+0x196>
    1504:	20 f4       	brcc	.+8      	; 0x150e <sIMU_begin+0x170>
    1506:	8d 37       	cpi	r24, 0x7D	; 125
    1508:	91 05       	cpc	r25, r1
    150a:	49 f0       	breq	.+18     	; 0x151e <sIMU_begin+0x180>
    150c:	11 c0       	rjmp	.+34     	; 0x1530 <sIMU_begin+0x192>
    150e:	84 3f       	cpi	r24, 0xF4	; 244
    1510:	21 e0       	ldi	r18, 0x01	; 1
    1512:	92 07       	cpc	r25, r18
    1514:	39 f0       	breq	.+14     	; 0x1524 <sIMU_begin+0x186>
    1516:	88 3e       	cpi	r24, 0xE8	; 232
    1518:	93 40       	sbci	r25, 0x03	; 3
    151a:	39 f0       	breq	.+14     	; 0x152a <sIMU_begin+0x18c>
    151c:	09 c0       	rjmp	.+18     	; 0x1530 <sIMU_begin+0x192>
            case 125:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_125_ENABLED;
    151e:	82 e0       	ldi	r24, 0x02	; 2
    1520:	89 83       	std	Y+1, r24	; 0x01
            break;
    1522:	08 c0       	rjmp	.+16     	; 0x1534 <sIMU_begin+0x196>
            case 245:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_245dps;
            break;
            case 500:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_500dps;
    1524:	84 e0       	ldi	r24, 0x04	; 4
    1526:	89 83       	std	Y+1, r24	; 0x01
            break;
    1528:	05 c0       	rjmp	.+10     	; 0x1534 <sIMU_begin+0x196>
            case 1000:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_1000dps;
    152a:	88 e0       	ldi	r24, 0x08	; 8
    152c:	89 83       	std	Y+1, r24	; 0x01
            break;
    152e:	02 c0       	rjmp	.+4      	; 0x1534 <sIMU_begin+0x196>
            default:  //Default to full 2000DPS range
            case 2000:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_2000dps;
    1530:	8c e0       	ldi	r24, 0x0C	; 12
    1532:	89 83       	std	Y+1, r24	; 0x01
            break;
        }
        //Lastly, patch in gyro ODR
        switch (settings.gyroSampleRate) {
    1534:	80 91 ee 16 	lds	r24, 0x16EE	; 0x8016ee <settings+0x3>
    1538:	90 91 ef 16 	lds	r25, 0x16EF	; 0x8016ef <settings+0x4>
    153c:	80 3d       	cpi	r24, 0xD0	; 208
    153e:	91 05       	cpc	r25, r1
    1540:	31 f1       	breq	.+76     	; 0x158e <sIMU_begin+0x1f0>
    1542:	48 f4       	brcc	.+18     	; 0x1556 <sIMU_begin+0x1b8>
    1544:	8a 31       	cpi	r24, 0x1A	; 26
    1546:	91 05       	cpc	r25, r1
    1548:	b1 f0       	breq	.+44     	; 0x1576 <sIMU_begin+0x1d8>
    154a:	84 33       	cpi	r24, 0x34	; 52
    154c:	91 05       	cpc	r25, r1
    154e:	b9 f0       	breq	.+46     	; 0x157e <sIMU_begin+0x1e0>
    1550:	0d 97       	sbiw	r24, 0x0d	; 13
    1552:	c9 f4       	brne	.+50     	; 0x1586 <sIMU_begin+0x1e8>
    1554:	0c c0       	rjmp	.+24     	; 0x156e <sIMU_begin+0x1d0>
    1556:	81 34       	cpi	r24, 0x41	; 65
    1558:	23 e0       	ldi	r18, 0x03	; 3
    155a:	92 07       	cpc	r25, r18
    155c:	01 f1       	breq	.+64     	; 0x159e <sIMU_begin+0x200>
    155e:	8c 37       	cpi	r24, 0x7C	; 124
    1560:	26 e0       	ldi	r18, 0x06	; 6
    1562:	92 07       	cpc	r25, r18
    1564:	01 f1       	breq	.+64     	; 0x15a6 <sIMU_begin+0x208>
    1566:	80 3a       	cpi	r24, 0xA0	; 160
    1568:	91 40       	sbci	r25, 0x01	; 1
    156a:	69 f4       	brne	.+26     	; 0x1586 <sIMU_begin+0x1e8>
    156c:	14 c0       	rjmp	.+40     	; 0x1596 <sIMU_begin+0x1f8>
            case 13:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_13Hz;
    156e:	89 81       	ldd	r24, Y+1	; 0x01
    1570:	80 61       	ori	r24, 0x10	; 16
    1572:	89 83       	std	Y+1, r24	; 0x01
            break;
    1574:	1b c0       	rjmp	.+54     	; 0x15ac <sIMU_begin+0x20e>
            case 26:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_26Hz;
    1576:	89 81       	ldd	r24, Y+1	; 0x01
    1578:	80 62       	ori	r24, 0x20	; 32
    157a:	89 83       	std	Y+1, r24	; 0x01
            break;
    157c:	17 c0       	rjmp	.+46     	; 0x15ac <sIMU_begin+0x20e>
            case 52:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_52Hz;
    157e:	89 81       	ldd	r24, Y+1	; 0x01
    1580:	80 63       	ori	r24, 0x30	; 48
    1582:	89 83       	std	Y+1, r24	; 0x01
            break;
    1584:	13 c0       	rjmp	.+38     	; 0x15ac <sIMU_begin+0x20e>
            default:  //Set default to 104
            case 104:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_104Hz;
    1586:	89 81       	ldd	r24, Y+1	; 0x01
    1588:	80 64       	ori	r24, 0x40	; 64
    158a:	89 83       	std	Y+1, r24	; 0x01
            break;
    158c:	0f c0       	rjmp	.+30     	; 0x15ac <sIMU_begin+0x20e>
            case 208:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_208Hz;
    158e:	89 81       	ldd	r24, Y+1	; 0x01
    1590:	80 65       	ori	r24, 0x50	; 80
    1592:	89 83       	std	Y+1, r24	; 0x01
            break;
    1594:	0b c0       	rjmp	.+22     	; 0x15ac <sIMU_begin+0x20e>
            case 416:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_416Hz;
    1596:	89 81       	ldd	r24, Y+1	; 0x01
    1598:	80 66       	ori	r24, 0x60	; 96
    159a:	89 83       	std	Y+1, r24	; 0x01
            break;
    159c:	07 c0       	rjmp	.+14     	; 0x15ac <sIMU_begin+0x20e>
            case 833:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_833Hz;
    159e:	89 81       	ldd	r24, Y+1	; 0x01
    15a0:	80 67       	ori	r24, 0x70	; 112
    15a2:	89 83       	std	Y+1, r24	; 0x01
            break;
    15a4:	03 c0       	rjmp	.+6      	; 0x15ac <sIMU_begin+0x20e>
            case 1660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_1660Hz;
    15a6:	89 81       	ldd	r24, Y+1	; 0x01
    15a8:	80 68       	ori	r24, 0x80	; 128
    }
    else{
        //dataToWrite already = 0 (powerdown);
    }
    //Write the byte
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL2_G, dataToWrite);
    15aa:	89 83       	std	Y+1, r24	; 0x01
    15ac:	69 81       	ldd	r22, Y+1	; 0x01
    15ae:	81 e1       	ldi	r24, 0x11	; 17
    if ( settings.tempEnabled == 1) {
    }

    //Return WHO AM I reg
    uint8_t result;
    sIMU_readRegister(&result, LSM6DS3_ACC_GYRO_WHO_AM_I_REG);
    15b0:	ea de       	rcall	.-556    	; 0x1386 <sIMU_writeRegister>
    15b2:	6f e0       	ldi	r22, 0x0F	; 15
    15b4:	ce 01       	movw	r24, r28
    15b6:	02 96       	adiw	r24, 0x02	; 2
    15b8:	7b de       	rcall	.-778    	; 0x12b0 <sIMU_readRegister>

    return returnError;
}
    15ba:	81 2f       	mov	r24, r17
    15bc:	0f 90       	pop	r0
    15be:	0f 90       	pop	r0
    15c0:	df 91       	pop	r29
    15c2:	cf 91       	pop	r28
    15c4:	1f 91       	pop	r17
    15c6:	08 95       	ret

000015c8 <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    15c8:	ea e0       	ldi	r30, 0x0A	; 10
    15ca:	f1 e0       	ldi	r31, 0x01	; 1
    15cc:	80 81       	ld	r24, Z
    15ce:	87 60       	ori	r24, 0x07	; 7
    15d0:	80 83       	st	Z, r24
    15d2:	08 95       	ret

000015d4 <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
    15d4:	82 30       	cpi	r24, 0x02	; 2
    15d6:	91 05       	cpc	r25, r1
    15d8:	31 f4       	brne	.+12     	; 0x15e6 <vLED_singleHigh+0x12>
    15da:	eb e0       	ldi	r30, 0x0B	; 11
    15dc:	f1 e0       	ldi	r31, 0x01	; 1
    15de:	80 81       	ld	r24, Z
    15e0:	84 60       	ori	r24, 0x04	; 4
    15e2:	80 83       	st	Z, r24
    15e4:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
    15e6:	81 30       	cpi	r24, 0x01	; 1
    15e8:	91 05       	cpc	r25, r1
    15ea:	31 f4       	brne	.+12     	; 0x15f8 <vLED_singleHigh+0x24>
    15ec:	eb e0       	ldi	r30, 0x0B	; 11
    15ee:	f1 e0       	ldi	r31, 0x01	; 1
    15f0:	80 81       	ld	r24, Z
    15f2:	82 60       	ori	r24, 0x02	; 2
    15f4:	80 83       	st	Z, r24
    15f6:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
    15f8:	89 2b       	or	r24, r25
    15fa:	29 f4       	brne	.+10     	; 0x1606 <vLED_singleHigh+0x32>
    15fc:	eb e0       	ldi	r30, 0x0B	; 11
    15fe:	f1 e0       	ldi	r31, 0x01	; 1
    1600:	80 81       	ld	r24, Z
    1602:	81 60       	ori	r24, 0x01	; 1
    1604:	80 83       	st	Z, r24
    1606:	08 95       	ret

00001608 <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
    1608:	82 30       	cpi	r24, 0x02	; 2
    160a:	91 05       	cpc	r25, r1
    160c:	31 f4       	brne	.+12     	; 0x161a <vLED_singleLow+0x12>
    160e:	eb e0       	ldi	r30, 0x0B	; 11
    1610:	f1 e0       	ldi	r31, 0x01	; 1
    1612:	80 81       	ld	r24, Z
    1614:	8b 7f       	andi	r24, 0xFB	; 251
    1616:	80 83       	st	Z, r24
    1618:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
    161a:	81 30       	cpi	r24, 0x01	; 1
    161c:	91 05       	cpc	r25, r1
    161e:	31 f4       	brne	.+12     	; 0x162c <vLED_singleLow+0x24>
    1620:	eb e0       	ldi	r30, 0x0B	; 11
    1622:	f1 e0       	ldi	r31, 0x01	; 1
    1624:	80 81       	ld	r24, Z
    1626:	8d 7f       	andi	r24, 0xFD	; 253
    1628:	80 83       	st	Z, r24
    162a:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
    162c:	89 2b       	or	r24, r25
    162e:	29 f4       	brne	.+10     	; 0x163a <vLED_singleLow+0x32>
    1630:	eb e0       	ldi	r30, 0x0B	; 11
    1632:	f1 e0       	ldi	r31, 0x01	; 1
    1634:	80 81       	ld	r24, Z
    1636:	8e 7f       	andi	r24, 0xFE	; 254
    1638:	80 83       	st	Z, r24
    163a:	08 95       	ret

0000163c <vLED_toggle>:
}

/* Toggle a single LED */
void vLED_toggle(int ledCOLOR){
	if (ledCOLOR == ledGREEN)		ledPORT ^= (1<<ledGREEN);
    163c:	82 30       	cpi	r24, 0x02	; 2
    163e:	91 05       	cpc	r25, r1
    1640:	39 f4       	brne	.+14     	; 0x1650 <vLED_toggle+0x14>
    1642:	eb e0       	ldi	r30, 0x0B	; 11
    1644:	f1 e0       	ldi	r31, 0x01	; 1
    1646:	90 81       	ld	r25, Z
    1648:	84 e0       	ldi	r24, 0x04	; 4
    164a:	89 27       	eor	r24, r25
    164c:	80 83       	st	Z, r24
    164e:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)	ledPORT ^= (1<<ledYELLOW);
    1650:	81 30       	cpi	r24, 0x01	; 1
    1652:	91 05       	cpc	r25, r1
    1654:	39 f4       	brne	.+14     	; 0x1664 <vLED_toggle+0x28>
    1656:	eb e0       	ldi	r30, 0x0B	; 11
    1658:	f1 e0       	ldi	r31, 0x01	; 1
    165a:	90 81       	ld	r25, Z
    165c:	82 e0       	ldi	r24, 0x02	; 2
    165e:	89 27       	eor	r24, r25
    1660:	80 83       	st	Z, r24
    1662:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT ^= (1<<ledRED);
    1664:	89 2b       	or	r24, r25
    1666:	31 f4       	brne	.+12     	; 0x1674 <vLED_toggle+0x38>
    1668:	eb e0       	ldi	r30, 0x0B	; 11
    166a:	f1 e0       	ldi	r31, 0x01	; 1
    166c:	90 81       	ld	r25, Z
    166e:	81 e0       	ldi	r24, 0x01	; 1
    1670:	89 27       	eor	r24, r25
    1672:	80 83       	st	Z, r24
    1674:	08 95       	ret

00001676 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1676:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1678:	03 96       	adiw	r24, 0x03	; 3
    167a:	92 83       	std	Z+2, r25	; 0x02
    167c:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    167e:	2f ef       	ldi	r18, 0xFF	; 255
    1680:	3f ef       	ldi	r19, 0xFF	; 255
    1682:	34 83       	std	Z+4, r19	; 0x04
    1684:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1686:	96 83       	std	Z+6, r25	; 0x06
    1688:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    168a:	90 87       	std	Z+8, r25	; 0x08
    168c:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    168e:	10 82       	st	Z, r1
    1690:	08 95       	ret

00001692 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1692:	fc 01       	movw	r30, r24
    1694:	11 86       	std	Z+9, r1	; 0x09
    1696:	10 86       	std	Z+8, r1	; 0x08
    1698:	08 95       	ret

0000169a <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    169a:	cf 93       	push	r28
    169c:	df 93       	push	r29
    169e:	9c 01       	movw	r18, r24
    16a0:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    16a2:	dc 01       	movw	r26, r24
    16a4:	11 96       	adiw	r26, 0x01	; 1
    16a6:	cd 91       	ld	r28, X+
    16a8:	dc 91       	ld	r29, X
    16aa:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    16ac:	d3 83       	std	Z+3, r29	; 0x03
    16ae:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    16b0:	8c 81       	ldd	r24, Y+4	; 0x04
    16b2:	9d 81       	ldd	r25, Y+5	; 0x05
    16b4:	95 83       	std	Z+5, r25	; 0x05
    16b6:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    16b8:	8c 81       	ldd	r24, Y+4	; 0x04
    16ba:	9d 81       	ldd	r25, Y+5	; 0x05
    16bc:	dc 01       	movw	r26, r24
    16be:	13 96       	adiw	r26, 0x03	; 3
    16c0:	7c 93       	st	X, r23
    16c2:	6e 93       	st	-X, r22
    16c4:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    16c6:	7d 83       	std	Y+5, r23	; 0x05
    16c8:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    16ca:	31 87       	std	Z+9, r19	; 0x09
    16cc:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    16ce:	f9 01       	movw	r30, r18
    16d0:	80 81       	ld	r24, Z
    16d2:	8f 5f       	subi	r24, 0xFF	; 255
    16d4:	80 83       	st	Z, r24
}
    16d6:	df 91       	pop	r29
    16d8:	cf 91       	pop	r28
    16da:	08 95       	ret

000016dc <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    16dc:	cf 93       	push	r28
    16de:	df 93       	push	r29
    16e0:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    16e2:	48 81       	ld	r20, Y
    16e4:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    16e6:	4f 3f       	cpi	r20, 0xFF	; 255
    16e8:	2f ef       	ldi	r18, 0xFF	; 255
    16ea:	52 07       	cpc	r21, r18
    16ec:	21 f4       	brne	.+8      	; 0x16f6 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    16ee:	fc 01       	movw	r30, r24
    16f0:	a7 81       	ldd	r26, Z+7	; 0x07
    16f2:	b0 85       	ldd	r27, Z+8	; 0x08
    16f4:	0d c0       	rjmp	.+26     	; 0x1710 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    16f6:	dc 01       	movw	r26, r24
    16f8:	13 96       	adiw	r26, 0x03	; 3
    16fa:	01 c0       	rjmp	.+2      	; 0x16fe <vListInsert+0x22>
    16fc:	df 01       	movw	r26, r30
    16fe:	12 96       	adiw	r26, 0x02	; 2
    1700:	ed 91       	ld	r30, X+
    1702:	fc 91       	ld	r31, X
    1704:	13 97       	sbiw	r26, 0x03	; 3
    1706:	20 81       	ld	r18, Z
    1708:	31 81       	ldd	r19, Z+1	; 0x01
    170a:	42 17       	cp	r20, r18
    170c:	53 07       	cpc	r21, r19
    170e:	b0 f7       	brcc	.-20     	; 0x16fc <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1710:	12 96       	adiw	r26, 0x02	; 2
    1712:	ed 91       	ld	r30, X+
    1714:	fc 91       	ld	r31, X
    1716:	13 97       	sbiw	r26, 0x03	; 3
    1718:	fb 83       	std	Y+3, r31	; 0x03
    171a:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    171c:	d5 83       	std	Z+5, r29	; 0x05
    171e:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1720:	bd 83       	std	Y+5, r27	; 0x05
    1722:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1724:	13 96       	adiw	r26, 0x03	; 3
    1726:	dc 93       	st	X, r29
    1728:	ce 93       	st	-X, r28
    172a:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    172c:	99 87       	std	Y+9, r25	; 0x09
    172e:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1730:	fc 01       	movw	r30, r24
    1732:	20 81       	ld	r18, Z
    1734:	2f 5f       	subi	r18, 0xFF	; 255
    1736:	20 83       	st	Z, r18
}
    1738:	df 91       	pop	r29
    173a:	cf 91       	pop	r28
    173c:	08 95       	ret

0000173e <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    173e:	cf 93       	push	r28
    1740:	df 93       	push	r29
    1742:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1744:	a0 85       	ldd	r26, Z+8	; 0x08
    1746:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1748:	c2 81       	ldd	r28, Z+2	; 0x02
    174a:	d3 81       	ldd	r29, Z+3	; 0x03
    174c:	84 81       	ldd	r24, Z+4	; 0x04
    174e:	95 81       	ldd	r25, Z+5	; 0x05
    1750:	9d 83       	std	Y+5, r25	; 0x05
    1752:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1754:	c4 81       	ldd	r28, Z+4	; 0x04
    1756:	d5 81       	ldd	r29, Z+5	; 0x05
    1758:	82 81       	ldd	r24, Z+2	; 0x02
    175a:	93 81       	ldd	r25, Z+3	; 0x03
    175c:	9b 83       	std	Y+3, r25	; 0x03
    175e:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1760:	11 96       	adiw	r26, 0x01	; 1
    1762:	8d 91       	ld	r24, X+
    1764:	9c 91       	ld	r25, X
    1766:	12 97       	sbiw	r26, 0x02	; 2
    1768:	e8 17       	cp	r30, r24
    176a:	f9 07       	cpc	r31, r25
    176c:	31 f4       	brne	.+12     	; 0x177a <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    176e:	84 81       	ldd	r24, Z+4	; 0x04
    1770:	95 81       	ldd	r25, Z+5	; 0x05
    1772:	12 96       	adiw	r26, 0x02	; 2
    1774:	9c 93       	st	X, r25
    1776:	8e 93       	st	-X, r24
    1778:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    177a:	11 86       	std	Z+9, r1	; 0x09
    177c:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    177e:	8c 91       	ld	r24, X
    1780:	81 50       	subi	r24, 0x01	; 1
    1782:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1784:	df 91       	pop	r29
    1786:	cf 91       	pop	r28
    1788:	08 95       	ret

0000178a <vMainCommunicationTask>:
                gyro+= fIMU_readFloatGyroZ();
			}
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
    178a:	cf 93       	push	r28
    178c:	df 93       	push	r29
    178e:	00 d0       	rcall	.+0      	; 0x1790 <vMainCommunicationTask+0x6>
    1790:	00 d0       	rcall	.+0      	; 0x1792 <vMainCommunicationTask+0x8>
    1792:	cd b7       	in	r28, 0x3d	; 61
    1794:	de b7       	in	r29, 0x3e	; 62
    1796:	fe 01       	movw	r30, r28
    1798:	31 96       	adiw	r30, 0x01	; 1
    179a:	86 e0       	ldi	r24, 0x06	; 6
    179c:	df 01       	movw	r26, r30
    179e:	1d 92       	st	X+, r1
    17a0:	8a 95       	dec	r24
    17a2:	e9 f7       	brne	.-6      	; 0x179e <vMainCommunicationTask+0x14>
    17a4:	0e 94 49 17 	call	0x2e92	; 0x2e92 <server_communication_init>
    17a8:	a1 2c       	mov	r10, r1
    17aa:	b1 2c       	mov	r11, r1
    17ac:	c1 2c       	mov	r12, r1
    17ae:	d1 2c       	mov	r13, r1
    17b0:	e1 2c       	mov	r14, r1
    17b2:	f1 2c       	mov	r15, r1
    17b4:	03 e0       	ldi	r16, 0x03	; 3
    17b6:	20 e0       	ldi	r18, 0x00	; 0
    17b8:	30 e0       	ldi	r19, 0x00	; 0
    17ba:	48 ec       	ldi	r20, 0xC8	; 200
    17bc:	50 e0       	ldi	r21, 0x00	; 0
    17be:	6b e0       	ldi	r22, 0x0B	; 11
    17c0:	72 e0       	ldi	r23, 0x02	; 2
    17c2:	8f ef       	ldi	r24, 0xFF	; 255
    17c4:	94 e0       	ldi	r25, 0x04	; 4
    17c6:	0e 94 5e 19 	call	0x32bc	; 0x32bc <xTaskGenericCreate>
    17ca:	81 30       	cpi	r24, 0x01	; 1
    17cc:	19 f0       	breq	.+6      	; 0x17d4 <vMainCommunicationTask+0x4a>
    17ce:	80 e0       	ldi	r24, 0x00	; 0
    17d0:	90 e0       	ldi	r25, 0x00	; 0
    17d2:	00 df       	rcall	.-512    	; 0x15d4 <vLED_singleHigh>
    17d4:	0e 94 52 17 	call	0x2ea4	; 0x2ea4 <server_connect>
    17d8:	18 2f       	mov	r17, r24
    17da:	88 ee       	ldi	r24, 0xE8	; 232
    17dc:	93 e0       	ldi	r25, 0x03	; 3
    17de:	0e 94 15 1c 	call	0x382a	; 0x382a <vTaskDelay>
    17e2:	82 e0       	ldi	r24, 0x02	; 2
    17e4:	90 e0       	ldi	r25, 0x00	; 0
    17e6:	2a df       	rcall	.-428    	; 0x163c <vLED_toggle>
    17e8:	11 23       	and	r17, r17
    17ea:	a1 f3       	breq	.-24     	; 0x17d4 <vMainCommunicationTask+0x4a>
    17ec:	0e 94 5e 17 	call	0x2ebc	; 0x2ebc <send_handshake>
    17f0:	0f 2e       	mov	r0, r31
    17f2:	f5 e1       	ldi	r31, 0x15	; 21
    17f4:	ef 2e       	mov	r14, r31
    17f6:	f7 e1       	ldi	r31, 0x17	; 23
    17f8:	ff 2e       	mov	r15, r31
    17fa:	f0 2d       	mov	r31, r0
    17fc:	01 e0       	ldi	r16, 0x01	; 1
    17fe:	0f 2e       	mov	r0, r31
    1800:	f0 ec       	ldi	r31, 0xC0	; 192
    1802:	6f 2e       	mov	r6, r31
    1804:	fe ef       	ldi	r31, 0xFE	; 254
    1806:	7f 2e       	mov	r7, r31
    1808:	f0 2d       	mov	r31, r0
    180a:	68 94       	set
    180c:	88 24       	eor	r8, r8
    180e:	86 f8       	bld	r8, 6
    1810:	99 24       	eor	r9, r9
    1812:	93 94       	inc	r9
    1814:	20 e0       	ldi	r18, 0x00	; 0
    1816:	4f ef       	ldi	r20, 0xFF	; 255
    1818:	5f ef       	ldi	r21, 0xFF	; 255
    181a:	60 e0       	ldi	r22, 0x00	; 0
    181c:	70 e0       	ldi	r23, 0x00	; 0
    181e:	80 91 11 17 	lds	r24, 0x1711	; 0x801711 <xCommandReadyBSem>
    1822:	90 91 12 17 	lds	r25, 0x1712	; 0x801712 <xCommandReadyBSem+0x1>
    1826:	0e 94 99 15 	call	0x2b32	; 0x2b32 <xQueueGenericReceive>
    182a:	81 30       	cpi	r24, 0x01	; 1
    182c:	99 f7       	brne	.-26     	; 0x1814 <vMainCommunicationTask+0x8a>
    182e:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <vTaskSuspendAll>
    1832:	0f b6       	in	r0, 0x3f	; 63
    1834:	f8 94       	cli
    1836:	0f 92       	push	r0
    1838:	f7 01       	movw	r30, r14
    183a:	10 81       	ld	r17, Z
    183c:	c1 80       	ldd	r12, Z+1	; 0x01
    183e:	d2 80       	ldd	r13, Z+2	; 0x02
    1840:	a3 80       	ldd	r10, Z+3	; 0x03
    1842:	b4 80       	ldd	r11, Z+4	; 0x04
    1844:	0f 90       	pop	r0
    1846:	0f be       	out	0x3f, r0	; 63
    1848:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    184c:	15 30       	cpi	r17, 0x05	; 5
    184e:	09 f4       	brne	.+2      	; 0x1852 <vMainCommunicationTask+0xc8>
    1850:	63 c0       	rjmp	.+198    	; 0x1918 <vMainCommunicationTask+0x18e>
    1852:	30 f4       	brcc	.+12     	; 0x1860 <vMainCommunicationTask+0xd6>
    1854:	12 30       	cpi	r17, 0x02	; 2
    1856:	b1 f0       	breq	.+44     	; 0x1884 <vMainCommunicationTask+0xfa>
    1858:	14 30       	cpi	r17, 0x04	; 4
    185a:	09 f4       	brne	.+2      	; 0x185e <vMainCommunicationTask+0xd4>
    185c:	44 c0       	rjmp	.+136    	; 0x18e6 <vMainCommunicationTask+0x15c>
    185e:	da cf       	rjmp	.-76     	; 0x1814 <vMainCommunicationTask+0x8a>
    1860:	17 30       	cpi	r17, 0x07	; 7
    1862:	09 f4       	brne	.+2      	; 0x1866 <vMainCommunicationTask+0xdc>
    1864:	61 c0       	rjmp	.+194    	; 0x1928 <vMainCommunicationTask+0x19e>
    1866:	18 f0       	brcs	.+6      	; 0x186e <vMainCommunicationTask+0xe4>
    1868:	18 30       	cpi	r17, 0x08	; 8
    186a:	49 f0       	breq	.+18     	; 0x187e <vMainCommunicationTask+0xf4>
    186c:	d3 cf       	rjmp	.-90     	; 0x1814 <vMainCommunicationTask+0x8a>
    186e:	0f b6       	in	r0, 0x3f	; 63
    1870:	f8 94       	cli
    1872:	0f 92       	push	r0
    1874:	00 93 a0 15 	sts	0x15A0, r16	; 0x8015a0 <gHandshook>
    1878:	0f 90       	pop	r0
    187a:	0f be       	out	0x3f, r0	; 63
    187c:	cb cf       	rjmp	.-106    	; 0x1814 <vMainCommunicationTask+0x8a>
    187e:	0e 94 01 18 	call	0x3002	; 0x3002 <send_ping_response>
    1882:	c8 cf       	rjmp	.-112    	; 0x1814 <vMainCommunicationTask+0x8a>
    1884:	b6 01       	movw	r22, r12
    1886:	dd 0c       	add	r13, r13
    1888:	88 0b       	sbc	r24, r24
    188a:	99 0b       	sbc	r25, r25
    188c:	0e 94 09 27 	call	0x4e12	; 0x4e12 <__floatsisf>
    1890:	f1 e4       	ldi	r31, 0x41	; 65
    1892:	af 16       	cp	r10, r31
    1894:	f1 e0       	ldi	r31, 0x01	; 1
    1896:	bf 06       	cpc	r11, r31
    1898:	1c f0       	brlt	.+6      	; 0x18a0 <vMainCommunicationTask+0x116>
    189a:	9e 82       	std	Y+6, r9	; 0x06
    189c:	8d 82       	std	Y+5, r8	; 0x05
    189e:	0a c0       	rjmp	.+20     	; 0x18b4 <vMainCommunicationTask+0x12a>
    18a0:	20 ec       	ldi	r18, 0xC0	; 192
    18a2:	a2 16       	cp	r10, r18
    18a4:	2e ef       	ldi	r18, 0xFE	; 254
    18a6:	b2 06       	cpc	r11, r18
    18a8:	1c f0       	brlt	.+6      	; 0x18b0 <vMainCommunicationTask+0x126>
    18aa:	be 82       	std	Y+6, r11	; 0x06
    18ac:	ad 82       	std	Y+5, r10	; 0x05
    18ae:	02 c0       	rjmp	.+4      	; 0x18b4 <vMainCommunicationTask+0x12a>
    18b0:	7e 82       	std	Y+6, r7	; 0x06
    18b2:	6d 82       	std	Y+5, r6	; 0x05
    18b4:	25 e3       	ldi	r18, 0x35	; 53
    18b6:	3a ef       	ldi	r19, 0xFA	; 250
    18b8:	4e e8       	ldi	r20, 0x8E	; 142
    18ba:	5c e3       	ldi	r21, 0x3C	; 60
    18bc:	0e 94 bd 27 	call	0x4f7a	; 0x4f7a <__mulsf3>
    18c0:	69 83       	std	Y+1, r22	; 0x01
    18c2:	7a 83       	std	Y+2, r23	; 0x02
    18c4:	8b 83       	std	Y+3, r24	; 0x03
    18c6:	9c 83       	std	Y+4, r25	; 0x04
    18c8:	ce 01       	movw	r24, r28
    18ca:	01 96       	adiw	r24, 0x01	; 1
    18cc:	28 db       	rcall	.-2480   	; 0xf1e <vFunc_Inf2pi>
    18ce:	20 e0       	ldi	r18, 0x00	; 0
    18d0:	44 e6       	ldi	r20, 0x64	; 100
    18d2:	50 e0       	ldi	r21, 0x00	; 0
    18d4:	be 01       	movw	r22, r28
    18d6:	6f 5f       	subi	r22, 0xFF	; 255
    18d8:	7f 4f       	sbci	r23, 0xFF	; 255
    18da:	80 91 a7 15 	lds	r24, 0x15A7	; 0x8015a7 <poseControllerQ>
    18de:	90 91 a8 15 	lds	r25, 0x15A8	; 0x8015a8 <poseControllerQ+0x1>
    18e2:	bb d5       	rcall	.+2934   	; 0x245a <xQueueGenericSend>
    18e4:	97 cf       	rjmp	.-210    	; 0x1814 <vMainCommunicationTask+0x8a>
    18e6:	0f b6       	in	r0, 0x3f	; 63
    18e8:	f8 94       	cli
    18ea:	0f 92       	push	r0
    18ec:	00 93 9f 15 	sts	0x159F, r16	; 0x80159f <gPaused>
    18f0:	0f 90       	pop	r0
    18f2:	0f be       	out	0x3f, r0	; 63
    18f4:	1e 82       	std	Y+6, r1	; 0x06
    18f6:	1d 82       	std	Y+5, r1	; 0x05
    18f8:	19 82       	std	Y+1, r1	; 0x01
    18fa:	1a 82       	std	Y+2, r1	; 0x02
    18fc:	1b 82       	std	Y+3, r1	; 0x03
    18fe:	1c 82       	std	Y+4, r1	; 0x04
    1900:	20 e0       	ldi	r18, 0x00	; 0
    1902:	44 e6       	ldi	r20, 0x64	; 100
    1904:	50 e0       	ldi	r21, 0x00	; 0
    1906:	be 01       	movw	r22, r28
    1908:	6f 5f       	subi	r22, 0xFF	; 255
    190a:	7f 4f       	sbci	r23, 0xFF	; 255
    190c:	80 91 a7 15 	lds	r24, 0x15A7	; 0x8015a7 <poseControllerQ>
    1910:	90 91 a8 15 	lds	r25, 0x15A8	; 0x8015a8 <poseControllerQ+0x1>
    1914:	a2 d5       	rcall	.+2884   	; 0x245a <xQueueGenericSend>
    1916:	7e cf       	rjmp	.-260    	; 0x1814 <vMainCommunicationTask+0x8a>
    1918:	0f b6       	in	r0, 0x3f	; 63
    191a:	f8 94       	cli
    191c:	0f 92       	push	r0
    191e:	10 92 9f 15 	sts	0x159F, r1	; 0x80159f <gPaused>
    1922:	0f 90       	pop	r0
    1924:	0f be       	out	0x3f, r0	; 63
    1926:	76 cf       	rjmp	.-276    	; 0x1814 <vMainCommunicationTask+0x8a>
    1928:	0f b6       	in	r0, 0x3f	; 63
    192a:	f8 94       	cli
    192c:	0f 92       	push	r0
    192e:	10 92 a0 15 	sts	0x15A0, r1	; 0x8015a0 <gHandshook>
    1932:	0f 90       	pop	r0
    1934:	0f be       	out	0x3f, r0	; 63
    1936:	6e cf       	rjmp	.-292    	; 0x1814 <vMainCommunicationTask+0x8a>

00001938 <vMainMovementTask>:
    1938:	cf 93       	push	r28
    193a:	df 93       	push	r29
    193c:	1f 92       	push	r1
    193e:	1f 92       	push	r1
    1940:	cd b7       	in	r28, 0x3d	; 61
    1942:	de b7       	in	r29, 0x3e	; 62
    1944:	0e 94 bf 1f 	call	0x3f7e	; 0x3f7e <xTaskGetTickCount>
    1948:	9a 83       	std	Y+2, r25	; 0x02
    194a:	89 83       	std	Y+1, r24	; 0x01
    194c:	64 e1       	ldi	r22, 0x14	; 20
    194e:	70 e0       	ldi	r23, 0x00	; 0
    1950:	ce 01       	movw	r24, r28
    1952:	01 96       	adiw	r24, 0x01	; 1
    1954:	0e 94 72 1a 	call	0x34e4	; 0x34e4 <vTaskDelayUntil>
    1958:	f9 cf       	rjmp	.-14     	; 0x194c <vMainMovementTask+0x14>

0000195a <vApplicationStackOverflowHook>:
}
#endif
*/
/*  In case of stack overflow, disable all interrupts and handle it  */
void vApplicationStackOverflowHook(TaskHandle_t *pxTask, signed char *pcTaskName){
    cli();
    195a:	f8 94       	cli
    /*  Handle overflow */
    #ifdef DEBUG
       debug("Overflow\n");
    #endif
    while(1){
        vLED_toggle(ledRED);
    195c:	80 e0       	ldi	r24, 0x00	; 0
    195e:	90 e0       	ldi	r25, 0x00	; 0
    1960:	6d de       	rcall	.-806    	; 0x163c <vLED_toggle>
    1962:	fc cf       	rjmp	.-8      	; 0x195c <vApplicationStackOverflowHook+0x2>

00001964 <main>:

/*  Main function   */
int main(void){
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */
    vLED_init();
    1964:	31 de       	rcall	.-926    	; 0x15c8 <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    1966:	80 e0       	ldi	r24, 0x00	; 0
    1968:	90 e0       	ldi	r25, 0x00	; 0
    196a:	34 de       	rcall	.-920    	; 0x15d4 <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    196c:	0e 94 bd 25 	call	0x4b7a	; 0x4b7a <vUSART_init>
    network_init();
    1970:	96 d1       	rcall	.+812    	; 0x1c9e <network_init>
    arq_init();
    1972:	0e 94 1d 01 	call	0x23a	; 0x23a <arq_init>
    simple_p_init(server_receiver);
    1976:	87 e3       	ldi	r24, 0x37	; 55
    1978:	97 e1       	ldi	r25, 0x17	; 23
    197a:	0e 94 bd 18 	call	0x317a	; 0x317a <simple_p_init>
        debug("tictoc!\n");
        tic;
    #endif
    
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    197e:	80 e0       	ldi	r24, 0x00	; 0
    /* Initialize sensors */
    vDistSens_init();
    1980:	0e 94 35 18 	call	0x306a	; 0x306a <vServo_init>
    vMotor_init();
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        debug("IMU init..\n");
    #endif
	vLED_singleHigh(ledGREEN);
    1984:	bc da       	rcall	.-2696   	; 0xefe <vDistSens_init>
    1986:	e7 d0       	rcall	.+462    	; 0x1b56 <vMotor_init>
    1988:	82 e0       	ldi	r24, 0x02	; 2
    sIMU_begin(); 
    198a:	90 e0       	ldi	r25, 0x00	; 0
   vLED_singleLow(ledGREEN);
    198c:	23 de       	rcall	.-954    	; 0x15d4 <vLED_singleHigh>
    198e:	07 dd       	rcall	.-1522   	; 0x139e <sIMU_begin>
    1990:	82 e0       	ldi	r24, 0x02	; 2
    /* Initialize compass */
    /* Connected with I2C, if the chip has no power, MCU will lock. */
    #ifdef DEBUG
            debug("Compass init..\n");
    #endif
    vLED_singleHigh(ledYELLOW);
    1992:	90 e0       	ldi	r25, 0x00	; 0
    1994:	39 de       	rcall	.-910    	; 0x1608 <vLED_singleLow>
    1996:	81 e0       	ldi	r24, 0x01	; 1
   // vCOM_init();
    vLED_singleLow(ledYELLOW);
    1998:	90 e0       	ldi	r25, 0x00	; 0
    199a:	1c de       	rcall	.-968    	; 0x15d4 <vLED_singleHigh>
    199c:	81 e0       	ldi	r24, 0x01	; 1
    199e:	90 e0       	ldi	r25, 0x00	; 0
	// TESTING

	
	
	
    movementQ = xQueueCreate(2,sizeof(uint8_t)); // For sending movements to vMainMovementTask
    19a0:	33 de       	rcall	.-922    	; 0x1608 <vLED_singleLow>
    19a2:	40 e0       	ldi	r20, 0x00	; 0
    19a4:	61 e0       	ldi	r22, 0x01	; 1
    19a6:	82 e0       	ldi	r24, 0x02	; 2
    19a8:	88 d3       	rcall	.+1808   	; 0x20ba <xQueueGenericCreate>
    19aa:	90 93 aa 15 	sts	0x15AA, r25	; 0x8015aa <movementQ+0x1>
    19ae:	80 93 a9 15 	sts	0x15A9, r24	; 0x8015a9 <movementQ>
    poseControllerQ = xQueueCreate(1, sizeof(struct sPolar)); // For setpoints to controller
    19b2:	40 e0       	ldi	r20, 0x00	; 0
    19b4:	66 e0       	ldi	r22, 0x06	; 6
    19b6:	81 e0       	ldi	r24, 0x01	; 1
    19b8:	80 d3       	rcall	.+1792   	; 0x20ba <xQueueGenericCreate>
    19ba:	90 93 a8 15 	sts	0x15A8, r25	; 0x8015a8 <poseControllerQ+0x1>
    19be:	80 93 a7 15 	sts	0x15A7, r24	; 0x8015a7 <poseControllerQ>
    scanStatusQ = xQueueCreate(1,sizeof(uint8_t)); // For robot status
    19c2:	40 e0       	ldi	r20, 0x00	; 0
    19c4:	61 e0       	ldi	r22, 0x01	; 1
    19c6:	81 e0       	ldi	r24, 0x01	; 1
    19c8:	78 d3       	rcall	.+1776   	; 0x20ba <xQueueGenericCreate>
    19ca:	90 93 a6 15 	sts	0x15A6, r25	; 0x8015a6 <scanStatusQ+0x1>
    19ce:	80 93 a5 15 	sts	0x15A5, r24	; 0x8015a5 <scanStatusQ>
    actuationQ = xQueueCreate(2,sizeof(uint8_t)); // To send variable actuation to motors
    19d2:	40 e0       	ldi	r20, 0x00	; 0
    19d4:	61 e0       	ldi	r22, 0x01	; 1
    19d6:	82 e0       	ldi	r24, 0x02	; 2
    19d8:	70 d3       	rcall	.+1760   	; 0x20ba <xQueueGenericCreate>
    19da:	90 93 a4 15 	sts	0x15A4, r25	; 0x8015a4 <actuationQ+0x1>
    19de:	80 93 a3 15 	sts	0x15A3, r24	; 0x8015a3 <actuationQ>
    
    xPoseMutex = xSemaphoreCreateMutex(); // Global variables for robot pose. Only updated from estimator, accessed from many
    19e2:	81 e0       	ldi	r24, 0x01	; 1
    19e4:	ba d3       	rcall	.+1908   	; 0x215a <xQueueCreateMutex>
    19e6:	90 93 14 17 	sts	0x1714, r25	; 0x801714 <xPoseMutex+0x1>
    19ea:	80 93 13 17 	sts	0x1713, r24	; 0x801713 <xPoseMutex>
    xUartMutex = xSemaphoreCreateMutex(); // Protected printf with a mutex, may cause fragmented bytes if higher priority task want to print as well
    19ee:	81 e0       	ldi	r24, 0x01	; 1
    19f0:	b4 d3       	rcall	.+1896   	; 0x215a <xQueueCreateMutex>
    19f2:	90 93 10 17 	sts	0x1710, r25	; 0x801710 <xUartMutex+0x1>
    19f6:	80 93 0f 17 	sts	0x170F, r24	; 0x80170f <xUartMutex>
    xTickMutex = xSemaphoreCreateMutex(); // Global variable to hold robot tick values
    19fa:	81 e0       	ldi	r24, 0x01	; 1
    19fc:	ae d3       	rcall	.+1884   	; 0x215a <xQueueCreateMutex>
    19fe:	90 93 0e 17 	sts	0x170E, r25	; 0x80170e <xTickMutex+0x1>
    1a02:	80 93 0d 17 	sts	0x170D, r24	; 0x80170d <xTickMutex>
    
    xControllerBSem = xSemaphoreCreateBinary(); // Estimator to Controller synchronization
    1a06:	43 e0       	ldi	r20, 0x03	; 3
    1a08:	60 e0       	ldi	r22, 0x00	; 0
    1a0a:	81 e0       	ldi	r24, 0x01	; 1
    1a0c:	56 d3       	rcall	.+1708   	; 0x20ba <xQueueGenericCreate>
    1a0e:	90 93 0c 17 	sts	0x170C, r25	; 0x80170c <xControllerBSem+0x1>
    1a12:	80 93 0b 17 	sts	0x170B, r24	; 0x80170b <xControllerBSem>
    1a16:	43 e0       	ldi	r20, 0x03	; 3
    xCommandReadyBSem = xSemaphoreCreateBinary(); // uart ISR to comm task sync
    1a18:	60 e0       	ldi	r22, 0x00	; 0
    1a1a:	81 e0       	ldi	r24, 0x01	; 1
    1a1c:	4e d3       	rcall	.+1692   	; 0x20ba <xQueueGenericCreate>
    1a1e:	90 93 12 17 	sts	0x1712, r25	; 0x801712 <xCommandReadyBSem+0x1>
    1a22:	80 93 11 17 	sts	0x1711, r24	; 0x801711 <xCommandReadyBSem>
    1a26:	a1 2c       	mov	r10, r1
    1a28:	b1 2c       	mov	r11, r1
    
    // Todo: Check return variable to ensure RTOS utilities were successfully initialized before continue
    xTaskCreate(vMainMovementTask, "Movement", 300, NULL, 4, NULL); // Independent task, uses ticks from ISR
    1a2a:	c1 2c       	mov	r12, r1
    1a2c:	d1 2c       	mov	r13, r1
    1a2e:	e1 2c       	mov	r14, r1
    1a30:	f1 2c       	mov	r15, r1
    1a32:	04 e0       	ldi	r16, 0x04	; 4
    1a34:	20 e0       	ldi	r18, 0x00	; 0
    1a36:	30 e0       	ldi	r19, 0x00	; 0
    1a38:	4c e2       	ldi	r20, 0x2C	; 44
    1a3a:	51 e0       	ldi	r21, 0x01	; 1
    1a3c:	6f e0       	ldi	r22, 0x0F	; 15
    1a3e:	72 e0       	ldi	r23, 0x02	; 2
    1a40:	8c e9       	ldi	r24, 0x9C	; 156
    1a42:	9c e0       	ldi	r25, 0x0C	; 12
    1a44:	0e 94 5e 19 	call	0x32bc	; 0x32bc <xTaskGenericCreate>
    1a48:	03 e0       	ldi	r16, 0x03	; 3
    xTaskCreate(vMainCommunicationTask, "Comm", 300, NULL, 3, NULL); // Dependant on ISR from UART, sends instructions to other tasks
    1a4a:	20 e0       	ldi	r18, 0x00	; 0
    1a4c:	30 e0       	ldi	r19, 0x00	; 0
    1a4e:	4c e2       	ldi	r20, 0x2C	; 44
    1a50:	51 e0       	ldi	r21, 0x01	; 1
    1a52:	68 e1       	ldi	r22, 0x18	; 24
    1a54:	72 e0       	ldi	r23, 0x02	; 2
    1a56:	85 ec       	ldi	r24, 0xC5	; 197
    1a58:	9b e0       	ldi	r25, 0x0B	; 11
    1a5a:	0e 94 5e 19 	call	0x32bc	; 0x32bc <xTaskGenericCreate>
    1a5e:	78 94       	sei
        xTaskCreate(compassTask, "compasscal", 3500, NULL, 3, NULL); // Task used for compass calibration, dependant on communication and movement task
    #endif
    */
    

    sei();
    1a60:	80 e0       	ldi	r24, 0x00	; 0
    vLED_singleLow(ledRED);
    1a62:	90 e0       	ldi	r25, 0x00	; 0
    1a64:	d1 dd       	rcall	.-1118   	; 0x1608 <vLED_singleLow>
    1a66:	0e 94 9a 1d 	call	0x3b34	; 0x3b34 <vTaskStartScheduler>
    #ifdef DEBUG
    debug("Starting scheduler ....\n");
    #endif
    //  Start scheduler 
    vTaskStartScheduler();
    1a6a:	cd e1       	ldi	r28, 0x1D	; 29
    1a6c:	d2 e0       	ldi	r29, 0x02	; 2

    //  MCU is out of RAM if the program comes here 
    while(1){
        cli();
        debug("RAM fail\n");
    1a6e:	f8 94       	cli
    1a70:	df 93       	push	r29
    //  Start scheduler 
    vTaskStartScheduler();

    //  MCU is out of RAM if the program comes here 
    while(1){
        cli();
    1a72:	cf 93       	push	r28
        debug("RAM fail\n");
    1a74:	0e 94 c4 17 	call	0x2f88	; 0x2f88 <debug>
    1a78:	0f 90       	pop	r0
    1a7a:	0f 90       	pop	r0
    1a7c:	f8 cf       	rjmp	.-16     	; 0x1a6e <main+0x10a>

00001a7e <__vector_4>:
    1a7e:	1f 92       	push	r1
    1a80:	0f 92       	push	r0

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	0f 92       	push	r0
    1a86:	11 24       	eor	r1, r1
    1a88:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    1a8a:	80 91 a1 15 	lds	r24, 0x15A1	; 0x8015a1 <gISR_leftWheelTicks>
    1a8e:	8f 5f       	subi	r24, 0xFF	; 255
    1a90:	80 93 a1 15 	sts	0x15A1, r24	; 0x8015a1 <gISR_leftWheelTicks>
}
    1a94:	8f 91       	pop	r24
    1a96:	0f 90       	pop	r0
    1a98:	0f be       	out	0x3f, r0	; 63
    1a9a:	0f 90       	pop	r0
    1a9c:	1f 90       	pop	r1
    1a9e:	18 95       	reti

00001aa0 <__vector_3>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    1aa0:	1f 92       	push	r1
    1aa2:	0f 92       	push	r0
    1aa4:	0f b6       	in	r0, 0x3f	; 63
    1aa6:	0f 92       	push	r0
    1aa8:	11 24       	eor	r1, r1
    1aaa:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    1aac:	80 91 a2 15 	lds	r24, 0x15A2	; 0x8015a2 <gISR_rightWheelTicks>
    1ab0:	8f 5f       	subi	r24, 0xFF	; 255
    1ab2:	80 93 a2 15 	sts	0x15A2, r24	; 0x8015a2 <gISR_rightWheelTicks>
}
    1ab6:	8f 91       	pop	r24
    1ab8:	0f 90       	pop	r0
    1aba:	0f be       	out	0x3f, r0	; 63
    1abc:	0f 90       	pop	r0
    1abe:	1f 90       	pop	r1
    1ac0:	18 95       	reti

00001ac2 <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    1ac2:	1f 92       	push	r1
    1ac4:	0f 92       	push	r0
    1ac6:	0f b6       	in	r0, 0x3f	; 63
    1ac8:	0f 92       	push	r0
    1aca:	11 24       	eor	r1, r1
    1acc:	0b b6       	in	r0, 0x3b	; 59
    1ace:	0f 92       	push	r0
    1ad0:	2f 93       	push	r18
    1ad2:	3f 93       	push	r19
    1ad4:	4f 93       	push	r20
    1ad6:	5f 93       	push	r21
    1ad8:	6f 93       	push	r22
    1ada:	7f 93       	push	r23
    1adc:	8f 93       	push	r24
    1ade:	9f 93       	push	r25
    1ae0:	af 93       	push	r26
    1ae2:	bf 93       	push	r27
    1ae4:	ef 93       	push	r30
    1ae6:	ff 93       	push	r31
    if (nRFconnected){
    1ae8:	64 99       	sbic	0x0c, 4	; 12
    1aea:	07 c0       	rjmp	.+14     	; 0x1afa <__vector_5+0x38>
        // indicate we are connected
        vLED_singleHigh(ledGREEN);
    1aec:	82 e0       	ldi	r24, 0x02	; 2
    1aee:	90 e0       	ldi	r25, 0x00	; 0
    1af0:	71 dd       	rcall	.-1310   	; 0x15d4 <vLED_singleHigh>
        vLED_singleHigh(ledYELLOW);
    1af2:	81 e0       	ldi	r24, 0x01	; 1
    1af4:	90 e0       	ldi	r25, 0x00	; 0
    1af6:	6e dd       	rcall	.-1316   	; 0x15d4 <vLED_singleHigh>
    1af8:	14 c0       	rjmp	.+40     	; 0x1b22 <__vector_5+0x60>
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    1afa:	10 92 a0 15 	sts	0x15A0, r1	; 0x8015a0 <gHandshook>
        gPaused = FALSE;
    1afe:	10 92 9f 15 	sts	0x159F, r1	; 0x80159f <gPaused>
        vLED_singleLow(ledGREEN);
    1b02:	82 e0       	ldi	r24, 0x02	; 2
    1b04:	90 e0       	ldi	r25, 0x00	; 0
    1b06:	80 dd       	rcall	.-1280   	; 0x1608 <vLED_singleLow>
        vLED_singleLow(ledYELLOW);
    1b08:	81 e0       	ldi	r24, 0x01	; 1
    1b0a:	90 e0       	ldi	r25, 0x00	; 0
    1b0c:	7d dd       	rcall	.-1286   	; 0x1608 <vLED_singleLow>
        vLED_singleLow(ledRED);
    1b0e:	80 e0       	ldi	r24, 0x00	; 0
    1b10:	90 e0       	ldi	r25, 0x00	; 0
    1b12:	7a dd       	rcall	.-1292   	; 0x1608 <vLED_singleLow>
    1b14:	60 e0       	ldi	r22, 0x00	; 0
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    1b16:	70 e0       	ldi	r23, 0x00	; 0
    1b18:	80 91 11 17 	lds	r24, 0x1711	; 0x801711 <xCommandReadyBSem>
    1b1c:	90 91 12 17 	lds	r25, 0x1712	; 0x801712 <xCommandReadyBSem+0x1>
    1b20:	dd d7       	rcall	.+4026   	; 0x2adc <xQueueGiveFromISR>
    1b22:	60 e0       	ldi	r22, 0x00	; 0
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    1b24:	70 e0       	ldi	r23, 0x00	; 0
    1b26:	80 91 0b 17 	lds	r24, 0x170B	; 0x80170b <xControllerBSem>
    1b2a:	90 91 0c 17 	lds	r25, 0x170C	; 0x80170c <xControllerBSem+0x1>
    1b2e:	d6 d7       	rcall	.+4012   	; 0x2adc <xQueueGiveFromISR>
    1b30:	ff 91       	pop	r31
}
    1b32:	ef 91       	pop	r30
    1b34:	bf 91       	pop	r27
    1b36:	af 91       	pop	r26
    1b38:	9f 91       	pop	r25
    1b3a:	8f 91       	pop	r24
    1b3c:	7f 91       	pop	r23
    1b3e:	6f 91       	pop	r22
    1b40:	5f 91       	pop	r21
    1b42:	4f 91       	pop	r20
    1b44:	3f 91       	pop	r19
    1b46:	2f 91       	pop	r18
    1b48:	0f 90       	pop	r0
    1b4a:	0b be       	out	0x3b, r0	; 59
    1b4c:	0f 90       	pop	r0
    1b4e:	0f be       	out	0x3f, r0	; 63
    1b50:	0f 90       	pop	r0
    1b52:	1f 90       	pop	r1
    1b54:	18 95       	reti

00001b56 <vMotor_init>:
    1b56:	27 9a       	sbi	0x04, 7	; 4
// Note: ISR Routines are in main.c
/************************************************************************/
void vMotor_init(){
    /* Initialize motor pins as output */
    DDRB |= (1<<motorLeftOn);
    DDRB |= (1<<motorLeftBackward) | (1<<motorLeftForward);
    1b58:	84 b1       	in	r24, 0x04	; 4
    1b5a:	80 63       	ori	r24, 0x30	; 48
    1b5c:	84 b9       	out	0x04, r24	; 4
    DDRB |= (1<<motorRightOn);
    1b5e:	26 9a       	sbi	0x04, 6	; 4
    DDRH |= (1<<motorRightForward) | (1<<motorRightBackward); 
    1b60:	e1 e0       	ldi	r30, 0x01	; 1
    1b62:	f1 e0       	ldi	r31, 0x01	; 1
    1b64:	80 81       	ld	r24, Z
    1b66:	80 66       	ori	r24, 0x60	; 96
    1b68:	80 83       	st	Z, r24
    
    /* Set motor high and direction low to ensure zero movement */
    PORTB &= ~(1<<motorLeftOn);
    1b6a:	2f 98       	cbi	0x05, 7	; 5
    PORTB &= ~(1<<motorRightOn);
    1b6c:	2e 98       	cbi	0x05, 6	; 5
    PORTH &= ~(1<<motorRightBackward) & ~(1<<motorRightForward);
    1b6e:	e2 e0       	ldi	r30, 0x02	; 2
    1b70:	f1 e0       	ldi	r31, 0x01	; 1
    1b72:	80 81       	ld	r24, Z
    1b74:	8f 79       	andi	r24, 0x9F	; 159
    1b76:	80 83       	st	Z, r24
    PORTB &= ~(1<<motorLeftForward) & ~(1<<motorLeftBackward);
    1b78:	85 b1       	in	r24, 0x05	; 5
    1b7a:	8f 7c       	andi	r24, 0xCF	; 207
    1b7c:	85 b9       	out	0x05, r24	; 5
    
    /* Initialize motor encoder pins as input */
    DDRD &= ~((1<<encoderPinRight) & (1<<encoderPinLeft));
    1b7e:	8a b1       	in	r24, 0x0a	; 10
    1b80:	8a b9       	out	0x0a, r24	; 10
    /* Enable pull up for encoder inputs */
    PORTD |= (1<<encoderPinLeft) | (1<<encoderPinRight);
    1b82:	8b b1       	in	r24, 0x0b	; 11
    1b84:	8c 60       	ori	r24, 0x0C	; 12
    1b86:	8b b9       	out	0x0b, r24	; 11
    
    /* nRF dongle pin 19 as input pin */    
    DDRE &= ~(1<<nRF19); // dongle pin input    
    1b88:	6c 98       	cbi	0x0d, 4	; 13
    
    /* Clear interrupt enable bits to ensure no interrupts occur */
    EIMSK &= ~((1<<INT2) & (1<<INT3) & (1<<INT4));
    1b8a:	8d b3       	in	r24, 0x1d	; 29
    1b8c:	8d bb       	out	0x1d, r24	; 29

    /* Set interrupt to trigger on rising edge for motor and any change for dongle */
    /* Datasheet p110-11 table 15-1,3 */
    EICRA |= (1<<ISC21) | (1<<ISC20) | (1<<ISC31) | (1<<ISC30);                             //MÅ KANKJSE SJEKKE UT DENNE NØYERE
    1b8e:	e9 e6       	ldi	r30, 0x69	; 105
    1b90:	f0 e0       	ldi	r31, 0x00	; 0
    1b92:	80 81       	ld	r24, Z
    1b94:	80 6f       	ori	r24, 0xF0	; 240
    1b96:	80 83       	st	Z, r24
    EICRB |= (1<<ISC40);
    1b98:	ea e6       	ldi	r30, 0x6A	; 106
    1b9a:	f0 e0       	ldi	r31, 0x00	; 0
    1b9c:	80 81       	ld	r24, Z
    1b9e:	81 60       	ori	r24, 0x01	; 1
    1ba0:	80 83       	st	Z, r24
    
    /* Clear interrupt flag for INT2, 3 and 4 */
    EIFR = (1<<INTF2) | (1<<INTF3) | (1<<INTF4);
    1ba2:	8c e1       	ldi	r24, 0x1C	; 28
    1ba4:	8c bb       	out	0x1c, r24	; 28

    /* Enable interrupts for INT2, 3 and 4 */
    EIMSK |= (1<<INT2) | (1<<INT3) | (1<<INT4);
    1ba6:	8d b3       	in	r24, 0x1d	; 29
    1ba8:	8c 61       	ori	r24, 0x1C	; 28
    1baa:	8d bb       	out	0x1d, r24	; 29
    /* Set up PWM for left motor connected to OC0A (8bit PWM) and right motor */
	/* connected to OC1B (16bit PWM)
    /* Clear OCnA/OCnB on Compare Match, set */
    /* OCnA/OCnB at BOTTOM (non-inverting mode) */
    /* Datasheet p.132 Table 14-3 */    
    TCCR0A |= (1<<COM0A1) | (0<<COM0A0);
    1bac:	84 b5       	in	r24, 0x24	; 36
    1bae:	80 68       	ori	r24, 0x80	; 128
    1bb0:	84 bd       	out	0x24, r24	; 36
    TCCR1A |= (1<<COM1B1) | (0<<COM1B1);
    1bb2:	e0 e8       	ldi	r30, 0x80	; 128
    1bb4:	f0 e0       	ldi	r31, 0x00	; 0
    1bb6:	80 81       	ld	r24, Z
    1bb8:	80 62       	ori	r24, 0x20	; 32
    1bba:	80 83       	st	Z, r24
    /* Waveform generation mode 3: Fast 8bit PWM */
    /* Top 0x00FF, Update bottom, flag set on top */
    /* Datasheet p.133 Table 14-5 */
	TCCR0B |= (0<<WGM02);
    1bbc:	85 b5       	in	r24, 0x25	; 37
    1bbe:	85 bd       	out	0x25, r24	; 37
    TCCR0A |= (1<<WGM01) | (1<<WGM00);
    1bc0:	84 b5       	in	r24, 0x24	; 36
    1bc2:	83 60       	ori	r24, 0x03	; 3
    1bc4:	84 bd       	out	0x24, r24	; 36
	
	TCCR1B |= (0<<WGM13) | (1<<WGM12);
    1bc6:	a1 e8       	ldi	r26, 0x81	; 129
    1bc8:	b0 e0       	ldi	r27, 0x00	; 0
    1bca:	8c 91       	ld	r24, X
    1bcc:	88 60       	ori	r24, 0x08	; 8
    1bce:	8c 93       	st	X, r24
	TCCR1A |= (0<<WGM11) | (1<<WGM10);
    1bd0:	80 81       	ld	r24, Z
    1bd2:	81 60       	ori	r24, 0x01	; 1
    1bd4:	80 83       	st	Z, r24
    
    /* Clock select bit description: */
    /* clkI/O/8 (From prescaler) - Datasheet p.157 Table 17-6*/
    TCCR0B |= (0<<CS02) | (1<<CS01) | (0<<CS00);
    1bd6:	85 b5       	in	r24, 0x25	; 37
    1bd8:	82 60       	ori	r24, 0x02	; 2
    1bda:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= (0<<CS12) | (1<<CS11) | (0<<CS10); 
    1bdc:	8c 91       	ld	r24, X
    1bde:	82 60       	ori	r24, 0x02	; 2
    1be0:	8c 93       	st	X, r24
	
	/* Set other motorpins to normal operation mode (connected to PWM ports)	*/
	/* Datasheet p.155 Table 17-3												*/
	
	TCCR1A |= (0<<COM1A1) | (0<<COM1A0); // MC_IN1 left backwards connected to OC1A
    1be2:	80 81       	ld	r24, Z
    1be4:	80 83       	st	Z, r24
	TCCR2A |= (0<<COM2A1) | (0<<COM2A0); // MC_IN1 left backwards connected to OC2A
    1be6:	e0 eb       	ldi	r30, 0xB0	; 176
    1be8:	f0 e0       	ldi	r31, 0x00	; 0
    1bea:	80 81       	ld	r24, Z
    1bec:	80 83       	st	Z, r24
	TCCR2A |= (0<<COM2B1) | (0<<COM2B0); // MC_IN1 left backwards connected to OC2B
    1bee:	80 81       	ld	r24, Z
    1bf0:	80 83       	st	Z, r24
	TCCR4A |= (0<<COM4C1) | (0<<COM4C0); // MC_IN1 left backwards connected to OC4C
    1bf2:	e0 ea       	ldi	r30, 0xA0	; 160
    1bf4:	f0 e0       	ldi	r31, 0x00	; 0
    1bf6:	80 81       	ld	r24, Z
    1bf8:	80 83       	st	Z, r24
    1bfa:	08 95       	ret

00001bfc <network_receive>:

uint8_t network_get_address(void) {
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
    1bfc:	ef 92       	push	r14
    1bfe:	ff 92       	push	r15
    1c00:	0f 93       	push	r16
    1c02:	1f 93       	push	r17
    1c04:	cf 93       	push	r28
    1c06:	df 93       	push	r29
    1c08:	7c 01       	movw	r14, r24
    1c0a:	8b 01       	movw	r16, r22
   uint8_t *decoded_data = pvPortMalloc(len);
    1c0c:	cb 01       	movw	r24, r22
    1c0e:	d6 d9       	rcall	.-3156   	; 0xfbc <pvPortMalloc>
    1c10:	ec 01       	movw	r28, r24
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    1c12:	98 01       	movw	r18, r16
    1c14:	21 50       	subi	r18, 0x01	; 1
    1c16:	31 09       	sbc	r19, r1
    1c18:	a7 01       	movw	r20, r14
    1c1a:	b8 01       	movw	r22, r16
    1c1c:	cf d8       	rcall	.-3682   	; 0xdbc <cobs_decode>
   static uint8_t cobs = 0;
   static uint8_t crc = 0;
   if(result.status != COBS_DECODE_OK) {
    1c1e:	88 23       	and	r24, r24
    1c20:	41 f0       	breq	.+16     	; 0x1c32 <network_receive+0x36>
	   ++cobs;
    1c22:	80 91 ac 15 	lds	r24, 0x15AC	; 0x8015ac <cobs.2024>
    1c26:	8f 5f       	subi	r24, 0xFF	; 255
    1c28:	80 93 ac 15 	sts	0x15AC, r24	; 0x8015ac <cobs.2024>
	   vPortFree(decoded_data);
    1c2c:	ce 01       	movw	r24, r28
    1c2e:	d0 da       	rcall	.-2656   	; 0x11d0 <vPortFree>
	   return;
    1c30:	2f c0       	rjmp	.+94     	; 0x1c90 <network_receive+0x94>
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
   uint8_t *decoded_data = pvPortMalloc(len);
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    1c32:	86 2f       	mov	r24, r22
    1c34:	97 2f       	mov	r25, r23
    1c36:	8c 01       	movw	r16, r24
   if(result.status != COBS_DECODE_OK) {
	   ++cobs;
	   vPortFree(decoded_data);
	   return;
   }
   if(decoded_data[result.out_len-1] != calculate_crc(decoded_data, result.out_len-1) ) {
    1c38:	fe 01       	movw	r30, r28
    1c3a:	e8 0f       	add	r30, r24
    1c3c:	f9 1f       	adc	r31, r25
    1c3e:	31 97       	sbiw	r30, 0x01	; 1
    1c40:	f0 80       	ld	r15, Z
    1c42:	6f ef       	ldi	r22, 0xFF	; 255
    1c44:	68 0f       	add	r22, r24
    1c46:	ce 01       	movw	r24, r28
    1c48:	43 d9       	rcall	.-3450   	; 0xed0 <calculate_crc>
    1c4a:	f8 16       	cp	r15, r24
    1c4c:	41 f0       	breq	.+16     	; 0x1c5e <network_receive+0x62>
	   ++crc;
    1c4e:	80 91 ab 15 	lds	r24, 0x15AB	; 0x8015ab <crc.2025>
    1c52:	8f 5f       	subi	r24, 0xFF	; 255
    1c54:	80 93 ab 15 	sts	0x15AB, r24	; 0x8015ab <crc.2025>
	   vPortFree(decoded_data);
    1c58:	ce 01       	movw	r24, r28
    1c5a:	ba da       	rcall	.-2700   	; 0x11d0 <vPortFree>
	   return;
   }
   uint8_t receiver = decoded_data[0];
   uint8_t sender = decoded_data[1];
   uint8_t protocol = decoded_data[2];
   if(receiver != ADDRESS) {
    1c5c:	19 c0       	rjmp	.+50     	; 0x1c90 <network_receive+0x94>
    1c5e:	88 81       	ld	r24, Y
    1c60:	83 30       	cpi	r24, 0x03	; 3
	   vPortFree(decoded_data);
    1c62:	19 f0       	breq	.+6      	; 0x1c6a <network_receive+0x6e>
    1c64:	ce 01       	movw	r24, r28
    1c66:	b4 da       	rcall	.-2712   	; 0x11d0 <vPortFree>
	   return;
    1c68:	13 c0       	rjmp	.+38     	; 0x1c90 <network_receive+0x94>
   }
   receive_callbacks[protocol](sender, decoded_data+3, result.out_len-4);
    1c6a:	a8 01       	movw	r20, r16
    1c6c:	44 50       	subi	r20, 0x04	; 4
    1c6e:	51 09       	sbc	r21, r1
    1c70:	be 01       	movw	r22, r28
    1c72:	6d 5f       	subi	r22, 0xFD	; 253
    1c74:	7f 4f       	sbci	r23, 0xFF	; 255
    1c76:	ea 81       	ldd	r30, Y+2	; 0x02
    1c78:	f0 e0       	ldi	r31, 0x00	; 0
    1c7a:	ee 0f       	add	r30, r30
    1c7c:	ff 1f       	adc	r31, r31
    1c7e:	ed 5c       	subi	r30, 0xCD	; 205
    1c80:	f8 4e       	sbci	r31, 0xE8	; 232
    1c82:	01 90       	ld	r0, Z+
    1c84:	f0 81       	ld	r31, Z
    1c86:	e0 2d       	mov	r30, r0
    1c88:	89 81       	ldd	r24, Y+1	; 0x01
   vPortFree(decoded_data);
    1c8a:	19 95       	eicall
    1c8c:	ce 01       	movw	r24, r28
    1c8e:	a0 da       	rcall	.-2752   	; 0x11d0 <vPortFree>
}
    1c90:	df 91       	pop	r29
    1c92:	cf 91       	pop	r28
    1c94:	1f 91       	pop	r17
    1c96:	0f 91       	pop	r16
    1c98:	ff 90       	pop	r15
    1c9a:	ef 90       	pop	r14
    1c9c:	08 95       	ret

00001c9e <network_init>:
void network_receive(uint8_t *frame, uint16_t len);

void (*receive_callbacks[10])(uint8_t, uint8_t*, uint16_t);

void network_init(void) {
  vUSART_set_receive_callback(network_receive);
    1c9e:	8e ef       	ldi	r24, 0xFE	; 254
    1ca0:	9d e0       	ldi	r25, 0x0D	; 13
    1ca2:	0c 94 2e 26 	jmp	0x4c5c	; 0x4c5c <vUSART_set_receive_callback>
    1ca6:	08 95       	ret

00001ca8 <network_set_callback>:
}

void network_set_callback(uint8_t protocol, void (*cb)(uint8_t, uint8_t*, uint16_t)) {
  if(protocol == PROTOCOL_ARQ || protocol == PROTOCOL_SIMPLE) receive_callbacks[protocol] = cb;
    1ca8:	82 30       	cpi	r24, 0x02	; 2
    1caa:	40 f4       	brcc	.+16     	; 0x1cbc <network_set_callback+0x14>
    1cac:	e8 2f       	mov	r30, r24
    1cae:	f0 e0       	ldi	r31, 0x00	; 0
    1cb0:	ee 0f       	add	r30, r30
    1cb2:	ff 1f       	adc	r31, r31
    1cb4:	ed 5c       	subi	r30, 0xCD	; 205
    1cb6:	f8 4e       	sbci	r31, 0xE8	; 232
    1cb8:	71 83       	std	Z+1, r23	; 0x01
    1cba:	60 83       	st	Z, r22
    1cbc:	08 95       	ret

00001cbe <network_send>:
}
    
uint8_t network_send(uint8_t remote_address, uint8_t protocol, uint8_t *data, uint16_t len) {
    1cbe:	8f 92       	push	r8
    1cc0:	9f 92       	push	r9
    1cc2:	af 92       	push	r10
    1cc4:	bf 92       	push	r11
    1cc6:	cf 92       	push	r12
    1cc8:	df 92       	push	r13
    1cca:	ef 92       	push	r14
    1ccc:	ff 92       	push	r15
    1cce:	0f 93       	push	r16
    1cd0:	1f 93       	push	r17
    1cd2:	cf 93       	push	r28
    1cd4:	df 93       	push	r29
    1cd6:	88 2e       	mov	r8, r24
    1cd8:	96 2e       	mov	r9, r22
    1cda:	5a 01       	movw	r10, r20
    1cdc:	89 01       	movw	r16, r18
  uint8_t *packet = pvPortMalloc(len+4);
    1cde:	69 01       	movw	r12, r18
    1ce0:	84 e0       	ldi	r24, 0x04	; 4
    1ce2:	c8 0e       	add	r12, r24
    1ce4:	d1 1c       	adc	r13, r1
    1ce6:	c6 01       	movw	r24, r12
    1ce8:	69 d9       	rcall	.-3374   	; 0xfbc <pvPortMalloc>
    1cea:	ec 01       	movw	r28, r24
  uint8_t *encoded_data = pvPortMalloc(len+6);
    1cec:	c8 01       	movw	r24, r16
    1cee:	06 96       	adiw	r24, 0x06	; 6
    1cf0:	65 d9       	rcall	.-3382   	; 0xfbc <pvPortMalloc>
    1cf2:	7c 01       	movw	r14, r24
  if(packet == NULL || encoded_data == NULL) {
    1cf4:	20 97       	sbiw	r28, 0x00	; 0
    1cf6:	11 f0       	breq	.+4      	; 0x1cfc <network_send+0x3e>
    1cf8:	89 2b       	or	r24, r25
    vPortFree(packet);
    1cfa:	31 f4       	brne	.+12     	; 0x1d08 <network_send+0x4a>
    1cfc:	ce 01       	movw	r24, r28
    vPortFree(encoded_data);
    1cfe:	68 da       	rcall	.-2864   	; 0x11d0 <vPortFree>
    1d00:	c7 01       	movw	r24, r14
    1d02:	66 da       	rcall	.-2868   	; 0x11d0 <vPortFree>
    return 0;
    1d04:	80 e0       	ldi	r24, 0x00	; 0
    1d06:	37 c0       	rjmp	.+110    	; 0x1d76 <network_send+0xb8>
  }
  packet[0] = remote_address;
    1d08:	88 82       	st	Y, r8
  packet[1] = ADDRESS;
    1d0a:	83 e0       	ldi	r24, 0x03	; 3
    1d0c:	89 83       	std	Y+1, r24	; 0x01
  packet[2] = protocol;
    1d0e:	9a 82       	std	Y+2, r9	; 0x02
  memcpy(packet+3, data, len);
    1d10:	a8 01       	movw	r20, r16
    1d12:	b5 01       	movw	r22, r10
    1d14:	ce 01       	movw	r24, r28
    1d16:	03 96       	adiw	r24, 0x03	; 3
    1d18:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
  packet[3+len] = calculate_crc(packet, 3+len);
    1d1c:	58 01       	movw	r10, r16
    1d1e:	e3 e0       	ldi	r30, 0x03	; 3
    1d20:	ae 0e       	add	r10, r30
    1d22:	b1 1c       	adc	r11, r1
    1d24:	ac 0e       	add	r10, r28
    1d26:	bd 1e       	adc	r11, r29
    1d28:	63 e0       	ldi	r22, 0x03	; 3
    1d2a:	60 0f       	add	r22, r16
    1d2c:	ce 01       	movw	r24, r28
    1d2e:	d0 d8       	rcall	.-3680   	; 0xed0 <calculate_crc>
    1d30:	f5 01       	movw	r30, r10
    1d32:	80 83       	st	Z, r24
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    1d34:	b8 01       	movw	r22, r16
    1d36:	6b 5f       	subi	r22, 0xFB	; 251
    1d38:	7f 4f       	sbci	r23, 0xFF	; 255
    1d3a:	96 01       	movw	r18, r12
    1d3c:	ae 01       	movw	r20, r28
    1d3e:	c7 01       	movw	r24, r14
    1d40:	0e 94 78 06 	call	0xcf0	; 0xcf0 <cobs_encode>
  if(result.status != COBS_ENCODE_OK) {
    vPortFree(packet);
    1d44:	88 23       	and	r24, r24
    1d46:	31 f0       	breq	.+12     	; 0x1d54 <network_send+0x96>
    1d48:	ce 01       	movw	r24, r28
    vPortFree(encoded_data);
    1d4a:	42 da       	rcall	.-2940   	; 0x11d0 <vPortFree>
    1d4c:	c7 01       	movw	r24, r14
    1d4e:	40 da       	rcall	.-2944   	; 0x11d0 <vPortFree>
    return 0;
    1d50:	80 e0       	ldi	r24, 0x00	; 0
    1d52:	11 c0       	rjmp	.+34     	; 0x1d76 <network_send+0xb8>
  packet[0] = remote_address;
  packet[1] = ADDRESS;
  packet[2] = protocol;
  memcpy(packet+3, data, len);
  packet[3+len] = calculate_crc(packet, 3+len);
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    1d54:	86 2f       	mov	r24, r22
    1d56:	97 2f       	mov	r25, r23
  if(result.status != COBS_ENCODE_OK) {
    vPortFree(packet);
    vPortFree(encoded_data);
    return 0;
  }
  encoded_data[result.out_len] = 0x00;
    1d58:	f7 01       	movw	r30, r14
    1d5a:	e8 0f       	add	r30, r24
    1d5c:	f9 1f       	adc	r31, r25
    1d5e:	10 82       	st	Z, r1
  vUSART_send(encoded_data, result.out_len+1);
    1d60:	bc 01       	movw	r22, r24
    1d62:	6f 5f       	subi	r22, 0xFF	; 255
    1d64:	7f 4f       	sbci	r23, 0xFF	; 255
    1d66:	c7 01       	movw	r24, r14
  vPortFree(packet);
    1d68:	0e 94 0a 26 	call	0x4c14	; 0x4c14 <vUSART_send>
    1d6c:	ce 01       	movw	r24, r28
  vPortFree(encoded_data);
    1d6e:	30 da       	rcall	.-2976   	; 0x11d0 <vPortFree>
    1d70:	c7 01       	movw	r24, r14
    1d72:	2e da       	rcall	.-2980   	; 0x11d0 <vPortFree>
  return 1;
    1d74:	81 e0       	ldi	r24, 0x01	; 1
}
    1d76:	df 91       	pop	r29
    1d78:	cf 91       	pop	r28
    1d7a:	1f 91       	pop	r17
    1d7c:	0f 91       	pop	r16
    1d7e:	ff 90       	pop	r15
    1d80:	ef 90       	pop	r14
    1d82:	df 90       	pop	r13
    1d84:	cf 90       	pop	r12
    1d86:	bf 90       	pop	r11
    1d88:	af 90       	pop	r10
    1d8a:	9f 90       	pop	r9
    1d8c:	8f 90       	pop	r8
    1d8e:	08 95       	ret

00001d90 <pxPortInitialiseStack>:
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    1d90:	31 e1       	ldi	r19, 0x11	; 17
    1d92:	fc 01       	movw	r30, r24
    1d94:	30 83       	st	Z, r19
    1d96:	31 97       	sbiw	r30, 0x01	; 1
    1d98:	22 e2       	ldi	r18, 0x22	; 34
    1d9a:	20 83       	st	Z, r18
    1d9c:	31 97       	sbiw	r30, 0x01	; 1
    1d9e:	a3 e3       	ldi	r26, 0x33	; 51
    1da0:	a0 83       	st	Z, r26
    1da2:	31 97       	sbiw	r30, 0x01	; 1
    1da4:	60 83       	st	Z, r22
    1da6:	31 97       	sbiw	r30, 0x01	; 1
    1da8:	70 83       	st	Z, r23
    1daa:	31 97       	sbiw	r30, 0x01	; 1
    1dac:	10 82       	st	Z, r1
    1dae:	31 97       	sbiw	r30, 0x01	; 1
    1db0:	10 82       	st	Z, r1
    1db2:	31 97       	sbiw	r30, 0x01	; 1
    1db4:	60 e8       	ldi	r22, 0x80	; 128
    1db6:	60 83       	st	Z, r22
    1db8:	31 97       	sbiw	r30, 0x01	; 1
    1dba:	10 82       	st	Z, r1
    1dbc:	31 97       	sbiw	r30, 0x01	; 1
    1dbe:	10 82       	st	Z, r1
    1dc0:	31 97       	sbiw	r30, 0x01	; 1
    1dc2:	10 82       	st	Z, r1
    1dc4:	31 97       	sbiw	r30, 0x01	; 1
    1dc6:	62 e0       	ldi	r22, 0x02	; 2
    1dc8:	60 83       	st	Z, r22
    1dca:	31 97       	sbiw	r30, 0x01	; 1
    1dcc:	63 e0       	ldi	r22, 0x03	; 3
    1dce:	60 83       	st	Z, r22
    1dd0:	31 97       	sbiw	r30, 0x01	; 1
    1dd2:	64 e0       	ldi	r22, 0x04	; 4
    1dd4:	60 83       	st	Z, r22
    1dd6:	31 97       	sbiw	r30, 0x01	; 1
    1dd8:	65 e0       	ldi	r22, 0x05	; 5
    1dda:	60 83       	st	Z, r22
    1ddc:	31 97       	sbiw	r30, 0x01	; 1
    1dde:	66 e0       	ldi	r22, 0x06	; 6
    1de0:	60 83       	st	Z, r22
    1de2:	31 97       	sbiw	r30, 0x01	; 1
    1de4:	67 e0       	ldi	r22, 0x07	; 7
    1de6:	60 83       	st	Z, r22
    1de8:	31 97       	sbiw	r30, 0x01	; 1
    1dea:	68 e0       	ldi	r22, 0x08	; 8
    1dec:	60 83       	st	Z, r22
    1dee:	31 97       	sbiw	r30, 0x01	; 1
    1df0:	69 e0       	ldi	r22, 0x09	; 9
    1df2:	60 83       	st	Z, r22
    1df4:	31 97       	sbiw	r30, 0x01	; 1
    1df6:	60 e1       	ldi	r22, 0x10	; 16
    1df8:	60 83       	st	Z, r22
    1dfa:	31 97       	sbiw	r30, 0x01	; 1
    1dfc:	30 83       	st	Z, r19
    1dfe:	31 97       	sbiw	r30, 0x01	; 1
    1e00:	32 e1       	ldi	r19, 0x12	; 18
    1e02:	30 83       	st	Z, r19
    1e04:	31 97       	sbiw	r30, 0x01	; 1
    1e06:	33 e1       	ldi	r19, 0x13	; 19
    1e08:	30 83       	st	Z, r19
    1e0a:	31 97       	sbiw	r30, 0x01	; 1
    1e0c:	34 e1       	ldi	r19, 0x14	; 20
    1e0e:	30 83       	st	Z, r19
    1e10:	31 97       	sbiw	r30, 0x01	; 1
    1e12:	35 e1       	ldi	r19, 0x15	; 21
    1e14:	30 83       	st	Z, r19
    1e16:	31 97       	sbiw	r30, 0x01	; 1
    1e18:	36 e1       	ldi	r19, 0x16	; 22
    1e1a:	30 83       	st	Z, r19
    1e1c:	31 97       	sbiw	r30, 0x01	; 1
    1e1e:	37 e1       	ldi	r19, 0x17	; 23
    1e20:	30 83       	st	Z, r19
    1e22:	31 97       	sbiw	r30, 0x01	; 1
    1e24:	38 e1       	ldi	r19, 0x18	; 24
    1e26:	30 83       	st	Z, r19
    1e28:	31 97       	sbiw	r30, 0x01	; 1
    1e2a:	39 e1       	ldi	r19, 0x19	; 25
    1e2c:	30 83       	st	Z, r19
    1e2e:	31 97       	sbiw	r30, 0x01	; 1
    1e30:	30 e2       	ldi	r19, 0x20	; 32
    1e32:	30 83       	st	Z, r19
    1e34:	31 97       	sbiw	r30, 0x01	; 1
    1e36:	31 e2       	ldi	r19, 0x21	; 33
    1e38:	30 83       	st	Z, r19
    1e3a:	31 97       	sbiw	r30, 0x01	; 1
    1e3c:	20 83       	st	Z, r18
    1e3e:	31 97       	sbiw	r30, 0x01	; 1
    1e40:	23 e2       	ldi	r18, 0x23	; 35
    1e42:	20 83       	st	Z, r18
    1e44:	31 97       	sbiw	r30, 0x01	; 1
    1e46:	40 83       	st	Z, r20
    1e48:	31 97       	sbiw	r30, 0x01	; 1
    1e4a:	50 83       	st	Z, r21
    1e4c:	31 97       	sbiw	r30, 0x01	; 1
    1e4e:	26 e2       	ldi	r18, 0x26	; 38
    1e50:	20 83       	st	Z, r18
    1e52:	31 97       	sbiw	r30, 0x01	; 1
    1e54:	27 e2       	ldi	r18, 0x27	; 39
    1e56:	20 83       	st	Z, r18
    1e58:	31 97       	sbiw	r30, 0x01	; 1
    1e5a:	28 e2       	ldi	r18, 0x28	; 40
    1e5c:	20 83       	st	Z, r18
    1e5e:	31 97       	sbiw	r30, 0x01	; 1
    1e60:	29 e2       	ldi	r18, 0x29	; 41
    1e62:	20 83       	st	Z, r18
    1e64:	31 97       	sbiw	r30, 0x01	; 1
    1e66:	20 e3       	ldi	r18, 0x30	; 48
    1e68:	20 83       	st	Z, r18
    1e6a:	31 97       	sbiw	r30, 0x01	; 1
    1e6c:	21 e3       	ldi	r18, 0x31	; 49
    1e6e:	20 83       	st	Z, r18
    1e70:	89 97       	sbiw	r24, 0x29	; 41
    1e72:	08 95       	ret

00001e74 <xPortStartScheduler>:
    1e74:	88 ee       	ldi	r24, 0xE8	; 232
    1e76:	93 e0       	ldi	r25, 0x03	; 3
    1e78:	90 93 48 17 	sts	0x1748, r25	; 0x801748 <portTickRateHz+0x1>
    1e7c:	80 93 47 17 	sts	0x1747, r24	; 0x801747 <portTickRateHz>
    1e80:	90 93 4a 17 	sts	0x174A, r25	; 0x80174a <ticksRemainingInSec+0x1>
    1e84:	80 93 49 17 	sts	0x1749, r24	; 0x801749 <ticksRemainingInSec>
    1e88:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    1e8c:	89 ef       	ldi	r24, 0xF9	; 249
    1e8e:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
    1e92:	8b e0       	ldi	r24, 0x0B	; 11
    1e94:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    1e98:	e1 e7       	ldi	r30, 0x71	; 113
    1e9a:	f0 e0       	ldi	r31, 0x00	; 0
    1e9c:	80 81       	ld	r24, Z
    1e9e:	82 60       	ori	r24, 0x02	; 2
    1ea0:	80 83       	st	Z, r24
    1ea2:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    1ea6:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    1eaa:	cd 91       	ld	r28, X+
    1eac:	cd bf       	out	0x3d, r28	; 61
    1eae:	dd 91       	ld	r29, X+
    1eb0:	de bf       	out	0x3e, r29	; 62
    1eb2:	ff 91       	pop	r31
    1eb4:	ef 91       	pop	r30
    1eb6:	df 91       	pop	r29
    1eb8:	cf 91       	pop	r28
    1eba:	bf 91       	pop	r27
    1ebc:	af 91       	pop	r26
    1ebe:	9f 91       	pop	r25
    1ec0:	8f 91       	pop	r24
    1ec2:	7f 91       	pop	r23
    1ec4:	6f 91       	pop	r22
    1ec6:	5f 91       	pop	r21
    1ec8:	4f 91       	pop	r20
    1eca:	3f 91       	pop	r19
    1ecc:	2f 91       	pop	r18
    1ece:	1f 91       	pop	r17
    1ed0:	0f 91       	pop	r16
    1ed2:	ff 90       	pop	r15
    1ed4:	ef 90       	pop	r14
    1ed6:	df 90       	pop	r13
    1ed8:	cf 90       	pop	r12
    1eda:	bf 90       	pop	r11
    1edc:	af 90       	pop	r10
    1ede:	9f 90       	pop	r9
    1ee0:	8f 90       	pop	r8
    1ee2:	7f 90       	pop	r7
    1ee4:	6f 90       	pop	r6
    1ee6:	5f 90       	pop	r5
    1ee8:	4f 90       	pop	r4
    1eea:	3f 90       	pop	r3
    1eec:	2f 90       	pop	r2
    1eee:	1f 90       	pop	r1
    1ef0:	0f 90       	pop	r0
    1ef2:	0c be       	out	0x3c, r0	; 60
    1ef4:	0f 90       	pop	r0
    1ef6:	0b be       	out	0x3b, r0	; 59
    1ef8:	0f 90       	pop	r0
    1efa:	0f be       	out	0x3f, r0	; 63
    1efc:	0f 90       	pop	r0
    1efe:	08 95       	ret
    1f00:	81 e0       	ldi	r24, 0x01	; 1
    1f02:	08 95       	ret

00001f04 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1f04:	0f 92       	push	r0
    1f06:	0f b6       	in	r0, 0x3f	; 63
    1f08:	f8 94       	cli
    1f0a:	0f 92       	push	r0
    1f0c:	0b b6       	in	r0, 0x3b	; 59
    1f0e:	0f 92       	push	r0
    1f10:	0c b6       	in	r0, 0x3c	; 60
    1f12:	0f 92       	push	r0
    1f14:	1f 92       	push	r1
    1f16:	11 24       	eor	r1, r1
    1f18:	2f 92       	push	r2
    1f1a:	3f 92       	push	r3
    1f1c:	4f 92       	push	r4
    1f1e:	5f 92       	push	r5
    1f20:	6f 92       	push	r6
    1f22:	7f 92       	push	r7
    1f24:	8f 92       	push	r8
    1f26:	9f 92       	push	r9
    1f28:	af 92       	push	r10
    1f2a:	bf 92       	push	r11
    1f2c:	cf 92       	push	r12
    1f2e:	df 92       	push	r13
    1f30:	ef 92       	push	r14
    1f32:	ff 92       	push	r15
    1f34:	0f 93       	push	r16
    1f36:	1f 93       	push	r17
    1f38:	2f 93       	push	r18
    1f3a:	3f 93       	push	r19
    1f3c:	4f 93       	push	r20
    1f3e:	5f 93       	push	r21
    1f40:	6f 93       	push	r22
    1f42:	7f 93       	push	r23
    1f44:	8f 93       	push	r24
    1f46:	9f 93       	push	r25
    1f48:	af 93       	push	r26
    1f4a:	bf 93       	push	r27
    1f4c:	cf 93       	push	r28
    1f4e:	df 93       	push	r29
    1f50:	ef 93       	push	r30
    1f52:	ff 93       	push	r31
    1f54:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    1f58:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    1f5c:	0d b6       	in	r0, 0x3d	; 61
    1f5e:	0d 92       	st	X+, r0
    1f60:	0e b6       	in	r0, 0x3e	; 62
    1f62:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1f64:	0e 94 8a 20 	call	0x4114	; 0x4114 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1f68:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    1f6c:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    1f70:	cd 91       	ld	r28, X+
    1f72:	cd bf       	out	0x3d, r28	; 61
    1f74:	dd 91       	ld	r29, X+
    1f76:	de bf       	out	0x3e, r29	; 62
    1f78:	ff 91       	pop	r31
    1f7a:	ef 91       	pop	r30
    1f7c:	df 91       	pop	r29
    1f7e:	cf 91       	pop	r28
    1f80:	bf 91       	pop	r27
    1f82:	af 91       	pop	r26
    1f84:	9f 91       	pop	r25
    1f86:	8f 91       	pop	r24
    1f88:	7f 91       	pop	r23
    1f8a:	6f 91       	pop	r22
    1f8c:	5f 91       	pop	r21
    1f8e:	4f 91       	pop	r20
    1f90:	3f 91       	pop	r19
    1f92:	2f 91       	pop	r18
    1f94:	1f 91       	pop	r17
    1f96:	0f 91       	pop	r16
    1f98:	ff 90       	pop	r15
    1f9a:	ef 90       	pop	r14
    1f9c:	df 90       	pop	r13
    1f9e:	cf 90       	pop	r12
    1fa0:	bf 90       	pop	r11
    1fa2:	af 90       	pop	r10
    1fa4:	9f 90       	pop	r9
    1fa6:	8f 90       	pop	r8
    1fa8:	7f 90       	pop	r7
    1faa:	6f 90       	pop	r6
    1fac:	5f 90       	pop	r5
    1fae:	4f 90       	pop	r4
    1fb0:	3f 90       	pop	r3
    1fb2:	2f 90       	pop	r2
    1fb4:	1f 90       	pop	r1
    1fb6:	0f 90       	pop	r0
    1fb8:	0c be       	out	0x3c, r0	; 60
    1fba:	0f 90       	pop	r0
    1fbc:	0b be       	out	0x3b, r0	; 59
    1fbe:	0f 90       	pop	r0
    1fc0:	0f be       	out	0x3f, r0	; 63
    1fc2:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1fc4:	08 95       	ret

00001fc6 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1fc6:	0f 92       	push	r0
    1fc8:	0f b6       	in	r0, 0x3f	; 63
    1fca:	f8 94       	cli
    1fcc:	0f 92       	push	r0
    1fce:	0b b6       	in	r0, 0x3b	; 59
    1fd0:	0f 92       	push	r0
    1fd2:	0c b6       	in	r0, 0x3c	; 60
    1fd4:	0f 92       	push	r0
    1fd6:	1f 92       	push	r1
    1fd8:	11 24       	eor	r1, r1
    1fda:	2f 92       	push	r2
    1fdc:	3f 92       	push	r3
    1fde:	4f 92       	push	r4
    1fe0:	5f 92       	push	r5
    1fe2:	6f 92       	push	r6
    1fe4:	7f 92       	push	r7
    1fe6:	8f 92       	push	r8
    1fe8:	9f 92       	push	r9
    1fea:	af 92       	push	r10
    1fec:	bf 92       	push	r11
    1fee:	cf 92       	push	r12
    1ff0:	df 92       	push	r13
    1ff2:	ef 92       	push	r14
    1ff4:	ff 92       	push	r15
    1ff6:	0f 93       	push	r16
    1ff8:	1f 93       	push	r17
    1ffa:	2f 93       	push	r18
    1ffc:	3f 93       	push	r19
    1ffe:	4f 93       	push	r20
    2000:	5f 93       	push	r21
    2002:	6f 93       	push	r22
    2004:	7f 93       	push	r23
    2006:	8f 93       	push	r24
    2008:	9f 93       	push	r25
    200a:	af 93       	push	r26
    200c:	bf 93       	push	r27
    200e:	cf 93       	push	r28
    2010:	df 93       	push	r29
    2012:	ef 93       	push	r30
    2014:	ff 93       	push	r31
    2016:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    201a:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    201e:	0d b6       	in	r0, 0x3d	; 61
    2020:	0d 92       	st	X+, r0
    2022:	0e b6       	in	r0, 0x3e	; 62
    2024:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    2026:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    2028:	80 91 49 17 	lds	r24, 0x1749	; 0x801749 <ticksRemainingInSec>
    202c:	90 91 4a 17 	lds	r25, 0x174A	; 0x80174a <ticksRemainingInSec+0x1>
    2030:	01 97       	sbiw	r24, 0x01	; 1
    2032:	90 93 4a 17 	sts	0x174A, r25	; 0x80174a <ticksRemainingInSec+0x1>
    2036:	80 93 49 17 	sts	0x1749, r24	; 0x801749 <ticksRemainingInSec>
    203a:	89 2b       	or	r24, r25
    203c:	41 f4       	brne	.+16     	; 0x204e <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    203e:	80 91 47 17 	lds	r24, 0x1747	; 0x801747 <portTickRateHz>
    2042:	90 91 48 17 	lds	r25, 0x1748	; 0x801748 <portTickRateHz+0x1>
    2046:	90 93 4a 17 	sts	0x174A, r25	; 0x80174a <ticksRemainingInSec+0x1>
    204a:	80 93 49 17 	sts	0x1749, r24	; 0x801749 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    204e:	0e 94 c9 1f 	call	0x3f92	; 0x3f92 <xTaskIncrementTick>
    2052:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    2054:	0e 94 8a 20 	call	0x4114	; 0x4114 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    2058:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    205c:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    2060:	cd 91       	ld	r28, X+
    2062:	cd bf       	out	0x3d, r28	; 61
    2064:	dd 91       	ld	r29, X+
    2066:	de bf       	out	0x3e, r29	; 62
    2068:	ff 91       	pop	r31
    206a:	ef 91       	pop	r30
    206c:	df 91       	pop	r29
    206e:	cf 91       	pop	r28
    2070:	bf 91       	pop	r27
    2072:	af 91       	pop	r26
    2074:	9f 91       	pop	r25
    2076:	8f 91       	pop	r24
    2078:	7f 91       	pop	r23
    207a:	6f 91       	pop	r22
    207c:	5f 91       	pop	r21
    207e:	4f 91       	pop	r20
    2080:	3f 91       	pop	r19
    2082:	2f 91       	pop	r18
    2084:	1f 91       	pop	r17
    2086:	0f 91       	pop	r16
    2088:	ff 90       	pop	r15
    208a:	ef 90       	pop	r14
    208c:	df 90       	pop	r13
    208e:	cf 90       	pop	r12
    2090:	bf 90       	pop	r11
    2092:	af 90       	pop	r10
    2094:	9f 90       	pop	r9
    2096:	8f 90       	pop	r8
    2098:	7f 90       	pop	r7
    209a:	6f 90       	pop	r6
    209c:	5f 90       	pop	r5
    209e:	4f 90       	pop	r4
    20a0:	3f 90       	pop	r3
    20a2:	2f 90       	pop	r2
    20a4:	1f 90       	pop	r1
    20a6:	0f 90       	pop	r0
    20a8:	0c be       	out	0x3c, r0	; 60
    20aa:	0f 90       	pop	r0
    20ac:	0b be       	out	0x3b, r0	; 59
    20ae:	0f 90       	pop	r0
    20b0:	0f be       	out	0x3f, r0	; 63
    20b2:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    20b4:	08 95       	ret

000020b6 <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    20b6:	87 df       	rcall	.-242    	; 0x1fc6 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    20b8:	18 95       	reti

000020ba <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    20ba:	0f 93       	push	r16
    20bc:	1f 93       	push	r17
    20be:	cf 93       	push	r28
    20c0:	df 93       	push	r29
    20c2:	08 2f       	mov	r16, r24
    20c4:	16 2f       	mov	r17, r22
    20c6:	66 23       	and	r22, r22
    20c8:	09 f4       	brne	.+2      	; 0x20cc <xQueueGenericCreate+0x12>
    20ca:	39 c0       	rjmp	.+114    	; 0x213e <xQueueGenericCreate+0x84>
    20cc:	86 9f       	mul	r24, r22
    20ce:	c0 01       	movw	r24, r0
    20d0:	11 24       	eor	r1, r1
    20d2:	80 96       	adiw	r24, 0x20	; 32
    20d4:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
    20d8:	ec 01       	movw	r28, r24
    20da:	00 97       	sbiw	r24, 0x00	; 0
    20dc:	21 f4       	brne	.+8      	; 0x20e6 <xQueueGenericCreate+0x2c>
    20de:	37 c0       	rjmp	.+110    	; 0x214e <xQueueGenericCreate+0x94>
    20e0:	d9 83       	std	Y+1, r29	; 0x01
    20e2:	c8 83       	st	Y, r28
    20e4:	03 c0       	rjmp	.+6      	; 0x20ec <xQueueGenericCreate+0x32>
    20e6:	4f 96       	adiw	r24, 0x1f	; 31
    20e8:	99 83       	std	Y+1, r25	; 0x01
    20ea:	88 83       	st	Y, r24
    20ec:	0b 8f       	std	Y+27, r16	; 0x1b
    20ee:	1c 8f       	std	Y+28, r17	; 0x1c
    20f0:	0f b6       	in	r0, 0x3f	; 63
    20f2:	f8 94       	cli
    20f4:	0f 92       	push	r0
    20f6:	48 81       	ld	r20, Y
    20f8:	59 81       	ldd	r21, Y+1	; 0x01
    20fa:	2c 8d       	ldd	r18, Y+28	; 0x1c
    20fc:	30 e0       	ldi	r19, 0x00	; 0
    20fe:	6b 8d       	ldd	r22, Y+27	; 0x1b
    2100:	62 9f       	mul	r22, r18
    2102:	c0 01       	movw	r24, r0
    2104:	63 9f       	mul	r22, r19
    2106:	90 0d       	add	r25, r0
    2108:	11 24       	eor	r1, r1
    210a:	ba 01       	movw	r22, r20
    210c:	68 0f       	add	r22, r24
    210e:	79 1f       	adc	r23, r25
    2110:	7b 83       	std	Y+3, r23	; 0x03
    2112:	6a 83       	std	Y+2, r22	; 0x02
    2114:	1a 8e       	std	Y+26, r1	; 0x1a
    2116:	5d 83       	std	Y+5, r21	; 0x05
    2118:	4c 83       	std	Y+4, r20	; 0x04
    211a:	82 1b       	sub	r24, r18
    211c:	93 0b       	sbc	r25, r19
    211e:	84 0f       	add	r24, r20
    2120:	95 1f       	adc	r25, r21
    2122:	9f 83       	std	Y+7, r25	; 0x07
    2124:	8e 83       	std	Y+6, r24	; 0x06
    2126:	8f ef       	ldi	r24, 0xFF	; 255
    2128:	8d 8f       	std	Y+29, r24	; 0x1d
    212a:	8e 8f       	std	Y+30, r24	; 0x1e
    212c:	ce 01       	movw	r24, r28
    212e:	08 96       	adiw	r24, 0x08	; 8
    2130:	a2 da       	rcall	.-2748   	; 0x1676 <vListInitialise>
    2132:	ce 01       	movw	r24, r28
    2134:	41 96       	adiw	r24, 0x11	; 17
    2136:	9f da       	rcall	.-2754   	; 0x1676 <vListInitialise>
    2138:	0f 90       	pop	r0
    213a:	0f be       	out	0x3f, r0	; 63
    213c:	08 c0       	rjmp	.+16     	; 0x214e <xQueueGenericCreate+0x94>
    213e:	8f e1       	ldi	r24, 0x1F	; 31
    2140:	90 e0       	ldi	r25, 0x00	; 0
    2142:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
    2146:	ec 01       	movw	r28, r24
    2148:	89 2b       	or	r24, r25
    214a:	09 f0       	breq	.+2      	; 0x214e <xQueueGenericCreate+0x94>
    214c:	c9 cf       	rjmp	.-110    	; 0x20e0 <xQueueGenericCreate+0x26>
    214e:	ce 01       	movw	r24, r28
    2150:	df 91       	pop	r29
    2152:	cf 91       	pop	r28
    2154:	1f 91       	pop	r17
    2156:	0f 91       	pop	r16
    2158:	08 95       	ret

0000215a <xQueueCreateMutex>:
    215a:	9f 92       	push	r9
    215c:	af 92       	push	r10
    215e:	bf 92       	push	r11
    2160:	cf 92       	push	r12
    2162:	df 92       	push	r13
    2164:	ef 92       	push	r14
    2166:	ff 92       	push	r15
    2168:	0f 93       	push	r16
    216a:	1f 93       	push	r17
    216c:	cf 93       	push	r28
    216e:	df 93       	push	r29
    2170:	00 d0       	rcall	.+0      	; 0x2172 <xQueueCreateMutex+0x18>
    2172:	1f 92       	push	r1
    2174:	1f 92       	push	r1
    2176:	cd b7       	in	r28, 0x3d	; 61
    2178:	de b7       	in	r29, 0x3e	; 62
    217a:	8f e1       	ldi	r24, 0x1F	; 31
    217c:	90 e0       	ldi	r25, 0x00	; 0
    217e:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
    2182:	8c 01       	movw	r16, r24
    2184:	00 97       	sbiw	r24, 0x00	; 0
    2186:	09 f4       	brne	.+2      	; 0x218a <xQueueCreateMutex+0x30>
    2188:	56 c1       	rjmp	.+684    	; 0x2436 <__stack+0x237>
    218a:	fc 01       	movw	r30, r24
    218c:	13 82       	std	Z+3, r1	; 0x03
    218e:	12 82       	std	Z+2, r1	; 0x02
    2190:	11 82       	std	Z+1, r1	; 0x01
    2192:	10 82       	st	Z, r1
    2194:	15 82       	std	Z+5, r1	; 0x05
    2196:	14 82       	std	Z+4, r1	; 0x04
    2198:	17 82       	std	Z+7, r1	; 0x07
    219a:	16 82       	std	Z+6, r1	; 0x06
    219c:	12 8e       	std	Z+26, r1	; 0x1a
    219e:	81 e0       	ldi	r24, 0x01	; 1
    21a0:	83 8f       	std	Z+27, r24	; 0x1b
    21a2:	14 8e       	std	Z+28, r1	; 0x1c
    21a4:	8f ef       	ldi	r24, 0xFF	; 255
    21a6:	85 8f       	std	Z+29, r24	; 0x1d
    21a8:	86 8f       	std	Z+30, r24	; 0x1e
    21aa:	78 01       	movw	r14, r16
    21ac:	f8 e0       	ldi	r31, 0x08	; 8
    21ae:	ef 0e       	add	r14, r31
    21b0:	f1 1c       	adc	r15, r1
    21b2:	c7 01       	movw	r24, r14
    21b4:	60 da       	rcall	.-2880   	; 0x1676 <vListInitialise>
    21b6:	68 01       	movw	r12, r16
    21b8:	81 e1       	ldi	r24, 0x11	; 17
    21ba:	c8 0e       	add	r12, r24
    21bc:	d1 1c       	adc	r13, r1
    21be:	c6 01       	movw	r24, r12
    21c0:	5a da       	rcall	.-2892   	; 0x1676 <vListInitialise>
    21c2:	1d 82       	std	Y+5, r1	; 0x05
    21c4:	1c 82       	std	Y+4, r1	; 0x04
    21c6:	a1 2c       	mov	r10, r1
    21c8:	99 24       	eor	r9, r9
    21ca:	93 94       	inc	r9
    21cc:	bb 24       	eor	r11, r11
    21ce:	ba 94       	dec	r11
    21d0:	0f b6       	in	r0, 0x3f	; 63
    21d2:	f8 94       	cli
    21d4:	0f 92       	push	r0
    21d6:	f8 01       	movw	r30, r16
    21d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    21da:	83 8d       	ldd	r24, Z+27	; 0x1b
    21dc:	98 17       	cp	r25, r24
    21de:	f0 f4       	brcc	.+60     	; 0x221c <__stack+0x1d>
    21e0:	80 81       	ld	r24, Z
    21e2:	91 81       	ldd	r25, Z+1	; 0x01
    21e4:	89 2b       	or	r24, r25
    21e6:	09 f0       	breq	.+2      	; 0x21ea <xQueueCreateMutex+0x90>
    21e8:	1d c1       	rjmp	.+570    	; 0x2424 <__stack+0x225>
    21ea:	82 81       	ldd	r24, Z+2	; 0x02
    21ec:	93 81       	ldd	r25, Z+3	; 0x03
    21ee:	0e 94 66 22 	call	0x44cc	; 0x44cc <xTaskPriorityDisinherit>
    21f2:	f8 01       	movw	r30, r16
    21f4:	13 82       	std	Z+3, r1	; 0x03
    21f6:	12 82       	std	Z+2, r1	; 0x02
    21f8:	92 8d       	ldd	r25, Z+26	; 0x1a
    21fa:	9f 5f       	subi	r25, 0xFF	; 255
    21fc:	92 8f       	std	Z+26, r25	; 0x1a
    21fe:	91 89       	ldd	r25, Z+17	; 0x11
    2200:	99 23       	and	r25, r25
    2202:	39 f0       	breq	.+14     	; 0x2212 <__stack+0x13>
    2204:	c6 01       	movw	r24, r12
    2206:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    220a:	81 30       	cpi	r24, 0x01	; 1
    220c:	21 f4       	brne	.+8      	; 0x2216 <__stack+0x17>
    220e:	7a de       	rcall	.-780    	; 0x1f04 <vPortYield>
    2210:	02 c0       	rjmp	.+4      	; 0x2216 <__stack+0x17>
    2212:	81 11       	cpse	r24, r1
    2214:	77 de       	rcall	.-786    	; 0x1f04 <vPortYield>
    2216:	0f 90       	pop	r0
    2218:	0f be       	out	0x3f, r0	; 63
    221a:	0d c1       	rjmp	.+538    	; 0x2436 <__stack+0x237>
    221c:	8c 81       	ldd	r24, Y+4	; 0x04
    221e:	9d 81       	ldd	r25, Y+5	; 0x05
    2220:	89 2b       	or	r24, r25
    2222:	19 f4       	brne	.+6      	; 0x222a <__stack+0x2b>
    2224:	0f 90       	pop	r0
    2226:	0f be       	out	0x3f, r0	; 63
    2228:	06 c1       	rjmp	.+524    	; 0x2436 <__stack+0x237>
    222a:	a1 10       	cpse	r10, r1
    222c:	05 c0       	rjmp	.+10     	; 0x2238 <__stack+0x39>
    222e:	ce 01       	movw	r24, r28
    2230:	01 96       	adiw	r24, 0x01	; 1
    2232:	0e 94 b5 21 	call	0x436a	; 0x436a <vTaskSetTimeOutState>
    2236:	a9 2c       	mov	r10, r9
    2238:	0f 90       	pop	r0
    223a:	0f be       	out	0x3f, r0	; 63
    223c:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <vTaskSuspendAll>
    2240:	0f b6       	in	r0, 0x3f	; 63
    2242:	f8 94       	cli
    2244:	0f 92       	push	r0
    2246:	f8 01       	movw	r30, r16
    2248:	85 8d       	ldd	r24, Z+29	; 0x1d
    224a:	8f 3f       	cpi	r24, 0xFF	; 255
    224c:	09 f4       	brne	.+2      	; 0x2250 <__stack+0x51>
    224e:	15 8e       	std	Z+29, r1	; 0x1d
    2250:	f8 01       	movw	r30, r16
    2252:	86 8d       	ldd	r24, Z+30	; 0x1e
    2254:	8f 3f       	cpi	r24, 0xFF	; 255
    2256:	09 f4       	brne	.+2      	; 0x225a <__stack+0x5b>
    2258:	16 8e       	std	Z+30, r1	; 0x1e
    225a:	0f 90       	pop	r0
    225c:	0f be       	out	0x3f, r0	; 63
    225e:	be 01       	movw	r22, r28
    2260:	6c 5f       	subi	r22, 0xFC	; 252
    2262:	7f 4f       	sbci	r23, 0xFF	; 255
    2264:	ce 01       	movw	r24, r28
    2266:	01 96       	adiw	r24, 0x01	; 1
    2268:	0e 94 c0 21 	call	0x4380	; 0x4380 <xTaskCheckForTimeOut>
    226c:	81 11       	cpse	r24, r1
    226e:	96 c0       	rjmp	.+300    	; 0x239c <__stack+0x19d>
    2270:	0f b6       	in	r0, 0x3f	; 63
    2272:	f8 94       	cli
    2274:	0f 92       	push	r0
    2276:	f8 01       	movw	r30, r16
    2278:	92 8d       	ldd	r25, Z+26	; 0x1a
    227a:	83 8d       	ldd	r24, Z+27	; 0x1b
    227c:	0f 90       	pop	r0
    227e:	0f be       	out	0x3f, r0	; 63
    2280:	98 13       	cpse	r25, r24
    2282:	4a c0       	rjmp	.+148    	; 0x2318 <__stack+0x119>
    2284:	6c 81       	ldd	r22, Y+4	; 0x04
    2286:	7d 81       	ldd	r23, Y+5	; 0x05
    2288:	c7 01       	movw	r24, r14
    228a:	0e 94 12 21 	call	0x4224	; 0x4224 <vTaskPlaceOnEventList>
    228e:	0f b6       	in	r0, 0x3f	; 63
    2290:	f8 94       	cli
    2292:	0f 92       	push	r0
    2294:	f8 01       	movw	r30, r16
    2296:	86 8d       	ldd	r24, Z+30	; 0x1e
    2298:	18 16       	cp	r1, r24
    229a:	ac f4       	brge	.+42     	; 0x22c6 <__stack+0xc7>
    229c:	81 89       	ldd	r24, Z+17	; 0x11
    229e:	81 11       	cpse	r24, r1
    22a0:	05 c0       	rjmp	.+10     	; 0x22ac <__stack+0xad>
    22a2:	11 c0       	rjmp	.+34     	; 0x22c6 <__stack+0xc7>
    22a4:	f8 01       	movw	r30, r16
    22a6:	81 89       	ldd	r24, Z+17	; 0x11
    22a8:	88 23       	and	r24, r24
    22aa:	69 f0       	breq	.+26     	; 0x22c6 <__stack+0xc7>
    22ac:	c6 01       	movw	r24, r12
    22ae:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    22b2:	81 11       	cpse	r24, r1
    22b4:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    22b8:	f8 01       	movw	r30, r16
    22ba:	86 8d       	ldd	r24, Z+30	; 0x1e
    22bc:	81 50       	subi	r24, 0x01	; 1
    22be:	86 8f       	std	Z+30, r24	; 0x1e
    22c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    22c2:	18 16       	cp	r1, r24
    22c4:	7c f3       	brlt	.-34     	; 0x22a4 <__stack+0xa5>
    22c6:	f8 01       	movw	r30, r16
    22c8:	b6 8e       	std	Z+30, r11	; 0x1e
    22ca:	0f 90       	pop	r0
    22cc:	0f be       	out	0x3f, r0	; 63
    22ce:	0f b6       	in	r0, 0x3f	; 63
    22d0:	f8 94       	cli
    22d2:	0f 92       	push	r0
    22d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    22d6:	18 16       	cp	r1, r24
    22d8:	ac f4       	brge	.+42     	; 0x2304 <__stack+0x105>
    22da:	80 85       	ldd	r24, Z+8	; 0x08
    22dc:	81 11       	cpse	r24, r1
    22de:	05 c0       	rjmp	.+10     	; 0x22ea <__stack+0xeb>
    22e0:	11 c0       	rjmp	.+34     	; 0x2304 <__stack+0x105>
    22e2:	f8 01       	movw	r30, r16
    22e4:	80 85       	ldd	r24, Z+8	; 0x08
    22e6:	88 23       	and	r24, r24
    22e8:	69 f0       	breq	.+26     	; 0x2304 <__stack+0x105>
    22ea:	c7 01       	movw	r24, r14
    22ec:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    22f0:	81 11       	cpse	r24, r1
    22f2:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    22f6:	f8 01       	movw	r30, r16
    22f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    22fa:	81 50       	subi	r24, 0x01	; 1
    22fc:	85 8f       	std	Z+29, r24	; 0x1d
    22fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2300:	18 16       	cp	r1, r24
    2302:	7c f3       	brlt	.-34     	; 0x22e2 <__stack+0xe3>
    2304:	f8 01       	movw	r30, r16
    2306:	b5 8e       	std	Z+29, r11	; 0x1d
    2308:	0f 90       	pop	r0
    230a:	0f be       	out	0x3f, r0	; 63
    230c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    2310:	81 11       	cpse	r24, r1
    2312:	5e cf       	rjmp	.-324    	; 0x21d0 <xQueueCreateMutex+0x76>
    2314:	f7 dd       	rcall	.-1042   	; 0x1f04 <vPortYield>
    2316:	5c cf       	rjmp	.-328    	; 0x21d0 <xQueueCreateMutex+0x76>
    2318:	0f b6       	in	r0, 0x3f	; 63
    231a:	f8 94       	cli
    231c:	0f 92       	push	r0
    231e:	f8 01       	movw	r30, r16
    2320:	86 8d       	ldd	r24, Z+30	; 0x1e
    2322:	18 16       	cp	r1, r24
    2324:	ac f4       	brge	.+42     	; 0x2350 <__stack+0x151>
    2326:	81 89       	ldd	r24, Z+17	; 0x11
    2328:	81 11       	cpse	r24, r1
    232a:	05 c0       	rjmp	.+10     	; 0x2336 <__stack+0x137>
    232c:	11 c0       	rjmp	.+34     	; 0x2350 <__stack+0x151>
    232e:	f8 01       	movw	r30, r16
    2330:	81 89       	ldd	r24, Z+17	; 0x11
    2332:	88 23       	and	r24, r24
    2334:	69 f0       	breq	.+26     	; 0x2350 <__stack+0x151>
    2336:	c6 01       	movw	r24, r12
    2338:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    233c:	81 11       	cpse	r24, r1
    233e:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2342:	f8 01       	movw	r30, r16
    2344:	86 8d       	ldd	r24, Z+30	; 0x1e
    2346:	81 50       	subi	r24, 0x01	; 1
    2348:	86 8f       	std	Z+30, r24	; 0x1e
    234a:	86 8d       	ldd	r24, Z+30	; 0x1e
    234c:	18 16       	cp	r1, r24
    234e:	7c f3       	brlt	.-34     	; 0x232e <__stack+0x12f>
    2350:	f8 01       	movw	r30, r16
    2352:	b6 8e       	std	Z+30, r11	; 0x1e
    2354:	0f 90       	pop	r0
    2356:	0f be       	out	0x3f, r0	; 63
    2358:	0f b6       	in	r0, 0x3f	; 63
    235a:	f8 94       	cli
    235c:	0f 92       	push	r0
    235e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2360:	18 16       	cp	r1, r24
    2362:	ac f4       	brge	.+42     	; 0x238e <__stack+0x18f>
    2364:	80 85       	ldd	r24, Z+8	; 0x08
    2366:	81 11       	cpse	r24, r1
    2368:	05 c0       	rjmp	.+10     	; 0x2374 <__stack+0x175>
    236a:	11 c0       	rjmp	.+34     	; 0x238e <__stack+0x18f>
    236c:	f8 01       	movw	r30, r16
    236e:	80 85       	ldd	r24, Z+8	; 0x08
    2370:	88 23       	and	r24, r24
    2372:	69 f0       	breq	.+26     	; 0x238e <__stack+0x18f>
    2374:	c7 01       	movw	r24, r14
    2376:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    237a:	81 11       	cpse	r24, r1
    237c:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2380:	f8 01       	movw	r30, r16
    2382:	85 8d       	ldd	r24, Z+29	; 0x1d
    2384:	81 50       	subi	r24, 0x01	; 1
    2386:	85 8f       	std	Z+29, r24	; 0x1d
    2388:	85 8d       	ldd	r24, Z+29	; 0x1d
    238a:	18 16       	cp	r1, r24
    238c:	7c f3       	brlt	.-34     	; 0x236c <__stack+0x16d>
    238e:	f8 01       	movw	r30, r16
    2390:	b5 8e       	std	Z+29, r11	; 0x1d
    2392:	0f 90       	pop	r0
    2394:	0f be       	out	0x3f, r0	; 63
    2396:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    239a:	1a cf       	rjmp	.-460    	; 0x21d0 <xQueueCreateMutex+0x76>
    239c:	0f b6       	in	r0, 0x3f	; 63
    239e:	f8 94       	cli
    23a0:	0f 92       	push	r0
    23a2:	f8 01       	movw	r30, r16
    23a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    23a6:	18 16       	cp	r1, r24
    23a8:	ac f4       	brge	.+42     	; 0x23d4 <__stack+0x1d5>
    23aa:	81 89       	ldd	r24, Z+17	; 0x11
    23ac:	81 11       	cpse	r24, r1
    23ae:	05 c0       	rjmp	.+10     	; 0x23ba <__stack+0x1bb>
    23b0:	11 c0       	rjmp	.+34     	; 0x23d4 <__stack+0x1d5>
    23b2:	f8 01       	movw	r30, r16
    23b4:	81 89       	ldd	r24, Z+17	; 0x11
    23b6:	88 23       	and	r24, r24
    23b8:	69 f0       	breq	.+26     	; 0x23d4 <__stack+0x1d5>
    23ba:	c6 01       	movw	r24, r12
    23bc:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    23c0:	81 11       	cpse	r24, r1
    23c2:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    23c6:	f8 01       	movw	r30, r16
    23c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    23ca:	81 50       	subi	r24, 0x01	; 1
    23cc:	86 8f       	std	Z+30, r24	; 0x1e
    23ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    23d0:	18 16       	cp	r1, r24
    23d2:	7c f3       	brlt	.-34     	; 0x23b2 <__stack+0x1b3>
    23d4:	8f ef       	ldi	r24, 0xFF	; 255
    23d6:	f8 01       	movw	r30, r16
    23d8:	86 8f       	std	Z+30, r24	; 0x1e
    23da:	0f 90       	pop	r0
    23dc:	0f be       	out	0x3f, r0	; 63
    23de:	0f b6       	in	r0, 0x3f	; 63
    23e0:	f8 94       	cli
    23e2:	0f 92       	push	r0
    23e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    23e6:	18 16       	cp	r1, r24
    23e8:	ac f4       	brge	.+42     	; 0x2414 <__stack+0x215>
    23ea:	80 85       	ldd	r24, Z+8	; 0x08
    23ec:	81 11       	cpse	r24, r1
    23ee:	05 c0       	rjmp	.+10     	; 0x23fa <__stack+0x1fb>
    23f0:	11 c0       	rjmp	.+34     	; 0x2414 <__stack+0x215>
    23f2:	f8 01       	movw	r30, r16
    23f4:	80 85       	ldd	r24, Z+8	; 0x08
    23f6:	88 23       	and	r24, r24
    23f8:	69 f0       	breq	.+26     	; 0x2414 <__stack+0x215>
    23fa:	c7 01       	movw	r24, r14
    23fc:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2400:	81 11       	cpse	r24, r1
    2402:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2406:	f8 01       	movw	r30, r16
    2408:	85 8d       	ldd	r24, Z+29	; 0x1d
    240a:	81 50       	subi	r24, 0x01	; 1
    240c:	85 8f       	std	Z+29, r24	; 0x1d
    240e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2410:	18 16       	cp	r1, r24
    2412:	7c f3       	brlt	.-34     	; 0x23f2 <__stack+0x1f3>
    2414:	8f ef       	ldi	r24, 0xFF	; 255
    2416:	f8 01       	movw	r30, r16
    2418:	85 8f       	std	Z+29, r24	; 0x1d
    241a:	0f 90       	pop	r0
    241c:	0f be       	out	0x3f, r0	; 63
    241e:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    2422:	09 c0       	rjmp	.+18     	; 0x2436 <__stack+0x237>
    2424:	f8 01       	movw	r30, r16
    2426:	82 8d       	ldd	r24, Z+26	; 0x1a
    2428:	8f 5f       	subi	r24, 0xFF	; 255
    242a:	82 8f       	std	Z+26, r24	; 0x1a
    242c:	81 89       	ldd	r24, Z+17	; 0x11
    242e:	88 23       	and	r24, r24
    2430:	09 f4       	brne	.+2      	; 0x2434 <__stack+0x235>
    2432:	f1 ce       	rjmp	.-542    	; 0x2216 <__stack+0x17>
    2434:	e7 ce       	rjmp	.-562    	; 0x2204 <__stack+0x5>
    2436:	c8 01       	movw	r24, r16
    2438:	0f 90       	pop	r0
    243a:	0f 90       	pop	r0
    243c:	0f 90       	pop	r0
    243e:	0f 90       	pop	r0
    2440:	0f 90       	pop	r0
    2442:	df 91       	pop	r29
    2444:	cf 91       	pop	r28
    2446:	1f 91       	pop	r17
    2448:	0f 91       	pop	r16
    244a:	ff 90       	pop	r15
    244c:	ef 90       	pop	r14
    244e:	df 90       	pop	r13
    2450:	cf 90       	pop	r12
    2452:	bf 90       	pop	r11
    2454:	af 90       	pop	r10
    2456:	9f 90       	pop	r9
    2458:	08 95       	ret

0000245a <xQueueGenericSend>:
    245a:	6f 92       	push	r6
    245c:	7f 92       	push	r7
    245e:	8f 92       	push	r8
    2460:	9f 92       	push	r9
    2462:	af 92       	push	r10
    2464:	bf 92       	push	r11
    2466:	cf 92       	push	r12
    2468:	df 92       	push	r13
    246a:	ef 92       	push	r14
    246c:	ff 92       	push	r15
    246e:	0f 93       	push	r16
    2470:	1f 93       	push	r17
    2472:	cf 93       	push	r28
    2474:	df 93       	push	r29
    2476:	00 d0       	rcall	.+0      	; 0x2478 <xQueueGenericSend+0x1e>
    2478:	1f 92       	push	r1
    247a:	1f 92       	push	r1
    247c:	cd b7       	in	r28, 0x3d	; 61
    247e:	de b7       	in	r29, 0x3e	; 62
    2480:	8c 01       	movw	r16, r24
    2482:	5b 01       	movw	r10, r22
    2484:	5d 83       	std	Y+5, r21	; 0x05
    2486:	4c 83       	std	Y+4, r20	; 0x04
    2488:	72 2e       	mov	r7, r18
    248a:	81 2c       	mov	r8, r1
    248c:	66 24       	eor	r6, r6
    248e:	63 94       	inc	r6
    2490:	99 24       	eor	r9, r9
    2492:	9a 94       	dec	r9
    2494:	7c 01       	movw	r14, r24
    2496:	88 e0       	ldi	r24, 0x08	; 8
    2498:	e8 0e       	add	r14, r24
    249a:	f1 1c       	adc	r15, r1
    249c:	68 01       	movw	r12, r16
    249e:	e1 e1       	ldi	r30, 0x11	; 17
    24a0:	ce 0e       	add	r12, r30
    24a2:	d1 1c       	adc	r13, r1
    24a4:	0f b6       	in	r0, 0x3f	; 63
    24a6:	f8 94       	cli
    24a8:	0f 92       	push	r0
    24aa:	f8 01       	movw	r30, r16
    24ac:	92 8d       	ldd	r25, Z+26	; 0x1a
    24ae:	83 8d       	ldd	r24, Z+27	; 0x1b
    24b0:	98 17       	cp	r25, r24
    24b2:	20 f0       	brcs	.+8      	; 0x24bc <xQueueGenericSend+0x62>
    24b4:	f2 e0       	ldi	r31, 0x02	; 2
    24b6:	7f 12       	cpse	r7, r31
    24b8:	6e c0       	rjmp	.+220    	; 0x2596 <xQueueGenericSend+0x13c>
    24ba:	7d c1       	rjmp	.+762    	; 0x27b6 <xQueueGenericSend+0x35c>
    24bc:	f8 01       	movw	r30, r16
    24be:	44 8d       	ldd	r20, Z+28	; 0x1c
    24c0:	41 11       	cpse	r20, r1
    24c2:	15 c0       	rjmp	.+42     	; 0x24ee <xQueueGenericSend+0x94>
    24c4:	f8 01       	movw	r30, r16
    24c6:	80 81       	ld	r24, Z
    24c8:	91 81       	ldd	r25, Z+1	; 0x01
    24ca:	89 2b       	or	r24, r25
    24cc:	09 f0       	breq	.+2      	; 0x24d0 <xQueueGenericSend+0x76>
    24ce:	79 c1       	rjmp	.+754    	; 0x27c2 <xQueueGenericSend+0x368>
    24d0:	82 81       	ldd	r24, Z+2	; 0x02
    24d2:	93 81       	ldd	r25, Z+3	; 0x03
    24d4:	0e 94 66 22 	call	0x44cc	; 0x44cc <xTaskPriorityDisinherit>
    24d8:	f8 01       	movw	r30, r16
    24da:	13 82       	std	Z+3, r1	; 0x03
    24dc:	12 82       	std	Z+2, r1	; 0x02
    24de:	92 8d       	ldd	r25, Z+26	; 0x1a
    24e0:	9f 5f       	subi	r25, 0xFF	; 255
    24e2:	92 8f       	std	Z+26, r25	; 0x1a
    24e4:	91 89       	ldd	r25, Z+17	; 0x11
    24e6:	99 23       	and	r25, r25
    24e8:	09 f4       	brne	.+2      	; 0x24ec <xQueueGenericSend+0x92>
    24ea:	4f c0       	rjmp	.+158    	; 0x258a <xQueueGenericSend+0x130>
    24ec:	46 c0       	rjmp	.+140    	; 0x257a <xQueueGenericSend+0x120>
    24ee:	71 10       	cpse	r7, r1
    24f0:	1a c0       	rjmp	.+52     	; 0x2526 <xQueueGenericSend+0xcc>
    24f2:	50 e0       	ldi	r21, 0x00	; 0
    24f4:	b5 01       	movw	r22, r10
    24f6:	f8 01       	movw	r30, r16
    24f8:	84 81       	ldd	r24, Z+4	; 0x04
    24fa:	95 81       	ldd	r25, Z+5	; 0x05
    24fc:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    2500:	f8 01       	movw	r30, r16
    2502:	24 8d       	ldd	r18, Z+28	; 0x1c
    2504:	84 81       	ldd	r24, Z+4	; 0x04
    2506:	95 81       	ldd	r25, Z+5	; 0x05
    2508:	82 0f       	add	r24, r18
    250a:	91 1d       	adc	r25, r1
    250c:	95 83       	std	Z+5, r25	; 0x05
    250e:	84 83       	std	Z+4, r24	; 0x04
    2510:	22 81       	ldd	r18, Z+2	; 0x02
    2512:	33 81       	ldd	r19, Z+3	; 0x03
    2514:	82 17       	cp	r24, r18
    2516:	93 07       	cpc	r25, r19
    2518:	08 f4       	brcc	.+2      	; 0x251c <xQueueGenericSend+0xc2>
    251a:	53 c1       	rjmp	.+678    	; 0x27c2 <xQueueGenericSend+0x368>
    251c:	80 81       	ld	r24, Z
    251e:	91 81       	ldd	r25, Z+1	; 0x01
    2520:	95 83       	std	Z+5, r25	; 0x05
    2522:	84 83       	std	Z+4, r24	; 0x04
    2524:	4e c1       	rjmp	.+668    	; 0x27c2 <xQueueGenericSend+0x368>
    2526:	50 e0       	ldi	r21, 0x00	; 0
    2528:	b5 01       	movw	r22, r10
    252a:	f8 01       	movw	r30, r16
    252c:	86 81       	ldd	r24, Z+6	; 0x06
    252e:	97 81       	ldd	r25, Z+7	; 0x07
    2530:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    2534:	f8 01       	movw	r30, r16
    2536:	84 8d       	ldd	r24, Z+28	; 0x1c
    2538:	90 e0       	ldi	r25, 0x00	; 0
    253a:	91 95       	neg	r25
    253c:	81 95       	neg	r24
    253e:	91 09       	sbc	r25, r1
    2540:	26 81       	ldd	r18, Z+6	; 0x06
    2542:	37 81       	ldd	r19, Z+7	; 0x07
    2544:	28 0f       	add	r18, r24
    2546:	39 1f       	adc	r19, r25
    2548:	37 83       	std	Z+7, r19	; 0x07
    254a:	26 83       	std	Z+6, r18	; 0x06
    254c:	40 81       	ld	r20, Z
    254e:	51 81       	ldd	r21, Z+1	; 0x01
    2550:	24 17       	cp	r18, r20
    2552:	35 07       	cpc	r19, r21
    2554:	30 f4       	brcc	.+12     	; 0x2562 <xQueueGenericSend+0x108>
    2556:	22 81       	ldd	r18, Z+2	; 0x02
    2558:	33 81       	ldd	r19, Z+3	; 0x03
    255a:	82 0f       	add	r24, r18
    255c:	93 1f       	adc	r25, r19
    255e:	97 83       	std	Z+7, r25	; 0x07
    2560:	86 83       	std	Z+6, r24	; 0x06
    2562:	f2 e0       	ldi	r31, 0x02	; 2
    2564:	7f 12       	cpse	r7, r31
    2566:	2d c1       	rjmp	.+602    	; 0x27c2 <xQueueGenericSend+0x368>
    2568:	f8 01       	movw	r30, r16
    256a:	82 8d       	ldd	r24, Z+26	; 0x1a
    256c:	88 23       	and	r24, r24
    256e:	09 f4       	brne	.+2      	; 0x2572 <xQueueGenericSend+0x118>
    2570:	28 c1       	rjmp	.+592    	; 0x27c2 <xQueueGenericSend+0x368>
    2572:	82 8d       	ldd	r24, Z+26	; 0x1a
    2574:	81 50       	subi	r24, 0x01	; 1
    2576:	82 8f       	std	Z+26, r24	; 0x1a
    2578:	24 c1       	rjmp	.+584    	; 0x27c2 <xQueueGenericSend+0x368>
    257a:	c8 01       	movw	r24, r16
    257c:	41 96       	adiw	r24, 0x11	; 17
    257e:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2582:	81 30       	cpi	r24, 0x01	; 1
    2584:	21 f4       	brne	.+8      	; 0x258e <xQueueGenericSend+0x134>
    2586:	be dc       	rcall	.-1668   	; 0x1f04 <vPortYield>
    2588:	02 c0       	rjmp	.+4      	; 0x258e <xQueueGenericSend+0x134>
    258a:	81 11       	cpse	r24, r1
    258c:	bb dc       	rcall	.-1674   	; 0x1f04 <vPortYield>
    258e:	0f 90       	pop	r0
    2590:	0f be       	out	0x3f, r0	; 63
    2592:	81 e0       	ldi	r24, 0x01	; 1
    2594:	1e c1       	rjmp	.+572    	; 0x27d2 <xQueueGenericSend+0x378>
    2596:	8c 81       	ldd	r24, Y+4	; 0x04
    2598:	9d 81       	ldd	r25, Y+5	; 0x05
    259a:	89 2b       	or	r24, r25
    259c:	21 f4       	brne	.+8      	; 0x25a6 <xQueueGenericSend+0x14c>
    259e:	0f 90       	pop	r0
    25a0:	0f be       	out	0x3f, r0	; 63
    25a2:	80 e0       	ldi	r24, 0x00	; 0
    25a4:	16 c1       	rjmp	.+556    	; 0x27d2 <xQueueGenericSend+0x378>
    25a6:	81 10       	cpse	r8, r1
    25a8:	05 c0       	rjmp	.+10     	; 0x25b4 <xQueueGenericSend+0x15a>
    25aa:	ce 01       	movw	r24, r28
    25ac:	01 96       	adiw	r24, 0x01	; 1
    25ae:	0e 94 b5 21 	call	0x436a	; 0x436a <vTaskSetTimeOutState>
    25b2:	86 2c       	mov	r8, r6
    25b4:	0f 90       	pop	r0
    25b6:	0f be       	out	0x3f, r0	; 63
    25b8:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <vTaskSuspendAll>
    25bc:	0f b6       	in	r0, 0x3f	; 63
    25be:	f8 94       	cli
    25c0:	0f 92       	push	r0
    25c2:	f8 01       	movw	r30, r16
    25c4:	85 8d       	ldd	r24, Z+29	; 0x1d
    25c6:	8f 3f       	cpi	r24, 0xFF	; 255
    25c8:	09 f4       	brne	.+2      	; 0x25cc <xQueueGenericSend+0x172>
    25ca:	15 8e       	std	Z+29, r1	; 0x1d
    25cc:	f8 01       	movw	r30, r16
    25ce:	86 8d       	ldd	r24, Z+30	; 0x1e
    25d0:	8f 3f       	cpi	r24, 0xFF	; 255
    25d2:	09 f4       	brne	.+2      	; 0x25d6 <xQueueGenericSend+0x17c>
    25d4:	16 8e       	std	Z+30, r1	; 0x1e
    25d6:	0f 90       	pop	r0
    25d8:	0f be       	out	0x3f, r0	; 63
    25da:	be 01       	movw	r22, r28
    25dc:	6c 5f       	subi	r22, 0xFC	; 252
    25de:	7f 4f       	sbci	r23, 0xFF	; 255
    25e0:	ce 01       	movw	r24, r28
    25e2:	01 96       	adiw	r24, 0x01	; 1
    25e4:	0e 94 c0 21 	call	0x4380	; 0x4380 <xTaskCheckForTimeOut>
    25e8:	81 11       	cpse	r24, r1
    25ea:	96 c0       	rjmp	.+300    	; 0x2718 <xQueueGenericSend+0x2be>
    25ec:	0f b6       	in	r0, 0x3f	; 63
    25ee:	f8 94       	cli
    25f0:	0f 92       	push	r0
    25f2:	f8 01       	movw	r30, r16
    25f4:	92 8d       	ldd	r25, Z+26	; 0x1a
    25f6:	83 8d       	ldd	r24, Z+27	; 0x1b
    25f8:	0f 90       	pop	r0
    25fa:	0f be       	out	0x3f, r0	; 63
    25fc:	98 13       	cpse	r25, r24
    25fe:	4a c0       	rjmp	.+148    	; 0x2694 <xQueueGenericSend+0x23a>
    2600:	6c 81       	ldd	r22, Y+4	; 0x04
    2602:	7d 81       	ldd	r23, Y+5	; 0x05
    2604:	c7 01       	movw	r24, r14
    2606:	0e 94 12 21 	call	0x4224	; 0x4224 <vTaskPlaceOnEventList>
    260a:	0f b6       	in	r0, 0x3f	; 63
    260c:	f8 94       	cli
    260e:	0f 92       	push	r0
    2610:	f8 01       	movw	r30, r16
    2612:	86 8d       	ldd	r24, Z+30	; 0x1e
    2614:	18 16       	cp	r1, r24
    2616:	ac f4       	brge	.+42     	; 0x2642 <xQueueGenericSend+0x1e8>
    2618:	81 89       	ldd	r24, Z+17	; 0x11
    261a:	81 11       	cpse	r24, r1
    261c:	05 c0       	rjmp	.+10     	; 0x2628 <xQueueGenericSend+0x1ce>
    261e:	11 c0       	rjmp	.+34     	; 0x2642 <xQueueGenericSend+0x1e8>
    2620:	f8 01       	movw	r30, r16
    2622:	81 89       	ldd	r24, Z+17	; 0x11
    2624:	88 23       	and	r24, r24
    2626:	69 f0       	breq	.+26     	; 0x2642 <xQueueGenericSend+0x1e8>
    2628:	c6 01       	movw	r24, r12
    262a:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    262e:	81 11       	cpse	r24, r1
    2630:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2634:	f8 01       	movw	r30, r16
    2636:	86 8d       	ldd	r24, Z+30	; 0x1e
    2638:	81 50       	subi	r24, 0x01	; 1
    263a:	86 8f       	std	Z+30, r24	; 0x1e
    263c:	86 8d       	ldd	r24, Z+30	; 0x1e
    263e:	18 16       	cp	r1, r24
    2640:	7c f3       	brlt	.-34     	; 0x2620 <xQueueGenericSend+0x1c6>
    2642:	f8 01       	movw	r30, r16
    2644:	96 8e       	std	Z+30, r9	; 0x1e
    2646:	0f 90       	pop	r0
    2648:	0f be       	out	0x3f, r0	; 63
    264a:	0f b6       	in	r0, 0x3f	; 63
    264c:	f8 94       	cli
    264e:	0f 92       	push	r0
    2650:	85 8d       	ldd	r24, Z+29	; 0x1d
    2652:	18 16       	cp	r1, r24
    2654:	ac f4       	brge	.+42     	; 0x2680 <xQueueGenericSend+0x226>
    2656:	80 85       	ldd	r24, Z+8	; 0x08
    2658:	81 11       	cpse	r24, r1
    265a:	05 c0       	rjmp	.+10     	; 0x2666 <xQueueGenericSend+0x20c>
    265c:	11 c0       	rjmp	.+34     	; 0x2680 <xQueueGenericSend+0x226>
    265e:	f8 01       	movw	r30, r16
    2660:	80 85       	ldd	r24, Z+8	; 0x08
    2662:	88 23       	and	r24, r24
    2664:	69 f0       	breq	.+26     	; 0x2680 <xQueueGenericSend+0x226>
    2666:	c7 01       	movw	r24, r14
    2668:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    266c:	81 11       	cpse	r24, r1
    266e:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2672:	f8 01       	movw	r30, r16
    2674:	85 8d       	ldd	r24, Z+29	; 0x1d
    2676:	81 50       	subi	r24, 0x01	; 1
    2678:	85 8f       	std	Z+29, r24	; 0x1d
    267a:	85 8d       	ldd	r24, Z+29	; 0x1d
    267c:	18 16       	cp	r1, r24
    267e:	7c f3       	brlt	.-34     	; 0x265e <xQueueGenericSend+0x204>
    2680:	f8 01       	movw	r30, r16
    2682:	95 8e       	std	Z+29, r9	; 0x1d
    2684:	0f 90       	pop	r0
    2686:	0f be       	out	0x3f, r0	; 63
    2688:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    268c:	81 11       	cpse	r24, r1
    268e:	0a cf       	rjmp	.-492    	; 0x24a4 <xQueueGenericSend+0x4a>
    2690:	39 dc       	rcall	.-1934   	; 0x1f04 <vPortYield>
    2692:	08 cf       	rjmp	.-496    	; 0x24a4 <xQueueGenericSend+0x4a>
    2694:	0f b6       	in	r0, 0x3f	; 63
    2696:	f8 94       	cli
    2698:	0f 92       	push	r0
    269a:	f8 01       	movw	r30, r16
    269c:	86 8d       	ldd	r24, Z+30	; 0x1e
    269e:	18 16       	cp	r1, r24
    26a0:	ac f4       	brge	.+42     	; 0x26cc <xQueueGenericSend+0x272>
    26a2:	81 89       	ldd	r24, Z+17	; 0x11
    26a4:	81 11       	cpse	r24, r1
    26a6:	05 c0       	rjmp	.+10     	; 0x26b2 <xQueueGenericSend+0x258>
    26a8:	11 c0       	rjmp	.+34     	; 0x26cc <xQueueGenericSend+0x272>
    26aa:	f8 01       	movw	r30, r16
    26ac:	81 89       	ldd	r24, Z+17	; 0x11
    26ae:	88 23       	and	r24, r24
    26b0:	69 f0       	breq	.+26     	; 0x26cc <xQueueGenericSend+0x272>
    26b2:	c6 01       	movw	r24, r12
    26b4:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    26b8:	81 11       	cpse	r24, r1
    26ba:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    26be:	f8 01       	movw	r30, r16
    26c0:	86 8d       	ldd	r24, Z+30	; 0x1e
    26c2:	81 50       	subi	r24, 0x01	; 1
    26c4:	86 8f       	std	Z+30, r24	; 0x1e
    26c6:	86 8d       	ldd	r24, Z+30	; 0x1e
    26c8:	18 16       	cp	r1, r24
    26ca:	7c f3       	brlt	.-34     	; 0x26aa <xQueueGenericSend+0x250>
    26cc:	f8 01       	movw	r30, r16
    26ce:	96 8e       	std	Z+30, r9	; 0x1e
    26d0:	0f 90       	pop	r0
    26d2:	0f be       	out	0x3f, r0	; 63
    26d4:	0f b6       	in	r0, 0x3f	; 63
    26d6:	f8 94       	cli
    26d8:	0f 92       	push	r0
    26da:	85 8d       	ldd	r24, Z+29	; 0x1d
    26dc:	18 16       	cp	r1, r24
    26de:	ac f4       	brge	.+42     	; 0x270a <xQueueGenericSend+0x2b0>
    26e0:	80 85       	ldd	r24, Z+8	; 0x08
    26e2:	81 11       	cpse	r24, r1
    26e4:	05 c0       	rjmp	.+10     	; 0x26f0 <xQueueGenericSend+0x296>
    26e6:	11 c0       	rjmp	.+34     	; 0x270a <xQueueGenericSend+0x2b0>
    26e8:	f8 01       	movw	r30, r16
    26ea:	80 85       	ldd	r24, Z+8	; 0x08
    26ec:	88 23       	and	r24, r24
    26ee:	69 f0       	breq	.+26     	; 0x270a <xQueueGenericSend+0x2b0>
    26f0:	c7 01       	movw	r24, r14
    26f2:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    26f6:	81 11       	cpse	r24, r1
    26f8:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    26fc:	f8 01       	movw	r30, r16
    26fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2700:	81 50       	subi	r24, 0x01	; 1
    2702:	85 8f       	std	Z+29, r24	; 0x1d
    2704:	85 8d       	ldd	r24, Z+29	; 0x1d
    2706:	18 16       	cp	r1, r24
    2708:	7c f3       	brlt	.-34     	; 0x26e8 <xQueueGenericSend+0x28e>
    270a:	f8 01       	movw	r30, r16
    270c:	95 8e       	std	Z+29, r9	; 0x1d
    270e:	0f 90       	pop	r0
    2710:	0f be       	out	0x3f, r0	; 63
    2712:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    2716:	c6 ce       	rjmp	.-628    	; 0x24a4 <xQueueGenericSend+0x4a>
    2718:	0f b6       	in	r0, 0x3f	; 63
    271a:	f8 94       	cli
    271c:	0f 92       	push	r0
    271e:	f8 01       	movw	r30, r16
    2720:	86 8d       	ldd	r24, Z+30	; 0x1e
    2722:	18 16       	cp	r1, r24
    2724:	d4 f4       	brge	.+52     	; 0x275a <xQueueGenericSend+0x300>
    2726:	81 89       	ldd	r24, Z+17	; 0x11
    2728:	81 11       	cpse	r24, r1
    272a:	06 c0       	rjmp	.+12     	; 0x2738 <xQueueGenericSend+0x2de>
    272c:	16 c0       	rjmp	.+44     	; 0x275a <xQueueGenericSend+0x300>
    272e:	f8 01       	movw	r30, r16
    2730:	81 89       	ldd	r24, Z+17	; 0x11
    2732:	81 11       	cpse	r24, r1
    2734:	05 c0       	rjmp	.+10     	; 0x2740 <xQueueGenericSend+0x2e6>
    2736:	11 c0       	rjmp	.+34     	; 0x275a <xQueueGenericSend+0x300>
    2738:	78 01       	movw	r14, r16
    273a:	f1 e1       	ldi	r31, 0x11	; 17
    273c:	ef 0e       	add	r14, r31
    273e:	f1 1c       	adc	r15, r1
    2740:	c7 01       	movw	r24, r14
    2742:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2746:	81 11       	cpse	r24, r1
    2748:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    274c:	f8 01       	movw	r30, r16
    274e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2750:	81 50       	subi	r24, 0x01	; 1
    2752:	86 8f       	std	Z+30, r24	; 0x1e
    2754:	86 8d       	ldd	r24, Z+30	; 0x1e
    2756:	18 16       	cp	r1, r24
    2758:	54 f3       	brlt	.-44     	; 0x272e <xQueueGenericSend+0x2d4>
    275a:	8f ef       	ldi	r24, 0xFF	; 255
    275c:	f8 01       	movw	r30, r16
    275e:	86 8f       	std	Z+30, r24	; 0x1e
    2760:	0f 90       	pop	r0
    2762:	0f be       	out	0x3f, r0	; 63
    2764:	0f b6       	in	r0, 0x3f	; 63
    2766:	f8 94       	cli
    2768:	0f 92       	push	r0
    276a:	85 8d       	ldd	r24, Z+29	; 0x1d
    276c:	18 16       	cp	r1, r24
    276e:	d4 f4       	brge	.+52     	; 0x27a4 <xQueueGenericSend+0x34a>
    2770:	80 85       	ldd	r24, Z+8	; 0x08
    2772:	81 11       	cpse	r24, r1
    2774:	06 c0       	rjmp	.+12     	; 0x2782 <xQueueGenericSend+0x328>
    2776:	16 c0       	rjmp	.+44     	; 0x27a4 <xQueueGenericSend+0x34a>
    2778:	f8 01       	movw	r30, r16
    277a:	80 85       	ldd	r24, Z+8	; 0x08
    277c:	81 11       	cpse	r24, r1
    277e:	05 c0       	rjmp	.+10     	; 0x278a <xQueueGenericSend+0x330>
    2780:	11 c0       	rjmp	.+34     	; 0x27a4 <xQueueGenericSend+0x34a>
    2782:	78 01       	movw	r14, r16
    2784:	f8 e0       	ldi	r31, 0x08	; 8
    2786:	ef 0e       	add	r14, r31
    2788:	f1 1c       	adc	r15, r1
    278a:	c7 01       	movw	r24, r14
    278c:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2790:	81 11       	cpse	r24, r1
    2792:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2796:	f8 01       	movw	r30, r16
    2798:	85 8d       	ldd	r24, Z+29	; 0x1d
    279a:	81 50       	subi	r24, 0x01	; 1
    279c:	85 8f       	std	Z+29, r24	; 0x1d
    279e:	85 8d       	ldd	r24, Z+29	; 0x1d
    27a0:	18 16       	cp	r1, r24
    27a2:	54 f3       	brlt	.-44     	; 0x2778 <xQueueGenericSend+0x31e>
    27a4:	8f ef       	ldi	r24, 0xFF	; 255
    27a6:	f8 01       	movw	r30, r16
    27a8:	85 8f       	std	Z+29, r24	; 0x1d
    27aa:	0f 90       	pop	r0
    27ac:	0f be       	out	0x3f, r0	; 63
    27ae:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    27b2:	80 e0       	ldi	r24, 0x00	; 0
    27b4:	0e c0       	rjmp	.+28     	; 0x27d2 <xQueueGenericSend+0x378>
    27b6:	f8 01       	movw	r30, r16
    27b8:	44 8d       	ldd	r20, Z+28	; 0x1c
    27ba:	44 23       	and	r20, r20
    27bc:	09 f4       	brne	.+2      	; 0x27c0 <xQueueGenericSend+0x366>
    27be:	82 ce       	rjmp	.-764    	; 0x24c4 <xQueueGenericSend+0x6a>
    27c0:	b2 ce       	rjmp	.-668    	; 0x2526 <xQueueGenericSend+0xcc>
    27c2:	f8 01       	movw	r30, r16
    27c4:	82 8d       	ldd	r24, Z+26	; 0x1a
    27c6:	8f 5f       	subi	r24, 0xFF	; 255
    27c8:	82 8f       	std	Z+26, r24	; 0x1a
    27ca:	81 89       	ldd	r24, Z+17	; 0x11
    27cc:	81 11       	cpse	r24, r1
    27ce:	d5 ce       	rjmp	.-598    	; 0x257a <xQueueGenericSend+0x120>
    27d0:	de ce       	rjmp	.-580    	; 0x258e <xQueueGenericSend+0x134>
    27d2:	0f 90       	pop	r0
    27d4:	0f 90       	pop	r0
    27d6:	0f 90       	pop	r0
    27d8:	0f 90       	pop	r0
    27da:	0f 90       	pop	r0
    27dc:	df 91       	pop	r29
    27de:	cf 91       	pop	r28
    27e0:	1f 91       	pop	r17
    27e2:	0f 91       	pop	r16
    27e4:	ff 90       	pop	r15
    27e6:	ef 90       	pop	r14
    27e8:	df 90       	pop	r13
    27ea:	cf 90       	pop	r12
    27ec:	bf 90       	pop	r11
    27ee:	af 90       	pop	r10
    27f0:	9f 90       	pop	r9
    27f2:	8f 90       	pop	r8
    27f4:	7f 90       	pop	r7
    27f6:	6f 90       	pop	r6
    27f8:	08 95       	ret

000027fa <xQueueGive>:
    27fa:	9f 92       	push	r9
    27fc:	af 92       	push	r10
    27fe:	bf 92       	push	r11
    2800:	cf 92       	push	r12
    2802:	df 92       	push	r13
    2804:	ef 92       	push	r14
    2806:	ff 92       	push	r15
    2808:	0f 93       	push	r16
    280a:	1f 93       	push	r17
    280c:	cf 93       	push	r28
    280e:	df 93       	push	r29
    2810:	00 d0       	rcall	.+0      	; 0x2812 <xQueueGive+0x18>
    2812:	1f 92       	push	r1
    2814:	1f 92       	push	r1
    2816:	cd b7       	in	r28, 0x3d	; 61
    2818:	de b7       	in	r29, 0x3e	; 62
    281a:	8c 01       	movw	r16, r24
    281c:	7d 83       	std	Y+5, r23	; 0x05
    281e:	6c 83       	std	Y+4, r22	; 0x04
    2820:	a1 2c       	mov	r10, r1
    2822:	99 24       	eor	r9, r9
    2824:	93 94       	inc	r9
    2826:	bb 24       	eor	r11, r11
    2828:	ba 94       	dec	r11
    282a:	7c 01       	movw	r14, r24
    282c:	88 e0       	ldi	r24, 0x08	; 8
    282e:	e8 0e       	add	r14, r24
    2830:	f1 1c       	adc	r15, r1
    2832:	68 01       	movw	r12, r16
    2834:	e1 e1       	ldi	r30, 0x11	; 17
    2836:	ce 0e       	add	r12, r30
    2838:	d1 1c       	adc	r13, r1
    283a:	0f b6       	in	r0, 0x3f	; 63
    283c:	f8 94       	cli
    283e:	0f 92       	push	r0
    2840:	f8 01       	movw	r30, r16
    2842:	92 8d       	ldd	r25, Z+26	; 0x1a
    2844:	83 8d       	ldd	r24, Z+27	; 0x1b
    2846:	98 17       	cp	r25, r24
    2848:	00 f5       	brcc	.+64     	; 0x288a <xQueueGive+0x90>
    284a:	80 81       	ld	r24, Z
    284c:	91 81       	ldd	r25, Z+1	; 0x01
    284e:	89 2b       	or	r24, r25
    2850:	09 f0       	breq	.+2      	; 0x2854 <xQueueGive+0x5a>
    2852:	2b c1       	rjmp	.+598    	; 0x2aaa <xQueueGive+0x2b0>
    2854:	82 81       	ldd	r24, Z+2	; 0x02
    2856:	93 81       	ldd	r25, Z+3	; 0x03
    2858:	0e 94 66 22 	call	0x44cc	; 0x44cc <xTaskPriorityDisinherit>
    285c:	f8 01       	movw	r30, r16
    285e:	13 82       	std	Z+3, r1	; 0x03
    2860:	12 82       	std	Z+2, r1	; 0x02
    2862:	92 8d       	ldd	r25, Z+26	; 0x1a
    2864:	9f 5f       	subi	r25, 0xFF	; 255
    2866:	92 8f       	std	Z+26, r25	; 0x1a
    2868:	91 89       	ldd	r25, Z+17	; 0x11
    286a:	99 23       	and	r25, r25
    286c:	41 f0       	breq	.+16     	; 0x287e <xQueueGive+0x84>
    286e:	c8 01       	movw	r24, r16
    2870:	41 96       	adiw	r24, 0x11	; 17
    2872:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2876:	81 30       	cpi	r24, 0x01	; 1
    2878:	21 f4       	brne	.+8      	; 0x2882 <xQueueGive+0x88>
    287a:	44 db       	rcall	.-2424   	; 0x1f04 <vPortYield>
    287c:	02 c0       	rjmp	.+4      	; 0x2882 <xQueueGive+0x88>
    287e:	81 11       	cpse	r24, r1
    2880:	41 db       	rcall	.-2430   	; 0x1f04 <vPortYield>
    2882:	0f 90       	pop	r0
    2884:	0f be       	out	0x3f, r0	; 63
    2886:	81 e0       	ldi	r24, 0x01	; 1
    2888:	18 c1       	rjmp	.+560    	; 0x2aba <xQueueGive+0x2c0>
    288a:	8c 81       	ldd	r24, Y+4	; 0x04
    288c:	9d 81       	ldd	r25, Y+5	; 0x05
    288e:	89 2b       	or	r24, r25
    2890:	21 f4       	brne	.+8      	; 0x289a <xQueueGive+0xa0>
    2892:	0f 90       	pop	r0
    2894:	0f be       	out	0x3f, r0	; 63
    2896:	80 e0       	ldi	r24, 0x00	; 0
    2898:	10 c1       	rjmp	.+544    	; 0x2aba <xQueueGive+0x2c0>
    289a:	a1 10       	cpse	r10, r1
    289c:	05 c0       	rjmp	.+10     	; 0x28a8 <xQueueGive+0xae>
    289e:	ce 01       	movw	r24, r28
    28a0:	01 96       	adiw	r24, 0x01	; 1
    28a2:	0e 94 b5 21 	call	0x436a	; 0x436a <vTaskSetTimeOutState>
    28a6:	a9 2c       	mov	r10, r9
    28a8:	0f 90       	pop	r0
    28aa:	0f be       	out	0x3f, r0	; 63
    28ac:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <vTaskSuspendAll>
    28b0:	0f b6       	in	r0, 0x3f	; 63
    28b2:	f8 94       	cli
    28b4:	0f 92       	push	r0
    28b6:	f8 01       	movw	r30, r16
    28b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    28ba:	8f 3f       	cpi	r24, 0xFF	; 255
    28bc:	09 f4       	brne	.+2      	; 0x28c0 <xQueueGive+0xc6>
    28be:	15 8e       	std	Z+29, r1	; 0x1d
    28c0:	f8 01       	movw	r30, r16
    28c2:	86 8d       	ldd	r24, Z+30	; 0x1e
    28c4:	8f 3f       	cpi	r24, 0xFF	; 255
    28c6:	09 f4       	brne	.+2      	; 0x28ca <xQueueGive+0xd0>
    28c8:	16 8e       	std	Z+30, r1	; 0x1e
    28ca:	0f 90       	pop	r0
    28cc:	0f be       	out	0x3f, r0	; 63
    28ce:	be 01       	movw	r22, r28
    28d0:	6c 5f       	subi	r22, 0xFC	; 252
    28d2:	7f 4f       	sbci	r23, 0xFF	; 255
    28d4:	ce 01       	movw	r24, r28
    28d6:	01 96       	adiw	r24, 0x01	; 1
    28d8:	0e 94 c0 21 	call	0x4380	; 0x4380 <xTaskCheckForTimeOut>
    28dc:	81 11       	cpse	r24, r1
    28de:	96 c0       	rjmp	.+300    	; 0x2a0c <xQueueGive+0x212>
    28e0:	0f b6       	in	r0, 0x3f	; 63
    28e2:	f8 94       	cli
    28e4:	0f 92       	push	r0
    28e6:	f8 01       	movw	r30, r16
    28e8:	92 8d       	ldd	r25, Z+26	; 0x1a
    28ea:	83 8d       	ldd	r24, Z+27	; 0x1b
    28ec:	0f 90       	pop	r0
    28ee:	0f be       	out	0x3f, r0	; 63
    28f0:	98 13       	cpse	r25, r24
    28f2:	4a c0       	rjmp	.+148    	; 0x2988 <xQueueGive+0x18e>
    28f4:	6c 81       	ldd	r22, Y+4	; 0x04
    28f6:	7d 81       	ldd	r23, Y+5	; 0x05
    28f8:	c7 01       	movw	r24, r14
    28fa:	0e 94 12 21 	call	0x4224	; 0x4224 <vTaskPlaceOnEventList>
    28fe:	0f b6       	in	r0, 0x3f	; 63
    2900:	f8 94       	cli
    2902:	0f 92       	push	r0
    2904:	f8 01       	movw	r30, r16
    2906:	86 8d       	ldd	r24, Z+30	; 0x1e
    2908:	18 16       	cp	r1, r24
    290a:	ac f4       	brge	.+42     	; 0x2936 <xQueueGive+0x13c>
    290c:	81 89       	ldd	r24, Z+17	; 0x11
    290e:	81 11       	cpse	r24, r1
    2910:	05 c0       	rjmp	.+10     	; 0x291c <xQueueGive+0x122>
    2912:	11 c0       	rjmp	.+34     	; 0x2936 <xQueueGive+0x13c>
    2914:	f8 01       	movw	r30, r16
    2916:	81 89       	ldd	r24, Z+17	; 0x11
    2918:	88 23       	and	r24, r24
    291a:	69 f0       	breq	.+26     	; 0x2936 <xQueueGive+0x13c>
    291c:	c6 01       	movw	r24, r12
    291e:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2922:	81 11       	cpse	r24, r1
    2924:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2928:	f8 01       	movw	r30, r16
    292a:	86 8d       	ldd	r24, Z+30	; 0x1e
    292c:	81 50       	subi	r24, 0x01	; 1
    292e:	86 8f       	std	Z+30, r24	; 0x1e
    2930:	86 8d       	ldd	r24, Z+30	; 0x1e
    2932:	18 16       	cp	r1, r24
    2934:	7c f3       	brlt	.-34     	; 0x2914 <xQueueGive+0x11a>
    2936:	f8 01       	movw	r30, r16
    2938:	b6 8e       	std	Z+30, r11	; 0x1e
    293a:	0f 90       	pop	r0
    293c:	0f be       	out	0x3f, r0	; 63
    293e:	0f b6       	in	r0, 0x3f	; 63
    2940:	f8 94       	cli
    2942:	0f 92       	push	r0
    2944:	85 8d       	ldd	r24, Z+29	; 0x1d
    2946:	18 16       	cp	r1, r24
    2948:	ac f4       	brge	.+42     	; 0x2974 <xQueueGive+0x17a>
    294a:	80 85       	ldd	r24, Z+8	; 0x08
    294c:	81 11       	cpse	r24, r1
    294e:	05 c0       	rjmp	.+10     	; 0x295a <xQueueGive+0x160>
    2950:	11 c0       	rjmp	.+34     	; 0x2974 <xQueueGive+0x17a>
    2952:	f8 01       	movw	r30, r16
    2954:	80 85       	ldd	r24, Z+8	; 0x08
    2956:	88 23       	and	r24, r24
    2958:	69 f0       	breq	.+26     	; 0x2974 <xQueueGive+0x17a>
    295a:	c7 01       	movw	r24, r14
    295c:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2960:	81 11       	cpse	r24, r1
    2962:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2966:	f8 01       	movw	r30, r16
    2968:	85 8d       	ldd	r24, Z+29	; 0x1d
    296a:	81 50       	subi	r24, 0x01	; 1
    296c:	85 8f       	std	Z+29, r24	; 0x1d
    296e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2970:	18 16       	cp	r1, r24
    2972:	7c f3       	brlt	.-34     	; 0x2952 <xQueueGive+0x158>
    2974:	f8 01       	movw	r30, r16
    2976:	b5 8e       	std	Z+29, r11	; 0x1d
    2978:	0f 90       	pop	r0
    297a:	0f be       	out	0x3f, r0	; 63
    297c:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    2980:	81 11       	cpse	r24, r1
    2982:	5b cf       	rjmp	.-330    	; 0x283a <xQueueGive+0x40>
    2984:	bf da       	rcall	.-2690   	; 0x1f04 <vPortYield>
    2986:	59 cf       	rjmp	.-334    	; 0x283a <xQueueGive+0x40>
    2988:	0f b6       	in	r0, 0x3f	; 63
    298a:	f8 94       	cli
    298c:	0f 92       	push	r0
    298e:	f8 01       	movw	r30, r16
    2990:	86 8d       	ldd	r24, Z+30	; 0x1e
    2992:	18 16       	cp	r1, r24
    2994:	ac f4       	brge	.+42     	; 0x29c0 <xQueueGive+0x1c6>
    2996:	81 89       	ldd	r24, Z+17	; 0x11
    2998:	81 11       	cpse	r24, r1
    299a:	05 c0       	rjmp	.+10     	; 0x29a6 <xQueueGive+0x1ac>
    299c:	11 c0       	rjmp	.+34     	; 0x29c0 <xQueueGive+0x1c6>
    299e:	f8 01       	movw	r30, r16
    29a0:	81 89       	ldd	r24, Z+17	; 0x11
    29a2:	88 23       	and	r24, r24
    29a4:	69 f0       	breq	.+26     	; 0x29c0 <xQueueGive+0x1c6>
    29a6:	c6 01       	movw	r24, r12
    29a8:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    29ac:	81 11       	cpse	r24, r1
    29ae:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    29b2:	f8 01       	movw	r30, r16
    29b4:	86 8d       	ldd	r24, Z+30	; 0x1e
    29b6:	81 50       	subi	r24, 0x01	; 1
    29b8:	86 8f       	std	Z+30, r24	; 0x1e
    29ba:	86 8d       	ldd	r24, Z+30	; 0x1e
    29bc:	18 16       	cp	r1, r24
    29be:	7c f3       	brlt	.-34     	; 0x299e <xQueueGive+0x1a4>
    29c0:	f8 01       	movw	r30, r16
    29c2:	b6 8e       	std	Z+30, r11	; 0x1e
    29c4:	0f 90       	pop	r0
    29c6:	0f be       	out	0x3f, r0	; 63
    29c8:	0f b6       	in	r0, 0x3f	; 63
    29ca:	f8 94       	cli
    29cc:	0f 92       	push	r0
    29ce:	85 8d       	ldd	r24, Z+29	; 0x1d
    29d0:	18 16       	cp	r1, r24
    29d2:	ac f4       	brge	.+42     	; 0x29fe <xQueueGive+0x204>
    29d4:	80 85       	ldd	r24, Z+8	; 0x08
    29d6:	81 11       	cpse	r24, r1
    29d8:	05 c0       	rjmp	.+10     	; 0x29e4 <xQueueGive+0x1ea>
    29da:	11 c0       	rjmp	.+34     	; 0x29fe <xQueueGive+0x204>
    29dc:	f8 01       	movw	r30, r16
    29de:	80 85       	ldd	r24, Z+8	; 0x08
    29e0:	88 23       	and	r24, r24
    29e2:	69 f0       	breq	.+26     	; 0x29fe <xQueueGive+0x204>
    29e4:	c7 01       	movw	r24, r14
    29e6:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    29ea:	81 11       	cpse	r24, r1
    29ec:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    29f0:	f8 01       	movw	r30, r16
    29f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    29f4:	81 50       	subi	r24, 0x01	; 1
    29f6:	85 8f       	std	Z+29, r24	; 0x1d
    29f8:	85 8d       	ldd	r24, Z+29	; 0x1d
    29fa:	18 16       	cp	r1, r24
    29fc:	7c f3       	brlt	.-34     	; 0x29dc <xQueueGive+0x1e2>
    29fe:	f8 01       	movw	r30, r16
    2a00:	b5 8e       	std	Z+29, r11	; 0x1d
    2a02:	0f 90       	pop	r0
    2a04:	0f be       	out	0x3f, r0	; 63
    2a06:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    2a0a:	17 cf       	rjmp	.-466    	; 0x283a <xQueueGive+0x40>
    2a0c:	0f b6       	in	r0, 0x3f	; 63
    2a0e:	f8 94       	cli
    2a10:	0f 92       	push	r0
    2a12:	f8 01       	movw	r30, r16
    2a14:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a16:	18 16       	cp	r1, r24
    2a18:	d4 f4       	brge	.+52     	; 0x2a4e <xQueueGive+0x254>
    2a1a:	81 89       	ldd	r24, Z+17	; 0x11
    2a1c:	81 11       	cpse	r24, r1
    2a1e:	06 c0       	rjmp	.+12     	; 0x2a2c <xQueueGive+0x232>
    2a20:	16 c0       	rjmp	.+44     	; 0x2a4e <xQueueGive+0x254>
    2a22:	f8 01       	movw	r30, r16
    2a24:	81 89       	ldd	r24, Z+17	; 0x11
    2a26:	81 11       	cpse	r24, r1
    2a28:	05 c0       	rjmp	.+10     	; 0x2a34 <xQueueGive+0x23a>
    2a2a:	11 c0       	rjmp	.+34     	; 0x2a4e <xQueueGive+0x254>
    2a2c:	78 01       	movw	r14, r16
    2a2e:	f1 e1       	ldi	r31, 0x11	; 17
    2a30:	ef 0e       	add	r14, r31
    2a32:	f1 1c       	adc	r15, r1
    2a34:	c7 01       	movw	r24, r14
    2a36:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2a3a:	81 11       	cpse	r24, r1
    2a3c:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2a40:	f8 01       	movw	r30, r16
    2a42:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a44:	81 50       	subi	r24, 0x01	; 1
    2a46:	86 8f       	std	Z+30, r24	; 0x1e
    2a48:	86 8d       	ldd	r24, Z+30	; 0x1e
    2a4a:	18 16       	cp	r1, r24
    2a4c:	54 f3       	brlt	.-44     	; 0x2a22 <xQueueGive+0x228>
    2a4e:	8f ef       	ldi	r24, 0xFF	; 255
    2a50:	f8 01       	movw	r30, r16
    2a52:	86 8f       	std	Z+30, r24	; 0x1e
    2a54:	0f 90       	pop	r0
    2a56:	0f be       	out	0x3f, r0	; 63
    2a58:	0f b6       	in	r0, 0x3f	; 63
    2a5a:	f8 94       	cli
    2a5c:	0f 92       	push	r0
    2a5e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a60:	18 16       	cp	r1, r24
    2a62:	d4 f4       	brge	.+52     	; 0x2a98 <xQueueGive+0x29e>
    2a64:	80 85       	ldd	r24, Z+8	; 0x08
    2a66:	81 11       	cpse	r24, r1
    2a68:	06 c0       	rjmp	.+12     	; 0x2a76 <xQueueGive+0x27c>
    2a6a:	16 c0       	rjmp	.+44     	; 0x2a98 <xQueueGive+0x29e>
    2a6c:	f8 01       	movw	r30, r16
    2a6e:	80 85       	ldd	r24, Z+8	; 0x08
    2a70:	81 11       	cpse	r24, r1
    2a72:	05 c0       	rjmp	.+10     	; 0x2a7e <xQueueGive+0x284>
    2a74:	11 c0       	rjmp	.+34     	; 0x2a98 <xQueueGive+0x29e>
    2a76:	78 01       	movw	r14, r16
    2a78:	f8 e0       	ldi	r31, 0x08	; 8
    2a7a:	ef 0e       	add	r14, r31
    2a7c:	f1 1c       	adc	r15, r1
    2a7e:	c7 01       	movw	r24, r14
    2a80:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2a84:	81 11       	cpse	r24, r1
    2a86:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
    2a8a:	f8 01       	movw	r30, r16
    2a8c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a8e:	81 50       	subi	r24, 0x01	; 1
    2a90:	85 8f       	std	Z+29, r24	; 0x1d
    2a92:	85 8d       	ldd	r24, Z+29	; 0x1d
    2a94:	18 16       	cp	r1, r24
    2a96:	54 f3       	brlt	.-44     	; 0x2a6c <xQueueGive+0x272>
    2a98:	8f ef       	ldi	r24, 0xFF	; 255
    2a9a:	f8 01       	movw	r30, r16
    2a9c:	85 8f       	std	Z+29, r24	; 0x1d
    2a9e:	0f 90       	pop	r0
    2aa0:	0f be       	out	0x3f, r0	; 63
    2aa2:	0e 94 84 1e 	call	0x3d08	; 0x3d08 <xTaskResumeAll>
    2aa6:	80 e0       	ldi	r24, 0x00	; 0
    2aa8:	08 c0       	rjmp	.+16     	; 0x2aba <xQueueGive+0x2c0>
    2aaa:	f8 01       	movw	r30, r16
    2aac:	82 8d       	ldd	r24, Z+26	; 0x1a
    2aae:	8f 5f       	subi	r24, 0xFF	; 255
    2ab0:	82 8f       	std	Z+26, r24	; 0x1a
    2ab2:	81 89       	ldd	r24, Z+17	; 0x11
    2ab4:	81 11       	cpse	r24, r1
    2ab6:	db ce       	rjmp	.-586    	; 0x286e <xQueueGive+0x74>
    2ab8:	e4 ce       	rjmp	.-568    	; 0x2882 <xQueueGive+0x88>
    2aba:	0f 90       	pop	r0
    2abc:	0f 90       	pop	r0
    2abe:	0f 90       	pop	r0
    2ac0:	0f 90       	pop	r0
    2ac2:	0f 90       	pop	r0
    2ac4:	df 91       	pop	r29
    2ac6:	cf 91       	pop	r28
    2ac8:	1f 91       	pop	r17
    2aca:	0f 91       	pop	r16
    2acc:	ff 90       	pop	r15
    2ace:	ef 90       	pop	r14
    2ad0:	df 90       	pop	r13
    2ad2:	cf 90       	pop	r12
    2ad4:	bf 90       	pop	r11
    2ad6:	af 90       	pop	r10
    2ad8:	9f 90       	pop	r9
    2ada:	08 95       	ret

00002adc <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    2adc:	cf 93       	push	r28
    2ade:	df 93       	push	r29
    2ae0:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    2ae2:	92 8d       	ldd	r25, Z+26	; 0x1a
    2ae4:	83 8d       	ldd	r24, Z+27	; 0x1b
    2ae6:	98 17       	cp	r25, r24
    2ae8:	d0 f4       	brcc	.+52     	; 0x2b1e <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    2aea:	82 8d       	ldd	r24, Z+26	; 0x1a
    2aec:	8f 5f       	subi	r24, 0xFF	; 255
    2aee:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    2af0:	86 8d       	ldd	r24, Z+30	; 0x1e
    2af2:	8f 3f       	cpi	r24, 0xFF	; 255
    2af4:	79 f4       	brne	.+30     	; 0x2b14 <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2af6:	81 89       	ldd	r24, Z+17	; 0x11
    2af8:	88 23       	and	r24, r24
    2afa:	99 f0       	breq	.+38     	; 0x2b22 <xQueueGiveFromISR+0x46>
    2afc:	eb 01       	movw	r28, r22
    2afe:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b00:	41 96       	adiw	r24, 0x11	; 17
    2b02:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2b06:	88 23       	and	r24, r24
    2b08:	71 f0       	breq	.+28     	; 0x2b26 <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    2b0a:	20 97       	sbiw	r28, 0x00	; 0
    2b0c:	71 f0       	breq	.+28     	; 0x2b2a <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	88 83       	st	Y, r24
    2b12:	0c c0       	rjmp	.+24     	; 0x2b2c <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    2b14:	86 8d       	ldd	r24, Z+30	; 0x1e
    2b16:	8f 5f       	subi	r24, 0xFF	; 255
    2b18:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    2b1a:	81 e0       	ldi	r24, 0x01	; 1
    2b1c:	07 c0       	rjmp	.+14     	; 0x2b2c <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2b1e:	80 e0       	ldi	r24, 0x00	; 0
    2b20:	05 c0       	rjmp	.+10     	; 0x2b2c <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    2b22:	81 e0       	ldi	r24, 0x01	; 1
    2b24:	03 c0       	rjmp	.+6      	; 0x2b2c <xQueueGiveFromISR+0x50>
    2b26:	81 e0       	ldi	r24, 0x01	; 1
    2b28:	01 c0       	rjmp	.+2      	; 0x2b2c <xQueueGiveFromISR+0x50>
    2b2a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    2b2c:	df 91       	pop	r29
    2b2e:	cf 91       	pop	r28
    2b30:	08 95       	ret

00002b32 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    2b32:	6f 92       	push	r6
    2b34:	7f 92       	push	r7
    2b36:	8f 92       	push	r8
    2b38:	9f 92       	push	r9
    2b3a:	af 92       	push	r10
    2b3c:	bf 92       	push	r11
    2b3e:	cf 92       	push	r12
    2b40:	df 92       	push	r13
    2b42:	ef 92       	push	r14
    2b44:	ff 92       	push	r15
    2b46:	0f 93       	push	r16
    2b48:	1f 93       	push	r17
    2b4a:	cf 93       	push	r28
    2b4c:	df 93       	push	r29
    2b4e:	00 d0       	rcall	.+0      	; 0x2b50 <xQueueGenericReceive+0x1e>
    2b50:	1f 92       	push	r1
    2b52:	1f 92       	push	r1
    2b54:	cd b7       	in	r28, 0x3d	; 61
    2b56:	de b7       	in	r29, 0x3e	; 62
    2b58:	8c 01       	movw	r16, r24
    2b5a:	5b 01       	movw	r10, r22
    2b5c:	5d 83       	std	Y+5, r21	; 0x05
    2b5e:	4c 83       	std	Y+4, r20	; 0x04
    2b60:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    2b62:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    2b64:	77 24       	eor	r7, r7
    2b66:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2b68:	99 24       	eor	r9, r9
    2b6a:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2b6c:	6c 01       	movw	r12, r24
    2b6e:	88 e0       	ldi	r24, 0x08	; 8
    2b70:	c8 0e       	add	r12, r24
    2b72:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2b74:	78 01       	movw	r14, r16
    2b76:	e1 e1       	ldi	r30, 0x11	; 17
    2b78:	ee 0e       	add	r14, r30
    2b7a:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    2b7c:	0f b6       	in	r0, 0x3f	; 63
    2b7e:	f8 94       	cli
    2b80:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    2b82:	f8 01       	movw	r30, r16
    2b84:	82 8d       	ldd	r24, Z+26	; 0x1a
    2b86:	88 23       	and	r24, r24
    2b88:	09 f4       	brne	.+2      	; 0x2b8c <xQueueGenericReceive+0x5a>
    2b8a:	45 c0       	rjmp	.+138    	; 0x2c16 <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    2b8c:	e6 80       	ldd	r14, Z+6	; 0x06
    2b8e:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    2b90:	44 8d       	ldd	r20, Z+28	; 0x1c
    2b92:	44 23       	and	r20, r20
    2b94:	a9 f0       	breq	.+42     	; 0x2bc0 <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    2b96:	50 e0       	ldi	r21, 0x00	; 0
    2b98:	c7 01       	movw	r24, r14
    2b9a:	84 0f       	add	r24, r20
    2b9c:	95 1f       	adc	r25, r21
    2b9e:	97 83       	std	Z+7, r25	; 0x07
    2ba0:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    2ba2:	22 81       	ldd	r18, Z+2	; 0x02
    2ba4:	33 81       	ldd	r19, Z+3	; 0x03
    2ba6:	82 17       	cp	r24, r18
    2ba8:	93 07       	cpc	r25, r19
    2baa:	20 f0       	brcs	.+8      	; 0x2bb4 <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    2bac:	80 81       	ld	r24, Z
    2bae:	91 81       	ldd	r25, Z+1	; 0x01
    2bb0:	97 83       	std	Z+7, r25	; 0x07
    2bb2:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    2bb4:	f8 01       	movw	r30, r16
    2bb6:	66 81       	ldd	r22, Z+6	; 0x06
    2bb8:	77 81       	ldd	r23, Z+7	; 0x07
    2bba:	c5 01       	movw	r24, r10
    2bbc:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    2bc0:	61 10       	cpse	r6, r1
    2bc2:	19 c0       	rjmp	.+50     	; 0x2bf6 <xQueueGenericReceive+0xc4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    2bc4:	f8 01       	movw	r30, r16
    2bc6:	82 8d       	ldd	r24, Z+26	; 0x1a
    2bc8:	81 50       	subi	r24, 0x01	; 1
    2bca:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2bcc:	80 81       	ld	r24, Z
    2bce:	91 81       	ldd	r25, Z+1	; 0x01
    2bd0:	89 2b       	or	r24, r25
    2bd2:	29 f4       	brne	.+10     	; 0x2bde <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    2bd4:	0e 94 a6 22 	call	0x454c	; 0x454c <pvTaskIncrementMutexHeldCount>
    2bd8:	f8 01       	movw	r30, r16
    2bda:	93 83       	std	Z+3, r25	; 0x03
    2bdc:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2bde:	f8 01       	movw	r30, r16
    2be0:	80 85       	ldd	r24, Z+8	; 0x08
    2be2:	88 23       	and	r24, r24
    2be4:	a1 f0       	breq	.+40     	; 0x2c0e <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    2be6:	c8 01       	movw	r24, r16
    2be8:	08 96       	adiw	r24, 0x08	; 8
    2bea:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2bee:	81 30       	cpi	r24, 0x01	; 1
    2bf0:	71 f4       	brne	.+28     	; 0x2c0e <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
    2bf2:	88 d9       	rcall	.-3312   	; 0x1f04 <vPortYield>
    2bf4:	0c c0       	rjmp	.+24     	; 0x2c0e <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    2bf6:	f8 01       	movw	r30, r16
    2bf8:	f7 82       	std	Z+7, r15	; 0x07
    2bfa:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2bfc:	81 89       	ldd	r24, Z+17	; 0x11
    2bfe:	88 23       	and	r24, r24
    2c00:	31 f0       	breq	.+12     	; 0x2c0e <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2c02:	c8 01       	movw	r24, r16
    2c04:	41 96       	adiw	r24, 0x11	; 17
    2c06:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    2c0a:	81 11       	cpse	r24, r1
    2c0c:	7b d9       	rcall	.-3338   	; 0x1f04 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    2c0e:	0f 90       	pop	r0
    2c10:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    2c12:	81 e0       	ldi	r24, 0x01	; 1
    2c14:	18 c1       	rjmp	.+560    	; 0x2e46 <xQueueGenericReceive+0x314>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    2c16:	8c 81       	ldd	r24, Y+4	; 0x04
    2c18:	9d 81       	ldd	r25, Y+5	; 0x05
    2c1a:	89 2b       	or	r24, r25
    2c1c:	21 f4       	brne	.+8      	; 0x2c26 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2c1e:	0f 90       	pop	r0
    2c20:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2c22:	80 e0       	ldi	r24, 0x00	; 0
    2c24:	10 c1       	rjmp	.+544    	; 0x2e46 <xQueueGenericReceive+0x314>
				}
				else if( xEntryTimeSet == pdFALSE )
    2c26:	81 10       	cpse	r8, r1
    2c28:	05 c0       	rjmp	.+10     	; 0x2c34 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2c2a:	ce 01       	movw	r24, r28
    2c2c:	01 96       	adiw	r24, 0x01	; 1
    2c2e:	0e 94 b5 21 	call	0x436a	; 0x436a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2c32:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    2c34:	0f 90       	pop	r0
    2c36:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2c38:	0e 94 7e 1e 	call	0x3cfc	; 0x3cfc <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2c3c:	0f b6       	in	r0, 0x3f	; 63
    2c3e:	f8 94       	cli
    2c40:	0f 92       	push	r0
    2c42:	f8 01       	movw	r30, r16
    2c44:	85 8d       	ldd	r24, Z+29	; 0x1d
    2c46:	8f 3f       	cpi	r24, 0xFF	; 255
    2c48:	09 f4       	brne	.+2      	; 0x2c4c <xQueueGenericReceive+0x11a>
    2c4a:	15 8e       	std	Z+29, r1	; 0x1d
    2c4c:	f8 01       	movw	r30, r16
    2c4e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2c50:	8f 3f       	cpi	r24, 0xFF	; 255
    2c52:	09 f4       	brne	.+2      	; 0x2c56 <xQueueGenericReceive+0x124>
    2c54:	16 8e       	std	Z+30, r1	; 0x1e
    2c56:	0f 90       	pop	r0
    2c58:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    2c5a:	be 01       	movw	r22, r28
    2c5c:	6c 5f       	subi	r22, 0xFC	; 252
    2c5e:	7f 4f       	sbci	r23, 0xFF	; 255
    2c60:	ce 01       	movw	r24, r28
    2c62:	01 96       	adiw	r24, 0x01	; 1
    2c64:	0e 94 c0 21 	call	0x4380	; 0x4380 <xTaskCheckForTimeOut>
    2c68:	81 11       	cpse	r24, r1
    2c6a:	a0 c0       	rjmp	.+320    	; 0x2dac <xQueueGenericReceive+0x27a>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    2c6c:	0f b6       	in	r0, 0x3f	; 63
    2c6e:	f8 94       	cli
    2c70:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    2c72:	f8 01       	movw	r30, r16
    2c74:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    2c76:	0f 90       	pop	r0
    2c78:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2c7a:	81 11       	cpse	r24, r1
    2c7c:	56 c0       	rjmp	.+172    	; 0x2d2a <xQueueGenericReceive+0x1f8>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    2c7e:	80 81       	ld	r24, Z
    2c80:	91 81       	ldd	r25, Z+1	; 0x01
    2c82:	89 2b       	or	r24, r25
    2c84:	49 f4       	brne	.+18     	; 0x2c98 <xQueueGenericReceive+0x166>
					{
						taskENTER_CRITICAL();
    2c86:	0f b6       	in	r0, 0x3f	; 63
    2c88:	f8 94       	cli
    2c8a:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2c8c:	82 81       	ldd	r24, Z+2	; 0x02
    2c8e:	93 81       	ldd	r25, Z+3	; 0x03
    2c90:	0e 94 04 22 	call	0x4408	; 0x4408 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    2c94:	0f 90       	pop	r0
    2c96:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2c98:	6c 81       	ldd	r22, Y+4	; 0x04
    2c9a:	7d 81       	ldd	r23, Y+5	; 0x05
    2c9c:	c7 01       	movw	r24, r14
    2c9e:	0e 94 12 21 	call	0x4224	; 0x4224 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2ca2:	0f b6       	in	r0, 0x3f	; 63
    2ca4:	f8 94       	cli
    2ca6:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2ca8:	f8 01       	movw	r30, r16
    2caa:	86 8d       	ldd	r24, Z+30	; 0x1e
    2cac:	18 16       	cp	r1, r24
    2cae:	ac f4       	brge	.+42     	; 0x2cda <xQueueGenericReceive+0x1a8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2cb0:	81 89       	ldd	r24, Z+17	; 0x11
    2cb2:	81 11       	cpse	r24, r1
    2cb4:	05 c0       	rjmp	.+10     	; 0x2cc0 <xQueueGenericReceive+0x18e>
    2cb6:	11 c0       	rjmp	.+34     	; 0x2cda <xQueueGenericReceive+0x1a8>
    2cb8:	f8 01       	movw	r30, r16
    2cba:	81 89       	ldd	r24, Z+17	; 0x11
    2cbc:	88 23       	and	r24, r24
    2cbe:	69 f0       	breq	.+26     	; 0x2cda <xQueueGenericReceive+0x1a8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2cc0:	c7 01       	movw	r24, r14
    2cc2:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2cc6:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2cc8:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2ccc:	f8 01       	movw	r30, r16
    2cce:	86 8d       	ldd	r24, Z+30	; 0x1e
    2cd0:	81 50       	subi	r24, 0x01	; 1
    2cd2:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2cd4:	86 8d       	ldd	r24, Z+30	; 0x1e
    2cd6:	18 16       	cp	r1, r24
    2cd8:	7c f3       	brlt	.-34     	; 0x2cb8 <xQueueGenericReceive+0x186>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2cda:	f8 01       	movw	r30, r16
    2cdc:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    2cde:	0f 90       	pop	r0
    2ce0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2ce2:	0f b6       	in	r0, 0x3f	; 63
    2ce4:	f8 94       	cli
    2ce6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2ce8:	85 8d       	ldd	r24, Z+29	; 0x1d
    2cea:	18 16       	cp	r1, r24
    2cec:	ac f4       	brge	.+42     	; 0x2d18 <xQueueGenericReceive+0x1e6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2cee:	80 85       	ldd	r24, Z+8	; 0x08
    2cf0:	81 11       	cpse	r24, r1
    2cf2:	05 c0       	rjmp	.+10     	; 0x2cfe <xQueueGenericReceive+0x1cc>
    2cf4:	11 c0       	rjmp	.+34     	; 0x2d18 <xQueueGenericReceive+0x1e6>
    2cf6:	f8 01       	movw	r30, r16
    2cf8:	80 85       	ldd	r24, Z+8	; 0x08
    2cfa:	88 23       	and	r24, r24
    2cfc:	69 f0       	breq	.+26     	; 0x2d18 <xQueueGenericReceive+0x1e6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2cfe:	c6 01       	movw	r24, r12
    2d00:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2d04:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    2d06:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2d0a:	f8 01       	movw	r30, r16
    2d0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d0e:	81 50       	subi	r24, 0x01	; 1
    2d10:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2d12:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d14:	18 16       	cp	r1, r24
    2d16:	7c f3       	brlt	.-34     	; 0x2cf6 <xQueueGenericReceive+0x1c4>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2d18:	f8 01       	movw	r30, r16
    2d1a:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    2d1c:	0f 90       	pop	r0
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    2d1e:	0f be       	out	0x3f, r0	; 63
    2d20:	f3 d7       	rcall	.+4070   	; 0x3d08 <xTaskResumeAll>
    2d22:	81 11       	cpse	r24, r1
				{
					portYIELD_WITHIN_API();
    2d24:	2b cf       	rjmp	.-426    	; 0x2b7c <xQueueGenericReceive+0x4a>
    2d26:	ee d8       	rcall	.-3620   	; 0x1f04 <vPortYield>
    2d28:	29 cf       	rjmp	.-430    	; 0x2b7c <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2d2a:	0f b6       	in	r0, 0x3f	; 63
    2d2c:	f8 94       	cli
    2d2e:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2d30:	f8 01       	movw	r30, r16
    2d32:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d34:	18 16       	cp	r1, r24
    2d36:	ac f4       	brge	.+42     	; 0x2d62 <xQueueGenericReceive+0x230>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2d38:	81 89       	ldd	r24, Z+17	; 0x11
    2d3a:	81 11       	cpse	r24, r1
    2d3c:	05 c0       	rjmp	.+10     	; 0x2d48 <xQueueGenericReceive+0x216>
    2d3e:	11 c0       	rjmp	.+34     	; 0x2d62 <xQueueGenericReceive+0x230>
    2d40:	f8 01       	movw	r30, r16
    2d42:	81 89       	ldd	r24, Z+17	; 0x11
    2d44:	88 23       	and	r24, r24
    2d46:	69 f0       	breq	.+26     	; 0x2d62 <xQueueGenericReceive+0x230>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2d48:	c7 01       	movw	r24, r14
    2d4a:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2d4e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2d50:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2d54:	f8 01       	movw	r30, r16
    2d56:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d58:	81 50       	subi	r24, 0x01	; 1
    2d5a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2d5c:	86 8d       	ldd	r24, Z+30	; 0x1e
    2d5e:	18 16       	cp	r1, r24
    2d60:	7c f3       	brlt	.-34     	; 0x2d40 <xQueueGenericReceive+0x20e>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2d62:	f8 01       	movw	r30, r16
    2d64:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    2d66:	0f 90       	pop	r0
    2d68:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2d6a:	0f b6       	in	r0, 0x3f	; 63
    2d6c:	f8 94       	cli
    2d6e:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2d70:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d72:	18 16       	cp	r1, r24
    2d74:	ac f4       	brge	.+42     	; 0x2da0 <xQueueGenericReceive+0x26e>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2d76:	80 85       	ldd	r24, Z+8	; 0x08
    2d78:	81 11       	cpse	r24, r1
    2d7a:	05 c0       	rjmp	.+10     	; 0x2d86 <xQueueGenericReceive+0x254>
    2d7c:	11 c0       	rjmp	.+34     	; 0x2da0 <xQueueGenericReceive+0x26e>
    2d7e:	f8 01       	movw	r30, r16
    2d80:	80 85       	ldd	r24, Z+8	; 0x08
    2d82:	88 23       	and	r24, r24
    2d84:	69 f0       	breq	.+26     	; 0x2da0 <xQueueGenericReceive+0x26e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2d86:	c6 01       	movw	r24, r12
    2d88:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2d8c:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    2d8e:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2d92:	f8 01       	movw	r30, r16
    2d94:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d96:	81 50       	subi	r24, 0x01	; 1
    2d98:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2d9a:	85 8d       	ldd	r24, Z+29	; 0x1d
    2d9c:	18 16       	cp	r1, r24
    2d9e:	7c f3       	brlt	.-34     	; 0x2d7e <xQueueGenericReceive+0x24c>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2da0:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    2da2:	95 8e       	std	Z+29, r9	; 0x1d
    2da4:	0f 90       	pop	r0
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    2da6:	0f be       	out	0x3f, r0	; 63
    2da8:	af d7       	rcall	.+3934   	; 0x3d08 <xTaskResumeAll>
    2daa:	e8 ce       	rjmp	.-560    	; 0x2b7c <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2dac:	0f b6       	in	r0, 0x3f	; 63
    2dae:	f8 94       	cli
    2db0:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2db2:	f8 01       	movw	r30, r16
    2db4:	86 8d       	ldd	r24, Z+30	; 0x1e
    2db6:	18 16       	cp	r1, r24
    2db8:	d4 f4       	brge	.+52     	; 0x2dee <xQueueGenericReceive+0x2bc>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2dba:	81 89       	ldd	r24, Z+17	; 0x11
    2dbc:	81 11       	cpse	r24, r1
    2dbe:	06 c0       	rjmp	.+12     	; 0x2dcc <xQueueGenericReceive+0x29a>
    2dc0:	16 c0       	rjmp	.+44     	; 0x2dee <xQueueGenericReceive+0x2bc>
    2dc2:	f8 01       	movw	r30, r16
    2dc4:	81 89       	ldd	r24, Z+17	; 0x11
    2dc6:	81 11       	cpse	r24, r1
    2dc8:	05 c0       	rjmp	.+10     	; 0x2dd4 <xQueueGenericReceive+0x2a2>
    2dca:	11 c0       	rjmp	.+34     	; 0x2dee <xQueueGenericReceive+0x2bc>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2dcc:	78 01       	movw	r14, r16
    2dce:	f1 e1       	ldi	r31, 0x11	; 17
    2dd0:	ef 0e       	add	r14, r31
    2dd2:	f1 1c       	adc	r15, r1
    2dd4:	c7 01       	movw	r24, r14
    2dd6:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2dda:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2ddc:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2de0:	f8 01       	movw	r30, r16
    2de2:	86 8d       	ldd	r24, Z+30	; 0x1e
    2de4:	81 50       	subi	r24, 0x01	; 1
    2de6:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2de8:	86 8d       	ldd	r24, Z+30	; 0x1e
    2dea:	18 16       	cp	r1, r24
    2dec:	54 f3       	brlt	.-44     	; 0x2dc2 <xQueueGenericReceive+0x290>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2dee:	8f ef       	ldi	r24, 0xFF	; 255
    2df0:	f8 01       	movw	r30, r16
    2df2:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2df4:	0f 90       	pop	r0
    2df6:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2df8:	0f b6       	in	r0, 0x3f	; 63
    2dfa:	f8 94       	cli
    2dfc:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2dfe:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e00:	18 16       	cp	r1, r24
    2e02:	d4 f4       	brge	.+52     	; 0x2e38 <xQueueGenericReceive+0x306>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2e04:	80 85       	ldd	r24, Z+8	; 0x08
    2e06:	81 11       	cpse	r24, r1
    2e08:	06 c0       	rjmp	.+12     	; 0x2e16 <xQueueGenericReceive+0x2e4>
    2e0a:	16 c0       	rjmp	.+44     	; 0x2e38 <xQueueGenericReceive+0x306>
    2e0c:	f8 01       	movw	r30, r16
    2e0e:	80 85       	ldd	r24, Z+8	; 0x08
    2e10:	81 11       	cpse	r24, r1
    2e12:	05 c0       	rjmp	.+10     	; 0x2e1e <xQueueGenericReceive+0x2ec>
    2e14:	11 c0       	rjmp	.+34     	; 0x2e38 <xQueueGenericReceive+0x306>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2e16:	78 01       	movw	r14, r16
    2e18:	f8 e0       	ldi	r31, 0x08	; 8
    2e1a:	ef 0e       	add	r14, r31
    2e1c:	f1 1c       	adc	r15, r1
    2e1e:	c7 01       	movw	r24, r14
    2e20:	0e 94 6d 21 	call	0x42da	; 0x42da <xTaskRemoveFromEventList>
    2e24:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    2e26:	0e 94 fb 21 	call	0x43f6	; 0x43f6 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2e2a:	f8 01       	movw	r30, r16
    2e2c:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e2e:	81 50       	subi	r24, 0x01	; 1
    2e30:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2e32:	85 8d       	ldd	r24, Z+29	; 0x1d
    2e34:	18 16       	cp	r1, r24
    2e36:	54 f3       	brlt	.-44     	; 0x2e0c <xQueueGenericReceive+0x2da>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2e38:	8f ef       	ldi	r24, 0xFF	; 255
    2e3a:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    2e3c:	85 8f       	std	Z+29, r24	; 0x1d
    2e3e:	0f 90       	pop	r0
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    2e40:	0f be       	out	0x3f, r0	; 63
    2e42:	62 d7       	rcall	.+3780   	; 0x3d08 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2e44:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    2e46:	0f 90       	pop	r0
    2e48:	0f 90       	pop	r0
    2e4a:	0f 90       	pop	r0
    2e4c:	0f 90       	pop	r0
    2e4e:	0f 90       	pop	r0
    2e50:	df 91       	pop	r29
    2e52:	cf 91       	pop	r28
    2e54:	1f 91       	pop	r17
    2e56:	0f 91       	pop	r16
    2e58:	ff 90       	pop	r15
    2e5a:	ef 90       	pop	r14
    2e5c:	df 90       	pop	r13
    2e5e:	cf 90       	pop	r12
    2e60:	bf 90       	pop	r11
    2e62:	af 90       	pop	r10
    2e64:	9f 90       	pop	r9
    2e66:	8f 90       	pop	r8
    2e68:	7f 90       	pop	r7
    2e6a:	6f 90       	pop	r6
    2e6c:	08 95       	ret

00002e6e <server_receiver>:
void send_idle(void) {
  if(!connected) return;
  uint8_t status = TYPE_IDLE;
  if(use_arq[TYPE_IDLE]) arq_send(server_connection, &status, 1);
  else simple_p_send(SERVER_ADDRESS, &status, 1);
}
    2e6e:	ab 01       	movw	r20, r22
    2e70:	00 97       	sbiw	r24, 0x00	; 0
    2e72:	11 f4       	brne	.+4      	; 0x2e78 <server_receiver+0xa>
    2e74:	10 92 a0 15 	sts	0x15A0, r1	; 0x8015a0 <gHandshook>
    2e78:	bc 01       	movw	r22, r24
    2e7a:	85 e1       	ldi	r24, 0x15	; 21
    2e7c:	97 e1       	ldi	r25, 0x17	; 23
    2e7e:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    2e82:	60 e0       	ldi	r22, 0x00	; 0
    2e84:	70 e0       	ldi	r23, 0x00	; 0
    2e86:	80 91 11 17 	lds	r24, 0x1711	; 0x801711 <xCommandReadyBSem>
    2e8a:	90 91 12 17 	lds	r25, 0x1712	; 0x801712 <xCommandReadyBSem+0x1>
    2e8e:	b5 cc       	rjmp	.-1686   	; 0x27fa <xQueueGive>
    2e90:	08 95       	ret

00002e92 <server_communication_init>:
    2e92:	80 91 ad 15 	lds	r24, 0x15AD	; 0x8015ad <connected>
    2e96:	81 11       	cpse	r24, r1
    2e98:	04 c0       	rjmp	.+8      	; 0x2ea2 <server_communication_init+0x10>
    2e9a:	0e 94 3a 01 	call	0x274	; 0x274 <arq_new_connection>
    2e9e:	80 93 4b 17 	sts	0x174B, r24	; 0x80174b <server_connection>
    2ea2:	08 95       	ret

00002ea4 <server_connect>:
    2ea4:	28 ee       	ldi	r18, 0xE8	; 232
    2ea6:	33 e0       	ldi	r19, 0x03	; 3
    2ea8:	47 e3       	ldi	r20, 0x37	; 55
    2eaa:	57 e1       	ldi	r21, 0x17	; 23
    2eac:	60 e0       	ldi	r22, 0x00	; 0
    2eae:	80 91 4b 17 	lds	r24, 0x174B	; 0x80174b <server_connection>
    2eb2:	0e 94 56 01 	call	0x2ac	; 0x2ac <arq_connect>
    2eb6:	80 93 ad 15 	sts	0x15AD, r24	; 0x8015ad <connected>
    2eba:	08 95       	ret

00002ebc <send_handshake>:
    2ebc:	cf 93       	push	r28
    2ebe:	df 93       	push	r29
    2ec0:	cd b7       	in	r28, 0x3d	; 61
    2ec2:	de b7       	in	r29, 0x3e	; 62
    2ec4:	ec 97       	sbiw	r28, 0x3c	; 60
    2ec6:	0f b6       	in	r0, 0x3f	; 63
    2ec8:	f8 94       	cli
    2eca:	de bf       	out	0x3e, r29	; 62
    2ecc:	0f be       	out	0x3f, r0	; 63
    2ece:	cd bf       	out	0x3d, r28	; 61
    2ed0:	80 91 ad 15 	lds	r24, 0x15AD	; 0x8015ad <connected>
    2ed4:	88 23       	and	r24, r24
    2ed6:	09 f4       	brne	.+2      	; 0x2eda <send_handshake+0x1e>
    2ed8:	4e c0       	rjmp	.+156    	; 0x2f76 <send_handshake+0xba>
    2eda:	19 82       	std	Y+1, r1	; 0x01
    2edc:	87 e0       	ldi	r24, 0x07	; 7
    2ede:	8a 83       	std	Y+2, r24	; 0x02
    2ee0:	88 e0       	ldi	r24, 0x08	; 8
    2ee2:	e7 e2       	ldi	r30, 0x27	; 39
    2ee4:	f2 e0       	ldi	r31, 0x02	; 2
    2ee6:	de 01       	movw	r26, r28
    2ee8:	13 96       	adiw	r26, 0x03	; 3
    2eea:	01 90       	ld	r0, Z+
    2eec:	0d 92       	st	X+, r0
    2eee:	8a 95       	dec	r24
    2ef0:	e1 f7       	brne	.-8      	; 0x2eea <send_handshake+0x2e>
    2ef2:	24 eb       	ldi	r18, 0xB4	; 180
    2ef4:	30 e0       	ldi	r19, 0x00	; 0
    2ef6:	3b 87       	std	Y+11, r19	; 0x0b
    2ef8:	2a 87       	std	Y+10, r18	; 0x0a
    2efa:	85 ef       	ldi	r24, 0xF5	; 245
    2efc:	90 e0       	ldi	r25, 0x00	; 0
    2efe:	9d 87       	std	Y+13, r25	; 0x0d
    2f00:	8c 87       	std	Y+12, r24	; 0x0c
    2f02:	88 e3       	ldi	r24, 0x38	; 56
    2f04:	88 8b       	std	Y+16, r24	; 0x10
    2f06:	8e 87       	std	Y+14, r24	; 0x0e
    2f08:	1f 86       	std	Y+15, r1	; 0x0f
    2f0a:	85 e1       	ldi	r24, 0x15	; 21
    2f0c:	89 8b       	std	Y+17, r24	; 0x11
    2f0e:	8a 8b       	std	Y+18, r24	; 0x12
    2f10:	8b 8b       	std	Y+19, r24	; 0x13
    2f12:	8c 8b       	std	Y+20, r24	; 0x14
    2f14:	1e 8a       	std	Y+22, r1	; 0x16
    2f16:	1d 8a       	std	Y+21, r1	; 0x15
    2f18:	8a e5       	ldi	r24, 0x5A	; 90
    2f1a:	90 e0       	ldi	r25, 0x00	; 0
    2f1c:	98 8f       	std	Y+24, r25	; 0x18
    2f1e:	8f 8b       	std	Y+23, r24	; 0x17
    2f20:	3a 8f       	std	Y+26, r19	; 0x1a
    2f22:	29 8f       	std	Y+25, r18	; 0x19
    2f24:	8e e0       	ldi	r24, 0x0E	; 14
    2f26:	91 e0       	ldi	r25, 0x01	; 1
    2f28:	9c 8f       	std	Y+28, r25	; 0x1c
    2f2a:	8b 8f       	std	Y+27, r24	; 0x1b
    2f2c:	88 ec       	ldi	r24, 0xC8	; 200
    2f2e:	90 e0       	ldi	r25, 0x00	; 0
    2f30:	9e 8f       	std	Y+30, r25	; 0x1e
    2f32:	8d 8f       	std	Y+29, r24	; 0x1d
    2f34:	8e e1       	ldi	r24, 0x1E	; 30
    2f36:	fe 01       	movw	r30, r28
    2f38:	31 96       	adiw	r30, 0x01	; 1
    2f3a:	de 01       	movw	r26, r28
    2f3c:	5f 96       	adiw	r26, 0x1f	; 31
    2f3e:	01 90       	ld	r0, Z+
    2f40:	0d 92       	st	X+, r0
    2f42:	8a 95       	dec	r24
    2f44:	e1 f7       	brne	.-8      	; 0x2f3e <send_handshake+0x82>
    2f46:	80 91 00 02 	lds	r24, 0x0200	; 0x800200 <__data_start>
    2f4a:	88 23       	and	r24, r24
    2f4c:	59 f0       	breq	.+22     	; 0x2f64 <send_handshake+0xa8>
    2f4e:	4e e1       	ldi	r20, 0x1E	; 30
    2f50:	50 e0       	ldi	r21, 0x00	; 0
    2f52:	be 01       	movw	r22, r28
    2f54:	61 5e       	subi	r22, 0xE1	; 225
    2f56:	7f 4f       	sbci	r23, 0xFF	; 255
    2f58:	80 91 4b 17 	lds	r24, 0x174B	; 0x80174b <server_connection>
    2f5c:	0e 94 0d 02 	call	0x41a	; 0x41a <arq_send>
    2f60:	81 e0       	ldi	r24, 0x01	; 1
    2f62:	09 c0       	rjmp	.+18     	; 0x2f76 <send_handshake+0xba>
    2f64:	4e e1       	ldi	r20, 0x1E	; 30
    2f66:	50 e0       	ldi	r21, 0x00	; 0
    2f68:	be 01       	movw	r22, r28
    2f6a:	61 5e       	subi	r22, 0xE1	; 225
    2f6c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f6e:	80 91 4b 17 	lds	r24, 0x174B	; 0x80174b <server_connection>
    2f72:	10 d1       	rcall	.+544    	; 0x3194 <simple_p_send>
    2f74:	81 e0       	ldi	r24, 0x01	; 1
    2f76:	ec 96       	adiw	r28, 0x3c	; 60
    2f78:	0f b6       	in	r0, 0x3f	; 63
    2f7a:	f8 94       	cli
    2f7c:	de bf       	out	0x3e, r29	; 62
    2f7e:	0f be       	out	0x3f, r0	; 63
    2f80:	cd bf       	out	0x3d, r28	; 61
    2f82:	df 91       	pop	r29
    2f84:	cf 91       	pop	r28
    2f86:	08 95       	ret

00002f88 <debug>:
void debug(const char *fmt, ...) {
    2f88:	cf 93       	push	r28
    2f8a:	df 93       	push	r29
    2f8c:	cd b7       	in	r28, 0x3d	; 61
    2f8e:	de b7       	in	r29, 0x3e	; 62
    2f90:	c4 56       	subi	r28, 0x64	; 100
    2f92:	d1 09       	sbc	r29, r1
    2f94:	0f b6       	in	r0, 0x3f	; 63
    2f96:	f8 94       	cli
    2f98:	de bf       	out	0x3e, r29	; 62
    2f9a:	0f be       	out	0x3f, r0	; 63
    2f9c:	cd bf       	out	0x3d, r28	; 61
    2f9e:	ae 01       	movw	r20, r28
    2fa0:	46 59       	subi	r20, 0x96	; 150
    2fa2:	5f 4f       	sbci	r21, 0xFF	; 255
    2fa4:	fa 01       	movw	r30, r20
    2fa6:	61 91       	ld	r22, Z+
    2fa8:	71 91       	ld	r23, Z+
    2faa:	af 01       	movw	r20, r30
	uint8_t buf[100];
	va_list ap;
	buf[0] = TYPE_DEBUG;
    2fac:	8a e0       	ldi	r24, 0x0A	; 10
    2fae:	89 83       	std	Y+1, r24	; 0x01
	va_start(ap, fmt);
	uint8_t ret = vsprintf((char*)buf+1, fmt, ap);
    2fb0:	ce 01       	movw	r24, r28
    2fb2:	02 96       	adiw	r24, 0x02	; 2
    2fb4:	0e 94 eb 2c 	call	0x59d6	; 0x59d6 <vsprintf>
	va_end(ap);
	if (ret > 0) {
    2fb8:	88 23       	and	r24, r24
    2fba:	c9 f0       	breq	.+50     	; 0x2fee <debug+0x66>
		if(use_arq[TYPE_DEBUG]) arq_send(server_connection, buf, ret+1);
    2fbc:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <__data_start+0xa>
    2fc0:	22 23       	and	r18, r18
    2fc2:	61 f0       	breq	.+24     	; 0x2fdc <debug+0x54>
    2fc4:	99 27       	eor	r25, r25
    2fc6:	ac 01       	movw	r20, r24
    2fc8:	4f 5f       	subi	r20, 0xFF	; 255
    2fca:	5f 4f       	sbci	r21, 0xFF	; 255
    2fcc:	be 01       	movw	r22, r28
    2fce:	6f 5f       	subi	r22, 0xFF	; 255
    2fd0:	7f 4f       	sbci	r23, 0xFF	; 255
    2fd2:	80 91 4b 17 	lds	r24, 0x174B	; 0x80174b <server_connection>
    2fd6:	0e 94 0d 02 	call	0x41a	; 0x41a <arq_send>
    2fda:	09 c0       	rjmp	.+18     	; 0x2fee <debug+0x66>
		else simple_p_send(SERVER_ADDRESS, buf, ret+1);
    2fdc:	99 27       	eor	r25, r25
    2fde:	ac 01       	movw	r20, r24
    2fe0:	4f 5f       	subi	r20, 0xFF	; 255
    2fe2:	5f 4f       	sbci	r21, 0xFF	; 255
    2fe4:	be 01       	movw	r22, r28
    2fe6:	6f 5f       	subi	r22, 0xFF	; 255
    2fe8:	7f 4f       	sbci	r23, 0xFF	; 255
    2fea:	80 e0       	ldi	r24, 0x00	; 0
    2fec:	d3 d0       	rcall	.+422    	; 0x3194 <simple_p_send>
	}
}
    2fee:	cc 59       	subi	r28, 0x9C	; 156
    2ff0:	df 4f       	sbci	r29, 0xFF	; 255
    2ff2:	0f b6       	in	r0, 0x3f	; 63
    2ff4:	f8 94       	cli
    2ff6:	de bf       	out	0x3e, r29	; 62
    2ff8:	0f be       	out	0x3f, r0	; 63
    2ffa:	cd bf       	out	0x3d, r28	; 61
    2ffc:	df 91       	pop	r29
    2ffe:	cf 91       	pop	r28
    3000:	08 95       	ret

00003002 <send_ping_response>:

void send_ping_response(void) {
    3002:	cf 93       	push	r28
    3004:	df 93       	push	r29
    3006:	1f 92       	push	r1
    3008:	cd b7       	in	r28, 0x3d	; 61
    300a:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    300c:	80 91 ad 15 	lds	r24, 0x15AD	; 0x8015ad <connected>
    3010:	88 23       	and	r24, r24
    3012:	b9 f0       	breq	.+46     	; 0x3042 <send_ping_response+0x40>
  uint8_t status = TYPE_PING_RESPONSE;
    3014:	89 e0       	ldi	r24, 0x09	; 9
    3016:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
    3018:	80 91 09 02 	lds	r24, 0x0209	; 0x800209 <__data_start+0x9>
    301c:	88 23       	and	r24, r24
    301e:	51 f0       	breq	.+20     	; 0x3034 <send_ping_response+0x32>
    3020:	41 e0       	ldi	r20, 0x01	; 1
    3022:	50 e0       	ldi	r21, 0x00	; 0
    3024:	be 01       	movw	r22, r28
    3026:	6f 5f       	subi	r22, 0xFF	; 255
    3028:	7f 4f       	sbci	r23, 0xFF	; 255
    302a:	80 91 4b 17 	lds	r24, 0x174B	; 0x80174b <server_connection>
    302e:	0e 94 0d 02 	call	0x41a	; 0x41a <arq_send>
    3032:	07 c0       	rjmp	.+14     	; 0x3042 <send_ping_response+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    3034:	41 e0       	ldi	r20, 0x01	; 1
    3036:	50 e0       	ldi	r21, 0x00	; 0
    3038:	be 01       	movw	r22, r28
    303a:	6f 5f       	subi	r22, 0xFF	; 255
    303c:	7f 4f       	sbci	r23, 0xFF	; 255
    303e:	80 e0       	ldi	r24, 0x00	; 0
    3040:	a9 d0       	rcall	.+338    	; 0x3194 <simple_p_send>
}
    3042:	0f 90       	pop	r0
    3044:	df 91       	pop	r29
    3046:	cf 91       	pop	r28
    3048:	08 95       	ret

0000304a <vServo_setAngle>:
}

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
    /* Ensure feasible values */
    if (ServoAngleDeg >= 90){
    304a:	8a 35       	cpi	r24, 0x5A	; 90
    304c:	08 f0       	brcs	.+2      	; 0x3050 <vServo_setAngle+0x6>
        ServoAngleDeg = 90;
    304e:	8a e5       	ldi	r24, 0x5A	; 90
    }
    else if(ServoAngleDeg <= 0){
        ServoAngleDeg = 0;
    }
    /* Fetch pulse width from array and set to output */
    servoOCR = DEG_TO_PWM[ServoAngleDeg];
    3050:	e8 2f       	mov	r30, r24
    3052:	f0 e0       	ldi	r31, 0x00	; 0
    3054:	ee 0f       	add	r30, r30
    3056:	ff 1f       	adc	r31, r31
    3058:	e1 5d       	subi	r30, 0xD1	; 209
    305a:	fd 4f       	sbci	r31, 0xFD	; 253
    305c:	80 81       	ld	r24, Z
    305e:	91 81       	ldd	r25, Z+1	; 0x01
    3060:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    3064:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    3068:	08 95       	ret

0000306a <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
    /* Clear OCnA/OCnB on Compare Match, set */
    /* OCnA/OCnB at BOTTOM (non-inverting mode) */
    /* Datasheet p.155 Table 17-4 */
    TCCR4A |= (1<<COM4B1) | (0<<COM4B0);
    306a:	a0 ea       	ldi	r26, 0xA0	; 160
    306c:	b0 e0       	ldi	r27, 0x00	; 0
    306e:	9c 91       	ld	r25, X
    3070:	90 62       	ori	r25, 0x20	; 32
    3072:	9c 93       	st	X, r25
    
    /* Waveform generation mode 14: Fast PWM */
    /* top: ICRn, Update bottom, flag set on top */
    /* Datasheet p.145 Table 17-2 */
	
    TCCR4B |= (1<<WGM43) | (1<<WGM42);                                             
    3074:	e1 ea       	ldi	r30, 0xA1	; 161
    3076:	f0 e0       	ldi	r31, 0x00	; 0
    3078:	90 81       	ld	r25, Z
    307a:	98 61       	ori	r25, 0x18	; 24
    307c:	90 83       	st	Z, r25
    TCCR4A |= (1<<WGM41) | (0<<WGM40);
    307e:	9c 91       	ld	r25, X
    3080:	92 60       	ori	r25, 0x02	; 2
    3082:	9c 93       	st	X, r25

    /* Clock select bit description: */
    /* clkI/O/8 (From prescaler) - Datasheet p.157 Table 17-6*/

     TCCR4B |= (0<<CS42) | (1<<CS41) | (0<<CS40);                                           
    3084:	90 81       	ld	r25, Z
    3086:	92 60       	ori	r25, 0x02	; 2
    3088:	90 83       	st	Z, r25
    
    /* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
    /* Datasheet p.125 */
    ICR4 = 39999; // 49999 for 20mhz, 39 999 for 16Mhz                                      
    308a:	2f e3       	ldi	r18, 0x3F	; 63
    308c:	3c e9       	ldi	r19, 0x9C	; 156
    308e:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>
    3092:	20 93 a6 00 	sts	0x00A6, r18	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
    
    /*Port H Pin 7 as servo PWM Output (OC4B)*/
    servoReg |= (1<<servoPin);
    3096:	e1 e0       	ldi	r30, 0x01	; 1
    3098:	f1 e0       	ldi	r31, 0x01	; 1
    309a:	90 81       	ld	r25, Z
    309c:	90 61       	ori	r25, 0x10	; 16
    309e:	90 83       	st	Z, r25
    
    /*  Set angle to desired start angle (usually 0)*/
    vServo_setAngle(servoAngleDeg);
    30a0:	d4 cf       	rjmp	.-88     	; 0x304a <vServo_setAngle>
    30a2:	08 95       	ret

000030a4 <simple_p_reassembly>:
  vPortFree(part);
  return 1;
}


void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length) {
    30a4:	ef 92       	push	r14
    30a6:	ff 92       	push	r15
    30a8:	0f 93       	push	r16
    30aa:	1f 93       	push	r17
    30ac:	cf 93       	push	r28
    30ae:	df 93       	push	r29
  uint8_t i;
  uint8_t id = 0xFF;
  uint8_t free = 0xFF;
  for(i=0;i<MAX_MESSAGES;i++) {
    if(messages[i].address == 0xFF && free == 0xFF) free = i;
    30b0:	90 91 af 15 	lds	r25, 0x15AF	; 0x8015af <messages+0x1>
    30b4:	9f 3f       	cpi	r25, 0xFF	; 255
    30b6:	11 f0       	breq	.+4      	; 0x30bc <simple_p_reassembly+0x18>
    else if(messages[i].address == sender) {
    30b8:	98 13       	cpse	r25, r24
    30ba:	58 c0       	rjmp	.+176    	; 0x316c <simple_p_reassembly+0xc8>
  if(id == 0xFF && free == 0xFF) return; // Not room for any more messages, and none is stored for this address
  else if(id == 0xFF && free != 0xFF) { // Did not find any part messages from this sender, but there is room to store a new one
    id = free; 
  }
    
  if(data[0] == 0) { // First part of a new message
    30bc:	fb 01       	movw	r30, r22
    30be:	80 81       	ld	r24, Z
    30c0:	81 11       	cpse	r24, r1
    30c2:	05 c0       	rjmp	.+10     	; 0x30ce <simple_p_reassembly+0x2a>
    messages[id].num_received_bytes = 0;
    30c4:	10 92 b1 15 	sts	0x15B1, r1	; 0x8015b1 <messages+0x3>
    30c8:	10 92 b0 15 	sts	0x15B0, r1	; 0x8015b0 <messages+0x2>
    30cc:	0c c0       	rjmp	.+24     	; 0x30e6 <simple_p_reassembly+0x42>
  } else if(data[0] != messages[id].next_part) {
    30ce:	90 91 b2 15 	lds	r25, 0x15B2	; 0x8015b2 <messages+0x4>
    30d2:	89 17       	cp	r24, r25
    30d4:	41 f0       	breq	.+16     	; 0x30e6 <simple_p_reassembly+0x42>
    messages[id].next_part = 0;
    30d6:	ee ea       	ldi	r30, 0xAE	; 174
    30d8:	f5 e1       	ldi	r31, 0x15	; 21
    30da:	14 82       	std	Z+4, r1	; 0x04
    messages[id].num_received_bytes = 0;
    30dc:	13 82       	std	Z+3, r1	; 0x03
    30de:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    30e0:	8f ef       	ldi	r24, 0xFF	; 255
    30e2:	81 83       	std	Z+1, r24	; 0x01
    return;
    30e4:	43 c0       	rjmp	.+134    	; 0x316c <simple_p_reassembly+0xc8>
  }

  if(messages[id].num_received_bytes + (length-2) > MAX_MESSAGE_SIZE) { // Message is larger than what can be handled, discard it
    30e6:	80 91 b0 15 	lds	r24, 0x15B0	; 0x8015b0 <messages+0x2>
    30ea:	90 91 b1 15 	lds	r25, 0x15B1	; 0x8015b1 <messages+0x3>
    30ee:	9c 01       	movw	r18, r24
    30f0:	22 50       	subi	r18, 0x02	; 2
    30f2:	31 09       	sbc	r19, r1
    30f4:	24 0f       	add	r18, r20
    30f6:	35 1f       	adc	r19, r21
    30f8:	25 36       	cpi	r18, 0x65	; 101
    30fa:	31 05       	cpc	r19, r1
    30fc:	40 f0       	brcs	.+16     	; 0x310e <simple_p_reassembly+0x6a>
    messages[id].num_received_bytes = 0;
    30fe:	ee ea       	ldi	r30, 0xAE	; 174
    3100:	f5 e1       	ldi	r31, 0x15	; 21
    3102:	13 82       	std	Z+3, r1	; 0x03
    3104:	12 82       	std	Z+2, r1	; 0x02
    messages[id].next_part = 0;
    3106:	14 82       	std	Z+4, r1	; 0x04
    messages[id].address = 0xFF;
    3108:	8f ef       	ldi	r24, 0xFF	; 255
    310a:	81 83       	std	Z+1, r24	; 0x01
    return;
    310c:	2f c0       	rjmp	.+94     	; 0x316c <simple_p_reassembly+0xc8>
    310e:	8a 01       	movw	r16, r20
    3110:	eb 01       	movw	r28, r22
  }
  
  messages[id].next_part++;
    3112:	0f 2e       	mov	r0, r31
    3114:	fe ea       	ldi	r31, 0xAE	; 174
    3116:	ef 2e       	mov	r14, r31
    3118:	f5 e1       	ldi	r31, 0x15	; 21
    311a:	ff 2e       	mov	r15, r31
    311c:	f0 2d       	mov	r31, r0
    311e:	f7 01       	movw	r30, r14
    3120:	24 81       	ldd	r18, Z+4	; 0x04
    3122:	2f 5f       	subi	r18, 0xFF	; 255
    3124:	24 83       	std	Z+4, r18	; 0x04
  memcpy(messages[id].message+messages[id].num_received_bytes, data+2, length-2);
    3126:	42 50       	subi	r20, 0x02	; 2
    3128:	51 09       	sbc	r21, r1
    312a:	6e 5f       	subi	r22, 0xFE	; 254
    312c:	7f 4f       	sbci	r23, 0xFF	; 255
    312e:	8d 54       	subi	r24, 0x4D	; 77
    3130:	9a 4e       	sbci	r25, 0xEA	; 234
    3132:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
  messages[id].num_received_bytes += (length-2);
    3136:	f7 01       	movw	r30, r14
    3138:	42 81       	ldd	r20, Z+2	; 0x02
    313a:	53 81       	ldd	r21, Z+3	; 0x03
    313c:	42 50       	subi	r20, 0x02	; 2
    313e:	51 09       	sbc	r21, r1
    3140:	ba 01       	movw	r22, r20
    3142:	60 0f       	add	r22, r16
    3144:	71 1f       	adc	r23, r17
    3146:	73 83       	std	Z+3, r23	; 0x03
    3148:	62 83       	std	Z+2, r22	; 0x02
  
  if(data[0] == data[1]) {
    314a:	98 81       	ld	r25, Y
    314c:	89 81       	ldd	r24, Y+1	; 0x01
    314e:	98 13       	cpse	r25, r24
    3150:	0d c0       	rjmp	.+26     	; 0x316c <simple_p_reassembly+0xc8>
    callback_data_received(messages[id].message, messages[id].num_received_bytes);
    3152:	e0 91 4c 17 	lds	r30, 0x174C	; 0x80174c <callback_data_received>
    3156:	f0 91 4d 17 	lds	r31, 0x174D	; 0x80174d <callback_data_received+0x1>
    315a:	83 eb       	ldi	r24, 0xB3	; 179
    315c:	95 e1       	ldi	r25, 0x15	; 21
    315e:	19 95       	eicall
    messages[id].num_received_bytes = messages[id].next_part = 0;
    3160:	f7 01       	movw	r30, r14
    3162:	14 82       	std	Z+4, r1	; 0x04
    3164:	13 82       	std	Z+3, r1	; 0x03
    3166:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    3168:	8f ef       	ldi	r24, 0xFF	; 255
    316a:	81 83       	std	Z+1, r24	; 0x01
  }
    316c:	df 91       	pop	r29
    316e:	cf 91       	pop	r28
    3170:	1f 91       	pop	r17
    3172:	0f 91       	pop	r16
    3174:	ff 90       	pop	r15
    3176:	ef 90       	pop	r14
    3178:	08 95       	ret

0000317a <simple_p_init>:
void (*callback_data_received)(uint8_t*, uint16_t); 

void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length);

void simple_p_init(void (*cb)(uint8_t*, uint16_t)) {
  callback_data_received = cb;
    317a:	90 93 4d 17 	sts	0x174D, r25	; 0x80174d <callback_data_received+0x1>
    317e:	80 93 4c 17 	sts	0x174C, r24	; 0x80174c <callback_data_received>
  uint8_t i;
  network_set_callback(PROTOCOL_SIMPLE, simple_p_reassembly);
    3182:	62 e5       	ldi	r22, 0x52	; 82
    3184:	78 e1       	ldi	r23, 0x18	; 24
    3186:	80 e0       	ldi	r24, 0x00	; 0
    3188:	0e 94 54 0e 	call	0x1ca8	; 0x1ca8 <network_set_callback>
  for(i=0;i<MAX_MESSAGES;i++) {
    messages[i].address = 0xFF;
    318c:	8f ef       	ldi	r24, 0xFF	; 255
    318e:	80 93 af 15 	sts	0x15AF, r24	; 0x8015af <messages+0x1>
    3192:	08 95       	ret

00003194 <simple_p_send>:
  }
}

uint8_t simple_p_send(uint8_t address, uint8_t *data, uint16_t length) {  
    3194:	5f 92       	push	r5
    3196:	6f 92       	push	r6
    3198:	7f 92       	push	r7
    319a:	8f 92       	push	r8
    319c:	9f 92       	push	r9
    319e:	af 92       	push	r10
    31a0:	bf 92       	push	r11
    31a2:	cf 92       	push	r12
    31a4:	df 92       	push	r13
    31a6:	ef 92       	push	r14
    31a8:	ff 92       	push	r15
    31aa:	0f 93       	push	r16
    31ac:	1f 93       	push	r17
    31ae:	cf 93       	push	r28
    31b0:	df 93       	push	r29
    31b2:	58 2e       	mov	r5, r24
    31b4:	5b 01       	movw	r10, r22
    31b6:	8a 01       	movw	r16, r20
  uint16_t tmp;
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
    31b8:	8c e2       	ldi	r24, 0x2C	; 44
    31ba:	90 e0       	ldi	r25, 0x00	; 0
    31bc:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
    31c0:	7c 01       	movw	r14, r24
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
    31c2:	98 01       	movw	r18, r16
    31c4:	36 95       	lsr	r19
    31c6:	27 95       	ror	r18
    31c8:	ad e0       	ldi	r26, 0x0D	; 13
    31ca:	b3 ec       	ldi	r27, 0xC3	; 195
    31cc:	0e 94 a9 2b 	call	0x5752	; 0x5752 <__umulhisi3>
    31d0:	92 95       	swap	r25
    31d2:	82 95       	swap	r24
    31d4:	8f 70       	andi	r24, 0x0F	; 15
    31d6:	89 27       	eor	r24, r25
    31d8:	9f 70       	andi	r25, 0x0F	; 15
    31da:	89 27       	eor	r24, r25
    31dc:	4a e2       	ldi	r20, 0x2A	; 42
    31de:	48 9f       	mul	r20, r24
    31e0:	90 01       	movw	r18, r0
    31e2:	49 9f       	mul	r20, r25
    31e4:	30 0d       	add	r19, r0
    31e6:	11 24       	eor	r1, r1
    31e8:	41 e0       	ldi	r20, 0x01	; 1
    31ea:	02 17       	cp	r16, r18
    31ec:	13 07       	cpc	r17, r19
    31ee:	09 f4       	brne	.+2      	; 0x31f2 <simple_p_send+0x5e>
    31f0:	40 e0       	ldi	r20, 0x00	; 0
    31f2:	98 01       	movw	r18, r16
    31f4:	36 95       	lsr	r19
    31f6:	27 95       	ror	r18
    31f8:	ad e0       	ldi	r26, 0x0D	; 13
    31fa:	b3 ec       	ldi	r27, 0xC3	; 195
    31fc:	0e 94 a9 2b 	call	0x5752	; 0x5752 <__umulhisi3>
    3200:	92 95       	swap	r25
    3202:	82 95       	swap	r24
    3204:	8f 70       	andi	r24, 0x0F	; 15
    3206:	89 27       	eor	r24, r25
    3208:	9f 70       	andi	r25, 0x0F	; 15
    320a:	89 27       	eor	r24, r25
    320c:	84 0f       	add	r24, r20
  while(remaining > 0) {
    320e:	01 15       	cp	r16, r1
    3210:	11 05       	cpc	r17, r1
    3212:	59 f1       	breq	.+86     	; 0x326a <simple_p_send+0xd6>
    3214:	90 e0       	ldi	r25, 0x00	; 0
    3216:	c1 2c       	mov	r12, r1
    3218:	d1 2c       	mov	r13, r1
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    part[1] = number_of_parts-1;
    321a:	66 24       	eor	r6, r6
    321c:	6a 94       	dec	r6
    321e:	68 0e       	add	r6, r24
    memcpy(part+2, data+offset, tmp);
    3220:	47 01       	movw	r8, r14
    3222:	82 e0       	ldi	r24, 0x02	; 2
    3224:	88 0e       	add	r8, r24
    3226:	91 1c       	adc	r9, r1
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    3228:	e8 01       	movw	r28, r16
    322a:	0b 32       	cpi	r16, 0x2B	; 43
    322c:	11 05       	cpc	r17, r1
    322e:	10 f0       	brcs	.+4      	; 0x3234 <simple_p_send+0xa0>
    3230:	ca e2       	ldi	r28, 0x2A	; 42
    3232:	d0 e0       	ldi	r29, 0x00	; 0
    part[0] = part_number++;
    3234:	77 24       	eor	r7, r7
    3236:	73 94       	inc	r7
    3238:	79 0e       	add	r7, r25
    323a:	f7 01       	movw	r30, r14
    323c:	90 83       	st	Z, r25
    part[1] = number_of_parts-1;
    323e:	61 82       	std	Z+1, r6	; 0x01
    memcpy(part+2, data+offset, tmp);
    3240:	b5 01       	movw	r22, r10
    3242:	6c 0d       	add	r22, r12
    3244:	7d 1d       	adc	r23, r13
    3246:	ae 01       	movw	r20, r28
    3248:	c4 01       	movw	r24, r8
    324a:	0e 94 9b 2c 	call	0x5936	; 0x5936 <memcpy>
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    324e:	9e 01       	movw	r18, r28
    3250:	2e 5f       	subi	r18, 0xFE	; 254
    3252:	3f 4f       	sbci	r19, 0xFF	; 255
    3254:	a7 01       	movw	r20, r14
    3256:	60 e0       	ldi	r22, 0x00	; 0
    3258:	85 2d       	mov	r24, r5
    325a:	0e 94 5f 0e 	call	0x1cbe	; 0x1cbe <network_send>
    offset += tmp;
    325e:	cc 0e       	add	r12, r28
    3260:	dd 1e       	adc	r13, r29
    remaining -= tmp;
    3262:	0c 1b       	sub	r16, r28
    3264:	1d 0b       	sbc	r17, r29
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    3266:	97 2d       	mov	r25, r7
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    3268:	f9 f6       	brne	.-66     	; 0x3228 <simple_p_send+0x94>
    memcpy(part+2, data+offset, tmp);
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    offset += tmp;
    remaining -= tmp;
  }
  vPortFree(part);
    326a:	c7 01       	movw	r24, r14
    326c:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <vPortFree>
  return 1;
}
    3270:	81 e0       	ldi	r24, 0x01	; 1
    3272:	df 91       	pop	r29
    3274:	cf 91       	pop	r28
    3276:	1f 91       	pop	r17
    3278:	0f 91       	pop	r16
    327a:	ff 90       	pop	r15
    327c:	ef 90       	pop	r14
    327e:	df 90       	pop	r13
    3280:	cf 90       	pop	r12
    3282:	bf 90       	pop	r11
    3284:	af 90       	pop	r10
    3286:	9f 90       	pop	r9
    3288:	8f 90       	pop	r8
    328a:	7f 90       	pop	r7
    328c:	6f 90       	pop	r6
    328e:	5f 90       	pop	r5
    3290:	08 95       	ret

00003292 <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    3292:	84 b1       	in	r24, 0x04	; 4
    3294:	87 60       	ori	r24, 0x07	; 7
    3296:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    3298:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    329a:	8c b5       	in	r24, 0x2c	; 44
    329c:	81 60       	ori	r24, 0x01	; 1
    329e:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    32a0:	8c b5       	in	r24, 0x2c	; 44
    32a2:	8c 65       	ori	r24, 0x5C	; 92
    32a4:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    32a6:	8c b5       	in	r24, 0x2c	; 44
    32a8:	8f 7d       	andi	r24, 0xDF	; 223
    32aa:	8c bd       	out	0x2c, r24	; 44
    32ac:	08 95       	ret

000032ae <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    32ae:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    32b0:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    32b2:	0d b4       	in	r0, 0x2d	; 45
    32b4:	07 fe       	sbrs	r0, 7
    32b6:	fd cf       	rjmp	.-6      	; 0x32b2 <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    32b8:	8e b5       	in	r24, 0x2e	; 46
}
    32ba:	08 95       	ret

000032bc <xTaskGenericCreate>:
    32bc:	4f 92       	push	r4
    32be:	5f 92       	push	r5
    32c0:	6f 92       	push	r6
    32c2:	7f 92       	push	r7
    32c4:	8f 92       	push	r8
    32c6:	9f 92       	push	r9
    32c8:	af 92       	push	r10
    32ca:	bf 92       	push	r11
    32cc:	cf 92       	push	r12
    32ce:	df 92       	push	r13
    32d0:	ef 92       	push	r14
    32d2:	ff 92       	push	r15
    32d4:	0f 93       	push	r16
    32d6:	1f 93       	push	r17
    32d8:	cf 93       	push	r28
    32da:	df 93       	push	r29
    32dc:	3c 01       	movw	r6, r24
    32de:	5b 01       	movw	r10, r22
    32e0:	4a 01       	movw	r8, r20
    32e2:	29 01       	movw	r4, r18
    32e4:	c1 14       	cp	r12, r1
    32e6:	d1 04       	cpc	r13, r1
    32e8:	39 f4       	brne	.+14     	; 0x32f8 <xTaskGenericCreate+0x3c>
    32ea:	ca 01       	movw	r24, r20
    32ec:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
    32f0:	6c 01       	movw	r12, r24
    32f2:	89 2b       	or	r24, r25
    32f4:	09 f4       	brne	.+2      	; 0x32f8 <xTaskGenericCreate+0x3c>
    32f6:	e4 c0       	rjmp	.+456    	; 0x34c0 <xTaskGenericCreate+0x204>
    32f8:	88 e2       	ldi	r24, 0x28	; 40
    32fa:	90 e0       	ldi	r25, 0x00	; 0
    32fc:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
    3300:	ec 01       	movw	r28, r24
    3302:	89 2b       	or	r24, r25
    3304:	71 f0       	breq	.+28     	; 0x3322 <xTaskGenericCreate+0x66>
    3306:	d8 8e       	std	Y+24, r13	; 0x18
    3308:	cf 8a       	std	Y+23, r12	; 0x17
    330a:	81 e0       	ldi	r24, 0x01	; 1
    330c:	88 1a       	sub	r8, r24
    330e:	91 08       	sbc	r9, r1
    3310:	c8 0c       	add	r12, r8
    3312:	d9 1c       	adc	r13, r9
    3314:	d5 01       	movw	r26, r10
    3316:	8c 91       	ld	r24, X
    3318:	89 8f       	std	Y+25, r24	; 0x19
    331a:	8c 91       	ld	r24, X
    331c:	81 11       	cpse	r24, r1
    331e:	05 c0       	rjmp	.+10     	; 0x332a <xTaskGenericCreate+0x6e>
    3320:	18 c0       	rjmp	.+48     	; 0x3352 <xTaskGenericCreate+0x96>
    3322:	c6 01       	movw	r24, r12
    3324:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <vPortFree>
    3328:	cb c0       	rjmp	.+406    	; 0x34c0 <xTaskGenericCreate+0x204>
    332a:	ae 01       	movw	r20, r28
    332c:	46 5e       	subi	r20, 0xE6	; 230
    332e:	5f 4f       	sbci	r21, 0xFF	; 255
    3330:	f5 01       	movw	r30, r10
    3332:	31 96       	adiw	r30, 0x01	; 1
    3334:	b8 e0       	ldi	r27, 0x08	; 8
    3336:	ab 0e       	add	r10, r27
    3338:	b1 1c       	adc	r11, r1
    333a:	cf 01       	movw	r24, r30
    333c:	21 91       	ld	r18, Z+
    333e:	da 01       	movw	r26, r20
    3340:	2d 93       	st	X+, r18
    3342:	ad 01       	movw	r20, r26
    3344:	dc 01       	movw	r26, r24
    3346:	8c 91       	ld	r24, X
    3348:	88 23       	and	r24, r24
    334a:	19 f0       	breq	.+6      	; 0x3352 <xTaskGenericCreate+0x96>
    334c:	ae 16       	cp	r10, r30
    334e:	bf 06       	cpc	r11, r31
    3350:	a1 f7       	brne	.-24     	; 0x333a <xTaskGenericCreate+0x7e>
    3352:	18 a2       	std	Y+32, r1	; 0x20
    3354:	10 2f       	mov	r17, r16
    3356:	06 30       	cpi	r16, 0x06	; 6
    3358:	08 f0       	brcs	.+2      	; 0x335c <xTaskGenericCreate+0xa0>
    335a:	15 e0       	ldi	r17, 0x05	; 5
    335c:	1e 8b       	std	Y+22, r17	; 0x16
    335e:	19 a3       	std	Y+33, r17	; 0x21
    3360:	1a a2       	std	Y+34, r1	; 0x22
    3362:	5e 01       	movw	r10, r28
    3364:	b2 e0       	ldi	r27, 0x02	; 2
    3366:	ab 0e       	add	r10, r27
    3368:	b1 1c       	adc	r11, r1
    336a:	c5 01       	movw	r24, r10
    336c:	0e 94 49 0b 	call	0x1692	; 0x1692 <vListInitialiseItem>
    3370:	ce 01       	movw	r24, r28
    3372:	0c 96       	adiw	r24, 0x0c	; 12
    3374:	0e 94 49 0b 	call	0x1692	; 0x1692 <vListInitialiseItem>
    3378:	d9 87       	std	Y+9, r29	; 0x09
    337a:	c8 87       	std	Y+8, r28	; 0x08
    337c:	86 e0       	ldi	r24, 0x06	; 6
    337e:	90 e0       	ldi	r25, 0x00	; 0
    3380:	81 1b       	sub	r24, r17
    3382:	91 09       	sbc	r25, r1
    3384:	9d 87       	std	Y+13, r25	; 0x0d
    3386:	8c 87       	std	Y+12, r24	; 0x0c
    3388:	db 8b       	std	Y+19, r29	; 0x13
    338a:	ca 8b       	std	Y+18, r28	; 0x12
    338c:	1b a2       	std	Y+35, r1	; 0x23
    338e:	1c a2       	std	Y+36, r1	; 0x24
    3390:	1d a2       	std	Y+37, r1	; 0x25
    3392:	1e a2       	std	Y+38, r1	; 0x26
    3394:	1f a2       	std	Y+39, r1	; 0x27
    3396:	a2 01       	movw	r20, r4
    3398:	b3 01       	movw	r22, r6
    339a:	c6 01       	movw	r24, r12
    339c:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <pxPortInitialiseStack>
    33a0:	99 83       	std	Y+1, r25	; 0x01
    33a2:	88 83       	st	Y, r24
    33a4:	e1 14       	cp	r14, r1
    33a6:	f1 04       	cpc	r15, r1
    33a8:	19 f0       	breq	.+6      	; 0x33b0 <xTaskGenericCreate+0xf4>
    33aa:	f7 01       	movw	r30, r14
    33ac:	d1 83       	std	Z+1, r29	; 0x01
    33ae:	c0 83       	st	Z, r28
    33b0:	0f b6       	in	r0, 0x3f	; 63
    33b2:	f8 94       	cli
    33b4:	0f 92       	push	r0
    33b6:	80 91 22 16 	lds	r24, 0x1622	; 0x801622 <uxCurrentNumberOfTasks>
    33ba:	8f 5f       	subi	r24, 0xFF	; 255
    33bc:	80 93 22 16 	sts	0x1622, r24	; 0x801622 <uxCurrentNumberOfTasks>
    33c0:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    33c4:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    33c8:	89 2b       	or	r24, r25
    33ca:	d9 f5       	brne	.+118    	; 0x3442 <xTaskGenericCreate+0x186>
    33cc:	d0 93 82 16 	sts	0x1682, r29	; 0x801682 <pxCurrentTCB+0x1>
    33d0:	c0 93 81 16 	sts	0x1681, r28	; 0x801681 <pxCurrentTCB>
    33d4:	80 91 22 16 	lds	r24, 0x1622	; 0x801622 <uxCurrentNumberOfTasks>
    33d8:	81 30       	cpi	r24, 0x01	; 1
    33da:	09 f0       	breq	.+2      	; 0x33de <xTaskGenericCreate+0x122>
    33dc:	41 c0       	rjmp	.+130    	; 0x3460 <xTaskGenericCreate+0x1a4>
    33de:	0f 2e       	mov	r0, r31
    33e0:	fb e4       	ldi	r31, 0x4B	; 75
    33e2:	ef 2e       	mov	r14, r31
    33e4:	f6 e1       	ldi	r31, 0x16	; 22
    33e6:	ff 2e       	mov	r15, r31
    33e8:	f0 2d       	mov	r31, r0
    33ea:	0f 2e       	mov	r0, r31
    33ec:	f1 e8       	ldi	r31, 0x81	; 129
    33ee:	cf 2e       	mov	r12, r31
    33f0:	f6 e1       	ldi	r31, 0x16	; 22
    33f2:	df 2e       	mov	r13, r31
    33f4:	f0 2d       	mov	r31, r0
    33f6:	c7 01       	movw	r24, r14
    33f8:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    33fc:	f9 e0       	ldi	r31, 0x09	; 9
    33fe:	ef 0e       	add	r14, r31
    3400:	f1 1c       	adc	r15, r1
    3402:	ec 14       	cp	r14, r12
    3404:	fd 04       	cpc	r15, r13
    3406:	b9 f7       	brne	.-18     	; 0x33f6 <xTaskGenericCreate+0x13a>
    3408:	82 e4       	ldi	r24, 0x42	; 66
    340a:	96 e1       	ldi	r25, 0x16	; 22
    340c:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3410:	89 e3       	ldi	r24, 0x39	; 57
    3412:	96 e1       	ldi	r25, 0x16	; 22
    3414:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3418:	8c e2       	ldi	r24, 0x2C	; 44
    341a:	96 e1       	ldi	r25, 0x16	; 22
    341c:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3420:	83 e2       	ldi	r24, 0x23	; 35
    3422:	96 e1       	ldi	r25, 0x16	; 22
    3424:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3428:	82 e4       	ldi	r24, 0x42	; 66
    342a:	96 e1       	ldi	r25, 0x16	; 22
    342c:	90 93 38 16 	sts	0x1638, r25	; 0x801638 <pxDelayedTaskList+0x1>
    3430:	80 93 37 16 	sts	0x1637, r24	; 0x801637 <pxDelayedTaskList>
    3434:	89 e3       	ldi	r24, 0x39	; 57
    3436:	96 e1       	ldi	r25, 0x16	; 22
    3438:	90 93 36 16 	sts	0x1636, r25	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    343c:	80 93 35 16 	sts	0x1635, r24	; 0x801635 <pxOverflowDelayedTaskList>
    3440:	0f c0       	rjmp	.+30     	; 0x3460 <xTaskGenericCreate+0x1a4>
    3442:	80 91 1e 16 	lds	r24, 0x161E	; 0x80161e <xSchedulerRunning>
    3446:	81 11       	cpse	r24, r1
    3448:	0b c0       	rjmp	.+22     	; 0x3460 <xTaskGenericCreate+0x1a4>
    344a:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    344e:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3452:	86 89       	ldd	r24, Z+22	; 0x16
    3454:	08 17       	cp	r16, r24
    3456:	20 f0       	brcs	.+8      	; 0x3460 <xTaskGenericCreate+0x1a4>
    3458:	d0 93 82 16 	sts	0x1682, r29	; 0x801682 <pxCurrentTCB+0x1>
    345c:	c0 93 81 16 	sts	0x1681, r28	; 0x801681 <pxCurrentTCB>
    3460:	80 91 1a 16 	lds	r24, 0x161A	; 0x80161a <uxTaskNumber>
    3464:	8f 5f       	subi	r24, 0xFF	; 255
    3466:	80 93 1a 16 	sts	0x161A, r24	; 0x80161a <uxTaskNumber>
    346a:	8e 89       	ldd	r24, Y+22	; 0x16
    346c:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    3470:	98 17       	cp	r25, r24
    3472:	10 f4       	brcc	.+4      	; 0x3478 <xTaskGenericCreate+0x1bc>
    3474:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    3478:	90 e0       	ldi	r25, 0x00	; 0
    347a:	9c 01       	movw	r18, r24
    347c:	22 0f       	add	r18, r18
    347e:	33 1f       	adc	r19, r19
    3480:	22 0f       	add	r18, r18
    3482:	33 1f       	adc	r19, r19
    3484:	22 0f       	add	r18, r18
    3486:	33 1f       	adc	r19, r19
    3488:	82 0f       	add	r24, r18
    348a:	93 1f       	adc	r25, r19
    348c:	b5 01       	movw	r22, r10
    348e:	85 5b       	subi	r24, 0xB5	; 181
    3490:	99 4e       	sbci	r25, 0xE9	; 233
    3492:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    3496:	0f 90       	pop	r0
    3498:	0f be       	out	0x3f, r0	; 63
    349a:	80 91 1e 16 	lds	r24, 0x161E	; 0x80161e <xSchedulerRunning>
    349e:	88 23       	and	r24, r24
    34a0:	59 f0       	breq	.+22     	; 0x34b8 <xTaskGenericCreate+0x1fc>
    34a2:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    34a6:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    34aa:	86 89       	ldd	r24, Z+22	; 0x16
    34ac:	80 17       	cp	r24, r16
    34ae:	30 f4       	brcc	.+12     	; 0x34bc <xTaskGenericCreate+0x200>
    34b0:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    34b4:	81 e0       	ldi	r24, 0x01	; 1
    34b6:	05 c0       	rjmp	.+10     	; 0x34c2 <xTaskGenericCreate+0x206>
    34b8:	81 e0       	ldi	r24, 0x01	; 1
    34ba:	03 c0       	rjmp	.+6      	; 0x34c2 <xTaskGenericCreate+0x206>
    34bc:	81 e0       	ldi	r24, 0x01	; 1
    34be:	01 c0       	rjmp	.+2      	; 0x34c2 <xTaskGenericCreate+0x206>
    34c0:	8f ef       	ldi	r24, 0xFF	; 255
    34c2:	df 91       	pop	r29
    34c4:	cf 91       	pop	r28
    34c6:	1f 91       	pop	r17
    34c8:	0f 91       	pop	r16
    34ca:	ff 90       	pop	r15
    34cc:	ef 90       	pop	r14
    34ce:	df 90       	pop	r13
    34d0:	cf 90       	pop	r12
    34d2:	bf 90       	pop	r11
    34d4:	af 90       	pop	r10
    34d6:	9f 90       	pop	r9
    34d8:	8f 90       	pop	r8
    34da:	7f 90       	pop	r7
    34dc:	6f 90       	pop	r6
    34de:	5f 90       	pop	r5
    34e0:	4f 90       	pop	r4
    34e2:	08 95       	ret

000034e4 <vTaskDelayUntil>:
    34e4:	9f 92       	push	r9
    34e6:	af 92       	push	r10
    34e8:	bf 92       	push	r11
    34ea:	cf 92       	push	r12
    34ec:	df 92       	push	r13
    34ee:	ef 92       	push	r14
    34f0:	ff 92       	push	r15
    34f2:	0f 93       	push	r16
    34f4:	1f 93       	push	r17
    34f6:	cf 93       	push	r28
    34f8:	df 93       	push	r29
    34fa:	fc 01       	movw	r30, r24
    34fc:	90 91 17 16 	lds	r25, 0x1617	; 0x801617 <uxSchedulerSuspended>
    3500:	9f 5f       	subi	r25, 0xFF	; 255
    3502:	90 93 17 16 	sts	0x1617, r25	; 0x801617 <uxSchedulerSuspended>
    3506:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    350a:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    350e:	20 81       	ld	r18, Z
    3510:	31 81       	ldd	r19, Z+1	; 0x01
    3512:	e9 01       	movw	r28, r18
    3514:	c6 0f       	add	r28, r22
    3516:	d7 1f       	adc	r29, r23
    3518:	82 17       	cp	r24, r18
    351a:	93 07       	cpc	r25, r19
    351c:	58 f4       	brcc	.+22     	; 0x3534 <vTaskDelayUntil+0x50>
    351e:	c2 17       	cp	r28, r18
    3520:	d3 07       	cpc	r29, r19
    3522:	08 f0       	brcs	.+2      	; 0x3526 <vTaskDelayUntil+0x42>
    3524:	6e c1       	rjmp	.+732    	; 0x3802 <vTaskDelayUntil+0x31e>
    3526:	d1 83       	std	Z+1, r29	; 0x01
    3528:	c0 83       	st	Z, r28
    352a:	8c 17       	cp	r24, r28
    352c:	9d 07       	cpc	r25, r29
    352e:	08 f0       	brcs	.+2      	; 0x3532 <vTaskDelayUntil+0x4e>
    3530:	42 c0       	rjmp	.+132    	; 0x35b6 <vTaskDelayUntil+0xd2>
    3532:	09 c0       	rjmp	.+18     	; 0x3546 <vTaskDelayUntil+0x62>
    3534:	c2 17       	cp	r28, r18
    3536:	d3 07       	cpc	r29, r19
    3538:	08 f4       	brcc	.+2      	; 0x353c <vTaskDelayUntil+0x58>
    353a:	60 c1       	rjmp	.+704    	; 0x37fc <vTaskDelayUntil+0x318>
    353c:	8c 17       	cp	r24, r28
    353e:	9d 07       	cpc	r25, r29
    3540:	08 f4       	brcc	.+2      	; 0x3544 <vTaskDelayUntil+0x60>
    3542:	5c c1       	rjmp	.+696    	; 0x37fc <vTaskDelayUntil+0x318>
    3544:	5e c1       	rjmp	.+700    	; 0x3802 <vTaskDelayUntil+0x31e>
    3546:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    354a:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    354e:	02 96       	adiw	r24, 0x02	; 2
    3550:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3554:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    3558:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    355c:	d3 83       	std	Z+3, r29	; 0x03
    355e:	c2 83       	std	Z+2, r28	; 0x02
    3560:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    3564:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    3568:	c8 17       	cp	r28, r24
    356a:	d9 07       	cpc	r29, r25
    356c:	68 f4       	brcc	.+26     	; 0x3588 <vTaskDelayUntil+0xa4>
    356e:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    3572:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3576:	80 91 35 16 	lds	r24, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    357a:	90 91 36 16 	lds	r25, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    357e:	6e 5f       	subi	r22, 0xFE	; 254
    3580:	7f 4f       	sbci	r23, 0xFF	; 255
    3582:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    3586:	17 c0       	rjmp	.+46     	; 0x35b6 <vTaskDelayUntil+0xd2>
    3588:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    358c:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3590:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    3594:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3598:	6e 5f       	subi	r22, 0xFE	; 254
    359a:	7f 4f       	sbci	r23, 0xFF	; 255
    359c:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    35a0:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    35a4:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    35a8:	c8 17       	cp	r28, r24
    35aa:	d9 07       	cpc	r29, r25
    35ac:	20 f4       	brcc	.+8      	; 0x35b6 <vTaskDelayUntil+0xd2>
    35ae:	d0 93 19 16 	sts	0x1619, r29	; 0x801619 <xNextTaskUnblockTime+0x1>
    35b2:	c0 93 18 16 	sts	0x1618, r28	; 0x801618 <xNextTaskUnblockTime>
    35b6:	0f b6       	in	r0, 0x3f	; 63
    35b8:	f8 94       	cli
    35ba:	0f 92       	push	r0
    35bc:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    35c0:	81 50       	subi	r24, 0x01	; 1
    35c2:	80 93 17 16 	sts	0x1617, r24	; 0x801617 <uxSchedulerSuspended>
    35c6:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    35ca:	81 11       	cpse	r24, r1
    35cc:	0d c1       	rjmp	.+538    	; 0x37e8 <vTaskDelayUntil+0x304>
    35ce:	80 91 22 16 	lds	r24, 0x1622	; 0x801622 <uxCurrentNumberOfTasks>
    35d2:	81 11       	cpse	r24, r1
    35d4:	33 c0       	rjmp	.+102    	; 0x363c <vTaskDelayUntil+0x158>
    35d6:	0b c1       	rjmp	.+534    	; 0x37ee <vTaskDelayUntil+0x30a>
    35d8:	d7 01       	movw	r26, r14
    35da:	15 96       	adiw	r26, 0x05	; 5
    35dc:	ed 91       	ld	r30, X+
    35de:	fc 91       	ld	r31, X
    35e0:	16 97       	sbiw	r26, 0x06	; 6
    35e2:	c6 81       	ldd	r28, Z+6	; 0x06
    35e4:	d7 81       	ldd	r29, Z+7	; 0x07
    35e6:	ce 01       	movw	r24, r28
    35e8:	0c 96       	adiw	r24, 0x0c	; 12
    35ea:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    35ee:	8e 01       	movw	r16, r28
    35f0:	0e 5f       	subi	r16, 0xFE	; 254
    35f2:	1f 4f       	sbci	r17, 0xFF	; 255
    35f4:	c8 01       	movw	r24, r16
    35f6:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    35fa:	8e 89       	ldd	r24, Y+22	; 0x16
    35fc:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    3600:	98 17       	cp	r25, r24
    3602:	10 f4       	brcc	.+4      	; 0x3608 <vTaskDelayUntil+0x124>
    3604:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    3608:	90 e0       	ldi	r25, 0x00	; 0
    360a:	9c 01       	movw	r18, r24
    360c:	22 0f       	add	r18, r18
    360e:	33 1f       	adc	r19, r19
    3610:	22 0f       	add	r18, r18
    3612:	33 1f       	adc	r19, r19
    3614:	22 0f       	add	r18, r18
    3616:	33 1f       	adc	r19, r19
    3618:	82 0f       	add	r24, r18
    361a:	93 1f       	adc	r25, r19
    361c:	b8 01       	movw	r22, r16
    361e:	85 5b       	subi	r24, 0xB5	; 181
    3620:	99 4e       	sbci	r25, 0xE9	; 233
    3622:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    3626:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    362a:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    362e:	9e 89       	ldd	r25, Y+22	; 0x16
    3630:	86 89       	ldd	r24, Z+22	; 0x16
    3632:	98 17       	cp	r25, r24
    3634:	58 f0       	brcs	.+22     	; 0x364c <vTaskDelayUntil+0x168>
    3636:	d0 92 1c 16 	sts	0x161C, r13	; 0x80161c <xYieldPending>
    363a:	08 c0       	rjmp	.+16     	; 0x364c <vTaskDelayUntil+0x168>
    363c:	0f 2e       	mov	r0, r31
    363e:	fc e2       	ldi	r31, 0x2C	; 44
    3640:	ef 2e       	mov	r14, r31
    3642:	f6 e1       	ldi	r31, 0x16	; 22
    3644:	ff 2e       	mov	r15, r31
    3646:	f0 2d       	mov	r31, r0
    3648:	dd 24       	eor	r13, r13
    364a:	d3 94       	inc	r13
    364c:	f7 01       	movw	r30, r14
    364e:	80 81       	ld	r24, Z
    3650:	81 11       	cpse	r24, r1
    3652:	c2 cf       	rjmp	.-124    	; 0x35d8 <vTaskDelayUntil+0xf4>
    3654:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3658:	88 23       	and	r24, r24
    365a:	09 f4       	brne	.+2      	; 0x365e <vTaskDelayUntil+0x17a>
    365c:	bd c0       	rjmp	.+378    	; 0x37d8 <vTaskDelayUntil+0x2f4>
    365e:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3662:	88 23       	and	r24, r24
    3664:	09 f4       	brne	.+2      	; 0x3668 <vTaskDelayUntil+0x184>
    3666:	b8 c0       	rjmp	.+368    	; 0x37d8 <vTaskDelayUntil+0x2f4>
    3668:	91 2c       	mov	r9, r1
    366a:	bb 24       	eor	r11, r11
    366c:	b3 94       	inc	r11
    366e:	cc 24       	eor	r12, r12
    3670:	ca 94       	dec	r12
    3672:	dc 2c       	mov	r13, r12
    3674:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    3678:	81 11       	cpse	r24, r1
    367a:	98 c0       	rjmp	.+304    	; 0x37ac <vTaskDelayUntil+0x2c8>
    367c:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    3680:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    3684:	01 96       	adiw	r24, 0x01	; 1
    3686:	90 93 21 16 	sts	0x1621, r25	; 0x801621 <xTickCount+0x1>
    368a:	80 93 20 16 	sts	0x1620, r24	; 0x801620 <xTickCount>
    368e:	e0 90 20 16 	lds	r14, 0x1620	; 0x801620 <xTickCount>
    3692:	f0 90 21 16 	lds	r15, 0x1621	; 0x801621 <xTickCount+0x1>
    3696:	e1 14       	cp	r14, r1
    3698:	f1 04       	cpc	r15, r1
    369a:	89 f5       	brne	.+98     	; 0x36fe <vTaskDelayUntil+0x21a>
    369c:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    36a0:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    36a4:	20 91 35 16 	lds	r18, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    36a8:	30 91 36 16 	lds	r19, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    36ac:	30 93 38 16 	sts	0x1638, r19	; 0x801638 <pxDelayedTaskList+0x1>
    36b0:	20 93 37 16 	sts	0x1637, r18	; 0x801637 <pxDelayedTaskList>
    36b4:	90 93 36 16 	sts	0x1636, r25	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    36b8:	80 93 35 16 	sts	0x1635, r24	; 0x801635 <pxOverflowDelayedTaskList>
    36bc:	80 91 1b 16 	lds	r24, 0x161B	; 0x80161b <xNumOfOverflows>
    36c0:	8f 5f       	subi	r24, 0xFF	; 255
    36c2:	80 93 1b 16 	sts	0x161B, r24	; 0x80161b <xNumOfOverflows>
    36c6:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    36ca:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    36ce:	80 81       	ld	r24, Z
    36d0:	81 11       	cpse	r24, r1
    36d2:	05 c0       	rjmp	.+10     	; 0x36de <vTaskDelayUntil+0x1fa>
    36d4:	d0 92 19 16 	sts	0x1619, r13	; 0x801619 <xNextTaskUnblockTime+0x1>
    36d8:	c0 92 18 16 	sts	0x1618, r12	; 0x801618 <xNextTaskUnblockTime>
    36dc:	10 c0       	rjmp	.+32     	; 0x36fe <vTaskDelayUntil+0x21a>
    36de:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    36e2:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    36e6:	05 80       	ldd	r0, Z+5	; 0x05
    36e8:	f6 81       	ldd	r31, Z+6	; 0x06
    36ea:	e0 2d       	mov	r30, r0
    36ec:	06 80       	ldd	r0, Z+6	; 0x06
    36ee:	f7 81       	ldd	r31, Z+7	; 0x07
    36f0:	e0 2d       	mov	r30, r0
    36f2:	82 81       	ldd	r24, Z+2	; 0x02
    36f4:	93 81       	ldd	r25, Z+3	; 0x03
    36f6:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    36fa:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    36fe:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    3702:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    3706:	e8 16       	cp	r14, r24
    3708:	f9 06       	cpc	r15, r25
    370a:	08 f4       	brcc	.+2      	; 0x370e <vTaskDelayUntil+0x22a>
    370c:	7d c0       	rjmp	.+250    	; 0x3808 <vTaskDelayUntil+0x324>
    370e:	a9 2c       	mov	r10, r9
    3710:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    3714:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3718:	80 81       	ld	r24, Z
    371a:	81 11       	cpse	r24, r1
    371c:	05 c0       	rjmp	.+10     	; 0x3728 <vTaskDelayUntil+0x244>
    371e:	d0 92 19 16 	sts	0x1619, r13	; 0x801619 <xNextTaskUnblockTime+0x1>
    3722:	c0 92 18 16 	sts	0x1618, r12	; 0x801618 <xNextTaskUnblockTime>
    3726:	48 c0       	rjmp	.+144    	; 0x37b8 <vTaskDelayUntil+0x2d4>
    3728:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    372c:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3730:	05 80       	ldd	r0, Z+5	; 0x05
    3732:	f6 81       	ldd	r31, Z+6	; 0x06
    3734:	e0 2d       	mov	r30, r0
    3736:	c6 81       	ldd	r28, Z+6	; 0x06
    3738:	d7 81       	ldd	r29, Z+7	; 0x07
    373a:	8a 81       	ldd	r24, Y+2	; 0x02
    373c:	9b 81       	ldd	r25, Y+3	; 0x03
    373e:	e8 16       	cp	r14, r24
    3740:	f9 06       	cpc	r15, r25
    3742:	28 f4       	brcc	.+10     	; 0x374e <vTaskDelayUntil+0x26a>
    3744:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    3748:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    374c:	35 c0       	rjmp	.+106    	; 0x37b8 <vTaskDelayUntil+0x2d4>
    374e:	8e 01       	movw	r16, r28
    3750:	0e 5f       	subi	r16, 0xFE	; 254
    3752:	1f 4f       	sbci	r17, 0xFF	; 255
    3754:	c8 01       	movw	r24, r16
    3756:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    375a:	8c 89       	ldd	r24, Y+20	; 0x14
    375c:	9d 89       	ldd	r25, Y+21	; 0x15
    375e:	89 2b       	or	r24, r25
    3760:	21 f0       	breq	.+8      	; 0x376a <vTaskDelayUntil+0x286>
    3762:	ce 01       	movw	r24, r28
    3764:	0c 96       	adiw	r24, 0x0c	; 12
    3766:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    376a:	8e 89       	ldd	r24, Y+22	; 0x16
    376c:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    3770:	98 17       	cp	r25, r24
    3772:	10 f4       	brcc	.+4      	; 0x3778 <vTaskDelayUntil+0x294>
    3774:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    3778:	90 e0       	ldi	r25, 0x00	; 0
    377a:	9c 01       	movw	r18, r24
    377c:	22 0f       	add	r18, r18
    377e:	33 1f       	adc	r19, r19
    3780:	22 0f       	add	r18, r18
    3782:	33 1f       	adc	r19, r19
    3784:	22 0f       	add	r18, r18
    3786:	33 1f       	adc	r19, r19
    3788:	82 0f       	add	r24, r18
    378a:	93 1f       	adc	r25, r19
    378c:	b8 01       	movw	r22, r16
    378e:	85 5b       	subi	r24, 0xB5	; 181
    3790:	99 4e       	sbci	r25, 0xE9	; 233
    3792:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    3796:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    379a:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    379e:	9e 89       	ldd	r25, Y+22	; 0x16
    37a0:	86 89       	ldd	r24, Z+22	; 0x16
    37a2:	98 17       	cp	r25, r24
    37a4:	08 f4       	brcc	.+2      	; 0x37a8 <vTaskDelayUntil+0x2c4>
    37a6:	b4 cf       	rjmp	.-152    	; 0x3710 <vTaskDelayUntil+0x22c>
    37a8:	ab 2c       	mov	r10, r11
    37aa:	b2 cf       	rjmp	.-156    	; 0x3710 <vTaskDelayUntil+0x22c>
    37ac:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    37b0:	8f 5f       	subi	r24, 0xFF	; 255
    37b2:	80 93 1d 16 	sts	0x161D, r24	; 0x80161d <uxPendedTicks>
    37b6:	28 c0       	rjmp	.+80     	; 0x3808 <vTaskDelayUntil+0x324>
    37b8:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    37bc:	81 11       	cpse	r24, r1
    37be:	01 c0       	rjmp	.+2      	; 0x37c2 <vTaskDelayUntil+0x2de>
    37c0:	a1 10       	cpse	r10, r1
    37c2:	b0 92 1c 16 	sts	0x161C, r11	; 0x80161c <xYieldPending>
    37c6:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    37ca:	81 50       	subi	r24, 0x01	; 1
    37cc:	80 93 1d 16 	sts	0x161D, r24	; 0x80161d <uxPendedTicks>
    37d0:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    37d4:	81 11       	cpse	r24, r1
    37d6:	4e cf       	rjmp	.-356    	; 0x3674 <vTaskDelayUntil+0x190>
    37d8:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    37dc:	81 30       	cpi	r24, 0x01	; 1
    37de:	31 f4       	brne	.+12     	; 0x37ec <vTaskDelayUntil+0x308>
    37e0:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    37e4:	81 e0       	ldi	r24, 0x01	; 1
    37e6:	03 c0       	rjmp	.+6      	; 0x37ee <vTaskDelayUntil+0x30a>
    37e8:	80 e0       	ldi	r24, 0x00	; 0
    37ea:	01 c0       	rjmp	.+2      	; 0x37ee <vTaskDelayUntil+0x30a>
    37ec:	80 e0       	ldi	r24, 0x00	; 0
    37ee:	0f 90       	pop	r0
    37f0:	0f be       	out	0x3f, r0	; 63
    37f2:	81 11       	cpse	r24, r1
    37f4:	0e c0       	rjmp	.+28     	; 0x3812 <vTaskDelayUntil+0x32e>
    37f6:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    37fa:	0b c0       	rjmp	.+22     	; 0x3812 <vTaskDelayUntil+0x32e>
    37fc:	d1 83       	std	Z+1, r29	; 0x01
    37fe:	c0 83       	st	Z, r28
    3800:	a2 ce       	rjmp	.-700    	; 0x3546 <vTaskDelayUntil+0x62>
    3802:	d1 83       	std	Z+1, r29	; 0x01
    3804:	c0 83       	st	Z, r28
    3806:	d7 ce       	rjmp	.-594    	; 0x35b6 <vTaskDelayUntil+0xd2>
    3808:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    380c:	81 11       	cpse	r24, r1
    380e:	d9 cf       	rjmp	.-78     	; 0x37c2 <vTaskDelayUntil+0x2de>
    3810:	da cf       	rjmp	.-76     	; 0x37c6 <vTaskDelayUntil+0x2e2>
    3812:	df 91       	pop	r29
    3814:	cf 91       	pop	r28
    3816:	1f 91       	pop	r17
    3818:	0f 91       	pop	r16
    381a:	ff 90       	pop	r15
    381c:	ef 90       	pop	r14
    381e:	df 90       	pop	r13
    3820:	cf 90       	pop	r12
    3822:	bf 90       	pop	r11
    3824:	af 90       	pop	r10
    3826:	9f 90       	pop	r9
    3828:	08 95       	ret

0000382a <vTaskDelay>:
    382a:	9f 92       	push	r9
    382c:	af 92       	push	r10
    382e:	bf 92       	push	r11
    3830:	cf 92       	push	r12
    3832:	df 92       	push	r13
    3834:	ef 92       	push	r14
    3836:	ff 92       	push	r15
    3838:	0f 93       	push	r16
    383a:	1f 93       	push	r17
    383c:	cf 93       	push	r28
    383e:	df 93       	push	r29
    3840:	00 97       	sbiw	r24, 0x00	; 0
    3842:	09 f4       	brne	.+2      	; 0x3846 <vTaskDelay+0x1c>
    3844:	63 c1       	rjmp	.+710    	; 0x3b0c <vTaskDelay+0x2e2>
    3846:	20 91 17 16 	lds	r18, 0x1617	; 0x801617 <uxSchedulerSuspended>
    384a:	2f 5f       	subi	r18, 0xFF	; 255
    384c:	20 93 17 16 	sts	0x1617, r18	; 0x801617 <uxSchedulerSuspended>
    3850:	c0 91 20 16 	lds	r28, 0x1620	; 0x801620 <xTickCount>
    3854:	d0 91 21 16 	lds	r29, 0x1621	; 0x801621 <xTickCount+0x1>
    3858:	c8 0f       	add	r28, r24
    385a:	d9 1f       	adc	r29, r25
    385c:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    3860:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3864:	02 96       	adiw	r24, 0x02	; 2
    3866:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    386a:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    386e:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3872:	d3 83       	std	Z+3, r29	; 0x03
    3874:	c2 83       	std	Z+2, r28	; 0x02
    3876:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    387a:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    387e:	c8 17       	cp	r28, r24
    3880:	d9 07       	cpc	r29, r25
    3882:	68 f4       	brcc	.+26     	; 0x389e <vTaskDelay+0x74>
    3884:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    3888:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    388c:	80 91 35 16 	lds	r24, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    3890:	90 91 36 16 	lds	r25, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    3894:	6e 5f       	subi	r22, 0xFE	; 254
    3896:	7f 4f       	sbci	r23, 0xFF	; 255
    3898:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    389c:	17 c0       	rjmp	.+46     	; 0x38cc <vTaskDelay+0xa2>
    389e:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    38a2:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    38a6:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    38aa:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    38ae:	6e 5f       	subi	r22, 0xFE	; 254
    38b0:	7f 4f       	sbci	r23, 0xFF	; 255
    38b2:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    38b6:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    38ba:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    38be:	c8 17       	cp	r28, r24
    38c0:	d9 07       	cpc	r29, r25
    38c2:	20 f4       	brcc	.+8      	; 0x38cc <vTaskDelay+0xa2>
    38c4:	d0 93 19 16 	sts	0x1619, r29	; 0x801619 <xNextTaskUnblockTime+0x1>
    38c8:	c0 93 18 16 	sts	0x1618, r28	; 0x801618 <xNextTaskUnblockTime>
    38cc:	0f b6       	in	r0, 0x3f	; 63
    38ce:	f8 94       	cli
    38d0:	0f 92       	push	r0
    38d2:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    38d6:	81 50       	subi	r24, 0x01	; 1
    38d8:	80 93 17 16 	sts	0x1617, r24	; 0x801617 <uxSchedulerSuspended>
    38dc:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    38e0:	81 11       	cpse	r24, r1
    38e2:	0d c1       	rjmp	.+538    	; 0x3afe <vTaskDelay+0x2d4>
    38e4:	80 91 22 16 	lds	r24, 0x1622	; 0x801622 <uxCurrentNumberOfTasks>
    38e8:	81 11       	cpse	r24, r1
    38ea:	33 c0       	rjmp	.+102    	; 0x3952 <vTaskDelay+0x128>
    38ec:	0b c1       	rjmp	.+534    	; 0x3b04 <vTaskDelay+0x2da>
    38ee:	d7 01       	movw	r26, r14
    38f0:	15 96       	adiw	r26, 0x05	; 5
    38f2:	ed 91       	ld	r30, X+
    38f4:	fc 91       	ld	r31, X
    38f6:	16 97       	sbiw	r26, 0x06	; 6
    38f8:	c6 81       	ldd	r28, Z+6	; 0x06
    38fa:	d7 81       	ldd	r29, Z+7	; 0x07
    38fc:	ce 01       	movw	r24, r28
    38fe:	0c 96       	adiw	r24, 0x0c	; 12
    3900:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3904:	8e 01       	movw	r16, r28
    3906:	0e 5f       	subi	r16, 0xFE	; 254
    3908:	1f 4f       	sbci	r17, 0xFF	; 255
    390a:	c8 01       	movw	r24, r16
    390c:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3910:	8e 89       	ldd	r24, Y+22	; 0x16
    3912:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    3916:	98 17       	cp	r25, r24
    3918:	10 f4       	brcc	.+4      	; 0x391e <vTaskDelay+0xf4>
    391a:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    391e:	90 e0       	ldi	r25, 0x00	; 0
    3920:	9c 01       	movw	r18, r24
    3922:	22 0f       	add	r18, r18
    3924:	33 1f       	adc	r19, r19
    3926:	22 0f       	add	r18, r18
    3928:	33 1f       	adc	r19, r19
    392a:	22 0f       	add	r18, r18
    392c:	33 1f       	adc	r19, r19
    392e:	82 0f       	add	r24, r18
    3930:	93 1f       	adc	r25, r19
    3932:	b8 01       	movw	r22, r16
    3934:	85 5b       	subi	r24, 0xB5	; 181
    3936:	99 4e       	sbci	r25, 0xE9	; 233
    3938:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    393c:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    3940:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3944:	9e 89       	ldd	r25, Y+22	; 0x16
    3946:	86 89       	ldd	r24, Z+22	; 0x16
    3948:	98 17       	cp	r25, r24
    394a:	58 f0       	brcs	.+22     	; 0x3962 <vTaskDelay+0x138>
    394c:	d0 92 1c 16 	sts	0x161C, r13	; 0x80161c <xYieldPending>
    3950:	08 c0       	rjmp	.+16     	; 0x3962 <vTaskDelay+0x138>
    3952:	0f 2e       	mov	r0, r31
    3954:	fc e2       	ldi	r31, 0x2C	; 44
    3956:	ef 2e       	mov	r14, r31
    3958:	f6 e1       	ldi	r31, 0x16	; 22
    395a:	ff 2e       	mov	r15, r31
    395c:	f0 2d       	mov	r31, r0
    395e:	dd 24       	eor	r13, r13
    3960:	d3 94       	inc	r13
    3962:	f7 01       	movw	r30, r14
    3964:	80 81       	ld	r24, Z
    3966:	81 11       	cpse	r24, r1
    3968:	c2 cf       	rjmp	.-124    	; 0x38ee <vTaskDelay+0xc4>
    396a:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    396e:	88 23       	and	r24, r24
    3970:	09 f4       	brne	.+2      	; 0x3974 <vTaskDelay+0x14a>
    3972:	bd c0       	rjmp	.+378    	; 0x3aee <vTaskDelay+0x2c4>
    3974:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3978:	88 23       	and	r24, r24
    397a:	09 f4       	brne	.+2      	; 0x397e <vTaskDelay+0x154>
    397c:	b8 c0       	rjmp	.+368    	; 0x3aee <vTaskDelay+0x2c4>
    397e:	91 2c       	mov	r9, r1
    3980:	bb 24       	eor	r11, r11
    3982:	b3 94       	inc	r11
    3984:	cc 24       	eor	r12, r12
    3986:	ca 94       	dec	r12
    3988:	dc 2c       	mov	r13, r12
    398a:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    398e:	81 11       	cpse	r24, r1
    3990:	98 c0       	rjmp	.+304    	; 0x3ac2 <vTaskDelay+0x298>
    3992:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    3996:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    399a:	01 96       	adiw	r24, 0x01	; 1
    399c:	90 93 21 16 	sts	0x1621, r25	; 0x801621 <xTickCount+0x1>
    39a0:	80 93 20 16 	sts	0x1620, r24	; 0x801620 <xTickCount>
    39a4:	e0 90 20 16 	lds	r14, 0x1620	; 0x801620 <xTickCount>
    39a8:	f0 90 21 16 	lds	r15, 0x1621	; 0x801621 <xTickCount+0x1>
    39ac:	e1 14       	cp	r14, r1
    39ae:	f1 04       	cpc	r15, r1
    39b0:	89 f5       	brne	.+98     	; 0x3a14 <vTaskDelay+0x1ea>
    39b2:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    39b6:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    39ba:	20 91 35 16 	lds	r18, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    39be:	30 91 36 16 	lds	r19, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    39c2:	30 93 38 16 	sts	0x1638, r19	; 0x801638 <pxDelayedTaskList+0x1>
    39c6:	20 93 37 16 	sts	0x1637, r18	; 0x801637 <pxDelayedTaskList>
    39ca:	90 93 36 16 	sts	0x1636, r25	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    39ce:	80 93 35 16 	sts	0x1635, r24	; 0x801635 <pxOverflowDelayedTaskList>
    39d2:	80 91 1b 16 	lds	r24, 0x161B	; 0x80161b <xNumOfOverflows>
    39d6:	8f 5f       	subi	r24, 0xFF	; 255
    39d8:	80 93 1b 16 	sts	0x161B, r24	; 0x80161b <xNumOfOverflows>
    39dc:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    39e0:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    39e4:	80 81       	ld	r24, Z
    39e6:	81 11       	cpse	r24, r1
    39e8:	05 c0       	rjmp	.+10     	; 0x39f4 <vTaskDelay+0x1ca>
    39ea:	d0 92 19 16 	sts	0x1619, r13	; 0x801619 <xNextTaskUnblockTime+0x1>
    39ee:	c0 92 18 16 	sts	0x1618, r12	; 0x801618 <xNextTaskUnblockTime>
    39f2:	10 c0       	rjmp	.+32     	; 0x3a14 <vTaskDelay+0x1ea>
    39f4:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    39f8:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    39fc:	05 80       	ldd	r0, Z+5	; 0x05
    39fe:	f6 81       	ldd	r31, Z+6	; 0x06
    3a00:	e0 2d       	mov	r30, r0
    3a02:	06 80       	ldd	r0, Z+6	; 0x06
    3a04:	f7 81       	ldd	r31, Z+7	; 0x07
    3a06:	e0 2d       	mov	r30, r0
    3a08:	82 81       	ldd	r24, Z+2	; 0x02
    3a0a:	93 81       	ldd	r25, Z+3	; 0x03
    3a0c:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    3a10:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    3a14:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    3a18:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    3a1c:	e8 16       	cp	r14, r24
    3a1e:	f9 06       	cpc	r15, r25
    3a20:	08 f4       	brcc	.+2      	; 0x3a24 <vTaskDelay+0x1fa>
    3a22:	77 c0       	rjmp	.+238    	; 0x3b12 <vTaskDelay+0x2e8>
    3a24:	a9 2c       	mov	r10, r9
    3a26:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    3a2a:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3a2e:	80 81       	ld	r24, Z
    3a30:	81 11       	cpse	r24, r1
    3a32:	05 c0       	rjmp	.+10     	; 0x3a3e <vTaskDelay+0x214>
    3a34:	d0 92 19 16 	sts	0x1619, r13	; 0x801619 <xNextTaskUnblockTime+0x1>
    3a38:	c0 92 18 16 	sts	0x1618, r12	; 0x801618 <xNextTaskUnblockTime>
    3a3c:	48 c0       	rjmp	.+144    	; 0x3ace <vTaskDelay+0x2a4>
    3a3e:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    3a42:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3a46:	05 80       	ldd	r0, Z+5	; 0x05
    3a48:	f6 81       	ldd	r31, Z+6	; 0x06
    3a4a:	e0 2d       	mov	r30, r0
    3a4c:	c6 81       	ldd	r28, Z+6	; 0x06
    3a4e:	d7 81       	ldd	r29, Z+7	; 0x07
    3a50:	8a 81       	ldd	r24, Y+2	; 0x02
    3a52:	9b 81       	ldd	r25, Y+3	; 0x03
    3a54:	e8 16       	cp	r14, r24
    3a56:	f9 06       	cpc	r15, r25
    3a58:	28 f4       	brcc	.+10     	; 0x3a64 <vTaskDelay+0x23a>
    3a5a:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    3a5e:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    3a62:	35 c0       	rjmp	.+106    	; 0x3ace <vTaskDelay+0x2a4>
    3a64:	8e 01       	movw	r16, r28
    3a66:	0e 5f       	subi	r16, 0xFE	; 254
    3a68:	1f 4f       	sbci	r17, 0xFF	; 255
    3a6a:	c8 01       	movw	r24, r16
    3a6c:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3a70:	8c 89       	ldd	r24, Y+20	; 0x14
    3a72:	9d 89       	ldd	r25, Y+21	; 0x15
    3a74:	89 2b       	or	r24, r25
    3a76:	21 f0       	breq	.+8      	; 0x3a80 <vTaskDelay+0x256>
    3a78:	ce 01       	movw	r24, r28
    3a7a:	0c 96       	adiw	r24, 0x0c	; 12
    3a7c:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3a80:	8e 89       	ldd	r24, Y+22	; 0x16
    3a82:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    3a86:	98 17       	cp	r25, r24
    3a88:	10 f4       	brcc	.+4      	; 0x3a8e <vTaskDelay+0x264>
    3a8a:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    3a8e:	90 e0       	ldi	r25, 0x00	; 0
    3a90:	9c 01       	movw	r18, r24
    3a92:	22 0f       	add	r18, r18
    3a94:	33 1f       	adc	r19, r19
    3a96:	22 0f       	add	r18, r18
    3a98:	33 1f       	adc	r19, r19
    3a9a:	22 0f       	add	r18, r18
    3a9c:	33 1f       	adc	r19, r19
    3a9e:	82 0f       	add	r24, r18
    3aa0:	93 1f       	adc	r25, r19
    3aa2:	b8 01       	movw	r22, r16
    3aa4:	85 5b       	subi	r24, 0xB5	; 181
    3aa6:	99 4e       	sbci	r25, 0xE9	; 233
    3aa8:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    3aac:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    3ab0:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3ab4:	9e 89       	ldd	r25, Y+22	; 0x16
    3ab6:	86 89       	ldd	r24, Z+22	; 0x16
    3ab8:	98 17       	cp	r25, r24
    3aba:	08 f4       	brcc	.+2      	; 0x3abe <vTaskDelay+0x294>
    3abc:	b4 cf       	rjmp	.-152    	; 0x3a26 <vTaskDelay+0x1fc>
    3abe:	ab 2c       	mov	r10, r11
    3ac0:	b2 cf       	rjmp	.-156    	; 0x3a26 <vTaskDelay+0x1fc>
    3ac2:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3ac6:	8f 5f       	subi	r24, 0xFF	; 255
    3ac8:	80 93 1d 16 	sts	0x161D, r24	; 0x80161d <uxPendedTicks>
    3acc:	22 c0       	rjmp	.+68     	; 0x3b12 <vTaskDelay+0x2e8>
    3ace:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    3ad2:	81 11       	cpse	r24, r1
    3ad4:	01 c0       	rjmp	.+2      	; 0x3ad8 <vTaskDelay+0x2ae>
    3ad6:	a1 10       	cpse	r10, r1
    3ad8:	b0 92 1c 16 	sts	0x161C, r11	; 0x80161c <xYieldPending>
    3adc:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3ae0:	81 50       	subi	r24, 0x01	; 1
    3ae2:	80 93 1d 16 	sts	0x161D, r24	; 0x80161d <uxPendedTicks>
    3ae6:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3aea:	81 11       	cpse	r24, r1
    3aec:	4e cf       	rjmp	.-356    	; 0x398a <vTaskDelay+0x160>
    3aee:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    3af2:	81 30       	cpi	r24, 0x01	; 1
    3af4:	31 f4       	brne	.+12     	; 0x3b02 <vTaskDelay+0x2d8>
    3af6:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    3afa:	81 e0       	ldi	r24, 0x01	; 1
    3afc:	03 c0       	rjmp	.+6      	; 0x3b04 <vTaskDelay+0x2da>
    3afe:	80 e0       	ldi	r24, 0x00	; 0
    3b00:	01 c0       	rjmp	.+2      	; 0x3b04 <vTaskDelay+0x2da>
    3b02:	80 e0       	ldi	r24, 0x00	; 0
    3b04:	0f 90       	pop	r0
    3b06:	0f be       	out	0x3f, r0	; 63
    3b08:	81 11       	cpse	r24, r1
    3b0a:	08 c0       	rjmp	.+16     	; 0x3b1c <vTaskDelay+0x2f2>
    3b0c:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    3b10:	05 c0       	rjmp	.+10     	; 0x3b1c <vTaskDelay+0x2f2>
    3b12:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    3b16:	81 11       	cpse	r24, r1
    3b18:	df cf       	rjmp	.-66     	; 0x3ad8 <vTaskDelay+0x2ae>
    3b1a:	e0 cf       	rjmp	.-64     	; 0x3adc <vTaskDelay+0x2b2>
    3b1c:	df 91       	pop	r29
    3b1e:	cf 91       	pop	r28
    3b20:	1f 91       	pop	r17
    3b22:	0f 91       	pop	r16
    3b24:	ff 90       	pop	r15
    3b26:	ef 90       	pop	r14
    3b28:	df 90       	pop	r13
    3b2a:	cf 90       	pop	r12
    3b2c:	bf 90       	pop	r11
    3b2e:	af 90       	pop	r10
    3b30:	9f 90       	pop	r9
    3b32:	08 95       	ret

00003b34 <vTaskStartScheduler>:
    3b34:	cf 92       	push	r12
    3b36:	df 92       	push	r13
    3b38:	ef 92       	push	r14
    3b3a:	ff 92       	push	r15
    3b3c:	0f 93       	push	r16
    3b3e:	1f 93       	push	r17
    3b40:	cf 93       	push	r28
    3b42:	df 93       	push	r29
    3b44:	85 e5       	ldi	r24, 0x55	; 85
    3b46:	90 e0       	ldi	r25, 0x00	; 0
    3b48:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
    3b4c:	8c 01       	movw	r16, r24
    3b4e:	89 2b       	or	r24, r25
    3b50:	09 f4       	brne	.+2      	; 0x3b54 <vTaskStartScheduler+0x20>
    3b52:	cb c0       	rjmp	.+406    	; 0x3cea <vTaskStartScheduler+0x1b6>
    3b54:	88 e2       	ldi	r24, 0x28	; 40
    3b56:	90 e0       	ldi	r25, 0x00	; 0
    3b58:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
    3b5c:	ec 01       	movw	r28, r24
    3b5e:	89 2b       	or	r24, r25
    3b60:	69 f0       	breq	.+26     	; 0x3b7c <vTaskStartScheduler+0x48>
    3b62:	18 8f       	std	Y+24, r17	; 0x18
    3b64:	0f 8b       	std	Y+23, r16	; 0x17
    3b66:	0c 5a       	subi	r16, 0xAC	; 172
    3b68:	1f 4f       	sbci	r17, 0xFF	; 255
    3b6a:	89 e4       	ldi	r24, 0x49	; 73
    3b6c:	89 8f       	std	Y+25, r24	; 0x19
    3b6e:	e6 ee       	ldi	r30, 0xE6	; 230
    3b70:	f2 e0       	ldi	r31, 0x02	; 2
    3b72:	de 01       	movw	r26, r28
    3b74:	5a 96       	adiw	r26, 0x1a	; 26
    3b76:	2d ee       	ldi	r18, 0xED	; 237
    3b78:	32 e0       	ldi	r19, 0x02	; 2
    3b7a:	04 c0       	rjmp	.+8      	; 0x3b84 <vTaskStartScheduler+0x50>
    3b7c:	c8 01       	movw	r24, r16
    3b7e:	0e 94 e8 08 	call	0x11d0	; 0x11d0 <vPortFree>
    3b82:	b3 c0       	rjmp	.+358    	; 0x3cea <vTaskStartScheduler+0x1b6>
    3b84:	91 91       	ld	r25, Z+
    3b86:	9d 93       	st	X+, r25
    3b88:	99 23       	and	r25, r25
    3b8a:	19 f0       	breq	.+6      	; 0x3b92 <vTaskStartScheduler+0x5e>
    3b8c:	2e 17       	cp	r18, r30
    3b8e:	3f 07       	cpc	r19, r31
    3b90:	c9 f7       	brne	.-14     	; 0x3b84 <vTaskStartScheduler+0x50>
    3b92:	18 a2       	std	Y+32, r1	; 0x20
    3b94:	1e 8a       	std	Y+22, r1	; 0x16
    3b96:	19 a2       	std	Y+33, r1	; 0x21
    3b98:	1a a2       	std	Y+34, r1	; 0x22
    3b9a:	7e 01       	movw	r14, r28
    3b9c:	82 e0       	ldi	r24, 0x02	; 2
    3b9e:	e8 0e       	add	r14, r24
    3ba0:	f1 1c       	adc	r15, r1
    3ba2:	c7 01       	movw	r24, r14
    3ba4:	0e 94 49 0b 	call	0x1692	; 0x1692 <vListInitialiseItem>
    3ba8:	ce 01       	movw	r24, r28
    3baa:	0c 96       	adiw	r24, 0x0c	; 12
    3bac:	0e 94 49 0b 	call	0x1692	; 0x1692 <vListInitialiseItem>
    3bb0:	d9 87       	std	Y+9, r29	; 0x09
    3bb2:	c8 87       	std	Y+8, r28	; 0x08
    3bb4:	86 e0       	ldi	r24, 0x06	; 6
    3bb6:	90 e0       	ldi	r25, 0x00	; 0
    3bb8:	9d 87       	std	Y+13, r25	; 0x0d
    3bba:	8c 87       	std	Y+12, r24	; 0x0c
    3bbc:	db 8b       	std	Y+19, r29	; 0x13
    3bbe:	ca 8b       	std	Y+18, r28	; 0x12
    3bc0:	1b a2       	std	Y+35, r1	; 0x23
    3bc2:	1c a2       	std	Y+36, r1	; 0x24
    3bc4:	1d a2       	std	Y+37, r1	; 0x25
    3bc6:	1e a2       	std	Y+38, r1	; 0x26
    3bc8:	1f a2       	std	Y+39, r1	; 0x27
    3bca:	40 e0       	ldi	r20, 0x00	; 0
    3bcc:	50 e0       	ldi	r21, 0x00	; 0
    3bce:	63 ef       	ldi	r22, 0xF3	; 243
    3bd0:	70 e0       	ldi	r23, 0x00	; 0
    3bd2:	c8 01       	movw	r24, r16
    3bd4:	0e 94 c8 0e 	call	0x1d90	; 0x1d90 <pxPortInitialiseStack>
    3bd8:	99 83       	std	Y+1, r25	; 0x01
    3bda:	88 83       	st	Y, r24
    3bdc:	0f b6       	in	r0, 0x3f	; 63
    3bde:	f8 94       	cli
    3be0:	0f 92       	push	r0
    3be2:	80 91 22 16 	lds	r24, 0x1622	; 0x801622 <uxCurrentNumberOfTasks>
    3be6:	8f 5f       	subi	r24, 0xFF	; 255
    3be8:	80 93 22 16 	sts	0x1622, r24	; 0x801622 <uxCurrentNumberOfTasks>
    3bec:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    3bf0:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3bf4:	89 2b       	or	r24, r25
    3bf6:	a9 f5       	brne	.+106    	; 0x3c62 <vTaskStartScheduler+0x12e>
    3bf8:	d0 93 82 16 	sts	0x1682, r29	; 0x801682 <pxCurrentTCB+0x1>
    3bfc:	c0 93 81 16 	sts	0x1681, r28	; 0x801681 <pxCurrentTCB>
    3c00:	80 91 22 16 	lds	r24, 0x1622	; 0x801622 <uxCurrentNumberOfTasks>
    3c04:	81 30       	cpi	r24, 0x01	; 1
    3c06:	e1 f5       	brne	.+120    	; 0x3c80 <vTaskStartScheduler+0x14c>
    3c08:	0b e4       	ldi	r16, 0x4B	; 75
    3c0a:	16 e1       	ldi	r17, 0x16	; 22
    3c0c:	0f 2e       	mov	r0, r31
    3c0e:	f1 e8       	ldi	r31, 0x81	; 129
    3c10:	cf 2e       	mov	r12, r31
    3c12:	f6 e1       	ldi	r31, 0x16	; 22
    3c14:	df 2e       	mov	r13, r31
    3c16:	f0 2d       	mov	r31, r0
    3c18:	c8 01       	movw	r24, r16
    3c1a:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3c1e:	07 5f       	subi	r16, 0xF7	; 247
    3c20:	1f 4f       	sbci	r17, 0xFF	; 255
    3c22:	0c 15       	cp	r16, r12
    3c24:	1d 05       	cpc	r17, r13
    3c26:	c1 f7       	brne	.-16     	; 0x3c18 <vTaskStartScheduler+0xe4>
    3c28:	82 e4       	ldi	r24, 0x42	; 66
    3c2a:	96 e1       	ldi	r25, 0x16	; 22
    3c2c:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3c30:	89 e3       	ldi	r24, 0x39	; 57
    3c32:	96 e1       	ldi	r25, 0x16	; 22
    3c34:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3c38:	8c e2       	ldi	r24, 0x2C	; 44
    3c3a:	96 e1       	ldi	r25, 0x16	; 22
    3c3c:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3c40:	83 e2       	ldi	r24, 0x23	; 35
    3c42:	96 e1       	ldi	r25, 0x16	; 22
    3c44:	0e 94 3b 0b 	call	0x1676	; 0x1676 <vListInitialise>
    3c48:	82 e4       	ldi	r24, 0x42	; 66
    3c4a:	96 e1       	ldi	r25, 0x16	; 22
    3c4c:	90 93 38 16 	sts	0x1638, r25	; 0x801638 <pxDelayedTaskList+0x1>
    3c50:	80 93 37 16 	sts	0x1637, r24	; 0x801637 <pxDelayedTaskList>
    3c54:	89 e3       	ldi	r24, 0x39	; 57
    3c56:	96 e1       	ldi	r25, 0x16	; 22
    3c58:	90 93 36 16 	sts	0x1636, r25	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    3c5c:	80 93 35 16 	sts	0x1635, r24	; 0x801635 <pxOverflowDelayedTaskList>
    3c60:	0f c0       	rjmp	.+30     	; 0x3c80 <vTaskStartScheduler+0x14c>
    3c62:	80 91 1e 16 	lds	r24, 0x161E	; 0x80161e <xSchedulerRunning>
    3c66:	81 11       	cpse	r24, r1
    3c68:	0b c0       	rjmp	.+22     	; 0x3c80 <vTaskStartScheduler+0x14c>
    3c6a:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    3c6e:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3c72:	86 89       	ldd	r24, Z+22	; 0x16
    3c74:	81 11       	cpse	r24, r1
    3c76:	04 c0       	rjmp	.+8      	; 0x3c80 <vTaskStartScheduler+0x14c>
    3c78:	d0 93 82 16 	sts	0x1682, r29	; 0x801682 <pxCurrentTCB+0x1>
    3c7c:	c0 93 81 16 	sts	0x1681, r28	; 0x801681 <pxCurrentTCB>
    3c80:	80 91 1a 16 	lds	r24, 0x161A	; 0x80161a <uxTaskNumber>
    3c84:	8f 5f       	subi	r24, 0xFF	; 255
    3c86:	80 93 1a 16 	sts	0x161A, r24	; 0x80161a <uxTaskNumber>
    3c8a:	8e 89       	ldd	r24, Y+22	; 0x16
    3c8c:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    3c90:	98 17       	cp	r25, r24
    3c92:	10 f4       	brcc	.+4      	; 0x3c98 <vTaskStartScheduler+0x164>
    3c94:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    3c98:	90 e0       	ldi	r25, 0x00	; 0
    3c9a:	9c 01       	movw	r18, r24
    3c9c:	22 0f       	add	r18, r18
    3c9e:	33 1f       	adc	r19, r19
    3ca0:	22 0f       	add	r18, r18
    3ca2:	33 1f       	adc	r19, r19
    3ca4:	22 0f       	add	r18, r18
    3ca6:	33 1f       	adc	r19, r19
    3ca8:	82 0f       	add	r24, r18
    3caa:	93 1f       	adc	r25, r19
    3cac:	b7 01       	movw	r22, r14
    3cae:	85 5b       	subi	r24, 0xB5	; 181
    3cb0:	99 4e       	sbci	r25, 0xE9	; 233
    3cb2:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    3cb6:	0f 90       	pop	r0
    3cb8:	0f be       	out	0x3f, r0	; 63
    3cba:	80 91 1e 16 	lds	r24, 0x161E	; 0x80161e <xSchedulerRunning>
    3cbe:	88 23       	and	r24, r24
    3cc0:	21 f0       	breq	.+8      	; 0x3cca <vTaskStartScheduler+0x196>
    3cc2:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    3cc6:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3cca:	f8 94       	cli
    3ccc:	8f ef       	ldi	r24, 0xFF	; 255
    3cce:	9f ef       	ldi	r25, 0xFF	; 255
    3cd0:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    3cd4:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    3cd8:	81 e0       	ldi	r24, 0x01	; 1
    3cda:	80 93 1e 16 	sts	0x161E, r24	; 0x80161e <xSchedulerRunning>
    3cde:	10 92 21 16 	sts	0x1621, r1	; 0x801621 <xTickCount+0x1>
    3ce2:	10 92 20 16 	sts	0x1620, r1	; 0x801620 <xTickCount>
    3ce6:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <xPortStartScheduler>
    3cea:	df 91       	pop	r29
    3cec:	cf 91       	pop	r28
    3cee:	1f 91       	pop	r17
    3cf0:	0f 91       	pop	r16
    3cf2:	ff 90       	pop	r15
    3cf4:	ef 90       	pop	r14
    3cf6:	df 90       	pop	r13
    3cf8:	cf 90       	pop	r12
    3cfa:	08 95       	ret

00003cfc <vTaskSuspendAll>:
    3cfc:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    3d00:	8f 5f       	subi	r24, 0xFF	; 255
    3d02:	80 93 17 16 	sts	0x1617, r24	; 0x801617 <uxSchedulerSuspended>
    3d06:	08 95       	ret

00003d08 <xTaskResumeAll>:
    3d08:	9f 92       	push	r9
    3d0a:	af 92       	push	r10
    3d0c:	bf 92       	push	r11
    3d0e:	cf 92       	push	r12
    3d10:	df 92       	push	r13
    3d12:	ef 92       	push	r14
    3d14:	ff 92       	push	r15
    3d16:	0f 93       	push	r16
    3d18:	1f 93       	push	r17
    3d1a:	cf 93       	push	r28
    3d1c:	df 93       	push	r29
    3d1e:	0f b6       	in	r0, 0x3f	; 63
    3d20:	f8 94       	cli
    3d22:	0f 92       	push	r0
    3d24:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    3d28:	81 50       	subi	r24, 0x01	; 1
    3d2a:	80 93 17 16 	sts	0x1617, r24	; 0x801617 <uxSchedulerSuspended>
    3d2e:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    3d32:	81 11       	cpse	r24, r1
    3d34:	0d c1       	rjmp	.+538    	; 0x3f50 <xTaskResumeAll+0x248>
    3d36:	80 91 22 16 	lds	r24, 0x1622	; 0x801622 <uxCurrentNumberOfTasks>
    3d3a:	81 11       	cpse	r24, r1
    3d3c:	33 c0       	rjmp	.+102    	; 0x3da4 <xTaskResumeAll+0x9c>
    3d3e:	0b c1       	rjmp	.+534    	; 0x3f56 <xTaskResumeAll+0x24e>
    3d40:	d7 01       	movw	r26, r14
    3d42:	15 96       	adiw	r26, 0x05	; 5
    3d44:	ed 91       	ld	r30, X+
    3d46:	fc 91       	ld	r31, X
    3d48:	16 97       	sbiw	r26, 0x06	; 6
    3d4a:	c6 81       	ldd	r28, Z+6	; 0x06
    3d4c:	d7 81       	ldd	r29, Z+7	; 0x07
    3d4e:	ce 01       	movw	r24, r28
    3d50:	0c 96       	adiw	r24, 0x0c	; 12
    3d52:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3d56:	8e 01       	movw	r16, r28
    3d58:	0e 5f       	subi	r16, 0xFE	; 254
    3d5a:	1f 4f       	sbci	r17, 0xFF	; 255
    3d5c:	c8 01       	movw	r24, r16
    3d5e:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3d62:	8e 89       	ldd	r24, Y+22	; 0x16
    3d64:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    3d68:	98 17       	cp	r25, r24
    3d6a:	10 f4       	brcc	.+4      	; 0x3d70 <xTaskResumeAll+0x68>
    3d6c:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    3d70:	90 e0       	ldi	r25, 0x00	; 0
    3d72:	9c 01       	movw	r18, r24
    3d74:	22 0f       	add	r18, r18
    3d76:	33 1f       	adc	r19, r19
    3d78:	22 0f       	add	r18, r18
    3d7a:	33 1f       	adc	r19, r19
    3d7c:	22 0f       	add	r18, r18
    3d7e:	33 1f       	adc	r19, r19
    3d80:	82 0f       	add	r24, r18
    3d82:	93 1f       	adc	r25, r19
    3d84:	b8 01       	movw	r22, r16
    3d86:	85 5b       	subi	r24, 0xB5	; 181
    3d88:	99 4e       	sbci	r25, 0xE9	; 233
    3d8a:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    3d8e:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    3d92:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3d96:	9e 89       	ldd	r25, Y+22	; 0x16
    3d98:	86 89       	ldd	r24, Z+22	; 0x16
    3d9a:	98 17       	cp	r25, r24
    3d9c:	58 f0       	brcs	.+22     	; 0x3db4 <xTaskResumeAll+0xac>
    3d9e:	d0 92 1c 16 	sts	0x161C, r13	; 0x80161c <xYieldPending>
    3da2:	08 c0       	rjmp	.+16     	; 0x3db4 <xTaskResumeAll+0xac>
    3da4:	0f 2e       	mov	r0, r31
    3da6:	fc e2       	ldi	r31, 0x2C	; 44
    3da8:	ef 2e       	mov	r14, r31
    3daa:	f6 e1       	ldi	r31, 0x16	; 22
    3dac:	ff 2e       	mov	r15, r31
    3dae:	f0 2d       	mov	r31, r0
    3db0:	dd 24       	eor	r13, r13
    3db2:	d3 94       	inc	r13
    3db4:	f7 01       	movw	r30, r14
    3db6:	80 81       	ld	r24, Z
    3db8:	81 11       	cpse	r24, r1
    3dba:	c2 cf       	rjmp	.-124    	; 0x3d40 <xTaskResumeAll+0x38>
    3dbc:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3dc0:	88 23       	and	r24, r24
    3dc2:	09 f4       	brne	.+2      	; 0x3dc6 <xTaskResumeAll+0xbe>
    3dc4:	bd c0       	rjmp	.+378    	; 0x3f40 <xTaskResumeAll+0x238>
    3dc6:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3dca:	88 23       	and	r24, r24
    3dcc:	09 f4       	brne	.+2      	; 0x3dd0 <xTaskResumeAll+0xc8>
    3dce:	b8 c0       	rjmp	.+368    	; 0x3f40 <xTaskResumeAll+0x238>
    3dd0:	91 2c       	mov	r9, r1
    3dd2:	bb 24       	eor	r11, r11
    3dd4:	b3 94       	inc	r11
    3dd6:	cc 24       	eor	r12, r12
    3dd8:	ca 94       	dec	r12
    3dda:	dc 2c       	mov	r13, r12
    3ddc:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    3de0:	81 11       	cpse	r24, r1
    3de2:	98 c0       	rjmp	.+304    	; 0x3f14 <xTaskResumeAll+0x20c>
    3de4:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    3de8:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    3dec:	01 96       	adiw	r24, 0x01	; 1
    3dee:	90 93 21 16 	sts	0x1621, r25	; 0x801621 <xTickCount+0x1>
    3df2:	80 93 20 16 	sts	0x1620, r24	; 0x801620 <xTickCount>
    3df6:	e0 90 20 16 	lds	r14, 0x1620	; 0x801620 <xTickCount>
    3dfa:	f0 90 21 16 	lds	r15, 0x1621	; 0x801621 <xTickCount+0x1>
    3dfe:	e1 14       	cp	r14, r1
    3e00:	f1 04       	cpc	r15, r1
    3e02:	89 f5       	brne	.+98     	; 0x3e66 <xTaskResumeAll+0x15e>
    3e04:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    3e08:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3e0c:	20 91 35 16 	lds	r18, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    3e10:	30 91 36 16 	lds	r19, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    3e14:	30 93 38 16 	sts	0x1638, r19	; 0x801638 <pxDelayedTaskList+0x1>
    3e18:	20 93 37 16 	sts	0x1637, r18	; 0x801637 <pxDelayedTaskList>
    3e1c:	90 93 36 16 	sts	0x1636, r25	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    3e20:	80 93 35 16 	sts	0x1635, r24	; 0x801635 <pxOverflowDelayedTaskList>
    3e24:	80 91 1b 16 	lds	r24, 0x161B	; 0x80161b <xNumOfOverflows>
    3e28:	8f 5f       	subi	r24, 0xFF	; 255
    3e2a:	80 93 1b 16 	sts	0x161B, r24	; 0x80161b <xNumOfOverflows>
    3e2e:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    3e32:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3e36:	80 81       	ld	r24, Z
    3e38:	81 11       	cpse	r24, r1
    3e3a:	05 c0       	rjmp	.+10     	; 0x3e46 <xTaskResumeAll+0x13e>
    3e3c:	d0 92 19 16 	sts	0x1619, r13	; 0x801619 <xNextTaskUnblockTime+0x1>
    3e40:	c0 92 18 16 	sts	0x1618, r12	; 0x801618 <xNextTaskUnblockTime>
    3e44:	10 c0       	rjmp	.+32     	; 0x3e66 <xTaskResumeAll+0x15e>
    3e46:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    3e4a:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3e4e:	05 80       	ldd	r0, Z+5	; 0x05
    3e50:	f6 81       	ldd	r31, Z+6	; 0x06
    3e52:	e0 2d       	mov	r30, r0
    3e54:	06 80       	ldd	r0, Z+6	; 0x06
    3e56:	f7 81       	ldd	r31, Z+7	; 0x07
    3e58:	e0 2d       	mov	r30, r0
    3e5a:	82 81       	ldd	r24, Z+2	; 0x02
    3e5c:	93 81       	ldd	r25, Z+3	; 0x03
    3e5e:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    3e62:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    3e66:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    3e6a:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    3e6e:	e8 16       	cp	r14, r24
    3e70:	f9 06       	cpc	r15, r25
    3e72:	08 f4       	brcc	.+2      	; 0x3e76 <xTaskResumeAll+0x16e>
    3e74:	73 c0       	rjmp	.+230    	; 0x3f5c <xTaskResumeAll+0x254>
    3e76:	a9 2c       	mov	r10, r9
    3e78:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    3e7c:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3e80:	80 81       	ld	r24, Z
    3e82:	81 11       	cpse	r24, r1
    3e84:	05 c0       	rjmp	.+10     	; 0x3e90 <xTaskResumeAll+0x188>
    3e86:	d0 92 19 16 	sts	0x1619, r13	; 0x801619 <xNextTaskUnblockTime+0x1>
    3e8a:	c0 92 18 16 	sts	0x1618, r12	; 0x801618 <xNextTaskUnblockTime>
    3e8e:	48 c0       	rjmp	.+144    	; 0x3f20 <xTaskResumeAll+0x218>
    3e90:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    3e94:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3e98:	05 80       	ldd	r0, Z+5	; 0x05
    3e9a:	f6 81       	ldd	r31, Z+6	; 0x06
    3e9c:	e0 2d       	mov	r30, r0
    3e9e:	c6 81       	ldd	r28, Z+6	; 0x06
    3ea0:	d7 81       	ldd	r29, Z+7	; 0x07
    3ea2:	8a 81       	ldd	r24, Y+2	; 0x02
    3ea4:	9b 81       	ldd	r25, Y+3	; 0x03
    3ea6:	e8 16       	cp	r14, r24
    3ea8:	f9 06       	cpc	r15, r25
    3eaa:	28 f4       	brcc	.+10     	; 0x3eb6 <xTaskResumeAll+0x1ae>
    3eac:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    3eb0:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    3eb4:	35 c0       	rjmp	.+106    	; 0x3f20 <xTaskResumeAll+0x218>
    3eb6:	8e 01       	movw	r16, r28
    3eb8:	0e 5f       	subi	r16, 0xFE	; 254
    3eba:	1f 4f       	sbci	r17, 0xFF	; 255
    3ebc:	c8 01       	movw	r24, r16
    3ebe:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3ec2:	8c 89       	ldd	r24, Y+20	; 0x14
    3ec4:	9d 89       	ldd	r25, Y+21	; 0x15
    3ec6:	89 2b       	or	r24, r25
    3ec8:	21 f0       	breq	.+8      	; 0x3ed2 <xTaskResumeAll+0x1ca>
    3eca:	ce 01       	movw	r24, r28
    3ecc:	0c 96       	adiw	r24, 0x0c	; 12
    3ece:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    3ed2:	8e 89       	ldd	r24, Y+22	; 0x16
    3ed4:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    3ed8:	98 17       	cp	r25, r24
    3eda:	10 f4       	brcc	.+4      	; 0x3ee0 <xTaskResumeAll+0x1d8>
    3edc:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    3ee0:	90 e0       	ldi	r25, 0x00	; 0
    3ee2:	9c 01       	movw	r18, r24
    3ee4:	22 0f       	add	r18, r18
    3ee6:	33 1f       	adc	r19, r19
    3ee8:	22 0f       	add	r18, r18
    3eea:	33 1f       	adc	r19, r19
    3eec:	22 0f       	add	r18, r18
    3eee:	33 1f       	adc	r19, r19
    3ef0:	82 0f       	add	r24, r18
    3ef2:	93 1f       	adc	r25, r19
    3ef4:	b8 01       	movw	r22, r16
    3ef6:	85 5b       	subi	r24, 0xB5	; 181
    3ef8:	99 4e       	sbci	r25, 0xE9	; 233
    3efa:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    3efe:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    3f02:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    3f06:	9e 89       	ldd	r25, Y+22	; 0x16
    3f08:	86 89       	ldd	r24, Z+22	; 0x16
    3f0a:	98 17       	cp	r25, r24
    3f0c:	08 f4       	brcc	.+2      	; 0x3f10 <xTaskResumeAll+0x208>
    3f0e:	b4 cf       	rjmp	.-152    	; 0x3e78 <xTaskResumeAll+0x170>
    3f10:	ab 2c       	mov	r10, r11
    3f12:	b2 cf       	rjmp	.-156    	; 0x3e78 <xTaskResumeAll+0x170>
    3f14:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3f18:	8f 5f       	subi	r24, 0xFF	; 255
    3f1a:	80 93 1d 16 	sts	0x161D, r24	; 0x80161d <uxPendedTicks>
    3f1e:	1e c0       	rjmp	.+60     	; 0x3f5c <xTaskResumeAll+0x254>
    3f20:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    3f24:	81 11       	cpse	r24, r1
    3f26:	01 c0       	rjmp	.+2      	; 0x3f2a <xTaskResumeAll+0x222>
    3f28:	a1 10       	cpse	r10, r1
    3f2a:	b0 92 1c 16 	sts	0x161C, r11	; 0x80161c <xYieldPending>
    3f2e:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3f32:	81 50       	subi	r24, 0x01	; 1
    3f34:	80 93 1d 16 	sts	0x161D, r24	; 0x80161d <uxPendedTicks>
    3f38:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    3f3c:	81 11       	cpse	r24, r1
    3f3e:	4e cf       	rjmp	.-356    	; 0x3ddc <xTaskResumeAll+0xd4>
    3f40:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    3f44:	81 30       	cpi	r24, 0x01	; 1
    3f46:	31 f4       	brne	.+12     	; 0x3f54 <xTaskResumeAll+0x24c>
    3f48:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    3f4c:	81 e0       	ldi	r24, 0x01	; 1
    3f4e:	03 c0       	rjmp	.+6      	; 0x3f56 <xTaskResumeAll+0x24e>
    3f50:	80 e0       	ldi	r24, 0x00	; 0
    3f52:	01 c0       	rjmp	.+2      	; 0x3f56 <xTaskResumeAll+0x24e>
    3f54:	80 e0       	ldi	r24, 0x00	; 0
    3f56:	0f 90       	pop	r0
    3f58:	0f be       	out	0x3f, r0	; 63
    3f5a:	05 c0       	rjmp	.+10     	; 0x3f66 <xTaskResumeAll+0x25e>
    3f5c:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    3f60:	81 11       	cpse	r24, r1
    3f62:	e3 cf       	rjmp	.-58     	; 0x3f2a <xTaskResumeAll+0x222>
    3f64:	e4 cf       	rjmp	.-56     	; 0x3f2e <xTaskResumeAll+0x226>
    3f66:	df 91       	pop	r29
    3f68:	cf 91       	pop	r28
    3f6a:	1f 91       	pop	r17
    3f6c:	0f 91       	pop	r16
    3f6e:	ff 90       	pop	r15
    3f70:	ef 90       	pop	r14
    3f72:	df 90       	pop	r13
    3f74:	cf 90       	pop	r12
    3f76:	bf 90       	pop	r11
    3f78:	af 90       	pop	r10
    3f7a:	9f 90       	pop	r9
    3f7c:	08 95       	ret

00003f7e <xTaskGetTickCount>:
    3f7e:	0f b6       	in	r0, 0x3f	; 63
    3f80:	f8 94       	cli
    3f82:	0f 92       	push	r0
    3f84:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    3f88:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    3f8c:	0f 90       	pop	r0
    3f8e:	0f be       	out	0x3f, r0	; 63
    3f90:	08 95       	ret

00003f92 <xTaskIncrementTick>:
    3f92:	cf 92       	push	r12
    3f94:	df 92       	push	r13
    3f96:	ef 92       	push	r14
    3f98:	ff 92       	push	r15
    3f9a:	0f 93       	push	r16
    3f9c:	1f 93       	push	r17
    3f9e:	cf 93       	push	r28
    3fa0:	df 93       	push	r29
    3fa2:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    3fa6:	81 11       	cpse	r24, r1
    3fa8:	9f c0       	rjmp	.+318    	; 0x40e8 <xTaskIncrementTick+0x156>
    3faa:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    3fae:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    3fb2:	01 96       	adiw	r24, 0x01	; 1
    3fb4:	90 93 21 16 	sts	0x1621, r25	; 0x801621 <xTickCount+0x1>
    3fb8:	80 93 20 16 	sts	0x1620, r24	; 0x801620 <xTickCount>
    3fbc:	e0 90 20 16 	lds	r14, 0x1620	; 0x801620 <xTickCount>
    3fc0:	f0 90 21 16 	lds	r15, 0x1621	; 0x801621 <xTickCount+0x1>
    3fc4:	e1 14       	cp	r14, r1
    3fc6:	f1 04       	cpc	r15, r1
    3fc8:	99 f5       	brne	.+102    	; 0x4030 <xTaskIncrementTick+0x9e>
    3fca:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    3fce:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3fd2:	20 91 35 16 	lds	r18, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    3fd6:	30 91 36 16 	lds	r19, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    3fda:	30 93 38 16 	sts	0x1638, r19	; 0x801638 <pxDelayedTaskList+0x1>
    3fde:	20 93 37 16 	sts	0x1637, r18	; 0x801637 <pxDelayedTaskList>
    3fe2:	90 93 36 16 	sts	0x1636, r25	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    3fe6:	80 93 35 16 	sts	0x1635, r24	; 0x801635 <pxOverflowDelayedTaskList>
    3fea:	80 91 1b 16 	lds	r24, 0x161B	; 0x80161b <xNumOfOverflows>
    3fee:	8f 5f       	subi	r24, 0xFF	; 255
    3ff0:	80 93 1b 16 	sts	0x161B, r24	; 0x80161b <xNumOfOverflows>
    3ff4:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    3ff8:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    3ffc:	80 81       	ld	r24, Z
    3ffe:	81 11       	cpse	r24, r1
    4000:	07 c0       	rjmp	.+14     	; 0x4010 <xTaskIncrementTick+0x7e>
    4002:	8f ef       	ldi	r24, 0xFF	; 255
    4004:	9f ef       	ldi	r25, 0xFF	; 255
    4006:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    400a:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    400e:	10 c0       	rjmp	.+32     	; 0x4030 <xTaskIncrementTick+0x9e>
    4010:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    4014:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    4018:	05 80       	ldd	r0, Z+5	; 0x05
    401a:	f6 81       	ldd	r31, Z+6	; 0x06
    401c:	e0 2d       	mov	r30, r0
    401e:	06 80       	ldd	r0, Z+6	; 0x06
    4020:	f7 81       	ldd	r31, Z+7	; 0x07
    4022:	e0 2d       	mov	r30, r0
    4024:	82 81       	ldd	r24, Z+2	; 0x02
    4026:	93 81       	ldd	r25, Z+3	; 0x03
    4028:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    402c:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    4030:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    4034:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    4038:	e8 16       	cp	r14, r24
    403a:	f9 06       	cpc	r15, r25
    403c:	10 f4       	brcc	.+4      	; 0x4042 <xTaskIncrementTick+0xb0>
    403e:	d1 2c       	mov	r13, r1
    4040:	59 c0       	rjmp	.+178    	; 0x40f4 <xTaskIncrementTick+0x162>
    4042:	d1 2c       	mov	r13, r1
    4044:	cc 24       	eor	r12, r12
    4046:	c3 94       	inc	r12
    4048:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    404c:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    4050:	80 81       	ld	r24, Z
    4052:	81 11       	cpse	r24, r1
    4054:	07 c0       	rjmp	.+14     	; 0x4064 <xTaskIncrementTick+0xd2>
    4056:	8f ef       	ldi	r24, 0xFF	; 255
    4058:	9f ef       	ldi	r25, 0xFF	; 255
    405a:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    405e:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    4062:	48 c0       	rjmp	.+144    	; 0x40f4 <xTaskIncrementTick+0x162>
    4064:	e0 91 37 16 	lds	r30, 0x1637	; 0x801637 <pxDelayedTaskList>
    4068:	f0 91 38 16 	lds	r31, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    406c:	05 80       	ldd	r0, Z+5	; 0x05
    406e:	f6 81       	ldd	r31, Z+6	; 0x06
    4070:	e0 2d       	mov	r30, r0
    4072:	c6 81       	ldd	r28, Z+6	; 0x06
    4074:	d7 81       	ldd	r29, Z+7	; 0x07
    4076:	8a 81       	ldd	r24, Y+2	; 0x02
    4078:	9b 81       	ldd	r25, Y+3	; 0x03
    407a:	e8 16       	cp	r14, r24
    407c:	f9 06       	cpc	r15, r25
    407e:	28 f4       	brcc	.+10     	; 0x408a <xTaskIncrementTick+0xf8>
    4080:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <xNextTaskUnblockTime+0x1>
    4084:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <xNextTaskUnblockTime>
    4088:	35 c0       	rjmp	.+106    	; 0x40f4 <xTaskIncrementTick+0x162>
    408a:	8e 01       	movw	r16, r28
    408c:	0e 5f       	subi	r16, 0xFE	; 254
    408e:	1f 4f       	sbci	r17, 0xFF	; 255
    4090:	c8 01       	movw	r24, r16
    4092:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    4096:	8c 89       	ldd	r24, Y+20	; 0x14
    4098:	9d 89       	ldd	r25, Y+21	; 0x15
    409a:	89 2b       	or	r24, r25
    409c:	21 f0       	breq	.+8      	; 0x40a6 <xTaskIncrementTick+0x114>
    409e:	ce 01       	movw	r24, r28
    40a0:	0c 96       	adiw	r24, 0x0c	; 12
    40a2:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    40a6:	8e 89       	ldd	r24, Y+22	; 0x16
    40a8:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    40ac:	98 17       	cp	r25, r24
    40ae:	10 f4       	brcc	.+4      	; 0x40b4 <xTaskIncrementTick+0x122>
    40b0:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    40b4:	90 e0       	ldi	r25, 0x00	; 0
    40b6:	9c 01       	movw	r18, r24
    40b8:	22 0f       	add	r18, r18
    40ba:	33 1f       	adc	r19, r19
    40bc:	22 0f       	add	r18, r18
    40be:	33 1f       	adc	r19, r19
    40c0:	22 0f       	add	r18, r18
    40c2:	33 1f       	adc	r19, r19
    40c4:	82 0f       	add	r24, r18
    40c6:	93 1f       	adc	r25, r19
    40c8:	b8 01       	movw	r22, r16
    40ca:	85 5b       	subi	r24, 0xB5	; 181
    40cc:	99 4e       	sbci	r25, 0xE9	; 233
    40ce:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    40d2:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    40d6:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    40da:	9e 89       	ldd	r25, Y+22	; 0x16
    40dc:	86 89       	ldd	r24, Z+22	; 0x16
    40de:	98 17       	cp	r25, r24
    40e0:	08 f4       	brcc	.+2      	; 0x40e4 <xTaskIncrementTick+0x152>
    40e2:	b2 cf       	rjmp	.-156    	; 0x4048 <xTaskIncrementTick+0xb6>
    40e4:	dc 2c       	mov	r13, r12
    40e6:	b0 cf       	rjmp	.-160    	; 0x4048 <xTaskIncrementTick+0xb6>
    40e8:	80 91 1d 16 	lds	r24, 0x161D	; 0x80161d <uxPendedTicks>
    40ec:	8f 5f       	subi	r24, 0xFF	; 255
    40ee:	80 93 1d 16 	sts	0x161D, r24	; 0x80161d <uxPendedTicks>
    40f2:	d1 2c       	mov	r13, r1
    40f4:	80 91 1c 16 	lds	r24, 0x161C	; 0x80161c <xYieldPending>
    40f8:	88 23       	and	r24, r24
    40fa:	11 f0       	breq	.+4      	; 0x4100 <xTaskIncrementTick+0x16e>
    40fc:	dd 24       	eor	r13, r13
    40fe:	d3 94       	inc	r13
    4100:	8d 2d       	mov	r24, r13
    4102:	df 91       	pop	r29
    4104:	cf 91       	pop	r28
    4106:	1f 91       	pop	r17
    4108:	0f 91       	pop	r16
    410a:	ff 90       	pop	r15
    410c:	ef 90       	pop	r14
    410e:	df 90       	pop	r13
    4110:	cf 90       	pop	r12
    4112:	08 95       	ret

00004114 <vTaskSwitchContext>:
    4114:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    4118:	88 23       	and	r24, r24
    411a:	21 f0       	breq	.+8      	; 0x4124 <vTaskSwitchContext+0x10>
    411c:	81 e0       	ldi	r24, 0x01	; 1
    411e:	80 93 1c 16 	sts	0x161C, r24	; 0x80161c <xYieldPending>
    4122:	08 95       	ret
    4124:	10 92 1c 16 	sts	0x161C, r1	; 0x80161c <xYieldPending>
    4128:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    412c:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4130:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    4134:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4138:	2d 91       	ld	r18, X+
    413a:	3c 91       	ld	r19, X
    413c:	87 89       	ldd	r24, Z+23	; 0x17
    413e:	90 8d       	ldd	r25, Z+24	; 0x18
    4140:	82 17       	cp	r24, r18
    4142:	93 07       	cpc	r25, r19
    4144:	60 f0       	brcs	.+24     	; 0x415e <vTaskSwitchContext+0x4a>
    4146:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    414a:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    414e:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    4152:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4156:	67 5e       	subi	r22, 0xE7	; 231
    4158:	7f 4f       	sbci	r23, 0xFF	; 255
    415a:	0e 94 ad 0c 	call	0x195a	; 0x195a <vApplicationStackOverflowHook>
    415e:	80 91 1f 16 	lds	r24, 0x161F	; 0x80161f <uxTopReadyPriority>
    4162:	90 e0       	ldi	r25, 0x00	; 0
    4164:	fc 01       	movw	r30, r24
    4166:	ee 0f       	add	r30, r30
    4168:	ff 1f       	adc	r31, r31
    416a:	ee 0f       	add	r30, r30
    416c:	ff 1f       	adc	r31, r31
    416e:	ee 0f       	add	r30, r30
    4170:	ff 1f       	adc	r31, r31
    4172:	8e 0f       	add	r24, r30
    4174:	9f 1f       	adc	r25, r31
    4176:	fc 01       	movw	r30, r24
    4178:	e5 5b       	subi	r30, 0xB5	; 181
    417a:	f9 4e       	sbci	r31, 0xE9	; 233
    417c:	80 81       	ld	r24, Z
    417e:	81 11       	cpse	r24, r1
    4180:	17 c0       	rjmp	.+46     	; 0x41b0 <vTaskSwitchContext+0x9c>
    4182:	80 91 1f 16 	lds	r24, 0x161F	; 0x80161f <uxTopReadyPriority>
    4186:	81 50       	subi	r24, 0x01	; 1
    4188:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    418c:	80 91 1f 16 	lds	r24, 0x161F	; 0x80161f <uxTopReadyPriority>
    4190:	90 e0       	ldi	r25, 0x00	; 0
    4192:	fc 01       	movw	r30, r24
    4194:	ee 0f       	add	r30, r30
    4196:	ff 1f       	adc	r31, r31
    4198:	ee 0f       	add	r30, r30
    419a:	ff 1f       	adc	r31, r31
    419c:	ee 0f       	add	r30, r30
    419e:	ff 1f       	adc	r31, r31
    41a0:	8e 0f       	add	r24, r30
    41a2:	9f 1f       	adc	r25, r31
    41a4:	fc 01       	movw	r30, r24
    41a6:	e5 5b       	subi	r30, 0xB5	; 181
    41a8:	f9 4e       	sbci	r31, 0xE9	; 233
    41aa:	80 81       	ld	r24, Z
    41ac:	88 23       	and	r24, r24
    41ae:	49 f3       	breq	.-46     	; 0x4182 <vTaskSwitchContext+0x6e>
    41b0:	80 91 1f 16 	lds	r24, 0x161F	; 0x80161f <uxTopReadyPriority>
    41b4:	90 e0       	ldi	r25, 0x00	; 0
    41b6:	9c 01       	movw	r18, r24
    41b8:	22 0f       	add	r18, r18
    41ba:	33 1f       	adc	r19, r19
    41bc:	22 0f       	add	r18, r18
    41be:	33 1f       	adc	r19, r19
    41c0:	22 0f       	add	r18, r18
    41c2:	33 1f       	adc	r19, r19
    41c4:	28 0f       	add	r18, r24
    41c6:	39 1f       	adc	r19, r25
    41c8:	d9 01       	movw	r26, r18
    41ca:	a5 5b       	subi	r26, 0xB5	; 181
    41cc:	b9 4e       	sbci	r27, 0xE9	; 233
    41ce:	11 96       	adiw	r26, 0x01	; 1
    41d0:	ed 91       	ld	r30, X+
    41d2:	fc 91       	ld	r31, X
    41d4:	12 97       	sbiw	r26, 0x02	; 2
    41d6:	02 80       	ldd	r0, Z+2	; 0x02
    41d8:	f3 81       	ldd	r31, Z+3	; 0x03
    41da:	e0 2d       	mov	r30, r0
    41dc:	12 96       	adiw	r26, 0x02	; 2
    41de:	fc 93       	st	X, r31
    41e0:	ee 93       	st	-X, r30
    41e2:	11 97       	sbiw	r26, 0x01	; 1
    41e4:	22 5b       	subi	r18, 0xB2	; 178
    41e6:	39 4e       	sbci	r19, 0xE9	; 233
    41e8:	e2 17       	cp	r30, r18
    41ea:	f3 07       	cpc	r31, r19
    41ec:	29 f4       	brne	.+10     	; 0x41f8 <vTaskSwitchContext+0xe4>
    41ee:	22 81       	ldd	r18, Z+2	; 0x02
    41f0:	33 81       	ldd	r19, Z+3	; 0x03
    41f2:	fd 01       	movw	r30, r26
    41f4:	32 83       	std	Z+2, r19	; 0x02
    41f6:	21 83       	std	Z+1, r18	; 0x01
    41f8:	fc 01       	movw	r30, r24
    41fa:	ee 0f       	add	r30, r30
    41fc:	ff 1f       	adc	r31, r31
    41fe:	ee 0f       	add	r30, r30
    4200:	ff 1f       	adc	r31, r31
    4202:	ee 0f       	add	r30, r30
    4204:	ff 1f       	adc	r31, r31
    4206:	8e 0f       	add	r24, r30
    4208:	9f 1f       	adc	r25, r31
    420a:	fc 01       	movw	r30, r24
    420c:	e5 5b       	subi	r30, 0xB5	; 181
    420e:	f9 4e       	sbci	r31, 0xE9	; 233
    4210:	01 80       	ldd	r0, Z+1	; 0x01
    4212:	f2 81       	ldd	r31, Z+2	; 0x02
    4214:	e0 2d       	mov	r30, r0
    4216:	86 81       	ldd	r24, Z+6	; 0x06
    4218:	97 81       	ldd	r25, Z+7	; 0x07
    421a:	90 93 82 16 	sts	0x1682, r25	; 0x801682 <pxCurrentTCB+0x1>
    421e:	80 93 81 16 	sts	0x1681, r24	; 0x801681 <pxCurrentTCB>
    4222:	08 95       	ret

00004224 <vTaskPlaceOnEventList>:
    4224:	cf 93       	push	r28
    4226:	df 93       	push	r29
    4228:	eb 01       	movw	r28, r22
    422a:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    422e:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4232:	64 5f       	subi	r22, 0xF4	; 244
    4234:	7f 4f       	sbci	r23, 0xFF	; 255
    4236:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    423a:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    423e:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4242:	02 96       	adiw	r24, 0x02	; 2
    4244:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    4248:	cf 3f       	cpi	r28, 0xFF	; 255
    424a:	8f ef       	ldi	r24, 0xFF	; 255
    424c:	d8 07       	cpc	r29, r24
    424e:	59 f4       	brne	.+22     	; 0x4266 <vTaskPlaceOnEventList+0x42>
    4250:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    4254:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4258:	6e 5f       	subi	r22, 0xFE	; 254
    425a:	7f 4f       	sbci	r23, 0xFF	; 255
    425c:	83 e2       	ldi	r24, 0x23	; 35
    425e:	96 e1       	ldi	r25, 0x16	; 22
    4260:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    4264:	37 c0       	rjmp	.+110    	; 0x42d4 <vTaskPlaceOnEventList+0xb0>
    4266:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    426a:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    426e:	c8 0f       	add	r28, r24
    4270:	d9 1f       	adc	r29, r25
    4272:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    4276:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    427a:	d3 83       	std	Z+3, r29	; 0x03
    427c:	c2 83       	std	Z+2, r28	; 0x02
    427e:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    4282:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    4286:	c8 17       	cp	r28, r24
    4288:	d9 07       	cpc	r29, r25
    428a:	68 f4       	brcc	.+26     	; 0x42a6 <vTaskPlaceOnEventList+0x82>
    428c:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    4290:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4294:	80 91 35 16 	lds	r24, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    4298:	90 91 36 16 	lds	r25, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    429c:	6e 5f       	subi	r22, 0xFE	; 254
    429e:	7f 4f       	sbci	r23, 0xFF	; 255
    42a0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    42a4:	17 c0       	rjmp	.+46     	; 0x42d4 <vTaskPlaceOnEventList+0xb0>
    42a6:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    42aa:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    42ae:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    42b2:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    42b6:	6e 5f       	subi	r22, 0xFE	; 254
    42b8:	7f 4f       	sbci	r23, 0xFF	; 255
    42ba:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    42be:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    42c2:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    42c6:	c8 17       	cp	r28, r24
    42c8:	d9 07       	cpc	r29, r25
    42ca:	20 f4       	brcc	.+8      	; 0x42d4 <vTaskPlaceOnEventList+0xb0>
    42cc:	d0 93 19 16 	sts	0x1619, r29	; 0x801619 <xNextTaskUnblockTime+0x1>
    42d0:	c0 93 18 16 	sts	0x1618, r28	; 0x801618 <xNextTaskUnblockTime>
    42d4:	df 91       	pop	r29
    42d6:	cf 91       	pop	r28
    42d8:	08 95       	ret

000042da <xTaskRemoveFromEventList>:
    42da:	0f 93       	push	r16
    42dc:	1f 93       	push	r17
    42de:	cf 93       	push	r28
    42e0:	df 93       	push	r29
    42e2:	dc 01       	movw	r26, r24
    42e4:	15 96       	adiw	r26, 0x05	; 5
    42e6:	ed 91       	ld	r30, X+
    42e8:	fc 91       	ld	r31, X
    42ea:	16 97       	sbiw	r26, 0x06	; 6
    42ec:	c6 81       	ldd	r28, Z+6	; 0x06
    42ee:	d7 81       	ldd	r29, Z+7	; 0x07
    42f0:	8e 01       	movw	r16, r28
    42f2:	04 5f       	subi	r16, 0xF4	; 244
    42f4:	1f 4f       	sbci	r17, 0xFF	; 255
    42f6:	c8 01       	movw	r24, r16
    42f8:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    42fc:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    4300:	81 11       	cpse	r24, r1
    4302:	1c c0       	rjmp	.+56     	; 0x433c <xTaskRemoveFromEventList+0x62>
    4304:	0a 50       	subi	r16, 0x0A	; 10
    4306:	11 09       	sbc	r17, r1
    4308:	c8 01       	movw	r24, r16
    430a:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    430e:	8e 89       	ldd	r24, Y+22	; 0x16
    4310:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    4314:	98 17       	cp	r25, r24
    4316:	10 f4       	brcc	.+4      	; 0x431c <xTaskRemoveFromEventList+0x42>
    4318:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    431c:	90 e0       	ldi	r25, 0x00	; 0
    431e:	9c 01       	movw	r18, r24
    4320:	22 0f       	add	r18, r18
    4322:	33 1f       	adc	r19, r19
    4324:	22 0f       	add	r18, r18
    4326:	33 1f       	adc	r19, r19
    4328:	22 0f       	add	r18, r18
    432a:	33 1f       	adc	r19, r19
    432c:	82 0f       	add	r24, r18
    432e:	93 1f       	adc	r25, r19
    4330:	b8 01       	movw	r22, r16
    4332:	85 5b       	subi	r24, 0xB5	; 181
    4334:	99 4e       	sbci	r25, 0xE9	; 233
    4336:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    433a:	05 c0       	rjmp	.+10     	; 0x4346 <xTaskRemoveFromEventList+0x6c>
    433c:	b8 01       	movw	r22, r16
    433e:	8c e2       	ldi	r24, 0x2C	; 44
    4340:	96 e1       	ldi	r25, 0x16	; 22
    4342:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    4346:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    434a:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    434e:	9e 89       	ldd	r25, Y+22	; 0x16
    4350:	86 89       	ldd	r24, Z+22	; 0x16
    4352:	89 17       	cp	r24, r25
    4354:	20 f4       	brcc	.+8      	; 0x435e <xTaskRemoveFromEventList+0x84>
    4356:	81 e0       	ldi	r24, 0x01	; 1
    4358:	80 93 1c 16 	sts	0x161C, r24	; 0x80161c <xYieldPending>
    435c:	01 c0       	rjmp	.+2      	; 0x4360 <xTaskRemoveFromEventList+0x86>
    435e:	80 e0       	ldi	r24, 0x00	; 0
    4360:	df 91       	pop	r29
    4362:	cf 91       	pop	r28
    4364:	1f 91       	pop	r17
    4366:	0f 91       	pop	r16
    4368:	08 95       	ret

0000436a <vTaskSetTimeOutState>:
    436a:	20 91 1b 16 	lds	r18, 0x161B	; 0x80161b <xNumOfOverflows>
    436e:	fc 01       	movw	r30, r24
    4370:	20 83       	st	Z, r18
    4372:	20 91 20 16 	lds	r18, 0x1620	; 0x801620 <xTickCount>
    4376:	30 91 21 16 	lds	r19, 0x1621	; 0x801621 <xTickCount+0x1>
    437a:	32 83       	std	Z+2, r19	; 0x02
    437c:	21 83       	std	Z+1, r18	; 0x01
    437e:	08 95       	ret

00004380 <xTaskCheckForTimeOut>:
    4380:	fc 01       	movw	r30, r24
    4382:	0f b6       	in	r0, 0x3f	; 63
    4384:	f8 94       	cli
    4386:	0f 92       	push	r0
    4388:	20 91 20 16 	lds	r18, 0x1620	; 0x801620 <xTickCount>
    438c:	30 91 21 16 	lds	r19, 0x1621	; 0x801621 <xTickCount+0x1>
    4390:	db 01       	movw	r26, r22
    4392:	8d 91       	ld	r24, X+
    4394:	9c 91       	ld	r25, X
    4396:	8f 3f       	cpi	r24, 0xFF	; 255
    4398:	bf ef       	ldi	r27, 0xFF	; 255
    439a:	9b 07       	cpc	r25, r27
    439c:	21 f1       	breq	.+72     	; 0x43e6 <xTaskCheckForTimeOut+0x66>
    439e:	40 91 1b 16 	lds	r20, 0x161B	; 0x80161b <xNumOfOverflows>
    43a2:	50 81       	ld	r21, Z
    43a4:	54 17       	cp	r21, r20
    43a6:	29 f0       	breq	.+10     	; 0x43b2 <xTaskCheckForTimeOut+0x32>
    43a8:	41 81       	ldd	r20, Z+1	; 0x01
    43aa:	52 81       	ldd	r21, Z+2	; 0x02
    43ac:	24 17       	cp	r18, r20
    43ae:	35 07       	cpc	r19, r21
    43b0:	e0 f4       	brcc	.+56     	; 0x43ea <xTaskCheckForTimeOut+0x6a>
    43b2:	41 81       	ldd	r20, Z+1	; 0x01
    43b4:	52 81       	ldd	r21, Z+2	; 0x02
    43b6:	d9 01       	movw	r26, r18
    43b8:	a4 1b       	sub	r26, r20
    43ba:	b5 0b       	sbc	r27, r21
    43bc:	a8 17       	cp	r26, r24
    43be:	b9 07       	cpc	r27, r25
    43c0:	b0 f4       	brcc	.+44     	; 0x43ee <xTaskCheckForTimeOut+0x6e>
    43c2:	42 1b       	sub	r20, r18
    43c4:	53 0b       	sbc	r21, r19
    43c6:	84 0f       	add	r24, r20
    43c8:	95 1f       	adc	r25, r21
    43ca:	db 01       	movw	r26, r22
    43cc:	8d 93       	st	X+, r24
    43ce:	9c 93       	st	X, r25
    43d0:	80 91 1b 16 	lds	r24, 0x161B	; 0x80161b <xNumOfOverflows>
    43d4:	80 83       	st	Z, r24
    43d6:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    43da:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    43de:	92 83       	std	Z+2, r25	; 0x02
    43e0:	81 83       	std	Z+1, r24	; 0x01
    43e2:	80 e0       	ldi	r24, 0x00	; 0
    43e4:	05 c0       	rjmp	.+10     	; 0x43f0 <xTaskCheckForTimeOut+0x70>
    43e6:	80 e0       	ldi	r24, 0x00	; 0
    43e8:	03 c0       	rjmp	.+6      	; 0x43f0 <xTaskCheckForTimeOut+0x70>
    43ea:	81 e0       	ldi	r24, 0x01	; 1
    43ec:	01 c0       	rjmp	.+2      	; 0x43f0 <xTaskCheckForTimeOut+0x70>
    43ee:	81 e0       	ldi	r24, 0x01	; 1
    43f0:	0f 90       	pop	r0
    43f2:	0f be       	out	0x3f, r0	; 63
    43f4:	08 95       	ret

000043f6 <vTaskMissedYield>:
    43f6:	81 e0       	ldi	r24, 0x01	; 1
    43f8:	80 93 1c 16 	sts	0x161C, r24	; 0x80161c <xYieldPending>
    43fc:	08 95       	ret

000043fe <xTaskGetCurrentTaskHandle>:
    43fe:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    4402:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4406:	08 95       	ret

00004408 <vTaskPriorityInherit>:
    4408:	0f 93       	push	r16
    440a:	1f 93       	push	r17
    440c:	cf 93       	push	r28
    440e:	df 93       	push	r29
    4410:	fc 01       	movw	r30, r24
    4412:	89 2b       	or	r24, r25
    4414:	09 f4       	brne	.+2      	; 0x4418 <vTaskPriorityInherit+0x10>
    4416:	55 c0       	rjmp	.+170    	; 0x44c2 <vTaskPriorityInherit+0xba>
    4418:	26 89       	ldd	r18, Z+22	; 0x16
    441a:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    441e:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4422:	56 96       	adiw	r26, 0x16	; 22
    4424:	8c 91       	ld	r24, X
    4426:	28 17       	cp	r18, r24
    4428:	08 f0       	brcs	.+2      	; 0x442c <vTaskPriorityInherit+0x24>
    442a:	4b c0       	rjmp	.+150    	; 0x44c2 <vTaskPriorityInherit+0xba>
    442c:	84 85       	ldd	r24, Z+12	; 0x0c
    442e:	95 85       	ldd	r25, Z+13	; 0x0d
    4430:	99 23       	and	r25, r25
    4432:	64 f0       	brlt	.+24     	; 0x444c <vTaskPriorityInherit+0x44>
    4434:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    4438:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    443c:	56 96       	adiw	r26, 0x16	; 22
    443e:	3c 91       	ld	r19, X
    4440:	86 e0       	ldi	r24, 0x06	; 6
    4442:	90 e0       	ldi	r25, 0x00	; 0
    4444:	83 1b       	sub	r24, r19
    4446:	91 09       	sbc	r25, r1
    4448:	95 87       	std	Z+13, r25	; 0x0d
    444a:	84 87       	std	Z+12, r24	; 0x0c
    444c:	30 e0       	ldi	r19, 0x00	; 0
    444e:	c9 01       	movw	r24, r18
    4450:	88 0f       	add	r24, r24
    4452:	99 1f       	adc	r25, r25
    4454:	88 0f       	add	r24, r24
    4456:	99 1f       	adc	r25, r25
    4458:	88 0f       	add	r24, r24
    445a:	99 1f       	adc	r25, r25
    445c:	28 0f       	add	r18, r24
    445e:	39 1f       	adc	r19, r25
    4460:	25 5b       	subi	r18, 0xB5	; 181
    4462:	39 4e       	sbci	r19, 0xE9	; 233
    4464:	82 85       	ldd	r24, Z+10	; 0x0a
    4466:	93 85       	ldd	r25, Z+11	; 0x0b
    4468:	82 17       	cp	r24, r18
    446a:	93 07       	cpc	r25, r19
    446c:	19 f5       	brne	.+70     	; 0x44b4 <vTaskPriorityInherit+0xac>
    446e:	8f 01       	movw	r16, r30
    4470:	ef 01       	movw	r28, r30
    4472:	22 96       	adiw	r28, 0x02	; 2
    4474:	ce 01       	movw	r24, r28
    4476:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    447a:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    447e:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4482:	86 89       	ldd	r24, Z+22	; 0x16
    4484:	f8 01       	movw	r30, r16
    4486:	86 8b       	std	Z+22, r24	; 0x16
    4488:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    448c:	98 17       	cp	r25, r24
    448e:	10 f4       	brcc	.+4      	; 0x4494 <vTaskPriorityInherit+0x8c>
    4490:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    4494:	90 e0       	ldi	r25, 0x00	; 0
    4496:	9c 01       	movw	r18, r24
    4498:	22 0f       	add	r18, r18
    449a:	33 1f       	adc	r19, r19
    449c:	22 0f       	add	r18, r18
    449e:	33 1f       	adc	r19, r19
    44a0:	22 0f       	add	r18, r18
    44a2:	33 1f       	adc	r19, r19
    44a4:	82 0f       	add	r24, r18
    44a6:	93 1f       	adc	r25, r19
    44a8:	be 01       	movw	r22, r28
    44aa:	85 5b       	subi	r24, 0xB5	; 181
    44ac:	99 4e       	sbci	r25, 0xE9	; 233
    44ae:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    44b2:	07 c0       	rjmp	.+14     	; 0x44c2 <vTaskPriorityInherit+0xba>
    44b4:	a0 91 81 16 	lds	r26, 0x1681	; 0x801681 <pxCurrentTCB>
    44b8:	b0 91 82 16 	lds	r27, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    44bc:	56 96       	adiw	r26, 0x16	; 22
    44be:	8c 91       	ld	r24, X
    44c0:	86 8b       	std	Z+22, r24	; 0x16
    44c2:	df 91       	pop	r29
    44c4:	cf 91       	pop	r28
    44c6:	1f 91       	pop	r17
    44c8:	0f 91       	pop	r16
    44ca:	08 95       	ret

000044cc <xTaskPriorityDisinherit>:
    44cc:	0f 93       	push	r16
    44ce:	1f 93       	push	r17
    44d0:	cf 93       	push	r28
    44d2:	df 93       	push	r29
    44d4:	fc 01       	movw	r30, r24
    44d6:	89 2b       	or	r24, r25
    44d8:	79 f1       	breq	.+94     	; 0x4538 <xTaskPriorityDisinherit+0x6c>
    44da:	82 a1       	ldd	r24, Z+34	; 0x22
    44dc:	81 50       	subi	r24, 0x01	; 1
    44de:	82 a3       	std	Z+34, r24	; 0x22
    44e0:	26 89       	ldd	r18, Z+22	; 0x16
    44e2:	91 a1       	ldd	r25, Z+33	; 0x21
    44e4:	29 17       	cp	r18, r25
    44e6:	51 f1       	breq	.+84     	; 0x453c <xTaskPriorityDisinherit+0x70>
    44e8:	81 11       	cpse	r24, r1
    44ea:	2a c0       	rjmp	.+84     	; 0x4540 <xTaskPriorityDisinherit+0x74>
    44ec:	ef 01       	movw	r28, r30
    44ee:	8f 01       	movw	r16, r30
    44f0:	0e 5f       	subi	r16, 0xFE	; 254
    44f2:	1f 4f       	sbci	r17, 0xFF	; 255
    44f4:	c8 01       	movw	r24, r16
    44f6:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    44fa:	89 a1       	ldd	r24, Y+33	; 0x21
    44fc:	8e 8b       	std	Y+22, r24	; 0x16
    44fe:	26 e0       	ldi	r18, 0x06	; 6
    4500:	30 e0       	ldi	r19, 0x00	; 0
    4502:	28 1b       	sub	r18, r24
    4504:	31 09       	sbc	r19, r1
    4506:	3d 87       	std	Y+13, r19	; 0x0d
    4508:	2c 87       	std	Y+12, r18	; 0x0c
    450a:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    450e:	98 17       	cp	r25, r24
    4510:	10 f4       	brcc	.+4      	; 0x4516 <xTaskPriorityDisinherit+0x4a>
    4512:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    4516:	90 e0       	ldi	r25, 0x00	; 0
    4518:	9c 01       	movw	r18, r24
    451a:	22 0f       	add	r18, r18
    451c:	33 1f       	adc	r19, r19
    451e:	22 0f       	add	r18, r18
    4520:	33 1f       	adc	r19, r19
    4522:	22 0f       	add	r18, r18
    4524:	33 1f       	adc	r19, r19
    4526:	82 0f       	add	r24, r18
    4528:	93 1f       	adc	r25, r19
    452a:	b8 01       	movw	r22, r16
    452c:	85 5b       	subi	r24, 0xB5	; 181
    452e:	99 4e       	sbci	r25, 0xE9	; 233
    4530:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    4534:	81 e0       	ldi	r24, 0x01	; 1
    4536:	05 c0       	rjmp	.+10     	; 0x4542 <xTaskPriorityDisinherit+0x76>
    4538:	80 e0       	ldi	r24, 0x00	; 0
    453a:	03 c0       	rjmp	.+6      	; 0x4542 <xTaskPriorityDisinherit+0x76>
    453c:	80 e0       	ldi	r24, 0x00	; 0
    453e:	01 c0       	rjmp	.+2      	; 0x4542 <xTaskPriorityDisinherit+0x76>
    4540:	80 e0       	ldi	r24, 0x00	; 0
    4542:	df 91       	pop	r29
    4544:	cf 91       	pop	r28
    4546:	1f 91       	pop	r17
    4548:	0f 91       	pop	r16
    454a:	08 95       	ret

0000454c <pvTaskIncrementMutexHeldCount>:
    454c:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    4550:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4554:	89 2b       	or	r24, r25
    4556:	39 f0       	breq	.+14     	; 0x4566 <pvTaskIncrementMutexHeldCount+0x1a>
    4558:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    455c:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4560:	82 a1       	ldd	r24, Z+34	; 0x22
    4562:	8f 5f       	subi	r24, 0xFF	; 255
    4564:	82 a3       	std	Z+34, r24	; 0x22
    4566:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    456a:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    456e:	08 95       	ret

00004570 <ulTaskNotifyTake>:
    4570:	0f 93       	push	r16
    4572:	1f 93       	push	r17
    4574:	cf 93       	push	r28
    4576:	df 93       	push	r29
    4578:	18 2f       	mov	r17, r24
    457a:	eb 01       	movw	r28, r22
    457c:	0f b6       	in	r0, 0x3f	; 63
    457e:	f8 94       	cli
    4580:	0f 92       	push	r0
    4582:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    4586:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    458a:	83 a1       	ldd	r24, Z+35	; 0x23
    458c:	94 a1       	ldd	r25, Z+36	; 0x24
    458e:	a5 a1       	ldd	r26, Z+37	; 0x25
    4590:	b6 a1       	ldd	r27, Z+38	; 0x26
    4592:	89 2b       	or	r24, r25
    4594:	8a 2b       	or	r24, r26
    4596:	8b 2b       	or	r24, r27
    4598:	09 f0       	breq	.+2      	; 0x459c <ulTaskNotifyTake+0x2c>
    459a:	58 c0       	rjmp	.+176    	; 0x464c <ulTaskNotifyTake+0xdc>
    459c:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    45a0:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    45a4:	81 e0       	ldi	r24, 0x01	; 1
    45a6:	87 a3       	std	Z+39, r24	; 0x27
    45a8:	20 97       	sbiw	r28, 0x00	; 0
    45aa:	09 f4       	brne	.+2      	; 0x45ae <ulTaskNotifyTake+0x3e>
    45ac:	4f c0       	rjmp	.+158    	; 0x464c <ulTaskNotifyTake+0xdc>
    45ae:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    45b2:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    45b6:	02 96       	adiw	r24, 0x02	; 2
    45b8:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    45bc:	cf 3f       	cpi	r28, 0xFF	; 255
    45be:	8f ef       	ldi	r24, 0xFF	; 255
    45c0:	d8 07       	cpc	r29, r24
    45c2:	59 f4       	brne	.+22     	; 0x45da <ulTaskNotifyTake+0x6a>
    45c4:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    45c8:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    45cc:	6e 5f       	subi	r22, 0xFE	; 254
    45ce:	7f 4f       	sbci	r23, 0xFF	; 255
    45d0:	83 e2       	ldi	r24, 0x23	; 35
    45d2:	96 e1       	ldi	r25, 0x16	; 22
    45d4:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    45d8:	37 c0       	rjmp	.+110    	; 0x4648 <ulTaskNotifyTake+0xd8>
    45da:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    45de:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    45e2:	c8 0f       	add	r28, r24
    45e4:	d9 1f       	adc	r29, r25
    45e6:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    45ea:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    45ee:	d3 83       	std	Z+3, r29	; 0x03
    45f0:	c2 83       	std	Z+2, r28	; 0x02
    45f2:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    45f6:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    45fa:	c8 17       	cp	r28, r24
    45fc:	d9 07       	cpc	r29, r25
    45fe:	68 f4       	brcc	.+26     	; 0x461a <ulTaskNotifyTake+0xaa>
    4600:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    4604:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4608:	80 91 35 16 	lds	r24, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    460c:	90 91 36 16 	lds	r25, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    4610:	6e 5f       	subi	r22, 0xFE	; 254
    4612:	7f 4f       	sbci	r23, 0xFF	; 255
    4614:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    4618:	17 c0       	rjmp	.+46     	; 0x4648 <ulTaskNotifyTake+0xd8>
    461a:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    461e:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4622:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    4626:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    462a:	6e 5f       	subi	r22, 0xFE	; 254
    462c:	7f 4f       	sbci	r23, 0xFF	; 255
    462e:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    4632:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    4636:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    463a:	c8 17       	cp	r28, r24
    463c:	d9 07       	cpc	r29, r25
    463e:	20 f4       	brcc	.+8      	; 0x4648 <ulTaskNotifyTake+0xd8>
    4640:	d0 93 19 16 	sts	0x1619, r29	; 0x801619 <xNextTaskUnblockTime+0x1>
    4644:	c0 93 18 16 	sts	0x1618, r28	; 0x801618 <xNextTaskUnblockTime>
    4648:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    464c:	0f 90       	pop	r0
    464e:	0f be       	out	0x3f, r0	; 63
    4650:	0f b6       	in	r0, 0x3f	; 63
    4652:	f8 94       	cli
    4654:	0f 92       	push	r0
    4656:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    465a:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    465e:	63 a1       	ldd	r22, Z+35	; 0x23
    4660:	74 a1       	ldd	r23, Z+36	; 0x24
    4662:	85 a1       	ldd	r24, Z+37	; 0x25
    4664:	96 a1       	ldd	r25, Z+38	; 0x26
    4666:	61 15       	cp	r22, r1
    4668:	71 05       	cpc	r23, r1
    466a:	81 05       	cpc	r24, r1
    466c:	91 05       	cpc	r25, r1
    466e:	d9 f0       	breq	.+54     	; 0x46a6 <ulTaskNotifyTake+0x136>
    4670:	11 23       	and	r17, r17
    4672:	49 f0       	breq	.+18     	; 0x4686 <ulTaskNotifyTake+0x116>
    4674:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    4678:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    467c:	13 a2       	std	Z+35, r1	; 0x23
    467e:	14 a2       	std	Z+36, r1	; 0x24
    4680:	15 a2       	std	Z+37, r1	; 0x25
    4682:	16 a2       	std	Z+38, r1	; 0x26
    4684:	10 c0       	rjmp	.+32     	; 0x46a6 <ulTaskNotifyTake+0x136>
    4686:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    468a:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    468e:	03 a1       	ldd	r16, Z+35	; 0x23
    4690:	14 a1       	ldd	r17, Z+36	; 0x24
    4692:	25 a1       	ldd	r18, Z+37	; 0x25
    4694:	36 a1       	ldd	r19, Z+38	; 0x26
    4696:	01 50       	subi	r16, 0x01	; 1
    4698:	11 09       	sbc	r17, r1
    469a:	21 09       	sbc	r18, r1
    469c:	31 09       	sbc	r19, r1
    469e:	03 a3       	std	Z+35, r16	; 0x23
    46a0:	14 a3       	std	Z+36, r17	; 0x24
    46a2:	25 a3       	std	Z+37, r18	; 0x25
    46a4:	36 a3       	std	Z+38, r19	; 0x26
    46a6:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    46aa:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    46ae:	17 a2       	std	Z+39, r1	; 0x27
    46b0:	0f 90       	pop	r0
    46b2:	0f be       	out	0x3f, r0	; 63
    46b4:	df 91       	pop	r29
    46b6:	cf 91       	pop	r28
    46b8:	1f 91       	pop	r17
    46ba:	0f 91       	pop	r16
    46bc:	08 95       	ret

000046be <xTaskNotifyWait>:
    46be:	4f 92       	push	r4
    46c0:	5f 92       	push	r5
    46c2:	6f 92       	push	r6
    46c4:	7f 92       	push	r7
    46c6:	8f 92       	push	r8
    46c8:	9f 92       	push	r9
    46ca:	af 92       	push	r10
    46cc:	bf 92       	push	r11
    46ce:	ef 92       	push	r14
    46d0:	ff 92       	push	r15
    46d2:	0f 93       	push	r16
    46d4:	1f 93       	push	r17
    46d6:	49 01       	movw	r8, r18
    46d8:	5a 01       	movw	r10, r20
    46da:	0f b6       	in	r0, 0x3f	; 63
    46dc:	f8 94       	cli
    46de:	0f 92       	push	r0
    46e0:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    46e4:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    46e8:	27 a1       	ldd	r18, Z+39	; 0x27
    46ea:	22 30       	cpi	r18, 0x02	; 2
    46ec:	09 f4       	brne	.+2      	; 0x46f0 <xTaskNotifyWait+0x32>
    46ee:	6f c0       	rjmp	.+222    	; 0x47ce <xTaskNotifyWait+0x110>
    46f0:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    46f4:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    46f8:	43 a0       	ldd	r4, Z+35	; 0x23
    46fa:	54 a0       	ldd	r5, Z+36	; 0x24
    46fc:	65 a0       	ldd	r6, Z+37	; 0x25
    46fe:	76 a0       	ldd	r7, Z+38	; 0x26
    4700:	dc 01       	movw	r26, r24
    4702:	cb 01       	movw	r24, r22
    4704:	80 95       	com	r24
    4706:	90 95       	com	r25
    4708:	a0 95       	com	r26
    470a:	b0 95       	com	r27
    470c:	84 21       	and	r24, r4
    470e:	95 21       	and	r25, r5
    4710:	a6 21       	and	r26, r6
    4712:	b7 21       	and	r27, r7
    4714:	83 a3       	std	Z+35, r24	; 0x23
    4716:	94 a3       	std	Z+36, r25	; 0x24
    4718:	a5 a3       	std	Z+37, r26	; 0x25
    471a:	b6 a3       	std	Z+38, r27	; 0x26
    471c:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    4720:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4724:	81 e0       	ldi	r24, 0x01	; 1
    4726:	87 a3       	std	Z+39, r24	; 0x27
    4728:	e1 14       	cp	r14, r1
    472a:	f1 04       	cpc	r15, r1
    472c:	09 f4       	brne	.+2      	; 0x4730 <xTaskNotifyWait+0x72>
    472e:	4f c0       	rjmp	.+158    	; 0x47ce <xTaskNotifyWait+0x110>
    4730:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    4734:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4738:	02 96       	adiw	r24, 0x02	; 2
    473a:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    473e:	8f ef       	ldi	r24, 0xFF	; 255
    4740:	e8 16       	cp	r14, r24
    4742:	f8 06       	cpc	r15, r24
    4744:	59 f4       	brne	.+22     	; 0x475c <xTaskNotifyWait+0x9e>
    4746:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    474a:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    474e:	6e 5f       	subi	r22, 0xFE	; 254
    4750:	7f 4f       	sbci	r23, 0xFF	; 255
    4752:	83 e2       	ldi	r24, 0x23	; 35
    4754:	96 e1       	ldi	r25, 0x16	; 22
    4756:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    475a:	37 c0       	rjmp	.+110    	; 0x47ca <xTaskNotifyWait+0x10c>
    475c:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    4760:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    4764:	e8 0e       	add	r14, r24
    4766:	f9 1e       	adc	r15, r25
    4768:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    476c:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4770:	f3 82       	std	Z+3, r15	; 0x03
    4772:	e2 82       	std	Z+2, r14	; 0x02
    4774:	80 91 20 16 	lds	r24, 0x1620	; 0x801620 <xTickCount>
    4778:	90 91 21 16 	lds	r25, 0x1621	; 0x801621 <xTickCount+0x1>
    477c:	e8 16       	cp	r14, r24
    477e:	f9 06       	cpc	r15, r25
    4780:	68 f4       	brcc	.+26     	; 0x479c <xTaskNotifyWait+0xde>
    4782:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    4786:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    478a:	80 91 35 16 	lds	r24, 0x1635	; 0x801635 <pxOverflowDelayedTaskList>
    478e:	90 91 36 16 	lds	r25, 0x1636	; 0x801636 <pxOverflowDelayedTaskList+0x1>
    4792:	6e 5f       	subi	r22, 0xFE	; 254
    4794:	7f 4f       	sbci	r23, 0xFF	; 255
    4796:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    479a:	17 c0       	rjmp	.+46     	; 0x47ca <xTaskNotifyWait+0x10c>
    479c:	60 91 81 16 	lds	r22, 0x1681	; 0x801681 <pxCurrentTCB>
    47a0:	70 91 82 16 	lds	r23, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    47a4:	80 91 37 16 	lds	r24, 0x1637	; 0x801637 <pxDelayedTaskList>
    47a8:	90 91 38 16 	lds	r25, 0x1638	; 0x801638 <pxDelayedTaskList+0x1>
    47ac:	6e 5f       	subi	r22, 0xFE	; 254
    47ae:	7f 4f       	sbci	r23, 0xFF	; 255
    47b0:	0e 94 6e 0b 	call	0x16dc	; 0x16dc <vListInsert>
    47b4:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <xNextTaskUnblockTime>
    47b8:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <xNextTaskUnblockTime+0x1>
    47bc:	e8 16       	cp	r14, r24
    47be:	f9 06       	cpc	r15, r25
    47c0:	20 f4       	brcc	.+8      	; 0x47ca <xTaskNotifyWait+0x10c>
    47c2:	f0 92 19 16 	sts	0x1619, r15	; 0x801619 <xNextTaskUnblockTime+0x1>
    47c6:	e0 92 18 16 	sts	0x1618, r14	; 0x801618 <xNextTaskUnblockTime>
    47ca:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    47ce:	0f 90       	pop	r0
    47d0:	0f be       	out	0x3f, r0	; 63
    47d2:	0f b6       	in	r0, 0x3f	; 63
    47d4:	f8 94       	cli
    47d6:	0f 92       	push	r0
    47d8:	01 15       	cp	r16, r1
    47da:	11 05       	cpc	r17, r1
    47dc:	69 f0       	breq	.+26     	; 0x47f8 <xTaskNotifyWait+0x13a>
    47de:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    47e2:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    47e6:	83 a1       	ldd	r24, Z+35	; 0x23
    47e8:	94 a1       	ldd	r25, Z+36	; 0x24
    47ea:	a5 a1       	ldd	r26, Z+37	; 0x25
    47ec:	b6 a1       	ldd	r27, Z+38	; 0x26
    47ee:	f8 01       	movw	r30, r16
    47f0:	80 83       	st	Z, r24
    47f2:	91 83       	std	Z+1, r25	; 0x01
    47f4:	a2 83       	std	Z+2, r26	; 0x02
    47f6:	b3 83       	std	Z+3, r27	; 0x03
    47f8:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    47fc:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4800:	87 a1       	ldd	r24, Z+39	; 0x27
    4802:	81 30       	cpi	r24, 0x01	; 1
    4804:	b1 f0       	breq	.+44     	; 0x4832 <xTaskNotifyWait+0x174>
    4806:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    480a:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    480e:	83 a1       	ldd	r24, Z+35	; 0x23
    4810:	94 a1       	ldd	r25, Z+36	; 0x24
    4812:	a5 a1       	ldd	r26, Z+37	; 0x25
    4814:	b6 a1       	ldd	r27, Z+38	; 0x26
    4816:	80 94       	com	r8
    4818:	90 94       	com	r9
    481a:	a0 94       	com	r10
    481c:	b0 94       	com	r11
    481e:	88 22       	and	r8, r24
    4820:	99 22       	and	r9, r25
    4822:	aa 22       	and	r10, r26
    4824:	bb 22       	and	r11, r27
    4826:	83 a2       	std	Z+35, r8	; 0x23
    4828:	94 a2       	std	Z+36, r9	; 0x24
    482a:	a5 a2       	std	Z+37, r10	; 0x25
    482c:	b6 a2       	std	Z+38, r11	; 0x26
    482e:	81 e0       	ldi	r24, 0x01	; 1
    4830:	01 c0       	rjmp	.+2      	; 0x4834 <xTaskNotifyWait+0x176>
    4832:	80 e0       	ldi	r24, 0x00	; 0
    4834:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    4838:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    483c:	17 a2       	std	Z+39, r1	; 0x27
    483e:	0f 90       	pop	r0
    4840:	0f be       	out	0x3f, r0	; 63
    4842:	1f 91       	pop	r17
    4844:	0f 91       	pop	r16
    4846:	ff 90       	pop	r15
    4848:	ef 90       	pop	r14
    484a:	bf 90       	pop	r11
    484c:	af 90       	pop	r10
    484e:	9f 90       	pop	r9
    4850:	8f 90       	pop	r8
    4852:	7f 90       	pop	r7
    4854:	6f 90       	pop	r6
    4856:	5f 90       	pop	r5
    4858:	4f 90       	pop	r4
    485a:	08 95       	ret

0000485c <xTaskGenericNotify>:
    485c:	0f 93       	push	r16
    485e:	1f 93       	push	r17
    4860:	cf 93       	push	r28
    4862:	df 93       	push	r29
    4864:	fc 01       	movw	r30, r24
    4866:	0f b6       	in	r0, 0x3f	; 63
    4868:	f8 94       	cli
    486a:	0f 92       	push	r0
    486c:	01 15       	cp	r16, r1
    486e:	11 05       	cpc	r17, r1
    4870:	49 f0       	breq	.+18     	; 0x4884 <xTaskGenericNotify+0x28>
    4872:	83 a1       	ldd	r24, Z+35	; 0x23
    4874:	94 a1       	ldd	r25, Z+36	; 0x24
    4876:	a5 a1       	ldd	r26, Z+37	; 0x25
    4878:	b6 a1       	ldd	r27, Z+38	; 0x26
    487a:	e8 01       	movw	r28, r16
    487c:	88 83       	st	Y, r24
    487e:	99 83       	std	Y+1, r25	; 0x01
    4880:	aa 83       	std	Y+2, r26	; 0x02
    4882:	bb 83       	std	Y+3, r27	; 0x03
    4884:	87 a1       	ldd	r24, Z+39	; 0x27
    4886:	92 e0       	ldi	r25, 0x02	; 2
    4888:	97 a3       	std	Z+39, r25	; 0x27
    488a:	22 30       	cpi	r18, 0x02	; 2
    488c:	b1 f0       	breq	.+44     	; 0x48ba <xTaskGenericNotify+0x5e>
    488e:	18 f4       	brcc	.+6      	; 0x4896 <xTaskGenericNotify+0x3a>
    4890:	21 30       	cpi	r18, 0x01	; 1
    4892:	31 f0       	breq	.+12     	; 0x48a0 <xTaskGenericNotify+0x44>
    4894:	2a c0       	rjmp	.+84     	; 0x48ea <xTaskGenericNotify+0x8e>
    4896:	23 30       	cpi	r18, 0x03	; 3
    4898:	e9 f0       	breq	.+58     	; 0x48d4 <xTaskGenericNotify+0x78>
    489a:	24 30       	cpi	r18, 0x04	; 4
    489c:	01 f1       	breq	.+64     	; 0x48de <xTaskGenericNotify+0x82>
    489e:	25 c0       	rjmp	.+74     	; 0x48ea <xTaskGenericNotify+0x8e>
    48a0:	03 a1       	ldd	r16, Z+35	; 0x23
    48a2:	14 a1       	ldd	r17, Z+36	; 0x24
    48a4:	25 a1       	ldd	r18, Z+37	; 0x25
    48a6:	36 a1       	ldd	r19, Z+38	; 0x26
    48a8:	40 2b       	or	r20, r16
    48aa:	51 2b       	or	r21, r17
    48ac:	62 2b       	or	r22, r18
    48ae:	73 2b       	or	r23, r19
    48b0:	43 a3       	std	Z+35, r20	; 0x23
    48b2:	54 a3       	std	Z+36, r21	; 0x24
    48b4:	65 a3       	std	Z+37, r22	; 0x25
    48b6:	76 a3       	std	Z+38, r23	; 0x26
    48b8:	18 c0       	rjmp	.+48     	; 0x48ea <xTaskGenericNotify+0x8e>
    48ba:	43 a1       	ldd	r20, Z+35	; 0x23
    48bc:	54 a1       	ldd	r21, Z+36	; 0x24
    48be:	65 a1       	ldd	r22, Z+37	; 0x25
    48c0:	76 a1       	ldd	r23, Z+38	; 0x26
    48c2:	4f 5f       	subi	r20, 0xFF	; 255
    48c4:	5f 4f       	sbci	r21, 0xFF	; 255
    48c6:	6f 4f       	sbci	r22, 0xFF	; 255
    48c8:	7f 4f       	sbci	r23, 0xFF	; 255
    48ca:	43 a3       	std	Z+35, r20	; 0x23
    48cc:	54 a3       	std	Z+36, r21	; 0x24
    48ce:	65 a3       	std	Z+37, r22	; 0x25
    48d0:	76 a3       	std	Z+38, r23	; 0x26
    48d2:	0b c0       	rjmp	.+22     	; 0x48ea <xTaskGenericNotify+0x8e>
    48d4:	43 a3       	std	Z+35, r20	; 0x23
    48d6:	54 a3       	std	Z+36, r21	; 0x24
    48d8:	65 a3       	std	Z+37, r22	; 0x25
    48da:	76 a3       	std	Z+38, r23	; 0x26
    48dc:	06 c0       	rjmp	.+12     	; 0x48ea <xTaskGenericNotify+0x8e>
    48de:	82 30       	cpi	r24, 0x02	; 2
    48e0:	79 f1       	breq	.+94     	; 0x4940 <xTaskGenericNotify+0xe4>
    48e2:	43 a3       	std	Z+35, r20	; 0x23
    48e4:	54 a3       	std	Z+36, r21	; 0x24
    48e6:	65 a3       	std	Z+37, r22	; 0x25
    48e8:	76 a3       	std	Z+38, r23	; 0x26
    48ea:	81 30       	cpi	r24, 0x01	; 1
    48ec:	59 f5       	brne	.+86     	; 0x4944 <xTaskGenericNotify+0xe8>
    48ee:	ef 01       	movw	r28, r30
    48f0:	8f 01       	movw	r16, r30
    48f2:	0e 5f       	subi	r16, 0xFE	; 254
    48f4:	1f 4f       	sbci	r17, 0xFF	; 255
    48f6:	c8 01       	movw	r24, r16
    48f8:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    48fc:	8e 89       	ldd	r24, Y+22	; 0x16
    48fe:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    4902:	98 17       	cp	r25, r24
    4904:	10 f4       	brcc	.+4      	; 0x490a <xTaskGenericNotify+0xae>
    4906:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    490a:	90 e0       	ldi	r25, 0x00	; 0
    490c:	9c 01       	movw	r18, r24
    490e:	22 0f       	add	r18, r18
    4910:	33 1f       	adc	r19, r19
    4912:	22 0f       	add	r18, r18
    4914:	33 1f       	adc	r19, r19
    4916:	22 0f       	add	r18, r18
    4918:	33 1f       	adc	r19, r19
    491a:	82 0f       	add	r24, r18
    491c:	93 1f       	adc	r25, r19
    491e:	b8 01       	movw	r22, r16
    4920:	85 5b       	subi	r24, 0xB5	; 181
    4922:	99 4e       	sbci	r25, 0xE9	; 233
    4924:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    4928:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    492c:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4930:	9e 89       	ldd	r25, Y+22	; 0x16
    4932:	86 89       	ldd	r24, Z+22	; 0x16
    4934:	89 17       	cp	r24, r25
    4936:	40 f4       	brcc	.+16     	; 0x4948 <xTaskGenericNotify+0xec>
    4938:	0e 94 82 0f 	call	0x1f04	; 0x1f04 <vPortYield>
    493c:	81 e0       	ldi	r24, 0x01	; 1
    493e:	05 c0       	rjmp	.+10     	; 0x494a <xTaskGenericNotify+0xee>
    4940:	80 e0       	ldi	r24, 0x00	; 0
    4942:	03 c0       	rjmp	.+6      	; 0x494a <xTaskGenericNotify+0xee>
    4944:	81 e0       	ldi	r24, 0x01	; 1
    4946:	01 c0       	rjmp	.+2      	; 0x494a <xTaskGenericNotify+0xee>
    4948:	81 e0       	ldi	r24, 0x01	; 1
    494a:	0f 90       	pop	r0
    494c:	0f be       	out	0x3f, r0	; 63
    494e:	df 91       	pop	r29
    4950:	cf 91       	pop	r28
    4952:	1f 91       	pop	r17
    4954:	0f 91       	pop	r16
    4956:	08 95       	ret

00004958 <xTaskGenericNotifyFromISR>:
    4958:	ef 92       	push	r14
    495a:	ff 92       	push	r15
    495c:	0f 93       	push	r16
    495e:	1f 93       	push	r17
    4960:	cf 93       	push	r28
    4962:	df 93       	push	r29
    4964:	fc 01       	movw	r30, r24
    4966:	01 15       	cp	r16, r1
    4968:	11 05       	cpc	r17, r1
    496a:	49 f0       	breq	.+18     	; 0x497e <xTaskGenericNotifyFromISR+0x26>
    496c:	83 a1       	ldd	r24, Z+35	; 0x23
    496e:	94 a1       	ldd	r25, Z+36	; 0x24
    4970:	a5 a1       	ldd	r26, Z+37	; 0x25
    4972:	b6 a1       	ldd	r27, Z+38	; 0x26
    4974:	e8 01       	movw	r28, r16
    4976:	88 83       	st	Y, r24
    4978:	99 83       	std	Y+1, r25	; 0x01
    497a:	aa 83       	std	Y+2, r26	; 0x02
    497c:	bb 83       	std	Y+3, r27	; 0x03
    497e:	87 a1       	ldd	r24, Z+39	; 0x27
    4980:	92 e0       	ldi	r25, 0x02	; 2
    4982:	97 a3       	std	Z+39, r25	; 0x27
    4984:	22 30       	cpi	r18, 0x02	; 2
    4986:	b1 f0       	breq	.+44     	; 0x49b4 <xTaskGenericNotifyFromISR+0x5c>
    4988:	18 f4       	brcc	.+6      	; 0x4990 <xTaskGenericNotifyFromISR+0x38>
    498a:	21 30       	cpi	r18, 0x01	; 1
    498c:	31 f0       	breq	.+12     	; 0x499a <xTaskGenericNotifyFromISR+0x42>
    498e:	2a c0       	rjmp	.+84     	; 0x49e4 <xTaskGenericNotifyFromISR+0x8c>
    4990:	23 30       	cpi	r18, 0x03	; 3
    4992:	e9 f0       	breq	.+58     	; 0x49ce <xTaskGenericNotifyFromISR+0x76>
    4994:	24 30       	cpi	r18, 0x04	; 4
    4996:	01 f1       	breq	.+64     	; 0x49d8 <xTaskGenericNotifyFromISR+0x80>
    4998:	25 c0       	rjmp	.+74     	; 0x49e4 <xTaskGenericNotifyFromISR+0x8c>
    499a:	03 a1       	ldd	r16, Z+35	; 0x23
    499c:	14 a1       	ldd	r17, Z+36	; 0x24
    499e:	25 a1       	ldd	r18, Z+37	; 0x25
    49a0:	36 a1       	ldd	r19, Z+38	; 0x26
    49a2:	40 2b       	or	r20, r16
    49a4:	51 2b       	or	r21, r17
    49a6:	62 2b       	or	r22, r18
    49a8:	73 2b       	or	r23, r19
    49aa:	43 a3       	std	Z+35, r20	; 0x23
    49ac:	54 a3       	std	Z+36, r21	; 0x24
    49ae:	65 a3       	std	Z+37, r22	; 0x25
    49b0:	76 a3       	std	Z+38, r23	; 0x26
    49b2:	18 c0       	rjmp	.+48     	; 0x49e4 <xTaskGenericNotifyFromISR+0x8c>
    49b4:	43 a1       	ldd	r20, Z+35	; 0x23
    49b6:	54 a1       	ldd	r21, Z+36	; 0x24
    49b8:	65 a1       	ldd	r22, Z+37	; 0x25
    49ba:	76 a1       	ldd	r23, Z+38	; 0x26
    49bc:	4f 5f       	subi	r20, 0xFF	; 255
    49be:	5f 4f       	sbci	r21, 0xFF	; 255
    49c0:	6f 4f       	sbci	r22, 0xFF	; 255
    49c2:	7f 4f       	sbci	r23, 0xFF	; 255
    49c4:	43 a3       	std	Z+35, r20	; 0x23
    49c6:	54 a3       	std	Z+36, r21	; 0x24
    49c8:	65 a3       	std	Z+37, r22	; 0x25
    49ca:	76 a3       	std	Z+38, r23	; 0x26
    49cc:	0b c0       	rjmp	.+22     	; 0x49e4 <xTaskGenericNotifyFromISR+0x8c>
    49ce:	43 a3       	std	Z+35, r20	; 0x23
    49d0:	54 a3       	std	Z+36, r21	; 0x24
    49d2:	65 a3       	std	Z+37, r22	; 0x25
    49d4:	76 a3       	std	Z+38, r23	; 0x26
    49d6:	06 c0       	rjmp	.+12     	; 0x49e4 <xTaskGenericNotifyFromISR+0x8c>
    49d8:	82 30       	cpi	r24, 0x02	; 2
    49da:	f1 f1       	breq	.+124    	; 0x4a58 <xTaskGenericNotifyFromISR+0x100>
    49dc:	43 a3       	std	Z+35, r20	; 0x23
    49de:	54 a3       	std	Z+36, r21	; 0x24
    49e0:	65 a3       	std	Z+37, r22	; 0x25
    49e2:	76 a3       	std	Z+38, r23	; 0x26
    49e4:	81 30       	cpi	r24, 0x01	; 1
    49e6:	d1 f5       	brne	.+116    	; 0x4a5c <xTaskGenericNotifyFromISR+0x104>
    49e8:	ef 01       	movw	r28, r30
    49ea:	80 91 17 16 	lds	r24, 0x1617	; 0x801617 <uxSchedulerSuspended>
    49ee:	81 11       	cpse	r24, r1
    49f0:	1d c0       	rjmp	.+58     	; 0x4a2c <xTaskGenericNotifyFromISR+0xd4>
    49f2:	8f 01       	movw	r16, r30
    49f4:	0e 5f       	subi	r16, 0xFE	; 254
    49f6:	1f 4f       	sbci	r17, 0xFF	; 255
    49f8:	c8 01       	movw	r24, r16
    49fa:	0e 94 9f 0b 	call	0x173e	; 0x173e <uxListRemove>
    49fe:	8e 89       	ldd	r24, Y+22	; 0x16
    4a00:	90 91 1f 16 	lds	r25, 0x161F	; 0x80161f <uxTopReadyPriority>
    4a04:	98 17       	cp	r25, r24
    4a06:	10 f4       	brcc	.+4      	; 0x4a0c <xTaskGenericNotifyFromISR+0xb4>
    4a08:	80 93 1f 16 	sts	0x161F, r24	; 0x80161f <uxTopReadyPriority>
    4a0c:	90 e0       	ldi	r25, 0x00	; 0
    4a0e:	9c 01       	movw	r18, r24
    4a10:	22 0f       	add	r18, r18
    4a12:	33 1f       	adc	r19, r19
    4a14:	22 0f       	add	r18, r18
    4a16:	33 1f       	adc	r19, r19
    4a18:	22 0f       	add	r18, r18
    4a1a:	33 1f       	adc	r19, r19
    4a1c:	82 0f       	add	r24, r18
    4a1e:	93 1f       	adc	r25, r19
    4a20:	b8 01       	movw	r22, r16
    4a22:	85 5b       	subi	r24, 0xB5	; 181
    4a24:	99 4e       	sbci	r25, 0xE9	; 233
    4a26:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    4a2a:	07 c0       	rjmp	.+14     	; 0x4a3a <xTaskGenericNotifyFromISR+0xe2>
    4a2c:	bf 01       	movw	r22, r30
    4a2e:	64 5f       	subi	r22, 0xF4	; 244
    4a30:	7f 4f       	sbci	r23, 0xFF	; 255
    4a32:	8c e2       	ldi	r24, 0x2C	; 44
    4a34:	96 e1       	ldi	r25, 0x16	; 22
    4a36:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListInsertEnd>
    4a3a:	e0 91 81 16 	lds	r30, 0x1681	; 0x801681 <pxCurrentTCB>
    4a3e:	f0 91 82 16 	lds	r31, 0x1682	; 0x801682 <pxCurrentTCB+0x1>
    4a42:	9e 89       	ldd	r25, Y+22	; 0x16
    4a44:	86 89       	ldd	r24, Z+22	; 0x16
    4a46:	89 17       	cp	r24, r25
    4a48:	58 f4       	brcc	.+22     	; 0x4a60 <xTaskGenericNotifyFromISR+0x108>
    4a4a:	e1 14       	cp	r14, r1
    4a4c:	f1 04       	cpc	r15, r1
    4a4e:	51 f0       	breq	.+20     	; 0x4a64 <xTaskGenericNotifyFromISR+0x10c>
    4a50:	81 e0       	ldi	r24, 0x01	; 1
    4a52:	f7 01       	movw	r30, r14
    4a54:	80 83       	st	Z, r24
    4a56:	07 c0       	rjmp	.+14     	; 0x4a66 <xTaskGenericNotifyFromISR+0x10e>
    4a58:	80 e0       	ldi	r24, 0x00	; 0
    4a5a:	05 c0       	rjmp	.+10     	; 0x4a66 <xTaskGenericNotifyFromISR+0x10e>
    4a5c:	81 e0       	ldi	r24, 0x01	; 1
    4a5e:	03 c0       	rjmp	.+6      	; 0x4a66 <xTaskGenericNotifyFromISR+0x10e>
    4a60:	81 e0       	ldi	r24, 0x01	; 1
    4a62:	01 c0       	rjmp	.+2      	; 0x4a66 <xTaskGenericNotifyFromISR+0x10e>
    4a64:	81 e0       	ldi	r24, 0x01	; 1
    4a66:	df 91       	pop	r29
    4a68:	cf 91       	pop	r28
    4a6a:	1f 91       	pop	r17
    4a6c:	0f 91       	pop	r16
    4a6e:	ff 90       	pop	r15
    4a70:	ef 90       	pop	r14
    4a72:	08 95       	ret

00004a74 <xTaskNotifyStateClear>:

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    4a74:	00 97       	sbiw	r24, 0x00	; 0
    4a76:	21 f4       	brne	.+8      	; 0x4a80 <xTaskNotifyStateClear+0xc>
    4a78:	80 91 81 16 	lds	r24, 0x1681	; 0x801681 <pxCurrentTCB>
    4a7c:	90 91 82 16 	lds	r25, 0x1682	; 0x801682 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    4a80:	0f b6       	in	r0, 0x3f	; 63
    4a82:	f8 94       	cli
    4a84:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    4a86:	fc 01       	movw	r30, r24
    4a88:	27 a1       	ldd	r18, Z+39	; 0x27
    4a8a:	22 30       	cpi	r18, 0x02	; 2
    4a8c:	19 f4       	brne	.+6      	; 0x4a94 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    4a8e:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    4a90:	81 e0       	ldi	r24, 0x01	; 1
    4a92:	01 c0       	rjmp	.+2      	; 0x4a96 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    4a94:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    4a96:	0f 90       	pop	r0
    4a98:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    4a9a:	08 95       	ret

00004a9c <vFrameReaderTask>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
}

void vFrameReaderTask( void *pvParameters ){
    4a9c:	cf 93       	push	r28
    4a9e:	df 93       	push	r29
    4aa0:	00 d0       	rcall	.+0      	; 0x4aa2 <vFrameReaderTask+0x6>
    4aa2:	1f 92       	push	r1
    4aa4:	cd b7       	in	r28, 0x3d	; 61
    4aa6:	de b7       	in	r29, 0x3e	; 62
	frame_receiver = xTaskGetCurrentTaskHandle();
    4aa8:	aa dc       	rcall	.-1708   	; 0x43fe <xTaskGetCurrentTaskHandle>
    4aaa:	90 93 ea 16 	sts	0x16EA, r25	; 0x8016ea <frame_receiver+0x1>
    4aae:	80 93 e9 16 	sts	0x16E9, r24	; 0x8016e9 <frame_receiver>
	uint32_t notification_value = 0;
    4ab2:	19 82       	std	Y+1, r1	; 0x01
    4ab4:	1a 82       	std	Y+2, r1	; 0x02
    4ab6:	1b 82       	std	Y+3, r1	; 0x03
    4ab8:	1c 82       	std	Y+4, r1	; 0x04
	while(1){
		xTaskNotifyWait(0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);
    4aba:	ee 24       	eor	r14, r14
    4abc:	ea 94       	dec	r14
    4abe:	fe 2c       	mov	r15, r14
    4ac0:	8e 01       	movw	r16, r28
    4ac2:	0f 5f       	subi	r16, 0xFF	; 255
    4ac4:	1f 4f       	sbci	r17, 0xFF	; 255
    4ac6:	2f ef       	ldi	r18, 0xFF	; 255
    4ac8:	3f ef       	ldi	r19, 0xFF	; 255
    4aca:	a9 01       	movw	r20, r18
    4acc:	6f ef       	ldi	r22, 0xFF	; 255
    4ace:	7f ef       	ldi	r23, 0xFF	; 255
    4ad0:	cb 01       	movw	r24, r22
    4ad2:	f5 dd       	rcall	.-1046   	; 0x46be <xTaskNotifyWait>
		if(receive_callback != NULL) receive_callback(receive_buffer, (uint16_t)notification_value);
    4ad4:	e0 91 4e 17 	lds	r30, 0x174E	; 0x80174e <receive_callback>
    4ad8:	f0 91 4f 17 	lds	r31, 0x174F	; 0x80174f <receive_callback+0x1>
    4adc:	30 97       	sbiw	r30, 0x00	; 0
    4ade:	69 f3       	breq	.-38     	; 0x4aba <vFrameReaderTask+0x1e>
    4ae0:	69 81       	ldd	r22, Y+1	; 0x01
    4ae2:	7a 81       	ldd	r23, Y+2	; 0x02
    4ae4:	80 e5       	ldi	r24, 0x50	; 80
    4ae6:	97 e1       	ldi	r25, 0x17	; 23
    4ae8:	19 95       	eicall
    4aea:	e7 cf       	rjmp	.-50     	; 0x4aba <vFrameReaderTask+0x1e>

00004aec <vUartSendTask>:
	}
}

void vUartSendTask(void *pvParamters) {
    4aec:	cf 93       	push	r28
    4aee:	df 93       	push	r29
    4af0:	cd b7       	in	r28, 0x3d	; 61
    4af2:	de b7       	in	r29, 0x3e	; 62
    4af4:	c4 56       	subi	r28, 0x64	; 100
    4af6:	d1 09       	sbc	r29, r1
    4af8:	0f b6       	in	r0, 0x3f	; 63
    4afa:	f8 94       	cli
    4afc:	de bf       	out	0x3e, r29	; 62
    4afe:	0f be       	out	0x3f, r0	; 63
    4b00:	cd bf       	out	0x3d, r28	; 61
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    4b02:	00 ed       	ldi	r16, 0xD0	; 208
    4b04:	10 e0       	ldi	r17, 0x00	; 0
				UDR2 = data[i];
    4b06:	0f 2e       	mov	r0, r31
    4b08:	f6 ed       	ldi	r31, 0xD6	; 214
    4b0a:	ef 2e       	mov	r14, r31
    4b0c:	f1 2c       	mov	r15, r1
    4b0e:	f0 2d       	mov	r31, r0
void vUartSendTask(void *pvParamters) {
	uint8_t data[100];
	uint16_t num;
	uint16_t i;
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
    4b10:	20 e0       	ldi	r18, 0x00	; 0
    4b12:	4f ef       	ldi	r20, 0xFF	; 255
    4b14:	5f ef       	ldi	r21, 0xFF	; 255
    4b16:	60 e0       	ldi	r22, 0x00	; 0
    4b18:	70 e0       	ldi	r23, 0x00	; 0
    4b1a:	80 91 0f 17 	lds	r24, 0x170F	; 0x80170f <xUartMutex>
    4b1e:	90 91 10 17 	lds	r25, 0x1710	; 0x801710 <xUartMutex+0x1>
    4b22:	0e 94 99 15 	call	0x2b32	; 0x2b32 <xQueueGenericReceive>
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
    4b26:	24 e6       	ldi	r18, 0x64	; 100
    4b28:	30 e0       	ldi	r19, 0x00	; 0
    4b2a:	40 e0       	ldi	r20, 0x00	; 0
    4b2c:	be 01       	movw	r22, r28
    4b2e:	6f 5f       	subi	r22, 0xFF	; 255
    4b30:	7f 4f       	sbci	r23, 0xFF	; 255
    4b32:	84 eb       	ldi	r24, 0xB4	; 180
    4b34:	97 e1       	ldi	r25, 0x17	; 23
    4b36:	0e 94 7c 05 	call	0xaf8	; 0xaf8 <buffer_remove_token>
    4b3a:	6c 01       	movw	r12, r24
		xSemaphoreGive(xUartMutex);
    4b3c:	60 e0       	ldi	r22, 0x00	; 0
    4b3e:	70 e0       	ldi	r23, 0x00	; 0
    4b40:	80 91 0f 17 	lds	r24, 0x170F	; 0x80170f <xUartMutex>
    4b44:	90 91 10 17 	lds	r25, 0x1710	; 0x801710 <xUartMutex+0x1>
    4b48:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
		if(num>0) {
    4b4c:	c1 14       	cp	r12, r1
    4b4e:	d1 04       	cpc	r13, r1
    4b50:	79 f0       	breq	.+30     	; 0x4b70 <vUartSendTask+0x84>
    4b52:	fe 01       	movw	r30, r28
    4b54:	31 96       	adiw	r30, 0x01	; 1
    4b56:	9f 01       	movw	r18, r30
    4b58:	2c 0d       	add	r18, r12
    4b5a:	3d 1d       	adc	r19, r13
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    4b5c:	d8 01       	movw	r26, r16
    4b5e:	8c 91       	ld	r24, X
    4b60:	85 ff       	sbrs	r24, 5
    4b62:	fc cf       	rjmp	.-8      	; 0x4b5c <vUartSendTask+0x70>
				UDR2 = data[i];
    4b64:	81 91       	ld	r24, Z+
    4b66:	d7 01       	movw	r26, r14
    4b68:	8c 93       	st	X, r24
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
    4b6a:	2e 17       	cp	r18, r30
    4b6c:	3f 07       	cpc	r19, r31
    4b6e:	b1 f7       	brne	.-20     	; 0x4b5c <vUartSendTask+0x70>
				while ( !( UCSR2A & (1<<UDRE2)) );
				UDR2 = data[i];
			}
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
    4b70:	8a e0       	ldi	r24, 0x0A	; 10
    4b72:	90 e0       	ldi	r25, 0x00	; 0
    4b74:	0e 94 15 1c 	call	0x382a	; 0x382a <vTaskDelay>
	}
    4b78:	cb cf       	rjmp	.-106    	; 0x4b10 <vUartSendTask+0x24>

00004b7a <vUSART_init>:
/************************************************************************/
//Initialize USART driver, note that RXD0/TXD0 (PD0/PD1) is used
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    4b7a:	af 92       	push	r10
    4b7c:	bf 92       	push	r11
    4b7e:	cf 92       	push	r12
    4b80:	df 92       	push	r13
    4b82:	ef 92       	push	r14
    4b84:	ff 92       	push	r15
    4b86:	0f 93       	push	r16
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    4b88:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    4b8c:	89 e1       	ldi	r24, 0x19	; 25
    4b8e:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    4b92:	80 ee       	ldi	r24, 0xE0	; 224
    4b94:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    4b98:	88 e9       	ldi	r24, 0x98	; 152
    4b9a:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    4b9e:	e2 ed       	ldi	r30, 0xD2	; 210
    4ba0:	f0 e0       	ldi	r31, 0x00	; 0
    4ba2:	86 e0       	ldi	r24, 0x06	; 6
    4ba4:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    4ba6:	80 81       	ld	r24, Z
    4ba8:	80 83       	st	Z, r24

	uint8_t *buf = pvPortMalloc(100);
    4baa:	84 e6       	ldi	r24, 0x64	; 100
    4bac:	90 e0       	ldi	r25, 0x00	; 0
    4bae:	0e 94 de 07 	call	0xfbc	; 0xfbc <pvPortMalloc>
	buffer_init(&send_buffer, buf, 100);
    4bb2:	44 e6       	ldi	r20, 0x64	; 100
    4bb4:	50 e0       	ldi	r21, 0x00	; 0
    4bb6:	bc 01       	movw	r22, r24
    4bb8:	84 eb       	ldi	r24, 0xB4	; 180
    4bba:	97 e1       	ldi	r25, 0x17	; 23
    4bbc:	0e 94 06 05 	call	0xa0c	; 0xa0c <buffer_init>
	xTaskCreate(vFrameReaderTask, "FrameReader", 300, NULL, 4, NULL);
    4bc0:	a1 2c       	mov	r10, r1
    4bc2:	b1 2c       	mov	r11, r1
    4bc4:	c1 2c       	mov	r12, r1
    4bc6:	d1 2c       	mov	r13, r1
    4bc8:	e1 2c       	mov	r14, r1
    4bca:	f1 2c       	mov	r15, r1
    4bcc:	04 e0       	ldi	r16, 0x04	; 4
    4bce:	20 e0       	ldi	r18, 0x00	; 0
    4bd0:	30 e0       	ldi	r19, 0x00	; 0
    4bd2:	4c e2       	ldi	r20, 0x2C	; 44
    4bd4:	51 e0       	ldi	r21, 0x01	; 1
    4bd6:	6a ee       	ldi	r22, 0xEA	; 234
    4bd8:	72 e0       	ldi	r23, 0x02	; 2
    4bda:	8e e4       	ldi	r24, 0x4E	; 78
    4bdc:	95 e2       	ldi	r25, 0x25	; 37
    4bde:	0e 94 5e 19 	call	0x32bc	; 0x32bc <xTaskGenericCreate>
	xTaskCreate(vUartSendTask, "UartSendTask", 300, NULL, 4, NULL);
    4be2:	20 e0       	ldi	r18, 0x00	; 0
    4be4:	30 e0       	ldi	r19, 0x00	; 0
    4be6:	4c e2       	ldi	r20, 0x2C	; 44
    4be8:	51 e0       	ldi	r21, 0x01	; 1
    4bea:	66 ef       	ldi	r22, 0xF6	; 246
    4bec:	72 e0       	ldi	r23, 0x02	; 2
    4bee:	86 e7       	ldi	r24, 0x76	; 118
    4bf0:	95 e2       	ldi	r25, 0x25	; 37
    4bf2:	0e 94 5e 19 	call	0x32bc	; 0x32bc <xTaskGenericCreate>
	
	xUartMutex = xSemaphoreCreateMutex();
    4bf6:	81 e0       	ldi	r24, 0x01	; 1
    4bf8:	0e 94 ad 10 	call	0x215a	; 0x215a <xQueueCreateMutex>
    4bfc:	90 93 10 17 	sts	0x1710, r25	; 0x801710 <xUartMutex+0x1>
    4c00:	80 93 0f 17 	sts	0x170F, r24	; 0x80170f <xUartMutex>
}
    4c04:	0f 91       	pop	r16
    4c06:	ff 90       	pop	r15
    4c08:	ef 90       	pop	r14
    4c0a:	df 90       	pop	r13
    4c0c:	cf 90       	pop	r12
    4c0e:	bf 90       	pop	r11
    4c10:	af 90       	pop	r10
    4c12:	08 95       	ret

00004c14 <vUSART_send>:

void vUSART_send(uint8_t *data, uint16_t len) {
    4c14:	0f 93       	push	r16
    4c16:	1f 93       	push	r17
    4c18:	cf 93       	push	r28
    4c1a:	df 93       	push	r29
    4c1c:	ec 01       	movw	r28, r24
    4c1e:	8b 01       	movw	r16, r22
	xSemaphoreTake(xUartMutex, portMAX_DELAY);
    4c20:	20 e0       	ldi	r18, 0x00	; 0
    4c22:	4f ef       	ldi	r20, 0xFF	; 255
    4c24:	5f ef       	ldi	r21, 0xFF	; 255
    4c26:	60 e0       	ldi	r22, 0x00	; 0
    4c28:	70 e0       	ldi	r23, 0x00	; 0
    4c2a:	80 91 0f 17 	lds	r24, 0x170F	; 0x80170f <xUartMutex>
    4c2e:	90 91 10 17 	lds	r25, 0x1710	; 0x801710 <xUartMutex+0x1>
    4c32:	0e 94 99 15 	call	0x2b32	; 0x2b32 <xQueueGenericReceive>
	buffer_append(&send_buffer, data, len);
    4c36:	a8 01       	movw	r20, r16
    4c38:	be 01       	movw	r22, r28
    4c3a:	84 eb       	ldi	r24, 0xB4	; 180
    4c3c:	97 e1       	ldi	r25, 0x17	; 23
    4c3e:	0e 94 18 05 	call	0xa30	; 0xa30 <buffer_append>
	xSemaphoreGive(xUartMutex);
    4c42:	60 e0       	ldi	r22, 0x00	; 0
    4c44:	70 e0       	ldi	r23, 0x00	; 0
    4c46:	80 91 0f 17 	lds	r24, 0x170F	; 0x80170f <xUartMutex>
    4c4a:	90 91 10 17 	lds	r25, 0x1710	; 0x801710 <xUartMutex+0x1>
    4c4e:	0e 94 fd 13 	call	0x27fa	; 0x27fa <xQueueGive>
}
    4c52:	df 91       	pop	r29
    4c54:	cf 91       	pop	r28
    4c56:	1f 91       	pop	r17
    4c58:	0f 91       	pop	r16
    4c5a:	08 95       	ret

00004c5c <vUSART_set_receive_callback>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
    4c5c:	90 93 4f 17 	sts	0x174F, r25	; 0x80174f <receive_callback+0x1>
    4c60:	80 93 4e 17 	sts	0x174E, r24	; 0x80174e <receive_callback>
    4c64:	08 95       	ret

00004c66 <__vector_51>:
		vTaskDelay(10*portTICK_PERIOD_MS);
	}
}


ISR(USART2_RX_vect){
    4c66:	1f 92       	push	r1
    4c68:	0f 92       	push	r0
    4c6a:	0f b6       	in	r0, 0x3f	; 63
    4c6c:	0f 92       	push	r0
    4c6e:	11 24       	eor	r1, r1
    4c70:	0b b6       	in	r0, 0x3b	; 59
    4c72:	0f 92       	push	r0
    4c74:	cf 92       	push	r12
    4c76:	df 92       	push	r13
    4c78:	ef 92       	push	r14
    4c7a:	ff 92       	push	r15
    4c7c:	0f 93       	push	r16
    4c7e:	1f 93       	push	r17
    4c80:	2f 93       	push	r18
    4c82:	3f 93       	push	r19
    4c84:	4f 93       	push	r20
    4c86:	5f 93       	push	r21
    4c88:	6f 93       	push	r22
    4c8a:	7f 93       	push	r23
    4c8c:	8f 93       	push	r24
    4c8e:	9f 93       	push	r25
    4c90:	af 93       	push	r26
    4c92:	bf 93       	push	r27
    4c94:	cf 93       	push	r28
    4c96:	df 93       	push	r29
    4c98:	ef 93       	push	r30
    4c9a:	ff 93       	push	r31
	static uint8_t input_buffer[100];
	static uint16_t input_index = 0;
	input_buffer[input_index++] = UDR2;
    4c9c:	80 91 e7 16 	lds	r24, 0x16E7	; 0x8016e7 <input_index.2398>
    4ca0:	90 91 e8 16 	lds	r25, 0x16E8	; 0x8016e8 <input_index.2398+0x1>
    4ca4:	ec 01       	movw	r28, r24
    4ca6:	21 96       	adiw	r28, 0x01	; 1
    4ca8:	d0 93 e8 16 	sts	0x16E8, r29	; 0x8016e8 <input_index.2398+0x1>
    4cac:	c0 93 e7 16 	sts	0x16E7, r28	; 0x8016e7 <input_index.2398>
    4cb0:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    4cb4:	fc 01       	movw	r30, r24
    4cb6:	ed 57       	subi	r30, 0x7D	; 125
    4cb8:	f9 4e       	sbci	r31, 0xE9	; 233
    4cba:	20 83       	st	Z, r18
	if(input_buffer[input_index-1] == 0x00) {
    4cbc:	21 11       	cpse	r18, r1
    4cbe:	1c c0       	rjmp	.+56     	; 0x4cf8 <__vector_51+0x92>
		if(frame_receiver != NULL) {
    4cc0:	c0 90 e9 16 	lds	r12, 0x16E9	; 0x8016e9 <frame_receiver>
    4cc4:	d0 90 ea 16 	lds	r13, 0x16EA	; 0x8016ea <frame_receiver+0x1>
    4cc8:	c1 14       	cp	r12, r1
    4cca:	d1 04       	cpc	r13, r1
    4ccc:	81 f0       	breq	.+32     	; 0x4cee <__vector_51+0x88>
			memcpy(receive_buffer, input_buffer, input_index);
    4cce:	ae 01       	movw	r20, r28
    4cd0:	63 e8       	ldi	r22, 0x83	; 131
    4cd2:	76 e1       	ldi	r23, 0x16	; 22
    4cd4:	80 e5       	ldi	r24, 0x50	; 80
    4cd6:	97 e1       	ldi	r25, 0x17	; 23
    4cd8:	2e d6       	rcall	.+3164   	; 0x5936 <memcpy>
			xTaskNotifyFromISR(frame_receiver, input_index, eSetValueWithoutOverwrite, NULL);
    4cda:	ae 01       	movw	r20, r28
    4cdc:	60 e0       	ldi	r22, 0x00	; 0
    4cde:	70 e0       	ldi	r23, 0x00	; 0
    4ce0:	e1 2c       	mov	r14, r1
    4ce2:	f1 2c       	mov	r15, r1
    4ce4:	00 e0       	ldi	r16, 0x00	; 0
    4ce6:	10 e0       	ldi	r17, 0x00	; 0
    4ce8:	24 e0       	ldi	r18, 0x04	; 4
    4cea:	c6 01       	movw	r24, r12
    4cec:	35 de       	rcall	.-918    	; 0x4958 <xTaskGenericNotifyFromISR>
		}
		input_index = 0;
    4cee:	10 92 e8 16 	sts	0x16E8, r1	; 0x8016e8 <input_index.2398+0x1>
    4cf2:	10 92 e7 16 	sts	0x16E7, r1	; 0x8016e7 <input_index.2398>
    4cf6:	07 c0       	rjmp	.+14     	; 0x4d06 <__vector_51+0xa0>
	}
	if(input_index > 100) input_index = 0; // Something went wrong, received too many bytes
    4cf8:	c5 36       	cpi	r28, 0x65	; 101
    4cfa:	d1 05       	cpc	r29, r1
    4cfc:	20 f0       	brcs	.+8      	; 0x4d06 <__vector_51+0xa0>
    4cfe:	10 92 e8 16 	sts	0x16E8, r1	; 0x8016e8 <input_index.2398+0x1>
    4d02:	10 92 e7 16 	sts	0x16E7, r1	; 0x8016e7 <input_index.2398>
    4d06:	ff 91       	pop	r31
    4d08:	ef 91       	pop	r30
    4d0a:	df 91       	pop	r29
    4d0c:	cf 91       	pop	r28
    4d0e:	bf 91       	pop	r27
    4d10:	af 91       	pop	r26
    4d12:	9f 91       	pop	r25
    4d14:	8f 91       	pop	r24
    4d16:	7f 91       	pop	r23
    4d18:	6f 91       	pop	r22
    4d1a:	5f 91       	pop	r21
    4d1c:	4f 91       	pop	r20
    4d1e:	3f 91       	pop	r19
    4d20:	2f 91       	pop	r18
    4d22:	1f 91       	pop	r17
    4d24:	0f 91       	pop	r16
    4d26:	ff 90       	pop	r15
    4d28:	ef 90       	pop	r14
    4d2a:	df 90       	pop	r13
    4d2c:	cf 90       	pop	r12
    4d2e:	0f 90       	pop	r0
    4d30:	0b be       	out	0x3b, r0	; 59
    4d32:	0f 90       	pop	r0
    4d34:	0f be       	out	0x3f, r0	; 63
    4d36:	0f 90       	pop	r0
    4d38:	1f 90       	pop	r1
    4d3a:	18 95       	reti

00004d3c <__subsf3>:
    4d3c:	50 58       	subi	r21, 0x80	; 128

00004d3e <__addsf3>:
    4d3e:	bb 27       	eor	r27, r27
    4d40:	aa 27       	eor	r26, r26
    4d42:	0e d0       	rcall	.+28     	; 0x4d60 <__addsf3x>
    4d44:	dc c0       	rjmp	.+440    	; 0x4efe <__fp_round>
    4d46:	cd d0       	rcall	.+410    	; 0x4ee2 <__fp_pscA>
    4d48:	30 f0       	brcs	.+12     	; 0x4d56 <__addsf3+0x18>
    4d4a:	d2 d0       	rcall	.+420    	; 0x4ef0 <__fp_pscB>
    4d4c:	20 f0       	brcs	.+8      	; 0x4d56 <__addsf3+0x18>
    4d4e:	31 f4       	brne	.+12     	; 0x4d5c <__addsf3+0x1e>
    4d50:	9f 3f       	cpi	r25, 0xFF	; 255
    4d52:	11 f4       	brne	.+4      	; 0x4d58 <__addsf3+0x1a>
    4d54:	1e f4       	brtc	.+6      	; 0x4d5c <__addsf3+0x1e>
    4d56:	c2 c0       	rjmp	.+388    	; 0x4edc <__fp_nan>
    4d58:	0e f4       	brtc	.+2      	; 0x4d5c <__addsf3+0x1e>
    4d5a:	e0 95       	com	r30
    4d5c:	e7 fb       	bst	r30, 7
    4d5e:	b8 c0       	rjmp	.+368    	; 0x4ed0 <__fp_inf>

00004d60 <__addsf3x>:
    4d60:	e9 2f       	mov	r30, r25
    4d62:	de d0       	rcall	.+444    	; 0x4f20 <__fp_split3>
    4d64:	80 f3       	brcs	.-32     	; 0x4d46 <__addsf3+0x8>
    4d66:	ba 17       	cp	r27, r26
    4d68:	62 07       	cpc	r22, r18
    4d6a:	73 07       	cpc	r23, r19
    4d6c:	84 07       	cpc	r24, r20
    4d6e:	95 07       	cpc	r25, r21
    4d70:	18 f0       	brcs	.+6      	; 0x4d78 <__addsf3x+0x18>
    4d72:	71 f4       	brne	.+28     	; 0x4d90 <__addsf3x+0x30>
    4d74:	9e f5       	brtc	.+102    	; 0x4ddc <__addsf3x+0x7c>
    4d76:	f6 c0       	rjmp	.+492    	; 0x4f64 <__fp_zero>
    4d78:	0e f4       	brtc	.+2      	; 0x4d7c <__addsf3x+0x1c>
    4d7a:	e0 95       	com	r30
    4d7c:	0b 2e       	mov	r0, r27
    4d7e:	ba 2f       	mov	r27, r26
    4d80:	a0 2d       	mov	r26, r0
    4d82:	0b 01       	movw	r0, r22
    4d84:	b9 01       	movw	r22, r18
    4d86:	90 01       	movw	r18, r0
    4d88:	0c 01       	movw	r0, r24
    4d8a:	ca 01       	movw	r24, r20
    4d8c:	a0 01       	movw	r20, r0
    4d8e:	11 24       	eor	r1, r1
    4d90:	ff 27       	eor	r31, r31
    4d92:	59 1b       	sub	r21, r25
    4d94:	99 f0       	breq	.+38     	; 0x4dbc <__addsf3x+0x5c>
    4d96:	59 3f       	cpi	r21, 0xF9	; 249
    4d98:	50 f4       	brcc	.+20     	; 0x4dae <__addsf3x+0x4e>
    4d9a:	50 3e       	cpi	r21, 0xE0	; 224
    4d9c:	68 f1       	brcs	.+90     	; 0x4df8 <__addsf3x+0x98>
    4d9e:	1a 16       	cp	r1, r26
    4da0:	f0 40       	sbci	r31, 0x00	; 0
    4da2:	a2 2f       	mov	r26, r18
    4da4:	23 2f       	mov	r18, r19
    4da6:	34 2f       	mov	r19, r20
    4da8:	44 27       	eor	r20, r20
    4daa:	58 5f       	subi	r21, 0xF8	; 248
    4dac:	f3 cf       	rjmp	.-26     	; 0x4d94 <__addsf3x+0x34>
    4dae:	46 95       	lsr	r20
    4db0:	37 95       	ror	r19
    4db2:	27 95       	ror	r18
    4db4:	a7 95       	ror	r26
    4db6:	f0 40       	sbci	r31, 0x00	; 0
    4db8:	53 95       	inc	r21
    4dba:	c9 f7       	brne	.-14     	; 0x4dae <__addsf3x+0x4e>
    4dbc:	7e f4       	brtc	.+30     	; 0x4ddc <__addsf3x+0x7c>
    4dbe:	1f 16       	cp	r1, r31
    4dc0:	ba 0b       	sbc	r27, r26
    4dc2:	62 0b       	sbc	r22, r18
    4dc4:	73 0b       	sbc	r23, r19
    4dc6:	84 0b       	sbc	r24, r20
    4dc8:	ba f0       	brmi	.+46     	; 0x4df8 <__addsf3x+0x98>
    4dca:	91 50       	subi	r25, 0x01	; 1
    4dcc:	a1 f0       	breq	.+40     	; 0x4df6 <__addsf3x+0x96>
    4dce:	ff 0f       	add	r31, r31
    4dd0:	bb 1f       	adc	r27, r27
    4dd2:	66 1f       	adc	r22, r22
    4dd4:	77 1f       	adc	r23, r23
    4dd6:	88 1f       	adc	r24, r24
    4dd8:	c2 f7       	brpl	.-16     	; 0x4dca <__addsf3x+0x6a>
    4dda:	0e c0       	rjmp	.+28     	; 0x4df8 <__addsf3x+0x98>
    4ddc:	ba 0f       	add	r27, r26
    4dde:	62 1f       	adc	r22, r18
    4de0:	73 1f       	adc	r23, r19
    4de2:	84 1f       	adc	r24, r20
    4de4:	48 f4       	brcc	.+18     	; 0x4df8 <__addsf3x+0x98>
    4de6:	87 95       	ror	r24
    4de8:	77 95       	ror	r23
    4dea:	67 95       	ror	r22
    4dec:	b7 95       	ror	r27
    4dee:	f7 95       	ror	r31
    4df0:	9e 3f       	cpi	r25, 0xFE	; 254
    4df2:	08 f0       	brcs	.+2      	; 0x4df6 <__addsf3x+0x96>
    4df4:	b3 cf       	rjmp	.-154    	; 0x4d5c <__addsf3+0x1e>
    4df6:	93 95       	inc	r25
    4df8:	88 0f       	add	r24, r24
    4dfa:	08 f0       	brcs	.+2      	; 0x4dfe <__addsf3x+0x9e>
    4dfc:	99 27       	eor	r25, r25
    4dfe:	ee 0f       	add	r30, r30
    4e00:	97 95       	ror	r25
    4e02:	87 95       	ror	r24
    4e04:	08 95       	ret

00004e06 <__cmpsf2>:
    4e06:	40 d0       	rcall	.+128    	; 0x4e88 <__fp_cmp>
    4e08:	08 f4       	brcc	.+2      	; 0x4e0c <__cmpsf2+0x6>
    4e0a:	81 e0       	ldi	r24, 0x01	; 1
    4e0c:	08 95       	ret

00004e0e <__floatunsisf>:
    4e0e:	e8 94       	clt
    4e10:	09 c0       	rjmp	.+18     	; 0x4e24 <__floatsisf+0x12>

00004e12 <__floatsisf>:
    4e12:	97 fb       	bst	r25, 7
    4e14:	3e f4       	brtc	.+14     	; 0x4e24 <__floatsisf+0x12>
    4e16:	90 95       	com	r25
    4e18:	80 95       	com	r24
    4e1a:	70 95       	com	r23
    4e1c:	61 95       	neg	r22
    4e1e:	7f 4f       	sbci	r23, 0xFF	; 255
    4e20:	8f 4f       	sbci	r24, 0xFF	; 255
    4e22:	9f 4f       	sbci	r25, 0xFF	; 255
    4e24:	99 23       	and	r25, r25
    4e26:	a9 f0       	breq	.+42     	; 0x4e52 <__floatsisf+0x40>
    4e28:	f9 2f       	mov	r31, r25
    4e2a:	96 e9       	ldi	r25, 0x96	; 150
    4e2c:	bb 27       	eor	r27, r27
    4e2e:	93 95       	inc	r25
    4e30:	f6 95       	lsr	r31
    4e32:	87 95       	ror	r24
    4e34:	77 95       	ror	r23
    4e36:	67 95       	ror	r22
    4e38:	b7 95       	ror	r27
    4e3a:	f1 11       	cpse	r31, r1
    4e3c:	f8 cf       	rjmp	.-16     	; 0x4e2e <__floatsisf+0x1c>
    4e3e:	fa f4       	brpl	.+62     	; 0x4e7e <__floatsisf+0x6c>
    4e40:	bb 0f       	add	r27, r27
    4e42:	11 f4       	brne	.+4      	; 0x4e48 <__floatsisf+0x36>
    4e44:	60 ff       	sbrs	r22, 0
    4e46:	1b c0       	rjmp	.+54     	; 0x4e7e <__floatsisf+0x6c>
    4e48:	6f 5f       	subi	r22, 0xFF	; 255
    4e4a:	7f 4f       	sbci	r23, 0xFF	; 255
    4e4c:	8f 4f       	sbci	r24, 0xFF	; 255
    4e4e:	9f 4f       	sbci	r25, 0xFF	; 255
    4e50:	16 c0       	rjmp	.+44     	; 0x4e7e <__floatsisf+0x6c>
    4e52:	88 23       	and	r24, r24
    4e54:	11 f0       	breq	.+4      	; 0x4e5a <__floatsisf+0x48>
    4e56:	96 e9       	ldi	r25, 0x96	; 150
    4e58:	11 c0       	rjmp	.+34     	; 0x4e7c <__floatsisf+0x6a>
    4e5a:	77 23       	and	r23, r23
    4e5c:	21 f0       	breq	.+8      	; 0x4e66 <__floatsisf+0x54>
    4e5e:	9e e8       	ldi	r25, 0x8E	; 142
    4e60:	87 2f       	mov	r24, r23
    4e62:	76 2f       	mov	r23, r22
    4e64:	05 c0       	rjmp	.+10     	; 0x4e70 <__floatsisf+0x5e>
    4e66:	66 23       	and	r22, r22
    4e68:	71 f0       	breq	.+28     	; 0x4e86 <__floatsisf+0x74>
    4e6a:	96 e8       	ldi	r25, 0x86	; 134
    4e6c:	86 2f       	mov	r24, r22
    4e6e:	70 e0       	ldi	r23, 0x00	; 0
    4e70:	60 e0       	ldi	r22, 0x00	; 0
    4e72:	2a f0       	brmi	.+10     	; 0x4e7e <__floatsisf+0x6c>
    4e74:	9a 95       	dec	r25
    4e76:	66 0f       	add	r22, r22
    4e78:	77 1f       	adc	r23, r23
    4e7a:	88 1f       	adc	r24, r24
    4e7c:	da f7       	brpl	.-10     	; 0x4e74 <__floatsisf+0x62>
    4e7e:	88 0f       	add	r24, r24
    4e80:	96 95       	lsr	r25
    4e82:	87 95       	ror	r24
    4e84:	97 f9       	bld	r25, 7
    4e86:	08 95       	ret

00004e88 <__fp_cmp>:
    4e88:	99 0f       	add	r25, r25
    4e8a:	00 08       	sbc	r0, r0
    4e8c:	55 0f       	add	r21, r21
    4e8e:	aa 0b       	sbc	r26, r26
    4e90:	e0 e8       	ldi	r30, 0x80	; 128
    4e92:	fe ef       	ldi	r31, 0xFE	; 254
    4e94:	16 16       	cp	r1, r22
    4e96:	17 06       	cpc	r1, r23
    4e98:	e8 07       	cpc	r30, r24
    4e9a:	f9 07       	cpc	r31, r25
    4e9c:	c0 f0       	brcs	.+48     	; 0x4ece <__fp_cmp+0x46>
    4e9e:	12 16       	cp	r1, r18
    4ea0:	13 06       	cpc	r1, r19
    4ea2:	e4 07       	cpc	r30, r20
    4ea4:	f5 07       	cpc	r31, r21
    4ea6:	98 f0       	brcs	.+38     	; 0x4ece <__fp_cmp+0x46>
    4ea8:	62 1b       	sub	r22, r18
    4eaa:	73 0b       	sbc	r23, r19
    4eac:	84 0b       	sbc	r24, r20
    4eae:	95 0b       	sbc	r25, r21
    4eb0:	39 f4       	brne	.+14     	; 0x4ec0 <__fp_cmp+0x38>
    4eb2:	0a 26       	eor	r0, r26
    4eb4:	61 f0       	breq	.+24     	; 0x4ece <__fp_cmp+0x46>
    4eb6:	23 2b       	or	r18, r19
    4eb8:	24 2b       	or	r18, r20
    4eba:	25 2b       	or	r18, r21
    4ebc:	21 f4       	brne	.+8      	; 0x4ec6 <__fp_cmp+0x3e>
    4ebe:	08 95       	ret
    4ec0:	0a 26       	eor	r0, r26
    4ec2:	09 f4       	brne	.+2      	; 0x4ec6 <__fp_cmp+0x3e>
    4ec4:	a1 40       	sbci	r26, 0x01	; 1
    4ec6:	a6 95       	lsr	r26
    4ec8:	8f ef       	ldi	r24, 0xFF	; 255
    4eca:	81 1d       	adc	r24, r1
    4ecc:	81 1d       	adc	r24, r1
    4ece:	08 95       	ret

00004ed0 <__fp_inf>:
    4ed0:	97 f9       	bld	r25, 7
    4ed2:	9f 67       	ori	r25, 0x7F	; 127
    4ed4:	80 e8       	ldi	r24, 0x80	; 128
    4ed6:	70 e0       	ldi	r23, 0x00	; 0
    4ed8:	60 e0       	ldi	r22, 0x00	; 0
    4eda:	08 95       	ret

00004edc <__fp_nan>:
    4edc:	9f ef       	ldi	r25, 0xFF	; 255
    4ede:	80 ec       	ldi	r24, 0xC0	; 192
    4ee0:	08 95       	ret

00004ee2 <__fp_pscA>:
    4ee2:	00 24       	eor	r0, r0
    4ee4:	0a 94       	dec	r0
    4ee6:	16 16       	cp	r1, r22
    4ee8:	17 06       	cpc	r1, r23
    4eea:	18 06       	cpc	r1, r24
    4eec:	09 06       	cpc	r0, r25
    4eee:	08 95       	ret

00004ef0 <__fp_pscB>:
    4ef0:	00 24       	eor	r0, r0
    4ef2:	0a 94       	dec	r0
    4ef4:	12 16       	cp	r1, r18
    4ef6:	13 06       	cpc	r1, r19
    4ef8:	14 06       	cpc	r1, r20
    4efa:	05 06       	cpc	r0, r21
    4efc:	08 95       	ret

00004efe <__fp_round>:
    4efe:	09 2e       	mov	r0, r25
    4f00:	03 94       	inc	r0
    4f02:	00 0c       	add	r0, r0
    4f04:	11 f4       	brne	.+4      	; 0x4f0a <__fp_round+0xc>
    4f06:	88 23       	and	r24, r24
    4f08:	52 f0       	brmi	.+20     	; 0x4f1e <__fp_round+0x20>
    4f0a:	bb 0f       	add	r27, r27
    4f0c:	40 f4       	brcc	.+16     	; 0x4f1e <__fp_round+0x20>
    4f0e:	bf 2b       	or	r27, r31
    4f10:	11 f4       	brne	.+4      	; 0x4f16 <__fp_round+0x18>
    4f12:	60 ff       	sbrs	r22, 0
    4f14:	04 c0       	rjmp	.+8      	; 0x4f1e <__fp_round+0x20>
    4f16:	6f 5f       	subi	r22, 0xFF	; 255
    4f18:	7f 4f       	sbci	r23, 0xFF	; 255
    4f1a:	8f 4f       	sbci	r24, 0xFF	; 255
    4f1c:	9f 4f       	sbci	r25, 0xFF	; 255
    4f1e:	08 95       	ret

00004f20 <__fp_split3>:
    4f20:	57 fd       	sbrc	r21, 7
    4f22:	90 58       	subi	r25, 0x80	; 128
    4f24:	44 0f       	add	r20, r20
    4f26:	55 1f       	adc	r21, r21
    4f28:	59 f0       	breq	.+22     	; 0x4f40 <__fp_splitA+0x10>
    4f2a:	5f 3f       	cpi	r21, 0xFF	; 255
    4f2c:	71 f0       	breq	.+28     	; 0x4f4a <__fp_splitA+0x1a>
    4f2e:	47 95       	ror	r20

00004f30 <__fp_splitA>:
    4f30:	88 0f       	add	r24, r24
    4f32:	97 fb       	bst	r25, 7
    4f34:	99 1f       	adc	r25, r25
    4f36:	61 f0       	breq	.+24     	; 0x4f50 <__fp_splitA+0x20>
    4f38:	9f 3f       	cpi	r25, 0xFF	; 255
    4f3a:	79 f0       	breq	.+30     	; 0x4f5a <__fp_splitA+0x2a>
    4f3c:	87 95       	ror	r24
    4f3e:	08 95       	ret
    4f40:	12 16       	cp	r1, r18
    4f42:	13 06       	cpc	r1, r19
    4f44:	14 06       	cpc	r1, r20
    4f46:	55 1f       	adc	r21, r21
    4f48:	f2 cf       	rjmp	.-28     	; 0x4f2e <__fp_split3+0xe>
    4f4a:	46 95       	lsr	r20
    4f4c:	f1 df       	rcall	.-30     	; 0x4f30 <__fp_splitA>
    4f4e:	08 c0       	rjmp	.+16     	; 0x4f60 <__fp_splitA+0x30>
    4f50:	16 16       	cp	r1, r22
    4f52:	17 06       	cpc	r1, r23
    4f54:	18 06       	cpc	r1, r24
    4f56:	99 1f       	adc	r25, r25
    4f58:	f1 cf       	rjmp	.-30     	; 0x4f3c <__fp_splitA+0xc>
    4f5a:	86 95       	lsr	r24
    4f5c:	71 05       	cpc	r23, r1
    4f5e:	61 05       	cpc	r22, r1
    4f60:	08 94       	sec
    4f62:	08 95       	ret

00004f64 <__fp_zero>:
    4f64:	e8 94       	clt

00004f66 <__fp_szero>:
    4f66:	bb 27       	eor	r27, r27
    4f68:	66 27       	eor	r22, r22
    4f6a:	77 27       	eor	r23, r23
    4f6c:	cb 01       	movw	r24, r22
    4f6e:	97 f9       	bld	r25, 7
    4f70:	08 95       	ret

00004f72 <__gesf2>:
    4f72:	8a df       	rcall	.-236    	; 0x4e88 <__fp_cmp>
    4f74:	08 f4       	brcc	.+2      	; 0x4f78 <__gesf2+0x6>
    4f76:	8f ef       	ldi	r24, 0xFF	; 255
    4f78:	08 95       	ret

00004f7a <__mulsf3>:
    4f7a:	0b d0       	rcall	.+22     	; 0x4f92 <__mulsf3x>
    4f7c:	c0 cf       	rjmp	.-128    	; 0x4efe <__fp_round>
    4f7e:	b1 df       	rcall	.-158    	; 0x4ee2 <__fp_pscA>
    4f80:	28 f0       	brcs	.+10     	; 0x4f8c <__mulsf3+0x12>
    4f82:	b6 df       	rcall	.-148    	; 0x4ef0 <__fp_pscB>
    4f84:	18 f0       	brcs	.+6      	; 0x4f8c <__mulsf3+0x12>
    4f86:	95 23       	and	r25, r21
    4f88:	09 f0       	breq	.+2      	; 0x4f8c <__mulsf3+0x12>
    4f8a:	a2 cf       	rjmp	.-188    	; 0x4ed0 <__fp_inf>
    4f8c:	a7 cf       	rjmp	.-178    	; 0x4edc <__fp_nan>
    4f8e:	11 24       	eor	r1, r1
    4f90:	ea cf       	rjmp	.-44     	; 0x4f66 <__fp_szero>

00004f92 <__mulsf3x>:
    4f92:	c6 df       	rcall	.-116    	; 0x4f20 <__fp_split3>
    4f94:	a0 f3       	brcs	.-24     	; 0x4f7e <__mulsf3+0x4>

00004f96 <__mulsf3_pse>:
    4f96:	95 9f       	mul	r25, r21
    4f98:	d1 f3       	breq	.-12     	; 0x4f8e <__mulsf3+0x14>
    4f9a:	95 0f       	add	r25, r21
    4f9c:	50 e0       	ldi	r21, 0x00	; 0
    4f9e:	55 1f       	adc	r21, r21
    4fa0:	62 9f       	mul	r22, r18
    4fa2:	f0 01       	movw	r30, r0
    4fa4:	72 9f       	mul	r23, r18
    4fa6:	bb 27       	eor	r27, r27
    4fa8:	f0 0d       	add	r31, r0
    4faa:	b1 1d       	adc	r27, r1
    4fac:	63 9f       	mul	r22, r19
    4fae:	aa 27       	eor	r26, r26
    4fb0:	f0 0d       	add	r31, r0
    4fb2:	b1 1d       	adc	r27, r1
    4fb4:	aa 1f       	adc	r26, r26
    4fb6:	64 9f       	mul	r22, r20
    4fb8:	66 27       	eor	r22, r22
    4fba:	b0 0d       	add	r27, r0
    4fbc:	a1 1d       	adc	r26, r1
    4fbe:	66 1f       	adc	r22, r22
    4fc0:	82 9f       	mul	r24, r18
    4fc2:	22 27       	eor	r18, r18
    4fc4:	b0 0d       	add	r27, r0
    4fc6:	a1 1d       	adc	r26, r1
    4fc8:	62 1f       	adc	r22, r18
    4fca:	73 9f       	mul	r23, r19
    4fcc:	b0 0d       	add	r27, r0
    4fce:	a1 1d       	adc	r26, r1
    4fd0:	62 1f       	adc	r22, r18
    4fd2:	83 9f       	mul	r24, r19
    4fd4:	a0 0d       	add	r26, r0
    4fd6:	61 1d       	adc	r22, r1
    4fd8:	22 1f       	adc	r18, r18
    4fda:	74 9f       	mul	r23, r20
    4fdc:	33 27       	eor	r19, r19
    4fde:	a0 0d       	add	r26, r0
    4fe0:	61 1d       	adc	r22, r1
    4fe2:	23 1f       	adc	r18, r19
    4fe4:	84 9f       	mul	r24, r20
    4fe6:	60 0d       	add	r22, r0
    4fe8:	21 1d       	adc	r18, r1
    4fea:	82 2f       	mov	r24, r18
    4fec:	76 2f       	mov	r23, r22
    4fee:	6a 2f       	mov	r22, r26
    4ff0:	11 24       	eor	r1, r1
    4ff2:	9f 57       	subi	r25, 0x7F	; 127
    4ff4:	50 40       	sbci	r21, 0x00	; 0
    4ff6:	8a f0       	brmi	.+34     	; 0x501a <__mulsf3_pse+0x84>
    4ff8:	e1 f0       	breq	.+56     	; 0x5032 <__mulsf3_pse+0x9c>
    4ffa:	88 23       	and	r24, r24
    4ffc:	4a f0       	brmi	.+18     	; 0x5010 <__mulsf3_pse+0x7a>
    4ffe:	ee 0f       	add	r30, r30
    5000:	ff 1f       	adc	r31, r31
    5002:	bb 1f       	adc	r27, r27
    5004:	66 1f       	adc	r22, r22
    5006:	77 1f       	adc	r23, r23
    5008:	88 1f       	adc	r24, r24
    500a:	91 50       	subi	r25, 0x01	; 1
    500c:	50 40       	sbci	r21, 0x00	; 0
    500e:	a9 f7       	brne	.-22     	; 0x4ffa <__mulsf3_pse+0x64>
    5010:	9e 3f       	cpi	r25, 0xFE	; 254
    5012:	51 05       	cpc	r21, r1
    5014:	70 f0       	brcs	.+28     	; 0x5032 <__mulsf3_pse+0x9c>
    5016:	5c cf       	rjmp	.-328    	; 0x4ed0 <__fp_inf>
    5018:	a6 cf       	rjmp	.-180    	; 0x4f66 <__fp_szero>
    501a:	5f 3f       	cpi	r21, 0xFF	; 255
    501c:	ec f3       	brlt	.-6      	; 0x5018 <__mulsf3_pse+0x82>
    501e:	98 3e       	cpi	r25, 0xE8	; 232
    5020:	dc f3       	brlt	.-10     	; 0x5018 <__mulsf3_pse+0x82>
    5022:	86 95       	lsr	r24
    5024:	77 95       	ror	r23
    5026:	67 95       	ror	r22
    5028:	b7 95       	ror	r27
    502a:	f7 95       	ror	r31
    502c:	e7 95       	ror	r30
    502e:	9f 5f       	subi	r25, 0xFF	; 255
    5030:	c1 f7       	brne	.-16     	; 0x5022 <__mulsf3_pse+0x8c>
    5032:	fe 2b       	or	r31, r30
    5034:	88 0f       	add	r24, r24
    5036:	91 1d       	adc	r25, r1
    5038:	96 95       	lsr	r25
    503a:	87 95       	ror	r24
    503c:	97 f9       	bld	r25, 7
    503e:	08 95       	ret

00005040 <vfprintf>:
    5040:	2f 92       	push	r2
    5042:	3f 92       	push	r3
    5044:	4f 92       	push	r4
    5046:	5f 92       	push	r5
    5048:	6f 92       	push	r6
    504a:	7f 92       	push	r7
    504c:	8f 92       	push	r8
    504e:	9f 92       	push	r9
    5050:	af 92       	push	r10
    5052:	bf 92       	push	r11
    5054:	cf 92       	push	r12
    5056:	df 92       	push	r13
    5058:	ef 92       	push	r14
    505a:	ff 92       	push	r15
    505c:	0f 93       	push	r16
    505e:	1f 93       	push	r17
    5060:	cf 93       	push	r28
    5062:	df 93       	push	r29
    5064:	cd b7       	in	r28, 0x3d	; 61
    5066:	de b7       	in	r29, 0x3e	; 62
    5068:	60 97       	sbiw	r28, 0x10	; 16
    506a:	0f b6       	in	r0, 0x3f	; 63
    506c:	f8 94       	cli
    506e:	de bf       	out	0x3e, r29	; 62
    5070:	0f be       	out	0x3f, r0	; 63
    5072:	cd bf       	out	0x3d, r28	; 61
    5074:	7c 01       	movw	r14, r24
    5076:	1b 01       	movw	r2, r22
    5078:	6a 01       	movw	r12, r20
    507a:	fc 01       	movw	r30, r24
    507c:	17 82       	std	Z+7, r1	; 0x07
    507e:	16 82       	std	Z+6, r1	; 0x06
    5080:	83 81       	ldd	r24, Z+3	; 0x03
    5082:	81 ff       	sbrs	r24, 1
    5084:	2a c3       	rjmp	.+1620   	; 0x56da <vfprintf+0x69a>
    5086:	9e 01       	movw	r18, r28
    5088:	2f 5f       	subi	r18, 0xFF	; 255
    508a:	3f 4f       	sbci	r19, 0xFF	; 255
    508c:	39 01       	movw	r6, r18
    508e:	f7 01       	movw	r30, r14
    5090:	93 81       	ldd	r25, Z+3	; 0x03
    5092:	f1 01       	movw	r30, r2
    5094:	93 fd       	sbrc	r25, 3
    5096:	85 91       	lpm	r24, Z+
    5098:	93 ff       	sbrs	r25, 3
    509a:	81 91       	ld	r24, Z+
    509c:	1f 01       	movw	r2, r30
    509e:	88 23       	and	r24, r24
    50a0:	09 f4       	brne	.+2      	; 0x50a4 <vfprintf+0x64>
    50a2:	17 c3       	rjmp	.+1582   	; 0x56d2 <vfprintf+0x692>
    50a4:	85 32       	cpi	r24, 0x25	; 37
    50a6:	39 f4       	brne	.+14     	; 0x50b6 <vfprintf+0x76>
    50a8:	93 fd       	sbrc	r25, 3
    50aa:	85 91       	lpm	r24, Z+
    50ac:	93 ff       	sbrs	r25, 3
    50ae:	81 91       	ld	r24, Z+
    50b0:	1f 01       	movw	r2, r30
    50b2:	85 32       	cpi	r24, 0x25	; 37
    50b4:	31 f4       	brne	.+12     	; 0x50c2 <vfprintf+0x82>
    50b6:	b7 01       	movw	r22, r14
    50b8:	90 e0       	ldi	r25, 0x00	; 0
    50ba:	51 d4       	rcall	.+2210   	; 0x595e <fputc>
    50bc:	56 01       	movw	r10, r12
    50be:	65 01       	movw	r12, r10
    50c0:	e6 cf       	rjmp	.-52     	; 0x508e <vfprintf+0x4e>
    50c2:	10 e0       	ldi	r17, 0x00	; 0
    50c4:	51 2c       	mov	r5, r1
    50c6:	91 2c       	mov	r9, r1
    50c8:	ff e1       	ldi	r31, 0x1F	; 31
    50ca:	f9 15       	cp	r31, r9
    50cc:	d8 f0       	brcs	.+54     	; 0x5104 <vfprintf+0xc4>
    50ce:	8b 32       	cpi	r24, 0x2B	; 43
    50d0:	79 f0       	breq	.+30     	; 0x50f0 <vfprintf+0xb0>
    50d2:	38 f4       	brcc	.+14     	; 0x50e2 <vfprintf+0xa2>
    50d4:	80 32       	cpi	r24, 0x20	; 32
    50d6:	79 f0       	breq	.+30     	; 0x50f6 <vfprintf+0xb6>
    50d8:	83 32       	cpi	r24, 0x23	; 35
    50da:	a1 f4       	brne	.+40     	; 0x5104 <vfprintf+0xc4>
    50dc:	f9 2d       	mov	r31, r9
    50de:	f0 61       	ori	r31, 0x10	; 16
    50e0:	2e c0       	rjmp	.+92     	; 0x513e <vfprintf+0xfe>
    50e2:	8d 32       	cpi	r24, 0x2D	; 45
    50e4:	61 f0       	breq	.+24     	; 0x50fe <vfprintf+0xbe>
    50e6:	80 33       	cpi	r24, 0x30	; 48
    50e8:	69 f4       	brne	.+26     	; 0x5104 <vfprintf+0xc4>
    50ea:	29 2d       	mov	r18, r9
    50ec:	21 60       	ori	r18, 0x01	; 1
    50ee:	2d c0       	rjmp	.+90     	; 0x514a <vfprintf+0x10a>
    50f0:	39 2d       	mov	r19, r9
    50f2:	32 60       	ori	r19, 0x02	; 2
    50f4:	93 2e       	mov	r9, r19
    50f6:	89 2d       	mov	r24, r9
    50f8:	84 60       	ori	r24, 0x04	; 4
    50fa:	98 2e       	mov	r9, r24
    50fc:	2a c0       	rjmp	.+84     	; 0x5152 <vfprintf+0x112>
    50fe:	e9 2d       	mov	r30, r9
    5100:	e8 60       	ori	r30, 0x08	; 8
    5102:	15 c0       	rjmp	.+42     	; 0x512e <vfprintf+0xee>
    5104:	97 fc       	sbrc	r9, 7
    5106:	2d c0       	rjmp	.+90     	; 0x5162 <vfprintf+0x122>
    5108:	20 ed       	ldi	r18, 0xD0	; 208
    510a:	28 0f       	add	r18, r24
    510c:	2a 30       	cpi	r18, 0x0A	; 10
    510e:	88 f4       	brcc	.+34     	; 0x5132 <vfprintf+0xf2>
    5110:	96 fe       	sbrs	r9, 6
    5112:	06 c0       	rjmp	.+12     	; 0x5120 <vfprintf+0xe0>
    5114:	3a e0       	ldi	r19, 0x0A	; 10
    5116:	13 9f       	mul	r17, r19
    5118:	20 0d       	add	r18, r0
    511a:	11 24       	eor	r1, r1
    511c:	12 2f       	mov	r17, r18
    511e:	19 c0       	rjmp	.+50     	; 0x5152 <vfprintf+0x112>
    5120:	8a e0       	ldi	r24, 0x0A	; 10
    5122:	58 9e       	mul	r5, r24
    5124:	20 0d       	add	r18, r0
    5126:	11 24       	eor	r1, r1
    5128:	52 2e       	mov	r5, r18
    512a:	e9 2d       	mov	r30, r9
    512c:	e0 62       	ori	r30, 0x20	; 32
    512e:	9e 2e       	mov	r9, r30
    5130:	10 c0       	rjmp	.+32     	; 0x5152 <vfprintf+0x112>
    5132:	8e 32       	cpi	r24, 0x2E	; 46
    5134:	31 f4       	brne	.+12     	; 0x5142 <vfprintf+0x102>
    5136:	96 fc       	sbrc	r9, 6
    5138:	cc c2       	rjmp	.+1432   	; 0x56d2 <vfprintf+0x692>
    513a:	f9 2d       	mov	r31, r9
    513c:	f0 64       	ori	r31, 0x40	; 64
    513e:	9f 2e       	mov	r9, r31
    5140:	08 c0       	rjmp	.+16     	; 0x5152 <vfprintf+0x112>
    5142:	8c 36       	cpi	r24, 0x6C	; 108
    5144:	21 f4       	brne	.+8      	; 0x514e <vfprintf+0x10e>
    5146:	29 2d       	mov	r18, r9
    5148:	20 68       	ori	r18, 0x80	; 128
    514a:	92 2e       	mov	r9, r18
    514c:	02 c0       	rjmp	.+4      	; 0x5152 <vfprintf+0x112>
    514e:	88 36       	cpi	r24, 0x68	; 104
    5150:	41 f4       	brne	.+16     	; 0x5162 <vfprintf+0x122>
    5152:	f1 01       	movw	r30, r2
    5154:	93 fd       	sbrc	r25, 3
    5156:	85 91       	lpm	r24, Z+
    5158:	93 ff       	sbrs	r25, 3
    515a:	81 91       	ld	r24, Z+
    515c:	1f 01       	movw	r2, r30
    515e:	81 11       	cpse	r24, r1
    5160:	b3 cf       	rjmp	.-154    	; 0x50c8 <vfprintf+0x88>
    5162:	9b eb       	ldi	r25, 0xBB	; 187
    5164:	98 0f       	add	r25, r24
    5166:	93 30       	cpi	r25, 0x03	; 3
    5168:	20 f4       	brcc	.+8      	; 0x5172 <vfprintf+0x132>
    516a:	99 2d       	mov	r25, r9
    516c:	90 61       	ori	r25, 0x10	; 16
    516e:	80 5e       	subi	r24, 0xE0	; 224
    5170:	07 c0       	rjmp	.+14     	; 0x5180 <vfprintf+0x140>
    5172:	9b e9       	ldi	r25, 0x9B	; 155
    5174:	98 0f       	add	r25, r24
    5176:	93 30       	cpi	r25, 0x03	; 3
    5178:	08 f0       	brcs	.+2      	; 0x517c <vfprintf+0x13c>
    517a:	59 c1       	rjmp	.+690    	; 0x542e <vfprintf+0x3ee>
    517c:	99 2d       	mov	r25, r9
    517e:	9f 7e       	andi	r25, 0xEF	; 239
    5180:	96 ff       	sbrs	r25, 6
    5182:	16 e0       	ldi	r17, 0x06	; 6
    5184:	9f 73       	andi	r25, 0x3F	; 63
    5186:	99 2e       	mov	r9, r25
    5188:	85 36       	cpi	r24, 0x65	; 101
    518a:	19 f4       	brne	.+6      	; 0x5192 <vfprintf+0x152>
    518c:	90 64       	ori	r25, 0x40	; 64
    518e:	99 2e       	mov	r9, r25
    5190:	08 c0       	rjmp	.+16     	; 0x51a2 <vfprintf+0x162>
    5192:	86 36       	cpi	r24, 0x66	; 102
    5194:	21 f4       	brne	.+8      	; 0x519e <vfprintf+0x15e>
    5196:	39 2f       	mov	r19, r25
    5198:	30 68       	ori	r19, 0x80	; 128
    519a:	93 2e       	mov	r9, r19
    519c:	02 c0       	rjmp	.+4      	; 0x51a2 <vfprintf+0x162>
    519e:	11 11       	cpse	r17, r1
    51a0:	11 50       	subi	r17, 0x01	; 1
    51a2:	97 fe       	sbrs	r9, 7
    51a4:	07 c0       	rjmp	.+14     	; 0x51b4 <vfprintf+0x174>
    51a6:	1c 33       	cpi	r17, 0x3C	; 60
    51a8:	50 f4       	brcc	.+20     	; 0x51be <vfprintf+0x17e>
    51aa:	44 24       	eor	r4, r4
    51ac:	43 94       	inc	r4
    51ae:	41 0e       	add	r4, r17
    51b0:	27 e0       	ldi	r18, 0x07	; 7
    51b2:	0b c0       	rjmp	.+22     	; 0x51ca <vfprintf+0x18a>
    51b4:	18 30       	cpi	r17, 0x08	; 8
    51b6:	38 f0       	brcs	.+14     	; 0x51c6 <vfprintf+0x186>
    51b8:	27 e0       	ldi	r18, 0x07	; 7
    51ba:	17 e0       	ldi	r17, 0x07	; 7
    51bc:	05 c0       	rjmp	.+10     	; 0x51c8 <vfprintf+0x188>
    51be:	27 e0       	ldi	r18, 0x07	; 7
    51c0:	9c e3       	ldi	r25, 0x3C	; 60
    51c2:	49 2e       	mov	r4, r25
    51c4:	02 c0       	rjmp	.+4      	; 0x51ca <vfprintf+0x18a>
    51c6:	21 2f       	mov	r18, r17
    51c8:	41 2c       	mov	r4, r1
    51ca:	56 01       	movw	r10, r12
    51cc:	84 e0       	ldi	r24, 0x04	; 4
    51ce:	a8 0e       	add	r10, r24
    51d0:	b1 1c       	adc	r11, r1
    51d2:	f6 01       	movw	r30, r12
    51d4:	60 81       	ld	r22, Z
    51d6:	71 81       	ldd	r23, Z+1	; 0x01
    51d8:	82 81       	ldd	r24, Z+2	; 0x02
    51da:	93 81       	ldd	r25, Z+3	; 0x03
    51dc:	04 2d       	mov	r16, r4
    51de:	a3 01       	movw	r20, r6
    51e0:	c7 d2       	rcall	.+1422   	; 0x5770 <__ftoa_engine>
    51e2:	6c 01       	movw	r12, r24
    51e4:	f9 81       	ldd	r31, Y+1	; 0x01
    51e6:	fc 87       	std	Y+12, r31	; 0x0c
    51e8:	f0 ff       	sbrs	r31, 0
    51ea:	02 c0       	rjmp	.+4      	; 0x51f0 <vfprintf+0x1b0>
    51ec:	f3 ff       	sbrs	r31, 3
    51ee:	06 c0       	rjmp	.+12     	; 0x51fc <vfprintf+0x1bc>
    51f0:	91 fc       	sbrc	r9, 1
    51f2:	06 c0       	rjmp	.+12     	; 0x5200 <vfprintf+0x1c0>
    51f4:	92 fe       	sbrs	r9, 2
    51f6:	06 c0       	rjmp	.+12     	; 0x5204 <vfprintf+0x1c4>
    51f8:	00 e2       	ldi	r16, 0x20	; 32
    51fa:	05 c0       	rjmp	.+10     	; 0x5206 <vfprintf+0x1c6>
    51fc:	0d e2       	ldi	r16, 0x2D	; 45
    51fe:	03 c0       	rjmp	.+6      	; 0x5206 <vfprintf+0x1c6>
    5200:	0b e2       	ldi	r16, 0x2B	; 43
    5202:	01 c0       	rjmp	.+2      	; 0x5206 <vfprintf+0x1c6>
    5204:	00 e0       	ldi	r16, 0x00	; 0
    5206:	8c 85       	ldd	r24, Y+12	; 0x0c
    5208:	8c 70       	andi	r24, 0x0C	; 12
    520a:	19 f0       	breq	.+6      	; 0x5212 <vfprintf+0x1d2>
    520c:	01 11       	cpse	r16, r1
    520e:	43 c2       	rjmp	.+1158   	; 0x5696 <vfprintf+0x656>
    5210:	80 c2       	rjmp	.+1280   	; 0x5712 <vfprintf+0x6d2>
    5212:	97 fe       	sbrs	r9, 7
    5214:	10 c0       	rjmp	.+32     	; 0x5236 <vfprintf+0x1f6>
    5216:	4c 0c       	add	r4, r12
    5218:	fc 85       	ldd	r31, Y+12	; 0x0c
    521a:	f4 ff       	sbrs	r31, 4
    521c:	04 c0       	rjmp	.+8      	; 0x5226 <vfprintf+0x1e6>
    521e:	8a 81       	ldd	r24, Y+2	; 0x02
    5220:	81 33       	cpi	r24, 0x31	; 49
    5222:	09 f4       	brne	.+2      	; 0x5226 <vfprintf+0x1e6>
    5224:	4a 94       	dec	r4
    5226:	14 14       	cp	r1, r4
    5228:	74 f5       	brge	.+92     	; 0x5286 <vfprintf+0x246>
    522a:	28 e0       	ldi	r18, 0x08	; 8
    522c:	24 15       	cp	r18, r4
    522e:	78 f5       	brcc	.+94     	; 0x528e <vfprintf+0x24e>
    5230:	88 e0       	ldi	r24, 0x08	; 8
    5232:	48 2e       	mov	r4, r24
    5234:	2c c0       	rjmp	.+88     	; 0x528e <vfprintf+0x24e>
    5236:	96 fc       	sbrc	r9, 6
    5238:	2a c0       	rjmp	.+84     	; 0x528e <vfprintf+0x24e>
    523a:	81 2f       	mov	r24, r17
    523c:	90 e0       	ldi	r25, 0x00	; 0
    523e:	8c 15       	cp	r24, r12
    5240:	9d 05       	cpc	r25, r13
    5242:	9c f0       	brlt	.+38     	; 0x526a <vfprintf+0x22a>
    5244:	3c ef       	ldi	r19, 0xFC	; 252
    5246:	c3 16       	cp	r12, r19
    5248:	3f ef       	ldi	r19, 0xFF	; 255
    524a:	d3 06       	cpc	r13, r19
    524c:	74 f0       	brlt	.+28     	; 0x526a <vfprintf+0x22a>
    524e:	89 2d       	mov	r24, r9
    5250:	80 68       	ori	r24, 0x80	; 128
    5252:	98 2e       	mov	r9, r24
    5254:	0a c0       	rjmp	.+20     	; 0x526a <vfprintf+0x22a>
    5256:	e2 e0       	ldi	r30, 0x02	; 2
    5258:	f0 e0       	ldi	r31, 0x00	; 0
    525a:	ec 0f       	add	r30, r28
    525c:	fd 1f       	adc	r31, r29
    525e:	e1 0f       	add	r30, r17
    5260:	f1 1d       	adc	r31, r1
    5262:	80 81       	ld	r24, Z
    5264:	80 33       	cpi	r24, 0x30	; 48
    5266:	19 f4       	brne	.+6      	; 0x526e <vfprintf+0x22e>
    5268:	11 50       	subi	r17, 0x01	; 1
    526a:	11 11       	cpse	r17, r1
    526c:	f4 cf       	rjmp	.-24     	; 0x5256 <vfprintf+0x216>
    526e:	97 fe       	sbrs	r9, 7
    5270:	0e c0       	rjmp	.+28     	; 0x528e <vfprintf+0x24e>
    5272:	44 24       	eor	r4, r4
    5274:	43 94       	inc	r4
    5276:	41 0e       	add	r4, r17
    5278:	81 2f       	mov	r24, r17
    527a:	90 e0       	ldi	r25, 0x00	; 0
    527c:	c8 16       	cp	r12, r24
    527e:	d9 06       	cpc	r13, r25
    5280:	2c f4       	brge	.+10     	; 0x528c <vfprintf+0x24c>
    5282:	1c 19       	sub	r17, r12
    5284:	04 c0       	rjmp	.+8      	; 0x528e <vfprintf+0x24e>
    5286:	44 24       	eor	r4, r4
    5288:	43 94       	inc	r4
    528a:	01 c0       	rjmp	.+2      	; 0x528e <vfprintf+0x24e>
    528c:	10 e0       	ldi	r17, 0x00	; 0
    528e:	97 fe       	sbrs	r9, 7
    5290:	06 c0       	rjmp	.+12     	; 0x529e <vfprintf+0x25e>
    5292:	1c 14       	cp	r1, r12
    5294:	1d 04       	cpc	r1, r13
    5296:	34 f4       	brge	.+12     	; 0x52a4 <vfprintf+0x264>
    5298:	c6 01       	movw	r24, r12
    529a:	01 96       	adiw	r24, 0x01	; 1
    529c:	05 c0       	rjmp	.+10     	; 0x52a8 <vfprintf+0x268>
    529e:	85 e0       	ldi	r24, 0x05	; 5
    52a0:	90 e0       	ldi	r25, 0x00	; 0
    52a2:	02 c0       	rjmp	.+4      	; 0x52a8 <vfprintf+0x268>
    52a4:	81 e0       	ldi	r24, 0x01	; 1
    52a6:	90 e0       	ldi	r25, 0x00	; 0
    52a8:	01 11       	cpse	r16, r1
    52aa:	01 96       	adiw	r24, 0x01	; 1
    52ac:	11 23       	and	r17, r17
    52ae:	31 f0       	breq	.+12     	; 0x52bc <vfprintf+0x27c>
    52b0:	21 2f       	mov	r18, r17
    52b2:	30 e0       	ldi	r19, 0x00	; 0
    52b4:	2f 5f       	subi	r18, 0xFF	; 255
    52b6:	3f 4f       	sbci	r19, 0xFF	; 255
    52b8:	82 0f       	add	r24, r18
    52ba:	93 1f       	adc	r25, r19
    52bc:	25 2d       	mov	r18, r5
    52be:	30 e0       	ldi	r19, 0x00	; 0
    52c0:	82 17       	cp	r24, r18
    52c2:	93 07       	cpc	r25, r19
    52c4:	14 f4       	brge	.+4      	; 0x52ca <vfprintf+0x28a>
    52c6:	58 1a       	sub	r5, r24
    52c8:	01 c0       	rjmp	.+2      	; 0x52cc <vfprintf+0x28c>
    52ca:	51 2c       	mov	r5, r1
    52cc:	89 2d       	mov	r24, r9
    52ce:	89 70       	andi	r24, 0x09	; 9
    52d0:	41 f4       	brne	.+16     	; 0x52e2 <vfprintf+0x2a2>
    52d2:	55 20       	and	r5, r5
    52d4:	31 f0       	breq	.+12     	; 0x52e2 <vfprintf+0x2a2>
    52d6:	b7 01       	movw	r22, r14
    52d8:	80 e2       	ldi	r24, 0x20	; 32
    52da:	90 e0       	ldi	r25, 0x00	; 0
    52dc:	40 d3       	rcall	.+1664   	; 0x595e <fputc>
    52de:	5a 94       	dec	r5
    52e0:	f8 cf       	rjmp	.-16     	; 0x52d2 <vfprintf+0x292>
    52e2:	00 23       	and	r16, r16
    52e4:	21 f0       	breq	.+8      	; 0x52ee <vfprintf+0x2ae>
    52e6:	b7 01       	movw	r22, r14
    52e8:	80 2f       	mov	r24, r16
    52ea:	90 e0       	ldi	r25, 0x00	; 0
    52ec:	38 d3       	rcall	.+1648   	; 0x595e <fputc>
    52ee:	93 fc       	sbrc	r9, 3
    52f0:	08 c0       	rjmp	.+16     	; 0x5302 <vfprintf+0x2c2>
    52f2:	55 20       	and	r5, r5
    52f4:	31 f0       	breq	.+12     	; 0x5302 <vfprintf+0x2c2>
    52f6:	b7 01       	movw	r22, r14
    52f8:	80 e3       	ldi	r24, 0x30	; 48
    52fa:	90 e0       	ldi	r25, 0x00	; 0
    52fc:	30 d3       	rcall	.+1632   	; 0x595e <fputc>
    52fe:	5a 94       	dec	r5
    5300:	f8 cf       	rjmp	.-16     	; 0x52f2 <vfprintf+0x2b2>
    5302:	97 fe       	sbrs	r9, 7
    5304:	4a c0       	rjmp	.+148    	; 0x539a <vfprintf+0x35a>
    5306:	46 01       	movw	r8, r12
    5308:	d7 fe       	sbrs	r13, 7
    530a:	02 c0       	rjmp	.+4      	; 0x5310 <vfprintf+0x2d0>
    530c:	81 2c       	mov	r8, r1
    530e:	91 2c       	mov	r9, r1
    5310:	c6 01       	movw	r24, r12
    5312:	88 19       	sub	r24, r8
    5314:	99 09       	sbc	r25, r9
    5316:	f3 01       	movw	r30, r6
    5318:	e8 0f       	add	r30, r24
    531a:	f9 1f       	adc	r31, r25
    531c:	fe 87       	std	Y+14, r31	; 0x0e
    531e:	ed 87       	std	Y+13, r30	; 0x0d
    5320:	96 01       	movw	r18, r12
    5322:	24 19       	sub	r18, r4
    5324:	31 09       	sbc	r19, r1
    5326:	38 8b       	std	Y+16, r19	; 0x10
    5328:	2f 87       	std	Y+15, r18	; 0x0f
    532a:	01 2f       	mov	r16, r17
    532c:	10 e0       	ldi	r17, 0x00	; 0
    532e:	11 95       	neg	r17
    5330:	01 95       	neg	r16
    5332:	11 09       	sbc	r17, r1
    5334:	3f ef       	ldi	r19, 0xFF	; 255
    5336:	83 16       	cp	r8, r19
    5338:	93 06       	cpc	r9, r19
    533a:	21 f4       	brne	.+8      	; 0x5344 <vfprintf+0x304>
    533c:	b7 01       	movw	r22, r14
    533e:	8e e2       	ldi	r24, 0x2E	; 46
    5340:	90 e0       	ldi	r25, 0x00	; 0
    5342:	0d d3       	rcall	.+1562   	; 0x595e <fputc>
    5344:	c8 14       	cp	r12, r8
    5346:	d9 04       	cpc	r13, r9
    5348:	4c f0       	brlt	.+18     	; 0x535c <vfprintf+0x31c>
    534a:	8f 85       	ldd	r24, Y+15	; 0x0f
    534c:	98 89       	ldd	r25, Y+16	; 0x10
    534e:	88 15       	cp	r24, r8
    5350:	99 05       	cpc	r25, r9
    5352:	24 f4       	brge	.+8      	; 0x535c <vfprintf+0x31c>
    5354:	ed 85       	ldd	r30, Y+13	; 0x0d
    5356:	fe 85       	ldd	r31, Y+14	; 0x0e
    5358:	81 81       	ldd	r24, Z+1	; 0x01
    535a:	01 c0       	rjmp	.+2      	; 0x535e <vfprintf+0x31e>
    535c:	80 e3       	ldi	r24, 0x30	; 48
    535e:	f1 e0       	ldi	r31, 0x01	; 1
    5360:	8f 1a       	sub	r8, r31
    5362:	91 08       	sbc	r9, r1
    5364:	2d 85       	ldd	r18, Y+13	; 0x0d
    5366:	3e 85       	ldd	r19, Y+14	; 0x0e
    5368:	2f 5f       	subi	r18, 0xFF	; 255
    536a:	3f 4f       	sbci	r19, 0xFF	; 255
    536c:	3e 87       	std	Y+14, r19	; 0x0e
    536e:	2d 87       	std	Y+13, r18	; 0x0d
    5370:	80 16       	cp	r8, r16
    5372:	91 06       	cpc	r9, r17
    5374:	24 f0       	brlt	.+8      	; 0x537e <vfprintf+0x33e>
    5376:	b7 01       	movw	r22, r14
    5378:	90 e0       	ldi	r25, 0x00	; 0
    537a:	f1 d2       	rcall	.+1506   	; 0x595e <fputc>
    537c:	db cf       	rjmp	.-74     	; 0x5334 <vfprintf+0x2f4>
    537e:	c8 14       	cp	r12, r8
    5380:	d9 04       	cpc	r13, r9
    5382:	41 f4       	brne	.+16     	; 0x5394 <vfprintf+0x354>
    5384:	9a 81       	ldd	r25, Y+2	; 0x02
    5386:	96 33       	cpi	r25, 0x36	; 54
    5388:	20 f4       	brcc	.+8      	; 0x5392 <vfprintf+0x352>
    538a:	95 33       	cpi	r25, 0x35	; 53
    538c:	19 f4       	brne	.+6      	; 0x5394 <vfprintf+0x354>
    538e:	3c 85       	ldd	r19, Y+12	; 0x0c
    5390:	34 ff       	sbrs	r19, 4
    5392:	81 e3       	ldi	r24, 0x31	; 49
    5394:	b7 01       	movw	r22, r14
    5396:	90 e0       	ldi	r25, 0x00	; 0
    5398:	48 c0       	rjmp	.+144    	; 0x542a <vfprintf+0x3ea>
    539a:	8a 81       	ldd	r24, Y+2	; 0x02
    539c:	81 33       	cpi	r24, 0x31	; 49
    539e:	19 f0       	breq	.+6      	; 0x53a6 <vfprintf+0x366>
    53a0:	9c 85       	ldd	r25, Y+12	; 0x0c
    53a2:	9f 7e       	andi	r25, 0xEF	; 239
    53a4:	9c 87       	std	Y+12, r25	; 0x0c
    53a6:	b7 01       	movw	r22, r14
    53a8:	90 e0       	ldi	r25, 0x00	; 0
    53aa:	d9 d2       	rcall	.+1458   	; 0x595e <fputc>
    53ac:	11 11       	cpse	r17, r1
    53ae:	05 c0       	rjmp	.+10     	; 0x53ba <vfprintf+0x37a>
    53b0:	94 fc       	sbrc	r9, 4
    53b2:	16 c0       	rjmp	.+44     	; 0x53e0 <vfprintf+0x3a0>
    53b4:	85 e6       	ldi	r24, 0x65	; 101
    53b6:	90 e0       	ldi	r25, 0x00	; 0
    53b8:	15 c0       	rjmp	.+42     	; 0x53e4 <vfprintf+0x3a4>
    53ba:	b7 01       	movw	r22, r14
    53bc:	8e e2       	ldi	r24, 0x2E	; 46
    53be:	90 e0       	ldi	r25, 0x00	; 0
    53c0:	ce d2       	rcall	.+1436   	; 0x595e <fputc>
    53c2:	1e 5f       	subi	r17, 0xFE	; 254
    53c4:	82 e0       	ldi	r24, 0x02	; 2
    53c6:	01 e0       	ldi	r16, 0x01	; 1
    53c8:	08 0f       	add	r16, r24
    53ca:	f3 01       	movw	r30, r6
    53cc:	e8 0f       	add	r30, r24
    53ce:	f1 1d       	adc	r31, r1
    53d0:	80 81       	ld	r24, Z
    53d2:	b7 01       	movw	r22, r14
    53d4:	90 e0       	ldi	r25, 0x00	; 0
    53d6:	c3 d2       	rcall	.+1414   	; 0x595e <fputc>
    53d8:	80 2f       	mov	r24, r16
    53da:	01 13       	cpse	r16, r17
    53dc:	f4 cf       	rjmp	.-24     	; 0x53c6 <vfprintf+0x386>
    53de:	e8 cf       	rjmp	.-48     	; 0x53b0 <vfprintf+0x370>
    53e0:	85 e4       	ldi	r24, 0x45	; 69
    53e2:	90 e0       	ldi	r25, 0x00	; 0
    53e4:	b7 01       	movw	r22, r14
    53e6:	bb d2       	rcall	.+1398   	; 0x595e <fputc>
    53e8:	d7 fc       	sbrc	r13, 7
    53ea:	06 c0       	rjmp	.+12     	; 0x53f8 <vfprintf+0x3b8>
    53ec:	c1 14       	cp	r12, r1
    53ee:	d1 04       	cpc	r13, r1
    53f0:	41 f4       	brne	.+16     	; 0x5402 <vfprintf+0x3c2>
    53f2:	ec 85       	ldd	r30, Y+12	; 0x0c
    53f4:	e4 ff       	sbrs	r30, 4
    53f6:	05 c0       	rjmp	.+10     	; 0x5402 <vfprintf+0x3c2>
    53f8:	d1 94       	neg	r13
    53fa:	c1 94       	neg	r12
    53fc:	d1 08       	sbc	r13, r1
    53fe:	8d e2       	ldi	r24, 0x2D	; 45
    5400:	01 c0       	rjmp	.+2      	; 0x5404 <vfprintf+0x3c4>
    5402:	8b e2       	ldi	r24, 0x2B	; 43
    5404:	b7 01       	movw	r22, r14
    5406:	90 e0       	ldi	r25, 0x00	; 0
    5408:	aa d2       	rcall	.+1364   	; 0x595e <fputc>
    540a:	80 e3       	ldi	r24, 0x30	; 48
    540c:	2a e0       	ldi	r18, 0x0A	; 10
    540e:	c2 16       	cp	r12, r18
    5410:	d1 04       	cpc	r13, r1
    5412:	2c f0       	brlt	.+10     	; 0x541e <vfprintf+0x3de>
    5414:	8f 5f       	subi	r24, 0xFF	; 255
    5416:	fa e0       	ldi	r31, 0x0A	; 10
    5418:	cf 1a       	sub	r12, r31
    541a:	d1 08       	sbc	r13, r1
    541c:	f7 cf       	rjmp	.-18     	; 0x540c <vfprintf+0x3cc>
    541e:	b7 01       	movw	r22, r14
    5420:	90 e0       	ldi	r25, 0x00	; 0
    5422:	9d d2       	rcall	.+1338   	; 0x595e <fputc>
    5424:	b7 01       	movw	r22, r14
    5426:	c6 01       	movw	r24, r12
    5428:	c0 96       	adiw	r24, 0x30	; 48
    542a:	99 d2       	rcall	.+1330   	; 0x595e <fputc>
    542c:	49 c1       	rjmp	.+658    	; 0x56c0 <vfprintf+0x680>
    542e:	83 36       	cpi	r24, 0x63	; 99
    5430:	31 f0       	breq	.+12     	; 0x543e <vfprintf+0x3fe>
    5432:	83 37       	cpi	r24, 0x73	; 115
    5434:	79 f0       	breq	.+30     	; 0x5454 <vfprintf+0x414>
    5436:	83 35       	cpi	r24, 0x53	; 83
    5438:	09 f0       	breq	.+2      	; 0x543c <vfprintf+0x3fc>
    543a:	52 c0       	rjmp	.+164    	; 0x54e0 <vfprintf+0x4a0>
    543c:	1f c0       	rjmp	.+62     	; 0x547c <vfprintf+0x43c>
    543e:	56 01       	movw	r10, r12
    5440:	32 e0       	ldi	r19, 0x02	; 2
    5442:	a3 0e       	add	r10, r19
    5444:	b1 1c       	adc	r11, r1
    5446:	f6 01       	movw	r30, r12
    5448:	80 81       	ld	r24, Z
    544a:	89 83       	std	Y+1, r24	; 0x01
    544c:	01 e0       	ldi	r16, 0x01	; 1
    544e:	10 e0       	ldi	r17, 0x00	; 0
    5450:	63 01       	movw	r12, r6
    5452:	11 c0       	rjmp	.+34     	; 0x5476 <vfprintf+0x436>
    5454:	56 01       	movw	r10, r12
    5456:	f2 e0       	ldi	r31, 0x02	; 2
    5458:	af 0e       	add	r10, r31
    545a:	b1 1c       	adc	r11, r1
    545c:	f6 01       	movw	r30, r12
    545e:	c0 80       	ld	r12, Z
    5460:	d1 80       	ldd	r13, Z+1	; 0x01
    5462:	96 fe       	sbrs	r9, 6
    5464:	03 c0       	rjmp	.+6      	; 0x546c <vfprintf+0x42c>
    5466:	61 2f       	mov	r22, r17
    5468:	70 e0       	ldi	r23, 0x00	; 0
    546a:	02 c0       	rjmp	.+4      	; 0x5470 <vfprintf+0x430>
    546c:	6f ef       	ldi	r22, 0xFF	; 255
    546e:	7f ef       	ldi	r23, 0xFF	; 255
    5470:	c6 01       	movw	r24, r12
    5472:	6a d2       	rcall	.+1236   	; 0x5948 <strnlen>
    5474:	8c 01       	movw	r16, r24
    5476:	f9 2d       	mov	r31, r9
    5478:	ff 77       	andi	r31, 0x7F	; 127
    547a:	13 c0       	rjmp	.+38     	; 0x54a2 <vfprintf+0x462>
    547c:	56 01       	movw	r10, r12
    547e:	22 e0       	ldi	r18, 0x02	; 2
    5480:	a2 0e       	add	r10, r18
    5482:	b1 1c       	adc	r11, r1
    5484:	f6 01       	movw	r30, r12
    5486:	c0 80       	ld	r12, Z
    5488:	d1 80       	ldd	r13, Z+1	; 0x01
    548a:	96 fe       	sbrs	r9, 6
    548c:	03 c0       	rjmp	.+6      	; 0x5494 <vfprintf+0x454>
    548e:	61 2f       	mov	r22, r17
    5490:	70 e0       	ldi	r23, 0x00	; 0
    5492:	02 c0       	rjmp	.+4      	; 0x5498 <vfprintf+0x458>
    5494:	6f ef       	ldi	r22, 0xFF	; 255
    5496:	7f ef       	ldi	r23, 0xFF	; 255
    5498:	c6 01       	movw	r24, r12
    549a:	42 d2       	rcall	.+1156   	; 0x5920 <strnlen_P>
    549c:	8c 01       	movw	r16, r24
    549e:	f9 2d       	mov	r31, r9
    54a0:	f0 68       	ori	r31, 0x80	; 128
    54a2:	9f 2e       	mov	r9, r31
    54a4:	f3 fd       	sbrc	r31, 3
    54a6:	18 c0       	rjmp	.+48     	; 0x54d8 <vfprintf+0x498>
    54a8:	85 2d       	mov	r24, r5
    54aa:	90 e0       	ldi	r25, 0x00	; 0
    54ac:	08 17       	cp	r16, r24
    54ae:	19 07       	cpc	r17, r25
    54b0:	98 f4       	brcc	.+38     	; 0x54d8 <vfprintf+0x498>
    54b2:	b7 01       	movw	r22, r14
    54b4:	80 e2       	ldi	r24, 0x20	; 32
    54b6:	90 e0       	ldi	r25, 0x00	; 0
    54b8:	52 d2       	rcall	.+1188   	; 0x595e <fputc>
    54ba:	5a 94       	dec	r5
    54bc:	f5 cf       	rjmp	.-22     	; 0x54a8 <vfprintf+0x468>
    54be:	f6 01       	movw	r30, r12
    54c0:	97 fc       	sbrc	r9, 7
    54c2:	85 91       	lpm	r24, Z+
    54c4:	97 fe       	sbrs	r9, 7
    54c6:	81 91       	ld	r24, Z+
    54c8:	6f 01       	movw	r12, r30
    54ca:	b7 01       	movw	r22, r14
    54cc:	90 e0       	ldi	r25, 0x00	; 0
    54ce:	47 d2       	rcall	.+1166   	; 0x595e <fputc>
    54d0:	51 10       	cpse	r5, r1
    54d2:	5a 94       	dec	r5
    54d4:	01 50       	subi	r16, 0x01	; 1
    54d6:	11 09       	sbc	r17, r1
    54d8:	01 15       	cp	r16, r1
    54da:	11 05       	cpc	r17, r1
    54dc:	81 f7       	brne	.-32     	; 0x54be <vfprintf+0x47e>
    54de:	f0 c0       	rjmp	.+480    	; 0x56c0 <vfprintf+0x680>
    54e0:	84 36       	cpi	r24, 0x64	; 100
    54e2:	11 f0       	breq	.+4      	; 0x54e8 <vfprintf+0x4a8>
    54e4:	89 36       	cpi	r24, 0x69	; 105
    54e6:	59 f5       	brne	.+86     	; 0x553e <vfprintf+0x4fe>
    54e8:	56 01       	movw	r10, r12
    54ea:	97 fe       	sbrs	r9, 7
    54ec:	09 c0       	rjmp	.+18     	; 0x5500 <vfprintf+0x4c0>
    54ee:	24 e0       	ldi	r18, 0x04	; 4
    54f0:	a2 0e       	add	r10, r18
    54f2:	b1 1c       	adc	r11, r1
    54f4:	f6 01       	movw	r30, r12
    54f6:	60 81       	ld	r22, Z
    54f8:	71 81       	ldd	r23, Z+1	; 0x01
    54fa:	82 81       	ldd	r24, Z+2	; 0x02
    54fc:	93 81       	ldd	r25, Z+3	; 0x03
    54fe:	0a c0       	rjmp	.+20     	; 0x5514 <vfprintf+0x4d4>
    5500:	f2 e0       	ldi	r31, 0x02	; 2
    5502:	af 0e       	add	r10, r31
    5504:	b1 1c       	adc	r11, r1
    5506:	f6 01       	movw	r30, r12
    5508:	60 81       	ld	r22, Z
    550a:	71 81       	ldd	r23, Z+1	; 0x01
    550c:	07 2e       	mov	r0, r23
    550e:	00 0c       	add	r0, r0
    5510:	88 0b       	sbc	r24, r24
    5512:	99 0b       	sbc	r25, r25
    5514:	f9 2d       	mov	r31, r9
    5516:	ff 76       	andi	r31, 0x6F	; 111
    5518:	9f 2e       	mov	r9, r31
    551a:	97 ff       	sbrs	r25, 7
    551c:	09 c0       	rjmp	.+18     	; 0x5530 <vfprintf+0x4f0>
    551e:	90 95       	com	r25
    5520:	80 95       	com	r24
    5522:	70 95       	com	r23
    5524:	61 95       	neg	r22
    5526:	7f 4f       	sbci	r23, 0xFF	; 255
    5528:	8f 4f       	sbci	r24, 0xFF	; 255
    552a:	9f 4f       	sbci	r25, 0xFF	; 255
    552c:	f0 68       	ori	r31, 0x80	; 128
    552e:	9f 2e       	mov	r9, r31
    5530:	2a e0       	ldi	r18, 0x0A	; 10
    5532:	30 e0       	ldi	r19, 0x00	; 0
    5534:	a3 01       	movw	r20, r6
    5536:	77 d2       	rcall	.+1262   	; 0x5a26 <__ultoa_invert>
    5538:	c8 2e       	mov	r12, r24
    553a:	c6 18       	sub	r12, r6
    553c:	3e c0       	rjmp	.+124    	; 0x55ba <vfprintf+0x57a>
    553e:	09 2d       	mov	r16, r9
    5540:	85 37       	cpi	r24, 0x75	; 117
    5542:	21 f4       	brne	.+8      	; 0x554c <vfprintf+0x50c>
    5544:	0f 7e       	andi	r16, 0xEF	; 239
    5546:	2a e0       	ldi	r18, 0x0A	; 10
    5548:	30 e0       	ldi	r19, 0x00	; 0
    554a:	1d c0       	rjmp	.+58     	; 0x5586 <vfprintf+0x546>
    554c:	09 7f       	andi	r16, 0xF9	; 249
    554e:	8f 36       	cpi	r24, 0x6F	; 111
    5550:	91 f0       	breq	.+36     	; 0x5576 <vfprintf+0x536>
    5552:	18 f4       	brcc	.+6      	; 0x555a <vfprintf+0x51a>
    5554:	88 35       	cpi	r24, 0x58	; 88
    5556:	59 f0       	breq	.+22     	; 0x556e <vfprintf+0x52e>
    5558:	bc c0       	rjmp	.+376    	; 0x56d2 <vfprintf+0x692>
    555a:	80 37       	cpi	r24, 0x70	; 112
    555c:	19 f0       	breq	.+6      	; 0x5564 <vfprintf+0x524>
    555e:	88 37       	cpi	r24, 0x78	; 120
    5560:	11 f0       	breq	.+4      	; 0x5566 <vfprintf+0x526>
    5562:	b7 c0       	rjmp	.+366    	; 0x56d2 <vfprintf+0x692>
    5564:	00 61       	ori	r16, 0x10	; 16
    5566:	04 ff       	sbrs	r16, 4
    5568:	09 c0       	rjmp	.+18     	; 0x557c <vfprintf+0x53c>
    556a:	04 60       	ori	r16, 0x04	; 4
    556c:	07 c0       	rjmp	.+14     	; 0x557c <vfprintf+0x53c>
    556e:	94 fe       	sbrs	r9, 4
    5570:	08 c0       	rjmp	.+16     	; 0x5582 <vfprintf+0x542>
    5572:	06 60       	ori	r16, 0x06	; 6
    5574:	06 c0       	rjmp	.+12     	; 0x5582 <vfprintf+0x542>
    5576:	28 e0       	ldi	r18, 0x08	; 8
    5578:	30 e0       	ldi	r19, 0x00	; 0
    557a:	05 c0       	rjmp	.+10     	; 0x5586 <vfprintf+0x546>
    557c:	20 e1       	ldi	r18, 0x10	; 16
    557e:	30 e0       	ldi	r19, 0x00	; 0
    5580:	02 c0       	rjmp	.+4      	; 0x5586 <vfprintf+0x546>
    5582:	20 e1       	ldi	r18, 0x10	; 16
    5584:	32 e0       	ldi	r19, 0x02	; 2
    5586:	56 01       	movw	r10, r12
    5588:	07 ff       	sbrs	r16, 7
    558a:	09 c0       	rjmp	.+18     	; 0x559e <vfprintf+0x55e>
    558c:	84 e0       	ldi	r24, 0x04	; 4
    558e:	a8 0e       	add	r10, r24
    5590:	b1 1c       	adc	r11, r1
    5592:	f6 01       	movw	r30, r12
    5594:	60 81       	ld	r22, Z
    5596:	71 81       	ldd	r23, Z+1	; 0x01
    5598:	82 81       	ldd	r24, Z+2	; 0x02
    559a:	93 81       	ldd	r25, Z+3	; 0x03
    559c:	08 c0       	rjmp	.+16     	; 0x55ae <vfprintf+0x56e>
    559e:	f2 e0       	ldi	r31, 0x02	; 2
    55a0:	af 0e       	add	r10, r31
    55a2:	b1 1c       	adc	r11, r1
    55a4:	f6 01       	movw	r30, r12
    55a6:	60 81       	ld	r22, Z
    55a8:	71 81       	ldd	r23, Z+1	; 0x01
    55aa:	80 e0       	ldi	r24, 0x00	; 0
    55ac:	90 e0       	ldi	r25, 0x00	; 0
    55ae:	a3 01       	movw	r20, r6
    55b0:	3a d2       	rcall	.+1140   	; 0x5a26 <__ultoa_invert>
    55b2:	c8 2e       	mov	r12, r24
    55b4:	c6 18       	sub	r12, r6
    55b6:	0f 77       	andi	r16, 0x7F	; 127
    55b8:	90 2e       	mov	r9, r16
    55ba:	96 fe       	sbrs	r9, 6
    55bc:	0b c0       	rjmp	.+22     	; 0x55d4 <vfprintf+0x594>
    55be:	09 2d       	mov	r16, r9
    55c0:	0e 7f       	andi	r16, 0xFE	; 254
    55c2:	c1 16       	cp	r12, r17
    55c4:	50 f4       	brcc	.+20     	; 0x55da <vfprintf+0x59a>
    55c6:	94 fe       	sbrs	r9, 4
    55c8:	0a c0       	rjmp	.+20     	; 0x55de <vfprintf+0x59e>
    55ca:	92 fc       	sbrc	r9, 2
    55cc:	08 c0       	rjmp	.+16     	; 0x55de <vfprintf+0x59e>
    55ce:	09 2d       	mov	r16, r9
    55d0:	0e 7e       	andi	r16, 0xEE	; 238
    55d2:	05 c0       	rjmp	.+10     	; 0x55de <vfprintf+0x59e>
    55d4:	dc 2c       	mov	r13, r12
    55d6:	09 2d       	mov	r16, r9
    55d8:	03 c0       	rjmp	.+6      	; 0x55e0 <vfprintf+0x5a0>
    55da:	dc 2c       	mov	r13, r12
    55dc:	01 c0       	rjmp	.+2      	; 0x55e0 <vfprintf+0x5a0>
    55de:	d1 2e       	mov	r13, r17
    55e0:	04 ff       	sbrs	r16, 4
    55e2:	0d c0       	rjmp	.+26     	; 0x55fe <vfprintf+0x5be>
    55e4:	fe 01       	movw	r30, r28
    55e6:	ec 0d       	add	r30, r12
    55e8:	f1 1d       	adc	r31, r1
    55ea:	80 81       	ld	r24, Z
    55ec:	80 33       	cpi	r24, 0x30	; 48
    55ee:	11 f4       	brne	.+4      	; 0x55f4 <vfprintf+0x5b4>
    55f0:	09 7e       	andi	r16, 0xE9	; 233
    55f2:	09 c0       	rjmp	.+18     	; 0x5606 <vfprintf+0x5c6>
    55f4:	02 ff       	sbrs	r16, 2
    55f6:	06 c0       	rjmp	.+12     	; 0x5604 <vfprintf+0x5c4>
    55f8:	d3 94       	inc	r13
    55fa:	d3 94       	inc	r13
    55fc:	04 c0       	rjmp	.+8      	; 0x5606 <vfprintf+0x5c6>
    55fe:	80 2f       	mov	r24, r16
    5600:	86 78       	andi	r24, 0x86	; 134
    5602:	09 f0       	breq	.+2      	; 0x5606 <vfprintf+0x5c6>
    5604:	d3 94       	inc	r13
    5606:	03 fd       	sbrc	r16, 3
    5608:	10 c0       	rjmp	.+32     	; 0x562a <vfprintf+0x5ea>
    560a:	00 ff       	sbrs	r16, 0
    560c:	06 c0       	rjmp	.+12     	; 0x561a <vfprintf+0x5da>
    560e:	1c 2d       	mov	r17, r12
    5610:	d5 14       	cp	r13, r5
    5612:	78 f4       	brcc	.+30     	; 0x5632 <vfprintf+0x5f2>
    5614:	15 0d       	add	r17, r5
    5616:	1d 19       	sub	r17, r13
    5618:	0c c0       	rjmp	.+24     	; 0x5632 <vfprintf+0x5f2>
    561a:	d5 14       	cp	r13, r5
    561c:	50 f4       	brcc	.+20     	; 0x5632 <vfprintf+0x5f2>
    561e:	b7 01       	movw	r22, r14
    5620:	80 e2       	ldi	r24, 0x20	; 32
    5622:	90 e0       	ldi	r25, 0x00	; 0
    5624:	9c d1       	rcall	.+824    	; 0x595e <fputc>
    5626:	d3 94       	inc	r13
    5628:	f8 cf       	rjmp	.-16     	; 0x561a <vfprintf+0x5da>
    562a:	d5 14       	cp	r13, r5
    562c:	10 f4       	brcc	.+4      	; 0x5632 <vfprintf+0x5f2>
    562e:	5d 18       	sub	r5, r13
    5630:	01 c0       	rjmp	.+2      	; 0x5634 <vfprintf+0x5f4>
    5632:	51 2c       	mov	r5, r1
    5634:	04 ff       	sbrs	r16, 4
    5636:	0f c0       	rjmp	.+30     	; 0x5656 <vfprintf+0x616>
    5638:	b7 01       	movw	r22, r14
    563a:	80 e3       	ldi	r24, 0x30	; 48
    563c:	90 e0       	ldi	r25, 0x00	; 0
    563e:	8f d1       	rcall	.+798    	; 0x595e <fputc>
    5640:	02 ff       	sbrs	r16, 2
    5642:	16 c0       	rjmp	.+44     	; 0x5670 <vfprintf+0x630>
    5644:	01 fd       	sbrc	r16, 1
    5646:	03 c0       	rjmp	.+6      	; 0x564e <vfprintf+0x60e>
    5648:	88 e7       	ldi	r24, 0x78	; 120
    564a:	90 e0       	ldi	r25, 0x00	; 0
    564c:	02 c0       	rjmp	.+4      	; 0x5652 <vfprintf+0x612>
    564e:	88 e5       	ldi	r24, 0x58	; 88
    5650:	90 e0       	ldi	r25, 0x00	; 0
    5652:	b7 01       	movw	r22, r14
    5654:	0c c0       	rjmp	.+24     	; 0x566e <vfprintf+0x62e>
    5656:	80 2f       	mov	r24, r16
    5658:	86 78       	andi	r24, 0x86	; 134
    565a:	51 f0       	breq	.+20     	; 0x5670 <vfprintf+0x630>
    565c:	01 ff       	sbrs	r16, 1
    565e:	02 c0       	rjmp	.+4      	; 0x5664 <vfprintf+0x624>
    5660:	8b e2       	ldi	r24, 0x2B	; 43
    5662:	01 c0       	rjmp	.+2      	; 0x5666 <vfprintf+0x626>
    5664:	80 e2       	ldi	r24, 0x20	; 32
    5666:	07 fd       	sbrc	r16, 7
    5668:	8d e2       	ldi	r24, 0x2D	; 45
    566a:	b7 01       	movw	r22, r14
    566c:	90 e0       	ldi	r25, 0x00	; 0
    566e:	77 d1       	rcall	.+750    	; 0x595e <fputc>
    5670:	c1 16       	cp	r12, r17
    5672:	30 f4       	brcc	.+12     	; 0x5680 <vfprintf+0x640>
    5674:	b7 01       	movw	r22, r14
    5676:	80 e3       	ldi	r24, 0x30	; 48
    5678:	90 e0       	ldi	r25, 0x00	; 0
    567a:	71 d1       	rcall	.+738    	; 0x595e <fputc>
    567c:	11 50       	subi	r17, 0x01	; 1
    567e:	f8 cf       	rjmp	.-16     	; 0x5670 <vfprintf+0x630>
    5680:	ca 94       	dec	r12
    5682:	f3 01       	movw	r30, r6
    5684:	ec 0d       	add	r30, r12
    5686:	f1 1d       	adc	r31, r1
    5688:	80 81       	ld	r24, Z
    568a:	b7 01       	movw	r22, r14
    568c:	90 e0       	ldi	r25, 0x00	; 0
    568e:	67 d1       	rcall	.+718    	; 0x595e <fputc>
    5690:	c1 10       	cpse	r12, r1
    5692:	f6 cf       	rjmp	.-20     	; 0x5680 <vfprintf+0x640>
    5694:	15 c0       	rjmp	.+42     	; 0x56c0 <vfprintf+0x680>
    5696:	f4 e0       	ldi	r31, 0x04	; 4
    5698:	f5 15       	cp	r31, r5
    569a:	50 f5       	brcc	.+84     	; 0x56f0 <vfprintf+0x6b0>
    569c:	84 e0       	ldi	r24, 0x04	; 4
    569e:	58 1a       	sub	r5, r24
    56a0:	93 fe       	sbrs	r9, 3
    56a2:	1e c0       	rjmp	.+60     	; 0x56e0 <vfprintf+0x6a0>
    56a4:	01 11       	cpse	r16, r1
    56a6:	25 c0       	rjmp	.+74     	; 0x56f2 <vfprintf+0x6b2>
    56a8:	2c 85       	ldd	r18, Y+12	; 0x0c
    56aa:	23 ff       	sbrs	r18, 3
    56ac:	27 c0       	rjmp	.+78     	; 0x56fc <vfprintf+0x6bc>
    56ae:	04 ee       	ldi	r16, 0xE4	; 228
    56b0:	10 e0       	ldi	r17, 0x00	; 0
    56b2:	39 2d       	mov	r19, r9
    56b4:	30 71       	andi	r19, 0x10	; 16
    56b6:	93 2e       	mov	r9, r19
    56b8:	f8 01       	movw	r30, r16
    56ba:	84 91       	lpm	r24, Z
    56bc:	81 11       	cpse	r24, r1
    56be:	21 c0       	rjmp	.+66     	; 0x5702 <vfprintf+0x6c2>
    56c0:	55 20       	and	r5, r5
    56c2:	09 f4       	brne	.+2      	; 0x56c6 <vfprintf+0x686>
    56c4:	fc cc       	rjmp	.-1544   	; 0x50be <vfprintf+0x7e>
    56c6:	b7 01       	movw	r22, r14
    56c8:	80 e2       	ldi	r24, 0x20	; 32
    56ca:	90 e0       	ldi	r25, 0x00	; 0
    56cc:	48 d1       	rcall	.+656    	; 0x595e <fputc>
    56ce:	5a 94       	dec	r5
    56d0:	f7 cf       	rjmp	.-18     	; 0x56c0 <vfprintf+0x680>
    56d2:	f7 01       	movw	r30, r14
    56d4:	86 81       	ldd	r24, Z+6	; 0x06
    56d6:	97 81       	ldd	r25, Z+7	; 0x07
    56d8:	23 c0       	rjmp	.+70     	; 0x5720 <vfprintf+0x6e0>
    56da:	8f ef       	ldi	r24, 0xFF	; 255
    56dc:	9f ef       	ldi	r25, 0xFF	; 255
    56de:	20 c0       	rjmp	.+64     	; 0x5720 <vfprintf+0x6e0>
    56e0:	b7 01       	movw	r22, r14
    56e2:	80 e2       	ldi	r24, 0x20	; 32
    56e4:	90 e0       	ldi	r25, 0x00	; 0
    56e6:	3b d1       	rcall	.+630    	; 0x595e <fputc>
    56e8:	5a 94       	dec	r5
    56ea:	51 10       	cpse	r5, r1
    56ec:	f9 cf       	rjmp	.-14     	; 0x56e0 <vfprintf+0x6a0>
    56ee:	da cf       	rjmp	.-76     	; 0x56a4 <vfprintf+0x664>
    56f0:	51 2c       	mov	r5, r1
    56f2:	b7 01       	movw	r22, r14
    56f4:	80 2f       	mov	r24, r16
    56f6:	90 e0       	ldi	r25, 0x00	; 0
    56f8:	32 d1       	rcall	.+612    	; 0x595e <fputc>
    56fa:	d6 cf       	rjmp	.-84     	; 0x56a8 <vfprintf+0x668>
    56fc:	08 ee       	ldi	r16, 0xE8	; 232
    56fe:	10 e0       	ldi	r17, 0x00	; 0
    5700:	d8 cf       	rjmp	.-80     	; 0x56b2 <vfprintf+0x672>
    5702:	91 10       	cpse	r9, r1
    5704:	80 52       	subi	r24, 0x20	; 32
    5706:	b7 01       	movw	r22, r14
    5708:	90 e0       	ldi	r25, 0x00	; 0
    570a:	29 d1       	rcall	.+594    	; 0x595e <fputc>
    570c:	0f 5f       	subi	r16, 0xFF	; 255
    570e:	1f 4f       	sbci	r17, 0xFF	; 255
    5710:	d3 cf       	rjmp	.-90     	; 0x56b8 <vfprintf+0x678>
    5712:	23 e0       	ldi	r18, 0x03	; 3
    5714:	25 15       	cp	r18, r5
    5716:	10 f4       	brcc	.+4      	; 0x571c <vfprintf+0x6dc>
    5718:	83 e0       	ldi	r24, 0x03	; 3
    571a:	c1 cf       	rjmp	.-126    	; 0x569e <vfprintf+0x65e>
    571c:	51 2c       	mov	r5, r1
    571e:	c4 cf       	rjmp	.-120    	; 0x56a8 <vfprintf+0x668>
    5720:	60 96       	adiw	r28, 0x10	; 16
    5722:	0f b6       	in	r0, 0x3f	; 63
    5724:	f8 94       	cli
    5726:	de bf       	out	0x3e, r29	; 62
    5728:	0f be       	out	0x3f, r0	; 63
    572a:	cd bf       	out	0x3d, r28	; 61
    572c:	df 91       	pop	r29
    572e:	cf 91       	pop	r28
    5730:	1f 91       	pop	r17
    5732:	0f 91       	pop	r16
    5734:	ff 90       	pop	r15
    5736:	ef 90       	pop	r14
    5738:	df 90       	pop	r13
    573a:	cf 90       	pop	r12
    573c:	bf 90       	pop	r11
    573e:	af 90       	pop	r10
    5740:	9f 90       	pop	r9
    5742:	8f 90       	pop	r8
    5744:	7f 90       	pop	r7
    5746:	6f 90       	pop	r6
    5748:	5f 90       	pop	r5
    574a:	4f 90       	pop	r4
    574c:	3f 90       	pop	r3
    574e:	2f 90       	pop	r2
    5750:	08 95       	ret

00005752 <__umulhisi3>:
    5752:	a2 9f       	mul	r26, r18
    5754:	b0 01       	movw	r22, r0
    5756:	b3 9f       	mul	r27, r19
    5758:	c0 01       	movw	r24, r0
    575a:	a3 9f       	mul	r26, r19
    575c:	70 0d       	add	r23, r0
    575e:	81 1d       	adc	r24, r1
    5760:	11 24       	eor	r1, r1
    5762:	91 1d       	adc	r25, r1
    5764:	b2 9f       	mul	r27, r18
    5766:	70 0d       	add	r23, r0
    5768:	81 1d       	adc	r24, r1
    576a:	11 24       	eor	r1, r1
    576c:	91 1d       	adc	r25, r1
    576e:	08 95       	ret

00005770 <__ftoa_engine>:
    5770:	28 30       	cpi	r18, 0x08	; 8
    5772:	08 f0       	brcs	.+2      	; 0x5776 <__ftoa_engine+0x6>
    5774:	27 e0       	ldi	r18, 0x07	; 7
    5776:	33 27       	eor	r19, r19
    5778:	da 01       	movw	r26, r20
    577a:	99 0f       	add	r25, r25
    577c:	31 1d       	adc	r19, r1
    577e:	87 fd       	sbrc	r24, 7
    5780:	91 60       	ori	r25, 0x01	; 1
    5782:	00 96       	adiw	r24, 0x00	; 0
    5784:	61 05       	cpc	r22, r1
    5786:	71 05       	cpc	r23, r1
    5788:	39 f4       	brne	.+14     	; 0x5798 <__ftoa_engine+0x28>
    578a:	32 60       	ori	r19, 0x02	; 2
    578c:	2e 5f       	subi	r18, 0xFE	; 254
    578e:	3d 93       	st	X+, r19
    5790:	30 e3       	ldi	r19, 0x30	; 48
    5792:	2a 95       	dec	r18
    5794:	e1 f7       	brne	.-8      	; 0x578e <__ftoa_engine+0x1e>
    5796:	08 95       	ret
    5798:	9f 3f       	cpi	r25, 0xFF	; 255
    579a:	30 f0       	brcs	.+12     	; 0x57a8 <__ftoa_engine+0x38>
    579c:	80 38       	cpi	r24, 0x80	; 128
    579e:	71 05       	cpc	r23, r1
    57a0:	61 05       	cpc	r22, r1
    57a2:	09 f0       	breq	.+2      	; 0x57a6 <__ftoa_engine+0x36>
    57a4:	3c 5f       	subi	r19, 0xFC	; 252
    57a6:	3c 5f       	subi	r19, 0xFC	; 252
    57a8:	3d 93       	st	X+, r19
    57aa:	91 30       	cpi	r25, 0x01	; 1
    57ac:	08 f0       	brcs	.+2      	; 0x57b0 <__ftoa_engine+0x40>
    57ae:	80 68       	ori	r24, 0x80	; 128
    57b0:	91 1d       	adc	r25, r1
    57b2:	df 93       	push	r29
    57b4:	cf 93       	push	r28
    57b6:	1f 93       	push	r17
    57b8:	0f 93       	push	r16
    57ba:	ff 92       	push	r15
    57bc:	ef 92       	push	r14
    57be:	19 2f       	mov	r17, r25
    57c0:	98 7f       	andi	r25, 0xF8	; 248
    57c2:	96 95       	lsr	r25
    57c4:	e9 2f       	mov	r30, r25
    57c6:	96 95       	lsr	r25
    57c8:	96 95       	lsr	r25
    57ca:	e9 0f       	add	r30, r25
    57cc:	ff 27       	eor	r31, r31
    57ce:	ea 5b       	subi	r30, 0xBA	; 186
    57d0:	fe 4f       	sbci	r31, 0xFE	; 254
    57d2:	99 27       	eor	r25, r25
    57d4:	33 27       	eor	r19, r19
    57d6:	ee 24       	eor	r14, r14
    57d8:	ff 24       	eor	r15, r15
    57da:	a7 01       	movw	r20, r14
    57dc:	e7 01       	movw	r28, r14
    57de:	05 90       	lpm	r0, Z+
    57e0:	08 94       	sec
    57e2:	07 94       	ror	r0
    57e4:	28 f4       	brcc	.+10     	; 0x57f0 <__ftoa_engine+0x80>
    57e6:	36 0f       	add	r19, r22
    57e8:	e7 1e       	adc	r14, r23
    57ea:	f8 1e       	adc	r15, r24
    57ec:	49 1f       	adc	r20, r25
    57ee:	51 1d       	adc	r21, r1
    57f0:	66 0f       	add	r22, r22
    57f2:	77 1f       	adc	r23, r23
    57f4:	88 1f       	adc	r24, r24
    57f6:	99 1f       	adc	r25, r25
    57f8:	06 94       	lsr	r0
    57fa:	a1 f7       	brne	.-24     	; 0x57e4 <__ftoa_engine+0x74>
    57fc:	05 90       	lpm	r0, Z+
    57fe:	07 94       	ror	r0
    5800:	28 f4       	brcc	.+10     	; 0x580c <__ftoa_engine+0x9c>
    5802:	e7 0e       	add	r14, r23
    5804:	f8 1e       	adc	r15, r24
    5806:	49 1f       	adc	r20, r25
    5808:	56 1f       	adc	r21, r22
    580a:	c1 1d       	adc	r28, r1
    580c:	77 0f       	add	r23, r23
    580e:	88 1f       	adc	r24, r24
    5810:	99 1f       	adc	r25, r25
    5812:	66 1f       	adc	r22, r22
    5814:	06 94       	lsr	r0
    5816:	a1 f7       	brne	.-24     	; 0x5800 <__ftoa_engine+0x90>
    5818:	05 90       	lpm	r0, Z+
    581a:	07 94       	ror	r0
    581c:	28 f4       	brcc	.+10     	; 0x5828 <__ftoa_engine+0xb8>
    581e:	f8 0e       	add	r15, r24
    5820:	49 1f       	adc	r20, r25
    5822:	56 1f       	adc	r21, r22
    5824:	c7 1f       	adc	r28, r23
    5826:	d1 1d       	adc	r29, r1
    5828:	88 0f       	add	r24, r24
    582a:	99 1f       	adc	r25, r25
    582c:	66 1f       	adc	r22, r22
    582e:	77 1f       	adc	r23, r23
    5830:	06 94       	lsr	r0
    5832:	a1 f7       	brne	.-24     	; 0x581c <__ftoa_engine+0xac>
    5834:	05 90       	lpm	r0, Z+
    5836:	07 94       	ror	r0
    5838:	20 f4       	brcc	.+8      	; 0x5842 <__ftoa_engine+0xd2>
    583a:	49 0f       	add	r20, r25
    583c:	56 1f       	adc	r21, r22
    583e:	c7 1f       	adc	r28, r23
    5840:	d8 1f       	adc	r29, r24
    5842:	99 0f       	add	r25, r25
    5844:	66 1f       	adc	r22, r22
    5846:	77 1f       	adc	r23, r23
    5848:	88 1f       	adc	r24, r24
    584a:	06 94       	lsr	r0
    584c:	a9 f7       	brne	.-22     	; 0x5838 <__ftoa_engine+0xc8>
    584e:	84 91       	lpm	r24, Z
    5850:	10 95       	com	r17
    5852:	17 70       	andi	r17, 0x07	; 7
    5854:	41 f0       	breq	.+16     	; 0x5866 <__ftoa_engine+0xf6>
    5856:	d6 95       	lsr	r29
    5858:	c7 95       	ror	r28
    585a:	57 95       	ror	r21
    585c:	47 95       	ror	r20
    585e:	f7 94       	ror	r15
    5860:	e7 94       	ror	r14
    5862:	1a 95       	dec	r17
    5864:	c1 f7       	brne	.-16     	; 0x5856 <__ftoa_engine+0xe6>
    5866:	ec ee       	ldi	r30, 0xEC	; 236
    5868:	f0 e0       	ldi	r31, 0x00	; 0
    586a:	68 94       	set
    586c:	15 90       	lpm	r1, Z+
    586e:	15 91       	lpm	r17, Z+
    5870:	35 91       	lpm	r19, Z+
    5872:	65 91       	lpm	r22, Z+
    5874:	95 91       	lpm	r25, Z+
    5876:	05 90       	lpm	r0, Z+
    5878:	7f e2       	ldi	r23, 0x2F	; 47
    587a:	73 95       	inc	r23
    587c:	e1 18       	sub	r14, r1
    587e:	f1 0a       	sbc	r15, r17
    5880:	43 0b       	sbc	r20, r19
    5882:	56 0b       	sbc	r21, r22
    5884:	c9 0b       	sbc	r28, r25
    5886:	d0 09       	sbc	r29, r0
    5888:	c0 f7       	brcc	.-16     	; 0x587a <__ftoa_engine+0x10a>
    588a:	e1 0c       	add	r14, r1
    588c:	f1 1e       	adc	r15, r17
    588e:	43 1f       	adc	r20, r19
    5890:	56 1f       	adc	r21, r22
    5892:	c9 1f       	adc	r28, r25
    5894:	d0 1d       	adc	r29, r0
    5896:	7e f4       	brtc	.+30     	; 0x58b6 <__ftoa_engine+0x146>
    5898:	70 33       	cpi	r23, 0x30	; 48
    589a:	11 f4       	brne	.+4      	; 0x58a0 <__ftoa_engine+0x130>
    589c:	8a 95       	dec	r24
    589e:	e6 cf       	rjmp	.-52     	; 0x586c <__ftoa_engine+0xfc>
    58a0:	e8 94       	clt
    58a2:	01 50       	subi	r16, 0x01	; 1
    58a4:	30 f0       	brcs	.+12     	; 0x58b2 <__ftoa_engine+0x142>
    58a6:	08 0f       	add	r16, r24
    58a8:	0a f4       	brpl	.+2      	; 0x58ac <__ftoa_engine+0x13c>
    58aa:	00 27       	eor	r16, r16
    58ac:	02 17       	cp	r16, r18
    58ae:	08 f4       	brcc	.+2      	; 0x58b2 <__ftoa_engine+0x142>
    58b0:	20 2f       	mov	r18, r16
    58b2:	23 95       	inc	r18
    58b4:	02 2f       	mov	r16, r18
    58b6:	7a 33       	cpi	r23, 0x3A	; 58
    58b8:	28 f0       	brcs	.+10     	; 0x58c4 <__ftoa_engine+0x154>
    58ba:	79 e3       	ldi	r23, 0x39	; 57
    58bc:	7d 93       	st	X+, r23
    58be:	2a 95       	dec	r18
    58c0:	e9 f7       	brne	.-6      	; 0x58bc <__ftoa_engine+0x14c>
    58c2:	10 c0       	rjmp	.+32     	; 0x58e4 <__ftoa_engine+0x174>
    58c4:	7d 93       	st	X+, r23
    58c6:	2a 95       	dec	r18
    58c8:	89 f6       	brne	.-94     	; 0x586c <__ftoa_engine+0xfc>
    58ca:	06 94       	lsr	r0
    58cc:	97 95       	ror	r25
    58ce:	67 95       	ror	r22
    58d0:	37 95       	ror	r19
    58d2:	17 95       	ror	r17
    58d4:	17 94       	ror	r1
    58d6:	e1 18       	sub	r14, r1
    58d8:	f1 0a       	sbc	r15, r17
    58da:	43 0b       	sbc	r20, r19
    58dc:	56 0b       	sbc	r21, r22
    58de:	c9 0b       	sbc	r28, r25
    58e0:	d0 09       	sbc	r29, r0
    58e2:	98 f0       	brcs	.+38     	; 0x590a <__ftoa_engine+0x19a>
    58e4:	23 95       	inc	r18
    58e6:	7e 91       	ld	r23, -X
    58e8:	73 95       	inc	r23
    58ea:	7a 33       	cpi	r23, 0x3A	; 58
    58ec:	08 f0       	brcs	.+2      	; 0x58f0 <__ftoa_engine+0x180>
    58ee:	70 e3       	ldi	r23, 0x30	; 48
    58f0:	7c 93       	st	X, r23
    58f2:	20 13       	cpse	r18, r16
    58f4:	b8 f7       	brcc	.-18     	; 0x58e4 <__ftoa_engine+0x174>
    58f6:	7e 91       	ld	r23, -X
    58f8:	70 61       	ori	r23, 0x10	; 16
    58fa:	7d 93       	st	X+, r23
    58fc:	30 f0       	brcs	.+12     	; 0x590a <__ftoa_engine+0x19a>
    58fe:	83 95       	inc	r24
    5900:	71 e3       	ldi	r23, 0x31	; 49
    5902:	7d 93       	st	X+, r23
    5904:	70 e3       	ldi	r23, 0x30	; 48
    5906:	2a 95       	dec	r18
    5908:	e1 f7       	brne	.-8      	; 0x5902 <__ftoa_engine+0x192>
    590a:	11 24       	eor	r1, r1
    590c:	ef 90       	pop	r14
    590e:	ff 90       	pop	r15
    5910:	0f 91       	pop	r16
    5912:	1f 91       	pop	r17
    5914:	cf 91       	pop	r28
    5916:	df 91       	pop	r29
    5918:	99 27       	eor	r25, r25
    591a:	87 fd       	sbrc	r24, 7
    591c:	90 95       	com	r25
    591e:	08 95       	ret

00005920 <strnlen_P>:
    5920:	fc 01       	movw	r30, r24
    5922:	05 90       	lpm	r0, Z+
    5924:	61 50       	subi	r22, 0x01	; 1
    5926:	70 40       	sbci	r23, 0x00	; 0
    5928:	01 10       	cpse	r0, r1
    592a:	d8 f7       	brcc	.-10     	; 0x5922 <strnlen_P+0x2>
    592c:	80 95       	com	r24
    592e:	90 95       	com	r25
    5930:	8e 0f       	add	r24, r30
    5932:	9f 1f       	adc	r25, r31
    5934:	08 95       	ret

00005936 <memcpy>:
    5936:	fb 01       	movw	r30, r22
    5938:	dc 01       	movw	r26, r24
    593a:	02 c0       	rjmp	.+4      	; 0x5940 <memcpy+0xa>
    593c:	01 90       	ld	r0, Z+
    593e:	0d 92       	st	X+, r0
    5940:	41 50       	subi	r20, 0x01	; 1
    5942:	50 40       	sbci	r21, 0x00	; 0
    5944:	d8 f7       	brcc	.-10     	; 0x593c <memcpy+0x6>
    5946:	08 95       	ret

00005948 <strnlen>:
    5948:	fc 01       	movw	r30, r24
    594a:	61 50       	subi	r22, 0x01	; 1
    594c:	70 40       	sbci	r23, 0x00	; 0
    594e:	01 90       	ld	r0, Z+
    5950:	01 10       	cpse	r0, r1
    5952:	d8 f7       	brcc	.-10     	; 0x594a <strnlen+0x2>
    5954:	80 95       	com	r24
    5956:	90 95       	com	r25
    5958:	8e 0f       	add	r24, r30
    595a:	9f 1f       	adc	r25, r31
    595c:	08 95       	ret

0000595e <fputc>:
    595e:	0f 93       	push	r16
    5960:	1f 93       	push	r17
    5962:	cf 93       	push	r28
    5964:	df 93       	push	r29
    5966:	fb 01       	movw	r30, r22
    5968:	23 81       	ldd	r18, Z+3	; 0x03
    596a:	21 fd       	sbrc	r18, 1
    596c:	03 c0       	rjmp	.+6      	; 0x5974 <fputc+0x16>
    596e:	8f ef       	ldi	r24, 0xFF	; 255
    5970:	9f ef       	ldi	r25, 0xFF	; 255
    5972:	2c c0       	rjmp	.+88     	; 0x59cc <fputc+0x6e>
    5974:	22 ff       	sbrs	r18, 2
    5976:	16 c0       	rjmp	.+44     	; 0x59a4 <fputc+0x46>
    5978:	46 81       	ldd	r20, Z+6	; 0x06
    597a:	57 81       	ldd	r21, Z+7	; 0x07
    597c:	24 81       	ldd	r18, Z+4	; 0x04
    597e:	35 81       	ldd	r19, Z+5	; 0x05
    5980:	42 17       	cp	r20, r18
    5982:	53 07       	cpc	r21, r19
    5984:	44 f4       	brge	.+16     	; 0x5996 <fputc+0x38>
    5986:	a0 81       	ld	r26, Z
    5988:	b1 81       	ldd	r27, Z+1	; 0x01
    598a:	9d 01       	movw	r18, r26
    598c:	2f 5f       	subi	r18, 0xFF	; 255
    598e:	3f 4f       	sbci	r19, 0xFF	; 255
    5990:	31 83       	std	Z+1, r19	; 0x01
    5992:	20 83       	st	Z, r18
    5994:	8c 93       	st	X, r24
    5996:	26 81       	ldd	r18, Z+6	; 0x06
    5998:	37 81       	ldd	r19, Z+7	; 0x07
    599a:	2f 5f       	subi	r18, 0xFF	; 255
    599c:	3f 4f       	sbci	r19, 0xFF	; 255
    599e:	37 83       	std	Z+7, r19	; 0x07
    59a0:	26 83       	std	Z+6, r18	; 0x06
    59a2:	14 c0       	rjmp	.+40     	; 0x59cc <fputc+0x6e>
    59a4:	8b 01       	movw	r16, r22
    59a6:	ec 01       	movw	r28, r24
    59a8:	fb 01       	movw	r30, r22
    59aa:	00 84       	ldd	r0, Z+8	; 0x08
    59ac:	f1 85       	ldd	r31, Z+9	; 0x09
    59ae:	e0 2d       	mov	r30, r0
    59b0:	19 95       	eicall
    59b2:	89 2b       	or	r24, r25
    59b4:	e1 f6       	brne	.-72     	; 0x596e <fputc+0x10>
    59b6:	d8 01       	movw	r26, r16
    59b8:	16 96       	adiw	r26, 0x06	; 6
    59ba:	8d 91       	ld	r24, X+
    59bc:	9c 91       	ld	r25, X
    59be:	17 97       	sbiw	r26, 0x07	; 7
    59c0:	01 96       	adiw	r24, 0x01	; 1
    59c2:	17 96       	adiw	r26, 0x07	; 7
    59c4:	9c 93       	st	X, r25
    59c6:	8e 93       	st	-X, r24
    59c8:	16 97       	sbiw	r26, 0x06	; 6
    59ca:	ce 01       	movw	r24, r28
    59cc:	df 91       	pop	r29
    59ce:	cf 91       	pop	r28
    59d0:	1f 91       	pop	r17
    59d2:	0f 91       	pop	r16
    59d4:	08 95       	ret

000059d6 <vsprintf>:
    59d6:	0f 93       	push	r16
    59d8:	1f 93       	push	r17
    59da:	cf 93       	push	r28
    59dc:	df 93       	push	r29
    59de:	cd b7       	in	r28, 0x3d	; 61
    59e0:	de b7       	in	r29, 0x3e	; 62
    59e2:	2e 97       	sbiw	r28, 0x0e	; 14
    59e4:	0f b6       	in	r0, 0x3f	; 63
    59e6:	f8 94       	cli
    59e8:	de bf       	out	0x3e, r29	; 62
    59ea:	0f be       	out	0x3f, r0	; 63
    59ec:	cd bf       	out	0x3d, r28	; 61
    59ee:	8c 01       	movw	r16, r24
    59f0:	86 e0       	ldi	r24, 0x06	; 6
    59f2:	8c 83       	std	Y+4, r24	; 0x04
    59f4:	1a 83       	std	Y+2, r17	; 0x02
    59f6:	09 83       	std	Y+1, r16	; 0x01
    59f8:	8f ef       	ldi	r24, 0xFF	; 255
    59fa:	9f e7       	ldi	r25, 0x7F	; 127
    59fc:	9e 83       	std	Y+6, r25	; 0x06
    59fe:	8d 83       	std	Y+5, r24	; 0x05
    5a00:	ce 01       	movw	r24, r28
    5a02:	01 96       	adiw	r24, 0x01	; 1
    5a04:	1d db       	rcall	.-2502   	; 0x5040 <vfprintf>
    5a06:	ef 81       	ldd	r30, Y+7	; 0x07
    5a08:	f8 85       	ldd	r31, Y+8	; 0x08
    5a0a:	e0 0f       	add	r30, r16
    5a0c:	f1 1f       	adc	r31, r17
    5a0e:	10 82       	st	Z, r1
    5a10:	2e 96       	adiw	r28, 0x0e	; 14
    5a12:	0f b6       	in	r0, 0x3f	; 63
    5a14:	f8 94       	cli
    5a16:	de bf       	out	0x3e, r29	; 62
    5a18:	0f be       	out	0x3f, r0	; 63
    5a1a:	cd bf       	out	0x3d, r28	; 61
    5a1c:	df 91       	pop	r29
    5a1e:	cf 91       	pop	r28
    5a20:	1f 91       	pop	r17
    5a22:	0f 91       	pop	r16
    5a24:	08 95       	ret

00005a26 <__ultoa_invert>:
    5a26:	fa 01       	movw	r30, r20
    5a28:	aa 27       	eor	r26, r26
    5a2a:	28 30       	cpi	r18, 0x08	; 8
    5a2c:	51 f1       	breq	.+84     	; 0x5a82 <__ultoa_invert+0x5c>
    5a2e:	20 31       	cpi	r18, 0x10	; 16
    5a30:	81 f1       	breq	.+96     	; 0x5a92 <__ultoa_invert+0x6c>
    5a32:	e8 94       	clt
    5a34:	6f 93       	push	r22
    5a36:	6e 7f       	andi	r22, 0xFE	; 254
    5a38:	6e 5f       	subi	r22, 0xFE	; 254
    5a3a:	7f 4f       	sbci	r23, 0xFF	; 255
    5a3c:	8f 4f       	sbci	r24, 0xFF	; 255
    5a3e:	9f 4f       	sbci	r25, 0xFF	; 255
    5a40:	af 4f       	sbci	r26, 0xFF	; 255
    5a42:	b1 e0       	ldi	r27, 0x01	; 1
    5a44:	3e d0       	rcall	.+124    	; 0x5ac2 <__ultoa_invert+0x9c>
    5a46:	b4 e0       	ldi	r27, 0x04	; 4
    5a48:	3c d0       	rcall	.+120    	; 0x5ac2 <__ultoa_invert+0x9c>
    5a4a:	67 0f       	add	r22, r23
    5a4c:	78 1f       	adc	r23, r24
    5a4e:	89 1f       	adc	r24, r25
    5a50:	9a 1f       	adc	r25, r26
    5a52:	a1 1d       	adc	r26, r1
    5a54:	68 0f       	add	r22, r24
    5a56:	79 1f       	adc	r23, r25
    5a58:	8a 1f       	adc	r24, r26
    5a5a:	91 1d       	adc	r25, r1
    5a5c:	a1 1d       	adc	r26, r1
    5a5e:	6a 0f       	add	r22, r26
    5a60:	71 1d       	adc	r23, r1
    5a62:	81 1d       	adc	r24, r1
    5a64:	91 1d       	adc	r25, r1
    5a66:	a1 1d       	adc	r26, r1
    5a68:	20 d0       	rcall	.+64     	; 0x5aaa <__ultoa_invert+0x84>
    5a6a:	09 f4       	brne	.+2      	; 0x5a6e <__ultoa_invert+0x48>
    5a6c:	68 94       	set
    5a6e:	3f 91       	pop	r19
    5a70:	2a e0       	ldi	r18, 0x0A	; 10
    5a72:	26 9f       	mul	r18, r22
    5a74:	11 24       	eor	r1, r1
    5a76:	30 19       	sub	r19, r0
    5a78:	30 5d       	subi	r19, 0xD0	; 208
    5a7a:	31 93       	st	Z+, r19
    5a7c:	de f6       	brtc	.-74     	; 0x5a34 <__ultoa_invert+0xe>
    5a7e:	cf 01       	movw	r24, r30
    5a80:	08 95       	ret
    5a82:	46 2f       	mov	r20, r22
    5a84:	47 70       	andi	r20, 0x07	; 7
    5a86:	40 5d       	subi	r20, 0xD0	; 208
    5a88:	41 93       	st	Z+, r20
    5a8a:	b3 e0       	ldi	r27, 0x03	; 3
    5a8c:	0f d0       	rcall	.+30     	; 0x5aac <__ultoa_invert+0x86>
    5a8e:	c9 f7       	brne	.-14     	; 0x5a82 <__ultoa_invert+0x5c>
    5a90:	f6 cf       	rjmp	.-20     	; 0x5a7e <__ultoa_invert+0x58>
    5a92:	46 2f       	mov	r20, r22
    5a94:	4f 70       	andi	r20, 0x0F	; 15
    5a96:	40 5d       	subi	r20, 0xD0	; 208
    5a98:	4a 33       	cpi	r20, 0x3A	; 58
    5a9a:	18 f0       	brcs	.+6      	; 0x5aa2 <__ultoa_invert+0x7c>
    5a9c:	49 5d       	subi	r20, 0xD9	; 217
    5a9e:	31 fd       	sbrc	r19, 1
    5aa0:	40 52       	subi	r20, 0x20	; 32
    5aa2:	41 93       	st	Z+, r20
    5aa4:	02 d0       	rcall	.+4      	; 0x5aaa <__ultoa_invert+0x84>
    5aa6:	a9 f7       	brne	.-22     	; 0x5a92 <__ultoa_invert+0x6c>
    5aa8:	ea cf       	rjmp	.-44     	; 0x5a7e <__ultoa_invert+0x58>
    5aaa:	b4 e0       	ldi	r27, 0x04	; 4
    5aac:	a6 95       	lsr	r26
    5aae:	97 95       	ror	r25
    5ab0:	87 95       	ror	r24
    5ab2:	77 95       	ror	r23
    5ab4:	67 95       	ror	r22
    5ab6:	ba 95       	dec	r27
    5ab8:	c9 f7       	brne	.-14     	; 0x5aac <__ultoa_invert+0x86>
    5aba:	00 97       	sbiw	r24, 0x00	; 0
    5abc:	61 05       	cpc	r22, r1
    5abe:	71 05       	cpc	r23, r1
    5ac0:	08 95       	ret
    5ac2:	9b 01       	movw	r18, r22
    5ac4:	ac 01       	movw	r20, r24
    5ac6:	0a 2e       	mov	r0, r26
    5ac8:	06 94       	lsr	r0
    5aca:	57 95       	ror	r21
    5acc:	47 95       	ror	r20
    5ace:	37 95       	ror	r19
    5ad0:	27 95       	ror	r18
    5ad2:	ba 95       	dec	r27
    5ad4:	c9 f7       	brne	.-14     	; 0x5ac8 <__ultoa_invert+0xa2>
    5ad6:	62 0f       	add	r22, r18
    5ad8:	73 1f       	adc	r23, r19
    5ada:	84 1f       	adc	r24, r20
    5adc:	95 1f       	adc	r25, r21
    5ade:	a0 1d       	adc	r26, r0
    5ae0:	08 95       	ret

00005ae2 <_exit>:
    5ae2:	f8 94       	cli

00005ae4 <__stop_program>:
    5ae4:	ff cf       	rjmp	.-2      	; 0x5ae4 <__stop_program>
