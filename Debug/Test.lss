
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000ee  00800200  00004390  00004424  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00004390  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000014b1  008002ee  008002ee  00004512  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  00004512  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00004570  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000728  00000000  00000000  000045b0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00009ea4  00000000  00000000  00004cd8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000020f7  00000000  00000000  0000eb7c  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005c09  00000000  00000000  00010c73  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000016f4  00000000  00000000  0001687c  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002d98  00000000  00000000  00017f70  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    000099fd  00000000  00000000  0001ad08  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000820  00000000  00000000  00024705  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f2 c0       	rjmp	.+484    	; 0x1e6 <__ctors_end>
       2:	00 00       	nop
       4:	11 c1       	rjmp	.+546    	; 0x228 <__bad_interrupt>
       6:	00 00       	nop
       8:	0f c1       	rjmp	.+542    	; 0x228 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 83 09 	jmp	0x1306	; 0x1306 <__vector_3>
      10:	0c 94 72 09 	jmp	0x12e4	; 0x12e4 <__vector_4>
      14:	0c 94 94 09 	jmp	0x1328	; 0x1328 <__vector_5>
      18:	07 c1       	rjmp	.+526    	; 0x228 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	05 c1       	rjmp	.+522    	; 0x228 <__bad_interrupt>
      1e:	00 00       	nop
      20:	03 c1       	rjmp	.+518    	; 0x228 <__bad_interrupt>
      22:	00 00       	nop
      24:	01 c1       	rjmp	.+514    	; 0x228 <__bad_interrupt>
      26:	00 00       	nop
      28:	ff c0       	rjmp	.+510    	; 0x228 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	fd c0       	rjmp	.+506    	; 0x228 <__bad_interrupt>
      2e:	00 00       	nop
      30:	fb c0       	rjmp	.+502    	; 0x228 <__bad_interrupt>
      32:	00 00       	nop
      34:	f9 c0       	rjmp	.+498    	; 0x228 <__bad_interrupt>
      36:	00 00       	nop
      38:	f7 c0       	rjmp	.+494    	; 0x228 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	f5 c0       	rjmp	.+490    	; 0x228 <__bad_interrupt>
      3e:	00 00       	nop
      40:	f3 c0       	rjmp	.+486    	; 0x228 <__bad_interrupt>
      42:	00 00       	nop
      44:	f1 c0       	rjmp	.+482    	; 0x228 <__bad_interrupt>
      46:	00 00       	nop
      48:	ef c0       	rjmp	.+478    	; 0x228 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ed c0       	rjmp	.+474    	; 0x228 <__bad_interrupt>
      4e:	00 00       	nop
      50:	eb c0       	rjmp	.+470    	; 0x228 <__bad_interrupt>
      52:	00 00       	nop
      54:	e9 c0       	rjmp	.+466    	; 0x228 <__bad_interrupt>
      56:	00 00       	nop
      58:	e7 c0       	rjmp	.+462    	; 0x228 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	e5 c0       	rjmp	.+458    	; 0x228 <__bad_interrupt>
      5e:	00 00       	nop
      60:	e3 c0       	rjmp	.+454    	; 0x228 <__bad_interrupt>
      62:	00 00       	nop
      64:	e1 c0       	rjmp	.+450    	; 0x228 <__bad_interrupt>
      66:	00 00       	nop
      68:	df c0       	rjmp	.+446    	; 0x228 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	dd c0       	rjmp	.+442    	; 0x228 <__bad_interrupt>
      6e:	00 00       	nop
      70:	db c0       	rjmp	.+438    	; 0x228 <__bad_interrupt>
      72:	00 00       	nop
      74:	d9 c0       	rjmp	.+434    	; 0x228 <__bad_interrupt>
      76:	00 00       	nop
      78:	d7 c0       	rjmp	.+430    	; 0x228 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	d5 c0       	rjmp	.+426    	; 0x228 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 42 0c 	jmp	0x1884	; 0x1884 <__vector_32>
      84:	d1 c0       	rjmp	.+418    	; 0x228 <__bad_interrupt>
      86:	00 00       	nop
      88:	cf c0       	rjmp	.+414    	; 0x228 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	cd c0       	rjmp	.+410    	; 0x228 <__bad_interrupt>
      8e:	00 00       	nop
      90:	cb c0       	rjmp	.+406    	; 0x228 <__bad_interrupt>
      92:	00 00       	nop
      94:	c9 c0       	rjmp	.+402    	; 0x228 <__bad_interrupt>
      96:	00 00       	nop
      98:	c7 c0       	rjmp	.+398    	; 0x228 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	c5 c0       	rjmp	.+394    	; 0x228 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	c3 c0       	rjmp	.+390    	; 0x228 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c1 c0       	rjmp	.+386    	; 0x228 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	bf c0       	rjmp	.+382    	; 0x228 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	bd c0       	rjmp	.+378    	; 0x228 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	bb c0       	rjmp	.+374    	; 0x228 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	b9 c0       	rjmp	.+370    	; 0x228 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	b7 c0       	rjmp	.+366    	; 0x228 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	b5 c0       	rjmp	.+362    	; 0x228 <__bad_interrupt>
      be:	00 00       	nop
      c0:	b3 c0       	rjmp	.+358    	; 0x228 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b1 c0       	rjmp	.+354    	; 0x228 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	af c0       	rjmp	.+350    	; 0x228 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 0a 1c 	jmp	0x3814	; 0x3814 <__vector_51>
      d0:	ab c0       	rjmp	.+342    	; 0x228 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	a9 c0       	rjmp	.+338    	; 0x228 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	a7 c0       	rjmp	.+334    	; 0x228 <__bad_interrupt>
      da:	00 00       	nop
      dc:	a5 c0       	rjmp	.+330    	; 0x228 <__bad_interrupt>
      de:	00 00       	nop
      e0:	a3 c0       	rjmp	.+326    	; 0x228 <__bad_interrupt>
	...

000000e4 <__trampolines_end>:
      e4:	6e 61       	ori	r22, 0x1E	; 30
      e6:	6e 00       	.word	0x006e	; ????

000000e8 <__c.2332>:
      e8:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
      f8:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     108:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     118:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     128:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     138:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     148:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     158:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     168:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     178:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     188:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     198:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1a8:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     1b8:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     1c8:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     1d8:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

000001e6 <__ctors_end>:
     1e6:	11 24       	eor	r1, r1
     1e8:	1f be       	out	0x3f, r1	; 63
     1ea:	cf ef       	ldi	r28, 0xFF	; 255
     1ec:	d1 e2       	ldi	r29, 0x21	; 33
     1ee:	de bf       	out	0x3e, r29	; 62
     1f0:	cd bf       	out	0x3d, r28	; 61
     1f2:	00 e0       	ldi	r16, 0x00	; 0
     1f4:	0c bf       	out	0x3c, r16	; 60

000001f6 <__do_copy_data>:
     1f6:	12 e0       	ldi	r17, 0x02	; 2
     1f8:	a0 e0       	ldi	r26, 0x00	; 0
     1fa:	b2 e0       	ldi	r27, 0x02	; 2
     1fc:	e0 e9       	ldi	r30, 0x90	; 144
     1fe:	f3 e4       	ldi	r31, 0x43	; 67
     200:	00 e0       	ldi	r16, 0x00	; 0
     202:	0b bf       	out	0x3b, r16	; 59
     204:	02 c0       	rjmp	.+4      	; 0x20a <__do_copy_data+0x14>
     206:	07 90       	elpm	r0, Z+
     208:	0d 92       	st	X+, r0
     20a:	ae 3e       	cpi	r26, 0xEE	; 238
     20c:	b1 07       	cpc	r27, r17
     20e:	d9 f7       	brne	.-10     	; 0x206 <__do_copy_data+0x10>

00000210 <__do_clear_bss>:
     210:	27 e1       	ldi	r18, 0x17	; 23
     212:	ae ee       	ldi	r26, 0xEE	; 238
     214:	b2 e0       	ldi	r27, 0x02	; 2
     216:	01 c0       	rjmp	.+2      	; 0x21a <.do_clear_bss_start>

00000218 <.do_clear_bss_loop>:
     218:	1d 92       	st	X+, r1

0000021a <.do_clear_bss_start>:
     21a:	af 39       	cpi	r26, 0x9F	; 159
     21c:	b2 07       	cpc	r27, r18
     21e:	e1 f7       	brne	.-8      	; 0x218 <.do_clear_bss_loop>
     220:	0e 94 4b 09 	call	0x1296	; 0x1296 <main>
     224:	0c 94 c6 21 	jmp	0x438c	; 0x438c <_exit>

00000228 <__bad_interrupt>:
     228:	eb ce       	rjmp	.-554    	; 0x0 <__vectors>

0000022a <arq_init>:
    con->sequence_number = (con->sequence_number+1) & 127;
    network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
  } 
  
  xSemaphoreGive(con->mutex);
}
     22a:	cf 93       	push	r28
     22c:	df 93       	push	r29
     22e:	6a e3       	ldi	r22, 0x3A	; 58
     230:	72 e0       	ldi	r23, 0x02	; 2
     232:	81 e0       	ldi	r24, 0x01	; 1
     234:	0e 94 84 0a 	call	0x1508	; 0x1508 <network_set_callback>
     238:	10 92 ef 02 	sts	0x02EF, r1	; 0x8002ef <__data_end+0x1>
     23c:	10 92 ee 02 	sts	0x02EE, r1	; 0x8002ee <__data_end>
     240:	c0 ef       	ldi	r28, 0xF0	; 240
     242:	d2 e0       	ldi	r29, 0x02	; 2
     244:	8d e8       	ldi	r24, 0x8D	; 141
     246:	fe 01       	movw	r30, r28
     248:	11 92       	st	Z+, r1
     24a:	8a 95       	dec	r24
     24c:	e9 f7       	brne	.-6      	; 0x248 <arq_init+0x1e>
     24e:	81 e0       	ldi	r24, 0x01	; 1
     250:	0e 94 44 0c 	call	0x1888	; 0x1888 <xQueueCreateMutex>
     254:	90 93 7a 03 	sts	0x037A, r25	; 0x80037a <connections+0x8a>
     258:	80 93 79 03 	sts	0x0379, r24	; 0x800379 <connections+0x89>
     25c:	18 82       	st	Y, r1
     25e:	df 91       	pop	r29
     260:	cf 91       	pop	r28
     262:	08 95       	ret

00000264 <arq_send>:
     264:	ef 92       	push	r14
     266:	ff 92       	push	r15
     268:	0f 93       	push	r16
     26a:	1f 93       	push	r17
     26c:	cf 93       	push	r28
     26e:	df 93       	push	r29
     270:	00 d0       	rcall	.+0      	; 0x272 <arq_send+0xe>
     272:	1f 92       	push	r1
     274:	cd b7       	in	r28, 0x3d	; 61
     276:	de b7       	in	r29, 0x3e	; 62
     278:	5c 83       	std	Y+4, r21	; 0x04
     27a:	4b 83       	std	Y+3, r20	; 0x03
     27c:	81 11       	cpse	r24, r1
     27e:	7b c0       	rjmp	.+246    	; 0x376 <arq_send+0x112>
     280:	7b 01       	movw	r14, r22
     282:	20 e0       	ldi	r18, 0x00	; 0
     284:	4f ef       	ldi	r20, 0xFF	; 255
     286:	5f ef       	ldi	r21, 0xFF	; 255
     288:	60 e0       	ldi	r22, 0x00	; 0
     28a:	70 e0       	ldi	r23, 0x00	; 0
     28c:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <connections+0x89>
     290:	90 91 7a 03 	lds	r25, 0x037A	; 0x80037a <connections+0x8a>
     294:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
     298:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <connections>
     29c:	82 30       	cpi	r24, 0x02	; 2
     29e:	51 f4       	brne	.+20     	; 0x2b4 <arq_send+0x50>
     2a0:	e1 14       	cp	r14, r1
     2a2:	f1 04       	cpc	r15, r1
     2a4:	39 f0       	breq	.+14     	; 0x2b4 <arq_send+0x50>
     2a6:	0b 81       	ldd	r16, Y+3	; 0x03
     2a8:	1c 81       	ldd	r17, Y+4	; 0x04
     2aa:	c8 01       	movw	r24, r16
     2ac:	01 97       	sbiw	r24, 0x01	; 1
     2ae:	84 36       	cpi	r24, 0x64	; 100
     2b0:	91 05       	cpc	r25, r1
     2b2:	50 f0       	brcs	.+20     	; 0x2c8 <arq_send+0x64>
     2b4:	60 e0       	ldi	r22, 0x00	; 0
     2b6:	70 e0       	ldi	r23, 0x00	; 0
     2b8:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <connections+0x89>
     2bc:	90 91 7a 03 	lds	r25, 0x037A	; 0x80037a <connections+0x8a>
     2c0:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueGive>
     2c4:	80 e0       	ldi	r24, 0x00	; 0
     2c6:	58 c0       	rjmp	.+176    	; 0x378 <arq_send+0x114>
     2c8:	0e 5f       	subi	r16, 0xFE	; 254
     2ca:	1f 4f       	sbci	r17, 0xFF	; 255
     2cc:	20 91 f9 02 	lds	r18, 0x02F9	; 0x8002f9 <connections+0x9>
     2d0:	30 91 fa 02 	lds	r19, 0x02FA	; 0x8002fa <connections+0xa>
     2d4:	80 e0       	ldi	r24, 0x00	; 0
     2d6:	91 e0       	ldi	r25, 0x01	; 1
     2d8:	82 1b       	sub	r24, r18
     2da:	93 0b       	sbc	r25, r19
     2dc:	08 17       	cp	r16, r24
     2de:	19 07       	cpc	r17, r25
     2e0:	08 f0       	brcs	.+2      	; 0x2e4 <arq_send+0x80>
     2e2:	3f c0       	rjmp	.+126    	; 0x362 <arq_send+0xfe>
     2e4:	20 91 03 03 	lds	r18, 0x0303	; 0x800303 <connections+0x13>
     2e8:	30 91 04 03 	lds	r19, 0x0304	; 0x800304 <connections+0x14>
     2ec:	84 e1       	ldi	r24, 0x14	; 20
     2ee:	90 e0       	ldi	r25, 0x00	; 0
     2f0:	82 1b       	sub	r24, r18
     2f2:	93 0b       	sbc	r25, r19
     2f4:	02 97       	sbiw	r24, 0x02	; 2
     2f6:	a8 f1       	brcs	.+106    	; 0x362 <arq_send+0xfe>
     2f8:	8a e2       	ldi	r24, 0x2A	; 42
     2fa:	90 e0       	ldi	r25, 0x00	; 0
     2fc:	9a 83       	std	Y+2, r25	; 0x02
     2fe:	89 83       	std	Y+1, r24	; 0x01
     300:	42 e0       	ldi	r20, 0x02	; 2
     302:	50 e0       	ldi	r21, 0x00	; 0
     304:	be 01       	movw	r22, r28
     306:	6d 5f       	subi	r22, 0xFD	; 253
     308:	7f 4f       	sbci	r23, 0xFF	; 255
     30a:	81 ef       	ldi	r24, 0xF1	; 241
     30c:	92 e0       	ldi	r25, 0x02	; 2
     30e:	ae d1       	rcall	.+860    	; 0x66c <buffer_append>
     310:	4b 81       	ldd	r20, Y+3	; 0x03
     312:	5c 81       	ldd	r21, Y+4	; 0x04
     314:	b7 01       	movw	r22, r14
     316:	81 ef       	ldi	r24, 0xF1	; 241
     318:	92 e0       	ldi	r25, 0x02	; 2
     31a:	a8 d1       	rcall	.+848    	; 0x66c <buffer_append>
     31c:	01 15       	cp	r16, r1
     31e:	11 05       	cpc	r17, r1
     320:	b1 f0       	breq	.+44     	; 0x34e <arq_send+0xea>
     322:	90 2f       	mov	r25, r16
     324:	81 2f       	mov	r24, r17
     326:	0b 32       	cpi	r16, 0x2B	; 43
     328:	11 05       	cpc	r17, r1
     32a:	10 f0       	brcs	.+4      	; 0x330 <arq_send+0xcc>
     32c:	9a e2       	ldi	r25, 0x2A	; 42
     32e:	80 e0       	ldi	r24, 0x00	; 0
     330:	99 83       	std	Y+1, r25	; 0x01
     332:	8a 83       	std	Y+2, r24	; 0x02
     334:	42 e0       	ldi	r20, 0x02	; 2
     336:	50 e0       	ldi	r21, 0x00	; 0
     338:	be 01       	movw	r22, r28
     33a:	6f 5f       	subi	r22, 0xFF	; 255
     33c:	7f 4f       	sbci	r23, 0xFF	; 255
     33e:	8b ef       	ldi	r24, 0xFB	; 251
     340:	92 e0       	ldi	r25, 0x02	; 2
     342:	94 d1       	rcall	.+808    	; 0x66c <buffer_append>
     344:	89 81       	ldd	r24, Y+1	; 0x01
     346:	9a 81       	ldd	r25, Y+2	; 0x02
     348:	08 1b       	sub	r16, r24
     34a:	19 0b       	sbc	r17, r25
     34c:	51 f7       	brne	.-44     	; 0x322 <arq_send+0xbe>
     34e:	60 e0       	ldi	r22, 0x00	; 0
     350:	70 e0       	ldi	r23, 0x00	; 0
     352:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <connections+0x89>
     356:	90 91 7a 03 	lds	r25, 0x037A	; 0x80037a <connections+0x8a>
     35a:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueGive>
     35e:	8b 81       	ldd	r24, Y+3	; 0x03
     360:	0b c0       	rjmp	.+22     	; 0x378 <arq_send+0x114>
     362:	60 e0       	ldi	r22, 0x00	; 0
     364:	70 e0       	ldi	r23, 0x00	; 0
     366:	80 91 79 03 	lds	r24, 0x0379	; 0x800379 <connections+0x89>
     36a:	90 91 7a 03 	lds	r25, 0x037A	; 0x80037a <connections+0x8a>
     36e:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueGive>
     372:	80 e0       	ldi	r24, 0x00	; 0
     374:	01 c0       	rjmp	.+2      	; 0x378 <arq_send+0x114>
     376:	80 e0       	ldi	r24, 0x00	; 0
     378:	0f 90       	pop	r0
     37a:	0f 90       	pop	r0
     37c:	0f 90       	pop	r0
     37e:	0f 90       	pop	r0
     380:	df 91       	pop	r29
     382:	cf 91       	pop	r28
     384:	1f 91       	pop	r17
     386:	0f 91       	pop	r16
     388:	ff 90       	pop	r15
     38a:	ef 90       	pop	r14
     38c:	08 95       	ret

0000038e <arq_send_ack>:
     38e:	cf 93       	push	r28
     390:	df 93       	push	r29
     392:	1f 92       	push	r1
     394:	1f 92       	push	r1
     396:	cd b7       	in	r28, 0x3d	; 61
     398:	de b7       	in	r29, 0x3e	; 62
     39a:	81 11       	cpse	r24, r1
     39c:	14 c0       	rjmp	.+40     	; 0x3c6 <arq_send_ack+0x38>
     39e:	80 91 f0 02 	lds	r24, 0x02F0	; 0x8002f0 <connections>
     3a2:	82 30       	cpi	r24, 0x02	; 2
     3a4:	91 f4       	brne	.+36     	; 0x3ca <arq_send_ack+0x3c>
     3a6:	66 23       	and	r22, r22
     3a8:	94 f0       	brlt	.+36     	; 0x3ce <arq_send_ack+0x40>
     3aa:	81 e0       	ldi	r24, 0x01	; 1
     3ac:	89 83       	std	Y+1, r24	; 0x01
     3ae:	6a 83       	std	Y+2, r22	; 0x02
     3b0:	22 e0       	ldi	r18, 0x02	; 2
     3b2:	30 e0       	ldi	r19, 0x00	; 0
     3b4:	ae 01       	movw	r20, r28
     3b6:	4f 5f       	subi	r20, 0xFF	; 255
     3b8:	5f 4f       	sbci	r21, 0xFF	; 255
     3ba:	61 e0       	ldi	r22, 0x01	; 1
     3bc:	80 91 10 03 	lds	r24, 0x0310	; 0x800310 <connections+0x20>
     3c0:	0e 94 8f 0a 	call	0x151e	; 0x151e <network_send>
     3c4:	05 c0       	rjmp	.+10     	; 0x3d0 <arq_send_ack+0x42>
     3c6:	80 e0       	ldi	r24, 0x00	; 0
     3c8:	03 c0       	rjmp	.+6      	; 0x3d0 <arq_send_ack+0x42>
     3ca:	80 e0       	ldi	r24, 0x00	; 0
     3cc:	01 c0       	rjmp	.+2      	; 0x3d0 <arq_send_ack+0x42>
     3ce:	80 e0       	ldi	r24, 0x00	; 0
     3d0:	0f 90       	pop	r0
     3d2:	0f 90       	pop	r0
     3d4:	df 91       	pop	r29
     3d6:	cf 91       	pop	r28
     3d8:	08 95       	ret

000003da <arq_reassembly>:

void arq_reassembly(arq_connection id, uint8_t *data, uint16_t len) { 
     3da:	0f 93       	push	r16
     3dc:	1f 93       	push	r17
     3de:	cf 93       	push	r28
     3e0:	df 93       	push	r29
     3e2:	ea 01       	movw	r28, r20
  if(id >= MAX_CONNECTIONS) return;
     3e4:	81 11       	cpse	r24, r1
     3e6:	41 c0       	rjmp	.+130    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
  
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
     3e8:	80 91 13 03 	lds	r24, 0x0313	; 0x800313 <connections+0x23>
     3ec:	90 91 14 03 	lds	r25, 0x0314	; 0x800314 <connections+0x24>
     3f0:	89 2b       	or	r24, r25
     3f2:	99 f4       	brne	.+38     	; 0x41a <__FUSE_REGION_LENGTH__+0x1a>
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
     3f4:	db 01       	movw	r26, r22
     3f6:	11 96       	adiw	r26, 0x01	; 1
     3f8:	8c 91       	ld	r24, X
     3fa:	11 97       	sbiw	r26, 0x01	; 1
     3fc:	90 e0       	ldi	r25, 0x00	; 0
     3fe:	98 2f       	mov	r25, r24
     400:	88 27       	eor	r24, r24
     402:	2c 91       	ld	r18, X
     404:	82 2b       	or	r24, r18
     406:	90 93 14 03 	sts	0x0314, r25	; 0x800314 <connections+0x24>
     40a:	80 93 13 03 	sts	0x0313, r24	; 0x800313 <connections+0x23>
    len-=2; // Remove the header from the length, left with the length of the payload
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
     40e:	85 36       	cpi	r24, 0x65	; 101
     410:	91 05       	cpc	r25, r1
     412:	58 f5       	brcc	.+86     	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
    len-=2; // Remove the header from the length, left with the length of the payload
     414:	22 97       	sbiw	r28, 0x02	; 2
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
     416:	6e 5f       	subi	r22, 0xFE	; 254
     418:	7f 4f       	sbci	r23, 0xFF	; 255
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
      return;
    }
  } 
  memcpy(con->message+con->num_received_bytes, data, len);
     41a:	00 ef       	ldi	r16, 0xF0	; 240
     41c:	12 e0       	ldi	r17, 0x02	; 2
     41e:	f8 01       	movw	r30, r16
     420:	81 a1       	ldd	r24, Z+33	; 0x21
     422:	92 a1       	ldd	r25, Z+34	; 0x22
     424:	ae 01       	movw	r20, r28
     426:	8b 5e       	subi	r24, 0xEB	; 235
     428:	9c 4f       	sbci	r25, 0xFC	; 252
     42a:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
  con->num_received_bytes += len;
     42e:	d8 01       	movw	r26, r16
     430:	91 96       	adiw	r26, 0x21	; 33
     432:	6d 91       	ld	r22, X+
     434:	7c 91       	ld	r23, X
     436:	92 97       	sbiw	r26, 0x22	; 34
     438:	6c 0f       	add	r22, r28
     43a:	7d 1f       	adc	r23, r29
     43c:	92 96       	adiw	r26, 0x22	; 34
     43e:	7c 93       	st	X, r23
     440:	6e 93       	st	-X, r22
     442:	91 97       	sbiw	r26, 0x21	; 33
  
  if(con->num_received_bytes == con->receive_message_length) {
     444:	93 96       	adiw	r26, 0x23	; 35
     446:	8d 91       	ld	r24, X+
     448:	9c 91       	ld	r25, X
     44a:	94 97       	sbiw	r26, 0x24	; 36
     44c:	68 17       	cp	r22, r24
     44e:	79 07       	cpc	r23, r25
     450:	61 f4       	brne	.+24     	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
    con->callback_data_received(con->message, con->num_received_bytes);
     452:	57 96       	adiw	r26, 0x17	; 23
     454:	ed 91       	ld	r30, X+
     456:	fc 91       	ld	r31, X
     458:	58 97       	sbiw	r26, 0x18	; 24
     45a:	85 e1       	ldi	r24, 0x15	; 21
     45c:	93 e0       	ldi	r25, 0x03	; 3
     45e:	19 95       	eicall
    con->num_received_bytes = con->receive_message_length = 0;
     460:	f8 01       	movw	r30, r16
     462:	14 a2       	std	Z+36, r1	; 0x24
     464:	13 a2       	std	Z+35, r1	; 0x23
     466:	12 a2       	std	Z+34, r1	; 0x22
     468:	11 a2       	std	Z+33, r1	; 0x21
  }
}
     46a:	df 91       	pop	r29
     46c:	cf 91       	pop	r28
     46e:	1f 91       	pop	r17
     470:	0f 91       	pop	r16
     472:	08 95       	ret

00000474 <receiver>:
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
     474:	9f 92       	push	r9
     476:	af 92       	push	r10
     478:	bf 92       	push	r11
     47a:	cf 92       	push	r12
     47c:	df 92       	push	r13
     47e:	ef 92       	push	r14
     480:	ff 92       	push	r15
     482:	0f 93       	push	r16
     484:	1f 93       	push	r17
     486:	cf 93       	push	r28
     488:	df 93       	push	r29
     48a:	1f 92       	push	r1
     48c:	cd b7       	in	r28, 0x3d	; 61
     48e:	de b7       	in	r29, 0x3e	; 62
     490:	8b 01       	movw	r16, r22
     492:	5a 01       	movw	r10, r20
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
     494:	90 91 10 03 	lds	r25, 0x0310	; 0x800310 <connections+0x20>
     498:	98 13       	cpse	r25, r24
     49a:	b8 c0       	rjmp	.+368    	; 0x60c <receiver+0x198>
     49c:	90 91 f0 02 	lds	r25, 0x02F0	; 0x8002f0 <connections>
     4a0:	99 23       	and	r25, r25
     4a2:	09 f4       	brne	.+2      	; 0x4a6 <receiver+0x32>
     4a4:	b3 c0       	rjmp	.+358    	; 0x60c <receiver+0x198>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     4a6:	fb 01       	movw	r30, r22
     4a8:	d0 80       	ld	r13, Z
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
      con = &connections[i];
     4aa:	0f 2e       	mov	r0, r31
     4ac:	f0 ef       	ldi	r31, 0xF0	; 240
     4ae:	ef 2e       	mov	r14, r31
     4b0:	f2 e0       	ldi	r31, 0x02	; 2
     4b2:	ff 2e       	mov	r15, r31
     4b4:	f0 2d       	mov	r31, r0
     4b6:	13 c0       	rjmp	.+38     	; 0x4de <receiver+0x6a>
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
  if(con == NULL && type == TYPE_SYN && listening_task != NULL) {
     4b8:	e0 91 ee 02 	lds	r30, 0x02EE	; 0x8002ee <__data_end>
     4bc:	f0 91 ef 02 	lds	r31, 0x02EF	; 0x8002ef <__data_end+0x1>
     4c0:	30 97       	sbiw	r30, 0x00	; 0
     4c2:	59 f0       	breq	.+22     	; 0x4da <receiver+0x66>
    xTaskNotify(listening_task, address, eSetValueWithOverwrite);
     4c4:	48 2f       	mov	r20, r24
     4c6:	50 e0       	ldi	r21, 0x00	; 0
     4c8:	60 e0       	ldi	r22, 0x00	; 0
     4ca:	70 e0       	ldi	r23, 0x00	; 0
     4cc:	00 e0       	ldi	r16, 0x00	; 0
     4ce:	10 e0       	ldi	r17, 0x00	; 0
     4d0:	23 e0       	ldi	r18, 0x03	; 3
     4d2:	cf 01       	movw	r24, r30
     4d4:	0e 94 11 1a 	call	0x3422	; 0x3422 <xTaskGenericNotify>
    return;
     4d8:	aa c0       	rjmp	.+340    	; 0x62e <receiver+0x1ba>
     4da:	e1 2c       	mov	r14, r1
     4dc:	f1 2c       	mov	r15, r1
  }
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     4de:	20 e0       	ldi	r18, 0x00	; 0
     4e0:	4f ef       	ldi	r20, 0xFF	; 255
     4e2:	5f ef       	ldi	r21, 0xFF	; 255
     4e4:	60 e0       	ldi	r22, 0x00	; 0
     4e6:	70 e0       	ldi	r23, 0x00	; 0
     4e8:	f7 01       	movw	r30, r14
     4ea:	e7 57       	subi	r30, 0x77	; 119
     4ec:	ff 4f       	sbci	r31, 0xFF	; 255
     4ee:	80 81       	ld	r24, Z
     4f0:	91 81       	ldd	r25, Z+1	; 0x01
     4f2:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
  
  if(con->status == STATUS_CLOSED || con->status == STATUS_NONE || len == 0 || data == NULL) {
     4f6:	f7 01       	movw	r30, r14
     4f8:	80 81       	ld	r24, Z
     4fa:	82 30       	cpi	r24, 0x02	; 2
     4fc:	30 f0       	brcs	.+12     	; 0x50a <receiver+0x96>
     4fe:	a1 14       	cp	r10, r1
     500:	b1 04       	cpc	r11, r1
     502:	19 f0       	breq	.+6      	; 0x50a <receiver+0x96>
     504:	01 15       	cp	r16, r1
     506:	11 05       	cpc	r17, r1
     508:	51 f4       	brne	.+20     	; 0x51e <receiver+0xaa>
    xSemaphoreGive(con->mutex);
     50a:	f7 01       	movw	r30, r14
     50c:	e7 57       	subi	r30, 0x77	; 119
     50e:	ff 4f       	sbci	r31, 0xFF	; 255
     510:	60 e0       	ldi	r22, 0x00	; 0
     512:	70 e0       	ldi	r23, 0x00	; 0
     514:	80 81       	ld	r24, Z
     516:	91 81       	ldd	r25, Z+1	; 0x01
     518:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueGive>
    return;
     51c:	88 c0       	rjmp	.+272    	; 0x62e <receiver+0x1ba>
  }
  
  if(con->status == STATUS_CONNECTING && type == TYPE_SYNACK) {
     51e:	83 30       	cpi	r24, 0x03	; 3
     520:	21 f5       	brne	.+72     	; 0x56a <receiver+0xf6>
     522:	f3 e0       	ldi	r31, 0x03	; 3
     524:	df 12       	cpse	r13, r31
     526:	21 c0       	rjmp	.+66     	; 0x56a <receiver+0xf6>
    if(con->blocked_task != NULL) {
     528:	f7 01       	movw	r30, r14
     52a:	e5 57       	subi	r30, 0x75	; 117
     52c:	ff 4f       	sbci	r31, 0xFF	; 255
     52e:	80 81       	ld	r24, Z
     530:	91 81       	ldd	r25, Z+1	; 0x01
     532:	00 97       	sbiw	r24, 0x00	; 0
     534:	81 f0       	breq	.+32     	; 0x556 <receiver+0xe2>
      xTaskNotifyGive(con->blocked_task);
     536:	00 e0       	ldi	r16, 0x00	; 0
     538:	10 e0       	ldi	r17, 0x00	; 0
     53a:	22 e0       	ldi	r18, 0x02	; 2
     53c:	40 e0       	ldi	r20, 0x00	; 0
     53e:	50 e0       	ldi	r21, 0x00	; 0
     540:	ba 01       	movw	r22, r20
     542:	0e 94 11 1a 	call	0x3422	; 0x3422 <xTaskGenericNotify>
      con->blocked_task = NULL;
     546:	f7 01       	movw	r30, r14
     548:	e5 57       	subi	r30, 0x75	; 117
     54a:	ff 4f       	sbci	r31, 0xFF	; 255
     54c:	11 82       	std	Z+1, r1	; 0x01
     54e:	10 82       	st	Z, r1
      arq_send_ack(id, 0x00);
     550:	60 e0       	ldi	r22, 0x00	; 0
     552:	80 e0       	ldi	r24, 0x00	; 0
     554:	1c df       	rcall	.-456    	; 0x38e <arq_send_ack>
    }
    
    xSemaphoreGive(con->mutex);
     556:	f7 01       	movw	r30, r14
     558:	e7 57       	subi	r30, 0x77	; 119
     55a:	ff 4f       	sbci	r31, 0xFF	; 255
     55c:	60 e0       	ldi	r22, 0x00	; 0
     55e:	70 e0       	ldi	r23, 0x00	; 0
     560:	80 81       	ld	r24, Z
     562:	91 81       	ldd	r25, Z+1	; 0x01
     564:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueGive>
    return;
     568:	62 c0       	rjmp	.+196    	; 0x62e <receiver+0x1ba>
  }
  
  uint8_t sequence = data[1];
     56a:	f8 01       	movw	r30, r16
     56c:	c1 80       	ldd	r12, Z+1	; 0x01
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
     56e:	dd 20       	and	r13, r13
     570:	09 f4       	brne	.+2      	; 0x574 <receiver+0x100>
     572:	52 c0       	rjmp	.+164    	; 0x618 <receiver+0x1a4>
     574:	f4 e0       	ldi	r31, 0x04	; 4
     576:	df 12       	cpse	r13, r31
     578:	13 c0       	rjmp	.+38     	; 0x5a0 <receiver+0x12c>
     57a:	53 c0       	rjmp	.+166    	; 0x622 <receiver+0x1ae>
    if(sequence == con->request_number) {
      if(type == TYPE_DATA) arq_reassembly(id, &data[2], len-2);
     57c:	a5 01       	movw	r20, r10
     57e:	42 50       	subi	r20, 0x02	; 2
     580:	51 09       	sbc	r21, r1
     582:	b8 01       	movw	r22, r16
     584:	6e 5f       	subi	r22, 0xFE	; 254
     586:	7f 4f       	sbci	r23, 0xFF	; 255
     588:	80 e0       	ldi	r24, 0x00	; 0
     58a:	27 df       	rcall	.-434    	; 0x3da <arq_reassembly>
      con->request_number = (con->request_number+1) & 127;
     58c:	f7 01       	movw	r30, r14
     58e:	82 8d       	ldd	r24, Z+26	; 0x1a
     590:	8f 5f       	subi	r24, 0xFF	; 255
     592:	8f 77       	andi	r24, 0x7F	; 127
     594:	82 8f       	std	Z+26, r24	; 0x1a
    }
    arq_send_ack(id, con->request_number);
     596:	f7 01       	movw	r30, r14
     598:	62 8d       	ldd	r22, Z+26	; 0x1a
     59a:	80 e0       	ldi	r24, 0x00	; 0
     59c:	f8 de       	rcall	.-528    	; 0x38e <arq_send_ack>
     59e:	2c c0       	rjmp	.+88     	; 0x5f8 <receiver+0x184>
  } else if(type == TYPE_ACK) {
     5a0:	f1 e0       	ldi	r31, 0x01	; 1
     5a2:	df 12       	cpse	r13, r31
     5a4:	29 c0       	rjmp	.+82     	; 0x5f8 <receiver+0x184>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
     5a6:	f7 01       	movw	r30, r14
     5a8:	83 8d       	ldd	r24, Z+27	; 0x1b
     5aa:	fc 2d       	mov	r31, r12
     5ac:	f8 1b       	sub	r31, r24
     5ae:	8f 2f       	mov	r24, r31
     5b0:	8f 77       	andi	r24, 0x7F	; 127
     5b2:	98 2e       	mov	r9, r24
    if(count != 0) {
     5b4:	09 f1       	breq	.+66     	; 0x5f8 <receiver+0x184>
     5b6:	d1 2c       	mov	r13, r1
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     5b8:	57 01       	movw	r10, r14
     5ba:	8b e0       	ldi	r24, 0x0B	; 11
     5bc:	a8 0e       	add	r10, r24
     5be:	b1 1c       	adc	r11, r1
        buffer_remove(&con->send_buffer, NULL, len);
     5c0:	87 01       	movw	r16, r14
     5c2:	0f 5f       	subi	r16, 0xFF	; 255
     5c4:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     5c6:	42 e0       	ldi	r20, 0x02	; 2
     5c8:	50 e0       	ldi	r21, 0x00	; 0
     5ca:	be 01       	movw	r22, r28
     5cc:	6f 5f       	subi	r22, 0xFF	; 255
     5ce:	7f 4f       	sbci	r23, 0xFF	; 255
     5d0:	c5 01       	movw	r24, r10
     5d2:	fb d0       	rcall	.+502    	; 0x7ca <buffer_remove>
        buffer_remove(&con->send_buffer, NULL, len);
     5d4:	49 81       	ldd	r20, Y+1	; 0x01
     5d6:	50 e0       	ldi	r21, 0x00	; 0
     5d8:	60 e0       	ldi	r22, 0x00	; 0
     5da:	70 e0       	ldi	r23, 0x00	; 0
     5dc:	c8 01       	movw	r24, r16
     5de:	f5 d0       	rcall	.+490    	; 0x7ca <buffer_remove>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
     5e0:	d3 94       	inc	r13
     5e2:	9d 10       	cpse	r9, r13
     5e4:	f0 cf       	rjmp	.-32     	; 0x5c6 <receiver+0x152>
        buffer_remove(&con->segment_lengths, &len, 2);
        buffer_remove(&con->send_buffer, NULL, len);
      }
      con->sequence_base = sequence;
     5e6:	f7 01       	movw	r30, r14
     5e8:	c3 8e       	std	Z+27, r12	; 0x1b

      con->timer = 0;
     5ea:	14 8e       	std	Z+28, r1	; 0x1c
      con->timeout = 0;
     5ec:	16 8e       	std	Z+30, r1	; 0x1e
     5ee:	15 8e       	std	Z+29, r1	; 0x1d
      if(con->sequence_base == con->sequence_number) con->timer_started = 0; // No more un-acked packets
     5f0:	81 8d       	ldd	r24, Z+25	; 0x19
     5f2:	c8 12       	cpse	r12, r24
     5f4:	01 c0       	rjmp	.+2      	; 0x5f8 <receiver+0x184>
     5f6:	17 8e       	std	Z+31, r1	; 0x1f
    }
  }
  
  xSemaphoreGive(con->mutex);
     5f8:	f7 01       	movw	r30, r14
     5fa:	e7 57       	subi	r30, 0x77	; 119
     5fc:	ff 4f       	sbci	r31, 0xFF	; 255
     5fe:	60 e0       	ldi	r22, 0x00	; 0
     600:	70 e0       	ldi	r23, 0x00	; 0
     602:	80 81       	ld	r24, Z
     604:	91 81       	ldd	r25, Z+1	; 0x01
     606:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueGive>
     60a:	11 c0       	rjmp	.+34     	; 0x62e <receiver+0x1ba>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     60c:	f8 01       	movw	r30, r16
     60e:	d0 80       	ld	r13, Z
  
  if(con == NULL && type != TYPE_SYN) return;
     610:	f2 e0       	ldi	r31, 0x02	; 2
     612:	df 12       	cpse	r13, r31
     614:	0c c0       	rjmp	.+24     	; 0x62e <receiver+0x1ba>
     616:	50 cf       	rjmp	.-352    	; 0x4b8 <receiver+0x44>
    return;
  }
  
  uint8_t sequence = data[1];
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
    if(sequence == con->request_number) {
     618:	f7 01       	movw	r30, r14
     61a:	82 8d       	ldd	r24, Z+26	; 0x1a
     61c:	c8 12       	cpse	r12, r24
     61e:	bb cf       	rjmp	.-138    	; 0x596 <receiver+0x122>
     620:	ad cf       	rjmp	.-166    	; 0x57c <receiver+0x108>
     622:	f7 01       	movw	r30, r14
     624:	82 8d       	ldd	r24, Z+26	; 0x1a
     626:	c8 16       	cp	r12, r24
     628:	09 f4       	brne	.+2      	; 0x62c <receiver+0x1b8>
     62a:	b0 cf       	rjmp	.-160    	; 0x58c <receiver+0x118>
     62c:	b4 cf       	rjmp	.-152    	; 0x596 <receiver+0x122>
    }
  }
  
  xSemaphoreGive(con->mutex);
  
}
     62e:	0f 90       	pop	r0
     630:	df 91       	pop	r29
     632:	cf 91       	pop	r28
     634:	1f 91       	pop	r17
     636:	0f 91       	pop	r16
     638:	ff 90       	pop	r15
     63a:	ef 90       	pop	r14
     63c:	df 90       	pop	r13
     63e:	cf 90       	pop	r12
     640:	bf 90       	pop	r11
     642:	af 90       	pop	r10
     644:	9f 90       	pop	r9
     646:	08 95       	ret

00000648 <buffer_init>:
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
}
     648:	fc 01       	movw	r30, r24
     64a:	61 15       	cp	r22, r1
     64c:	71 05       	cpc	r23, r1
     64e:	61 f0       	breq	.+24     	; 0x668 <buffer_init+0x20>
     650:	71 83       	std	Z+1, r23	; 0x01
     652:	60 83       	st	Z, r22
     654:	53 83       	std	Z+3, r21	; 0x03
     656:	42 83       	std	Z+2, r20	; 0x02
     658:	11 86       	std	Z+9, r1	; 0x09
     65a:	10 86       	std	Z+8, r1	; 0x08
     65c:	17 82       	std	Z+7, r1	; 0x07
     65e:	16 82       	std	Z+6, r1	; 0x06
     660:	15 82       	std	Z+5, r1	; 0x05
     662:	14 82       	std	Z+4, r1	; 0x04
     664:	81 e0       	ldi	r24, 0x01	; 1
     666:	08 95       	ret
     668:	80 e0       	ldi	r24, 0x00	; 0
     66a:	08 95       	ret

0000066c <buffer_append>:
     66c:	ef 92       	push	r14
     66e:	ff 92       	push	r15
     670:	0f 93       	push	r16
     672:	1f 93       	push	r17
     674:	cf 93       	push	r28
     676:	df 93       	push	r29
     678:	ec 01       	movw	r28, r24
     67a:	2a 81       	ldd	r18, Y+2	; 0x02
     67c:	3b 81       	ldd	r19, Y+3	; 0x03
     67e:	88 85       	ldd	r24, Y+8	; 0x08
     680:	99 85       	ldd	r25, Y+9	; 0x09
     682:	f9 01       	movw	r30, r18
     684:	e8 1b       	sub	r30, r24
     686:	f9 0b       	sbc	r31, r25
     688:	e4 17       	cp	r30, r20
     68a:	f5 07       	cpc	r31, r21
     68c:	08 f4       	brcc	.+2      	; 0x690 <buffer_append+0x24>
     68e:	49 c0       	rjmp	.+146    	; 0x722 <buffer_append+0xb6>
     690:	8a 01       	movw	r16, r20
     692:	7b 01       	movw	r14, r22
     694:	8c 81       	ldd	r24, Y+4	; 0x04
     696:	9d 81       	ldd	r25, Y+5	; 0x05
     698:	a9 01       	movw	r20, r18
     69a:	48 1b       	sub	r20, r24
     69c:	59 0b       	sbc	r21, r25
     69e:	04 17       	cp	r16, r20
     6a0:	15 07       	cpc	r17, r21
     6a2:	a8 f4       	brcc	.+42     	; 0x6ce <buffer_append+0x62>
     6a4:	28 81       	ld	r18, Y
     6a6:	39 81       	ldd	r19, Y+1	; 0x01
     6a8:	a8 01       	movw	r20, r16
     6aa:	82 0f       	add	r24, r18
     6ac:	93 1f       	adc	r25, r19
     6ae:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
     6b2:	8c 81       	ldd	r24, Y+4	; 0x04
     6b4:	9d 81       	ldd	r25, Y+5	; 0x05
     6b6:	80 0f       	add	r24, r16
     6b8:	91 1f       	adc	r25, r17
     6ba:	9d 83       	std	Y+5, r25	; 0x05
     6bc:	8c 83       	std	Y+4, r24	; 0x04
     6be:	2a 81       	ldd	r18, Y+2	; 0x02
     6c0:	3b 81       	ldd	r19, Y+3	; 0x03
     6c2:	82 17       	cp	r24, r18
     6c4:	93 07       	cpc	r25, r19
     6c6:	21 f5       	brne	.+72     	; 0x710 <buffer_append+0xa4>
     6c8:	1d 82       	std	Y+5, r1	; 0x05
     6ca:	1c 82       	std	Y+4, r1	; 0x04
     6cc:	21 c0       	rjmp	.+66     	; 0x710 <buffer_append+0xa4>
     6ce:	28 81       	ld	r18, Y
     6d0:	39 81       	ldd	r19, Y+1	; 0x01
     6d2:	82 0f       	add	r24, r18
     6d4:	93 1f       	adc	r25, r19
     6d6:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
     6da:	8c 81       	ldd	r24, Y+4	; 0x04
     6dc:	9d 81       	ldd	r25, Y+5	; 0x05
     6de:	6a 81       	ldd	r22, Y+2	; 0x02
     6e0:	7b 81       	ldd	r23, Y+3	; 0x03
     6e2:	ac 01       	movw	r20, r24
     6e4:	46 1b       	sub	r20, r22
     6e6:	57 0b       	sbc	r21, r23
     6e8:	40 0f       	add	r20, r16
     6ea:	51 1f       	adc	r21, r17
     6ec:	68 1b       	sub	r22, r24
     6ee:	79 0b       	sbc	r23, r25
     6f0:	6e 0d       	add	r22, r14
     6f2:	7f 1d       	adc	r23, r15
     6f4:	88 81       	ld	r24, Y
     6f6:	99 81       	ldd	r25, Y+1	; 0x01
     6f8:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
     6fc:	8c 81       	ldd	r24, Y+4	; 0x04
     6fe:	9d 81       	ldd	r25, Y+5	; 0x05
     700:	2a 81       	ldd	r18, Y+2	; 0x02
     702:	3b 81       	ldd	r19, Y+3	; 0x03
     704:	82 1b       	sub	r24, r18
     706:	93 0b       	sbc	r25, r19
     708:	80 0f       	add	r24, r16
     70a:	91 1f       	adc	r25, r17
     70c:	9d 83       	std	Y+5, r25	; 0x05
     70e:	8c 83       	std	Y+4, r24	; 0x04
     710:	48 85       	ldd	r20, Y+8	; 0x08
     712:	59 85       	ldd	r21, Y+9	; 0x09
     714:	04 0f       	add	r16, r20
     716:	15 1f       	adc	r17, r21
     718:	19 87       	std	Y+9, r17	; 0x09
     71a:	08 87       	std	Y+8, r16	; 0x08
     71c:	81 e0       	ldi	r24, 0x01	; 1
     71e:	90 e0       	ldi	r25, 0x00	; 0
     720:	02 c0       	rjmp	.+4      	; 0x726 <buffer_append+0xba>
     722:	80 e0       	ldi	r24, 0x00	; 0
     724:	90 e0       	ldi	r25, 0x00	; 0
     726:	df 91       	pop	r29
     728:	cf 91       	pop	r28
     72a:	1f 91       	pop	r17
     72c:	0f 91       	pop	r16
     72e:	ff 90       	pop	r15
     730:	ef 90       	pop	r14
     732:	08 95       	ret

00000734 <buffer_remove_token>:
     734:	0f 93       	push	r16
     736:	1f 93       	push	r17
     738:	cf 93       	push	r28
     73a:	df 93       	push	r29
     73c:	fc 01       	movw	r30, r24
     73e:	21 15       	cp	r18, r1
     740:	31 05       	cpc	r19, r1
     742:	c9 f1       	breq	.+114    	; 0x7b6 <buffer_remove_token+0x82>
     744:	a6 81       	ldd	r26, Z+6	; 0x06
     746:	b7 81       	ldd	r27, Z+7	; 0x07
     748:	84 81       	ldd	r24, Z+4	; 0x04
     74a:	95 81       	ldd	r25, Z+5	; 0x05
     74c:	a8 17       	cp	r26, r24
     74e:	b9 07       	cpc	r27, r25
     750:	a9 f1       	breq	.+106    	; 0x7bc <buffer_remove_token+0x88>
     752:	c6 2f       	mov	r28, r22
     754:	d7 2f       	mov	r29, r23
     756:	80 e0       	ldi	r24, 0x00	; 0
     758:	90 e0       	ldi	r25, 0x00	; 0
     75a:	07 c0       	rjmp	.+14     	; 0x76a <buffer_remove_token+0x36>
     75c:	a6 81       	ldd	r26, Z+6	; 0x06
     75e:	b7 81       	ldd	r27, Z+7	; 0x07
     760:	64 81       	ldd	r22, Z+4	; 0x04
     762:	75 81       	ldd	r23, Z+5	; 0x05
     764:	a6 17       	cp	r26, r22
     766:	b7 07       	cpc	r27, r23
     768:	59 f1       	breq	.+86     	; 0x7c0 <buffer_remove_token+0x8c>
     76a:	60 81       	ld	r22, Z
     76c:	71 81       	ldd	r23, Z+1	; 0x01
     76e:	a6 0f       	add	r26, r22
     770:	b7 1f       	adc	r27, r23
     772:	5c 91       	ld	r21, X
     774:	8e 01       	movw	r16, r28
     776:	58 83       	st	Y, r21
     778:	66 81       	ldd	r22, Z+6	; 0x06
     77a:	77 81       	ldd	r23, Z+7	; 0x07
     77c:	6f 5f       	subi	r22, 0xFF	; 255
     77e:	7f 4f       	sbci	r23, 0xFF	; 255
     780:	77 83       	std	Z+7, r23	; 0x07
     782:	66 83       	std	Z+6, r22	; 0x06
     784:	a0 85       	ldd	r26, Z+8	; 0x08
     786:	b1 85       	ldd	r27, Z+9	; 0x09
     788:	11 97       	sbiw	r26, 0x01	; 1
     78a:	b1 87       	std	Z+9, r27	; 0x09
     78c:	a0 87       	std	Z+8, r26	; 0x08
     78e:	a2 81       	ldd	r26, Z+2	; 0x02
     790:	b3 81       	ldd	r27, Z+3	; 0x03
     792:	6a 17       	cp	r22, r26
     794:	7b 07       	cpc	r23, r27
     796:	11 f4       	brne	.+4      	; 0x79c <buffer_remove_token+0x68>
     798:	17 82       	std	Z+7, r1	; 0x07
     79a:	16 82       	std	Z+6, r1	; 0x06
     79c:	21 96       	adiw	r28, 0x01	; 1
     79e:	d8 01       	movw	r26, r16
     7a0:	5c 91       	ld	r21, X
     7a2:	54 13       	cpse	r21, r20
     7a4:	02 c0       	rjmp	.+4      	; 0x7aa <buffer_remove_token+0x76>
     7a6:	01 96       	adiw	r24, 0x01	; 1
     7a8:	0b c0       	rjmp	.+22     	; 0x7c0 <buffer_remove_token+0x8c>
     7aa:	01 96       	adiw	r24, 0x01	; 1
     7ac:	28 17       	cp	r18, r24
     7ae:	39 07       	cpc	r19, r25
     7b0:	a9 f6       	brne	.-86     	; 0x75c <buffer_remove_token+0x28>
     7b2:	c9 01       	movw	r24, r18
     7b4:	05 c0       	rjmp	.+10     	; 0x7c0 <buffer_remove_token+0x8c>
     7b6:	80 e0       	ldi	r24, 0x00	; 0
     7b8:	90 e0       	ldi	r25, 0x00	; 0
     7ba:	02 c0       	rjmp	.+4      	; 0x7c0 <buffer_remove_token+0x8c>
     7bc:	80 e0       	ldi	r24, 0x00	; 0
     7be:	90 e0       	ldi	r25, 0x00	; 0
     7c0:	df 91       	pop	r29
     7c2:	cf 91       	pop	r28
     7c4:	1f 91       	pop	r17
     7c6:	0f 91       	pop	r16
     7c8:	08 95       	ret

000007ca <buffer_remove>:

//Remove 'len' bytes from the buffer and add them to 'data'
uint16_t buffer_remove(buffer_t *b, uint8_t *data, uint16_t len) {
     7ca:	ef 92       	push	r14
     7cc:	ff 92       	push	r15
     7ce:	0f 93       	push	r16
     7d0:	1f 93       	push	r17
     7d2:	cf 93       	push	r28
     7d4:	df 93       	push	r29
     7d6:	ec 01       	movw	r28, r24
     7d8:	7b 01       	movw	r14, r22
  if(len > b->len) len = b->len;
     7da:	08 85       	ldd	r16, Y+8	; 0x08
     7dc:	19 85       	ldd	r17, Y+9	; 0x09
     7de:	40 17       	cp	r20, r16
     7e0:	51 07       	cpc	r21, r17
     7e2:	08 f4       	brcc	.+2      	; 0x7e6 <buffer_remove+0x1c>
     7e4:	8a 01       	movw	r16, r20
  if(b->capacity - b->tail >= len) {
     7e6:	8e 81       	ldd	r24, Y+6	; 0x06
     7e8:	9f 81       	ldd	r25, Y+7	; 0x07
     7ea:	4a 81       	ldd	r20, Y+2	; 0x02
     7ec:	5b 81       	ldd	r21, Y+3	; 0x03
     7ee:	48 1b       	sub	r20, r24
     7f0:	59 0b       	sbc	r21, r25
     7f2:	40 17       	cp	r20, r16
     7f4:	51 07       	cpc	r21, r17
     7f6:	c8 f0       	brcs	.+50     	; 0x82a <buffer_remove+0x60>
    if(data != NULL) memcpy(data, b->buf+b->tail, len);
     7f8:	e1 14       	cp	r14, r1
     7fa:	f1 04       	cpc	r15, r1
     7fc:	41 f0       	breq	.+16     	; 0x80e <buffer_remove+0x44>
     7fe:	68 81       	ld	r22, Y
     800:	79 81       	ldd	r23, Y+1	; 0x01
     802:	68 0f       	add	r22, r24
     804:	79 1f       	adc	r23, r25
     806:	a8 01       	movw	r20, r16
     808:	c7 01       	movw	r24, r14
     80a:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
    b->tail = b->tail + len;
     80e:	8e 81       	ldd	r24, Y+6	; 0x06
     810:	9f 81       	ldd	r25, Y+7	; 0x07
     812:	80 0f       	add	r24, r16
     814:	91 1f       	adc	r25, r17
     816:	9f 83       	std	Y+7, r25	; 0x07
     818:	8e 83       	std	Y+6, r24	; 0x06
    if(b->tail == b->capacity) b->tail = 0;
     81a:	2a 81       	ldd	r18, Y+2	; 0x02
     81c:	3b 81       	ldd	r19, Y+3	; 0x03
     81e:	82 17       	cp	r24, r18
     820:	93 07       	cpc	r25, r19
     822:	41 f5       	brne	.+80     	; 0x874 <buffer_remove+0xaa>
     824:	1f 82       	std	Y+7, r1	; 0x07
     826:	1e 82       	std	Y+6, r1	; 0x06
     828:	25 c0       	rjmp	.+74     	; 0x874 <buffer_remove+0xaa>
  } else {
    if(data != NULL) {
     82a:	e1 14       	cp	r14, r1
     82c:	f1 04       	cpc	r15, r1
     82e:	c1 f0       	breq	.+48     	; 0x860 <buffer_remove+0x96>
      memcpy(data, b->buf+b->tail, b->capacity - b->tail);
     830:	68 81       	ld	r22, Y
     832:	79 81       	ldd	r23, Y+1	; 0x01
     834:	68 0f       	add	r22, r24
     836:	79 1f       	adc	r23, r25
     838:	c7 01       	movw	r24, r14
     83a:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
      memcpy(data + (b->capacity - b->tail), b->buf, len - (b->capacity - b->tail) );
     83e:	4e 81       	ldd	r20, Y+6	; 0x06
     840:	5f 81       	ldd	r21, Y+7	; 0x07
     842:	2a 81       	ldd	r18, Y+2	; 0x02
     844:	3b 81       	ldd	r19, Y+3	; 0x03
     846:	c9 01       	movw	r24, r18
     848:	84 1b       	sub	r24, r20
     84a:	95 0b       	sbc	r25, r21
     84c:	42 1b       	sub	r20, r18
     84e:	53 0b       	sbc	r21, r19
     850:	40 0f       	add	r20, r16
     852:	51 1f       	adc	r21, r17
     854:	68 81       	ld	r22, Y
     856:	79 81       	ldd	r23, Y+1	; 0x01
     858:	8e 0d       	add	r24, r14
     85a:	9f 1d       	adc	r25, r15
     85c:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
    }
    b->tail = len - (b->capacity - b->tail);
     860:	8e 81       	ldd	r24, Y+6	; 0x06
     862:	9f 81       	ldd	r25, Y+7	; 0x07
     864:	2a 81       	ldd	r18, Y+2	; 0x02
     866:	3b 81       	ldd	r19, Y+3	; 0x03
     868:	82 1b       	sub	r24, r18
     86a:	93 0b       	sbc	r25, r19
     86c:	80 0f       	add	r24, r16
     86e:	91 1f       	adc	r25, r17
     870:	9f 83       	std	Y+7, r25	; 0x07
     872:	8e 83       	std	Y+6, r24	; 0x06
  }
  b->len -= len;
     874:	88 85       	ldd	r24, Y+8	; 0x08
     876:	99 85       	ldd	r25, Y+9	; 0x09
     878:	80 1b       	sub	r24, r16
     87a:	91 0b       	sbc	r25, r17
     87c:	99 87       	std	Y+9, r25	; 0x09
     87e:	88 87       	std	Y+8, r24	; 0x08
  return len;
     880:	c8 01       	movw	r24, r16
     882:	df 91       	pop	r29
     884:	cf 91       	pop	r28
     886:	1f 91       	pop	r17
     888:	0f 91       	pop	r16
     88a:	ff 90       	pop	r15
     88c:	ef 90       	pop	r14
     88e:	08 95       	ret

00000890 <cobs_encode>:
/*****************************************************************************
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     890:	ef 92       	push	r14
     892:	ff 92       	push	r15
     894:	0f 93       	push	r16
     896:	1f 93       	push	r17
     898:	cf 93       	push	r28
     89a:	df 93       	push	r29
     89c:	7c 01       	movw	r14, r24
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     89e:	68 0f       	add	r22, r24
     8a0:	79 1f       	adc	r23, r25
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
     8a2:	fc 01       	movw	r30, r24
     8a4:	31 96       	adiw	r30, 0x01	; 1
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     8a6:	00 97       	sbiw	r24, 0x00	; 0
     8a8:	19 f0       	breq	.+6      	; 0x8b0 <cobs_encode+0x20>
     8aa:	41 15       	cp	r20, r1
     8ac:	51 05       	cpc	r21, r1
     8ae:	21 f4       	brne	.+8      	; 0x8b8 <cobs_encode+0x28>
    {
        result.status = COBS_ENCODE_NULL_POINTER;
        return result;
     8b0:	60 e0       	ldi	r22, 0x00	; 0
     8b2:	70 e0       	ldi	r23, 0x00	; 0
     8b4:	81 e0       	ldi	r24, 0x01	; 1
     8b6:	4b c0       	rjmp	.+150    	; 0x94e <cobs_encode+0xbe>
    }

    if (src_len != 0)
     8b8:	21 15       	cp	r18, r1
     8ba:	31 05       	cpc	r19, r1
     8bc:	59 f1       	breq	.+86     	; 0x914 <cobs_encode+0x84>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     8be:	e6 17       	cp	r30, r22
     8c0:	f7 07       	cpc	r31, r23
     8c2:	60 f5       	brcc	.+88     	; 0x91c <cobs_encode+0x8c>
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     8c4:	8a 01       	movw	r16, r20
     8c6:	02 0f       	add	r16, r18
     8c8:	13 1f       	adc	r17, r19
     8ca:	da 01       	movw	r26, r20
     8cc:	ec 01       	movw	r28, r24
     8ce:	91 e0       	ldi	r25, 0x01	; 1
                }
                if (search_len == 0xFF)
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     8d0:	2f ef       	ldi	r18, 0xFF	; 255
     8d2:	04 c0       	rjmp	.+8      	; 0x8dc <cobs_encode+0x4c>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     8d4:	fa 01       	movw	r30, r20
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     8d6:	e6 17       	cp	r30, r22
     8d8:	f7 07       	cpc	r31, r23
     8da:	20 f5       	brcc	.+72     	; 0x924 <cobs_encode+0x94>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
                break;
            }

            src_byte = *src_ptr++;
     8dc:	3d 91       	ld	r19, X+
            if (src_byte == 0)
     8de:	31 11       	cpse	r19, r1
     8e0:	0a c0       	rjmp	.+20     	; 0x8f6 <cobs_encode+0x66>
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
     8e2:	98 83       	st	Y, r25
                dst_code_write_ptr = dst_write_ptr++;
     8e4:	cf 01       	movw	r24, r30
     8e6:	01 96       	adiw	r24, 0x01	; 1
                search_len = 1;
                if (src_ptr >= src_end_ptr)
     8e8:	a0 17       	cp	r26, r16
     8ea:	b1 07       	cpc	r27, r17
     8ec:	e8 f4       	brcc	.+58     	; 0x928 <cobs_encode+0x98>
     8ee:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     8f0:	fc 01       	movw	r30, r24
                search_len = 1;
     8f2:	91 e0       	ldi	r25, 0x01	; 1
     8f4:	f0 cf       	rjmp	.-32     	; 0x8d6 <cobs_encode+0x46>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     8f6:	af 01       	movw	r20, r30
     8f8:	4f 5f       	subi	r20, 0xFF	; 255
     8fa:	5f 4f       	sbci	r21, 0xFF	; 255
     8fc:	30 83       	st	Z, r19
                search_len++;
     8fe:	9f 5f       	subi	r25, 0xFF	; 255
                if (src_ptr >= src_end_ptr)
     900:	a0 17       	cp	r26, r16
     902:	b1 07       	cpc	r27, r17
     904:	b0 f4       	brcc	.+44     	; 0x932 <cobs_encode+0xa2>
                {
                    break;
                }
                if (search_len == 0xFF)
     906:	9f 3f       	cpi	r25, 0xFF	; 255
     908:	29 f7       	brne	.-54     	; 0x8d4 <cobs_encode+0x44>
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     90a:	28 83       	st	Y, r18
                    dst_code_write_ptr = dst_write_ptr++;
     90c:	32 96       	adiw	r30, 0x02	; 2
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     90e:	ea 01       	movw	r28, r20
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
                    dst_code_write_ptr = dst_write_ptr++;
                    search_len = 1;
     910:	91 e0       	ldi	r25, 0x01	; 1
     912:	e1 cf       	rjmp	.-62     	; 0x8d6 <cobs_encode+0x46>
cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
     914:	ec 01       	movw	r28, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     916:	80 e0       	ldi	r24, 0x00	; 0
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;
     918:	91 e0       	ldi	r25, 0x01	; 1
     91a:	0d c0       	rjmp	.+26     	; 0x936 <cobs_encode+0xa6>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     91c:	ec 01       	movw	r28, r24
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     91e:	82 e0       	ldi	r24, 0x02	; 2
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     920:	91 e0       	ldi	r25, 0x01	; 1
     922:	09 c0       	rjmp	.+18     	; 0x936 <cobs_encode+0xa6>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     924:	82 e0       	ldi	r24, 0x02	; 2
     926:	07 c0       	rjmp	.+14     	; 0x936 <cobs_encode+0xa6>
     928:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     92a:	fc 01       	movw	r30, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     92c:	80 e0       	ldi	r24, 0x00	; 0
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
                search_len = 1;
     92e:	91 e0       	ldi	r25, 0x01	; 1
     930:	02 c0       	rjmp	.+4      	; 0x936 <cobs_encode+0xa6>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     932:	fa 01       	movw	r30, r20
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     934:	80 e0       	ldi	r24, 0x00	; 0

    /* We've reached the end of the source data (or possibly run out of output buffer)
     * Finalise the remaining output. In particular, write the code (length) byte.
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
     936:	c6 17       	cp	r28, r22
     938:	d7 07       	cpc	r29, r23
     93a:	18 f4       	brcc	.+6      	; 0x942 <cobs_encode+0xb2>
        dst_write_ptr = dst_buf_end_ptr;
    }
    else
    {
        /* Write the last code (length) byte. */
        *dst_code_write_ptr = search_len;
     93c:	98 83       	st	Y, r25
     93e:	bf 01       	movw	r22, r30
     940:	01 c0       	rjmp	.+2      	; 0x944 <cobs_encode+0xb4>
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
    {
        /* We've run out of output buffer to write the code byte. */
        result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     942:	82 e0       	ldi	r24, 0x02	; 2
    }

    /* Calculate the output length, from the value of dst_code_write_ptr */
    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     944:	9b 01       	movw	r18, r22
     946:	2e 19       	sub	r18, r14
     948:	3f 09       	sbc	r19, r15
     94a:	62 2f       	mov	r22, r18
     94c:	73 2f       	mov	r23, r19
}
     94e:	df 91       	pop	r29
     950:	cf 91       	pop	r28
     952:	1f 91       	pop	r17
     954:	0f 91       	pop	r16
     956:	ff 90       	pop	r15
     958:	ef 90       	pop	r14
     95a:	08 95       	ret

0000095c <cobs_decode>:


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     95c:	af 92       	push	r10
     95e:	bf 92       	push	r11
     960:	cf 92       	push	r12
     962:	df 92       	push	r13
     964:	ef 92       	push	r14
     966:	ff 92       	push	r15
     968:	0f 93       	push	r16
     96a:	1f 93       	push	r17
     96c:	cf 93       	push	r28
     96e:	df 93       	push	r29
     970:	7c 01       	movw	r14, r24
     972:	da 01       	movw	r26, r20
    uint8_t             i;
    uint8_t             len_code;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     974:	00 97       	sbiw	r24, 0x00	; 0
     976:	11 f0       	breq	.+4      	; 0x97c <cobs_decode+0x20>
     978:	10 97       	sbiw	r26, 0x00	; 0
     97a:	21 f4       	brne	.+8      	; 0x984 <cobs_decode+0x28>
    {
        result.status = COBS_DECODE_NULL_POINTER;
        return result;
     97c:	60 e0       	ldi	r22, 0x00	; 0
     97e:	70 e0       	ldi	r23, 0x00	; 0
     980:	81 e0       	ldi	r24, 0x01	; 1
     982:	5f c0       	rjmp	.+190    	; 0xa42 <cobs_decode+0xe6>
    }

    if (src_len != 0)
     984:	21 15       	cp	r18, r1
     986:	31 05       	cpc	r19, r1
     988:	09 f4       	brne	.+2      	; 0x98c <cobs_decode+0x30>
     98a:	4b c0       	rjmp	.+150    	; 0xa22 <cobs_decode+0xc6>


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     98c:	6a 01       	movw	r12, r20
     98e:	c2 0e       	add	r12, r18
     990:	d3 1e       	adc	r13, r19
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     992:	5c 01       	movw	r10, r24
     994:	a6 0e       	add	r10, r22
     996:	b7 1e       	adc	r11, r23
     998:	8c 01       	movw	r16, r24
     99a:	50 e0       	ldi	r21, 0x00	; 0
     99c:	01 c0       	rjmp	.+2      	; 0x9a0 <cobs_decode+0x44>
                src_byte = *src_ptr++;
                if (src_byte == 0)
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
     99e:	8f 01       	movw	r16, r30

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     9a0:	ed 01       	movw	r28, r26
     9a2:	21 96       	adiw	r28, 0x01	; 1
     9a4:	7c 91       	ld	r23, X
            if (len_code == 0)
     9a6:	71 11       	cpse	r23, r1
     9a8:	03 c0       	rjmp	.+6      	; 0x9b0 <cobs_decode+0x54>
            {
                result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     9aa:	54 60       	ori	r21, 0x04	; 4
                break;
     9ac:	f8 01       	movw	r30, r16
     9ae:	3d c0       	rjmp	.+122    	; 0xa2a <cobs_decode+0xce>
            }
            len_code--;
     9b0:	71 50       	subi	r23, 0x01	; 1

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
     9b2:	c6 01       	movw	r24, r12
     9b4:	8c 1b       	sub	r24, r28
     9b6:	9d 0b       	sbc	r25, r29
            if (len_code > remaining_bytes)
     9b8:	27 2f       	mov	r18, r23
     9ba:	30 e0       	ldi	r19, 0x00	; 0
     9bc:	82 17       	cp	r24, r18
     9be:	93 07       	cpc	r25, r19
     9c0:	10 f4       	brcc	.+4      	; 0x9c6 <cobs_decode+0x6a>
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
                len_code = remaining_bytes;
     9c2:	78 2f       	mov	r23, r24

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
     9c4:	58 60       	ori	r21, 0x08	; 8
                len_code = remaining_bytes;
            }

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
     9c6:	c5 01       	movw	r24, r10
     9c8:	80 1b       	sub	r24, r16
     9ca:	91 0b       	sbc	r25, r17
            if (len_code > remaining_bytes)
     9cc:	27 2f       	mov	r18, r23
     9ce:	30 e0       	ldi	r19, 0x00	; 0
     9d0:	82 17       	cp	r24, r18
     9d2:	93 07       	cpc	r25, r19
     9d4:	10 f4       	brcc	.+4      	; 0x9da <cobs_decode+0x7e>
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
     9d6:	78 2f       	mov	r23, r24

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     9d8:	52 60       	ori	r21, 0x02	; 2
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     9da:	77 23       	and	r23, r23
     9dc:	61 f1       	breq	.+88     	; 0xa36 <cobs_decode+0xda>
     9de:	de 01       	movw	r26, r28
     9e0:	f8 01       	movw	r30, r16
     9e2:	97 2f       	mov	r25, r23
            {
                src_byte = *src_ptr++;
     9e4:	3d 91       	ld	r19, X+
                if (src_byte == 0)
     9e6:	31 11       	cpse	r19, r1
     9e8:	01 c0       	rjmp	.+2      	; 0x9ec <cobs_decode+0x90>
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     9ea:	54 60       	ori	r21, 0x04	; 4
                }
                *dst_write_ptr++ = src_byte;
     9ec:	31 93       	st	Z+, r19
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     9ee:	91 50       	subi	r25, 0x01	; 1
     9f0:	c9 f7       	brne	.-14     	; 0x9e4 <cobs_decode+0x88>
     9f2:	ef ef       	ldi	r30, 0xFF	; 255
     9f4:	e7 0f       	add	r30, r23
     9f6:	f0 e0       	ldi	r31, 0x00	; 0
     9f8:	31 96       	adiw	r30, 0x01	; 1
     9fa:	de 01       	movw	r26, r28
     9fc:	ae 0f       	add	r26, r30
     9fe:	bf 1f       	adc	r27, r31
     a00:	e0 0f       	add	r30, r16
     a02:	f1 1f       	adc	r31, r17
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     a04:	ac 15       	cp	r26, r12
     a06:	bd 05       	cpc	r27, r13
     a08:	80 f4       	brcc	.+32     	; 0xa2a <cobs_decode+0xce>
            {
                break;
            }

            /* Add a zero to the end */
            if (len_code != 0xFE)
     a0a:	7e 3f       	cpi	r23, 0xFE	; 254
     a0c:	41 f2       	breq	.-112    	; 0x99e <cobs_decode+0x42>
            {
                if (dst_write_ptr >= dst_buf_end_ptr)
     a0e:	ea 15       	cp	r30, r10
     a10:	fb 05       	cpc	r31, r11
     a12:	10 f0       	brcs	.+4      	; 0xa18 <cobs_decode+0xbc>
                {
                    result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     a14:	52 60       	ori	r21, 0x02	; 2
                    break;
     a16:	09 c0       	rjmp	.+18     	; 0xa2a <cobs_decode+0xce>
                }
                *dst_write_ptr++ = 0;
     a18:	8f 01       	movw	r16, r30
     a1a:	0f 5f       	subi	r16, 0xFF	; 255
     a1c:	1f 4f       	sbci	r17, 0xFF	; 255
     a1e:	10 82       	st	Z, r1
     a20:	bf cf       	rjmp	.-130    	; 0x9a0 <cobs_decode+0x44>
cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_write_ptr       = dst_buf_ptr;
     a22:	fc 01       	movw	r30, r24
}


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
     a24:	50 e0       	ldi	r21, 0x00	; 0
     a26:	01 c0       	rjmp	.+2      	; 0xa2a <cobs_decode+0xce>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     a28:	f8 01       	movw	r30, r16
        }
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     a2a:	ee 19       	sub	r30, r14
     a2c:	ff 09       	sbc	r31, r15
     a2e:	6e 2f       	mov	r22, r30
     a30:	7f 2f       	mov	r23, r31
     a32:	85 2f       	mov	r24, r21
     a34:	06 c0       	rjmp	.+12     	; 0xa42 <cobs_decode+0xe6>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     a36:	cc 15       	cp	r28, r12
     a38:	dd 05       	cpc	r29, r13
     a3a:	b0 f7       	brcc	.-20     	; 0xa28 <cobs_decode+0xcc>
     a3c:	f8 01       	movw	r30, r16

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     a3e:	de 01       	movw	r26, r28
     a40:	e6 cf       	rjmp	.-52     	; 0xa0e <cobs_decode+0xb2>
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
}
     a42:	df 91       	pop	r29
     a44:	cf 91       	pop	r28
     a46:	1f 91       	pop	r17
     a48:	0f 91       	pop	r16
     a4a:	ff 90       	pop	r15
     a4c:	ef 90       	pop	r14
     a4e:	df 90       	pop	r13
     a50:	cf 90       	pop	r12
     a52:	bf 90       	pop	r11
     a54:	af 90       	pop	r10
     a56:	08 95       	ret

00000a58 <crc_ibutton_update>:
  return crc;
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
     a58:	86 27       	eor	r24, r22
     a5a:	98 e0       	ldi	r25, 0x08	; 8
  for (i = 0; i < 8; i++) {
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
     a5c:	2c e8       	ldi	r18, 0x8C	; 140
     a5e:	80 ff       	sbrs	r24, 0
     a60:	03 c0       	rjmp	.+6      	; 0xa68 <crc_ibutton_update+0x10>
     a62:	86 95       	lsr	r24
     a64:	82 27       	eor	r24, r18
     a66:	01 c0       	rjmp	.+2      	; 0xa6a <crc_ibutton_update+0x12>
    else crc >>= 1;
     a68:	86 95       	lsr	r24
     a6a:	91 50       	subi	r25, 0x01	; 1
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
  for (i = 0; i < 8; i++) {
     a6c:	c1 f7       	brne	.-16     	; 0xa5e <crc_ibutton_update+0x6>
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
    else crc >>= 1;
  }
  return crc;
     a6e:	08 95       	ret

00000a70 <calculate_crc>:

#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
     a70:	0f 93       	push	r16
     a72:	1f 93       	push	r17
     a74:	cf 93       	push	r28
     a76:	df 93       	push	r29
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
     a78:	66 23       	and	r22, r22
     a7a:	59 f0       	breq	.+22     	; 0xa92 <calculate_crc+0x22>
     a7c:	8c 01       	movw	r16, r24
     a7e:	ec 01       	movw	r28, r24
     a80:	06 0f       	add	r16, r22
     a82:	11 1d       	adc	r17, r1
     a84:	80 e0       	ldi	r24, 0x00	; 0
    crc = crc_ibutton_update(crc, data[i]);
     a86:	69 91       	ld	r22, Y+
     a88:	e7 df       	rcall	.-50     	; 0xa58 <crc_ibutton_update>
char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
     a8a:	0c 17       	cp	r16, r28
     a8c:	1d 07       	cpc	r17, r29
     a8e:	d9 f7       	brne	.-10     	; 0xa86 <calculate_crc+0x16>
     a90:	01 c0       	rjmp	.+2      	; 0xa94 <calculate_crc+0x24>
#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
     a92:	80 e0       	ldi	r24, 0x00	; 0
  int i;
  for(i=0;i<len;i++) {
    crc = crc_ibutton_update(crc, data[i]);
  }
  return crc;
}
     a94:	df 91       	pop	r29
     a96:	cf 91       	pop	r28
     a98:	1f 91       	pop	r17
     a9a:	0f 91       	pop	r16
     a9c:	08 95       	ret

00000a9e <vDistSens_init>:
};

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
     a9e:	80 b3       	in	r24, 0x10	; 16
     aa0:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     aa2:	ec e7       	ldi	r30, 0x7C	; 124
     aa4:	f0 e0       	ldi	r31, 0x00	; 0
     aa6:	80 81       	ld	r24, Z
     aa8:	80 6c       	ori	r24, 0xC0	; 192
     aaa:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
     aac:	ea e7       	ldi	r30, 0x7A	; 122
     aae:	f0 e0       	ldi	r31, 0x00	; 0
     ab0:	80 81       	ld	r24, Z
     ab2:	80 68       	ori	r24, 0x80	; 128
     ab4:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
     ab6:	80 81       	ld	r24, Z
     ab8:	84 60       	ori	r24, 0x04	; 4
     aba:	80 83       	st	Z, r24
     abc:	08 95       	ret

00000abe <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     abe:	ef 92       	push	r14
     ac0:	ff 92       	push	r15
     ac2:	0f 93       	push	r16
     ac4:	1f 93       	push	r17
     ac6:	cf 93       	push	r28
     ac8:	df 93       	push	r29
     aca:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     acc:	0e 94 12 15 	call	0x2a24	; 0x2a24 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     ad0:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <pxEnd>
     ad4:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <pxEnd+0x1>
     ad8:	89 2b       	or	r24, r25
     ada:	41 f5       	brne	.+80     	; 0xb2c <pvPortMalloc+0x6e>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     adc:	e5 e8       	ldi	r30, 0x85	; 133
     ade:	f3 e0       	ldi	r31, 0x03	; 3
     ae0:	a9 e8       	ldi	r26, 0x89	; 137
     ae2:	b3 e0       	ldi	r27, 0x03	; 3
     ae4:	b1 83       	std	Z+1, r27	; 0x01
     ae6:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     ae8:	13 82       	std	Z+3, r1	; 0x03
     aea:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     aec:	e5 e8       	ldi	r30, 0x85	; 133
     aee:	f5 e1       	ldi	r31, 0x15	; 21
     af0:	f0 93 84 03 	sts	0x0384, r31	; 0x800384 <pxEnd+0x1>
     af4:	e0 93 83 03 	sts	0x0383, r30	; 0x800383 <pxEnd>
	pxEnd->xBlockSize = 0;
     af8:	13 82       	std	Z+3, r1	; 0x03
     afa:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     afc:	11 82       	std	Z+1, r1	; 0x01
     afe:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     b00:	8c ef       	ldi	r24, 0xFC	; 252
     b02:	91 e1       	ldi	r25, 0x11	; 17
     b04:	13 96       	adiw	r26, 0x03	; 3
     b06:	9c 93       	st	X, r25
     b08:	8e 93       	st	-X, r24
     b0a:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     b0c:	ed 93       	st	X+, r30
     b0e:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     b10:	90 93 80 03 	sts	0x0380, r25	; 0x800380 <xMinimumEverFreeBytesRemaining+0x1>
     b14:	80 93 7f 03 	sts	0x037F, r24	; 0x80037f <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     b18:	90 93 82 03 	sts	0x0382, r25	; 0x800382 <xFreeBytesRemaining+0x1>
     b1c:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     b20:	80 e0       	ldi	r24, 0x00	; 0
     b22:	90 e8       	ldi	r25, 0x80	; 128
     b24:	90 93 7e 03 	sts	0x037E, r25	; 0x80037e <xBlockAllocatedBit+0x1>
     b28:	80 93 7d 03 	sts	0x037D, r24	; 0x80037d <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     b2c:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <xBlockAllocatedBit>
     b30:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <xBlockAllocatedBit+0x1>
     b34:	8c 23       	and	r24, r28
     b36:	9d 23       	and	r25, r29
     b38:	89 2b       	or	r24, r25
     b3a:	09 f0       	breq	.+2      	; 0xb3e <pvPortMalloc+0x80>
     b3c:	b2 c0       	rjmp	.+356    	; 0xca2 <pvPortMalloc+0x1e4>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     b3e:	20 97       	sbiw	r28, 0x00	; 0
     b40:	09 f4       	brne	.+2      	; 0xb44 <pvPortMalloc+0x86>
     b42:	b2 c0       	rjmp	.+356    	; 0xca8 <pvPortMalloc+0x1ea>
			{
				xWantedSize += xHeapStructSize;
     b44:	ae 01       	movw	r20, r28
     b46:	4c 5f       	subi	r20, 0xFC	; 252
     b48:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     b4a:	09 f4       	brne	.+2      	; 0xb4e <pvPortMalloc+0x90>
     b4c:	b0 c0       	rjmp	.+352    	; 0xcae <pvPortMalloc+0x1f0>
     b4e:	80 91 81 03 	lds	r24, 0x0381	; 0x800381 <xFreeBytesRemaining>
     b52:	90 91 82 03 	lds	r25, 0x0382	; 0x800382 <xFreeBytesRemaining+0x1>
     b56:	84 17       	cp	r24, r20
     b58:	95 07       	cpc	r25, r21
     b5a:	08 f4       	brcc	.+2      	; 0xb5e <pvPortMalloc+0xa0>
     b5c:	ab c0       	rjmp	.+342    	; 0xcb4 <pvPortMalloc+0x1f6>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     b5e:	e0 91 85 03 	lds	r30, 0x0385	; 0x800385 <xStart>
     b62:	f0 91 86 03 	lds	r31, 0x0386	; 0x800386 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     b66:	a5 e8       	ldi	r26, 0x85	; 133
     b68:	b3 e0       	ldi	r27, 0x03	; 3
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     b6a:	02 c0       	rjmp	.+4      	; 0xb70 <pvPortMalloc+0xb2>
     b6c:	df 01       	movw	r26, r30
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
     b6e:	f9 01       	movw	r30, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     b70:	22 81       	ldd	r18, Z+2	; 0x02
     b72:	33 81       	ldd	r19, Z+3	; 0x03
     b74:	24 17       	cp	r18, r20
     b76:	35 07       	cpc	r19, r21
     b78:	28 f4       	brcc	.+10     	; 0xb84 <pvPortMalloc+0xc6>
     b7a:	20 81       	ld	r18, Z
     b7c:	31 81       	ldd	r19, Z+1	; 0x01
     b7e:	21 15       	cp	r18, r1
     b80:	31 05       	cpc	r19, r1
     b82:	a1 f7       	brne	.-24     	; 0xb6c <pvPortMalloc+0xae>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     b84:	60 91 83 03 	lds	r22, 0x0383	; 0x800383 <pxEnd>
     b88:	70 91 84 03 	lds	r23, 0x0384	; 0x800384 <pxEnd+0x1>
     b8c:	e6 17       	cp	r30, r22
     b8e:	f7 07       	cpc	r31, r23
     b90:	09 f4       	brne	.+2      	; 0xb94 <pvPortMalloc+0xd6>
     b92:	93 c0       	rjmp	.+294    	; 0xcba <pvPortMalloc+0x1fc>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     b94:	cd 91       	ld	r28, X+
     b96:	dc 91       	ld	r29, X
     b98:	11 97       	sbiw	r26, 0x01	; 1
     b9a:	7e 01       	movw	r14, r28
     b9c:	84 e0       	ldi	r24, 0x04	; 4
     b9e:	e8 0e       	add	r14, r24
     ba0:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     ba2:	80 81       	ld	r24, Z
     ba4:	91 81       	ldd	r25, Z+1	; 0x01
     ba6:	8d 93       	st	X+, r24
     ba8:	9c 93       	st	X, r25

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     baa:	82 81       	ldd	r24, Z+2	; 0x02
     bac:	93 81       	ldd	r25, Z+3	; 0x03
     bae:	84 1b       	sub	r24, r20
     bb0:	95 0b       	sbc	r25, r21
     bb2:	89 30       	cpi	r24, 0x09	; 9
     bb4:	91 05       	cpc	r25, r1
     bb6:	08 f4       	brcc	.+2      	; 0xbba <pvPortMalloc+0xfc>
     bb8:	52 c0       	rjmp	.+164    	; 0xc5e <pvPortMalloc+0x1a0>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     bba:	9f 01       	movw	r18, r30
     bbc:	24 0f       	add	r18, r20
     bbe:	35 1f       	adc	r19, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     bc0:	d9 01       	movw	r26, r18
     bc2:	13 96       	adiw	r26, 0x03	; 3
     bc4:	9c 93       	st	X, r25
     bc6:	8e 93       	st	-X, r24
     bc8:	12 97       	sbiw	r26, 0x02	; 2
						pxBlock->xBlockSize = xWantedSize;
     bca:	53 83       	std	Z+3, r21	; 0x03
     bcc:	42 83       	std	Z+2, r20	; 0x02
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     bce:	a5 e8       	ldi	r26, 0x85	; 133
     bd0:	b3 e0       	ldi	r27, 0x03	; 3
     bd2:	01 c0       	rjmp	.+2      	; 0xbd6 <pvPortMalloc+0x118>
     bd4:	dc 01       	movw	r26, r24
     bd6:	8d 91       	ld	r24, X+
     bd8:	9c 91       	ld	r25, X
     bda:	11 97       	sbiw	r26, 0x01	; 1
     bdc:	82 17       	cp	r24, r18
     bde:	93 07       	cpc	r25, r19
     be0:	c8 f3       	brcs	.-14     	; 0xbd4 <pvPortMalloc+0x116>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     be2:	12 96       	adiw	r26, 0x02	; 2
     be4:	4d 91       	ld	r20, X+
     be6:	5c 91       	ld	r21, X
     be8:	13 97       	sbiw	r26, 0x03	; 3
     bea:	8d 01       	movw	r16, r26
     bec:	04 0f       	add	r16, r20
     bee:	15 1f       	adc	r17, r21
     bf0:	20 17       	cp	r18, r16
     bf2:	31 07       	cpc	r19, r17
     bf4:	51 f4       	brne	.+20     	; 0xc0a <pvPortMalloc+0x14c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     bf6:	e9 01       	movw	r28, r18
     bf8:	2a 81       	ldd	r18, Y+2	; 0x02
     bfa:	3b 81       	ldd	r19, Y+3	; 0x03
     bfc:	42 0f       	add	r20, r18
     bfe:	53 1f       	adc	r21, r19
     c00:	13 96       	adiw	r26, 0x03	; 3
     c02:	5c 93       	st	X, r21
     c04:	4e 93       	st	-X, r20
     c06:	12 97       	sbiw	r26, 0x02	; 2
     c08:	9d 01       	movw	r18, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     c0a:	e9 01       	movw	r28, r18
     c0c:	4a 81       	ldd	r20, Y+2	; 0x02
     c0e:	5b 81       	ldd	r21, Y+3	; 0x03
     c10:	89 01       	movw	r16, r18
     c12:	04 0f       	add	r16, r20
     c14:	15 1f       	adc	r17, r21
     c16:	80 17       	cp	r24, r16
     c18:	91 07       	cpc	r25, r17
     c1a:	c9 f4       	brne	.+50     	; 0xc4e <pvPortMalloc+0x190>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     c1c:	60 17       	cp	r22, r16
     c1e:	71 07       	cpc	r23, r17
     c20:	91 f0       	breq	.+36     	; 0xc46 <pvPortMalloc+0x188>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     c22:	e8 01       	movw	r28, r16
     c24:	8a 81       	ldd	r24, Y+2	; 0x02
     c26:	9b 81       	ldd	r25, Y+3	; 0x03
     c28:	48 0f       	add	r20, r24
     c2a:	59 1f       	adc	r21, r25
     c2c:	e9 01       	movw	r28, r18
     c2e:	5b 83       	std	Y+3, r21	; 0x03
     c30:	4a 83       	std	Y+2, r20	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     c32:	8d 91       	ld	r24, X+
     c34:	9c 91       	ld	r25, X
     c36:	11 97       	sbiw	r26, 0x01	; 1
     c38:	ec 01       	movw	r28, r24
     c3a:	88 81       	ld	r24, Y
     c3c:	99 81       	ldd	r25, Y+1	; 0x01
     c3e:	e9 01       	movw	r28, r18
     c40:	99 83       	std	Y+1, r25	; 0x01
     c42:	88 83       	st	Y, r24
     c44:	07 c0       	rjmp	.+14     	; 0xc54 <pvPortMalloc+0x196>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     c46:	e9 01       	movw	r28, r18
     c48:	79 83       	std	Y+1, r23	; 0x01
     c4a:	68 83       	st	Y, r22
     c4c:	03 c0       	rjmp	.+6      	; 0xc54 <pvPortMalloc+0x196>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     c4e:	e9 01       	movw	r28, r18
     c50:	99 83       	std	Y+1, r25	; 0x01
     c52:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     c54:	a2 17       	cp	r26, r18
     c56:	b3 07       	cpc	r27, r19
     c58:	11 f0       	breq	.+4      	; 0xc5e <pvPortMalloc+0x1a0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     c5a:	2d 93       	st	X+, r18
     c5c:	3c 93       	st	X, r19
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     c5e:	22 81       	ldd	r18, Z+2	; 0x02
     c60:	33 81       	ldd	r19, Z+3	; 0x03
     c62:	80 91 81 03 	lds	r24, 0x0381	; 0x800381 <xFreeBytesRemaining>
     c66:	90 91 82 03 	lds	r25, 0x0382	; 0x800382 <xFreeBytesRemaining+0x1>
     c6a:	82 1b       	sub	r24, r18
     c6c:	93 0b       	sbc	r25, r19
     c6e:	90 93 82 03 	sts	0x0382, r25	; 0x800382 <xFreeBytesRemaining+0x1>
     c72:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     c76:	40 91 7f 03 	lds	r20, 0x037F	; 0x80037f <xMinimumEverFreeBytesRemaining>
     c7a:	50 91 80 03 	lds	r21, 0x0380	; 0x800380 <xMinimumEverFreeBytesRemaining+0x1>
     c7e:	84 17       	cp	r24, r20
     c80:	95 07       	cpc	r25, r21
     c82:	20 f4       	brcc	.+8      	; 0xc8c <pvPortMalloc+0x1ce>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     c84:	90 93 80 03 	sts	0x0380, r25	; 0x800380 <xMinimumEverFreeBytesRemaining+0x1>
     c88:	80 93 7f 03 	sts	0x037F, r24	; 0x80037f <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     c8c:	80 91 7d 03 	lds	r24, 0x037D	; 0x80037d <xBlockAllocatedBit>
     c90:	90 91 7e 03 	lds	r25, 0x037E	; 0x80037e <xBlockAllocatedBit+0x1>
     c94:	28 2b       	or	r18, r24
     c96:	39 2b       	or	r19, r25
     c98:	33 83       	std	Z+3, r19	; 0x03
     c9a:	22 83       	std	Z+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     c9c:	11 82       	std	Z+1, r1	; 0x01
     c9e:	10 82       	st	Z, r1
     ca0:	0e c0       	rjmp	.+28     	; 0xcbe <pvPortMalloc+0x200>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     ca2:	e1 2c       	mov	r14, r1
     ca4:	f1 2c       	mov	r15, r1
     ca6:	0b c0       	rjmp	.+22     	; 0xcbe <pvPortMalloc+0x200>
     ca8:	e1 2c       	mov	r14, r1
     caa:	f1 2c       	mov	r15, r1
     cac:	08 c0       	rjmp	.+16     	; 0xcbe <pvPortMalloc+0x200>
     cae:	e1 2c       	mov	r14, r1
     cb0:	f1 2c       	mov	r15, r1
     cb2:	05 c0       	rjmp	.+10     	; 0xcbe <pvPortMalloc+0x200>
     cb4:	e1 2c       	mov	r14, r1
     cb6:	f1 2c       	mov	r15, r1
     cb8:	02 c0       	rjmp	.+4      	; 0xcbe <pvPortMalloc+0x200>
     cba:	e1 2c       	mov	r14, r1
     cbc:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     cbe:	0e 94 18 15 	call	0x2a30	; 0x2a30 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     cc2:	c7 01       	movw	r24, r14
     cc4:	df 91       	pop	r29
     cc6:	cf 91       	pop	r28
     cc8:	1f 91       	pop	r17
     cca:	0f 91       	pop	r16
     ccc:	ff 90       	pop	r15
     cce:	ef 90       	pop	r14
     cd0:	08 95       	ret

00000cd2 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     cd2:	cf 93       	push	r28
     cd4:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     cd6:	00 97       	sbiw	r24, 0x00	; 0
     cd8:	09 f4       	brne	.+2      	; 0xcdc <vPortFree+0xa>
     cda:	68 c0       	rjmp	.+208    	; 0xdac <vPortFree+0xda>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     cdc:	fc 01       	movw	r30, r24
     cde:	34 97       	sbiw	r30, 0x04	; 4
     ce0:	22 81       	ldd	r18, Z+2	; 0x02
     ce2:	33 81       	ldd	r19, Z+3	; 0x03
     ce4:	40 91 7d 03 	lds	r20, 0x037D	; 0x80037d <xBlockAllocatedBit>
     ce8:	50 91 7e 03 	lds	r21, 0x037E	; 0x80037e <xBlockAllocatedBit+0x1>
     cec:	b9 01       	movw	r22, r18
     cee:	64 23       	and	r22, r20
     cf0:	75 23       	and	r23, r21
     cf2:	67 2b       	or	r22, r23
     cf4:	09 f4       	brne	.+2      	; 0xcf8 <vPortFree+0x26>
     cf6:	5a c0       	rjmp	.+180    	; 0xdac <vPortFree+0xda>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     cf8:	60 81       	ld	r22, Z
     cfa:	71 81       	ldd	r23, Z+1	; 0x01
     cfc:	67 2b       	or	r22, r23
     cfe:	09 f0       	breq	.+2      	; 0xd02 <vPortFree+0x30>
     d00:	55 c0       	rjmp	.+170    	; 0xdac <vPortFree+0xda>

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     d02:	ef 01       	movw	r28, r30
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     d04:	40 95       	com	r20
     d06:	50 95       	com	r21
     d08:	24 23       	and	r18, r20
     d0a:	35 23       	and	r19, r21
     d0c:	33 83       	std	Z+3, r19	; 0x03
     d0e:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
     d10:	0e 94 12 15 	call	0x2a24	; 0x2a24 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     d14:	4a 81       	ldd	r20, Y+2	; 0x02
     d16:	5b 81       	ldd	r21, Y+3	; 0x03
     d18:	80 91 81 03 	lds	r24, 0x0381	; 0x800381 <xFreeBytesRemaining>
     d1c:	90 91 82 03 	lds	r25, 0x0382	; 0x800382 <xFreeBytesRemaining+0x1>
     d20:	84 0f       	add	r24, r20
     d22:	95 1f       	adc	r25, r21
     d24:	90 93 82 03 	sts	0x0382, r25	; 0x800382 <xFreeBytesRemaining+0x1>
     d28:	80 93 81 03 	sts	0x0381, r24	; 0x800381 <xFreeBytesRemaining>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     d2c:	e5 e8       	ldi	r30, 0x85	; 133
     d2e:	f3 e0       	ldi	r31, 0x03	; 3
     d30:	01 c0       	rjmp	.+2      	; 0xd34 <vPortFree+0x62>
     d32:	fc 01       	movw	r30, r24
     d34:	80 81       	ld	r24, Z
     d36:	91 81       	ldd	r25, Z+1	; 0x01
     d38:	8c 17       	cp	r24, r28
     d3a:	9d 07       	cpc	r25, r29
     d3c:	d0 f3       	brcs	.-12     	; 0xd32 <vPortFree+0x60>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     d3e:	22 81       	ldd	r18, Z+2	; 0x02
     d40:	33 81       	ldd	r19, Z+3	; 0x03
     d42:	bf 01       	movw	r22, r30
     d44:	62 0f       	add	r22, r18
     d46:	73 1f       	adc	r23, r19
     d48:	c6 17       	cp	r28, r22
     d4a:	d7 07       	cpc	r29, r23
     d4c:	29 f4       	brne	.+10     	; 0xd58 <vPortFree+0x86>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     d4e:	24 0f       	add	r18, r20
     d50:	35 1f       	adc	r19, r21
     d52:	33 83       	std	Z+3, r19	; 0x03
     d54:	22 83       	std	Z+2, r18	; 0x02
     d56:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     d58:	2a 81       	ldd	r18, Y+2	; 0x02
     d5a:	3b 81       	ldd	r19, Y+3	; 0x03
     d5c:	de 01       	movw	r26, r28
     d5e:	a2 0f       	add	r26, r18
     d60:	b3 1f       	adc	r27, r19
     d62:	8a 17       	cp	r24, r26
     d64:	9b 07       	cpc	r25, r27
     d66:	c9 f4       	brne	.+50     	; 0xd9a <vPortFree+0xc8>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     d68:	80 91 83 03 	lds	r24, 0x0383	; 0x800383 <pxEnd>
     d6c:	90 91 84 03 	lds	r25, 0x0384	; 0x800384 <pxEnd+0x1>
     d70:	a8 17       	cp	r26, r24
     d72:	b9 07       	cpc	r27, r25
     d74:	79 f0       	breq	.+30     	; 0xd94 <vPortFree+0xc2>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     d76:	12 96       	adiw	r26, 0x02	; 2
     d78:	8d 91       	ld	r24, X+
     d7a:	9c 91       	ld	r25, X
     d7c:	13 97       	sbiw	r26, 0x03	; 3
     d7e:	28 0f       	add	r18, r24
     d80:	39 1f       	adc	r19, r25
     d82:	3b 83       	std	Y+3, r19	; 0x03
     d84:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     d86:	a0 81       	ld	r26, Z
     d88:	b1 81       	ldd	r27, Z+1	; 0x01
     d8a:	8d 91       	ld	r24, X+
     d8c:	9c 91       	ld	r25, X
     d8e:	99 83       	std	Y+1, r25	; 0x01
     d90:	88 83       	st	Y, r24
     d92:	05 c0       	rjmp	.+10     	; 0xd9e <vPortFree+0xcc>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     d94:	b9 83       	std	Y+1, r27	; 0x01
     d96:	a8 83       	st	Y, r26
     d98:	02 c0       	rjmp	.+4      	; 0xd9e <vPortFree+0xcc>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     d9a:	99 83       	std	Y+1, r25	; 0x01
     d9c:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     d9e:	ec 17       	cp	r30, r28
     da0:	fd 07       	cpc	r31, r29
     da2:	11 f0       	breq	.+4      	; 0xda8 <vPortFree+0xd6>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     da4:	d1 83       	std	Z+1, r29	; 0x01
     da6:	c0 83       	st	Z, r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
     da8:	0e 94 18 15 	call	0x2a30	; 0x2a30 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     dac:	df 91       	pop	r29
     dae:	cf 91       	pop	r28
     db0:	08 95       	ret

00000db2 <sIMU_readRegister>:
    int16_t tempBuffer = (myBuffer[1] << 8);
    int16_t output = (int16_t)myBuffer[0] | tempBuffer;
    
    *outputPointer = output;
    return returnError;
}
     db2:	cf 93       	push	r28
     db4:	df 93       	push	r29
     db6:	ec 01       	movw	r28, r24
     db8:	28 98       	cbi	0x05, 0	; 5
     dba:	86 2f       	mov	r24, r22
     dbc:	80 68       	ori	r24, 0x80	; 128
     dbe:	0e 94 73 12 	call	0x24e6	; 0x24e6 <ui8SPI_MasterTransmit>
     dc2:	80 e0       	ldi	r24, 0x00	; 0
     dc4:	0e 94 73 12 	call	0x24e6	; 0x24e6 <ui8SPI_MasterTransmit>
     dc8:	28 9a       	sbi	0x05, 0	; 5
     dca:	8f 3f       	cpi	r24, 0xFF	; 255
     dcc:	11 f4       	brne	.+4      	; 0xdd2 <sIMU_readRegister+0x20>
     dce:	95 e0       	ldi	r25, 0x05	; 5
     dd0:	01 c0       	rjmp	.+2      	; 0xdd4 <sIMU_readRegister+0x22>
     dd2:	90 e0       	ldi	r25, 0x00	; 0
     dd4:	88 83       	st	Y, r24
     dd6:	89 2f       	mov	r24, r25
     dd8:	df 91       	pop	r29
     dda:	cf 91       	pop	r28
     ddc:	08 95       	ret

00000dde <sIMU_Init>:
     dde:	cf 93       	push	r28
     de0:	df 93       	push	r29
     de2:	1f 92       	push	r1
     de4:	1f 92       	push	r1
     de6:	cd b7       	in	r28, 0x3d	; 61
     de8:	de b7       	in	r29, 0x3e	; 62
     dea:	ec ec       	ldi	r30, 0xCC	; 204
     dec:	f6 e1       	ldi	r31, 0x16	; 22
     dee:	81 e0       	ldi	r24, 0x01	; 1
     df0:	80 83       	st	Z, r24
     df2:	24 ef       	ldi	r18, 0xF4	; 244
     df4:	31 e0       	ldi	r19, 0x01	; 1
     df6:	32 83       	std	Z+2, r19	; 0x02
     df8:	21 83       	std	Z+1, r18	; 0x01
     dfa:	22 e8       	ldi	r18, 0x82	; 130
     dfc:	36 e0       	ldi	r19, 0x06	; 6
     dfe:	34 83       	std	Z+4, r19	; 0x04
     e00:	23 83       	std	Z+3, r18	; 0x03
     e02:	20 e9       	ldi	r18, 0x90	; 144
     e04:	31 e0       	ldi	r19, 0x01	; 1
     e06:	36 83       	std	Z+6, r19	; 0x06
     e08:	25 83       	std	Z+5, r18	; 0x05
     e0a:	17 82       	std	Z+7, r1	; 0x07
     e0c:	10 86       	std	Z+8, r1	; 0x08
     e0e:	81 87       	std	Z+9, r24	; 0x09
     e10:	82 87       	std	Z+10, r24	; 0x0a
     e12:	20 e1       	ldi	r18, 0x10	; 16
     e14:	30 e0       	ldi	r19, 0x00	; 0
     e16:	34 87       	std	Z+12, r19	; 0x0c
     e18:	23 87       	std	Z+11, r18	; 0x0b
     e1a:	2d e0       	ldi	r18, 0x0D	; 13
     e1c:	30 e0       	ldi	r19, 0x00	; 0
     e1e:	36 87       	std	Z+14, r19	; 0x0e
     e20:	25 87       	std	Z+13, r18	; 0x0d
     e22:	22 e3       	ldi	r18, 0x32	; 50
     e24:	30 e0       	ldi	r19, 0x00	; 0
     e26:	30 8b       	std	Z+16, r19	; 0x10
     e28:	27 87       	std	Z+15, r18	; 0x0f
     e2a:	11 8a       	std	Z+17, r1	; 0x11
     e2c:	12 8a       	std	Z+18, r1	; 0x12
     e2e:	83 8b       	std	Z+19, r24	; 0x13
     e30:	84 8b       	std	Z+20, r24	; 0x14
     e32:	88 eb       	ldi	r24, 0xB8	; 184
     e34:	9b e0       	ldi	r25, 0x0B	; 11
     e36:	96 8b       	std	Z+22, r25	; 0x16
     e38:	85 8b       	std	Z+21, r24	; 0x15
     e3a:	8a e0       	ldi	r24, 0x0A	; 10
     e3c:	90 e0       	ldi	r25, 0x00	; 0
     e3e:	90 8f       	std	Z+24, r25	; 0x18
     e40:	87 8b       	std	Z+23, r24	; 0x17
     e42:	11 8e       	std	Z+25, r1	; 0x19
     e44:	10 92 e7 16 	sts	0x16E7, r1	; 0x8016e7 <allOnesCounter+0x1>
     e48:	10 92 e6 16 	sts	0x16E6, r1	; 0x8016e6 <allOnesCounter>
     e4c:	10 92 e9 16 	sts	0x16E9, r1	; 0x8016e9 <nonSuccessCounter+0x1>
     e50:	10 92 e8 16 	sts	0x16E8, r1	; 0x8016e8 <nonSuccessCounter>
     e54:	0e 94 65 12 	call	0x24ca	; 0x24ca <vSPI_MasterInit>
     e58:	20 9a       	sbi	0x04, 0	; 4
     e5a:	28 9a       	sbi	0x05, 0	; 5
     e5c:	19 82       	std	Y+1, r1	; 0x01
     e5e:	20 e1       	ldi	r18, 0x10	; 16
     e60:	37 e2       	ldi	r19, 0x27	; 39
     e62:	89 81       	ldd	r24, Y+1	; 0x01
     e64:	8f 5f       	subi	r24, 0xFF	; 255
     e66:	89 83       	std	Y+1, r24	; 0x01
     e68:	21 50       	subi	r18, 0x01	; 1
     e6a:	31 09       	sbc	r19, r1
     e6c:	d1 f7       	brne	.-12     	; 0xe62 <sIMU_Init+0x84>
     e6e:	6f e0       	ldi	r22, 0x0F	; 15
     e70:	ce 01       	movw	r24, r28
     e72:	02 96       	adiw	r24, 0x02	; 2
     e74:	9e df       	rcall	.-196    	; 0xdb2 <sIMU_readRegister>
     e76:	8a 81       	ldd	r24, Y+2	; 0x02
     e78:	89 36       	cpi	r24, 0x69	; 105
     e7a:	c9 f7       	brne	.-14     	; 0xe6e <sIMU_Init+0x90>
     e7c:	80 e0       	ldi	r24, 0x00	; 0
     e7e:	0f 90       	pop	r0
     e80:	0f 90       	pop	r0
     e82:	df 91       	pop	r29
     e84:	cf 91       	pop	r28
     e86:	08 95       	ret

00000e88 <sIMU_writeRegister>:
//  Parameters:
//    offset -- register to write
//    dataToWrite -- 8 bit data to write to register
//
//****************************************************************************//
status_t sIMU_writeRegister(uint8_t offset, uint8_t dataToWrite ){
     e88:	cf 93       	push	r28
     e8a:	c6 2f       	mov	r28, r22
    status_t returnError = IMU_SUCCESS;

    // take the chip select low to select the device:
    PORTB &= ~(1<<IMU_SS);
     e8c:	28 98       	cbi	0x05, 0	; 5
    // send the device the register you want to read:
    ui8SPI_MasterTransmit(offset);
     e8e:	0e 94 73 12 	call	0x24e6	; 0x24e6 <ui8SPI_MasterTransmit>
    // send a value of 0 to read the first byte returned:
    ui8SPI_MasterTransmit(dataToWrite);
     e92:	8c 2f       	mov	r24, r28
     e94:	0e 94 73 12 	call	0x24e6	; 0x24e6 <ui8SPI_MasterTransmit>
    // decrement the number of bytes left to read:
    // take the chip select high to de-select:
    PORTB |= (1<<IMU_SS);
     e98:	28 9a       	sbi	0x05, 0	; 5
    return returnError;
}
     e9a:	80 e0       	ldi	r24, 0x00	; 0
     e9c:	cf 91       	pop	r28
     e9e:	08 95       	ret

00000ea0 <sIMU_begin>:
//  This uses the stored SensorSettings to start the IMU
//  Use statements such as 
//  "myIMU.settings.accelEnabled = 1;" to configure before calling .begin();
//
//****************************************************************************//
status_t sIMU_begin(){
     ea0:	1f 93       	push	r17
     ea2:	cf 93       	push	r28
     ea4:	df 93       	push	r29
     ea6:	1f 92       	push	r1
     ea8:	1f 92       	push	r1
     eaa:	cd b7       	in	r28, 0x3d	; 61
     eac:	de b7       	in	r29, 0x3e	; 62
    //Check the settings structure values to determine how to setup the device
    uint8_t dataToWrite = 0;  //Temporary variable
     eae:	19 82       	std	Y+1, r1	; 0x01

    //Initialize the IMU and the SPI driver
    status_t returnError = sIMU_Init();
     eb0:	96 df       	rcall	.-212    	; 0xdde <sIMU_Init>
     eb2:	18 2f       	mov	r17, r24

    //Setup the accelerometer******************************
    dataToWrite = 0; //Start Fresh!
     eb4:	19 82       	std	Y+1, r1	; 0x01
    if ( settings.accelEnabled == 1) {
     eb6:	80 91 d5 16 	lds	r24, 0x16D5	; 0x8016d5 <settings+0x9>
     eba:	81 30       	cpi	r24, 0x01	; 1
     ebc:	09 f0       	breq	.+2      	; 0xec0 <sIMU_begin+0x20>
     ebe:	83 c0       	rjmp	.+262    	; 0xfc6 <sIMU_begin+0x126>
        //Build config reg
        //First patch in filter bandwidth
        switch (settings.accelBandWidth) {
     ec0:	80 91 db 16 	lds	r24, 0x16DB	; 0x8016db <settings+0xf>
     ec4:	90 91 dc 16 	lds	r25, 0x16DC	; 0x8016dc <settings+0x10>
     ec8:	84 36       	cpi	r24, 0x64	; 100
     eca:	91 05       	cpc	r25, r1
     ecc:	41 f0       	breq	.+16     	; 0xede <sIMU_begin+0x3e>
     ece:	88 3c       	cpi	r24, 0xC8	; 200
     ed0:	91 05       	cpc	r25, r1
     ed2:	41 f0       	breq	.+16     	; 0xee4 <sIMU_begin+0x44>
     ed4:	c2 97       	sbiw	r24, 0x32	; 50
     ed6:	41 f4       	brne	.+16     	; 0xee8 <sIMU_begin+0x48>
            case 50:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_50Hz;
     ed8:	83 e0       	ldi	r24, 0x03	; 3
     eda:	89 83       	std	Y+1, r24	; 0x01
            break;
     edc:	05 c0       	rjmp	.+10     	; 0xee8 <sIMU_begin+0x48>
            case 100:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_100Hz;
     ede:	82 e0       	ldi	r24, 0x02	; 2
     ee0:	89 83       	std	Y+1, r24	; 0x01
            break;
     ee2:	02 c0       	rjmp	.+4      	; 0xee8 <sIMU_begin+0x48>
            case 200:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_200Hz;
     ee4:	81 e0       	ldi	r24, 0x01	; 1
     ee6:	89 83       	std	Y+1, r24	; 0x01
            case 400:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_400Hz;
            break;
        }
        //Next, patch in full scale
        switch (settings.accelRange) {
     ee8:	80 91 d7 16 	lds	r24, 0x16D7	; 0x8016d7 <settings+0xb>
     eec:	90 91 d8 16 	lds	r25, 0x16D8	; 0x8016d8 <settings+0xc>
     ef0:	84 30       	cpi	r24, 0x04	; 4
     ef2:	91 05       	cpc	r25, r1
     ef4:	31 f0       	breq	.+12     	; 0xf02 <sIMU_begin+0x62>
     ef6:	88 30       	cpi	r24, 0x08	; 8
     ef8:	91 05       	cpc	r25, r1
     efa:	39 f0       	breq	.+14     	; 0xf0a <sIMU_begin+0x6a>
     efc:	02 97       	sbiw	r24, 0x02	; 2
     efe:	49 f4       	brne	.+18     	; 0xf12 <sIMU_begin+0x72>
     f00:	0b c0       	rjmp	.+22     	; 0xf18 <sIMU_begin+0x78>
            case 2:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_2g;
            break;
            case 4:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_4g;
     f02:	89 81       	ldd	r24, Y+1	; 0x01
     f04:	88 60       	ori	r24, 0x08	; 8
     f06:	89 83       	std	Y+1, r24	; 0x01
            break;
     f08:	07 c0       	rjmp	.+14     	; 0xf18 <sIMU_begin+0x78>
            case 8:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_8g;
     f0a:	89 81       	ldd	r24, Y+1	; 0x01
     f0c:	8c 60       	ori	r24, 0x0C	; 12
     f0e:	89 83       	std	Y+1, r24	; 0x01
            break;
     f10:	03 c0       	rjmp	.+6      	; 0xf18 <sIMU_begin+0x78>
            default:  //set default case to 16(max)
            case 16:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_16g;
     f12:	89 81       	ldd	r24, Y+1	; 0x01
     f14:	84 60       	ori	r24, 0x04	; 4
     f16:	89 83       	std	Y+1, r24	; 0x01
            break;
        }
        //Lastly, patch in accelerometer ODR
        switch (settings.accelSampleRate) {
     f18:	80 91 d9 16 	lds	r24, 0x16D9	; 0x8016d9 <settings+0xd>
     f1c:	90 91 da 16 	lds	r25, 0x16DA	; 0x8016da <settings+0xe>
     f20:	80 3a       	cpi	r24, 0xA0	; 160
     f22:	21 e0       	ldi	r18, 0x01	; 1
     f24:	92 07       	cpc	r25, r18
     f26:	c1 f1       	breq	.+112    	; 0xf98 <sIMU_begin+0xf8>
     f28:	70 f4       	brcc	.+28     	; 0xf46 <sIMU_begin+0xa6>
     f2a:	8a 31       	cpi	r24, 0x1A	; 26
     f2c:	91 05       	cpc	r25, r1
     f2e:	21 f1       	breq	.+72     	; 0xf78 <sIMU_begin+0xd8>
     f30:	18 f4       	brcc	.+6      	; 0xf38 <sIMU_begin+0x98>
     f32:	0d 97       	sbiw	r24, 0x0d	; 13
     f34:	e9 f0       	breq	.+58     	; 0xf70 <sIMU_begin+0xd0>
     f36:	28 c0       	rjmp	.+80     	; 0xf88 <sIMU_begin+0xe8>
     f38:	84 33       	cpi	r24, 0x34	; 52
     f3a:	91 05       	cpc	r25, r1
     f3c:	09 f1       	breq	.+66     	; 0xf80 <sIMU_begin+0xe0>
     f3e:	80 3d       	cpi	r24, 0xD0	; 208
     f40:	91 05       	cpc	r25, r1
     f42:	31 f1       	breq	.+76     	; 0xf90 <sIMU_begin+0xf0>
     f44:	21 c0       	rjmp	.+66     	; 0xf88 <sIMU_begin+0xe8>
     f46:	82 30       	cpi	r24, 0x02	; 2
     f48:	2d e0       	ldi	r18, 0x0D	; 13
     f4a:	92 07       	cpc	r25, r18
     f4c:	89 f1       	breq	.+98     	; 0xfb0 <sIMU_begin+0x110>
     f4e:	40 f4       	brcc	.+16     	; 0xf60 <sIMU_begin+0xc0>
     f50:	81 34       	cpi	r24, 0x41	; 65
     f52:	23 e0       	ldi	r18, 0x03	; 3
     f54:	92 07       	cpc	r25, r18
     f56:	21 f1       	breq	.+72     	; 0xfa0 <sIMU_begin+0x100>
     f58:	8c 37       	cpi	r24, 0x7C	; 124
     f5a:	96 40       	sbci	r25, 0x06	; 6
     f5c:	29 f1       	breq	.+74     	; 0xfa8 <sIMU_begin+0x108>
     f5e:	14 c0       	rjmp	.+40     	; 0xf88 <sIMU_begin+0xe8>
     f60:	84 30       	cpi	r24, 0x04	; 4
     f62:	2a e1       	ldi	r18, 0x1A	; 26
     f64:	92 07       	cpc	r25, r18
     f66:	41 f1       	breq	.+80     	; 0xfb8 <sIMU_begin+0x118>
     f68:	82 31       	cpi	r24, 0x12	; 18
     f6a:	94 43       	sbci	r25, 0x34	; 52
     f6c:	49 f1       	breq	.+82     	; 0xfc0 <sIMU_begin+0x120>
     f6e:	0c c0       	rjmp	.+24     	; 0xf88 <sIMU_begin+0xe8>
            case 13:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_13Hz;
     f70:	89 81       	ldd	r24, Y+1	; 0x01
     f72:	80 61       	ori	r24, 0x10	; 16
     f74:	89 83       	std	Y+1, r24	; 0x01
            break;
     f76:	27 c0       	rjmp	.+78     	; 0xfc6 <sIMU_begin+0x126>
            case 26:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_26Hz;
     f78:	89 81       	ldd	r24, Y+1	; 0x01
     f7a:	80 62       	ori	r24, 0x20	; 32
     f7c:	89 83       	std	Y+1, r24	; 0x01
            break;
     f7e:	23 c0       	rjmp	.+70     	; 0xfc6 <sIMU_begin+0x126>
            case 52:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_52Hz;
     f80:	89 81       	ldd	r24, Y+1	; 0x01
     f82:	80 63       	ori	r24, 0x30	; 48
     f84:	89 83       	std	Y+1, r24	; 0x01
            break;
     f86:	1f c0       	rjmp	.+62     	; 0xfc6 <sIMU_begin+0x126>
            default:  //Set default to 104
            case 104:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_104Hz;
     f88:	89 81       	ldd	r24, Y+1	; 0x01
     f8a:	80 64       	ori	r24, 0x40	; 64
     f8c:	89 83       	std	Y+1, r24	; 0x01
            break;
     f8e:	1b c0       	rjmp	.+54     	; 0xfc6 <sIMU_begin+0x126>
            case 208:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_208Hz;
     f90:	89 81       	ldd	r24, Y+1	; 0x01
     f92:	80 65       	ori	r24, 0x50	; 80
     f94:	89 83       	std	Y+1, r24	; 0x01
            break;
     f96:	17 c0       	rjmp	.+46     	; 0xfc6 <sIMU_begin+0x126>
            case 416:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_416Hz;
     f98:	89 81       	ldd	r24, Y+1	; 0x01
     f9a:	80 66       	ori	r24, 0x60	; 96
     f9c:	89 83       	std	Y+1, r24	; 0x01
            break;
     f9e:	13 c0       	rjmp	.+38     	; 0xfc6 <sIMU_begin+0x126>
            case 833:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_833Hz;
     fa0:	89 81       	ldd	r24, Y+1	; 0x01
     fa2:	80 67       	ori	r24, 0x70	; 112
     fa4:	89 83       	std	Y+1, r24	; 0x01
            break;
     fa6:	0f c0       	rjmp	.+30     	; 0xfc6 <sIMU_begin+0x126>
            case 1660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_1660Hz;
     fa8:	89 81       	ldd	r24, Y+1	; 0x01
     faa:	80 68       	ori	r24, 0x80	; 128
     fac:	89 83       	std	Y+1, r24	; 0x01
            break;
     fae:	0b c0       	rjmp	.+22     	; 0xfc6 <sIMU_begin+0x126>
            case 3330:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_3330Hz;
     fb0:	89 81       	ldd	r24, Y+1	; 0x01
     fb2:	80 69       	ori	r24, 0x90	; 144
     fb4:	89 83       	std	Y+1, r24	; 0x01
            break;
     fb6:	07 c0       	rjmp	.+14     	; 0xfc6 <sIMU_begin+0x126>
            case 6660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_6660Hz;
     fb8:	89 81       	ldd	r24, Y+1	; 0x01
     fba:	80 6a       	ori	r24, 0xA0	; 160
     fbc:	89 83       	std	Y+1, r24	; 0x01
            break;
     fbe:	03 c0       	rjmp	.+6      	; 0xfc6 <sIMU_begin+0x126>
            case 13330:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_13330Hz;
     fc0:	89 81       	ldd	r24, Y+1	; 0x01
     fc2:	80 6b       	ori	r24, 0xB0	; 176
     fc4:	89 83       	std	Y+1, r24	; 0x01
    {
        //dataToWrite already = 0 (powerdown);
    }

    //Now, write the patched together data
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL1_XL, dataToWrite);
     fc6:	69 81       	ldd	r22, Y+1	; 0x01
     fc8:	80 e1       	ldi	r24, 0x10	; 16
     fca:	5e df       	rcall	.-324    	; 0xe88 <sIMU_writeRegister>

    //Set the ODR bit
    sIMU_readRegister(&dataToWrite, LSM6DS3_ACC_GYRO_CTRL4_C);
     fcc:	63 e1       	ldi	r22, 0x13	; 19
     fce:	ce 01       	movw	r24, r28
     fd0:	01 96       	adiw	r24, 0x01	; 1
     fd2:	ef de       	rcall	.-546    	; 0xdb2 <sIMU_readRegister>
    dataToWrite &= ~((uint8_t)LSM6DS3_ACC_GYRO_BW_SCAL_ODR_ENABLED);
     fd4:	89 81       	ldd	r24, Y+1	; 0x01
     fd6:	8f 77       	andi	r24, 0x7F	; 127
     fd8:	89 83       	std	Y+1, r24	; 0x01
    if ( settings.accelODROff == 1) {
     fda:	90 91 d6 16 	lds	r25, 0x16D6	; 0x8016d6 <settings+0xa>
     fde:	91 30       	cpi	r25, 0x01	; 1
     fe0:	11 f4       	brne	.+4      	; 0xfe6 <sIMU_begin+0x146>
        dataToWrite |= LSM6DS3_ACC_GYRO_BW_SCAL_ODR_ENABLED;
     fe2:	80 68       	ori	r24, 0x80	; 128
    }
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL4_C, dataToWrite);
     fe4:	89 83       	std	Y+1, r24	; 0x01
     fe6:	69 81       	ldd	r22, Y+1	; 0x01
     fe8:	83 e1       	ldi	r24, 0x13	; 19
     fea:	4e df       	rcall	.-356    	; 0xe88 <sIMU_writeRegister>

    //Setup the gyroscope**********************************************
    dataToWrite = 0; //Start Fresh!
     fec:	19 82       	std	Y+1, r1	; 0x01
    if ( settings.gyroEnabled == 1) {
     fee:	80 91 cc 16 	lds	r24, 0x16CC	; 0x8016cc <settings>
     ff2:	81 30       	cpi	r24, 0x01	; 1
     ff4:	09 f0       	breq	.+2      	; 0xff8 <sIMU_begin+0x158>
     ff6:	5b c0       	rjmp	.+182    	; 0x10ae <sIMU_begin+0x20e>
        //Build config reg
        //First, patch in full scale
        switch (settings.gyroRange) {
     ff8:	80 91 cd 16 	lds	r24, 0x16CD	; 0x8016cd <settings+0x1>
     ffc:	90 91 ce 16 	lds	r25, 0x16CE	; 0x8016ce <settings+0x2>
    1000:	85 3f       	cpi	r24, 0xF5	; 245
    1002:	91 05       	cpc	r25, r1
    1004:	c1 f0       	breq	.+48     	; 0x1036 <sIMU_begin+0x196>
    1006:	20 f4       	brcc	.+8      	; 0x1010 <sIMU_begin+0x170>
    1008:	8d 37       	cpi	r24, 0x7D	; 125
    100a:	91 05       	cpc	r25, r1
    100c:	49 f0       	breq	.+18     	; 0x1020 <sIMU_begin+0x180>
    100e:	11 c0       	rjmp	.+34     	; 0x1032 <sIMU_begin+0x192>
    1010:	84 3f       	cpi	r24, 0xF4	; 244
    1012:	21 e0       	ldi	r18, 0x01	; 1
    1014:	92 07       	cpc	r25, r18
    1016:	39 f0       	breq	.+14     	; 0x1026 <sIMU_begin+0x186>
    1018:	88 3e       	cpi	r24, 0xE8	; 232
    101a:	93 40       	sbci	r25, 0x03	; 3
    101c:	39 f0       	breq	.+14     	; 0x102c <sIMU_begin+0x18c>
    101e:	09 c0       	rjmp	.+18     	; 0x1032 <sIMU_begin+0x192>
            case 125:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_125_ENABLED;
    1020:	82 e0       	ldi	r24, 0x02	; 2
    1022:	89 83       	std	Y+1, r24	; 0x01
            break;
    1024:	08 c0       	rjmp	.+16     	; 0x1036 <sIMU_begin+0x196>
            case 245:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_245dps;
            break;
            case 500:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_500dps;
    1026:	84 e0       	ldi	r24, 0x04	; 4
    1028:	89 83       	std	Y+1, r24	; 0x01
            break;
    102a:	05 c0       	rjmp	.+10     	; 0x1036 <sIMU_begin+0x196>
            case 1000:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_1000dps;
    102c:	88 e0       	ldi	r24, 0x08	; 8
    102e:	89 83       	std	Y+1, r24	; 0x01
            break;
    1030:	02 c0       	rjmp	.+4      	; 0x1036 <sIMU_begin+0x196>
            default:  //Default to full 2000DPS range
            case 2000:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_2000dps;
    1032:	8c e0       	ldi	r24, 0x0C	; 12
    1034:	89 83       	std	Y+1, r24	; 0x01
            break;
        }
        //Lastly, patch in gyro ODR
        switch (settings.gyroSampleRate) {
    1036:	80 91 cf 16 	lds	r24, 0x16CF	; 0x8016cf <settings+0x3>
    103a:	90 91 d0 16 	lds	r25, 0x16D0	; 0x8016d0 <settings+0x4>
    103e:	80 3d       	cpi	r24, 0xD0	; 208
    1040:	91 05       	cpc	r25, r1
    1042:	31 f1       	breq	.+76     	; 0x1090 <sIMU_begin+0x1f0>
    1044:	48 f4       	brcc	.+18     	; 0x1058 <sIMU_begin+0x1b8>
    1046:	8a 31       	cpi	r24, 0x1A	; 26
    1048:	91 05       	cpc	r25, r1
    104a:	b1 f0       	breq	.+44     	; 0x1078 <sIMU_begin+0x1d8>
    104c:	84 33       	cpi	r24, 0x34	; 52
    104e:	91 05       	cpc	r25, r1
    1050:	b9 f0       	breq	.+46     	; 0x1080 <sIMU_begin+0x1e0>
    1052:	0d 97       	sbiw	r24, 0x0d	; 13
    1054:	c9 f4       	brne	.+50     	; 0x1088 <sIMU_begin+0x1e8>
    1056:	0c c0       	rjmp	.+24     	; 0x1070 <sIMU_begin+0x1d0>
    1058:	81 34       	cpi	r24, 0x41	; 65
    105a:	23 e0       	ldi	r18, 0x03	; 3
    105c:	92 07       	cpc	r25, r18
    105e:	01 f1       	breq	.+64     	; 0x10a0 <sIMU_begin+0x200>
    1060:	8c 37       	cpi	r24, 0x7C	; 124
    1062:	26 e0       	ldi	r18, 0x06	; 6
    1064:	92 07       	cpc	r25, r18
    1066:	01 f1       	breq	.+64     	; 0x10a8 <sIMU_begin+0x208>
    1068:	80 3a       	cpi	r24, 0xA0	; 160
    106a:	91 40       	sbci	r25, 0x01	; 1
    106c:	69 f4       	brne	.+26     	; 0x1088 <sIMU_begin+0x1e8>
    106e:	14 c0       	rjmp	.+40     	; 0x1098 <sIMU_begin+0x1f8>
            case 13:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_13Hz;
    1070:	89 81       	ldd	r24, Y+1	; 0x01
    1072:	80 61       	ori	r24, 0x10	; 16
    1074:	89 83       	std	Y+1, r24	; 0x01
            break;
    1076:	1b c0       	rjmp	.+54     	; 0x10ae <sIMU_begin+0x20e>
            case 26:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_26Hz;
    1078:	89 81       	ldd	r24, Y+1	; 0x01
    107a:	80 62       	ori	r24, 0x20	; 32
    107c:	89 83       	std	Y+1, r24	; 0x01
            break;
    107e:	17 c0       	rjmp	.+46     	; 0x10ae <sIMU_begin+0x20e>
            case 52:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_52Hz;
    1080:	89 81       	ldd	r24, Y+1	; 0x01
    1082:	80 63       	ori	r24, 0x30	; 48
    1084:	89 83       	std	Y+1, r24	; 0x01
            break;
    1086:	13 c0       	rjmp	.+38     	; 0x10ae <sIMU_begin+0x20e>
            default:  //Set default to 104
            case 104:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_104Hz;
    1088:	89 81       	ldd	r24, Y+1	; 0x01
    108a:	80 64       	ori	r24, 0x40	; 64
    108c:	89 83       	std	Y+1, r24	; 0x01
            break;
    108e:	0f c0       	rjmp	.+30     	; 0x10ae <sIMU_begin+0x20e>
            case 208:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_208Hz;
    1090:	89 81       	ldd	r24, Y+1	; 0x01
    1092:	80 65       	ori	r24, 0x50	; 80
    1094:	89 83       	std	Y+1, r24	; 0x01
            break;
    1096:	0b c0       	rjmp	.+22     	; 0x10ae <sIMU_begin+0x20e>
            case 416:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_416Hz;
    1098:	89 81       	ldd	r24, Y+1	; 0x01
    109a:	80 66       	ori	r24, 0x60	; 96
    109c:	89 83       	std	Y+1, r24	; 0x01
            break;
    109e:	07 c0       	rjmp	.+14     	; 0x10ae <sIMU_begin+0x20e>
            case 833:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_833Hz;
    10a0:	89 81       	ldd	r24, Y+1	; 0x01
    10a2:	80 67       	ori	r24, 0x70	; 112
    10a4:	89 83       	std	Y+1, r24	; 0x01
            break;
    10a6:	03 c0       	rjmp	.+6      	; 0x10ae <sIMU_begin+0x20e>
            case 1660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_1660Hz;
    10a8:	89 81       	ldd	r24, Y+1	; 0x01
    10aa:	80 68       	ori	r24, 0x80	; 128
    }
    else{
        //dataToWrite already = 0 (powerdown);
    }
    //Write the byte
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL2_G, dataToWrite);
    10ac:	89 83       	std	Y+1, r24	; 0x01
    10ae:	69 81       	ldd	r22, Y+1	; 0x01
    10b0:	81 e1       	ldi	r24, 0x11	; 17
    if ( settings.tempEnabled == 1) {
    }

    //Return WHO AM I reg
    uint8_t result;
    sIMU_readRegister(&result, LSM6DS3_ACC_GYRO_WHO_AM_I_REG);
    10b2:	ea de       	rcall	.-556    	; 0xe88 <sIMU_writeRegister>
    10b4:	6f e0       	ldi	r22, 0x0F	; 15
    10b6:	ce 01       	movw	r24, r28
    10b8:	02 96       	adiw	r24, 0x02	; 2
    10ba:	7b de       	rcall	.-778    	; 0xdb2 <sIMU_readRegister>

    return returnError;
}
    10bc:	81 2f       	mov	r24, r17
    10be:	0f 90       	pop	r0
    10c0:	0f 90       	pop	r0
    10c2:	df 91       	pop	r29
    10c4:	cf 91       	pop	r28
    10c6:	1f 91       	pop	r17
    10c8:	08 95       	ret

000010ca <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    10ca:	ea e0       	ldi	r30, 0x0A	; 10
    10cc:	f1 e0       	ldi	r31, 0x01	; 1
    10ce:	80 81       	ld	r24, Z
    10d0:	87 60       	ori	r24, 0x07	; 7
    10d2:	80 83       	st	Z, r24
    10d4:	08 95       	ret

000010d6 <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
    10d6:	82 30       	cpi	r24, 0x02	; 2
    10d8:	91 05       	cpc	r25, r1
    10da:	31 f4       	brne	.+12     	; 0x10e8 <vLED_singleHigh+0x12>
    10dc:	eb e0       	ldi	r30, 0x0B	; 11
    10de:	f1 e0       	ldi	r31, 0x01	; 1
    10e0:	80 81       	ld	r24, Z
    10e2:	84 60       	ori	r24, 0x04	; 4
    10e4:	80 83       	st	Z, r24
    10e6:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
    10e8:	81 30       	cpi	r24, 0x01	; 1
    10ea:	91 05       	cpc	r25, r1
    10ec:	31 f4       	brne	.+12     	; 0x10fa <vLED_singleHigh+0x24>
    10ee:	eb e0       	ldi	r30, 0x0B	; 11
    10f0:	f1 e0       	ldi	r31, 0x01	; 1
    10f2:	80 81       	ld	r24, Z
    10f4:	82 60       	ori	r24, 0x02	; 2
    10f6:	80 83       	st	Z, r24
    10f8:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
    10fa:	89 2b       	or	r24, r25
    10fc:	29 f4       	brne	.+10     	; 0x1108 <vLED_singleHigh+0x32>
    10fe:	eb e0       	ldi	r30, 0x0B	; 11
    1100:	f1 e0       	ldi	r31, 0x01	; 1
    1102:	80 81       	ld	r24, Z
    1104:	81 60       	ori	r24, 0x01	; 1
    1106:	80 83       	st	Z, r24
    1108:	08 95       	ret

0000110a <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
    110a:	82 30       	cpi	r24, 0x02	; 2
    110c:	91 05       	cpc	r25, r1
    110e:	31 f4       	brne	.+12     	; 0x111c <vLED_singleLow+0x12>
    1110:	eb e0       	ldi	r30, 0x0B	; 11
    1112:	f1 e0       	ldi	r31, 0x01	; 1
    1114:	80 81       	ld	r24, Z
    1116:	8b 7f       	andi	r24, 0xFB	; 251
    1118:	80 83       	st	Z, r24
    111a:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
    111c:	81 30       	cpi	r24, 0x01	; 1
    111e:	91 05       	cpc	r25, r1
    1120:	31 f4       	brne	.+12     	; 0x112e <vLED_singleLow+0x24>
    1122:	eb e0       	ldi	r30, 0x0B	; 11
    1124:	f1 e0       	ldi	r31, 0x01	; 1
    1126:	80 81       	ld	r24, Z
    1128:	8d 7f       	andi	r24, 0xFD	; 253
    112a:	80 83       	st	Z, r24
    112c:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
    112e:	89 2b       	or	r24, r25
    1130:	29 f4       	brne	.+10     	; 0x113c <vLED_singleLow+0x32>
    1132:	eb e0       	ldi	r30, 0x0B	; 11
    1134:	f1 e0       	ldi	r31, 0x01	; 1
    1136:	80 81       	ld	r24, Z
    1138:	8e 7f       	andi	r24, 0xFE	; 254
    113a:	80 83       	st	Z, r24
    113c:	08 95       	ret

0000113e <vLED_toggle>:
}

/* Toggle a single LED */
void vLED_toggle(int ledCOLOR){
	if (ledCOLOR == ledGREEN)		ledPORT ^= (1<<ledGREEN);
    113e:	82 30       	cpi	r24, 0x02	; 2
    1140:	91 05       	cpc	r25, r1
    1142:	39 f4       	brne	.+14     	; 0x1152 <vLED_toggle+0x14>
    1144:	eb e0       	ldi	r30, 0x0B	; 11
    1146:	f1 e0       	ldi	r31, 0x01	; 1
    1148:	90 81       	ld	r25, Z
    114a:	84 e0       	ldi	r24, 0x04	; 4
    114c:	89 27       	eor	r24, r25
    114e:	80 83       	st	Z, r24
    1150:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)	ledPORT ^= (1<<ledYELLOW);
    1152:	81 30       	cpi	r24, 0x01	; 1
    1154:	91 05       	cpc	r25, r1
    1156:	39 f4       	brne	.+14     	; 0x1166 <vLED_toggle+0x28>
    1158:	eb e0       	ldi	r30, 0x0B	; 11
    115a:	f1 e0       	ldi	r31, 0x01	; 1
    115c:	90 81       	ld	r25, Z
    115e:	82 e0       	ldi	r24, 0x02	; 2
    1160:	89 27       	eor	r24, r25
    1162:	80 83       	st	Z, r24
    1164:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT ^= (1<<ledRED);
    1166:	89 2b       	or	r24, r25
    1168:	31 f4       	brne	.+12     	; 0x1176 <vLED_toggle+0x38>
    116a:	eb e0       	ldi	r30, 0x0B	; 11
    116c:	f1 e0       	ldi	r31, 0x01	; 1
    116e:	90 81       	ld	r25, Z
    1170:	81 e0       	ldi	r24, 0x01	; 1
    1172:	89 27       	eor	r24, r25
    1174:	80 83       	st	Z, r24
    1176:	08 95       	ret

00001178 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1178:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    117a:	03 96       	adiw	r24, 0x03	; 3
    117c:	92 83       	std	Z+2, r25	; 0x02
    117e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1180:	2f ef       	ldi	r18, 0xFF	; 255
    1182:	3f ef       	ldi	r19, 0xFF	; 255
    1184:	34 83       	std	Z+4, r19	; 0x04
    1186:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1188:	96 83       	std	Z+6, r25	; 0x06
    118a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    118c:	90 87       	std	Z+8, r25	; 0x08
    118e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1190:	10 82       	st	Z, r1
    1192:	08 95       	ret

00001194 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1194:	fc 01       	movw	r30, r24
    1196:	11 86       	std	Z+9, r1	; 0x09
    1198:	10 86       	std	Z+8, r1	; 0x08
    119a:	08 95       	ret

0000119c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    119c:	cf 93       	push	r28
    119e:	df 93       	push	r29
    11a0:	9c 01       	movw	r18, r24
    11a2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    11a4:	dc 01       	movw	r26, r24
    11a6:	11 96       	adiw	r26, 0x01	; 1
    11a8:	cd 91       	ld	r28, X+
    11aa:	dc 91       	ld	r29, X
    11ac:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    11ae:	d3 83       	std	Z+3, r29	; 0x03
    11b0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    11b2:	8c 81       	ldd	r24, Y+4	; 0x04
    11b4:	9d 81       	ldd	r25, Y+5	; 0x05
    11b6:	95 83       	std	Z+5, r25	; 0x05
    11b8:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    11ba:	8c 81       	ldd	r24, Y+4	; 0x04
    11bc:	9d 81       	ldd	r25, Y+5	; 0x05
    11be:	dc 01       	movw	r26, r24
    11c0:	13 96       	adiw	r26, 0x03	; 3
    11c2:	7c 93       	st	X, r23
    11c4:	6e 93       	st	-X, r22
    11c6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    11c8:	7d 83       	std	Y+5, r23	; 0x05
    11ca:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    11cc:	31 87       	std	Z+9, r19	; 0x09
    11ce:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    11d0:	f9 01       	movw	r30, r18
    11d2:	80 81       	ld	r24, Z
    11d4:	8f 5f       	subi	r24, 0xFF	; 255
    11d6:	80 83       	st	Z, r24
}
    11d8:	df 91       	pop	r29
    11da:	cf 91       	pop	r28
    11dc:	08 95       	ret

000011de <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    11de:	cf 93       	push	r28
    11e0:	df 93       	push	r29
    11e2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    11e4:	48 81       	ld	r20, Y
    11e6:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    11e8:	4f 3f       	cpi	r20, 0xFF	; 255
    11ea:	2f ef       	ldi	r18, 0xFF	; 255
    11ec:	52 07       	cpc	r21, r18
    11ee:	21 f4       	brne	.+8      	; 0x11f8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    11f0:	fc 01       	movw	r30, r24
    11f2:	a7 81       	ldd	r26, Z+7	; 0x07
    11f4:	b0 85       	ldd	r27, Z+8	; 0x08
    11f6:	0d c0       	rjmp	.+26     	; 0x1212 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    11f8:	dc 01       	movw	r26, r24
    11fa:	13 96       	adiw	r26, 0x03	; 3
    11fc:	01 c0       	rjmp	.+2      	; 0x1200 <vListInsert+0x22>
    11fe:	df 01       	movw	r26, r30
    1200:	12 96       	adiw	r26, 0x02	; 2
    1202:	ed 91       	ld	r30, X+
    1204:	fc 91       	ld	r31, X
    1206:	13 97       	sbiw	r26, 0x03	; 3
    1208:	20 81       	ld	r18, Z
    120a:	31 81       	ldd	r19, Z+1	; 0x01
    120c:	42 17       	cp	r20, r18
    120e:	53 07       	cpc	r21, r19
    1210:	b0 f7       	brcc	.-20     	; 0x11fe <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1212:	12 96       	adiw	r26, 0x02	; 2
    1214:	ed 91       	ld	r30, X+
    1216:	fc 91       	ld	r31, X
    1218:	13 97       	sbiw	r26, 0x03	; 3
    121a:	fb 83       	std	Y+3, r31	; 0x03
    121c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    121e:	d5 83       	std	Z+5, r29	; 0x05
    1220:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1222:	bd 83       	std	Y+5, r27	; 0x05
    1224:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1226:	13 96       	adiw	r26, 0x03	; 3
    1228:	dc 93       	st	X, r29
    122a:	ce 93       	st	-X, r28
    122c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    122e:	99 87       	std	Y+9, r25	; 0x09
    1230:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1232:	fc 01       	movw	r30, r24
    1234:	20 81       	ld	r18, Z
    1236:	2f 5f       	subi	r18, 0xFF	; 255
    1238:	20 83       	st	Z, r18
}
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	08 95       	ret

00001240 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1240:	cf 93       	push	r28
    1242:	df 93       	push	r29
    1244:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1246:	a0 85       	ldd	r26, Z+8	; 0x08
    1248:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    124a:	c2 81       	ldd	r28, Z+2	; 0x02
    124c:	d3 81       	ldd	r29, Z+3	; 0x03
    124e:	84 81       	ldd	r24, Z+4	; 0x04
    1250:	95 81       	ldd	r25, Z+5	; 0x05
    1252:	9d 83       	std	Y+5, r25	; 0x05
    1254:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1256:	c4 81       	ldd	r28, Z+4	; 0x04
    1258:	d5 81       	ldd	r29, Z+5	; 0x05
    125a:	82 81       	ldd	r24, Z+2	; 0x02
    125c:	93 81       	ldd	r25, Z+3	; 0x03
    125e:	9b 83       	std	Y+3, r25	; 0x03
    1260:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1262:	11 96       	adiw	r26, 0x01	; 1
    1264:	8d 91       	ld	r24, X+
    1266:	9c 91       	ld	r25, X
    1268:	12 97       	sbiw	r26, 0x02	; 2
    126a:	e8 17       	cp	r30, r24
    126c:	f9 07       	cpc	r31, r25
    126e:	31 f4       	brne	.+12     	; 0x127c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1270:	84 81       	ldd	r24, Z+4	; 0x04
    1272:	95 81       	ldd	r25, Z+5	; 0x05
    1274:	12 96       	adiw	r26, 0x02	; 2
    1276:	9c 93       	st	X, r25
    1278:	8e 93       	st	-X, r24
    127a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    127c:	11 86       	std	Z+9, r1	; 0x09
    127e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1280:	8c 91       	ld	r24, X
    1282:	81 50       	subi	r24, 0x01	; 1
    1284:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1286:	df 91       	pop	r29
    1288:	cf 91       	pop	r28
    128a:	08 95       	ret

0000128c <vApplicationStackOverflowHook>:
}
#endif
*/
/*  In case of stack overflow, disable all interrupts and handle it  */
void vApplicationStackOverflowHook(TaskHandle_t *pxTask, signed char *pcTaskName){
    cli();
    128c:	f8 94       	cli
    /*  Handle overflow */
    #ifdef DEBUG
       debug("Overflow\n");
    #endif
    while(1){
        vLED_toggle(ledRED);
    128e:	80 e0       	ldi	r24, 0x00	; 0
    1290:	90 e0       	ldi	r25, 0x00	; 0
    1292:	55 df       	rcall	.-342    	; 0x113e <vLED_toggle>
    1294:	fc cf       	rjmp	.-8      	; 0x128e <vApplicationStackOverflowHook+0x2>

00001296 <main>:

/*  Main function   */
int main(void){
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */
    vLED_init();
    1296:	19 df       	rcall	.-462    	; 0x10ca <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    1298:	80 e0       	ldi	r24, 0x00	; 0
    129a:	90 e0       	ldi	r25, 0x00	; 0
    129c:	1c df       	rcall	.-456    	; 0x10d6 <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    129e:	0e 94 8b 1b 	call	0x3716	; 0x3716 <vUSART_init>
    network_init();
    12a2:	2d d1       	rcall	.+602    	; 0x14fe <network_init>
    arq_init();
    12a4:	0e 94 15 01 	call	0x22a	; 0x22a <arq_init>
    simple_p_init(server_receiver);
    12a8:	8c ee       	ldi	r24, 0xEC	; 236
    12aa:	90 e1       	ldi	r25, 0x10	; 16
    12ac:	0e 94 db 11 	call	0x23b6	; 0x23b6 <simple_p_init>
    #endif
    
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    /* Initialize sensors */
    vDistSens_init();
    12b0:	80 e0       	ldi	r24, 0x00	; 0
    /* Initialize motor controller */
    vMotor_init();
    12b2:	f9 d7       	rcall	.+4082   	; 0x22a6 <vServo_init>
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        debug("IMU init..\n");
    #endif
	vLED_singleHigh(ledGREEN);
    12b4:	f4 db       	rcall	.-2072   	; 0xa9e <vDistSens_init>
    12b6:	7f d0       	rcall	.+254    	; 0x13b6 <vMotor_init>
    12b8:	82 e0       	ldi	r24, 0x02	; 2
    sIMU_begin(); 
    12ba:	90 e0       	ldi	r25, 0x00	; 0
   vLED_singleLow(ledGREEN);
    12bc:	0c df       	rcall	.-488    	; 0x10d6 <vLED_singleHigh>
    12be:	f0 dd       	rcall	.-1056   	; 0xea0 <sIMU_begin>
    12c0:	82 e0       	ldi	r24, 0x02	; 2
    12c2:	90 e0       	ldi	r25, 0x00	; 0
   vLED_singleLow(ledRED);
    12c4:	22 df       	rcall	.-444    	; 0x110a <vLED_singleLow>
    12c6:	80 e0       	ldi	r24, 0x00	; 0
    12c8:	90 e0       	ldi	r25, 0x00	; 0
    12ca:	1f df       	rcall	.-450    	; 0x110a <vLED_singleLow>

	
	/* ************************************* TESTING **************************************/
	while (1)
	{
		vServo_setAngle(0);
    12cc:	80 e0       	ldi	r24, 0x00	; 0
    12ce:	d3 d7       	rcall	.+4006   	; 0x2276 <vServo_setAngle>
    12d0:	2f ef       	ldi	r18, 0xFF	; 255
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    12d2:	83 e2       	ldi	r24, 0x23	; 35
    12d4:	94 ef       	ldi	r25, 0xF4	; 244
    12d6:	21 50       	subi	r18, 0x01	; 1
    12d8:	80 40       	sbci	r24, 0x00	; 0
    12da:	90 40       	sbci	r25, 0x00	; 0
    12dc:	e1 f7       	brne	.-8      	; 0x12d6 <main+0x40>
    12de:	00 c0       	rjmp	.+0      	; 0x12e0 <main+0x4a>
    12e0:	00 00       	nop
    12e2:	f4 cf       	rjmp	.-24     	; 0x12cc <main+0x36>

000012e4 <__vector_4>:
    12e4:	1f 92       	push	r1

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    12e6:	0f 92       	push	r0
    12e8:	0f b6       	in	r0, 0x3f	; 63
    12ea:	0f 92       	push	r0
    12ec:	11 24       	eor	r1, r1
    12ee:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    12f0:	80 91 8b 15 	lds	r24, 0x158B	; 0x80158b <gISR_leftWheelTicks>
    12f4:	8f 5f       	subi	r24, 0xFF	; 255
    12f6:	80 93 8b 15 	sts	0x158B, r24	; 0x80158b <gISR_leftWheelTicks>
}
    12fa:	8f 91       	pop	r24
    12fc:	0f 90       	pop	r0
    12fe:	0f be       	out	0x3f, r0	; 63
    1300:	0f 90       	pop	r0
    1302:	1f 90       	pop	r1
    1304:	18 95       	reti

00001306 <__vector_3>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    1306:	1f 92       	push	r1
    1308:	0f 92       	push	r0
    130a:	0f b6       	in	r0, 0x3f	; 63
    130c:	0f 92       	push	r0
    130e:	11 24       	eor	r1, r1
    1310:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    1312:	80 91 8c 15 	lds	r24, 0x158C	; 0x80158c <gISR_rightWheelTicks>
    1316:	8f 5f       	subi	r24, 0xFF	; 255
    1318:	80 93 8c 15 	sts	0x158C, r24	; 0x80158c <gISR_rightWheelTicks>
}
    131c:	8f 91       	pop	r24
    131e:	0f 90       	pop	r0
    1320:	0f be       	out	0x3f, r0	; 63
    1322:	0f 90       	pop	r0
    1324:	1f 90       	pop	r1
    1326:	18 95       	reti

00001328 <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    1328:	1f 92       	push	r1
    132a:	0f 92       	push	r0
    132c:	0f b6       	in	r0, 0x3f	; 63
    132e:	0f 92       	push	r0
    1330:	11 24       	eor	r1, r1
    1332:	0b b6       	in	r0, 0x3b	; 59
    1334:	0f 92       	push	r0
    1336:	2f 93       	push	r18
    1338:	3f 93       	push	r19
    133a:	4f 93       	push	r20
    133c:	5f 93       	push	r21
    133e:	6f 93       	push	r22
    1340:	7f 93       	push	r23
    1342:	8f 93       	push	r24
    1344:	9f 93       	push	r25
    1346:	af 93       	push	r26
    1348:	bf 93       	push	r27
    134a:	ef 93       	push	r30
    134c:	ff 93       	push	r31
    if (nRFconnected){
    134e:	64 99       	sbic	0x0c, 4	; 12
    1350:	04 c0       	rjmp	.+8      	; 0x135a <__vector_5+0x32>
        // indicate we are connected
        vLED_singleHigh(ledGREEN);
    1352:	82 e0       	ldi	r24, 0x02	; 2
    1354:	90 e0       	ldi	r25, 0x00	; 0
    1356:	bf de       	rcall	.-642    	; 0x10d6 <vLED_singleHigh>
    1358:	14 c0       	rjmp	.+40     	; 0x1382 <__vector_5+0x5a>
        
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    135a:	10 92 8a 15 	sts	0x158A, r1	; 0x80158a <gHandshook>
        gPaused = FALSE;
    135e:	10 92 89 15 	sts	0x1589, r1	; 0x801589 <gPaused>
        vLED_singleLow(ledGREEN);
    1362:	82 e0       	ldi	r24, 0x02	; 2
    1364:	90 e0       	ldi	r25, 0x00	; 0
    1366:	d1 de       	rcall	.-606    	; 0x110a <vLED_singleLow>
        vLED_singleLow(ledYELLOW);
    1368:	81 e0       	ldi	r24, 0x01	; 1
    136a:	90 e0       	ldi	r25, 0x00	; 0
    136c:	ce de       	rcall	.-612    	; 0x110a <vLED_singleLow>
        vLED_singleLow(ledRED);
    136e:	80 e0       	ldi	r24, 0x00	; 0
    1370:	90 e0       	ldi	r25, 0x00	; 0
    1372:	cb de       	rcall	.-618    	; 0x110a <vLED_singleLow>
    1374:	60 e0       	ldi	r22, 0x00	; 0
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    1376:	70 e0       	ldi	r23, 0x00	; 0
    1378:	80 91 f2 16 	lds	r24, 0x16F2	; 0x8016f2 <xCommandReadyBSem>
    137c:	90 91 f3 16 	lds	r25, 0x16F3	; 0x8016f3 <xCommandReadyBSem+0x1>
    1380:	6c d5       	rcall	.+2776   	; 0x1e5a <xQueueGiveFromISR>
    1382:	60 e0       	ldi	r22, 0x00	; 0
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    1384:	70 e0       	ldi	r23, 0x00	; 0
    1386:	80 91 ec 16 	lds	r24, 0x16EC	; 0x8016ec <xControllerBSem>
    138a:	90 91 ed 16 	lds	r25, 0x16ED	; 0x8016ed <xControllerBSem+0x1>
    138e:	65 d5       	rcall	.+2762   	; 0x1e5a <xQueueGiveFromISR>
    1390:	ff 91       	pop	r31
}
    1392:	ef 91       	pop	r30
    1394:	bf 91       	pop	r27
    1396:	af 91       	pop	r26
    1398:	9f 91       	pop	r25
    139a:	8f 91       	pop	r24
    139c:	7f 91       	pop	r23
    139e:	6f 91       	pop	r22
    13a0:	5f 91       	pop	r21
    13a2:	4f 91       	pop	r20
    13a4:	3f 91       	pop	r19
    13a6:	2f 91       	pop	r18
    13a8:	0f 90       	pop	r0
    13aa:	0b be       	out	0x3b, r0	; 59
    13ac:	0f 90       	pop	r0
    13ae:	0f be       	out	0x3f, r0	; 63
    13b0:	0f 90       	pop	r0
    13b2:	1f 90       	pop	r1
    13b4:	18 95       	reti

000013b6 <vMotor_init>:
    13b6:	27 9a       	sbi	0x04, 7	; 4
// Note: ISR Routines are in main.c
/************************************************************************/
void vMotor_init(){
    /* Initialize motor pins as output */
    DDRB |= (1<<motorLeftOn);
    DDRB |= (1<<motorLeftBackward) | (1<<motorLeftForward);
    13b8:	84 b1       	in	r24, 0x04	; 4
    13ba:	80 63       	ori	r24, 0x30	; 48
    13bc:	84 b9       	out	0x04, r24	; 4
    DDRB |= (1<<motorRightOn);
    13be:	26 9a       	sbi	0x04, 6	; 4
    DDRH |= (1<<motorRightForward) | (1<<motorRightBackward); 
    13c0:	e1 e0       	ldi	r30, 0x01	; 1
    13c2:	f1 e0       	ldi	r31, 0x01	; 1
    13c4:	80 81       	ld	r24, Z
    13c6:	80 66       	ori	r24, 0x60	; 96
    13c8:	80 83       	st	Z, r24
    
    /* Set motor high and direction low to ensure zero movement */
    PORTB &= ~(1<<motorLeftOn);
    13ca:	2f 98       	cbi	0x05, 7	; 5
    PORTB &= ~(1<<motorRightOn);
    13cc:	2e 98       	cbi	0x05, 6	; 5
    PORTH &= ~(1<<motorRightBackward) & ~(1<<motorRightForward);
    13ce:	e2 e0       	ldi	r30, 0x02	; 2
    13d0:	f1 e0       	ldi	r31, 0x01	; 1
    13d2:	80 81       	ld	r24, Z
    13d4:	8f 79       	andi	r24, 0x9F	; 159
    13d6:	80 83       	st	Z, r24
    PORTB &= ~(1<<motorLeftForward) & ~(1<<motorLeftBackward);
    13d8:	85 b1       	in	r24, 0x05	; 5
    13da:	8f 7c       	andi	r24, 0xCF	; 207
    13dc:	85 b9       	out	0x05, r24	; 5
    
    /* Initialize motor encoder pins as input */
    DDRD &= ~((1<<encoderPinRight) & (1<<encoderPinLeft));
    13de:	8a b1       	in	r24, 0x0a	; 10
    13e0:	8a b9       	out	0x0a, r24	; 10
    /* Enable pull up for encoder inputs */
    PORTD |= (1<<encoderPinLeft) | (1<<encoderPinRight);
    13e2:	8b b1       	in	r24, 0x0b	; 11
    13e4:	8c 60       	ori	r24, 0x0C	; 12
    13e6:	8b b9       	out	0x0b, r24	; 11
    
    /* nRF dongle pin 19 as input pin */    
    DDRE &= ~(1<<nRF19); // dongle pin input    
    13e8:	6c 98       	cbi	0x0d, 4	; 13
    
    /* Clear interrupt enable bits to ensure no interrupts occur */
    EIMSK &= ~((1<<INT2) & (1<<INT3) & (1<<INT4));
    13ea:	8d b3       	in	r24, 0x1d	; 29
    13ec:	8d bb       	out	0x1d, r24	; 29

    /* Set interrupt to trigger on rising edge for motor and any change for dongle */
    /* Datasheet p110-11 table 15-1,3 */
    EICRA |= (1<<ISC21) | (1<<ISC20) | (1<<ISC31) | (1<<ISC30);                             //MÅ KANKJSE SJEKKE UT DENNE NØYERE
    13ee:	e9 e6       	ldi	r30, 0x69	; 105
    13f0:	f0 e0       	ldi	r31, 0x00	; 0
    13f2:	80 81       	ld	r24, Z
    13f4:	80 6f       	ori	r24, 0xF0	; 240
    13f6:	80 83       	st	Z, r24
    EICRB |= (1<<ISC40);
    13f8:	ea e6       	ldi	r30, 0x6A	; 106
    13fa:	f0 e0       	ldi	r31, 0x00	; 0
    13fc:	80 81       	ld	r24, Z
    13fe:	81 60       	ori	r24, 0x01	; 1
    1400:	80 83       	st	Z, r24
    
    /* Clear interrupt flag for INT2, 3 and 4 */
    EIFR = (1<<INTF2) | (1<<INTF3) | (1<<INTF4);
    1402:	8c e1       	ldi	r24, 0x1C	; 28
    1404:	8c bb       	out	0x1c, r24	; 28

    /* Enable interrupts for INT2, 3 and 4 */
    EIMSK |= (1<<INT2) | (1<<INT3) | (1<<INT4);
    1406:	8d b3       	in	r24, 0x1d	; 29
    1408:	8c 61       	ori	r24, 0x1C	; 28
    140a:	8d bb       	out	0x1d, r24	; 29
    /* Set up PWM for left motor connected to OC0A (8bit PWM) and right motor */
	/* connected to OC1B (16bit PWM)
    /* Clear OCnA/OCnB on Compare Match, set */
    /* OCnA/OCnB at BOTTOM (non-inverting mode) */
    /* Datasheet p.132 Table 14-3 */    
    TCCR0A |= (1<<COM0A1) | (0<<COM0A0);
    140c:	84 b5       	in	r24, 0x24	; 36
    140e:	80 68       	ori	r24, 0x80	; 128
    1410:	84 bd       	out	0x24, r24	; 36
    TCCR1A |= (1<<COM1B1) | (0<<COM1B1);
    1412:	e0 e8       	ldi	r30, 0x80	; 128
    1414:	f0 e0       	ldi	r31, 0x00	; 0
    1416:	80 81       	ld	r24, Z
    1418:	80 62       	ori	r24, 0x20	; 32
    141a:	80 83       	st	Z, r24
    /* Waveform generation mode 3: Fast 8bit PWM */
    /* Top 0x00FF, Update bottom, flag set on top */
    /* Datasheet p.133 Table 14-5 */
	TCCR0B |= (0<<WGM02);
    141c:	85 b5       	in	r24, 0x25	; 37
    141e:	85 bd       	out	0x25, r24	; 37
    TCCR0A |= (1<<WGM01) | (1<<WGM00);
    1420:	84 b5       	in	r24, 0x24	; 36
    1422:	83 60       	ori	r24, 0x03	; 3
    1424:	84 bd       	out	0x24, r24	; 36
	
	TCCR1B |= (0<<WGM13) | (1<<WGM12);
    1426:	a1 e8       	ldi	r26, 0x81	; 129
    1428:	b0 e0       	ldi	r27, 0x00	; 0
    142a:	8c 91       	ld	r24, X
    142c:	88 60       	ori	r24, 0x08	; 8
    142e:	8c 93       	st	X, r24
	TCCR1A |= (0<<WGM11) | (1<<WGM10);
    1430:	80 81       	ld	r24, Z
    1432:	81 60       	ori	r24, 0x01	; 1
    1434:	80 83       	st	Z, r24
    
    /* Clock select bit description: */
    /* clkI/O/8 (From prescaler) - Datasheet p.157 Table 17-6*/
    TCCR0B |= (0<<CS02) | (1<<CS01) | (0<<CS00);
    1436:	85 b5       	in	r24, 0x25	; 37
    1438:	82 60       	ori	r24, 0x02	; 2
    143a:	85 bd       	out	0x25, r24	; 37
	TCCR1B |= (0<<CS12) | (1<<CS11) | (0<<CS10); 
    143c:	8c 91       	ld	r24, X
    143e:	82 60       	ori	r24, 0x02	; 2
    1440:	8c 93       	st	X, r24
	
	/* Set other motorpins to normal operation mode (connected to PWM ports)	*/
	/* Datasheet p.155 Table 17-3												*/
	
	TCCR1A |= (0<<COM1A1) | (0<<COM1A0); // MC_IN1 left backwards connected to OC1A
    1442:	80 81       	ld	r24, Z
    1444:	80 83       	st	Z, r24
	TCCR2A |= (0<<COM2A1) | (0<<COM2A0); // MC_IN1 left backwards connected to OC2A
    1446:	e0 eb       	ldi	r30, 0xB0	; 176
    1448:	f0 e0       	ldi	r31, 0x00	; 0
    144a:	80 81       	ld	r24, Z
    144c:	80 83       	st	Z, r24
	TCCR2A |= (0<<COM2B1) | (0<<COM2B0); // MC_IN1 left backwards connected to OC2B
    144e:	80 81       	ld	r24, Z
    1450:	80 83       	st	Z, r24
	TCCR4A |= (0<<COM4C1) | (0<<COM4C0); // MC_IN1 left backwards connected to OC4C
    1452:	e0 ea       	ldi	r30, 0xA0	; 160
    1454:	f0 e0       	ldi	r31, 0x00	; 0
    1456:	80 81       	ld	r24, Z
    1458:	80 83       	st	Z, r24
    145a:	08 95       	ret

0000145c <network_receive>:

uint8_t network_get_address(void) {
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
    145c:	ef 92       	push	r14
    145e:	ff 92       	push	r15
    1460:	0f 93       	push	r16
    1462:	1f 93       	push	r17
    1464:	cf 93       	push	r28
    1466:	df 93       	push	r29
    1468:	7c 01       	movw	r14, r24
    146a:	8b 01       	movw	r16, r22
   uint8_t *decoded_data = pvPortMalloc(len);
    146c:	cb 01       	movw	r24, r22
    146e:	27 db       	rcall	.-2482   	; 0xabe <pvPortMalloc>
    1470:	ec 01       	movw	r28, r24
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    1472:	98 01       	movw	r18, r16
    1474:	21 50       	subi	r18, 0x01	; 1
    1476:	31 09       	sbc	r19, r1
    1478:	a7 01       	movw	r20, r14
    147a:	b8 01       	movw	r22, r16
    147c:	6f da       	rcall	.-2850   	; 0x95c <cobs_decode>
   static uint8_t cobs = 0;
   static uint8_t crc = 0;
   if(result.status != COBS_DECODE_OK) {
    147e:	88 23       	and	r24, r24
    1480:	41 f0       	breq	.+16     	; 0x1492 <network_receive+0x36>
	   ++cobs;
    1482:	80 91 8e 15 	lds	r24, 0x158E	; 0x80158e <cobs.2024>
    1486:	8f 5f       	subi	r24, 0xFF	; 255
    1488:	80 93 8e 15 	sts	0x158E, r24	; 0x80158e <cobs.2024>
	   vPortFree(decoded_data);
    148c:	ce 01       	movw	r24, r28
    148e:	21 dc       	rcall	.-1982   	; 0xcd2 <vPortFree>
	   return;
    1490:	2f c0       	rjmp	.+94     	; 0x14f0 <network_receive+0x94>
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
   uint8_t *decoded_data = pvPortMalloc(len);
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    1492:	86 2f       	mov	r24, r22
    1494:	97 2f       	mov	r25, r23
    1496:	8c 01       	movw	r16, r24
   if(result.status != COBS_DECODE_OK) {
	   ++cobs;
	   vPortFree(decoded_data);
	   return;
   }
   if(decoded_data[result.out_len-1] != calculate_crc(decoded_data, result.out_len-1) ) {
    1498:	fe 01       	movw	r30, r28
    149a:	e8 0f       	add	r30, r24
    149c:	f9 1f       	adc	r31, r25
    149e:	31 97       	sbiw	r30, 0x01	; 1
    14a0:	f0 80       	ld	r15, Z
    14a2:	6f ef       	ldi	r22, 0xFF	; 255
    14a4:	68 0f       	add	r22, r24
    14a6:	ce 01       	movw	r24, r28
    14a8:	e3 da       	rcall	.-2618   	; 0xa70 <calculate_crc>
    14aa:	f8 16       	cp	r15, r24
    14ac:	41 f0       	breq	.+16     	; 0x14be <network_receive+0x62>
	   ++crc;
    14ae:	80 91 8d 15 	lds	r24, 0x158D	; 0x80158d <crc.2025>
    14b2:	8f 5f       	subi	r24, 0xFF	; 255
    14b4:	80 93 8d 15 	sts	0x158D, r24	; 0x80158d <crc.2025>
	   vPortFree(decoded_data);
    14b8:	ce 01       	movw	r24, r28
    14ba:	0b dc       	rcall	.-2026   	; 0xcd2 <vPortFree>
	   return;
   }
   uint8_t receiver = decoded_data[0];
   uint8_t sender = decoded_data[1];
   uint8_t protocol = decoded_data[2];
   if(receiver != ADDRESS) {
    14bc:	19 c0       	rjmp	.+50     	; 0x14f0 <network_receive+0x94>
    14be:	88 81       	ld	r24, Y
    14c0:	83 30       	cpi	r24, 0x03	; 3
	   vPortFree(decoded_data);
    14c2:	19 f0       	breq	.+6      	; 0x14ca <network_receive+0x6e>
    14c4:	ce 01       	movw	r24, r28
    14c6:	05 dc       	rcall	.-2038   	; 0xcd2 <vPortFree>
	   return;
    14c8:	13 c0       	rjmp	.+38     	; 0x14f0 <network_receive+0x94>
   }
   receive_callbacks[protocol](sender, decoded_data+3, result.out_len-4);
    14ca:	a8 01       	movw	r20, r16
    14cc:	44 50       	subi	r20, 0x04	; 4
    14ce:	51 09       	sbc	r21, r1
    14d0:	be 01       	movw	r22, r28
    14d2:	6d 5f       	subi	r22, 0xFD	; 253
    14d4:	7f 4f       	sbci	r23, 0xFF	; 255
    14d6:	ea 81       	ldd	r30, Y+2	; 0x02
    14d8:	f0 e0       	ldi	r31, 0x00	; 0
    14da:	ee 0f       	add	r30, r30
    14dc:	ff 1f       	adc	r31, r31
    14de:	ec 5e       	subi	r30, 0xEC	; 236
    14e0:	f8 4e       	sbci	r31, 0xE8	; 232
    14e2:	01 90       	ld	r0, Z+
    14e4:	f0 81       	ld	r31, Z
    14e6:	e0 2d       	mov	r30, r0
    14e8:	89 81       	ldd	r24, Y+1	; 0x01
   vPortFree(decoded_data);
    14ea:	19 95       	eicall
    14ec:	ce 01       	movw	r24, r28
    14ee:	f1 db       	rcall	.-2078   	; 0xcd2 <vPortFree>
}
    14f0:	df 91       	pop	r29
    14f2:	cf 91       	pop	r28
    14f4:	1f 91       	pop	r17
    14f6:	0f 91       	pop	r16
    14f8:	ff 90       	pop	r15
    14fa:	ef 90       	pop	r14
    14fc:	08 95       	ret

000014fe <network_init>:
void network_receive(uint8_t *frame, uint16_t len);

void (*receive_callbacks[10])(uint8_t, uint8_t*, uint16_t);

void network_init(void) {
  vUSART_set_receive_callback(network_receive);
    14fe:	8e e2       	ldi	r24, 0x2E	; 46
    1500:	9a e0       	ldi	r25, 0x0A	; 10
    1502:	0c 94 05 1c 	jmp	0x380a	; 0x380a <vUSART_set_receive_callback>
    1506:	08 95       	ret

00001508 <network_set_callback>:
}

void network_set_callback(uint8_t protocol, void (*cb)(uint8_t, uint8_t*, uint16_t)) {
  if(protocol == PROTOCOL_ARQ || protocol == PROTOCOL_SIMPLE) receive_callbacks[protocol] = cb;
    1508:	82 30       	cpi	r24, 0x02	; 2
    150a:	40 f4       	brcc	.+16     	; 0x151c <network_set_callback+0x14>
    150c:	e8 2f       	mov	r30, r24
    150e:	f0 e0       	ldi	r31, 0x00	; 0
    1510:	ee 0f       	add	r30, r30
    1512:	ff 1f       	adc	r31, r31
    1514:	ec 5e       	subi	r30, 0xEC	; 236
    1516:	f8 4e       	sbci	r31, 0xE8	; 232
    1518:	71 83       	std	Z+1, r23	; 0x01
    151a:	60 83       	st	Z, r22
    151c:	08 95       	ret

0000151e <network_send>:
}
    
uint8_t network_send(uint8_t remote_address, uint8_t protocol, uint8_t *data, uint16_t len) {
    151e:	8f 92       	push	r8
    1520:	9f 92       	push	r9
    1522:	af 92       	push	r10
    1524:	bf 92       	push	r11
    1526:	cf 92       	push	r12
    1528:	df 92       	push	r13
    152a:	ef 92       	push	r14
    152c:	ff 92       	push	r15
    152e:	0f 93       	push	r16
    1530:	1f 93       	push	r17
    1532:	cf 93       	push	r28
    1534:	df 93       	push	r29
    1536:	88 2e       	mov	r8, r24
    1538:	96 2e       	mov	r9, r22
    153a:	5a 01       	movw	r10, r20
    153c:	89 01       	movw	r16, r18
  uint8_t *packet = pvPortMalloc(len+4);
    153e:	69 01       	movw	r12, r18
    1540:	84 e0       	ldi	r24, 0x04	; 4
    1542:	c8 0e       	add	r12, r24
    1544:	d1 1c       	adc	r13, r1
    1546:	c6 01       	movw	r24, r12
    1548:	ba da       	rcall	.-2700   	; 0xabe <pvPortMalloc>
    154a:	ec 01       	movw	r28, r24
  uint8_t *encoded_data = pvPortMalloc(len+6);
    154c:	c8 01       	movw	r24, r16
    154e:	06 96       	adiw	r24, 0x06	; 6
    1550:	b6 da       	rcall	.-2708   	; 0xabe <pvPortMalloc>
    1552:	7c 01       	movw	r14, r24
  if(packet == NULL || encoded_data == NULL) {
    1554:	20 97       	sbiw	r28, 0x00	; 0
    1556:	11 f0       	breq	.+4      	; 0x155c <network_send+0x3e>
    1558:	89 2b       	or	r24, r25
    vPortFree(packet);
    155a:	31 f4       	brne	.+12     	; 0x1568 <network_send+0x4a>
    155c:	ce 01       	movw	r24, r28
    vPortFree(encoded_data);
    155e:	b9 db       	rcall	.-2190   	; 0xcd2 <vPortFree>
    1560:	c7 01       	movw	r24, r14
    1562:	b7 db       	rcall	.-2194   	; 0xcd2 <vPortFree>
    return 0;
    1564:	80 e0       	ldi	r24, 0x00	; 0
    1566:	36 c0       	rjmp	.+108    	; 0x15d4 <network_send+0xb6>
  }
  packet[0] = remote_address;
    1568:	88 82       	st	Y, r8
  packet[1] = ADDRESS;
    156a:	83 e0       	ldi	r24, 0x03	; 3
    156c:	89 83       	std	Y+1, r24	; 0x01
  packet[2] = protocol;
    156e:	9a 82       	std	Y+2, r9	; 0x02
  memcpy(packet+3, data, len);
    1570:	a8 01       	movw	r20, r16
    1572:	b5 01       	movw	r22, r10
    1574:	ce 01       	movw	r24, r28
    1576:	03 96       	adiw	r24, 0x03	; 3
    1578:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
  packet[3+len] = calculate_crc(packet, 3+len);
    157c:	58 01       	movw	r10, r16
    157e:	e3 e0       	ldi	r30, 0x03	; 3
    1580:	ae 0e       	add	r10, r30
    1582:	b1 1c       	adc	r11, r1
    1584:	ac 0e       	add	r10, r28
    1586:	bd 1e       	adc	r11, r29
    1588:	63 e0       	ldi	r22, 0x03	; 3
    158a:	60 0f       	add	r22, r16
    158c:	ce 01       	movw	r24, r28
    158e:	70 da       	rcall	.-2848   	; 0xa70 <calculate_crc>
    1590:	f5 01       	movw	r30, r10
    1592:	80 83       	st	Z, r24
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    1594:	b8 01       	movw	r22, r16
    1596:	6b 5f       	subi	r22, 0xFB	; 251
    1598:	7f 4f       	sbci	r23, 0xFF	; 255
    159a:	96 01       	movw	r18, r12
    159c:	ae 01       	movw	r20, r28
    159e:	c7 01       	movw	r24, r14
  if(result.status != COBS_ENCODE_OK) {
    15a0:	77 d9       	rcall	.-3346   	; 0x890 <cobs_encode>
    15a2:	88 23       	and	r24, r24
    vPortFree(packet);
    15a4:	31 f0       	breq	.+12     	; 0x15b2 <network_send+0x94>
    15a6:	ce 01       	movw	r24, r28
    15a8:	94 db       	rcall	.-2264   	; 0xcd2 <vPortFree>
    vPortFree(encoded_data);
    15aa:	c7 01       	movw	r24, r14
    15ac:	92 db       	rcall	.-2268   	; 0xcd2 <vPortFree>
    15ae:	80 e0       	ldi	r24, 0x00	; 0
    return 0;
    15b0:	11 c0       	rjmp	.+34     	; 0x15d4 <network_send+0xb6>
    15b2:	86 2f       	mov	r24, r22
  packet[0] = remote_address;
  packet[1] = ADDRESS;
  packet[2] = protocol;
  memcpy(packet+3, data, len);
  packet[3+len] = calculate_crc(packet, 3+len);
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    15b4:	97 2f       	mov	r25, r23
    15b6:	f7 01       	movw	r30, r14
  if(result.status != COBS_ENCODE_OK) {
    vPortFree(packet);
    vPortFree(encoded_data);
    return 0;
  }
  encoded_data[result.out_len] = 0x00;
    15b8:	e8 0f       	add	r30, r24
    15ba:	f9 1f       	adc	r31, r25
    15bc:	10 82       	st	Z, r1
  vUSART_send(encoded_data, result.out_len+1);
    15be:	bc 01       	movw	r22, r24
    15c0:	6f 5f       	subi	r22, 0xFF	; 255
    15c2:	7f 4f       	sbci	r23, 0xFF	; 255
    15c4:	c7 01       	movw	r24, r14
    15c6:	0e 94 e1 1b 	call	0x37c2	; 0x37c2 <vUSART_send>
  vPortFree(packet);
    15ca:	ce 01       	movw	r24, r28
    15cc:	82 db       	rcall	.-2300   	; 0xcd2 <vPortFree>
  vPortFree(encoded_data);
    15ce:	c7 01       	movw	r24, r14
    15d0:	80 db       	rcall	.-2304   	; 0xcd2 <vPortFree>
    15d2:	81 e0       	ldi	r24, 0x01	; 1
  return 1;
    15d4:	df 91       	pop	r29
}
    15d6:	cf 91       	pop	r28
    15d8:	1f 91       	pop	r17
    15da:	0f 91       	pop	r16
    15dc:	ff 90       	pop	r15
    15de:	ef 90       	pop	r14
    15e0:	df 90       	pop	r13
    15e2:	cf 90       	pop	r12
    15e4:	bf 90       	pop	r11
    15e6:	af 90       	pop	r10
    15e8:	9f 90       	pop	r9
    15ea:	8f 90       	pop	r8
    15ec:	08 95       	ret

000015ee <pxPortInitialiseStack>:
    15ee:	31 e1       	ldi	r19, 0x11	; 17
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    15f0:	fc 01       	movw	r30, r24
    15f2:	30 83       	st	Z, r19
    15f4:	31 97       	sbiw	r30, 0x01	; 1
    15f6:	22 e2       	ldi	r18, 0x22	; 34
    15f8:	20 83       	st	Z, r18
    15fa:	31 97       	sbiw	r30, 0x01	; 1
    15fc:	a3 e3       	ldi	r26, 0x33	; 51
    15fe:	a0 83       	st	Z, r26
    1600:	31 97       	sbiw	r30, 0x01	; 1
    1602:	60 83       	st	Z, r22
    1604:	31 97       	sbiw	r30, 0x01	; 1
    1606:	70 83       	st	Z, r23
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	10 82       	st	Z, r1
    160c:	31 97       	sbiw	r30, 0x01	; 1
    160e:	10 82       	st	Z, r1
    1610:	31 97       	sbiw	r30, 0x01	; 1
    1612:	60 e8       	ldi	r22, 0x80	; 128
    1614:	60 83       	st	Z, r22
    1616:	31 97       	sbiw	r30, 0x01	; 1
    1618:	10 82       	st	Z, r1
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	10 82       	st	Z, r1
    161e:	31 97       	sbiw	r30, 0x01	; 1
    1620:	10 82       	st	Z, r1
    1622:	31 97       	sbiw	r30, 0x01	; 1
    1624:	62 e0       	ldi	r22, 0x02	; 2
    1626:	60 83       	st	Z, r22
    1628:	31 97       	sbiw	r30, 0x01	; 1
    162a:	63 e0       	ldi	r22, 0x03	; 3
    162c:	60 83       	st	Z, r22
    162e:	31 97       	sbiw	r30, 0x01	; 1
    1630:	64 e0       	ldi	r22, 0x04	; 4
    1632:	60 83       	st	Z, r22
    1634:	31 97       	sbiw	r30, 0x01	; 1
    1636:	65 e0       	ldi	r22, 0x05	; 5
    1638:	60 83       	st	Z, r22
    163a:	31 97       	sbiw	r30, 0x01	; 1
    163c:	66 e0       	ldi	r22, 0x06	; 6
    163e:	60 83       	st	Z, r22
    1640:	31 97       	sbiw	r30, 0x01	; 1
    1642:	67 e0       	ldi	r22, 0x07	; 7
    1644:	60 83       	st	Z, r22
    1646:	31 97       	sbiw	r30, 0x01	; 1
    1648:	68 e0       	ldi	r22, 0x08	; 8
    164a:	60 83       	st	Z, r22
    164c:	31 97       	sbiw	r30, 0x01	; 1
    164e:	69 e0       	ldi	r22, 0x09	; 9
    1650:	60 83       	st	Z, r22
    1652:	31 97       	sbiw	r30, 0x01	; 1
    1654:	60 e1       	ldi	r22, 0x10	; 16
    1656:	60 83       	st	Z, r22
    1658:	31 97       	sbiw	r30, 0x01	; 1
    165a:	30 83       	st	Z, r19
    165c:	31 97       	sbiw	r30, 0x01	; 1
    165e:	32 e1       	ldi	r19, 0x12	; 18
    1660:	30 83       	st	Z, r19
    1662:	31 97       	sbiw	r30, 0x01	; 1
    1664:	33 e1       	ldi	r19, 0x13	; 19
    1666:	30 83       	st	Z, r19
    1668:	31 97       	sbiw	r30, 0x01	; 1
    166a:	34 e1       	ldi	r19, 0x14	; 20
    166c:	30 83       	st	Z, r19
    166e:	31 97       	sbiw	r30, 0x01	; 1
    1670:	35 e1       	ldi	r19, 0x15	; 21
    1672:	30 83       	st	Z, r19
    1674:	31 97       	sbiw	r30, 0x01	; 1
    1676:	36 e1       	ldi	r19, 0x16	; 22
    1678:	30 83       	st	Z, r19
    167a:	31 97       	sbiw	r30, 0x01	; 1
    167c:	37 e1       	ldi	r19, 0x17	; 23
    167e:	30 83       	st	Z, r19
    1680:	31 97       	sbiw	r30, 0x01	; 1
    1682:	38 e1       	ldi	r19, 0x18	; 24
    1684:	30 83       	st	Z, r19
    1686:	31 97       	sbiw	r30, 0x01	; 1
    1688:	39 e1       	ldi	r19, 0x19	; 25
    168a:	30 83       	st	Z, r19
    168c:	31 97       	sbiw	r30, 0x01	; 1
    168e:	30 e2       	ldi	r19, 0x20	; 32
    1690:	30 83       	st	Z, r19
    1692:	31 97       	sbiw	r30, 0x01	; 1
    1694:	31 e2       	ldi	r19, 0x21	; 33
    1696:	30 83       	st	Z, r19
    1698:	31 97       	sbiw	r30, 0x01	; 1
    169a:	20 83       	st	Z, r18
    169c:	31 97       	sbiw	r30, 0x01	; 1
    169e:	23 e2       	ldi	r18, 0x23	; 35
    16a0:	20 83       	st	Z, r18
    16a2:	31 97       	sbiw	r30, 0x01	; 1
    16a4:	40 83       	st	Z, r20
    16a6:	31 97       	sbiw	r30, 0x01	; 1
    16a8:	50 83       	st	Z, r21
    16aa:	31 97       	sbiw	r30, 0x01	; 1
    16ac:	26 e2       	ldi	r18, 0x26	; 38
    16ae:	20 83       	st	Z, r18
    16b0:	31 97       	sbiw	r30, 0x01	; 1
    16b2:	27 e2       	ldi	r18, 0x27	; 39
    16b4:	20 83       	st	Z, r18
    16b6:	31 97       	sbiw	r30, 0x01	; 1
    16b8:	28 e2       	ldi	r18, 0x28	; 40
    16ba:	20 83       	st	Z, r18
    16bc:	31 97       	sbiw	r30, 0x01	; 1
    16be:	29 e2       	ldi	r18, 0x29	; 41
    16c0:	20 83       	st	Z, r18
    16c2:	31 97       	sbiw	r30, 0x01	; 1
    16c4:	20 e3       	ldi	r18, 0x30	; 48
    16c6:	20 83       	st	Z, r18
    16c8:	31 97       	sbiw	r30, 0x01	; 1
    16ca:	21 e3       	ldi	r18, 0x31	; 49
    16cc:	20 83       	st	Z, r18
    16ce:	89 97       	sbiw	r24, 0x29	; 41
    16d0:	08 95       	ret

000016d2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    16d2:	0f 92       	push	r0
    16d4:	0f b6       	in	r0, 0x3f	; 63
    16d6:	f8 94       	cli
    16d8:	0f 92       	push	r0
    16da:	0b b6       	in	r0, 0x3b	; 59
    16dc:	0f 92       	push	r0
    16de:	0c b6       	in	r0, 0x3c	; 60
    16e0:	0f 92       	push	r0
    16e2:	1f 92       	push	r1
    16e4:	11 24       	eor	r1, r1
    16e6:	2f 92       	push	r2
    16e8:	3f 92       	push	r3
    16ea:	4f 92       	push	r4
    16ec:	5f 92       	push	r5
    16ee:	6f 92       	push	r6
    16f0:	7f 92       	push	r7
    16f2:	8f 92       	push	r8
    16f4:	9f 92       	push	r9
    16f6:	af 92       	push	r10
    16f8:	bf 92       	push	r11
    16fa:	cf 92       	push	r12
    16fc:	df 92       	push	r13
    16fe:	ef 92       	push	r14
    1700:	ff 92       	push	r15
    1702:	0f 93       	push	r16
    1704:	1f 93       	push	r17
    1706:	2f 93       	push	r18
    1708:	3f 93       	push	r19
    170a:	4f 93       	push	r20
    170c:	5f 93       	push	r21
    170e:	6f 93       	push	r22
    1710:	7f 93       	push	r23
    1712:	8f 93       	push	r24
    1714:	9f 93       	push	r25
    1716:	af 93       	push	r26
    1718:	bf 93       	push	r27
    171a:	cf 93       	push	r28
    171c:	df 93       	push	r29
    171e:	ef 93       	push	r30
    1720:	ff 93       	push	r31
    1722:	a0 91 62 16 	lds	r26, 0x1662	; 0x801662 <pxCurrentTCB>
    1726:	b0 91 63 16 	lds	r27, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    172a:	0d b6       	in	r0, 0x3d	; 61
    172c:	0d 92       	st	X+, r0
    172e:	0e b6       	in	r0, 0x3e	; 62
    1730:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1732:	0e 94 14 17 	call	0x2e28	; 0x2e28 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1736:	a0 91 62 16 	lds	r26, 0x1662	; 0x801662 <pxCurrentTCB>
    173a:	b0 91 63 16 	lds	r27, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    173e:	cd 91       	ld	r28, X+
    1740:	cd bf       	out	0x3d, r28	; 61
    1742:	dd 91       	ld	r29, X+
    1744:	de bf       	out	0x3e, r29	; 62
    1746:	ff 91       	pop	r31
    1748:	ef 91       	pop	r30
    174a:	df 91       	pop	r29
    174c:	cf 91       	pop	r28
    174e:	bf 91       	pop	r27
    1750:	af 91       	pop	r26
    1752:	9f 91       	pop	r25
    1754:	8f 91       	pop	r24
    1756:	7f 91       	pop	r23
    1758:	6f 91       	pop	r22
    175a:	5f 91       	pop	r21
    175c:	4f 91       	pop	r20
    175e:	3f 91       	pop	r19
    1760:	2f 91       	pop	r18
    1762:	1f 91       	pop	r17
    1764:	0f 91       	pop	r16
    1766:	ff 90       	pop	r15
    1768:	ef 90       	pop	r14
    176a:	df 90       	pop	r13
    176c:	cf 90       	pop	r12
    176e:	bf 90       	pop	r11
    1770:	af 90       	pop	r10
    1772:	9f 90       	pop	r9
    1774:	8f 90       	pop	r8
    1776:	7f 90       	pop	r7
    1778:	6f 90       	pop	r6
    177a:	5f 90       	pop	r5
    177c:	4f 90       	pop	r4
    177e:	3f 90       	pop	r3
    1780:	2f 90       	pop	r2
    1782:	1f 90       	pop	r1
    1784:	0f 90       	pop	r0
    1786:	0c be       	out	0x3c, r0	; 60
    1788:	0f 90       	pop	r0
    178a:	0b be       	out	0x3b, r0	; 59
    178c:	0f 90       	pop	r0
    178e:	0f be       	out	0x3f, r0	; 63
    1790:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1792:	08 95       	ret

00001794 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1794:	0f 92       	push	r0
    1796:	0f b6       	in	r0, 0x3f	; 63
    1798:	f8 94       	cli
    179a:	0f 92       	push	r0
    179c:	0b b6       	in	r0, 0x3b	; 59
    179e:	0f 92       	push	r0
    17a0:	0c b6       	in	r0, 0x3c	; 60
    17a2:	0f 92       	push	r0
    17a4:	1f 92       	push	r1
    17a6:	11 24       	eor	r1, r1
    17a8:	2f 92       	push	r2
    17aa:	3f 92       	push	r3
    17ac:	4f 92       	push	r4
    17ae:	5f 92       	push	r5
    17b0:	6f 92       	push	r6
    17b2:	7f 92       	push	r7
    17b4:	8f 92       	push	r8
    17b6:	9f 92       	push	r9
    17b8:	af 92       	push	r10
    17ba:	bf 92       	push	r11
    17bc:	cf 92       	push	r12
    17be:	df 92       	push	r13
    17c0:	ef 92       	push	r14
    17c2:	ff 92       	push	r15
    17c4:	0f 93       	push	r16
    17c6:	1f 93       	push	r17
    17c8:	2f 93       	push	r18
    17ca:	3f 93       	push	r19
    17cc:	4f 93       	push	r20
    17ce:	5f 93       	push	r21
    17d0:	6f 93       	push	r22
    17d2:	7f 93       	push	r23
    17d4:	8f 93       	push	r24
    17d6:	9f 93       	push	r25
    17d8:	af 93       	push	r26
    17da:	bf 93       	push	r27
    17dc:	cf 93       	push	r28
    17de:	df 93       	push	r29
    17e0:	ef 93       	push	r30
    17e2:	ff 93       	push	r31
    17e4:	a0 91 62 16 	lds	r26, 0x1662	; 0x801662 <pxCurrentTCB>
    17e8:	b0 91 63 16 	lds	r27, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    17ec:	0d b6       	in	r0, 0x3d	; 61
    17ee:	0d 92       	st	X+, r0
    17f0:	0e b6       	in	r0, 0x3e	; 62
    17f2:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    17f4:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    17f6:	80 91 2a 17 	lds	r24, 0x172A	; 0x80172a <ticksRemainingInSec>
    17fa:	90 91 2b 17 	lds	r25, 0x172B	; 0x80172b <ticksRemainingInSec+0x1>
    17fe:	01 97       	sbiw	r24, 0x01	; 1
    1800:	90 93 2b 17 	sts	0x172B, r25	; 0x80172b <ticksRemainingInSec+0x1>
    1804:	80 93 2a 17 	sts	0x172A, r24	; 0x80172a <ticksRemainingInSec>
    1808:	89 2b       	or	r24, r25
    180a:	41 f4       	brne	.+16     	; 0x181c <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    180c:	80 91 28 17 	lds	r24, 0x1728	; 0x801728 <portTickRateHz>
    1810:	90 91 29 17 	lds	r25, 0x1729	; 0x801729 <portTickRateHz+0x1>
    1814:	90 93 2b 17 	sts	0x172B, r25	; 0x80172b <ticksRemainingInSec+0x1>
    1818:	80 93 2a 17 	sts	0x172A, r24	; 0x80172a <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    181c:	0e 94 53 16 	call	0x2ca6	; 0x2ca6 <xTaskIncrementTick>
    1820:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1822:	0e 94 14 17 	call	0x2e28	; 0x2e28 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    1826:	a0 91 62 16 	lds	r26, 0x1662	; 0x801662 <pxCurrentTCB>
    182a:	b0 91 63 16 	lds	r27, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    182e:	cd 91       	ld	r28, X+
    1830:	cd bf       	out	0x3d, r28	; 61
    1832:	dd 91       	ld	r29, X+
    1834:	de bf       	out	0x3e, r29	; 62
    1836:	ff 91       	pop	r31
    1838:	ef 91       	pop	r30
    183a:	df 91       	pop	r29
    183c:	cf 91       	pop	r28
    183e:	bf 91       	pop	r27
    1840:	af 91       	pop	r26
    1842:	9f 91       	pop	r25
    1844:	8f 91       	pop	r24
    1846:	7f 91       	pop	r23
    1848:	6f 91       	pop	r22
    184a:	5f 91       	pop	r21
    184c:	4f 91       	pop	r20
    184e:	3f 91       	pop	r19
    1850:	2f 91       	pop	r18
    1852:	1f 91       	pop	r17
    1854:	0f 91       	pop	r16
    1856:	ff 90       	pop	r15
    1858:	ef 90       	pop	r14
    185a:	df 90       	pop	r13
    185c:	cf 90       	pop	r12
    185e:	bf 90       	pop	r11
    1860:	af 90       	pop	r10
    1862:	9f 90       	pop	r9
    1864:	8f 90       	pop	r8
    1866:	7f 90       	pop	r7
    1868:	6f 90       	pop	r6
    186a:	5f 90       	pop	r5
    186c:	4f 90       	pop	r4
    186e:	3f 90       	pop	r3
    1870:	2f 90       	pop	r2
    1872:	1f 90       	pop	r1
    1874:	0f 90       	pop	r0
    1876:	0c be       	out	0x3c, r0	; 60
    1878:	0f 90       	pop	r0
    187a:	0b be       	out	0x3b, r0	; 59
    187c:	0f 90       	pop	r0
    187e:	0f be       	out	0x3f, r0	; 63
    1880:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    1882:	08 95       	ret

00001884 <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    1884:	87 df       	rcall	.-242    	; 0x1794 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    1886:	18 95       	reti

00001888 <xQueueCreateMutex>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1888:	9f 92       	push	r9
    188a:	af 92       	push	r10
    188c:	bf 92       	push	r11
    188e:	cf 92       	push	r12
    1890:	df 92       	push	r13
    1892:	ef 92       	push	r14
    1894:	ff 92       	push	r15
    1896:	0f 93       	push	r16
    1898:	1f 93       	push	r17
    189a:	cf 93       	push	r28
    189c:	df 93       	push	r29
    189e:	00 d0       	rcall	.+0      	; 0x18a0 <xQueueCreateMutex+0x18>
    18a0:	1f 92       	push	r1
    18a2:	1f 92       	push	r1
    18a4:	cd b7       	in	r28, 0x3d	; 61
    18a6:	de b7       	in	r29, 0x3e	; 62
    18a8:	8f e1       	ldi	r24, 0x1F	; 31
    18aa:	90 e0       	ldi	r25, 0x00	; 0
    18ac:	08 d9       	rcall	.-3568   	; 0xabe <pvPortMalloc>
    18ae:	8c 01       	movw	r16, r24
    18b0:	00 97       	sbiw	r24, 0x00	; 0
    18b2:	09 f4       	brne	.+2      	; 0x18b6 <xQueueCreateMutex+0x2e>
    18b4:	53 c1       	rjmp	.+678    	; 0x1b5c <xQueueCreateMutex+0x2d4>
    18b6:	fc 01       	movw	r30, r24
    18b8:	13 82       	std	Z+3, r1	; 0x03
    18ba:	12 82       	std	Z+2, r1	; 0x02
    18bc:	11 82       	std	Z+1, r1	; 0x01
    18be:	10 82       	st	Z, r1
    18c0:	15 82       	std	Z+5, r1	; 0x05
    18c2:	14 82       	std	Z+4, r1	; 0x04
    18c4:	17 82       	std	Z+7, r1	; 0x07
    18c6:	16 82       	std	Z+6, r1	; 0x06
    18c8:	12 8e       	std	Z+26, r1	; 0x1a
    18ca:	81 e0       	ldi	r24, 0x01	; 1
    18cc:	83 8f       	std	Z+27, r24	; 0x1b
    18ce:	14 8e       	std	Z+28, r1	; 0x1c
    18d0:	8f ef       	ldi	r24, 0xFF	; 255
    18d2:	85 8f       	std	Z+29, r24	; 0x1d
    18d4:	86 8f       	std	Z+30, r24	; 0x1e
    18d6:	78 01       	movw	r14, r16
    18d8:	f8 e0       	ldi	r31, 0x08	; 8
    18da:	ef 0e       	add	r14, r31
    18dc:	f1 1c       	adc	r15, r1
    18de:	c7 01       	movw	r24, r14
    18e0:	4b dc       	rcall	.-1898   	; 0x1178 <vListInitialise>
    18e2:	68 01       	movw	r12, r16
    18e4:	81 e1       	ldi	r24, 0x11	; 17
    18e6:	c8 0e       	add	r12, r24
    18e8:	d1 1c       	adc	r13, r1
    18ea:	c6 01       	movw	r24, r12
    18ec:	45 dc       	rcall	.-1910   	; 0x1178 <vListInitialise>
    18ee:	1d 82       	std	Y+5, r1	; 0x05
    18f0:	1c 82       	std	Y+4, r1	; 0x04
    18f2:	a1 2c       	mov	r10, r1
    18f4:	99 24       	eor	r9, r9
    18f6:	93 94       	inc	r9
    18f8:	bb 24       	eor	r11, r11
    18fa:	ba 94       	dec	r11
    18fc:	0f b6       	in	r0, 0x3f	; 63
    18fe:	f8 94       	cli
    1900:	0f 92       	push	r0
    1902:	f8 01       	movw	r30, r16
    1904:	92 8d       	ldd	r25, Z+26	; 0x1a
    1906:	83 8d       	ldd	r24, Z+27	; 0x1b
    1908:	98 17       	cp	r25, r24
    190a:	f0 f4       	brcc	.+60     	; 0x1948 <xQueueCreateMutex+0xc0>
    190c:	80 81       	ld	r24, Z
    190e:	91 81       	ldd	r25, Z+1	; 0x01
    1910:	89 2b       	or	r24, r25
    1912:	09 f0       	breq	.+2      	; 0x1916 <xQueueCreateMutex+0x8e>
    1914:	1a c1       	rjmp	.+564    	; 0x1b4a <xQueueCreateMutex+0x2c2>
    1916:	82 81       	ldd	r24, Z+2	; 0x02
    1918:	93 81       	ldd	r25, Z+3	; 0x03
    191a:	0e 94 f0 18 	call	0x31e0	; 0x31e0 <xTaskPriorityDisinherit>
    191e:	f8 01       	movw	r30, r16
    1920:	13 82       	std	Z+3, r1	; 0x03
    1922:	12 82       	std	Z+2, r1	; 0x02
    1924:	92 8d       	ldd	r25, Z+26	; 0x1a
    1926:	9f 5f       	subi	r25, 0xFF	; 255
    1928:	92 8f       	std	Z+26, r25	; 0x1a
    192a:	91 89       	ldd	r25, Z+17	; 0x11
    192c:	99 23       	and	r25, r25
    192e:	39 f0       	breq	.+14     	; 0x193e <xQueueCreateMutex+0xb6>
    1930:	c6 01       	movw	r24, r12
    1932:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1936:	81 30       	cpi	r24, 0x01	; 1
    1938:	21 f4       	brne	.+8      	; 0x1942 <xQueueCreateMutex+0xba>
    193a:	cb de       	rcall	.-618    	; 0x16d2 <vPortYield>
    193c:	02 c0       	rjmp	.+4      	; 0x1942 <xQueueCreateMutex+0xba>
    193e:	81 11       	cpse	r24, r1
    1940:	c8 de       	rcall	.-624    	; 0x16d2 <vPortYield>
    1942:	0f 90       	pop	r0
    1944:	0f be       	out	0x3f, r0	; 63
    1946:	0a c1       	rjmp	.+532    	; 0x1b5c <xQueueCreateMutex+0x2d4>
    1948:	8c 81       	ldd	r24, Y+4	; 0x04
    194a:	9d 81       	ldd	r25, Y+5	; 0x05
    194c:	89 2b       	or	r24, r25
    194e:	19 f4       	brne	.+6      	; 0x1956 <xQueueCreateMutex+0xce>
    1950:	0f 90       	pop	r0
    1952:	0f be       	out	0x3f, r0	; 63
    1954:	03 c1       	rjmp	.+518    	; 0x1b5c <xQueueCreateMutex+0x2d4>
    1956:	a1 10       	cpse	r10, r1
    1958:	05 c0       	rjmp	.+10     	; 0x1964 <xQueueCreateMutex+0xdc>
    195a:	ce 01       	movw	r24, r28
    195c:	01 96       	adiw	r24, 0x01	; 1
    195e:	0e 94 3f 18 	call	0x307e	; 0x307e <vTaskSetTimeOutState>
    1962:	a9 2c       	mov	r10, r9
    1964:	0f 90       	pop	r0
    1966:	0f be       	out	0x3f, r0	; 63
    1968:	0e 94 12 15 	call	0x2a24	; 0x2a24 <vTaskSuspendAll>
    196c:	0f b6       	in	r0, 0x3f	; 63
    196e:	f8 94       	cli
    1970:	0f 92       	push	r0
    1972:	f8 01       	movw	r30, r16
    1974:	85 8d       	ldd	r24, Z+29	; 0x1d
    1976:	8f 3f       	cpi	r24, 0xFF	; 255
    1978:	09 f4       	brne	.+2      	; 0x197c <xQueueCreateMutex+0xf4>
    197a:	15 8e       	std	Z+29, r1	; 0x1d
    197c:	f8 01       	movw	r30, r16
    197e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1980:	8f 3f       	cpi	r24, 0xFF	; 255
    1982:	09 f4       	brne	.+2      	; 0x1986 <xQueueCreateMutex+0xfe>
    1984:	16 8e       	std	Z+30, r1	; 0x1e
    1986:	0f 90       	pop	r0
    1988:	0f be       	out	0x3f, r0	; 63
    198a:	be 01       	movw	r22, r28
    198c:	6c 5f       	subi	r22, 0xFC	; 252
    198e:	7f 4f       	sbci	r23, 0xFF	; 255
    1990:	ce 01       	movw	r24, r28
    1992:	01 96       	adiw	r24, 0x01	; 1
    1994:	0e 94 4a 18 	call	0x3094	; 0x3094 <xTaskCheckForTimeOut>
    1998:	81 11       	cpse	r24, r1
    199a:	94 c0       	rjmp	.+296    	; 0x1ac4 <xQueueCreateMutex+0x23c>
    199c:	0f b6       	in	r0, 0x3f	; 63
    199e:	f8 94       	cli
    19a0:	0f 92       	push	r0
    19a2:	f8 01       	movw	r30, r16
    19a4:	92 8d       	ldd	r25, Z+26	; 0x1a
    19a6:	83 8d       	ldd	r24, Z+27	; 0x1b
    19a8:	0f 90       	pop	r0
    19aa:	0f be       	out	0x3f, r0	; 63
    19ac:	98 13       	cpse	r25, r24
    19ae:	49 c0       	rjmp	.+146    	; 0x1a42 <xQueueCreateMutex+0x1ba>
    19b0:	6c 81       	ldd	r22, Y+4	; 0x04
    19b2:	7d 81       	ldd	r23, Y+5	; 0x05
    19b4:	c7 01       	movw	r24, r14
    19b6:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <vTaskPlaceOnEventList>
    19ba:	0f b6       	in	r0, 0x3f	; 63
    19bc:	f8 94       	cli
    19be:	0f 92       	push	r0
    19c0:	f8 01       	movw	r30, r16
    19c2:	86 8d       	ldd	r24, Z+30	; 0x1e
    19c4:	18 16       	cp	r1, r24
    19c6:	ac f4       	brge	.+42     	; 0x19f2 <xQueueCreateMutex+0x16a>
    19c8:	81 89       	ldd	r24, Z+17	; 0x11
    19ca:	81 11       	cpse	r24, r1
    19cc:	05 c0       	rjmp	.+10     	; 0x19d8 <xQueueCreateMutex+0x150>
    19ce:	11 c0       	rjmp	.+34     	; 0x19f2 <xQueueCreateMutex+0x16a>
    19d0:	f8 01       	movw	r30, r16
    19d2:	81 89       	ldd	r24, Z+17	; 0x11
    19d4:	88 23       	and	r24, r24
    19d6:	69 f0       	breq	.+26     	; 0x19f2 <xQueueCreateMutex+0x16a>
    19d8:	c6 01       	movw	r24, r12
    19da:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    19de:	81 11       	cpse	r24, r1
    19e0:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    19e4:	f8 01       	movw	r30, r16
    19e6:	86 8d       	ldd	r24, Z+30	; 0x1e
    19e8:	81 50       	subi	r24, 0x01	; 1
    19ea:	86 8f       	std	Z+30, r24	; 0x1e
    19ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    19ee:	18 16       	cp	r1, r24
    19f0:	7c f3       	brlt	.-34     	; 0x19d0 <xQueueCreateMutex+0x148>
    19f2:	f8 01       	movw	r30, r16
    19f4:	b6 8e       	std	Z+30, r11	; 0x1e
    19f6:	0f 90       	pop	r0
    19f8:	0f be       	out	0x3f, r0	; 63
    19fa:	0f b6       	in	r0, 0x3f	; 63
    19fc:	f8 94       	cli
    19fe:	0f 92       	push	r0
    1a00:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a02:	18 16       	cp	r1, r24
    1a04:	ac f4       	brge	.+42     	; 0x1a30 <xQueueCreateMutex+0x1a8>
    1a06:	80 85       	ldd	r24, Z+8	; 0x08
    1a08:	81 11       	cpse	r24, r1
    1a0a:	05 c0       	rjmp	.+10     	; 0x1a16 <xQueueCreateMutex+0x18e>
    1a0c:	11 c0       	rjmp	.+34     	; 0x1a30 <xQueueCreateMutex+0x1a8>
    1a0e:	f8 01       	movw	r30, r16
    1a10:	80 85       	ldd	r24, Z+8	; 0x08
    1a12:	88 23       	and	r24, r24
    1a14:	69 f0       	breq	.+26     	; 0x1a30 <xQueueCreateMutex+0x1a8>
    1a16:	c7 01       	movw	r24, r14
    1a18:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1a1c:	81 11       	cpse	r24, r1
    1a1e:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1a22:	f8 01       	movw	r30, r16
    1a24:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a26:	81 50       	subi	r24, 0x01	; 1
    1a28:	85 8f       	std	Z+29, r24	; 0x1d
    1a2a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a2c:	18 16       	cp	r1, r24
    1a2e:	7c f3       	brlt	.-34     	; 0x1a0e <xQueueCreateMutex+0x186>
    1a30:	f8 01       	movw	r30, r16
    1a32:	b5 8e       	std	Z+29, r11	; 0x1d
    1a34:	0f 90       	pop	r0
    1a36:	0f be       	out	0x3f, r0	; 63
    1a38:	fb d7       	rcall	.+4086   	; 0x2a30 <xTaskResumeAll>
    1a3a:	81 11       	cpse	r24, r1
    1a3c:	5f cf       	rjmp	.-322    	; 0x18fc <xQueueCreateMutex+0x74>
    1a3e:	49 de       	rcall	.-878    	; 0x16d2 <vPortYield>
    1a40:	5d cf       	rjmp	.-326    	; 0x18fc <xQueueCreateMutex+0x74>
    1a42:	0f b6       	in	r0, 0x3f	; 63
    1a44:	f8 94       	cli
    1a46:	0f 92       	push	r0
    1a48:	f8 01       	movw	r30, r16
    1a4a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a4c:	18 16       	cp	r1, r24
    1a4e:	ac f4       	brge	.+42     	; 0x1a7a <xQueueCreateMutex+0x1f2>
    1a50:	81 89       	ldd	r24, Z+17	; 0x11
    1a52:	81 11       	cpse	r24, r1
    1a54:	05 c0       	rjmp	.+10     	; 0x1a60 <xQueueCreateMutex+0x1d8>
    1a56:	11 c0       	rjmp	.+34     	; 0x1a7a <xQueueCreateMutex+0x1f2>
    1a58:	f8 01       	movw	r30, r16
    1a5a:	81 89       	ldd	r24, Z+17	; 0x11
    1a5c:	88 23       	and	r24, r24
    1a5e:	69 f0       	breq	.+26     	; 0x1a7a <xQueueCreateMutex+0x1f2>
    1a60:	c6 01       	movw	r24, r12
    1a62:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1a66:	81 11       	cpse	r24, r1
    1a68:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1a6c:	f8 01       	movw	r30, r16
    1a6e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a70:	81 50       	subi	r24, 0x01	; 1
    1a72:	86 8f       	std	Z+30, r24	; 0x1e
    1a74:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a76:	18 16       	cp	r1, r24
    1a78:	7c f3       	brlt	.-34     	; 0x1a58 <xQueueCreateMutex+0x1d0>
    1a7a:	f8 01       	movw	r30, r16
    1a7c:	b6 8e       	std	Z+30, r11	; 0x1e
    1a7e:	0f 90       	pop	r0
    1a80:	0f be       	out	0x3f, r0	; 63
    1a82:	0f b6       	in	r0, 0x3f	; 63
    1a84:	f8 94       	cli
    1a86:	0f 92       	push	r0
    1a88:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a8a:	18 16       	cp	r1, r24
    1a8c:	ac f4       	brge	.+42     	; 0x1ab8 <xQueueCreateMutex+0x230>
    1a8e:	80 85       	ldd	r24, Z+8	; 0x08
    1a90:	81 11       	cpse	r24, r1
    1a92:	05 c0       	rjmp	.+10     	; 0x1a9e <xQueueCreateMutex+0x216>
    1a94:	11 c0       	rjmp	.+34     	; 0x1ab8 <xQueueCreateMutex+0x230>
    1a96:	f8 01       	movw	r30, r16
    1a98:	80 85       	ldd	r24, Z+8	; 0x08
    1a9a:	88 23       	and	r24, r24
    1a9c:	69 f0       	breq	.+26     	; 0x1ab8 <xQueueCreateMutex+0x230>
    1a9e:	c7 01       	movw	r24, r14
    1aa0:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1aa4:	81 11       	cpse	r24, r1
    1aa6:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1aaa:	f8 01       	movw	r30, r16
    1aac:	85 8d       	ldd	r24, Z+29	; 0x1d
    1aae:	81 50       	subi	r24, 0x01	; 1
    1ab0:	85 8f       	std	Z+29, r24	; 0x1d
    1ab2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ab4:	18 16       	cp	r1, r24
    1ab6:	7c f3       	brlt	.-34     	; 0x1a96 <xQueueCreateMutex+0x20e>
    1ab8:	f8 01       	movw	r30, r16
    1aba:	b5 8e       	std	Z+29, r11	; 0x1d
    1abc:	0f 90       	pop	r0
    1abe:	0f be       	out	0x3f, r0	; 63
    1ac0:	b7 d7       	rcall	.+3950   	; 0x2a30 <xTaskResumeAll>
    1ac2:	1c cf       	rjmp	.-456    	; 0x18fc <xQueueCreateMutex+0x74>
    1ac4:	0f b6       	in	r0, 0x3f	; 63
    1ac6:	f8 94       	cli
    1ac8:	0f 92       	push	r0
    1aca:	f8 01       	movw	r30, r16
    1acc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ace:	18 16       	cp	r1, r24
    1ad0:	ac f4       	brge	.+42     	; 0x1afc <xQueueCreateMutex+0x274>
    1ad2:	81 89       	ldd	r24, Z+17	; 0x11
    1ad4:	81 11       	cpse	r24, r1
    1ad6:	05 c0       	rjmp	.+10     	; 0x1ae2 <xQueueCreateMutex+0x25a>
    1ad8:	11 c0       	rjmp	.+34     	; 0x1afc <xQueueCreateMutex+0x274>
    1ada:	f8 01       	movw	r30, r16
    1adc:	81 89       	ldd	r24, Z+17	; 0x11
    1ade:	88 23       	and	r24, r24
    1ae0:	69 f0       	breq	.+26     	; 0x1afc <xQueueCreateMutex+0x274>
    1ae2:	c6 01       	movw	r24, r12
    1ae4:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1ae8:	81 11       	cpse	r24, r1
    1aea:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1aee:	f8 01       	movw	r30, r16
    1af0:	86 8d       	ldd	r24, Z+30	; 0x1e
    1af2:	81 50       	subi	r24, 0x01	; 1
    1af4:	86 8f       	std	Z+30, r24	; 0x1e
    1af6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1af8:	18 16       	cp	r1, r24
    1afa:	7c f3       	brlt	.-34     	; 0x1ada <xQueueCreateMutex+0x252>
    1afc:	8f ef       	ldi	r24, 0xFF	; 255
    1afe:	f8 01       	movw	r30, r16
    1b00:	86 8f       	std	Z+30, r24	; 0x1e
    1b02:	0f 90       	pop	r0
    1b04:	0f be       	out	0x3f, r0	; 63
    1b06:	0f b6       	in	r0, 0x3f	; 63
    1b08:	f8 94       	cli
    1b0a:	0f 92       	push	r0
    1b0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b0e:	18 16       	cp	r1, r24
    1b10:	ac f4       	brge	.+42     	; 0x1b3c <xQueueCreateMutex+0x2b4>
    1b12:	80 85       	ldd	r24, Z+8	; 0x08
    1b14:	81 11       	cpse	r24, r1
    1b16:	05 c0       	rjmp	.+10     	; 0x1b22 <xQueueCreateMutex+0x29a>
    1b18:	11 c0       	rjmp	.+34     	; 0x1b3c <xQueueCreateMutex+0x2b4>
    1b1a:	f8 01       	movw	r30, r16
    1b1c:	80 85       	ldd	r24, Z+8	; 0x08
    1b1e:	88 23       	and	r24, r24
    1b20:	69 f0       	breq	.+26     	; 0x1b3c <xQueueCreateMutex+0x2b4>
    1b22:	c7 01       	movw	r24, r14
    1b24:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1b28:	81 11       	cpse	r24, r1
    1b2a:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1b2e:	f8 01       	movw	r30, r16
    1b30:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b32:	81 50       	subi	r24, 0x01	; 1
    1b34:	85 8f       	std	Z+29, r24	; 0x1d
    1b36:	85 8d       	ldd	r24, Z+29	; 0x1d
    1b38:	18 16       	cp	r1, r24
    1b3a:	7c f3       	brlt	.-34     	; 0x1b1a <xQueueCreateMutex+0x292>
    1b3c:	8f ef       	ldi	r24, 0xFF	; 255
    1b3e:	f8 01       	movw	r30, r16
    1b40:	85 8f       	std	Z+29, r24	; 0x1d
    1b42:	0f 90       	pop	r0
    1b44:	0f be       	out	0x3f, r0	; 63
    1b46:	74 d7       	rcall	.+3816   	; 0x2a30 <xTaskResumeAll>
    1b48:	09 c0       	rjmp	.+18     	; 0x1b5c <xQueueCreateMutex+0x2d4>
    1b4a:	f8 01       	movw	r30, r16
    1b4c:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b4e:	8f 5f       	subi	r24, 0xFF	; 255
    1b50:	82 8f       	std	Z+26, r24	; 0x1a
    1b52:	81 89       	ldd	r24, Z+17	; 0x11
    1b54:	88 23       	and	r24, r24
    1b56:	09 f4       	brne	.+2      	; 0x1b5a <xQueueCreateMutex+0x2d2>
    1b58:	f4 ce       	rjmp	.-536    	; 0x1942 <xQueueCreateMutex+0xba>
    1b5a:	ea ce       	rjmp	.-556    	; 0x1930 <xQueueCreateMutex+0xa8>
    1b5c:	c8 01       	movw	r24, r16
    1b5e:	0f 90       	pop	r0
    1b60:	0f 90       	pop	r0
    1b62:	0f 90       	pop	r0
    1b64:	0f 90       	pop	r0
    1b66:	0f 90       	pop	r0
    1b68:	df 91       	pop	r29
    1b6a:	cf 91       	pop	r28
    1b6c:	1f 91       	pop	r17
    1b6e:	0f 91       	pop	r16
    1b70:	ff 90       	pop	r15
    1b72:	ef 90       	pop	r14
    1b74:	df 90       	pop	r13
    1b76:	cf 90       	pop	r12
    1b78:	bf 90       	pop	r11
    1b7a:	af 90       	pop	r10
    1b7c:	9f 90       	pop	r9
    1b7e:	08 95       	ret

00001b80 <xQueueGive>:
    1b80:	9f 92       	push	r9
    1b82:	af 92       	push	r10
    1b84:	bf 92       	push	r11
    1b86:	cf 92       	push	r12
    1b88:	df 92       	push	r13
    1b8a:	ef 92       	push	r14
    1b8c:	ff 92       	push	r15
    1b8e:	0f 93       	push	r16
    1b90:	1f 93       	push	r17
    1b92:	cf 93       	push	r28
    1b94:	df 93       	push	r29
    1b96:	00 d0       	rcall	.+0      	; 0x1b98 <xQueueGive+0x18>
    1b98:	1f 92       	push	r1
    1b9a:	1f 92       	push	r1
    1b9c:	cd b7       	in	r28, 0x3d	; 61
    1b9e:	de b7       	in	r29, 0x3e	; 62
    1ba0:	8c 01       	movw	r16, r24
    1ba2:	7d 83       	std	Y+5, r23	; 0x05
    1ba4:	6c 83       	std	Y+4, r22	; 0x04
    1ba6:	a1 2c       	mov	r10, r1
    1ba8:	99 24       	eor	r9, r9
    1baa:	93 94       	inc	r9
    1bac:	bb 24       	eor	r11, r11
    1bae:	ba 94       	dec	r11
    1bb0:	7c 01       	movw	r14, r24
    1bb2:	88 e0       	ldi	r24, 0x08	; 8
    1bb4:	e8 0e       	add	r14, r24
    1bb6:	f1 1c       	adc	r15, r1
    1bb8:	68 01       	movw	r12, r16
    1bba:	e1 e1       	ldi	r30, 0x11	; 17
    1bbc:	ce 0e       	add	r12, r30
    1bbe:	d1 1c       	adc	r13, r1
    1bc0:	0f b6       	in	r0, 0x3f	; 63
    1bc2:	f8 94       	cli
    1bc4:	0f 92       	push	r0
    1bc6:	f8 01       	movw	r30, r16
    1bc8:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bca:	83 8d       	ldd	r24, Z+27	; 0x1b
    1bcc:	98 17       	cp	r25, r24
    1bce:	00 f5       	brcc	.+64     	; 0x1c10 <xQueueGive+0x90>
    1bd0:	80 81       	ld	r24, Z
    1bd2:	91 81       	ldd	r25, Z+1	; 0x01
    1bd4:	89 2b       	or	r24, r25
    1bd6:	09 f0       	breq	.+2      	; 0x1bda <xQueueGive+0x5a>
    1bd8:	27 c1       	rjmp	.+590    	; 0x1e28 <xQueueGive+0x2a8>
    1bda:	82 81       	ldd	r24, Z+2	; 0x02
    1bdc:	93 81       	ldd	r25, Z+3	; 0x03
    1bde:	0e 94 f0 18 	call	0x31e0	; 0x31e0 <xTaskPriorityDisinherit>
    1be2:	f8 01       	movw	r30, r16
    1be4:	13 82       	std	Z+3, r1	; 0x03
    1be6:	12 82       	std	Z+2, r1	; 0x02
    1be8:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bea:	9f 5f       	subi	r25, 0xFF	; 255
    1bec:	92 8f       	std	Z+26, r25	; 0x1a
    1bee:	91 89       	ldd	r25, Z+17	; 0x11
    1bf0:	99 23       	and	r25, r25
    1bf2:	41 f0       	breq	.+16     	; 0x1c04 <xQueueGive+0x84>
    1bf4:	c8 01       	movw	r24, r16
    1bf6:	41 96       	adiw	r24, 0x11	; 17
    1bf8:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1bfc:	81 30       	cpi	r24, 0x01	; 1
    1bfe:	21 f4       	brne	.+8      	; 0x1c08 <xQueueGive+0x88>
    1c00:	68 dd       	rcall	.-1328   	; 0x16d2 <vPortYield>
    1c02:	02 c0       	rjmp	.+4      	; 0x1c08 <xQueueGive+0x88>
    1c04:	81 11       	cpse	r24, r1
    1c06:	65 dd       	rcall	.-1334   	; 0x16d2 <vPortYield>
    1c08:	0f 90       	pop	r0
    1c0a:	0f be       	out	0x3f, r0	; 63
    1c0c:	81 e0       	ldi	r24, 0x01	; 1
    1c0e:	14 c1       	rjmp	.+552    	; 0x1e38 <xQueueGive+0x2b8>
    1c10:	8c 81       	ldd	r24, Y+4	; 0x04
    1c12:	9d 81       	ldd	r25, Y+5	; 0x05
    1c14:	89 2b       	or	r24, r25
    1c16:	21 f4       	brne	.+8      	; 0x1c20 <xQueueGive+0xa0>
    1c18:	0f 90       	pop	r0
    1c1a:	0f be       	out	0x3f, r0	; 63
    1c1c:	80 e0       	ldi	r24, 0x00	; 0
    1c1e:	0c c1       	rjmp	.+536    	; 0x1e38 <xQueueGive+0x2b8>
    1c20:	a1 10       	cpse	r10, r1
    1c22:	05 c0       	rjmp	.+10     	; 0x1c2e <xQueueGive+0xae>
    1c24:	ce 01       	movw	r24, r28
    1c26:	01 96       	adiw	r24, 0x01	; 1
    1c28:	0e 94 3f 18 	call	0x307e	; 0x307e <vTaskSetTimeOutState>
    1c2c:	a9 2c       	mov	r10, r9
    1c2e:	0f 90       	pop	r0
    1c30:	0f be       	out	0x3f, r0	; 63
    1c32:	f8 d6       	rcall	.+3568   	; 0x2a24 <vTaskSuspendAll>
    1c34:	0f b6       	in	r0, 0x3f	; 63
    1c36:	f8 94       	cli
    1c38:	0f 92       	push	r0
    1c3a:	f8 01       	movw	r30, r16
    1c3c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c3e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c40:	09 f4       	brne	.+2      	; 0x1c44 <xQueueGive+0xc4>
    1c42:	15 8e       	std	Z+29, r1	; 0x1d
    1c44:	f8 01       	movw	r30, r16
    1c46:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c48:	8f 3f       	cpi	r24, 0xFF	; 255
    1c4a:	09 f4       	brne	.+2      	; 0x1c4e <xQueueGive+0xce>
    1c4c:	16 8e       	std	Z+30, r1	; 0x1e
    1c4e:	0f 90       	pop	r0
    1c50:	0f be       	out	0x3f, r0	; 63
    1c52:	be 01       	movw	r22, r28
    1c54:	6c 5f       	subi	r22, 0xFC	; 252
    1c56:	7f 4f       	sbci	r23, 0xFF	; 255
    1c58:	ce 01       	movw	r24, r28
    1c5a:	01 96       	adiw	r24, 0x01	; 1
    1c5c:	0e 94 4a 18 	call	0x3094	; 0x3094 <xTaskCheckForTimeOut>
    1c60:	81 11       	cpse	r24, r1
    1c62:	94 c0       	rjmp	.+296    	; 0x1d8c <xQueueGive+0x20c>
    1c64:	0f b6       	in	r0, 0x3f	; 63
    1c66:	f8 94       	cli
    1c68:	0f 92       	push	r0
    1c6a:	f8 01       	movw	r30, r16
    1c6c:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c6e:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c70:	0f 90       	pop	r0
    1c72:	0f be       	out	0x3f, r0	; 63
    1c74:	98 13       	cpse	r25, r24
    1c76:	49 c0       	rjmp	.+146    	; 0x1d0a <xQueueGive+0x18a>
    1c78:	6c 81       	ldd	r22, Y+4	; 0x04
    1c7a:	7d 81       	ldd	r23, Y+5	; 0x05
    1c7c:	c7 01       	movw	r24, r14
    1c7e:	0e 94 9c 17 	call	0x2f38	; 0x2f38 <vTaskPlaceOnEventList>
    1c82:	0f b6       	in	r0, 0x3f	; 63
    1c84:	f8 94       	cli
    1c86:	0f 92       	push	r0
    1c88:	f8 01       	movw	r30, r16
    1c8a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c8c:	18 16       	cp	r1, r24
    1c8e:	ac f4       	brge	.+42     	; 0x1cba <xQueueGive+0x13a>
    1c90:	81 89       	ldd	r24, Z+17	; 0x11
    1c92:	81 11       	cpse	r24, r1
    1c94:	05 c0       	rjmp	.+10     	; 0x1ca0 <xQueueGive+0x120>
    1c96:	11 c0       	rjmp	.+34     	; 0x1cba <xQueueGive+0x13a>
    1c98:	f8 01       	movw	r30, r16
    1c9a:	81 89       	ldd	r24, Z+17	; 0x11
    1c9c:	88 23       	and	r24, r24
    1c9e:	69 f0       	breq	.+26     	; 0x1cba <xQueueGive+0x13a>
    1ca0:	c6 01       	movw	r24, r12
    1ca2:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1ca6:	81 11       	cpse	r24, r1
    1ca8:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1cac:	f8 01       	movw	r30, r16
    1cae:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cb0:	81 50       	subi	r24, 0x01	; 1
    1cb2:	86 8f       	std	Z+30, r24	; 0x1e
    1cb4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cb6:	18 16       	cp	r1, r24
    1cb8:	7c f3       	brlt	.-34     	; 0x1c98 <xQueueGive+0x118>
    1cba:	f8 01       	movw	r30, r16
    1cbc:	b6 8e       	std	Z+30, r11	; 0x1e
    1cbe:	0f 90       	pop	r0
    1cc0:	0f be       	out	0x3f, r0	; 63
    1cc2:	0f b6       	in	r0, 0x3f	; 63
    1cc4:	f8 94       	cli
    1cc6:	0f 92       	push	r0
    1cc8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cca:	18 16       	cp	r1, r24
    1ccc:	ac f4       	brge	.+42     	; 0x1cf8 <xQueueGive+0x178>
    1cce:	80 85       	ldd	r24, Z+8	; 0x08
    1cd0:	81 11       	cpse	r24, r1
    1cd2:	05 c0       	rjmp	.+10     	; 0x1cde <xQueueGive+0x15e>
    1cd4:	11 c0       	rjmp	.+34     	; 0x1cf8 <xQueueGive+0x178>
    1cd6:	f8 01       	movw	r30, r16
    1cd8:	80 85       	ldd	r24, Z+8	; 0x08
    1cda:	88 23       	and	r24, r24
    1cdc:	69 f0       	breq	.+26     	; 0x1cf8 <xQueueGive+0x178>
    1cde:	c7 01       	movw	r24, r14
    1ce0:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1ce4:	81 11       	cpse	r24, r1
    1ce6:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1cea:	f8 01       	movw	r30, r16
    1cec:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cee:	81 50       	subi	r24, 0x01	; 1
    1cf0:	85 8f       	std	Z+29, r24	; 0x1d
    1cf2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cf4:	18 16       	cp	r1, r24
    1cf6:	7c f3       	brlt	.-34     	; 0x1cd6 <xQueueGive+0x156>
    1cf8:	f8 01       	movw	r30, r16
    1cfa:	b5 8e       	std	Z+29, r11	; 0x1d
    1cfc:	0f 90       	pop	r0
    1cfe:	0f be       	out	0x3f, r0	; 63
    1d00:	97 d6       	rcall	.+3374   	; 0x2a30 <xTaskResumeAll>
    1d02:	81 11       	cpse	r24, r1
    1d04:	5d cf       	rjmp	.-326    	; 0x1bc0 <xQueueGive+0x40>
    1d06:	e5 dc       	rcall	.-1590   	; 0x16d2 <vPortYield>
    1d08:	5b cf       	rjmp	.-330    	; 0x1bc0 <xQueueGive+0x40>
    1d0a:	0f b6       	in	r0, 0x3f	; 63
    1d0c:	f8 94       	cli
    1d0e:	0f 92       	push	r0
    1d10:	f8 01       	movw	r30, r16
    1d12:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d14:	18 16       	cp	r1, r24
    1d16:	ac f4       	brge	.+42     	; 0x1d42 <xQueueGive+0x1c2>
    1d18:	81 89       	ldd	r24, Z+17	; 0x11
    1d1a:	81 11       	cpse	r24, r1
    1d1c:	05 c0       	rjmp	.+10     	; 0x1d28 <xQueueGive+0x1a8>
    1d1e:	11 c0       	rjmp	.+34     	; 0x1d42 <xQueueGive+0x1c2>
    1d20:	f8 01       	movw	r30, r16
    1d22:	81 89       	ldd	r24, Z+17	; 0x11
    1d24:	88 23       	and	r24, r24
    1d26:	69 f0       	breq	.+26     	; 0x1d42 <xQueueGive+0x1c2>
    1d28:	c6 01       	movw	r24, r12
    1d2a:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1d2e:	81 11       	cpse	r24, r1
    1d30:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1d34:	f8 01       	movw	r30, r16
    1d36:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d38:	81 50       	subi	r24, 0x01	; 1
    1d3a:	86 8f       	std	Z+30, r24	; 0x1e
    1d3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d3e:	18 16       	cp	r1, r24
    1d40:	7c f3       	brlt	.-34     	; 0x1d20 <xQueueGive+0x1a0>
    1d42:	f8 01       	movw	r30, r16
    1d44:	b6 8e       	std	Z+30, r11	; 0x1e
    1d46:	0f 90       	pop	r0
    1d48:	0f be       	out	0x3f, r0	; 63
    1d4a:	0f b6       	in	r0, 0x3f	; 63
    1d4c:	f8 94       	cli
    1d4e:	0f 92       	push	r0
    1d50:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d52:	18 16       	cp	r1, r24
    1d54:	ac f4       	brge	.+42     	; 0x1d80 <xQueueGive+0x200>
    1d56:	80 85       	ldd	r24, Z+8	; 0x08
    1d58:	81 11       	cpse	r24, r1
    1d5a:	05 c0       	rjmp	.+10     	; 0x1d66 <xQueueGive+0x1e6>
    1d5c:	11 c0       	rjmp	.+34     	; 0x1d80 <xQueueGive+0x200>
    1d5e:	f8 01       	movw	r30, r16
    1d60:	80 85       	ldd	r24, Z+8	; 0x08
    1d62:	88 23       	and	r24, r24
    1d64:	69 f0       	breq	.+26     	; 0x1d80 <xQueueGive+0x200>
    1d66:	c7 01       	movw	r24, r14
    1d68:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1d6c:	81 11       	cpse	r24, r1
    1d6e:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1d72:	f8 01       	movw	r30, r16
    1d74:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d76:	81 50       	subi	r24, 0x01	; 1
    1d78:	85 8f       	std	Z+29, r24	; 0x1d
    1d7a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d7c:	18 16       	cp	r1, r24
    1d7e:	7c f3       	brlt	.-34     	; 0x1d5e <xQueueGive+0x1de>
    1d80:	f8 01       	movw	r30, r16
    1d82:	b5 8e       	std	Z+29, r11	; 0x1d
    1d84:	0f 90       	pop	r0
    1d86:	0f be       	out	0x3f, r0	; 63
    1d88:	53 d6       	rcall	.+3238   	; 0x2a30 <xTaskResumeAll>
    1d8a:	1a cf       	rjmp	.-460    	; 0x1bc0 <xQueueGive+0x40>
    1d8c:	0f b6       	in	r0, 0x3f	; 63
    1d8e:	f8 94       	cli
    1d90:	0f 92       	push	r0
    1d92:	f8 01       	movw	r30, r16
    1d94:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d96:	18 16       	cp	r1, r24
    1d98:	d4 f4       	brge	.+52     	; 0x1dce <xQueueGive+0x24e>
    1d9a:	81 89       	ldd	r24, Z+17	; 0x11
    1d9c:	81 11       	cpse	r24, r1
    1d9e:	06 c0       	rjmp	.+12     	; 0x1dac <xQueueGive+0x22c>
    1da0:	16 c0       	rjmp	.+44     	; 0x1dce <xQueueGive+0x24e>
    1da2:	f8 01       	movw	r30, r16
    1da4:	81 89       	ldd	r24, Z+17	; 0x11
    1da6:	81 11       	cpse	r24, r1
    1da8:	05 c0       	rjmp	.+10     	; 0x1db4 <xQueueGive+0x234>
    1daa:	11 c0       	rjmp	.+34     	; 0x1dce <xQueueGive+0x24e>
    1dac:	78 01       	movw	r14, r16
    1dae:	f1 e1       	ldi	r31, 0x11	; 17
    1db0:	ef 0e       	add	r14, r31
    1db2:	f1 1c       	adc	r15, r1
    1db4:	c7 01       	movw	r24, r14
    1db6:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1dba:	81 11       	cpse	r24, r1
    1dbc:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1dc0:	f8 01       	movw	r30, r16
    1dc2:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dc4:	81 50       	subi	r24, 0x01	; 1
    1dc6:	86 8f       	std	Z+30, r24	; 0x1e
    1dc8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1dca:	18 16       	cp	r1, r24
    1dcc:	54 f3       	brlt	.-44     	; 0x1da2 <xQueueGive+0x222>
    1dce:	8f ef       	ldi	r24, 0xFF	; 255
    1dd0:	f8 01       	movw	r30, r16
    1dd2:	86 8f       	std	Z+30, r24	; 0x1e
    1dd4:	0f 90       	pop	r0
    1dd6:	0f be       	out	0x3f, r0	; 63
    1dd8:	0f b6       	in	r0, 0x3f	; 63
    1dda:	f8 94       	cli
    1ddc:	0f 92       	push	r0
    1dde:	85 8d       	ldd	r24, Z+29	; 0x1d
    1de0:	18 16       	cp	r1, r24
    1de2:	d4 f4       	brge	.+52     	; 0x1e18 <xQueueGive+0x298>
    1de4:	80 85       	ldd	r24, Z+8	; 0x08
    1de6:	81 11       	cpse	r24, r1
    1de8:	06 c0       	rjmp	.+12     	; 0x1df6 <xQueueGive+0x276>
    1dea:	16 c0       	rjmp	.+44     	; 0x1e18 <xQueueGive+0x298>
    1dec:	f8 01       	movw	r30, r16
    1dee:	80 85       	ldd	r24, Z+8	; 0x08
    1df0:	81 11       	cpse	r24, r1
    1df2:	05 c0       	rjmp	.+10     	; 0x1dfe <xQueueGive+0x27e>
    1df4:	11 c0       	rjmp	.+34     	; 0x1e18 <xQueueGive+0x298>
    1df6:	78 01       	movw	r14, r16
    1df8:	f8 e0       	ldi	r31, 0x08	; 8
    1dfa:	ef 0e       	add	r14, r31
    1dfc:	f1 1c       	adc	r15, r1
    1dfe:	c7 01       	movw	r24, r14
    1e00:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1e04:	81 11       	cpse	r24, r1
    1e06:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
    1e0a:	f8 01       	movw	r30, r16
    1e0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e0e:	81 50       	subi	r24, 0x01	; 1
    1e10:	85 8f       	std	Z+29, r24	; 0x1d
    1e12:	85 8d       	ldd	r24, Z+29	; 0x1d
    1e14:	18 16       	cp	r1, r24
    1e16:	54 f3       	brlt	.-44     	; 0x1dec <xQueueGive+0x26c>
    1e18:	8f ef       	ldi	r24, 0xFF	; 255
    1e1a:	f8 01       	movw	r30, r16
    1e1c:	85 8f       	std	Z+29, r24	; 0x1d
    1e1e:	0f 90       	pop	r0
    1e20:	0f be       	out	0x3f, r0	; 63
    1e22:	06 d6       	rcall	.+3084   	; 0x2a30 <xTaskResumeAll>
    1e24:	80 e0       	ldi	r24, 0x00	; 0
    1e26:	08 c0       	rjmp	.+16     	; 0x1e38 <xQueueGive+0x2b8>
    1e28:	f8 01       	movw	r30, r16
    1e2a:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e2c:	8f 5f       	subi	r24, 0xFF	; 255
    1e2e:	82 8f       	std	Z+26, r24	; 0x1a
    1e30:	81 89       	ldd	r24, Z+17	; 0x11
    1e32:	81 11       	cpse	r24, r1
    1e34:	df ce       	rjmp	.-578    	; 0x1bf4 <xQueueGive+0x74>
    1e36:	e8 ce       	rjmp	.-560    	; 0x1c08 <xQueueGive+0x88>
    1e38:	0f 90       	pop	r0
    1e3a:	0f 90       	pop	r0
    1e3c:	0f 90       	pop	r0
    1e3e:	0f 90       	pop	r0
    1e40:	0f 90       	pop	r0
    1e42:	df 91       	pop	r29
    1e44:	cf 91       	pop	r28
    1e46:	1f 91       	pop	r17
    1e48:	0f 91       	pop	r16
    1e4a:	ff 90       	pop	r15
    1e4c:	ef 90       	pop	r14
    1e4e:	df 90       	pop	r13
    1e50:	cf 90       	pop	r12
    1e52:	bf 90       	pop	r11
    1e54:	af 90       	pop	r10
    1e56:	9f 90       	pop	r9
    1e58:	08 95       	ret

00001e5a <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1e5a:	cf 93       	push	r28
    1e5c:	df 93       	push	r29
    1e5e:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e60:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e62:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e64:	98 17       	cp	r25, r24
    1e66:	d0 f4       	brcc	.+52     	; 0x1e9c <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    1e68:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e6a:	8f 5f       	subi	r24, 0xFF	; 255
    1e6c:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e6e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e70:	8f 3f       	cpi	r24, 0xFF	; 255
    1e72:	79 f4       	brne	.+30     	; 0x1e92 <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e74:	81 89       	ldd	r24, Z+17	; 0x11
    1e76:	88 23       	and	r24, r24
    1e78:	99 f0       	breq	.+38     	; 0x1ea0 <xQueueGiveFromISR+0x46>
    1e7a:	eb 01       	movw	r28, r22
    1e7c:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e7e:	41 96       	adiw	r24, 0x11	; 17
    1e80:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1e84:	88 23       	and	r24, r24
    1e86:	71 f0       	breq	.+28     	; 0x1ea4 <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1e88:	20 97       	sbiw	r28, 0x00	; 0
    1e8a:	71 f0       	breq	.+28     	; 0x1ea8 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1e8c:	81 e0       	ldi	r24, 0x01	; 1
    1e8e:	88 83       	st	Y, r24
    1e90:	0c c0       	rjmp	.+24     	; 0x1eaa <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e92:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e94:	8f 5f       	subi	r24, 0xFF	; 255
    1e96:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1e98:	81 e0       	ldi	r24, 0x01	; 1
    1e9a:	07 c0       	rjmp	.+14     	; 0x1eaa <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e9c:	80 e0       	ldi	r24, 0x00	; 0
    1e9e:	05 c0       	rjmp	.+10     	; 0x1eaa <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1ea0:	81 e0       	ldi	r24, 0x01	; 1
    1ea2:	03 c0       	rjmp	.+6      	; 0x1eaa <xQueueGiveFromISR+0x50>
    1ea4:	81 e0       	ldi	r24, 0x01	; 1
    1ea6:	01 c0       	rjmp	.+2      	; 0x1eaa <xQueueGiveFromISR+0x50>
    1ea8:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1eaa:	df 91       	pop	r29
    1eac:	cf 91       	pop	r28
    1eae:	08 95       	ret

00001eb0 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1eb0:	6f 92       	push	r6
    1eb2:	7f 92       	push	r7
    1eb4:	8f 92       	push	r8
    1eb6:	9f 92       	push	r9
    1eb8:	af 92       	push	r10
    1eba:	bf 92       	push	r11
    1ebc:	cf 92       	push	r12
    1ebe:	df 92       	push	r13
    1ec0:	ef 92       	push	r14
    1ec2:	ff 92       	push	r15
    1ec4:	0f 93       	push	r16
    1ec6:	1f 93       	push	r17
    1ec8:	cf 93       	push	r28
    1eca:	df 93       	push	r29
    1ecc:	00 d0       	rcall	.+0      	; 0x1ece <xQueueGenericReceive+0x1e>
    1ece:	1f 92       	push	r1
    1ed0:	1f 92       	push	r1
    1ed2:	cd b7       	in	r28, 0x3d	; 61
    1ed4:	de b7       	in	r29, 0x3e	; 62
    1ed6:	8c 01       	movw	r16, r24
    1ed8:	5b 01       	movw	r10, r22
    1eda:	5d 83       	std	Y+5, r21	; 0x05
    1edc:	4c 83       	std	Y+4, r20	; 0x04
    1ede:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1ee0:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1ee2:	77 24       	eor	r7, r7
    1ee4:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1ee6:	99 24       	eor	r9, r9
    1ee8:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1eea:	6c 01       	movw	r12, r24
    1eec:	88 e0       	ldi	r24, 0x08	; 8
    1eee:	c8 0e       	add	r12, r24
    1ef0:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ef2:	78 01       	movw	r14, r16
    1ef4:	e1 e1       	ldi	r30, 0x11	; 17
    1ef6:	ee 0e       	add	r14, r30
    1ef8:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1efa:	0f b6       	in	r0, 0x3f	; 63
    1efc:	f8 94       	cli
    1efe:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1f00:	f8 01       	movw	r30, r16
    1f02:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f04:	88 23       	and	r24, r24
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <xQueueGenericReceive+0x5a>
    1f08:	45 c0       	rjmp	.+138    	; 0x1f94 <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1f0a:	e6 80       	ldd	r14, Z+6	; 0x06
    1f0c:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1f0e:	44 8d       	ldd	r20, Z+28	; 0x1c
    1f10:	44 23       	and	r20, r20
    1f12:	a9 f0       	breq	.+42     	; 0x1f3e <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1f14:	50 e0       	ldi	r21, 0x00	; 0
    1f16:	c7 01       	movw	r24, r14
    1f18:	84 0f       	add	r24, r20
    1f1a:	95 1f       	adc	r25, r21
    1f1c:	97 83       	std	Z+7, r25	; 0x07
    1f1e:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1f20:	22 81       	ldd	r18, Z+2	; 0x02
    1f22:	33 81       	ldd	r19, Z+3	; 0x03
    1f24:	82 17       	cp	r24, r18
    1f26:	93 07       	cpc	r25, r19
    1f28:	20 f0       	brcs	.+8      	; 0x1f32 <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1f2a:	80 81       	ld	r24, Z
    1f2c:	91 81       	ldd	r25, Z+1	; 0x01
    1f2e:	97 83       	std	Z+7, r25	; 0x07
    1f30:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1f32:	f8 01       	movw	r30, r16
    1f34:	66 81       	ldd	r22, Z+6	; 0x06
    1f36:	77 81       	ldd	r23, Z+7	; 0x07
    1f38:	c5 01       	movw	r24, r10
    1f3a:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1f3e:	61 10       	cpse	r6, r1
    1f40:	19 c0       	rjmp	.+50     	; 0x1f74 <xQueueGenericReceive+0xc4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1f42:	f8 01       	movw	r30, r16
    1f44:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f46:	81 50       	subi	r24, 0x01	; 1
    1f48:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f4a:	80 81       	ld	r24, Z
    1f4c:	91 81       	ldd	r25, Z+1	; 0x01
    1f4e:	89 2b       	or	r24, r25
    1f50:	29 f4       	brne	.+10     	; 0x1f5c <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1f52:	0e 94 30 19 	call	0x3260	; 0x3260 <pvTaskIncrementMutexHeldCount>
    1f56:	f8 01       	movw	r30, r16
    1f58:	93 83       	std	Z+3, r25	; 0x03
    1f5a:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f5c:	f8 01       	movw	r30, r16
    1f5e:	80 85       	ldd	r24, Z+8	; 0x08
    1f60:	88 23       	and	r24, r24
    1f62:	a1 f0       	breq	.+40     	; 0x1f8c <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1f64:	c8 01       	movw	r24, r16
    1f66:	08 96       	adiw	r24, 0x08	; 8
    1f68:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
    1f6c:	81 30       	cpi	r24, 0x01	; 1
    1f6e:	71 f4       	brne	.+28     	; 0x1f8c <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1f70:	b0 db       	rcall	.-2208   	; 0x16d2 <vPortYield>
    1f72:	0c c0       	rjmp	.+24     	; 0x1f8c <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1f74:	f8 01       	movw	r30, r16
    1f76:	f7 82       	std	Z+7, r15	; 0x07
    1f78:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f7a:	81 89       	ldd	r24, Z+17	; 0x11
    1f7c:	88 23       	and	r24, r24
    1f7e:	31 f0       	breq	.+12     	; 0x1f8c <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f80:	c8 01       	movw	r24, r16
    1f82:	41 96       	adiw	r24, 0x11	; 17
    1f84:	0e 94 f7 17 	call	0x2fee	; 0x2fee <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1f88:	81 11       	cpse	r24, r1
    1f8a:	a3 db       	rcall	.-2234   	; 0x16d2 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1f8c:	0f 90       	pop	r0
    1f8e:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    1f90:	81 e0       	ldi	r24, 0x01	; 1
    1f92:	0e c1       	rjmp	.+540    	; 0x21b0 <xQueueGenericReceive+0x300>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f94:	8c 81       	ldd	r24, Y+4	; 0x04
    1f96:	9d 81       	ldd	r25, Y+5	; 0x05
    1f98:	89 2b       	or	r24, r25
    1f9a:	21 f4       	brne	.+8      	; 0x1fa4 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f9c:	0f 90       	pop	r0
    1f9e:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1fa0:	80 e0       	ldi	r24, 0x00	; 0
    1fa2:	06 c1       	rjmp	.+524    	; 0x21b0 <xQueueGenericReceive+0x300>
				}
				else if( xEntryTimeSet == pdFALSE )
    1fa4:	81 10       	cpse	r8, r1
    1fa6:	05 c0       	rjmp	.+10     	; 0x1fb2 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1fa8:	ce 01       	movw	r24, r28
    1faa:	01 96       	adiw	r24, 0x01	; 1
    1fac:	0e 94 3f 18 	call	0x307e	; 0x307e <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1fb0:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1fb2:	0f 90       	pop	r0

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1fb4:	0f be       	out	0x3f, r0	; 63
    1fb6:	36 d5       	rcall	.+2668   	; 0x2a24 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1fb8:	0f b6       	in	r0, 0x3f	; 63
    1fba:	f8 94       	cli
    1fbc:	0f 92       	push	r0
    1fbe:	f8 01       	movw	r30, r16
    1fc0:	85 8d       	ldd	r24, Z+29	; 0x1d
    1fc2:	8f 3f       	cpi	r24, 0xFF	; 255
    1fc4:	09 f4       	brne	.+2      	; 0x1fc8 <xQueueGenericReceive+0x118>
    1fc6:	15 8e       	std	Z+29, r1	; 0x1d
    1fc8:	f8 01       	movw	r30, r16
    1fca:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fcc:	8f 3f       	cpi	r24, 0xFF	; 255
    1fce:	09 f4       	brne	.+2      	; 0x1fd2 <xQueueGenericReceive+0x122>
    1fd0:	16 8e       	std	Z+30, r1	; 0x1e
    1fd2:	0f 90       	pop	r0
    1fd4:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1fd6:	be 01       	movw	r22, r28
    1fd8:	6c 5f       	subi	r22, 0xFC	; 252
    1fda:	7f 4f       	sbci	r23, 0xFF	; 255
    1fdc:	ce 01       	movw	r24, r28
    1fde:	01 96       	adiw	r24, 0x01	; 1
    1fe0:	0e 94 4a 18 	call	0x3094	; 0x3094 <xTaskCheckForTimeOut>
    1fe4:	81 11       	cpse	r24, r1
    1fe6:	9b c0       	rjmp	.+310    	; 0x211e <xQueueGenericReceive+0x26e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1fe8:	0f b6       	in	r0, 0x3f	; 63
    1fea:	f8 94       	cli
    1fec:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1fee:	f8 01       	movw	r30, r16
    1ff0:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1ff2:	0f 90       	pop	r0
    1ff4:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1ff6:	81 11       	cpse	r24, r1
    1ff8:	53 c0       	rjmp	.+166    	; 0x20a0 <xQueueGenericReceive+0x1f0>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1ffa:	80 81       	ld	r24, Z
    1ffc:	91 81       	ldd	r25, Z+1	; 0x01
    1ffe:	89 2b       	or	r24, r25
    2000:	49 f4       	brne	.+18     	; 0x2014 <xQueueGenericReceive+0x164>
					{
						taskENTER_CRITICAL();
    2002:	0f b6       	in	r0, 0x3f	; 63
    2004:	f8 94       	cli
    2006:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    2008:	82 81       	ldd	r24, Z+2	; 0x02
    200a:	93 81       	ldd	r25, Z+3	; 0x03
    200c:	0e 94 8e 18 	call	0x311c	; 0x311c <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    2010:	0f 90       	pop	r0
    2012:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2014:	6c 81       	ldd	r22, Y+4	; 0x04
    2016:	7d 81       	ldd	r23, Y+5	; 0x05
    2018:	c7 01       	movw	r24, r14
    201a:	8e d7       	rcall	.+3868   	; 0x2f38 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    201c:	0f b6       	in	r0, 0x3f	; 63
    201e:	f8 94       	cli
    2020:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2022:	f8 01       	movw	r30, r16
    2024:	86 8d       	ldd	r24, Z+30	; 0x1e
    2026:	18 16       	cp	r1, r24
    2028:	a4 f4       	brge	.+40     	; 0x2052 <xQueueGenericReceive+0x1a2>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    202a:	81 89       	ldd	r24, Z+17	; 0x11
    202c:	81 11       	cpse	r24, r1
    202e:	05 c0       	rjmp	.+10     	; 0x203a <xQueueGenericReceive+0x18a>
    2030:	10 c0       	rjmp	.+32     	; 0x2052 <xQueueGenericReceive+0x1a2>
    2032:	f8 01       	movw	r30, r16
    2034:	81 89       	ldd	r24, Z+17	; 0x11
    2036:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2038:	61 f0       	breq	.+24     	; 0x2052 <xQueueGenericReceive+0x1a2>
    203a:	c7 01       	movw	r24, r14
    203c:	d8 d7       	rcall	.+4016   	; 0x2fee <xTaskRemoveFromEventList>
    203e:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    2040:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2044:	f8 01       	movw	r30, r16
    2046:	86 8d       	ldd	r24, Z+30	; 0x1e
    2048:	81 50       	subi	r24, 0x01	; 1
    204a:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    204c:	86 8d       	ldd	r24, Z+30	; 0x1e
    204e:	18 16       	cp	r1, r24
    2050:	84 f3       	brlt	.-32     	; 0x2032 <xQueueGenericReceive+0x182>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2052:	f8 01       	movw	r30, r16
    2054:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    2056:	0f 90       	pop	r0
    2058:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    205a:	0f b6       	in	r0, 0x3f	; 63
    205c:	f8 94       	cli
    205e:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2060:	85 8d       	ldd	r24, Z+29	; 0x1d
    2062:	18 16       	cp	r1, r24
    2064:	a4 f4       	brge	.+40     	; 0x208e <xQueueGenericReceive+0x1de>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2066:	80 85       	ldd	r24, Z+8	; 0x08
    2068:	81 11       	cpse	r24, r1
    206a:	05 c0       	rjmp	.+10     	; 0x2076 <xQueueGenericReceive+0x1c6>
    206c:	10 c0       	rjmp	.+32     	; 0x208e <xQueueGenericReceive+0x1de>
    206e:	f8 01       	movw	r30, r16
    2070:	80 85       	ldd	r24, Z+8	; 0x08
    2072:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2074:	61 f0       	breq	.+24     	; 0x208e <xQueueGenericReceive+0x1de>
    2076:	c6 01       	movw	r24, r12
    2078:	ba d7       	rcall	.+3956   	; 0x2fee <xTaskRemoveFromEventList>
    207a:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    207c:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2080:	f8 01       	movw	r30, r16
    2082:	85 8d       	ldd	r24, Z+29	; 0x1d
    2084:	81 50       	subi	r24, 0x01	; 1
    2086:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2088:	85 8d       	ldd	r24, Z+29	; 0x1d
    208a:	18 16       	cp	r1, r24
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    208c:	84 f3       	brlt	.-32     	; 0x206e <xQueueGenericReceive+0x1be>
	}
	taskEXIT_CRITICAL();
    208e:	f8 01       	movw	r30, r16
    2090:	95 8e       	std	Z+29, r9	; 0x1d
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    2092:	0f 90       	pop	r0
    2094:	0f be       	out	0x3f, r0	; 63
    2096:	cc d4       	rcall	.+2456   	; 0x2a30 <xTaskResumeAll>
    2098:	81 11       	cpse	r24, r1
				{
					portYIELD_WITHIN_API();
    209a:	2f cf       	rjmp	.-418    	; 0x1efa <xQueueGenericReceive+0x4a>
    209c:	1a db       	rcall	.-2508   	; 0x16d2 <vPortYield>
    209e:	2d cf       	rjmp	.-422    	; 0x1efa <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    20a0:	0f b6       	in	r0, 0x3f	; 63
    20a2:	f8 94       	cli
    20a4:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    20a6:	f8 01       	movw	r30, r16
    20a8:	86 8d       	ldd	r24, Z+30	; 0x1e
    20aa:	18 16       	cp	r1, r24
    20ac:	a4 f4       	brge	.+40     	; 0x20d6 <xQueueGenericReceive+0x226>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20ae:	81 89       	ldd	r24, Z+17	; 0x11
    20b0:	81 11       	cpse	r24, r1
    20b2:	05 c0       	rjmp	.+10     	; 0x20be <xQueueGenericReceive+0x20e>
    20b4:	10 c0       	rjmp	.+32     	; 0x20d6 <xQueueGenericReceive+0x226>
    20b6:	f8 01       	movw	r30, r16
    20b8:	81 89       	ldd	r24, Z+17	; 0x11
    20ba:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20bc:	61 f0       	breq	.+24     	; 0x20d6 <xQueueGenericReceive+0x226>
    20be:	c7 01       	movw	r24, r14
    20c0:	96 d7       	rcall	.+3884   	; 0x2fee <xTaskRemoveFromEventList>
    20c2:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    20c4:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    20c8:	f8 01       	movw	r30, r16
    20ca:	86 8d       	ldd	r24, Z+30	; 0x1e
    20cc:	81 50       	subi	r24, 0x01	; 1
    20ce:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    20d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    20d2:	18 16       	cp	r1, r24
    20d4:	84 f3       	brlt	.-32     	; 0x20b6 <xQueueGenericReceive+0x206>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    20d6:	f8 01       	movw	r30, r16
    20d8:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    20da:	0f 90       	pop	r0
    20dc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    20de:	0f b6       	in	r0, 0x3f	; 63
    20e0:	f8 94       	cli
    20e2:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    20e4:	85 8d       	ldd	r24, Z+29	; 0x1d
    20e6:	18 16       	cp	r1, r24
    20e8:	a4 f4       	brge	.+40     	; 0x2112 <xQueueGenericReceive+0x262>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20ea:	80 85       	ldd	r24, Z+8	; 0x08
    20ec:	81 11       	cpse	r24, r1
    20ee:	05 c0       	rjmp	.+10     	; 0x20fa <xQueueGenericReceive+0x24a>
    20f0:	10 c0       	rjmp	.+32     	; 0x2112 <xQueueGenericReceive+0x262>
    20f2:	f8 01       	movw	r30, r16
    20f4:	80 85       	ldd	r24, Z+8	; 0x08
    20f6:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20f8:	61 f0       	breq	.+24     	; 0x2112 <xQueueGenericReceive+0x262>
    20fa:	c6 01       	movw	r24, r12
    20fc:	78 d7       	rcall	.+3824   	; 0x2fee <xTaskRemoveFromEventList>
    20fe:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    2100:	0e 94 85 18 	call	0x310a	; 0x310a <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2104:	f8 01       	movw	r30, r16
    2106:	85 8d       	ldd	r24, Z+29	; 0x1d
    2108:	81 50       	subi	r24, 0x01	; 1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    210a:	85 8f       	std	Z+29, r24	; 0x1d
    210c:	85 8d       	ldd	r24, Z+29	; 0x1d
    210e:	18 16       	cp	r1, r24
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2110:	84 f3       	brlt	.-32     	; 0x20f2 <xQueueGenericReceive+0x242>
    2112:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    2114:	95 8e       	std	Z+29, r9	; 0x1d
    2116:	0f 90       	pop	r0
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    2118:	0f be       	out	0x3f, r0	; 63
    211a:	8a d4       	rcall	.+2324   	; 0x2a30 <xTaskResumeAll>
    211c:	ee ce       	rjmp	.-548    	; 0x1efa <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    211e:	0f b6       	in	r0, 0x3f	; 63
    2120:	f8 94       	cli
    2122:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2124:	f8 01       	movw	r30, r16
    2126:	86 8d       	ldd	r24, Z+30	; 0x1e
    2128:	18 16       	cp	r1, r24
    212a:	c4 f4       	brge	.+48     	; 0x215c <xQueueGenericReceive+0x2ac>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    212c:	81 89       	ldd	r24, Z+17	; 0x11
    212e:	81 11       	cpse	r24, r1
    2130:	06 c0       	rjmp	.+12     	; 0x213e <xQueueGenericReceive+0x28e>
    2132:	14 c0       	rjmp	.+40     	; 0x215c <xQueueGenericReceive+0x2ac>
    2134:	f8 01       	movw	r30, r16
    2136:	81 89       	ldd	r24, Z+17	; 0x11
    2138:	81 11       	cpse	r24, r1
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    213a:	05 c0       	rjmp	.+10     	; 0x2146 <xQueueGenericReceive+0x296>
    213c:	0f c0       	rjmp	.+30     	; 0x215c <xQueueGenericReceive+0x2ac>
    213e:	78 01       	movw	r14, r16
    2140:	f1 e1       	ldi	r31, 0x11	; 17
    2142:	ef 0e       	add	r14, r31
    2144:	f1 1c       	adc	r15, r1
    2146:	c7 01       	movw	r24, r14
    2148:	52 d7       	rcall	.+3748   	; 0x2fee <xTaskRemoveFromEventList>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    214a:	81 11       	cpse	r24, r1
    214c:	de d7       	rcall	.+4028   	; 0x310a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    214e:	f8 01       	movw	r30, r16
    2150:	86 8d       	ldd	r24, Z+30	; 0x1e
    2152:	81 50       	subi	r24, 0x01	; 1
    2154:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2156:	86 8d       	ldd	r24, Z+30	; 0x1e
    2158:	18 16       	cp	r1, r24
    215a:	64 f3       	brlt	.-40     	; 0x2134 <xQueueGenericReceive+0x284>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    215c:	8f ef       	ldi	r24, 0xFF	; 255
    215e:	f8 01       	movw	r30, r16
    2160:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    2162:	0f 90       	pop	r0
    2164:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2166:	0f b6       	in	r0, 0x3f	; 63
    2168:	f8 94       	cli
    216a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    216c:	85 8d       	ldd	r24, Z+29	; 0x1d
    216e:	18 16       	cp	r1, r24
    2170:	c4 f4       	brge	.+48     	; 0x21a2 <xQueueGenericReceive+0x2f2>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2172:	80 85       	ldd	r24, Z+8	; 0x08
    2174:	81 11       	cpse	r24, r1
    2176:	06 c0       	rjmp	.+12     	; 0x2184 <xQueueGenericReceive+0x2d4>
    2178:	14 c0       	rjmp	.+40     	; 0x21a2 <xQueueGenericReceive+0x2f2>
    217a:	f8 01       	movw	r30, r16
    217c:	80 85       	ldd	r24, Z+8	; 0x08
    217e:	81 11       	cpse	r24, r1
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2180:	05 c0       	rjmp	.+10     	; 0x218c <xQueueGenericReceive+0x2dc>
    2182:	0f c0       	rjmp	.+30     	; 0x21a2 <xQueueGenericReceive+0x2f2>
    2184:	78 01       	movw	r14, r16
    2186:	f8 e0       	ldi	r31, 0x08	; 8
    2188:	ef 0e       	add	r14, r31
    218a:	f1 1c       	adc	r15, r1
    218c:	c7 01       	movw	r24, r14
				{
					vTaskMissedYield();
    218e:	2f d7       	rcall	.+3678   	; 0x2fee <xTaskRemoveFromEventList>
    2190:	81 11       	cpse	r24, r1
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2192:	bb d7       	rcall	.+3958   	; 0x310a <vTaskMissedYield>
    2194:	f8 01       	movw	r30, r16
    2196:	85 8d       	ldd	r24, Z+29	; 0x1d
    2198:	81 50       	subi	r24, 0x01	; 1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    219a:	85 8f       	std	Z+29, r24	; 0x1d
    219c:	85 8d       	ldd	r24, Z+29	; 0x1d
    219e:	18 16       	cp	r1, r24
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    21a0:	64 f3       	brlt	.-40     	; 0x217a <xQueueGenericReceive+0x2ca>
    21a2:	8f ef       	ldi	r24, 0xFF	; 255
    21a4:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    21a6:	85 8f       	std	Z+29, r24	; 0x1d
    21a8:	0f 90       	pop	r0
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    21aa:	0f be       	out	0x3f, r0	; 63
    21ac:	41 d4       	rcall	.+2178   	; 0x2a30 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    21ae:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    21b0:	0f 90       	pop	r0
    21b2:	0f 90       	pop	r0
    21b4:	0f 90       	pop	r0
    21b6:	0f 90       	pop	r0
    21b8:	0f 90       	pop	r0
    21ba:	df 91       	pop	r29
    21bc:	cf 91       	pop	r28
    21be:	1f 91       	pop	r17
    21c0:	0f 91       	pop	r16
    21c2:	ff 90       	pop	r15
    21c4:	ef 90       	pop	r14
    21c6:	df 90       	pop	r13
    21c8:	cf 90       	pop	r12
    21ca:	bf 90       	pop	r11
    21cc:	af 90       	pop	r10
    21ce:	9f 90       	pop	r9
    21d0:	8f 90       	pop	r8
    21d2:	7f 90       	pop	r7
    21d4:	6f 90       	pop	r6
    21d6:	08 95       	ret

000021d8 <server_receiver>:
void send_idle(void) {
  if(!connected) return;
  uint8_t status = TYPE_IDLE;
  if(use_arq[TYPE_IDLE]) arq_send(server_connection, &status, 1);
  else simple_p_send(SERVER_ADDRESS, &status, 1);
}
    21d8:	ab 01       	movw	r20, r22
    21da:	00 97       	sbiw	r24, 0x00	; 0
    21dc:	11 f4       	brne	.+4      	; 0x21e2 <server_receiver+0xa>
    21de:	10 92 8a 15 	sts	0x158A, r1	; 0x80158a <gHandshook>
    21e2:	bc 01       	movw	r22, r24
    21e4:	86 ef       	ldi	r24, 0xF6	; 246
    21e6:	96 e1       	ldi	r25, 0x16	; 22
    21e8:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
    21ec:	60 e0       	ldi	r22, 0x00	; 0
    21ee:	70 e0       	ldi	r23, 0x00	; 0
    21f0:	80 91 f2 16 	lds	r24, 0x16F2	; 0x8016f2 <xCommandReadyBSem>
    21f4:	90 91 f3 16 	lds	r25, 0x16F3	; 0x8016f3 <xCommandReadyBSem+0x1>
    21f8:	c3 cc       	rjmp	.-1658   	; 0x1b80 <xQueueGive>
    21fa:	08 95       	ret

000021fc <debug>:
void debug(const char *fmt, ...) {
    21fc:	cf 93       	push	r28
    21fe:	df 93       	push	r29
    2200:	cd b7       	in	r28, 0x3d	; 61
    2202:	de b7       	in	r29, 0x3e	; 62
    2204:	c4 56       	subi	r28, 0x64	; 100
    2206:	d1 09       	sbc	r29, r1
    2208:	0f b6       	in	r0, 0x3f	; 63
    220a:	f8 94       	cli
    220c:	de bf       	out	0x3e, r29	; 62
    220e:	0f be       	out	0x3f, r0	; 63
    2210:	cd bf       	out	0x3d, r28	; 61
    2212:	ae 01       	movw	r20, r28
    2214:	46 59       	subi	r20, 0x96	; 150
    2216:	5f 4f       	sbci	r21, 0xFF	; 255
    2218:	fa 01       	movw	r30, r20
    221a:	61 91       	ld	r22, Z+
    221c:	71 91       	ld	r23, Z+
    221e:	af 01       	movw	r20, r30
	uint8_t buf[100];
	va_list ap;
	buf[0] = TYPE_DEBUG;
    2220:	8a e0       	ldi	r24, 0x0A	; 10
    2222:	89 83       	std	Y+1, r24	; 0x01
	va_start(ap, fmt);
	uint8_t ret = vsprintf((char*)buf+1, fmt, ap);
    2224:	ce 01       	movw	r24, r28
    2226:	02 96       	adiw	r24, 0x02	; 2
    2228:	0e 94 40 21 	call	0x4280	; 0x4280 <vsprintf>
	va_end(ap);
	if (ret > 0) {
    222c:	88 23       	and	r24, r24
    222e:	c9 f0       	breq	.+50     	; 0x2262 <__stack+0x63>
		if(use_arq[TYPE_DEBUG]) arq_send(server_connection, buf, ret+1);
    2230:	20 91 0a 02 	lds	r18, 0x020A	; 0x80020a <__data_start+0xa>
    2234:	22 23       	and	r18, r18
    2236:	61 f0       	breq	.+24     	; 0x2250 <__stack+0x51>
    2238:	99 27       	eor	r25, r25
    223a:	ac 01       	movw	r20, r24
    223c:	4f 5f       	subi	r20, 0xFF	; 255
    223e:	5f 4f       	sbci	r21, 0xFF	; 255
    2240:	be 01       	movw	r22, r28
    2242:	6f 5f       	subi	r22, 0xFF	; 255
    2244:	7f 4f       	sbci	r23, 0xFF	; 255
    2246:	80 91 2c 17 	lds	r24, 0x172C	; 0x80172c <server_connection>
    224a:	0e 94 32 01 	call	0x264	; 0x264 <arq_send>
    224e:	09 c0       	rjmp	.+18     	; 0x2262 <__stack+0x63>
		else simple_p_send(SERVER_ADDRESS, buf, ret+1);
    2250:	99 27       	eor	r25, r25
    2252:	ac 01       	movw	r20, r24
    2254:	4f 5f       	subi	r20, 0xFF	; 255
    2256:	5f 4f       	sbci	r21, 0xFF	; 255
    2258:	be 01       	movw	r22, r28
    225a:	6f 5f       	subi	r22, 0xFF	; 255
    225c:	7f 4f       	sbci	r23, 0xFF	; 255
    225e:	80 e0       	ldi	r24, 0x00	; 0
    2260:	b6 d0       	rcall	.+364    	; 0x23ce <simple_p_send>
	}
}
    2262:	cc 59       	subi	r28, 0x9C	; 156
    2264:	df 4f       	sbci	r29, 0xFF	; 255
    2266:	0f b6       	in	r0, 0x3f	; 63
    2268:	f8 94       	cli
    226a:	de bf       	out	0x3e, r29	; 62
    226c:	0f be       	out	0x3f, r0	; 63
    226e:	cd bf       	out	0x3d, r28	; 61
    2270:	df 91       	pop	r29
    2272:	cf 91       	pop	r28
    2274:	08 95       	ret

00002276 <vServo_setAngle>:
    /*  Set angle to desired start angle (usually 0)*/
    vServo_setAngle(servoAngleDeg);
}

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
    2276:	cf 93       	push	r28
    2278:	c8 2f       	mov	r28, r24
	debug("vServo_setAngle: %i", ServoAngleDeg);
    227a:	68 2f       	mov	r22, r24
    227c:	70 e0       	ldi	r23, 0x00	; 0
    227e:	8b e0       	ldi	r24, 0x0B	; 11
    2280:	92 e0       	ldi	r25, 0x02	; 2
    2282:	bc df       	rcall	.-136    	; 0x21fc <debug>
    /* Ensure feasible values */
    if (ServoAngleDeg >= 90){
    2284:	ca 35       	cpi	r28, 0x5A	; 90
    2286:	08 f0       	brcs	.+2      	; 0x228a <vServo_setAngle+0x14>
        ServoAngleDeg = 90;
    2288:	ca e5       	ldi	r28, 0x5A	; 90
    }
    else if(ServoAngleDeg <= 0){
        ServoAngleDeg = 0;
    }
    /* Fetch pulse width from array and set to output */
    servoOCR = DEG_TO_PWM[ServoAngleDeg];
    228a:	ec 2f       	mov	r30, r28
    228c:	f0 e0       	ldi	r31, 0x00	; 0
    228e:	ee 0f       	add	r30, r30
    2290:	ff 1f       	adc	r31, r31
    2292:	e1 5e       	subi	r30, 0xE1	; 225
    2294:	fd 4f       	sbci	r31, 0xFD	; 253
    2296:	80 81       	ld	r24, Z
    2298:	91 81       	ldd	r25, Z+1	; 0x01
    229a:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    229e:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    22a2:	cf 91       	pop	r28
    22a4:	08 95       	ret

000022a6 <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
    /* Clear OCnA/OCnB on Compare Match, set */
    /* OCnA/OCnB at BOTTOM (non-inverting mode) */
    /* Datasheet p.155 Table 17-4 */
    TCCR4A |= (1<<COM4B1) | (0<<COM4B0);
    22a6:	a0 ea       	ldi	r26, 0xA0	; 160
    22a8:	b0 e0       	ldi	r27, 0x00	; 0
    22aa:	9c 91       	ld	r25, X
    22ac:	90 62       	ori	r25, 0x20	; 32
    22ae:	9c 93       	st	X, r25
    
    /* Waveform generation mode 14: Fast PWM */
    /* top: ICRn, Update bottom, flag set on top */
    /* Datasheet p.145 Table 17-2 */
	
    TCCR4B |= (1<<WGM43) | (1<<WGM42);                                             
    22b0:	e1 ea       	ldi	r30, 0xA1	; 161
    22b2:	f0 e0       	ldi	r31, 0x00	; 0
    22b4:	90 81       	ld	r25, Z
    22b6:	98 61       	ori	r25, 0x18	; 24
    22b8:	90 83       	st	Z, r25
    TCCR4A |= (1<<WGM41) | (0<<WGM40);
    22ba:	9c 91       	ld	r25, X
    22bc:	92 60       	ori	r25, 0x02	; 2
    22be:	9c 93       	st	X, r25

    /* Clock select bit description: */
    /* clkI/O/8 (From prescaler) - Datasheet p.157 Table 17-6*/

     TCCR4B |= (0<<CS42) | (1<<CS41) | (0<<CS40);                                           
    22c0:	90 81       	ld	r25, Z
    22c2:	92 60       	ori	r25, 0x02	; 2
    22c4:	90 83       	st	Z, r25
    
    /* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
    /* Datasheet p.125 */
    ICR4 = 39999; // 49999 for 20mhz, 39 999 for 16Mhz                                      
    22c6:	2f e3       	ldi	r18, 0x3F	; 63
    22c8:	3c e9       	ldi	r19, 0x9C	; 156
    22ca:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>
    22ce:	20 93 a6 00 	sts	0x00A6, r18	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
    
    /*Port H Pin 7 as servo PWM Output (OC4B)*/
    servoReg |= (1<<servoPin);
    22d2:	e1 e0       	ldi	r30, 0x01	; 1
    22d4:	f1 e0       	ldi	r31, 0x01	; 1
    22d6:	90 81       	ld	r25, Z
    22d8:	90 61       	ori	r25, 0x10	; 16
    22da:	90 83       	st	Z, r25
    
    /*  Set angle to desired start angle (usually 0)*/
    vServo_setAngle(servoAngleDeg);
    22dc:	cc cf       	rjmp	.-104    	; 0x2276 <vServo_setAngle>
    22de:	08 95       	ret

000022e0 <simple_p_reassembly>:
  vPortFree(part);
  return 1;
}


void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length) {
    22e0:	ef 92       	push	r14
    22e2:	ff 92       	push	r15
    22e4:	0f 93       	push	r16
    22e6:	1f 93       	push	r17
    22e8:	cf 93       	push	r28
    22ea:	df 93       	push	r29
  uint8_t i;
  uint8_t id = 0xFF;
  uint8_t free = 0xFF;
  for(i=0;i<MAX_MESSAGES;i++) {
    if(messages[i].address == 0xFF && free == 0xFF) free = i;
    22ec:	90 91 90 15 	lds	r25, 0x1590	; 0x801590 <messages+0x1>
    22f0:	9f 3f       	cpi	r25, 0xFF	; 255
    22f2:	11 f0       	breq	.+4      	; 0x22f8 <simple_p_reassembly+0x18>
    else if(messages[i].address == sender) {
    22f4:	98 13       	cpse	r25, r24
    22f6:	58 c0       	rjmp	.+176    	; 0x23a8 <simple_p_reassembly+0xc8>
  if(id == 0xFF && free == 0xFF) return; // Not room for any more messages, and none is stored for this address
  else if(id == 0xFF && free != 0xFF) { // Did not find any part messages from this sender, but there is room to store a new one
    id = free; 
  }
    
  if(data[0] == 0) { // First part of a new message
    22f8:	fb 01       	movw	r30, r22
    22fa:	80 81       	ld	r24, Z
    22fc:	81 11       	cpse	r24, r1
    22fe:	05 c0       	rjmp	.+10     	; 0x230a <simple_p_reassembly+0x2a>
    messages[id].num_received_bytes = 0;
    2300:	10 92 92 15 	sts	0x1592, r1	; 0x801592 <messages+0x3>
    2304:	10 92 91 15 	sts	0x1591, r1	; 0x801591 <messages+0x2>
    2308:	0c c0       	rjmp	.+24     	; 0x2322 <simple_p_reassembly+0x42>
  } else if(data[0] != messages[id].next_part) {
    230a:	90 91 93 15 	lds	r25, 0x1593	; 0x801593 <messages+0x4>
    230e:	89 17       	cp	r24, r25
    2310:	41 f0       	breq	.+16     	; 0x2322 <simple_p_reassembly+0x42>
    messages[id].next_part = 0;
    2312:	ef e8       	ldi	r30, 0x8F	; 143
    2314:	f5 e1       	ldi	r31, 0x15	; 21
    2316:	14 82       	std	Z+4, r1	; 0x04
    messages[id].num_received_bytes = 0;
    2318:	13 82       	std	Z+3, r1	; 0x03
    231a:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    231c:	8f ef       	ldi	r24, 0xFF	; 255
    231e:	81 83       	std	Z+1, r24	; 0x01
    return;
    2320:	43 c0       	rjmp	.+134    	; 0x23a8 <simple_p_reassembly+0xc8>
  }

  if(messages[id].num_received_bytes + (length-2) > MAX_MESSAGE_SIZE) { // Message is larger than what can be handled, discard it
    2322:	80 91 91 15 	lds	r24, 0x1591	; 0x801591 <messages+0x2>
    2326:	90 91 92 15 	lds	r25, 0x1592	; 0x801592 <messages+0x3>
    232a:	9c 01       	movw	r18, r24
    232c:	22 50       	subi	r18, 0x02	; 2
    232e:	31 09       	sbc	r19, r1
    2330:	24 0f       	add	r18, r20
    2332:	35 1f       	adc	r19, r21
    2334:	25 36       	cpi	r18, 0x65	; 101
    2336:	31 05       	cpc	r19, r1
    2338:	40 f0       	brcs	.+16     	; 0x234a <simple_p_reassembly+0x6a>
    messages[id].num_received_bytes = 0;
    233a:	ef e8       	ldi	r30, 0x8F	; 143
    233c:	f5 e1       	ldi	r31, 0x15	; 21
    233e:	13 82       	std	Z+3, r1	; 0x03
    2340:	12 82       	std	Z+2, r1	; 0x02
    messages[id].next_part = 0;
    2342:	14 82       	std	Z+4, r1	; 0x04
    messages[id].address = 0xFF;
    2344:	8f ef       	ldi	r24, 0xFF	; 255
    2346:	81 83       	std	Z+1, r24	; 0x01
    return;
    2348:	2f c0       	rjmp	.+94     	; 0x23a8 <simple_p_reassembly+0xc8>
    234a:	8a 01       	movw	r16, r20
    234c:	eb 01       	movw	r28, r22
  }
  
  messages[id].next_part++;
    234e:	0f 2e       	mov	r0, r31
    2350:	ff e8       	ldi	r31, 0x8F	; 143
    2352:	ef 2e       	mov	r14, r31
    2354:	f5 e1       	ldi	r31, 0x15	; 21
    2356:	ff 2e       	mov	r15, r31
    2358:	f0 2d       	mov	r31, r0
    235a:	f7 01       	movw	r30, r14
    235c:	24 81       	ldd	r18, Z+4	; 0x04
    235e:	2f 5f       	subi	r18, 0xFF	; 255
    2360:	24 83       	std	Z+4, r18	; 0x04
  memcpy(messages[id].message+messages[id].num_received_bytes, data+2, length-2);
    2362:	42 50       	subi	r20, 0x02	; 2
    2364:	51 09       	sbc	r21, r1
    2366:	6e 5f       	subi	r22, 0xFE	; 254
    2368:	7f 4f       	sbci	r23, 0xFF	; 255
    236a:	8c 56       	subi	r24, 0x6C	; 108
    236c:	9a 4e       	sbci	r25, 0xEA	; 234
    236e:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
  messages[id].num_received_bytes += (length-2);
    2372:	f7 01       	movw	r30, r14
    2374:	42 81       	ldd	r20, Z+2	; 0x02
    2376:	53 81       	ldd	r21, Z+3	; 0x03
    2378:	42 50       	subi	r20, 0x02	; 2
    237a:	51 09       	sbc	r21, r1
    237c:	ba 01       	movw	r22, r20
    237e:	60 0f       	add	r22, r16
    2380:	71 1f       	adc	r23, r17
    2382:	73 83       	std	Z+3, r23	; 0x03
    2384:	62 83       	std	Z+2, r22	; 0x02
  
  if(data[0] == data[1]) {
    2386:	98 81       	ld	r25, Y
    2388:	89 81       	ldd	r24, Y+1	; 0x01
    238a:	98 13       	cpse	r25, r24
    238c:	0d c0       	rjmp	.+26     	; 0x23a8 <simple_p_reassembly+0xc8>
    callback_data_received(messages[id].message, messages[id].num_received_bytes);
    238e:	e0 91 2d 17 	lds	r30, 0x172D	; 0x80172d <callback_data_received>
    2392:	f0 91 2e 17 	lds	r31, 0x172E	; 0x80172e <callback_data_received+0x1>
    2396:	84 e9       	ldi	r24, 0x94	; 148
    2398:	95 e1       	ldi	r25, 0x15	; 21
    239a:	19 95       	eicall
    messages[id].num_received_bytes = messages[id].next_part = 0;
    239c:	f7 01       	movw	r30, r14
    239e:	14 82       	std	Z+4, r1	; 0x04
    23a0:	13 82       	std	Z+3, r1	; 0x03
    23a2:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    23a4:	8f ef       	ldi	r24, 0xFF	; 255
    23a6:	81 83       	std	Z+1, r24	; 0x01
  }
    23a8:	df 91       	pop	r29
    23aa:	cf 91       	pop	r28
    23ac:	1f 91       	pop	r17
    23ae:	0f 91       	pop	r16
    23b0:	ff 90       	pop	r15
    23b2:	ef 90       	pop	r14
    23b4:	08 95       	ret

000023b6 <simple_p_init>:
void (*callback_data_received)(uint8_t*, uint16_t); 

void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length);

void simple_p_init(void (*cb)(uint8_t*, uint16_t)) {
  callback_data_received = cb;
    23b6:	90 93 2e 17 	sts	0x172E, r25	; 0x80172e <callback_data_received+0x1>
    23ba:	80 93 2d 17 	sts	0x172D, r24	; 0x80172d <callback_data_received>
  uint8_t i;
  network_set_callback(PROTOCOL_SIMPLE, simple_p_reassembly);
    23be:	60 e7       	ldi	r22, 0x70	; 112
    23c0:	71 e1       	ldi	r23, 0x11	; 17
    23c2:	80 e0       	ldi	r24, 0x00	; 0
    23c4:	a1 d8       	rcall	.-3774   	; 0x1508 <network_set_callback>
  for(i=0;i<MAX_MESSAGES;i++) {
    messages[i].address = 0xFF;
    23c6:	8f ef       	ldi	r24, 0xFF	; 255
    23c8:	80 93 90 15 	sts	0x1590, r24	; 0x801590 <messages+0x1>
    23cc:	08 95       	ret

000023ce <simple_p_send>:
  }
}

uint8_t simple_p_send(uint8_t address, uint8_t *data, uint16_t length) {  
    23ce:	5f 92       	push	r5
    23d0:	6f 92       	push	r6
    23d2:	7f 92       	push	r7
    23d4:	8f 92       	push	r8
    23d6:	9f 92       	push	r9
    23d8:	af 92       	push	r10
    23da:	bf 92       	push	r11
    23dc:	cf 92       	push	r12
    23de:	df 92       	push	r13
    23e0:	ef 92       	push	r14
    23e2:	ff 92       	push	r15
    23e4:	0f 93       	push	r16
    23e6:	1f 93       	push	r17
    23e8:	cf 93       	push	r28
    23ea:	df 93       	push	r29
    23ec:	58 2e       	mov	r5, r24
    23ee:	5b 01       	movw	r10, r22
    23f0:	8a 01       	movw	r16, r20
  uint16_t tmp;
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
    23f2:	8c e2       	ldi	r24, 0x2C	; 44
    23f4:	90 e0       	ldi	r25, 0x00	; 0
    23f6:	0e 94 5f 05 	call	0xabe	; 0xabe <pvPortMalloc>
    23fa:	7c 01       	movw	r14, r24
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
    23fc:	98 01       	movw	r18, r16
    23fe:	36 95       	lsr	r19
    2400:	27 95       	ror	r18
    2402:	ad e0       	ldi	r26, 0x0D	; 13
    2404:	b3 ec       	ldi	r27, 0xC3	; 195
    2406:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <__umulhisi3>
    240a:	92 95       	swap	r25
    240c:	82 95       	swap	r24
    240e:	8f 70       	andi	r24, 0x0F	; 15
    2410:	89 27       	eor	r24, r25
    2412:	9f 70       	andi	r25, 0x0F	; 15
    2414:	89 27       	eor	r24, r25
    2416:	4a e2       	ldi	r20, 0x2A	; 42
    2418:	48 9f       	mul	r20, r24
    241a:	90 01       	movw	r18, r0
    241c:	49 9f       	mul	r20, r25
    241e:	30 0d       	add	r19, r0
    2420:	11 24       	eor	r1, r1
    2422:	41 e0       	ldi	r20, 0x01	; 1
    2424:	02 17       	cp	r16, r18
    2426:	13 07       	cpc	r17, r19
    2428:	09 f4       	brne	.+2      	; 0x242c <simple_p_send+0x5e>
    242a:	40 e0       	ldi	r20, 0x00	; 0
    242c:	98 01       	movw	r18, r16
    242e:	36 95       	lsr	r19
    2430:	27 95       	ror	r18
    2432:	ad e0       	ldi	r26, 0x0D	; 13
    2434:	b3 ec       	ldi	r27, 0xC3	; 195
    2436:	0e 94 fe 1f 	call	0x3ffc	; 0x3ffc <__umulhisi3>
    243a:	92 95       	swap	r25
    243c:	82 95       	swap	r24
    243e:	8f 70       	andi	r24, 0x0F	; 15
    2440:	89 27       	eor	r24, r25
    2442:	9f 70       	andi	r25, 0x0F	; 15
    2444:	89 27       	eor	r24, r25
    2446:	84 0f       	add	r24, r20
  while(remaining > 0) {
    2448:	01 15       	cp	r16, r1
    244a:	11 05       	cpc	r17, r1
    244c:	51 f1       	breq	.+84     	; 0x24a2 <simple_p_send+0xd4>
    244e:	90 e0       	ldi	r25, 0x00	; 0
    2450:	c1 2c       	mov	r12, r1
    2452:	d1 2c       	mov	r13, r1
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    part[1] = number_of_parts-1;
    2454:	66 24       	eor	r6, r6
    2456:	6a 94       	dec	r6
    2458:	68 0e       	add	r6, r24
    memcpy(part+2, data+offset, tmp);
    245a:	47 01       	movw	r8, r14
    245c:	82 e0       	ldi	r24, 0x02	; 2
    245e:	88 0e       	add	r8, r24
    2460:	91 1c       	adc	r9, r1
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    2462:	e8 01       	movw	r28, r16
    2464:	0b 32       	cpi	r16, 0x2B	; 43
    2466:	11 05       	cpc	r17, r1
    2468:	10 f0       	brcs	.+4      	; 0x246e <simple_p_send+0xa0>
    246a:	ca e2       	ldi	r28, 0x2A	; 42
    246c:	d0 e0       	ldi	r29, 0x00	; 0
    part[0] = part_number++;
    246e:	77 24       	eor	r7, r7
    2470:	73 94       	inc	r7
    2472:	79 0e       	add	r7, r25
    2474:	f7 01       	movw	r30, r14
    2476:	90 83       	st	Z, r25
    part[1] = number_of_parts-1;
    2478:	61 82       	std	Z+1, r6	; 0x01
    memcpy(part+2, data+offset, tmp);
    247a:	b5 01       	movw	r22, r10
    247c:	6c 0d       	add	r22, r12
    247e:	7d 1d       	adc	r23, r13
    2480:	ae 01       	movw	r20, r28
    2482:	c4 01       	movw	r24, r8
    2484:	0e 94 f0 20 	call	0x41e0	; 0x41e0 <memcpy>
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    2488:	9e 01       	movw	r18, r28
    248a:	2e 5f       	subi	r18, 0xFE	; 254
    248c:	3f 4f       	sbci	r19, 0xFF	; 255
    248e:	a7 01       	movw	r20, r14
    2490:	60 e0       	ldi	r22, 0x00	; 0
    2492:	85 2d       	mov	r24, r5
    2494:	44 d8       	rcall	.-3960   	; 0x151e <network_send>
    offset += tmp;
    2496:	cc 0e       	add	r12, r28
    2498:	dd 1e       	adc	r13, r29
    remaining -= tmp;
    249a:	0c 1b       	sub	r16, r28
    249c:	1d 0b       	sbc	r17, r29
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    249e:	97 2d       	mov	r25, r7
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    24a0:	01 f7       	brne	.-64     	; 0x2462 <simple_p_send+0x94>
    memcpy(part+2, data+offset, tmp);
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    offset += tmp;
    remaining -= tmp;
  }
  vPortFree(part);
    24a2:	c7 01       	movw	r24, r14
    24a4:	0e 94 69 06 	call	0xcd2	; 0xcd2 <vPortFree>
  return 1;
}
    24a8:	81 e0       	ldi	r24, 0x01	; 1
    24aa:	df 91       	pop	r29
    24ac:	cf 91       	pop	r28
    24ae:	1f 91       	pop	r17
    24b0:	0f 91       	pop	r16
    24b2:	ff 90       	pop	r15
    24b4:	ef 90       	pop	r14
    24b6:	df 90       	pop	r13
    24b8:	cf 90       	pop	r12
    24ba:	bf 90       	pop	r11
    24bc:	af 90       	pop	r10
    24be:	9f 90       	pop	r9
    24c0:	8f 90       	pop	r8
    24c2:	7f 90       	pop	r7
    24c4:	6f 90       	pop	r6
    24c6:	5f 90       	pop	r5
    24c8:	08 95       	ret

000024ca <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    24ca:	84 b1       	in	r24, 0x04	; 4
    24cc:	87 60       	ori	r24, 0x07	; 7
    24ce:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    24d0:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    24d2:	8c b5       	in	r24, 0x2c	; 44
    24d4:	81 60       	ori	r24, 0x01	; 1
    24d6:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    24d8:	8c b5       	in	r24, 0x2c	; 44
    24da:	8c 65       	ori	r24, 0x5C	; 92
    24dc:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    24de:	8c b5       	in	r24, 0x2c	; 44
    24e0:	8f 7d       	andi	r24, 0xDF	; 223
    24e2:	8c bd       	out	0x2c, r24	; 44
    24e4:	08 95       	ret

000024e6 <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    24e6:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    24e8:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    24ea:	0d b4       	in	r0, 0x2d	; 45
    24ec:	07 fe       	sbrs	r0, 7
    24ee:	fd cf       	rjmp	.-6      	; 0x24ea <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    24f0:	8e b5       	in	r24, 0x2e	; 46
}
    24f2:	08 95       	ret

000024f4 <xTaskGenericCreate>:
			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
		}
		taskEXIT_CRITICAL();

		return ulReturn;
	}
    24f4:	4f 92       	push	r4
    24f6:	5f 92       	push	r5
    24f8:	6f 92       	push	r6
    24fa:	7f 92       	push	r7
    24fc:	8f 92       	push	r8
    24fe:	9f 92       	push	r9
    2500:	af 92       	push	r10
    2502:	bf 92       	push	r11
    2504:	cf 92       	push	r12
    2506:	df 92       	push	r13
    2508:	ef 92       	push	r14
    250a:	ff 92       	push	r15
    250c:	0f 93       	push	r16
    250e:	1f 93       	push	r17
    2510:	cf 93       	push	r28
    2512:	df 93       	push	r29
    2514:	3c 01       	movw	r6, r24
    2516:	5b 01       	movw	r10, r22
    2518:	4a 01       	movw	r8, r20
    251a:	29 01       	movw	r4, r18
    251c:	c1 14       	cp	r12, r1
    251e:	d1 04       	cpc	r13, r1
    2520:	39 f4       	brne	.+14     	; 0x2530 <xTaskGenericCreate+0x3c>
    2522:	ca 01       	movw	r24, r20
    2524:	0e 94 5f 05 	call	0xabe	; 0xabe <pvPortMalloc>
    2528:	6c 01       	movw	r12, r24
    252a:	89 2b       	or	r24, r25
    252c:	09 f4       	brne	.+2      	; 0x2530 <xTaskGenericCreate+0x3c>
    252e:	e3 c0       	rjmp	.+454    	; 0x26f6 <xTaskGenericCreate+0x202>
    2530:	88 e2       	ldi	r24, 0x28	; 40
    2532:	90 e0       	ldi	r25, 0x00	; 0
    2534:	0e 94 5f 05 	call	0xabe	; 0xabe <pvPortMalloc>
    2538:	ec 01       	movw	r28, r24
    253a:	89 2b       	or	r24, r25
    253c:	71 f0       	breq	.+28     	; 0x255a <xTaskGenericCreate+0x66>
    253e:	d8 8e       	std	Y+24, r13	; 0x18
    2540:	cf 8a       	std	Y+23, r12	; 0x17
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	88 1a       	sub	r8, r24
    2546:	91 08       	sbc	r9, r1
    2548:	c8 0c       	add	r12, r8
    254a:	d9 1c       	adc	r13, r9
    254c:	d5 01       	movw	r26, r10
    254e:	8c 91       	ld	r24, X
    2550:	89 8f       	std	Y+25, r24	; 0x19
    2552:	8c 91       	ld	r24, X
    2554:	81 11       	cpse	r24, r1
    2556:	05 c0       	rjmp	.+10     	; 0x2562 <xTaskGenericCreate+0x6e>
    2558:	18 c0       	rjmp	.+48     	; 0x258a <xTaskGenericCreate+0x96>
    255a:	c6 01       	movw	r24, r12
    255c:	0e 94 69 06 	call	0xcd2	; 0xcd2 <vPortFree>
    2560:	ca c0       	rjmp	.+404    	; 0x26f6 <xTaskGenericCreate+0x202>
    2562:	ae 01       	movw	r20, r28
    2564:	46 5e       	subi	r20, 0xE6	; 230
    2566:	5f 4f       	sbci	r21, 0xFF	; 255
    2568:	f5 01       	movw	r30, r10
    256a:	31 96       	adiw	r30, 0x01	; 1
    256c:	b8 e0       	ldi	r27, 0x08	; 8
    256e:	ab 0e       	add	r10, r27
    2570:	b1 1c       	adc	r11, r1
    2572:	cf 01       	movw	r24, r30
    2574:	21 91       	ld	r18, Z+
    2576:	da 01       	movw	r26, r20
    2578:	2d 93       	st	X+, r18
    257a:	ad 01       	movw	r20, r26
    257c:	dc 01       	movw	r26, r24
    257e:	8c 91       	ld	r24, X
    2580:	88 23       	and	r24, r24
    2582:	19 f0       	breq	.+6      	; 0x258a <xTaskGenericCreate+0x96>
    2584:	ae 16       	cp	r10, r30
    2586:	bf 06       	cpc	r11, r31
    2588:	a1 f7       	brne	.-24     	; 0x2572 <xTaskGenericCreate+0x7e>
    258a:	18 a2       	std	Y+32, r1	; 0x20
    258c:	10 2f       	mov	r17, r16
    258e:	06 30       	cpi	r16, 0x06	; 6
    2590:	08 f0       	brcs	.+2      	; 0x2594 <xTaskGenericCreate+0xa0>
    2592:	15 e0       	ldi	r17, 0x05	; 5
    2594:	1e 8b       	std	Y+22, r17	; 0x16
    2596:	19 a3       	std	Y+33, r17	; 0x21
    2598:	1a a2       	std	Y+34, r1	; 0x22
    259a:	5e 01       	movw	r10, r28
    259c:	b2 e0       	ldi	r27, 0x02	; 2
    259e:	ab 0e       	add	r10, r27
    25a0:	b1 1c       	adc	r11, r1
    25a2:	c5 01       	movw	r24, r10
    25a4:	0e 94 ca 08 	call	0x1194	; 0x1194 <vListInitialiseItem>
    25a8:	ce 01       	movw	r24, r28
    25aa:	0c 96       	adiw	r24, 0x0c	; 12
    25ac:	0e 94 ca 08 	call	0x1194	; 0x1194 <vListInitialiseItem>
    25b0:	d9 87       	std	Y+9, r29	; 0x09
    25b2:	c8 87       	std	Y+8, r28	; 0x08
    25b4:	86 e0       	ldi	r24, 0x06	; 6
    25b6:	90 e0       	ldi	r25, 0x00	; 0
    25b8:	81 1b       	sub	r24, r17
    25ba:	91 09       	sbc	r25, r1
    25bc:	9d 87       	std	Y+13, r25	; 0x0d
    25be:	8c 87       	std	Y+12, r24	; 0x0c
    25c0:	db 8b       	std	Y+19, r29	; 0x13
    25c2:	ca 8b       	std	Y+18, r28	; 0x12
    25c4:	1b a2       	std	Y+35, r1	; 0x23
    25c6:	1c a2       	std	Y+36, r1	; 0x24
    25c8:	1d a2       	std	Y+37, r1	; 0x25
    25ca:	1e a2       	std	Y+38, r1	; 0x26
    25cc:	1f a2       	std	Y+39, r1	; 0x27
    25ce:	a2 01       	movw	r20, r4
    25d0:	b3 01       	movw	r22, r6
    25d2:	c6 01       	movw	r24, r12
    25d4:	0c d8       	rcall	.-4072   	; 0x15ee <pxPortInitialiseStack>
    25d6:	99 83       	std	Y+1, r25	; 0x01
    25d8:	88 83       	st	Y, r24
    25da:	e1 14       	cp	r14, r1
    25dc:	f1 04       	cpc	r15, r1
    25de:	19 f0       	breq	.+6      	; 0x25e6 <xTaskGenericCreate+0xf2>
    25e0:	f7 01       	movw	r30, r14
    25e2:	d1 83       	std	Z+1, r29	; 0x01
    25e4:	c0 83       	st	Z, r28
    25e6:	0f b6       	in	r0, 0x3f	; 63
    25e8:	f8 94       	cli
    25ea:	0f 92       	push	r0
    25ec:	80 91 03 16 	lds	r24, 0x1603	; 0x801603 <uxCurrentNumberOfTasks>
    25f0:	8f 5f       	subi	r24, 0xFF	; 255
    25f2:	80 93 03 16 	sts	0x1603, r24	; 0x801603 <uxCurrentNumberOfTasks>
    25f6:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <pxCurrentTCB>
    25fa:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    25fe:	89 2b       	or	r24, r25
    2600:	d9 f5       	brne	.+118    	; 0x2678 <xTaskGenericCreate+0x184>
    2602:	d0 93 63 16 	sts	0x1663, r29	; 0x801663 <pxCurrentTCB+0x1>
    2606:	c0 93 62 16 	sts	0x1662, r28	; 0x801662 <pxCurrentTCB>
    260a:	80 91 03 16 	lds	r24, 0x1603	; 0x801603 <uxCurrentNumberOfTasks>
    260e:	81 30       	cpi	r24, 0x01	; 1
    2610:	09 f0       	breq	.+2      	; 0x2614 <xTaskGenericCreate+0x120>
    2612:	41 c0       	rjmp	.+130    	; 0x2696 <xTaskGenericCreate+0x1a2>
    2614:	0f 2e       	mov	r0, r31
    2616:	fc e2       	ldi	r31, 0x2C	; 44
    2618:	ef 2e       	mov	r14, r31
    261a:	f6 e1       	ldi	r31, 0x16	; 22
    261c:	ff 2e       	mov	r15, r31
    261e:	f0 2d       	mov	r31, r0
    2620:	0f 2e       	mov	r0, r31
    2622:	f2 e6       	ldi	r31, 0x62	; 98
    2624:	cf 2e       	mov	r12, r31
    2626:	f6 e1       	ldi	r31, 0x16	; 22
    2628:	df 2e       	mov	r13, r31
    262a:	f0 2d       	mov	r31, r0
    262c:	c7 01       	movw	r24, r14
    262e:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListInitialise>
    2632:	f9 e0       	ldi	r31, 0x09	; 9
    2634:	ef 0e       	add	r14, r31
    2636:	f1 1c       	adc	r15, r1
    2638:	ec 14       	cp	r14, r12
    263a:	fd 04       	cpc	r15, r13
    263c:	b9 f7       	brne	.-18     	; 0x262c <xTaskGenericCreate+0x138>
    263e:	83 e2       	ldi	r24, 0x23	; 35
    2640:	96 e1       	ldi	r25, 0x16	; 22
    2642:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListInitialise>
    2646:	8a e1       	ldi	r24, 0x1A	; 26
    2648:	96 e1       	ldi	r25, 0x16	; 22
    264a:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListInitialise>
    264e:	8d e0       	ldi	r24, 0x0D	; 13
    2650:	96 e1       	ldi	r25, 0x16	; 22
    2652:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListInitialise>
    2656:	84 e0       	ldi	r24, 0x04	; 4
    2658:	96 e1       	ldi	r25, 0x16	; 22
    265a:	0e 94 bc 08 	call	0x1178	; 0x1178 <vListInitialise>
    265e:	83 e2       	ldi	r24, 0x23	; 35
    2660:	96 e1       	ldi	r25, 0x16	; 22
    2662:	90 93 19 16 	sts	0x1619, r25	; 0x801619 <pxDelayedTaskList+0x1>
    2666:	80 93 18 16 	sts	0x1618, r24	; 0x801618 <pxDelayedTaskList>
    266a:	8a e1       	ldi	r24, 0x1A	; 26
    266c:	96 e1       	ldi	r25, 0x16	; 22
    266e:	90 93 17 16 	sts	0x1617, r25	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    2672:	80 93 16 16 	sts	0x1616, r24	; 0x801616 <pxOverflowDelayedTaskList>
    2676:	0f c0       	rjmp	.+30     	; 0x2696 <xTaskGenericCreate+0x1a2>
    2678:	80 91 ff 15 	lds	r24, 0x15FF	; 0x8015ff <xSchedulerRunning>
    267c:	81 11       	cpse	r24, r1
    267e:	0b c0       	rjmp	.+22     	; 0x2696 <xTaskGenericCreate+0x1a2>
    2680:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    2684:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2688:	86 89       	ldd	r24, Z+22	; 0x16
    268a:	08 17       	cp	r16, r24
    268c:	20 f0       	brcs	.+8      	; 0x2696 <xTaskGenericCreate+0x1a2>
    268e:	d0 93 63 16 	sts	0x1663, r29	; 0x801663 <pxCurrentTCB+0x1>
    2692:	c0 93 62 16 	sts	0x1662, r28	; 0x801662 <pxCurrentTCB>
    2696:	80 91 fb 15 	lds	r24, 0x15FB	; 0x8015fb <uxTaskNumber>
    269a:	8f 5f       	subi	r24, 0xFF	; 255
    269c:	80 93 fb 15 	sts	0x15FB, r24	; 0x8015fb <uxTaskNumber>
    26a0:	8e 89       	ldd	r24, Y+22	; 0x16
    26a2:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    26a6:	98 17       	cp	r25, r24
    26a8:	10 f4       	brcc	.+4      	; 0x26ae <xTaskGenericCreate+0x1ba>
    26aa:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    26ae:	90 e0       	ldi	r25, 0x00	; 0
    26b0:	9c 01       	movw	r18, r24
    26b2:	22 0f       	add	r18, r18
    26b4:	33 1f       	adc	r19, r19
    26b6:	22 0f       	add	r18, r18
    26b8:	33 1f       	adc	r19, r19
    26ba:	22 0f       	add	r18, r18
    26bc:	33 1f       	adc	r19, r19
    26be:	82 0f       	add	r24, r18
    26c0:	93 1f       	adc	r25, r19
    26c2:	b5 01       	movw	r22, r10
    26c4:	84 5d       	subi	r24, 0xD4	; 212
    26c6:	99 4e       	sbci	r25, 0xE9	; 233
    26c8:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    26cc:	0f 90       	pop	r0
    26ce:	0f be       	out	0x3f, r0	; 63
    26d0:	80 91 ff 15 	lds	r24, 0x15FF	; 0x8015ff <xSchedulerRunning>
    26d4:	88 23       	and	r24, r24
    26d6:	59 f0       	breq	.+22     	; 0x26ee <xTaskGenericCreate+0x1fa>
    26d8:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    26dc:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    26e0:	86 89       	ldd	r24, Z+22	; 0x16
    26e2:	80 17       	cp	r24, r16
    26e4:	30 f4       	brcc	.+12     	; 0x26f2 <xTaskGenericCreate+0x1fe>
    26e6:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vPortYield>
    26ea:	81 e0       	ldi	r24, 0x01	; 1
    26ec:	05 c0       	rjmp	.+10     	; 0x26f8 <xTaskGenericCreate+0x204>
    26ee:	81 e0       	ldi	r24, 0x01	; 1
    26f0:	03 c0       	rjmp	.+6      	; 0x26f8 <xTaskGenericCreate+0x204>
    26f2:	81 e0       	ldi	r24, 0x01	; 1
    26f4:	01 c0       	rjmp	.+2      	; 0x26f8 <xTaskGenericCreate+0x204>
    26f6:	8f ef       	ldi	r24, 0xFF	; 255
    26f8:	df 91       	pop	r29
    26fa:	cf 91       	pop	r28
    26fc:	1f 91       	pop	r17
    26fe:	0f 91       	pop	r16
    2700:	ff 90       	pop	r15
    2702:	ef 90       	pop	r14
    2704:	df 90       	pop	r13
    2706:	cf 90       	pop	r12
    2708:	bf 90       	pop	r11
    270a:	af 90       	pop	r10
    270c:	9f 90       	pop	r9
    270e:	8f 90       	pop	r8
    2710:	7f 90       	pop	r7
    2712:	6f 90       	pop	r6
    2714:	5f 90       	pop	r5
    2716:	4f 90       	pop	r4
    2718:	08 95       	ret

0000271a <vTaskDelay>:
    271a:	9f 92       	push	r9
    271c:	af 92       	push	r10
    271e:	bf 92       	push	r11
    2720:	cf 92       	push	r12
    2722:	df 92       	push	r13
    2724:	ef 92       	push	r14
    2726:	ff 92       	push	r15
    2728:	0f 93       	push	r16
    272a:	1f 93       	push	r17
    272c:	cf 93       	push	r28
    272e:	df 93       	push	r29
    2730:	00 97       	sbiw	r24, 0x00	; 0
    2732:	09 f4       	brne	.+2      	; 0x2736 <vTaskDelay+0x1c>
    2734:	63 c1       	rjmp	.+710    	; 0x29fc <vTaskDelay+0x2e2>
    2736:	20 91 f8 15 	lds	r18, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    273a:	2f 5f       	subi	r18, 0xFF	; 255
    273c:	20 93 f8 15 	sts	0x15F8, r18	; 0x8015f8 <uxSchedulerSuspended>
    2740:	c0 91 01 16 	lds	r28, 0x1601	; 0x801601 <xTickCount>
    2744:	d0 91 02 16 	lds	r29, 0x1602	; 0x801602 <xTickCount+0x1>
    2748:	c8 0f       	add	r28, r24
    274a:	d9 1f       	adc	r29, r25
    274c:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <pxCurrentTCB>
    2750:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2754:	02 96       	adiw	r24, 0x02	; 2
    2756:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    275a:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    275e:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2762:	d3 83       	std	Z+3, r29	; 0x03
    2764:	c2 83       	std	Z+2, r28	; 0x02
    2766:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    276a:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    276e:	c8 17       	cp	r28, r24
    2770:	d9 07       	cpc	r29, r25
    2772:	68 f4       	brcc	.+26     	; 0x278e <vTaskDelay+0x74>
    2774:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    2778:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    277c:	80 91 16 16 	lds	r24, 0x1616	; 0x801616 <pxOverflowDelayedTaskList>
    2780:	90 91 17 16 	lds	r25, 0x1617	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    2784:	6e 5f       	subi	r22, 0xFE	; 254
    2786:	7f 4f       	sbci	r23, 0xFF	; 255
    2788:	0e 94 ef 08 	call	0x11de	; 0x11de <vListInsert>
    278c:	17 c0       	rjmp	.+46     	; 0x27bc <vTaskDelay+0xa2>
    278e:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    2792:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2796:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <pxDelayedTaskList>
    279a:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    279e:	6e 5f       	subi	r22, 0xFE	; 254
    27a0:	7f 4f       	sbci	r23, 0xFF	; 255
    27a2:	0e 94 ef 08 	call	0x11de	; 0x11de <vListInsert>
    27a6:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xNextTaskUnblockTime>
    27aa:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <xNextTaskUnblockTime+0x1>
    27ae:	c8 17       	cp	r28, r24
    27b0:	d9 07       	cpc	r29, r25
    27b2:	20 f4       	brcc	.+8      	; 0x27bc <vTaskDelay+0xa2>
    27b4:	d0 93 fa 15 	sts	0x15FA, r29	; 0x8015fa <xNextTaskUnblockTime+0x1>
    27b8:	c0 93 f9 15 	sts	0x15F9, r28	; 0x8015f9 <xNextTaskUnblockTime>
    27bc:	0f b6       	in	r0, 0x3f	; 63
    27be:	f8 94       	cli
    27c0:	0f 92       	push	r0
    27c2:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    27c6:	81 50       	subi	r24, 0x01	; 1
    27c8:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxSchedulerSuspended>
    27cc:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    27d0:	81 11       	cpse	r24, r1
    27d2:	0d c1       	rjmp	.+538    	; 0x29ee <vTaskDelay+0x2d4>
    27d4:	80 91 03 16 	lds	r24, 0x1603	; 0x801603 <uxCurrentNumberOfTasks>
    27d8:	81 11       	cpse	r24, r1
    27da:	33 c0       	rjmp	.+102    	; 0x2842 <vTaskDelay+0x128>
    27dc:	0b c1       	rjmp	.+534    	; 0x29f4 <vTaskDelay+0x2da>
    27de:	d7 01       	movw	r26, r14
    27e0:	15 96       	adiw	r26, 0x05	; 5
    27e2:	ed 91       	ld	r30, X+
    27e4:	fc 91       	ld	r31, X
    27e6:	16 97       	sbiw	r26, 0x06	; 6
    27e8:	c6 81       	ldd	r28, Z+6	; 0x06
    27ea:	d7 81       	ldd	r29, Z+7	; 0x07
    27ec:	ce 01       	movw	r24, r28
    27ee:	0c 96       	adiw	r24, 0x0c	; 12
    27f0:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    27f4:	8e 01       	movw	r16, r28
    27f6:	0e 5f       	subi	r16, 0xFE	; 254
    27f8:	1f 4f       	sbci	r17, 0xFF	; 255
    27fa:	c8 01       	movw	r24, r16
    27fc:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2800:	8e 89       	ldd	r24, Y+22	; 0x16
    2802:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    2806:	98 17       	cp	r25, r24
    2808:	10 f4       	brcc	.+4      	; 0x280e <vTaskDelay+0xf4>
    280a:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    280e:	90 e0       	ldi	r25, 0x00	; 0
    2810:	9c 01       	movw	r18, r24
    2812:	22 0f       	add	r18, r18
    2814:	33 1f       	adc	r19, r19
    2816:	22 0f       	add	r18, r18
    2818:	33 1f       	adc	r19, r19
    281a:	22 0f       	add	r18, r18
    281c:	33 1f       	adc	r19, r19
    281e:	82 0f       	add	r24, r18
    2820:	93 1f       	adc	r25, r19
    2822:	b8 01       	movw	r22, r16
    2824:	84 5d       	subi	r24, 0xD4	; 212
    2826:	99 4e       	sbci	r25, 0xE9	; 233
    2828:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    282c:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    2830:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2834:	9e 89       	ldd	r25, Y+22	; 0x16
    2836:	86 89       	ldd	r24, Z+22	; 0x16
    2838:	98 17       	cp	r25, r24
    283a:	58 f0       	brcs	.+22     	; 0x2852 <vTaskDelay+0x138>
    283c:	d0 92 fd 15 	sts	0x15FD, r13	; 0x8015fd <xYieldPending>
    2840:	08 c0       	rjmp	.+16     	; 0x2852 <vTaskDelay+0x138>
    2842:	0f 2e       	mov	r0, r31
    2844:	fd e0       	ldi	r31, 0x0D	; 13
    2846:	ef 2e       	mov	r14, r31
    2848:	f6 e1       	ldi	r31, 0x16	; 22
    284a:	ff 2e       	mov	r15, r31
    284c:	f0 2d       	mov	r31, r0
    284e:	dd 24       	eor	r13, r13
    2850:	d3 94       	inc	r13
    2852:	f7 01       	movw	r30, r14
    2854:	80 81       	ld	r24, Z
    2856:	81 11       	cpse	r24, r1
    2858:	c2 cf       	rjmp	.-124    	; 0x27de <vTaskDelay+0xc4>
    285a:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    285e:	88 23       	and	r24, r24
    2860:	09 f4       	brne	.+2      	; 0x2864 <vTaskDelay+0x14a>
    2862:	bd c0       	rjmp	.+378    	; 0x29de <vTaskDelay+0x2c4>
    2864:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    2868:	88 23       	and	r24, r24
    286a:	09 f4       	brne	.+2      	; 0x286e <vTaskDelay+0x154>
    286c:	b8 c0       	rjmp	.+368    	; 0x29de <vTaskDelay+0x2c4>
    286e:	91 2c       	mov	r9, r1
    2870:	bb 24       	eor	r11, r11
    2872:	b3 94       	inc	r11
    2874:	cc 24       	eor	r12, r12
    2876:	ca 94       	dec	r12
    2878:	dc 2c       	mov	r13, r12
    287a:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    287e:	81 11       	cpse	r24, r1
    2880:	98 c0       	rjmp	.+304    	; 0x29b2 <vTaskDelay+0x298>
    2882:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    2886:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    288a:	01 96       	adiw	r24, 0x01	; 1
    288c:	90 93 02 16 	sts	0x1602, r25	; 0x801602 <xTickCount+0x1>
    2890:	80 93 01 16 	sts	0x1601, r24	; 0x801601 <xTickCount>
    2894:	e0 90 01 16 	lds	r14, 0x1601	; 0x801601 <xTickCount>
    2898:	f0 90 02 16 	lds	r15, 0x1602	; 0x801602 <xTickCount+0x1>
    289c:	e1 14       	cp	r14, r1
    289e:	f1 04       	cpc	r15, r1
    28a0:	89 f5       	brne	.+98     	; 0x2904 <vTaskDelay+0x1ea>
    28a2:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <pxDelayedTaskList>
    28a6:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    28aa:	20 91 16 16 	lds	r18, 0x1616	; 0x801616 <pxOverflowDelayedTaskList>
    28ae:	30 91 17 16 	lds	r19, 0x1617	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    28b2:	30 93 19 16 	sts	0x1619, r19	; 0x801619 <pxDelayedTaskList+0x1>
    28b6:	20 93 18 16 	sts	0x1618, r18	; 0x801618 <pxDelayedTaskList>
    28ba:	90 93 17 16 	sts	0x1617, r25	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    28be:	80 93 16 16 	sts	0x1616, r24	; 0x801616 <pxOverflowDelayedTaskList>
    28c2:	80 91 fc 15 	lds	r24, 0x15FC	; 0x8015fc <xNumOfOverflows>
    28c6:	8f 5f       	subi	r24, 0xFF	; 255
    28c8:	80 93 fc 15 	sts	0x15FC, r24	; 0x8015fc <xNumOfOverflows>
    28cc:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    28d0:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    28d4:	80 81       	ld	r24, Z
    28d6:	81 11       	cpse	r24, r1
    28d8:	05 c0       	rjmp	.+10     	; 0x28e4 <vTaskDelay+0x1ca>
    28da:	d0 92 fa 15 	sts	0x15FA, r13	; 0x8015fa <xNextTaskUnblockTime+0x1>
    28de:	c0 92 f9 15 	sts	0x15F9, r12	; 0x8015f9 <xNextTaskUnblockTime>
    28e2:	10 c0       	rjmp	.+32     	; 0x2904 <vTaskDelay+0x1ea>
    28e4:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    28e8:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    28ec:	05 80       	ldd	r0, Z+5	; 0x05
    28ee:	f6 81       	ldd	r31, Z+6	; 0x06
    28f0:	e0 2d       	mov	r30, r0
    28f2:	06 80       	ldd	r0, Z+6	; 0x06
    28f4:	f7 81       	ldd	r31, Z+7	; 0x07
    28f6:	e0 2d       	mov	r30, r0
    28f8:	82 81       	ldd	r24, Z+2	; 0x02
    28fa:	93 81       	ldd	r25, Z+3	; 0x03
    28fc:	90 93 fa 15 	sts	0x15FA, r25	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2900:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xNextTaskUnblockTime>
    2904:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xNextTaskUnblockTime>
    2908:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <xNextTaskUnblockTime+0x1>
    290c:	e8 16       	cp	r14, r24
    290e:	f9 06       	cpc	r15, r25
    2910:	08 f4       	brcc	.+2      	; 0x2914 <vTaskDelay+0x1fa>
    2912:	77 c0       	rjmp	.+238    	; 0x2a02 <vTaskDelay+0x2e8>
    2914:	a9 2c       	mov	r10, r9
    2916:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    291a:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    291e:	80 81       	ld	r24, Z
    2920:	81 11       	cpse	r24, r1
    2922:	05 c0       	rjmp	.+10     	; 0x292e <vTaskDelay+0x214>
    2924:	d0 92 fa 15 	sts	0x15FA, r13	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2928:	c0 92 f9 15 	sts	0x15F9, r12	; 0x8015f9 <xNextTaskUnblockTime>
    292c:	48 c0       	rjmp	.+144    	; 0x29be <vTaskDelay+0x2a4>
    292e:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2932:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2936:	05 80       	ldd	r0, Z+5	; 0x05
    2938:	f6 81       	ldd	r31, Z+6	; 0x06
    293a:	e0 2d       	mov	r30, r0
    293c:	c6 81       	ldd	r28, Z+6	; 0x06
    293e:	d7 81       	ldd	r29, Z+7	; 0x07
    2940:	8a 81       	ldd	r24, Y+2	; 0x02
    2942:	9b 81       	ldd	r25, Y+3	; 0x03
    2944:	e8 16       	cp	r14, r24
    2946:	f9 06       	cpc	r15, r25
    2948:	28 f4       	brcc	.+10     	; 0x2954 <vTaskDelay+0x23a>
    294a:	90 93 fa 15 	sts	0x15FA, r25	; 0x8015fa <xNextTaskUnblockTime+0x1>
    294e:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xNextTaskUnblockTime>
    2952:	35 c0       	rjmp	.+106    	; 0x29be <vTaskDelay+0x2a4>
    2954:	8e 01       	movw	r16, r28
    2956:	0e 5f       	subi	r16, 0xFE	; 254
    2958:	1f 4f       	sbci	r17, 0xFF	; 255
    295a:	c8 01       	movw	r24, r16
    295c:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2960:	8c 89       	ldd	r24, Y+20	; 0x14
    2962:	9d 89       	ldd	r25, Y+21	; 0x15
    2964:	89 2b       	or	r24, r25
    2966:	21 f0       	breq	.+8      	; 0x2970 <vTaskDelay+0x256>
    2968:	ce 01       	movw	r24, r28
    296a:	0c 96       	adiw	r24, 0x0c	; 12
    296c:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2970:	8e 89       	ldd	r24, Y+22	; 0x16
    2972:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    2976:	98 17       	cp	r25, r24
    2978:	10 f4       	brcc	.+4      	; 0x297e <vTaskDelay+0x264>
    297a:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    297e:	90 e0       	ldi	r25, 0x00	; 0
    2980:	9c 01       	movw	r18, r24
    2982:	22 0f       	add	r18, r18
    2984:	33 1f       	adc	r19, r19
    2986:	22 0f       	add	r18, r18
    2988:	33 1f       	adc	r19, r19
    298a:	22 0f       	add	r18, r18
    298c:	33 1f       	adc	r19, r19
    298e:	82 0f       	add	r24, r18
    2990:	93 1f       	adc	r25, r19
    2992:	b8 01       	movw	r22, r16
    2994:	84 5d       	subi	r24, 0xD4	; 212
    2996:	99 4e       	sbci	r25, 0xE9	; 233
    2998:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    299c:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    29a0:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    29a4:	9e 89       	ldd	r25, Y+22	; 0x16
    29a6:	86 89       	ldd	r24, Z+22	; 0x16
    29a8:	98 17       	cp	r25, r24
    29aa:	08 f4       	brcc	.+2      	; 0x29ae <vTaskDelay+0x294>
    29ac:	b4 cf       	rjmp	.-152    	; 0x2916 <vTaskDelay+0x1fc>
    29ae:	ab 2c       	mov	r10, r11
    29b0:	b2 cf       	rjmp	.-156    	; 0x2916 <vTaskDelay+0x1fc>
    29b2:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    29b6:	8f 5f       	subi	r24, 0xFF	; 255
    29b8:	80 93 fe 15 	sts	0x15FE, r24	; 0x8015fe <uxPendedTicks>
    29bc:	22 c0       	rjmp	.+68     	; 0x2a02 <vTaskDelay+0x2e8>
    29be:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <xYieldPending>
    29c2:	81 11       	cpse	r24, r1
    29c4:	01 c0       	rjmp	.+2      	; 0x29c8 <vTaskDelay+0x2ae>
    29c6:	a1 10       	cpse	r10, r1
    29c8:	b0 92 fd 15 	sts	0x15FD, r11	; 0x8015fd <xYieldPending>
    29cc:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    29d0:	81 50       	subi	r24, 0x01	; 1
    29d2:	80 93 fe 15 	sts	0x15FE, r24	; 0x8015fe <uxPendedTicks>
    29d6:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    29da:	81 11       	cpse	r24, r1
    29dc:	4e cf       	rjmp	.-356    	; 0x287a <vTaskDelay+0x160>
    29de:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <xYieldPending>
    29e2:	81 30       	cpi	r24, 0x01	; 1
    29e4:	31 f4       	brne	.+12     	; 0x29f2 <vTaskDelay+0x2d8>
    29e6:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vPortYield>
    29ea:	81 e0       	ldi	r24, 0x01	; 1
    29ec:	03 c0       	rjmp	.+6      	; 0x29f4 <vTaskDelay+0x2da>
    29ee:	80 e0       	ldi	r24, 0x00	; 0
    29f0:	01 c0       	rjmp	.+2      	; 0x29f4 <vTaskDelay+0x2da>
    29f2:	80 e0       	ldi	r24, 0x00	; 0
    29f4:	0f 90       	pop	r0
    29f6:	0f be       	out	0x3f, r0	; 63
    29f8:	81 11       	cpse	r24, r1
    29fa:	08 c0       	rjmp	.+16     	; 0x2a0c <vTaskDelay+0x2f2>
    29fc:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vPortYield>
    2a00:	05 c0       	rjmp	.+10     	; 0x2a0c <vTaskDelay+0x2f2>
    2a02:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <xYieldPending>
    2a06:	81 11       	cpse	r24, r1
    2a08:	df cf       	rjmp	.-66     	; 0x29c8 <vTaskDelay+0x2ae>
    2a0a:	e0 cf       	rjmp	.-64     	; 0x29cc <vTaskDelay+0x2b2>
    2a0c:	df 91       	pop	r29
    2a0e:	cf 91       	pop	r28
    2a10:	1f 91       	pop	r17
    2a12:	0f 91       	pop	r16
    2a14:	ff 90       	pop	r15
    2a16:	ef 90       	pop	r14
    2a18:	df 90       	pop	r13
    2a1a:	cf 90       	pop	r12
    2a1c:	bf 90       	pop	r11
    2a1e:	af 90       	pop	r10
    2a20:	9f 90       	pop	r9
    2a22:	08 95       	ret

00002a24 <vTaskSuspendAll>:
    2a24:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    2a28:	8f 5f       	subi	r24, 0xFF	; 255
    2a2a:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxSchedulerSuspended>
    2a2e:	08 95       	ret

00002a30 <xTaskResumeAll>:
    2a30:	9f 92       	push	r9
    2a32:	af 92       	push	r10
    2a34:	bf 92       	push	r11
    2a36:	cf 92       	push	r12
    2a38:	df 92       	push	r13
    2a3a:	ef 92       	push	r14
    2a3c:	ff 92       	push	r15
    2a3e:	0f 93       	push	r16
    2a40:	1f 93       	push	r17
    2a42:	cf 93       	push	r28
    2a44:	df 93       	push	r29
    2a46:	0f b6       	in	r0, 0x3f	; 63
    2a48:	f8 94       	cli
    2a4a:	0f 92       	push	r0
    2a4c:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    2a50:	81 50       	subi	r24, 0x01	; 1
    2a52:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <uxSchedulerSuspended>
    2a56:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    2a5a:	81 11       	cpse	r24, r1
    2a5c:	0d c1       	rjmp	.+538    	; 0x2c78 <xTaskResumeAll+0x248>
    2a5e:	80 91 03 16 	lds	r24, 0x1603	; 0x801603 <uxCurrentNumberOfTasks>
    2a62:	81 11       	cpse	r24, r1
    2a64:	33 c0       	rjmp	.+102    	; 0x2acc <xTaskResumeAll+0x9c>
    2a66:	0b c1       	rjmp	.+534    	; 0x2c7e <xTaskResumeAll+0x24e>
    2a68:	d7 01       	movw	r26, r14
    2a6a:	15 96       	adiw	r26, 0x05	; 5
    2a6c:	ed 91       	ld	r30, X+
    2a6e:	fc 91       	ld	r31, X
    2a70:	16 97       	sbiw	r26, 0x06	; 6
    2a72:	c6 81       	ldd	r28, Z+6	; 0x06
    2a74:	d7 81       	ldd	r29, Z+7	; 0x07
    2a76:	ce 01       	movw	r24, r28
    2a78:	0c 96       	adiw	r24, 0x0c	; 12
    2a7a:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2a7e:	8e 01       	movw	r16, r28
    2a80:	0e 5f       	subi	r16, 0xFE	; 254
    2a82:	1f 4f       	sbci	r17, 0xFF	; 255
    2a84:	c8 01       	movw	r24, r16
    2a86:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2a8a:	8e 89       	ldd	r24, Y+22	; 0x16
    2a8c:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    2a90:	98 17       	cp	r25, r24
    2a92:	10 f4       	brcc	.+4      	; 0x2a98 <xTaskResumeAll+0x68>
    2a94:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    2a98:	90 e0       	ldi	r25, 0x00	; 0
    2a9a:	9c 01       	movw	r18, r24
    2a9c:	22 0f       	add	r18, r18
    2a9e:	33 1f       	adc	r19, r19
    2aa0:	22 0f       	add	r18, r18
    2aa2:	33 1f       	adc	r19, r19
    2aa4:	22 0f       	add	r18, r18
    2aa6:	33 1f       	adc	r19, r19
    2aa8:	82 0f       	add	r24, r18
    2aaa:	93 1f       	adc	r25, r19
    2aac:	b8 01       	movw	r22, r16
    2aae:	84 5d       	subi	r24, 0xD4	; 212
    2ab0:	99 4e       	sbci	r25, 0xE9	; 233
    2ab2:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    2ab6:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    2aba:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2abe:	9e 89       	ldd	r25, Y+22	; 0x16
    2ac0:	86 89       	ldd	r24, Z+22	; 0x16
    2ac2:	98 17       	cp	r25, r24
    2ac4:	58 f0       	brcs	.+22     	; 0x2adc <xTaskResumeAll+0xac>
    2ac6:	d0 92 fd 15 	sts	0x15FD, r13	; 0x8015fd <xYieldPending>
    2aca:	08 c0       	rjmp	.+16     	; 0x2adc <xTaskResumeAll+0xac>
    2acc:	0f 2e       	mov	r0, r31
    2ace:	fd e0       	ldi	r31, 0x0D	; 13
    2ad0:	ef 2e       	mov	r14, r31
    2ad2:	f6 e1       	ldi	r31, 0x16	; 22
    2ad4:	ff 2e       	mov	r15, r31
    2ad6:	f0 2d       	mov	r31, r0
    2ad8:	dd 24       	eor	r13, r13
    2ada:	d3 94       	inc	r13
    2adc:	f7 01       	movw	r30, r14
    2ade:	80 81       	ld	r24, Z
    2ae0:	81 11       	cpse	r24, r1
    2ae2:	c2 cf       	rjmp	.-124    	; 0x2a68 <xTaskResumeAll+0x38>
    2ae4:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    2ae8:	88 23       	and	r24, r24
    2aea:	09 f4       	brne	.+2      	; 0x2aee <xTaskResumeAll+0xbe>
    2aec:	bd c0       	rjmp	.+378    	; 0x2c68 <xTaskResumeAll+0x238>
    2aee:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    2af2:	88 23       	and	r24, r24
    2af4:	09 f4       	brne	.+2      	; 0x2af8 <xTaskResumeAll+0xc8>
    2af6:	b8 c0       	rjmp	.+368    	; 0x2c68 <xTaskResumeAll+0x238>
    2af8:	91 2c       	mov	r9, r1
    2afa:	bb 24       	eor	r11, r11
    2afc:	b3 94       	inc	r11
    2afe:	cc 24       	eor	r12, r12
    2b00:	ca 94       	dec	r12
    2b02:	dc 2c       	mov	r13, r12
    2b04:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    2b08:	81 11       	cpse	r24, r1
    2b0a:	98 c0       	rjmp	.+304    	; 0x2c3c <xTaskResumeAll+0x20c>
    2b0c:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    2b10:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    2b14:	01 96       	adiw	r24, 0x01	; 1
    2b16:	90 93 02 16 	sts	0x1602, r25	; 0x801602 <xTickCount+0x1>
    2b1a:	80 93 01 16 	sts	0x1601, r24	; 0x801601 <xTickCount>
    2b1e:	e0 90 01 16 	lds	r14, 0x1601	; 0x801601 <xTickCount>
    2b22:	f0 90 02 16 	lds	r15, 0x1602	; 0x801602 <xTickCount+0x1>
    2b26:	e1 14       	cp	r14, r1
    2b28:	f1 04       	cpc	r15, r1
    2b2a:	89 f5       	brne	.+98     	; 0x2b8e <xTaskResumeAll+0x15e>
    2b2c:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <pxDelayedTaskList>
    2b30:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2b34:	20 91 16 16 	lds	r18, 0x1616	; 0x801616 <pxOverflowDelayedTaskList>
    2b38:	30 91 17 16 	lds	r19, 0x1617	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    2b3c:	30 93 19 16 	sts	0x1619, r19	; 0x801619 <pxDelayedTaskList+0x1>
    2b40:	20 93 18 16 	sts	0x1618, r18	; 0x801618 <pxDelayedTaskList>
    2b44:	90 93 17 16 	sts	0x1617, r25	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    2b48:	80 93 16 16 	sts	0x1616, r24	; 0x801616 <pxOverflowDelayedTaskList>
    2b4c:	80 91 fc 15 	lds	r24, 0x15FC	; 0x8015fc <xNumOfOverflows>
    2b50:	8f 5f       	subi	r24, 0xFF	; 255
    2b52:	80 93 fc 15 	sts	0x15FC, r24	; 0x8015fc <xNumOfOverflows>
    2b56:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2b5a:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2b5e:	80 81       	ld	r24, Z
    2b60:	81 11       	cpse	r24, r1
    2b62:	05 c0       	rjmp	.+10     	; 0x2b6e <xTaskResumeAll+0x13e>
    2b64:	d0 92 fa 15 	sts	0x15FA, r13	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2b68:	c0 92 f9 15 	sts	0x15F9, r12	; 0x8015f9 <xNextTaskUnblockTime>
    2b6c:	10 c0       	rjmp	.+32     	; 0x2b8e <xTaskResumeAll+0x15e>
    2b6e:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2b72:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2b76:	05 80       	ldd	r0, Z+5	; 0x05
    2b78:	f6 81       	ldd	r31, Z+6	; 0x06
    2b7a:	e0 2d       	mov	r30, r0
    2b7c:	06 80       	ldd	r0, Z+6	; 0x06
    2b7e:	f7 81       	ldd	r31, Z+7	; 0x07
    2b80:	e0 2d       	mov	r30, r0
    2b82:	82 81       	ldd	r24, Z+2	; 0x02
    2b84:	93 81       	ldd	r25, Z+3	; 0x03
    2b86:	90 93 fa 15 	sts	0x15FA, r25	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2b8a:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xNextTaskUnblockTime>
    2b8e:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xNextTaskUnblockTime>
    2b92:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2b96:	e8 16       	cp	r14, r24
    2b98:	f9 06       	cpc	r15, r25
    2b9a:	08 f4       	brcc	.+2      	; 0x2b9e <xTaskResumeAll+0x16e>
    2b9c:	73 c0       	rjmp	.+230    	; 0x2c84 <xTaskResumeAll+0x254>
    2b9e:	a9 2c       	mov	r10, r9
    2ba0:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2ba4:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2ba8:	80 81       	ld	r24, Z
    2baa:	81 11       	cpse	r24, r1
    2bac:	05 c0       	rjmp	.+10     	; 0x2bb8 <xTaskResumeAll+0x188>
    2bae:	d0 92 fa 15 	sts	0x15FA, r13	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2bb2:	c0 92 f9 15 	sts	0x15F9, r12	; 0x8015f9 <xNextTaskUnblockTime>
    2bb6:	48 c0       	rjmp	.+144    	; 0x2c48 <xTaskResumeAll+0x218>
    2bb8:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2bbc:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2bc0:	05 80       	ldd	r0, Z+5	; 0x05
    2bc2:	f6 81       	ldd	r31, Z+6	; 0x06
    2bc4:	e0 2d       	mov	r30, r0
    2bc6:	c6 81       	ldd	r28, Z+6	; 0x06
    2bc8:	d7 81       	ldd	r29, Z+7	; 0x07
    2bca:	8a 81       	ldd	r24, Y+2	; 0x02
    2bcc:	9b 81       	ldd	r25, Y+3	; 0x03
    2bce:	e8 16       	cp	r14, r24
    2bd0:	f9 06       	cpc	r15, r25
    2bd2:	28 f4       	brcc	.+10     	; 0x2bde <xTaskResumeAll+0x1ae>
    2bd4:	90 93 fa 15 	sts	0x15FA, r25	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2bd8:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xNextTaskUnblockTime>
    2bdc:	35 c0       	rjmp	.+106    	; 0x2c48 <xTaskResumeAll+0x218>
    2bde:	8e 01       	movw	r16, r28
    2be0:	0e 5f       	subi	r16, 0xFE	; 254
    2be2:	1f 4f       	sbci	r17, 0xFF	; 255
    2be4:	c8 01       	movw	r24, r16
    2be6:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2bea:	8c 89       	ldd	r24, Y+20	; 0x14
    2bec:	9d 89       	ldd	r25, Y+21	; 0x15
    2bee:	89 2b       	or	r24, r25
    2bf0:	21 f0       	breq	.+8      	; 0x2bfa <xTaskResumeAll+0x1ca>
    2bf2:	ce 01       	movw	r24, r28
    2bf4:	0c 96       	adiw	r24, 0x0c	; 12
    2bf6:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2bfa:	8e 89       	ldd	r24, Y+22	; 0x16
    2bfc:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    2c00:	98 17       	cp	r25, r24
    2c02:	10 f4       	brcc	.+4      	; 0x2c08 <xTaskResumeAll+0x1d8>
    2c04:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    2c08:	90 e0       	ldi	r25, 0x00	; 0
    2c0a:	9c 01       	movw	r18, r24
    2c0c:	22 0f       	add	r18, r18
    2c0e:	33 1f       	adc	r19, r19
    2c10:	22 0f       	add	r18, r18
    2c12:	33 1f       	adc	r19, r19
    2c14:	22 0f       	add	r18, r18
    2c16:	33 1f       	adc	r19, r19
    2c18:	82 0f       	add	r24, r18
    2c1a:	93 1f       	adc	r25, r19
    2c1c:	b8 01       	movw	r22, r16
    2c1e:	84 5d       	subi	r24, 0xD4	; 212
    2c20:	99 4e       	sbci	r25, 0xE9	; 233
    2c22:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    2c26:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    2c2a:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2c2e:	9e 89       	ldd	r25, Y+22	; 0x16
    2c30:	86 89       	ldd	r24, Z+22	; 0x16
    2c32:	98 17       	cp	r25, r24
    2c34:	08 f4       	brcc	.+2      	; 0x2c38 <xTaskResumeAll+0x208>
    2c36:	b4 cf       	rjmp	.-152    	; 0x2ba0 <xTaskResumeAll+0x170>
    2c38:	ab 2c       	mov	r10, r11
    2c3a:	b2 cf       	rjmp	.-156    	; 0x2ba0 <xTaskResumeAll+0x170>
    2c3c:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    2c40:	8f 5f       	subi	r24, 0xFF	; 255
    2c42:	80 93 fe 15 	sts	0x15FE, r24	; 0x8015fe <uxPendedTicks>
    2c46:	1e c0       	rjmp	.+60     	; 0x2c84 <xTaskResumeAll+0x254>
    2c48:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <xYieldPending>
    2c4c:	81 11       	cpse	r24, r1
    2c4e:	01 c0       	rjmp	.+2      	; 0x2c52 <xTaskResumeAll+0x222>
    2c50:	a1 10       	cpse	r10, r1
    2c52:	b0 92 fd 15 	sts	0x15FD, r11	; 0x8015fd <xYieldPending>
    2c56:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    2c5a:	81 50       	subi	r24, 0x01	; 1
    2c5c:	80 93 fe 15 	sts	0x15FE, r24	; 0x8015fe <uxPendedTicks>
    2c60:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    2c64:	81 11       	cpse	r24, r1
    2c66:	4e cf       	rjmp	.-356    	; 0x2b04 <xTaskResumeAll+0xd4>
    2c68:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <xYieldPending>
    2c6c:	81 30       	cpi	r24, 0x01	; 1
    2c6e:	31 f4       	brne	.+12     	; 0x2c7c <xTaskResumeAll+0x24c>
    2c70:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vPortYield>
    2c74:	81 e0       	ldi	r24, 0x01	; 1
    2c76:	03 c0       	rjmp	.+6      	; 0x2c7e <xTaskResumeAll+0x24e>
    2c78:	80 e0       	ldi	r24, 0x00	; 0
    2c7a:	01 c0       	rjmp	.+2      	; 0x2c7e <xTaskResumeAll+0x24e>
    2c7c:	80 e0       	ldi	r24, 0x00	; 0
    2c7e:	0f 90       	pop	r0
    2c80:	0f be       	out	0x3f, r0	; 63
    2c82:	05 c0       	rjmp	.+10     	; 0x2c8e <xTaskResumeAll+0x25e>
    2c84:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <xYieldPending>
    2c88:	81 11       	cpse	r24, r1
    2c8a:	e3 cf       	rjmp	.-58     	; 0x2c52 <xTaskResumeAll+0x222>
    2c8c:	e4 cf       	rjmp	.-56     	; 0x2c56 <xTaskResumeAll+0x226>
    2c8e:	df 91       	pop	r29
    2c90:	cf 91       	pop	r28
    2c92:	1f 91       	pop	r17
    2c94:	0f 91       	pop	r16
    2c96:	ff 90       	pop	r15
    2c98:	ef 90       	pop	r14
    2c9a:	df 90       	pop	r13
    2c9c:	cf 90       	pop	r12
    2c9e:	bf 90       	pop	r11
    2ca0:	af 90       	pop	r10
    2ca2:	9f 90       	pop	r9
    2ca4:	08 95       	ret

00002ca6 <xTaskIncrementTick>:
    2ca6:	cf 92       	push	r12
    2ca8:	df 92       	push	r13
    2caa:	ef 92       	push	r14
    2cac:	ff 92       	push	r15
    2cae:	0f 93       	push	r16
    2cb0:	1f 93       	push	r17
    2cb2:	cf 93       	push	r28
    2cb4:	df 93       	push	r29
    2cb6:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    2cba:	81 11       	cpse	r24, r1
    2cbc:	9f c0       	rjmp	.+318    	; 0x2dfc <xTaskIncrementTick+0x156>
    2cbe:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    2cc2:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    2cc6:	01 96       	adiw	r24, 0x01	; 1
    2cc8:	90 93 02 16 	sts	0x1602, r25	; 0x801602 <xTickCount+0x1>
    2ccc:	80 93 01 16 	sts	0x1601, r24	; 0x801601 <xTickCount>
    2cd0:	e0 90 01 16 	lds	r14, 0x1601	; 0x801601 <xTickCount>
    2cd4:	f0 90 02 16 	lds	r15, 0x1602	; 0x801602 <xTickCount+0x1>
    2cd8:	e1 14       	cp	r14, r1
    2cda:	f1 04       	cpc	r15, r1
    2cdc:	99 f5       	brne	.+102    	; 0x2d44 <xTaskIncrementTick+0x9e>
    2cde:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <pxDelayedTaskList>
    2ce2:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2ce6:	20 91 16 16 	lds	r18, 0x1616	; 0x801616 <pxOverflowDelayedTaskList>
    2cea:	30 91 17 16 	lds	r19, 0x1617	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    2cee:	30 93 19 16 	sts	0x1619, r19	; 0x801619 <pxDelayedTaskList+0x1>
    2cf2:	20 93 18 16 	sts	0x1618, r18	; 0x801618 <pxDelayedTaskList>
    2cf6:	90 93 17 16 	sts	0x1617, r25	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    2cfa:	80 93 16 16 	sts	0x1616, r24	; 0x801616 <pxOverflowDelayedTaskList>
    2cfe:	80 91 fc 15 	lds	r24, 0x15FC	; 0x8015fc <xNumOfOverflows>
    2d02:	8f 5f       	subi	r24, 0xFF	; 255
    2d04:	80 93 fc 15 	sts	0x15FC, r24	; 0x8015fc <xNumOfOverflows>
    2d08:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2d0c:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2d10:	80 81       	ld	r24, Z
    2d12:	81 11       	cpse	r24, r1
    2d14:	07 c0       	rjmp	.+14     	; 0x2d24 <xTaskIncrementTick+0x7e>
    2d16:	8f ef       	ldi	r24, 0xFF	; 255
    2d18:	9f ef       	ldi	r25, 0xFF	; 255
    2d1a:	90 93 fa 15 	sts	0x15FA, r25	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2d1e:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xNextTaskUnblockTime>
    2d22:	10 c0       	rjmp	.+32     	; 0x2d44 <xTaskIncrementTick+0x9e>
    2d24:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2d28:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2d2c:	05 80       	ldd	r0, Z+5	; 0x05
    2d2e:	f6 81       	ldd	r31, Z+6	; 0x06
    2d30:	e0 2d       	mov	r30, r0
    2d32:	06 80       	ldd	r0, Z+6	; 0x06
    2d34:	f7 81       	ldd	r31, Z+7	; 0x07
    2d36:	e0 2d       	mov	r30, r0
    2d38:	82 81       	ldd	r24, Z+2	; 0x02
    2d3a:	93 81       	ldd	r25, Z+3	; 0x03
    2d3c:	90 93 fa 15 	sts	0x15FA, r25	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2d40:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xNextTaskUnblockTime>
    2d44:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xNextTaskUnblockTime>
    2d48:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2d4c:	e8 16       	cp	r14, r24
    2d4e:	f9 06       	cpc	r15, r25
    2d50:	10 f4       	brcc	.+4      	; 0x2d56 <xTaskIncrementTick+0xb0>
    2d52:	d1 2c       	mov	r13, r1
    2d54:	59 c0       	rjmp	.+178    	; 0x2e08 <xTaskIncrementTick+0x162>
    2d56:	d1 2c       	mov	r13, r1
    2d58:	cc 24       	eor	r12, r12
    2d5a:	c3 94       	inc	r12
    2d5c:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2d60:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2d64:	80 81       	ld	r24, Z
    2d66:	81 11       	cpse	r24, r1
    2d68:	07 c0       	rjmp	.+14     	; 0x2d78 <xTaskIncrementTick+0xd2>
    2d6a:	8f ef       	ldi	r24, 0xFF	; 255
    2d6c:	9f ef       	ldi	r25, 0xFF	; 255
    2d6e:	90 93 fa 15 	sts	0x15FA, r25	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2d72:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xNextTaskUnblockTime>
    2d76:	48 c0       	rjmp	.+144    	; 0x2e08 <xTaskIncrementTick+0x162>
    2d78:	e0 91 18 16 	lds	r30, 0x1618	; 0x801618 <pxDelayedTaskList>
    2d7c:	f0 91 19 16 	lds	r31, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2d80:	05 80       	ldd	r0, Z+5	; 0x05
    2d82:	f6 81       	ldd	r31, Z+6	; 0x06
    2d84:	e0 2d       	mov	r30, r0
    2d86:	c6 81       	ldd	r28, Z+6	; 0x06
    2d88:	d7 81       	ldd	r29, Z+7	; 0x07
    2d8a:	8a 81       	ldd	r24, Y+2	; 0x02
    2d8c:	9b 81       	ldd	r25, Y+3	; 0x03
    2d8e:	e8 16       	cp	r14, r24
    2d90:	f9 06       	cpc	r15, r25
    2d92:	28 f4       	brcc	.+10     	; 0x2d9e <xTaskIncrementTick+0xf8>
    2d94:	90 93 fa 15 	sts	0x15FA, r25	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2d98:	80 93 f9 15 	sts	0x15F9, r24	; 0x8015f9 <xNextTaskUnblockTime>
    2d9c:	35 c0       	rjmp	.+106    	; 0x2e08 <xTaskIncrementTick+0x162>
    2d9e:	8e 01       	movw	r16, r28
    2da0:	0e 5f       	subi	r16, 0xFE	; 254
    2da2:	1f 4f       	sbci	r17, 0xFF	; 255
    2da4:	c8 01       	movw	r24, r16
    2da6:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2daa:	8c 89       	ldd	r24, Y+20	; 0x14
    2dac:	9d 89       	ldd	r25, Y+21	; 0x15
    2dae:	89 2b       	or	r24, r25
    2db0:	21 f0       	breq	.+8      	; 0x2dba <xTaskIncrementTick+0x114>
    2db2:	ce 01       	movw	r24, r28
    2db4:	0c 96       	adiw	r24, 0x0c	; 12
    2db6:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2dba:	8e 89       	ldd	r24, Y+22	; 0x16
    2dbc:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    2dc0:	98 17       	cp	r25, r24
    2dc2:	10 f4       	brcc	.+4      	; 0x2dc8 <xTaskIncrementTick+0x122>
    2dc4:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    2dc8:	90 e0       	ldi	r25, 0x00	; 0
    2dca:	9c 01       	movw	r18, r24
    2dcc:	22 0f       	add	r18, r18
    2dce:	33 1f       	adc	r19, r19
    2dd0:	22 0f       	add	r18, r18
    2dd2:	33 1f       	adc	r19, r19
    2dd4:	22 0f       	add	r18, r18
    2dd6:	33 1f       	adc	r19, r19
    2dd8:	82 0f       	add	r24, r18
    2dda:	93 1f       	adc	r25, r19
    2ddc:	b8 01       	movw	r22, r16
    2dde:	84 5d       	subi	r24, 0xD4	; 212
    2de0:	99 4e       	sbci	r25, 0xE9	; 233
    2de2:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    2de6:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    2dea:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2dee:	9e 89       	ldd	r25, Y+22	; 0x16
    2df0:	86 89       	ldd	r24, Z+22	; 0x16
    2df2:	98 17       	cp	r25, r24
    2df4:	08 f4       	brcc	.+2      	; 0x2df8 <xTaskIncrementTick+0x152>
    2df6:	b2 cf       	rjmp	.-156    	; 0x2d5c <xTaskIncrementTick+0xb6>
    2df8:	dc 2c       	mov	r13, r12
    2dfa:	b0 cf       	rjmp	.-160    	; 0x2d5c <xTaskIncrementTick+0xb6>
    2dfc:	80 91 fe 15 	lds	r24, 0x15FE	; 0x8015fe <uxPendedTicks>
    2e00:	8f 5f       	subi	r24, 0xFF	; 255
    2e02:	80 93 fe 15 	sts	0x15FE, r24	; 0x8015fe <uxPendedTicks>
    2e06:	d1 2c       	mov	r13, r1
    2e08:	80 91 fd 15 	lds	r24, 0x15FD	; 0x8015fd <xYieldPending>
    2e0c:	88 23       	and	r24, r24
    2e0e:	11 f0       	breq	.+4      	; 0x2e14 <xTaskIncrementTick+0x16e>
    2e10:	dd 24       	eor	r13, r13
    2e12:	d3 94       	inc	r13
    2e14:	8d 2d       	mov	r24, r13
    2e16:	df 91       	pop	r29
    2e18:	cf 91       	pop	r28
    2e1a:	1f 91       	pop	r17
    2e1c:	0f 91       	pop	r16
    2e1e:	ff 90       	pop	r15
    2e20:	ef 90       	pop	r14
    2e22:	df 90       	pop	r13
    2e24:	cf 90       	pop	r12
    2e26:	08 95       	ret

00002e28 <vTaskSwitchContext>:
    2e28:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    2e2c:	88 23       	and	r24, r24
    2e2e:	21 f0       	breq	.+8      	; 0x2e38 <vTaskSwitchContext+0x10>
    2e30:	81 e0       	ldi	r24, 0x01	; 1
    2e32:	80 93 fd 15 	sts	0x15FD, r24	; 0x8015fd <xYieldPending>
    2e36:	08 95       	ret
    2e38:	10 92 fd 15 	sts	0x15FD, r1	; 0x8015fd <xYieldPending>
    2e3c:	a0 91 62 16 	lds	r26, 0x1662	; 0x801662 <pxCurrentTCB>
    2e40:	b0 91 63 16 	lds	r27, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2e44:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    2e48:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2e4c:	2d 91       	ld	r18, X+
    2e4e:	3c 91       	ld	r19, X
    2e50:	87 89       	ldd	r24, Z+23	; 0x17
    2e52:	90 8d       	ldd	r25, Z+24	; 0x18
    2e54:	82 17       	cp	r24, r18
    2e56:	93 07       	cpc	r25, r19
    2e58:	60 f0       	brcs	.+24     	; 0x2e72 <vTaskSwitchContext+0x4a>
    2e5a:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    2e5e:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2e62:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <pxCurrentTCB>
    2e66:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2e6a:	67 5e       	subi	r22, 0xE7	; 231
    2e6c:	7f 4f       	sbci	r23, 0xFF	; 255
    2e6e:	0e 94 46 09 	call	0x128c	; 0x128c <vApplicationStackOverflowHook>
    2e72:	80 91 00 16 	lds	r24, 0x1600	; 0x801600 <uxTopReadyPriority>
    2e76:	90 e0       	ldi	r25, 0x00	; 0
    2e78:	fc 01       	movw	r30, r24
    2e7a:	ee 0f       	add	r30, r30
    2e7c:	ff 1f       	adc	r31, r31
    2e7e:	ee 0f       	add	r30, r30
    2e80:	ff 1f       	adc	r31, r31
    2e82:	ee 0f       	add	r30, r30
    2e84:	ff 1f       	adc	r31, r31
    2e86:	8e 0f       	add	r24, r30
    2e88:	9f 1f       	adc	r25, r31
    2e8a:	fc 01       	movw	r30, r24
    2e8c:	e4 5d       	subi	r30, 0xD4	; 212
    2e8e:	f9 4e       	sbci	r31, 0xE9	; 233
    2e90:	80 81       	ld	r24, Z
    2e92:	81 11       	cpse	r24, r1
    2e94:	17 c0       	rjmp	.+46     	; 0x2ec4 <vTaskSwitchContext+0x9c>
    2e96:	80 91 00 16 	lds	r24, 0x1600	; 0x801600 <uxTopReadyPriority>
    2e9a:	81 50       	subi	r24, 0x01	; 1
    2e9c:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    2ea0:	80 91 00 16 	lds	r24, 0x1600	; 0x801600 <uxTopReadyPriority>
    2ea4:	90 e0       	ldi	r25, 0x00	; 0
    2ea6:	fc 01       	movw	r30, r24
    2ea8:	ee 0f       	add	r30, r30
    2eaa:	ff 1f       	adc	r31, r31
    2eac:	ee 0f       	add	r30, r30
    2eae:	ff 1f       	adc	r31, r31
    2eb0:	ee 0f       	add	r30, r30
    2eb2:	ff 1f       	adc	r31, r31
    2eb4:	8e 0f       	add	r24, r30
    2eb6:	9f 1f       	adc	r25, r31
    2eb8:	fc 01       	movw	r30, r24
    2eba:	e4 5d       	subi	r30, 0xD4	; 212
    2ebc:	f9 4e       	sbci	r31, 0xE9	; 233
    2ebe:	80 81       	ld	r24, Z
    2ec0:	88 23       	and	r24, r24
    2ec2:	49 f3       	breq	.-46     	; 0x2e96 <vTaskSwitchContext+0x6e>
    2ec4:	80 91 00 16 	lds	r24, 0x1600	; 0x801600 <uxTopReadyPriority>
    2ec8:	90 e0       	ldi	r25, 0x00	; 0
    2eca:	9c 01       	movw	r18, r24
    2ecc:	22 0f       	add	r18, r18
    2ece:	33 1f       	adc	r19, r19
    2ed0:	22 0f       	add	r18, r18
    2ed2:	33 1f       	adc	r19, r19
    2ed4:	22 0f       	add	r18, r18
    2ed6:	33 1f       	adc	r19, r19
    2ed8:	28 0f       	add	r18, r24
    2eda:	39 1f       	adc	r19, r25
    2edc:	d9 01       	movw	r26, r18
    2ede:	a4 5d       	subi	r26, 0xD4	; 212
    2ee0:	b9 4e       	sbci	r27, 0xE9	; 233
    2ee2:	11 96       	adiw	r26, 0x01	; 1
    2ee4:	ed 91       	ld	r30, X+
    2ee6:	fc 91       	ld	r31, X
    2ee8:	12 97       	sbiw	r26, 0x02	; 2
    2eea:	02 80       	ldd	r0, Z+2	; 0x02
    2eec:	f3 81       	ldd	r31, Z+3	; 0x03
    2eee:	e0 2d       	mov	r30, r0
    2ef0:	12 96       	adiw	r26, 0x02	; 2
    2ef2:	fc 93       	st	X, r31
    2ef4:	ee 93       	st	-X, r30
    2ef6:	11 97       	sbiw	r26, 0x01	; 1
    2ef8:	21 5d       	subi	r18, 0xD1	; 209
    2efa:	39 4e       	sbci	r19, 0xE9	; 233
    2efc:	e2 17       	cp	r30, r18
    2efe:	f3 07       	cpc	r31, r19
    2f00:	29 f4       	brne	.+10     	; 0x2f0c <vTaskSwitchContext+0xe4>
    2f02:	22 81       	ldd	r18, Z+2	; 0x02
    2f04:	33 81       	ldd	r19, Z+3	; 0x03
    2f06:	fd 01       	movw	r30, r26
    2f08:	32 83       	std	Z+2, r19	; 0x02
    2f0a:	21 83       	std	Z+1, r18	; 0x01
    2f0c:	fc 01       	movw	r30, r24
    2f0e:	ee 0f       	add	r30, r30
    2f10:	ff 1f       	adc	r31, r31
    2f12:	ee 0f       	add	r30, r30
    2f14:	ff 1f       	adc	r31, r31
    2f16:	ee 0f       	add	r30, r30
    2f18:	ff 1f       	adc	r31, r31
    2f1a:	8e 0f       	add	r24, r30
    2f1c:	9f 1f       	adc	r25, r31
    2f1e:	fc 01       	movw	r30, r24
    2f20:	e4 5d       	subi	r30, 0xD4	; 212
    2f22:	f9 4e       	sbci	r31, 0xE9	; 233
    2f24:	01 80       	ldd	r0, Z+1	; 0x01
    2f26:	f2 81       	ldd	r31, Z+2	; 0x02
    2f28:	e0 2d       	mov	r30, r0
    2f2a:	86 81       	ldd	r24, Z+6	; 0x06
    2f2c:	97 81       	ldd	r25, Z+7	; 0x07
    2f2e:	90 93 63 16 	sts	0x1663, r25	; 0x801663 <pxCurrentTCB+0x1>
    2f32:	80 93 62 16 	sts	0x1662, r24	; 0x801662 <pxCurrentTCB>
    2f36:	08 95       	ret

00002f38 <vTaskPlaceOnEventList>:
    2f38:	cf 93       	push	r28
    2f3a:	df 93       	push	r29
    2f3c:	eb 01       	movw	r28, r22
    2f3e:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    2f42:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2f46:	64 5f       	subi	r22, 0xF4	; 244
    2f48:	7f 4f       	sbci	r23, 0xFF	; 255
    2f4a:	0e 94 ef 08 	call	0x11de	; 0x11de <vListInsert>
    2f4e:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <pxCurrentTCB>
    2f52:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2f56:	02 96       	adiw	r24, 0x02	; 2
    2f58:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    2f5c:	cf 3f       	cpi	r28, 0xFF	; 255
    2f5e:	8f ef       	ldi	r24, 0xFF	; 255
    2f60:	d8 07       	cpc	r29, r24
    2f62:	59 f4       	brne	.+22     	; 0x2f7a <vTaskPlaceOnEventList+0x42>
    2f64:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    2f68:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2f6c:	6e 5f       	subi	r22, 0xFE	; 254
    2f6e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f70:	84 e0       	ldi	r24, 0x04	; 4
    2f72:	96 e1       	ldi	r25, 0x16	; 22
    2f74:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    2f78:	37 c0       	rjmp	.+110    	; 0x2fe8 <vTaskPlaceOnEventList+0xb0>
    2f7a:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    2f7e:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    2f82:	c8 0f       	add	r28, r24
    2f84:	d9 1f       	adc	r29, r25
    2f86:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    2f8a:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2f8e:	d3 83       	std	Z+3, r29	; 0x03
    2f90:	c2 83       	std	Z+2, r28	; 0x02
    2f92:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    2f96:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    2f9a:	c8 17       	cp	r28, r24
    2f9c:	d9 07       	cpc	r29, r25
    2f9e:	68 f4       	brcc	.+26     	; 0x2fba <vTaskPlaceOnEventList+0x82>
    2fa0:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    2fa4:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2fa8:	80 91 16 16 	lds	r24, 0x1616	; 0x801616 <pxOverflowDelayedTaskList>
    2fac:	90 91 17 16 	lds	r25, 0x1617	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    2fb0:	6e 5f       	subi	r22, 0xFE	; 254
    2fb2:	7f 4f       	sbci	r23, 0xFF	; 255
    2fb4:	0e 94 ef 08 	call	0x11de	; 0x11de <vListInsert>
    2fb8:	17 c0       	rjmp	.+46     	; 0x2fe8 <vTaskPlaceOnEventList+0xb0>
    2fba:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    2fbe:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    2fc2:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <pxDelayedTaskList>
    2fc6:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    2fca:	6e 5f       	subi	r22, 0xFE	; 254
    2fcc:	7f 4f       	sbci	r23, 0xFF	; 255
    2fce:	0e 94 ef 08 	call	0x11de	; 0x11de <vListInsert>
    2fd2:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xNextTaskUnblockTime>
    2fd6:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2fda:	c8 17       	cp	r28, r24
    2fdc:	d9 07       	cpc	r29, r25
    2fde:	20 f4       	brcc	.+8      	; 0x2fe8 <vTaskPlaceOnEventList+0xb0>
    2fe0:	d0 93 fa 15 	sts	0x15FA, r29	; 0x8015fa <xNextTaskUnblockTime+0x1>
    2fe4:	c0 93 f9 15 	sts	0x15F9, r28	; 0x8015f9 <xNextTaskUnblockTime>
    2fe8:	df 91       	pop	r29
    2fea:	cf 91       	pop	r28
    2fec:	08 95       	ret

00002fee <xTaskRemoveFromEventList>:
    2fee:	0f 93       	push	r16
    2ff0:	1f 93       	push	r17
    2ff2:	cf 93       	push	r28
    2ff4:	df 93       	push	r29
    2ff6:	dc 01       	movw	r26, r24
    2ff8:	15 96       	adiw	r26, 0x05	; 5
    2ffa:	ed 91       	ld	r30, X+
    2ffc:	fc 91       	ld	r31, X
    2ffe:	16 97       	sbiw	r26, 0x06	; 6
    3000:	c6 81       	ldd	r28, Z+6	; 0x06
    3002:	d7 81       	ldd	r29, Z+7	; 0x07
    3004:	8e 01       	movw	r16, r28
    3006:	04 5f       	subi	r16, 0xF4	; 244
    3008:	1f 4f       	sbci	r17, 0xFF	; 255
    300a:	c8 01       	movw	r24, r16
    300c:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    3010:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    3014:	81 11       	cpse	r24, r1
    3016:	1c c0       	rjmp	.+56     	; 0x3050 <xTaskRemoveFromEventList+0x62>
    3018:	0a 50       	subi	r16, 0x0A	; 10
    301a:	11 09       	sbc	r17, r1
    301c:	c8 01       	movw	r24, r16
    301e:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    3022:	8e 89       	ldd	r24, Y+22	; 0x16
    3024:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    3028:	98 17       	cp	r25, r24
    302a:	10 f4       	brcc	.+4      	; 0x3030 <xTaskRemoveFromEventList+0x42>
    302c:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    3030:	90 e0       	ldi	r25, 0x00	; 0
    3032:	9c 01       	movw	r18, r24
    3034:	22 0f       	add	r18, r18
    3036:	33 1f       	adc	r19, r19
    3038:	22 0f       	add	r18, r18
    303a:	33 1f       	adc	r19, r19
    303c:	22 0f       	add	r18, r18
    303e:	33 1f       	adc	r19, r19
    3040:	82 0f       	add	r24, r18
    3042:	93 1f       	adc	r25, r19
    3044:	b8 01       	movw	r22, r16
    3046:	84 5d       	subi	r24, 0xD4	; 212
    3048:	99 4e       	sbci	r25, 0xE9	; 233
    304a:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    304e:	05 c0       	rjmp	.+10     	; 0x305a <xTaskRemoveFromEventList+0x6c>
    3050:	b8 01       	movw	r22, r16
    3052:	8d e0       	ldi	r24, 0x0D	; 13
    3054:	96 e1       	ldi	r25, 0x16	; 22
    3056:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    305a:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    305e:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3062:	9e 89       	ldd	r25, Y+22	; 0x16
    3064:	86 89       	ldd	r24, Z+22	; 0x16
    3066:	89 17       	cp	r24, r25
    3068:	20 f4       	brcc	.+8      	; 0x3072 <xTaskRemoveFromEventList+0x84>
    306a:	81 e0       	ldi	r24, 0x01	; 1
    306c:	80 93 fd 15 	sts	0x15FD, r24	; 0x8015fd <xYieldPending>
    3070:	01 c0       	rjmp	.+2      	; 0x3074 <xTaskRemoveFromEventList+0x86>
    3072:	80 e0       	ldi	r24, 0x00	; 0
    3074:	df 91       	pop	r29
    3076:	cf 91       	pop	r28
    3078:	1f 91       	pop	r17
    307a:	0f 91       	pop	r16
    307c:	08 95       	ret

0000307e <vTaskSetTimeOutState>:
    307e:	20 91 fc 15 	lds	r18, 0x15FC	; 0x8015fc <xNumOfOverflows>
    3082:	fc 01       	movw	r30, r24
    3084:	20 83       	st	Z, r18
    3086:	20 91 01 16 	lds	r18, 0x1601	; 0x801601 <xTickCount>
    308a:	30 91 02 16 	lds	r19, 0x1602	; 0x801602 <xTickCount+0x1>
    308e:	32 83       	std	Z+2, r19	; 0x02
    3090:	21 83       	std	Z+1, r18	; 0x01
    3092:	08 95       	ret

00003094 <xTaskCheckForTimeOut>:
    3094:	fc 01       	movw	r30, r24
    3096:	0f b6       	in	r0, 0x3f	; 63
    3098:	f8 94       	cli
    309a:	0f 92       	push	r0
    309c:	20 91 01 16 	lds	r18, 0x1601	; 0x801601 <xTickCount>
    30a0:	30 91 02 16 	lds	r19, 0x1602	; 0x801602 <xTickCount+0x1>
    30a4:	db 01       	movw	r26, r22
    30a6:	8d 91       	ld	r24, X+
    30a8:	9c 91       	ld	r25, X
    30aa:	8f 3f       	cpi	r24, 0xFF	; 255
    30ac:	bf ef       	ldi	r27, 0xFF	; 255
    30ae:	9b 07       	cpc	r25, r27
    30b0:	21 f1       	breq	.+72     	; 0x30fa <xTaskCheckForTimeOut+0x66>
    30b2:	40 91 fc 15 	lds	r20, 0x15FC	; 0x8015fc <xNumOfOverflows>
    30b6:	50 81       	ld	r21, Z
    30b8:	54 17       	cp	r21, r20
    30ba:	29 f0       	breq	.+10     	; 0x30c6 <xTaskCheckForTimeOut+0x32>
    30bc:	41 81       	ldd	r20, Z+1	; 0x01
    30be:	52 81       	ldd	r21, Z+2	; 0x02
    30c0:	24 17       	cp	r18, r20
    30c2:	35 07       	cpc	r19, r21
    30c4:	e0 f4       	brcc	.+56     	; 0x30fe <xTaskCheckForTimeOut+0x6a>
    30c6:	41 81       	ldd	r20, Z+1	; 0x01
    30c8:	52 81       	ldd	r21, Z+2	; 0x02
    30ca:	d9 01       	movw	r26, r18
    30cc:	a4 1b       	sub	r26, r20
    30ce:	b5 0b       	sbc	r27, r21
    30d0:	a8 17       	cp	r26, r24
    30d2:	b9 07       	cpc	r27, r25
    30d4:	b0 f4       	brcc	.+44     	; 0x3102 <xTaskCheckForTimeOut+0x6e>
    30d6:	42 1b       	sub	r20, r18
    30d8:	53 0b       	sbc	r21, r19
    30da:	84 0f       	add	r24, r20
    30dc:	95 1f       	adc	r25, r21
    30de:	db 01       	movw	r26, r22
    30e0:	8d 93       	st	X+, r24
    30e2:	9c 93       	st	X, r25
    30e4:	80 91 fc 15 	lds	r24, 0x15FC	; 0x8015fc <xNumOfOverflows>
    30e8:	80 83       	st	Z, r24
    30ea:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    30ee:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    30f2:	92 83       	std	Z+2, r25	; 0x02
    30f4:	81 83       	std	Z+1, r24	; 0x01
    30f6:	80 e0       	ldi	r24, 0x00	; 0
    30f8:	05 c0       	rjmp	.+10     	; 0x3104 <xTaskCheckForTimeOut+0x70>
    30fa:	80 e0       	ldi	r24, 0x00	; 0
    30fc:	03 c0       	rjmp	.+6      	; 0x3104 <xTaskCheckForTimeOut+0x70>
    30fe:	81 e0       	ldi	r24, 0x01	; 1
    3100:	01 c0       	rjmp	.+2      	; 0x3104 <xTaskCheckForTimeOut+0x70>
    3102:	81 e0       	ldi	r24, 0x01	; 1
    3104:	0f 90       	pop	r0
    3106:	0f be       	out	0x3f, r0	; 63
    3108:	08 95       	ret

0000310a <vTaskMissedYield>:
    310a:	81 e0       	ldi	r24, 0x01	; 1
    310c:	80 93 fd 15 	sts	0x15FD, r24	; 0x8015fd <xYieldPending>
    3110:	08 95       	ret

00003112 <xTaskGetCurrentTaskHandle>:
    3112:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <pxCurrentTCB>
    3116:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    311a:	08 95       	ret

0000311c <vTaskPriorityInherit>:
    311c:	0f 93       	push	r16
    311e:	1f 93       	push	r17
    3120:	cf 93       	push	r28
    3122:	df 93       	push	r29
    3124:	fc 01       	movw	r30, r24
    3126:	89 2b       	or	r24, r25
    3128:	09 f4       	brne	.+2      	; 0x312c <vTaskPriorityInherit+0x10>
    312a:	55 c0       	rjmp	.+170    	; 0x31d6 <vTaskPriorityInherit+0xba>
    312c:	26 89       	ldd	r18, Z+22	; 0x16
    312e:	a0 91 62 16 	lds	r26, 0x1662	; 0x801662 <pxCurrentTCB>
    3132:	b0 91 63 16 	lds	r27, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3136:	56 96       	adiw	r26, 0x16	; 22
    3138:	8c 91       	ld	r24, X
    313a:	28 17       	cp	r18, r24
    313c:	08 f0       	brcs	.+2      	; 0x3140 <vTaskPriorityInherit+0x24>
    313e:	4b c0       	rjmp	.+150    	; 0x31d6 <vTaskPriorityInherit+0xba>
    3140:	84 85       	ldd	r24, Z+12	; 0x0c
    3142:	95 85       	ldd	r25, Z+13	; 0x0d
    3144:	99 23       	and	r25, r25
    3146:	64 f0       	brlt	.+24     	; 0x3160 <vTaskPriorityInherit+0x44>
    3148:	a0 91 62 16 	lds	r26, 0x1662	; 0x801662 <pxCurrentTCB>
    314c:	b0 91 63 16 	lds	r27, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3150:	56 96       	adiw	r26, 0x16	; 22
    3152:	3c 91       	ld	r19, X
    3154:	86 e0       	ldi	r24, 0x06	; 6
    3156:	90 e0       	ldi	r25, 0x00	; 0
    3158:	83 1b       	sub	r24, r19
    315a:	91 09       	sbc	r25, r1
    315c:	95 87       	std	Z+13, r25	; 0x0d
    315e:	84 87       	std	Z+12, r24	; 0x0c
    3160:	30 e0       	ldi	r19, 0x00	; 0
    3162:	c9 01       	movw	r24, r18
    3164:	88 0f       	add	r24, r24
    3166:	99 1f       	adc	r25, r25
    3168:	88 0f       	add	r24, r24
    316a:	99 1f       	adc	r25, r25
    316c:	88 0f       	add	r24, r24
    316e:	99 1f       	adc	r25, r25
    3170:	28 0f       	add	r18, r24
    3172:	39 1f       	adc	r19, r25
    3174:	24 5d       	subi	r18, 0xD4	; 212
    3176:	39 4e       	sbci	r19, 0xE9	; 233
    3178:	82 85       	ldd	r24, Z+10	; 0x0a
    317a:	93 85       	ldd	r25, Z+11	; 0x0b
    317c:	82 17       	cp	r24, r18
    317e:	93 07       	cpc	r25, r19
    3180:	19 f5       	brne	.+70     	; 0x31c8 <vTaskPriorityInherit+0xac>
    3182:	8f 01       	movw	r16, r30
    3184:	ef 01       	movw	r28, r30
    3186:	22 96       	adiw	r28, 0x02	; 2
    3188:	ce 01       	movw	r24, r28
    318a:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    318e:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    3192:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3196:	86 89       	ldd	r24, Z+22	; 0x16
    3198:	f8 01       	movw	r30, r16
    319a:	86 8b       	std	Z+22, r24	; 0x16
    319c:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    31a0:	98 17       	cp	r25, r24
    31a2:	10 f4       	brcc	.+4      	; 0x31a8 <vTaskPriorityInherit+0x8c>
    31a4:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    31a8:	90 e0       	ldi	r25, 0x00	; 0
    31aa:	9c 01       	movw	r18, r24
    31ac:	22 0f       	add	r18, r18
    31ae:	33 1f       	adc	r19, r19
    31b0:	22 0f       	add	r18, r18
    31b2:	33 1f       	adc	r19, r19
    31b4:	22 0f       	add	r18, r18
    31b6:	33 1f       	adc	r19, r19
    31b8:	82 0f       	add	r24, r18
    31ba:	93 1f       	adc	r25, r19
    31bc:	be 01       	movw	r22, r28
    31be:	84 5d       	subi	r24, 0xD4	; 212
    31c0:	99 4e       	sbci	r25, 0xE9	; 233
    31c2:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    31c6:	07 c0       	rjmp	.+14     	; 0x31d6 <vTaskPriorityInherit+0xba>
    31c8:	a0 91 62 16 	lds	r26, 0x1662	; 0x801662 <pxCurrentTCB>
    31cc:	b0 91 63 16 	lds	r27, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    31d0:	56 96       	adiw	r26, 0x16	; 22
    31d2:	8c 91       	ld	r24, X
    31d4:	86 8b       	std	Z+22, r24	; 0x16
    31d6:	df 91       	pop	r29
    31d8:	cf 91       	pop	r28
    31da:	1f 91       	pop	r17
    31dc:	0f 91       	pop	r16
    31de:	08 95       	ret

000031e0 <xTaskPriorityDisinherit>:
    31e0:	0f 93       	push	r16
    31e2:	1f 93       	push	r17
    31e4:	cf 93       	push	r28
    31e6:	df 93       	push	r29
    31e8:	fc 01       	movw	r30, r24
    31ea:	89 2b       	or	r24, r25
    31ec:	79 f1       	breq	.+94     	; 0x324c <xTaskPriorityDisinherit+0x6c>
    31ee:	82 a1       	ldd	r24, Z+34	; 0x22
    31f0:	81 50       	subi	r24, 0x01	; 1
    31f2:	82 a3       	std	Z+34, r24	; 0x22
    31f4:	26 89       	ldd	r18, Z+22	; 0x16
    31f6:	91 a1       	ldd	r25, Z+33	; 0x21
    31f8:	29 17       	cp	r18, r25
    31fa:	51 f1       	breq	.+84     	; 0x3250 <xTaskPriorityDisinherit+0x70>
    31fc:	81 11       	cpse	r24, r1
    31fe:	2a c0       	rjmp	.+84     	; 0x3254 <xTaskPriorityDisinherit+0x74>
    3200:	ef 01       	movw	r28, r30
    3202:	8f 01       	movw	r16, r30
    3204:	0e 5f       	subi	r16, 0xFE	; 254
    3206:	1f 4f       	sbci	r17, 0xFF	; 255
    3208:	c8 01       	movw	r24, r16
    320a:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
    320e:	89 a1       	ldd	r24, Y+33	; 0x21
    3210:	8e 8b       	std	Y+22, r24	; 0x16
    3212:	26 e0       	ldi	r18, 0x06	; 6
    3214:	30 e0       	ldi	r19, 0x00	; 0
    3216:	28 1b       	sub	r18, r24
    3218:	31 09       	sbc	r19, r1
    321a:	3d 87       	std	Y+13, r19	; 0x0d
    321c:	2c 87       	std	Y+12, r18	; 0x0c
    321e:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    3222:	98 17       	cp	r25, r24
    3224:	10 f4       	brcc	.+4      	; 0x322a <xTaskPriorityDisinherit+0x4a>
    3226:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    322a:	90 e0       	ldi	r25, 0x00	; 0
    322c:	9c 01       	movw	r18, r24
    322e:	22 0f       	add	r18, r18
    3230:	33 1f       	adc	r19, r19
    3232:	22 0f       	add	r18, r18
    3234:	33 1f       	adc	r19, r19
    3236:	22 0f       	add	r18, r18
    3238:	33 1f       	adc	r19, r19
    323a:	82 0f       	add	r24, r18
    323c:	93 1f       	adc	r25, r19
    323e:	b8 01       	movw	r22, r16
    3240:	84 5d       	subi	r24, 0xD4	; 212
    3242:	99 4e       	sbci	r25, 0xE9	; 233
    3244:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    3248:	81 e0       	ldi	r24, 0x01	; 1
    324a:	05 c0       	rjmp	.+10     	; 0x3256 <xTaskPriorityDisinherit+0x76>
    324c:	80 e0       	ldi	r24, 0x00	; 0
    324e:	03 c0       	rjmp	.+6      	; 0x3256 <xTaskPriorityDisinherit+0x76>
    3250:	80 e0       	ldi	r24, 0x00	; 0
    3252:	01 c0       	rjmp	.+2      	; 0x3256 <xTaskPriorityDisinherit+0x76>
    3254:	80 e0       	ldi	r24, 0x00	; 0
    3256:	df 91       	pop	r29
    3258:	cf 91       	pop	r28
    325a:	1f 91       	pop	r17
    325c:	0f 91       	pop	r16
    325e:	08 95       	ret

00003260 <pvTaskIncrementMutexHeldCount>:
    3260:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <pxCurrentTCB>
    3264:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3268:	89 2b       	or	r24, r25
    326a:	39 f0       	breq	.+14     	; 0x327a <pvTaskIncrementMutexHeldCount+0x1a>
    326c:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    3270:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3274:	82 a1       	ldd	r24, Z+34	; 0x22
    3276:	8f 5f       	subi	r24, 0xFF	; 255
    3278:	82 a3       	std	Z+34, r24	; 0x22
    327a:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <pxCurrentTCB>
    327e:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3282:	08 95       	ret

00003284 <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    3284:	4f 92       	push	r4
    3286:	5f 92       	push	r5
    3288:	6f 92       	push	r6
    328a:	7f 92       	push	r7
    328c:	8f 92       	push	r8
    328e:	9f 92       	push	r9
    3290:	af 92       	push	r10
    3292:	bf 92       	push	r11
    3294:	ef 92       	push	r14
    3296:	ff 92       	push	r15
    3298:	0f 93       	push	r16
    329a:	1f 93       	push	r17
    329c:	49 01       	movw	r8, r18
    329e:	5a 01       	movw	r10, r20
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    32a0:	0f b6       	in	r0, 0x3f	; 63
    32a2:	f8 94       	cli
    32a4:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    32a6:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    32aa:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    32ae:	27 a1       	ldd	r18, Z+39	; 0x27
    32b0:	22 30       	cpi	r18, 0x02	; 2
    32b2:	09 f4       	brne	.+2      	; 0x32b6 <xTaskNotifyWait+0x32>
    32b4:	6f c0       	rjmp	.+222    	; 0x3394 <xTaskNotifyWait+0x110>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    32b6:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    32ba:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    32be:	43 a0       	ldd	r4, Z+35	; 0x23
    32c0:	54 a0       	ldd	r5, Z+36	; 0x24
    32c2:	65 a0       	ldd	r6, Z+37	; 0x25
    32c4:	76 a0       	ldd	r7, Z+38	; 0x26
    32c6:	dc 01       	movw	r26, r24
    32c8:	cb 01       	movw	r24, r22
    32ca:	80 95       	com	r24
    32cc:	90 95       	com	r25
    32ce:	a0 95       	com	r26
    32d0:	b0 95       	com	r27
    32d2:	84 21       	and	r24, r4
    32d4:	95 21       	and	r25, r5
    32d6:	a6 21       	and	r26, r6
    32d8:	b7 21       	and	r27, r7
    32da:	83 a3       	std	Z+35, r24	; 0x23
    32dc:	94 a3       	std	Z+36, r25	; 0x24
    32de:	a5 a3       	std	Z+37, r26	; 0x25
    32e0:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    32e2:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    32e6:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    32ea:	81 e0       	ldi	r24, 0x01	; 1
    32ec:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    32ee:	e1 14       	cp	r14, r1
    32f0:	f1 04       	cpc	r15, r1
    32f2:	09 f4       	brne	.+2      	; 0x32f6 <xTaskNotifyWait+0x72>
    32f4:	4f c0       	rjmp	.+158    	; 0x3394 <xTaskNotifyWait+0x110>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    32f6:	80 91 62 16 	lds	r24, 0x1662	; 0x801662 <pxCurrentTCB>
    32fa:	90 91 63 16 	lds	r25, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    32fe:	02 96       	adiw	r24, 0x02	; 2
    3300:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    3304:	8f ef       	ldi	r24, 0xFF	; 255
    3306:	e8 16       	cp	r14, r24
    3308:	f8 06       	cpc	r15, r24
    330a:	59 f4       	brne	.+22     	; 0x3322 <xTaskNotifyWait+0x9e>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    330c:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    3310:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3314:	6e 5f       	subi	r22, 0xFE	; 254
    3316:	7f 4f       	sbci	r23, 0xFF	; 255
    3318:	84 e0       	ldi	r24, 0x04	; 4
    331a:	96 e1       	ldi	r25, 0x16	; 22
    331c:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    3320:	37 c0       	rjmp	.+110    	; 0x3390 <xTaskNotifyWait+0x10c>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    3322:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    3326:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    332a:	e8 0e       	add	r14, r24
    332c:	f9 1e       	adc	r15, r25
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    332e:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    3332:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3336:	f3 82       	std	Z+3, r15	; 0x03
    3338:	e2 82       	std	Z+2, r14	; 0x02

	if( xTimeToWake < xTickCount )
    333a:	80 91 01 16 	lds	r24, 0x1601	; 0x801601 <xTickCount>
    333e:	90 91 02 16 	lds	r25, 0x1602	; 0x801602 <xTickCount+0x1>
    3342:	e8 16       	cp	r14, r24
    3344:	f9 06       	cpc	r15, r25
    3346:	68 f4       	brcc	.+26     	; 0x3362 <xTaskNotifyWait+0xde>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3348:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    334c:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3350:	80 91 16 16 	lds	r24, 0x1616	; 0x801616 <pxOverflowDelayedTaskList>
    3354:	90 91 17 16 	lds	r25, 0x1617	; 0x801617 <pxOverflowDelayedTaskList+0x1>
    3358:	6e 5f       	subi	r22, 0xFE	; 254
    335a:	7f 4f       	sbci	r23, 0xFF	; 255
    335c:	0e 94 ef 08 	call	0x11de	; 0x11de <vListInsert>
    3360:	17 c0       	rjmp	.+46     	; 0x3390 <xTaskNotifyWait+0x10c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3362:	60 91 62 16 	lds	r22, 0x1662	; 0x801662 <pxCurrentTCB>
    3366:	70 91 63 16 	lds	r23, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    336a:	80 91 18 16 	lds	r24, 0x1618	; 0x801618 <pxDelayedTaskList>
    336e:	90 91 19 16 	lds	r25, 0x1619	; 0x801619 <pxDelayedTaskList+0x1>
    3372:	6e 5f       	subi	r22, 0xFE	; 254
    3374:	7f 4f       	sbci	r23, 0xFF	; 255
    3376:	0e 94 ef 08 	call	0x11de	; 0x11de <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    337a:	80 91 f9 15 	lds	r24, 0x15F9	; 0x8015f9 <xNextTaskUnblockTime>
    337e:	90 91 fa 15 	lds	r25, 0x15FA	; 0x8015fa <xNextTaskUnblockTime+0x1>
    3382:	e8 16       	cp	r14, r24
    3384:	f9 06       	cpc	r15, r25
    3386:	20 f4       	brcc	.+8      	; 0x3390 <xTaskNotifyWait+0x10c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3388:	f0 92 fa 15 	sts	0x15FA, r15	; 0x8015fa <xNextTaskUnblockTime+0x1>
    338c:	e0 92 f9 15 	sts	0x15F9, r14	; 0x8015f9 <xNextTaskUnblockTime>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    3390:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3394:	0f 90       	pop	r0
    3396:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    3398:	0f b6       	in	r0, 0x3f	; 63
    339a:	f8 94       	cli
    339c:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    339e:	01 15       	cp	r16, r1
    33a0:	11 05       	cpc	r17, r1
    33a2:	69 f0       	breq	.+26     	; 0x33be <xTaskNotifyWait+0x13a>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    33a4:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    33a8:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    33ac:	83 a1       	ldd	r24, Z+35	; 0x23
    33ae:	94 a1       	ldd	r25, Z+36	; 0x24
    33b0:	a5 a1       	ldd	r26, Z+37	; 0x25
    33b2:	b6 a1       	ldd	r27, Z+38	; 0x26
    33b4:	f8 01       	movw	r30, r16
    33b6:	80 83       	st	Z, r24
    33b8:	91 83       	std	Z+1, r25	; 0x01
    33ba:	a2 83       	std	Z+2, r26	; 0x02
    33bc:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    33be:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    33c2:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    33c6:	87 a1       	ldd	r24, Z+39	; 0x27
    33c8:	81 30       	cpi	r24, 0x01	; 1
    33ca:	b1 f0       	breq	.+44     	; 0x33f8 <xTaskNotifyWait+0x174>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    33cc:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    33d0:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    33d4:	83 a1       	ldd	r24, Z+35	; 0x23
    33d6:	94 a1       	ldd	r25, Z+36	; 0x24
    33d8:	a5 a1       	ldd	r26, Z+37	; 0x25
    33da:	b6 a1       	ldd	r27, Z+38	; 0x26
    33dc:	80 94       	com	r8
    33de:	90 94       	com	r9
    33e0:	a0 94       	com	r10
    33e2:	b0 94       	com	r11
    33e4:	88 22       	and	r8, r24
    33e6:	99 22       	and	r9, r25
    33e8:	aa 22       	and	r10, r26
    33ea:	bb 22       	and	r11, r27
    33ec:	83 a2       	std	Z+35, r8	; 0x23
    33ee:	94 a2       	std	Z+36, r9	; 0x24
    33f0:	a5 a2       	std	Z+37, r10	; 0x25
    33f2:	b6 a2       	std	Z+38, r11	; 0x26
				xReturn = pdTRUE;
    33f4:	81 e0       	ldi	r24, 0x01	; 1
    33f6:	01 c0       	rjmp	.+2      	; 0x33fa <xTaskNotifyWait+0x176>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    33f8:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    33fa:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    33fe:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3402:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    3404:	0f 90       	pop	r0
    3406:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    3408:	1f 91       	pop	r17
    340a:	0f 91       	pop	r16
    340c:	ff 90       	pop	r15
    340e:	ef 90       	pop	r14
    3410:	bf 90       	pop	r11
    3412:	af 90       	pop	r10
    3414:	9f 90       	pop	r9
    3416:	8f 90       	pop	r8
    3418:	7f 90       	pop	r7
    341a:	6f 90       	pop	r6
    341c:	5f 90       	pop	r5
    341e:	4f 90       	pop	r4
    3420:	08 95       	ret

00003422 <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    3422:	0f 93       	push	r16
    3424:	1f 93       	push	r17
    3426:	cf 93       	push	r28
    3428:	df 93       	push	r29
    342a:	fc 01       	movw	r30, r24
	BaseType_t xReturn = pdPASS;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    342c:	0f b6       	in	r0, 0x3f	; 63
    342e:	f8 94       	cli
    3430:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    3432:	01 15       	cp	r16, r1
    3434:	11 05       	cpc	r17, r1
    3436:	49 f0       	breq	.+18     	; 0x344a <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3438:	83 a1       	ldd	r24, Z+35	; 0x23
    343a:	94 a1       	ldd	r25, Z+36	; 0x24
    343c:	a5 a1       	ldd	r26, Z+37	; 0x25
    343e:	b6 a1       	ldd	r27, Z+38	; 0x26
    3440:	e8 01       	movw	r28, r16
    3442:	88 83       	st	Y, r24
    3444:	99 83       	std	Y+1, r25	; 0x01
    3446:	aa 83       	std	Y+2, r26	; 0x02
    3448:	bb 83       	std	Y+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    344a:	87 a1       	ldd	r24, Z+39	; 0x27

			pxTCB->eNotifyState = eNotified;
    344c:	92 e0       	ldi	r25, 0x02	; 2
    344e:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    3450:	22 30       	cpi	r18, 0x02	; 2
    3452:	b1 f0       	breq	.+44     	; 0x3480 <xTaskGenericNotify+0x5e>
    3454:	18 f4       	brcc	.+6      	; 0x345c <xTaskGenericNotify+0x3a>
    3456:	21 30       	cpi	r18, 0x01	; 1
    3458:	31 f0       	breq	.+12     	; 0x3466 <xTaskGenericNotify+0x44>
    345a:	2a c0       	rjmp	.+84     	; 0x34b0 <xTaskGenericNotify+0x8e>
    345c:	23 30       	cpi	r18, 0x03	; 3
    345e:	e9 f0       	breq	.+58     	; 0x349a <xTaskGenericNotify+0x78>
    3460:	24 30       	cpi	r18, 0x04	; 4
    3462:	01 f1       	breq	.+64     	; 0x34a4 <xTaskGenericNotify+0x82>
    3464:	25 c0       	rjmp	.+74     	; 0x34b0 <xTaskGenericNotify+0x8e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3466:	03 a1       	ldd	r16, Z+35	; 0x23
    3468:	14 a1       	ldd	r17, Z+36	; 0x24
    346a:	25 a1       	ldd	r18, Z+37	; 0x25
    346c:	36 a1       	ldd	r19, Z+38	; 0x26
    346e:	40 2b       	or	r20, r16
    3470:	51 2b       	or	r21, r17
    3472:	62 2b       	or	r22, r18
    3474:	73 2b       	or	r23, r19
    3476:	43 a3       	std	Z+35, r20	; 0x23
    3478:	54 a3       	std	Z+36, r21	; 0x24
    347a:	65 a3       	std	Z+37, r22	; 0x25
    347c:	76 a3       	std	Z+38, r23	; 0x26
					break;
    347e:	18 c0       	rjmp	.+48     	; 0x34b0 <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    3480:	43 a1       	ldd	r20, Z+35	; 0x23
    3482:	54 a1       	ldd	r21, Z+36	; 0x24
    3484:	65 a1       	ldd	r22, Z+37	; 0x25
    3486:	76 a1       	ldd	r23, Z+38	; 0x26
    3488:	4f 5f       	subi	r20, 0xFF	; 255
    348a:	5f 4f       	sbci	r21, 0xFF	; 255
    348c:	6f 4f       	sbci	r22, 0xFF	; 255
    348e:	7f 4f       	sbci	r23, 0xFF	; 255
    3490:	43 a3       	std	Z+35, r20	; 0x23
    3492:	54 a3       	std	Z+36, r21	; 0x24
    3494:	65 a3       	std	Z+37, r22	; 0x25
    3496:	76 a3       	std	Z+38, r23	; 0x26
					break;
    3498:	0b c0       	rjmp	.+22     	; 0x34b0 <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    349a:	43 a3       	std	Z+35, r20	; 0x23
    349c:	54 a3       	std	Z+36, r21	; 0x24
    349e:	65 a3       	std	Z+37, r22	; 0x25
    34a0:	76 a3       	std	Z+38, r23	; 0x26
					break;
    34a2:	06 c0       	rjmp	.+12     	; 0x34b0 <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    34a4:	82 30       	cpi	r24, 0x02	; 2
    34a6:	79 f1       	breq	.+94     	; 0x3506 <xTaskGenericNotify+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    34a8:	43 a3       	std	Z+35, r20	; 0x23
    34aa:	54 a3       	std	Z+36, r21	; 0x24
    34ac:	65 a3       	std	Z+37, r22	; 0x25
    34ae:	76 a3       	std	Z+38, r23	; 0x26

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    34b0:	81 30       	cpi	r24, 0x01	; 1
    34b2:	59 f5       	brne	.+86     	; 0x350a <xTaskGenericNotify+0xe8>
    34b4:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    34b6:	8f 01       	movw	r16, r30
    34b8:	0e 5f       	subi	r16, 0xFE	; 254
    34ba:	1f 4f       	sbci	r17, 0xFF	; 255
    34bc:	c8 01       	movw	r24, r16
    34be:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    34c2:	8e 89       	ldd	r24, Y+22	; 0x16
    34c4:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    34c8:	98 17       	cp	r25, r24
    34ca:	10 f4       	brcc	.+4      	; 0x34d0 <xTaskGenericNotify+0xae>
    34cc:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    34d0:	90 e0       	ldi	r25, 0x00	; 0
    34d2:	9c 01       	movw	r18, r24
    34d4:	22 0f       	add	r18, r18
    34d6:	33 1f       	adc	r19, r19
    34d8:	22 0f       	add	r18, r18
    34da:	33 1f       	adc	r19, r19
    34dc:	22 0f       	add	r18, r18
    34de:	33 1f       	adc	r19, r19
    34e0:	82 0f       	add	r24, r18
    34e2:	93 1f       	adc	r25, r19
    34e4:	b8 01       	movw	r22, r16
    34e6:	84 5d       	subi	r24, 0xD4	; 212
    34e8:	99 4e       	sbci	r25, 0xE9	; 233
    34ea:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    34ee:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    34f2:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    34f6:	9e 89       	ldd	r25, Y+22	; 0x16
    34f8:	86 89       	ldd	r24, Z+22	; 0x16
    34fa:	89 17       	cp	r24, r25
    34fc:	40 f4       	brcc	.+16     	; 0x350e <xTaskGenericNotify+0xec>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    34fe:	0e 94 69 0b 	call	0x16d2	; 0x16d2 <vPortYield>
    3502:	81 e0       	ldi	r24, 0x01	; 1
    3504:	05 c0       	rjmp	.+10     	; 0x3510 <xTaskGenericNotify+0xee>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3506:	80 e0       	ldi	r24, 0x00	; 0
    3508:	03 c0       	rjmp	.+6      	; 0x3510 <xTaskGenericNotify+0xee>
    350a:	81 e0       	ldi	r24, 0x01	; 1
    350c:	01 c0       	rjmp	.+2      	; 0x3510 <xTaskGenericNotify+0xee>
    350e:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    3510:	0f 90       	pop	r0
    3512:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    3514:	df 91       	pop	r29
    3516:	cf 91       	pop	r28
    3518:	1f 91       	pop	r17
    351a:	0f 91       	pop	r16
    351c:	08 95       	ret

0000351e <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    351e:	ef 92       	push	r14
    3520:	ff 92       	push	r15
    3522:	0f 93       	push	r16
    3524:	1f 93       	push	r17
    3526:	cf 93       	push	r28
    3528:	df 93       	push	r29
    352a:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    352c:	01 15       	cp	r16, r1
    352e:	11 05       	cpc	r17, r1
    3530:	49 f0       	breq	.+18     	; 0x3544 <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3532:	83 a1       	ldd	r24, Z+35	; 0x23
    3534:	94 a1       	ldd	r25, Z+36	; 0x24
    3536:	a5 a1       	ldd	r26, Z+37	; 0x25
    3538:	b6 a1       	ldd	r27, Z+38	; 0x26
    353a:	e8 01       	movw	r28, r16
    353c:	88 83       	st	Y, r24
    353e:	99 83       	std	Y+1, r25	; 0x01
    3540:	aa 83       	std	Y+2, r26	; 0x02
    3542:	bb 83       	std	Y+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    3544:	87 a1       	ldd	r24, Z+39	; 0x27
			pxTCB->eNotifyState = eNotified;
    3546:	92 e0       	ldi	r25, 0x02	; 2
    3548:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    354a:	22 30       	cpi	r18, 0x02	; 2
    354c:	b1 f0       	breq	.+44     	; 0x357a <xTaskGenericNotifyFromISR+0x5c>
    354e:	18 f4       	brcc	.+6      	; 0x3556 <xTaskGenericNotifyFromISR+0x38>
    3550:	21 30       	cpi	r18, 0x01	; 1
    3552:	31 f0       	breq	.+12     	; 0x3560 <xTaskGenericNotifyFromISR+0x42>
    3554:	2a c0       	rjmp	.+84     	; 0x35aa <xTaskGenericNotifyFromISR+0x8c>
    3556:	23 30       	cpi	r18, 0x03	; 3
    3558:	e9 f0       	breq	.+58     	; 0x3594 <xTaskGenericNotifyFromISR+0x76>
    355a:	24 30       	cpi	r18, 0x04	; 4
    355c:	01 f1       	breq	.+64     	; 0x359e <xTaskGenericNotifyFromISR+0x80>
    355e:	25 c0       	rjmp	.+74     	; 0x35aa <xTaskGenericNotifyFromISR+0x8c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3560:	03 a1       	ldd	r16, Z+35	; 0x23
    3562:	14 a1       	ldd	r17, Z+36	; 0x24
    3564:	25 a1       	ldd	r18, Z+37	; 0x25
    3566:	36 a1       	ldd	r19, Z+38	; 0x26
    3568:	40 2b       	or	r20, r16
    356a:	51 2b       	or	r21, r17
    356c:	62 2b       	or	r22, r18
    356e:	73 2b       	or	r23, r19
    3570:	43 a3       	std	Z+35, r20	; 0x23
    3572:	54 a3       	std	Z+36, r21	; 0x24
    3574:	65 a3       	std	Z+37, r22	; 0x25
    3576:	76 a3       	std	Z+38, r23	; 0x26
					break;
    3578:	18 c0       	rjmp	.+48     	; 0x35aa <xTaskGenericNotifyFromISR+0x8c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    357a:	43 a1       	ldd	r20, Z+35	; 0x23
    357c:	54 a1       	ldd	r21, Z+36	; 0x24
    357e:	65 a1       	ldd	r22, Z+37	; 0x25
    3580:	76 a1       	ldd	r23, Z+38	; 0x26
    3582:	4f 5f       	subi	r20, 0xFF	; 255
    3584:	5f 4f       	sbci	r21, 0xFF	; 255
    3586:	6f 4f       	sbci	r22, 0xFF	; 255
    3588:	7f 4f       	sbci	r23, 0xFF	; 255
    358a:	43 a3       	std	Z+35, r20	; 0x23
    358c:	54 a3       	std	Z+36, r21	; 0x24
    358e:	65 a3       	std	Z+37, r22	; 0x25
    3590:	76 a3       	std	Z+38, r23	; 0x26
					break;
    3592:	0b c0       	rjmp	.+22     	; 0x35aa <xTaskGenericNotifyFromISR+0x8c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    3594:	43 a3       	std	Z+35, r20	; 0x23
    3596:	54 a3       	std	Z+36, r21	; 0x24
    3598:	65 a3       	std	Z+37, r22	; 0x25
    359a:	76 a3       	std	Z+38, r23	; 0x26
					break;
    359c:	06 c0       	rjmp	.+12     	; 0x35aa <xTaskGenericNotifyFromISR+0x8c>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    359e:	82 30       	cpi	r24, 0x02	; 2
    35a0:	f1 f1       	breq	.+124    	; 0x361e <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
    35a2:	43 a3       	std	Z+35, r20	; 0x23
    35a4:	54 a3       	std	Z+36, r21	; 0x24
    35a6:	65 a3       	std	Z+37, r22	; 0x25
    35a8:	76 a3       	std	Z+38, r23	; 0x26

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    35aa:	81 30       	cpi	r24, 0x01	; 1
    35ac:	d1 f5       	brne	.+116    	; 0x3622 <xTaskGenericNotifyFromISR+0x104>
    35ae:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    35b0:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <uxSchedulerSuspended>
    35b4:	81 11       	cpse	r24, r1
    35b6:	1d c0       	rjmp	.+58     	; 0x35f2 <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    35b8:	8f 01       	movw	r16, r30
    35ba:	0e 5f       	subi	r16, 0xFE	; 254
    35bc:	1f 4f       	sbci	r17, 0xFF	; 255
    35be:	c8 01       	movw	r24, r16
    35c0:	0e 94 20 09 	call	0x1240	; 0x1240 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    35c4:	8e 89       	ldd	r24, Y+22	; 0x16
    35c6:	90 91 00 16 	lds	r25, 0x1600	; 0x801600 <uxTopReadyPriority>
    35ca:	98 17       	cp	r25, r24
    35cc:	10 f4       	brcc	.+4      	; 0x35d2 <xTaskGenericNotifyFromISR+0xb4>
    35ce:	80 93 00 16 	sts	0x1600, r24	; 0x801600 <uxTopReadyPriority>
    35d2:	90 e0       	ldi	r25, 0x00	; 0
    35d4:	9c 01       	movw	r18, r24
    35d6:	22 0f       	add	r18, r18
    35d8:	33 1f       	adc	r19, r19
    35da:	22 0f       	add	r18, r18
    35dc:	33 1f       	adc	r19, r19
    35de:	22 0f       	add	r18, r18
    35e0:	33 1f       	adc	r19, r19
    35e2:	82 0f       	add	r24, r18
    35e4:	93 1f       	adc	r25, r19
    35e6:	b8 01       	movw	r22, r16
    35e8:	84 5d       	subi	r24, 0xD4	; 212
    35ea:	99 4e       	sbci	r25, 0xE9	; 233
    35ec:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
    35f0:	07 c0       	rjmp	.+14     	; 0x3600 <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    35f2:	bf 01       	movw	r22, r30
    35f4:	64 5f       	subi	r22, 0xF4	; 244
    35f6:	7f 4f       	sbci	r23, 0xFF	; 255
    35f8:	8d e0       	ldi	r24, 0x0D	; 13
    35fa:	96 e1       	ldi	r25, 0x16	; 22
    35fc:	0e 94 ce 08 	call	0x119c	; 0x119c <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3600:	e0 91 62 16 	lds	r30, 0x1662	; 0x801662 <pxCurrentTCB>
    3604:	f0 91 63 16 	lds	r31, 0x1663	; 0x801663 <pxCurrentTCB+0x1>
    3608:	9e 89       	ldd	r25, Y+22	; 0x16
    360a:	86 89       	ldd	r24, Z+22	; 0x16
    360c:	89 17       	cp	r24, r25
    360e:	58 f4       	brcc	.+22     	; 0x3626 <xTaskGenericNotifyFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    3610:	e1 14       	cp	r14, r1
    3612:	f1 04       	cpc	r15, r1
    3614:	51 f0       	breq	.+20     	; 0x362a <xTaskGenericNotifyFromISR+0x10c>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3616:	81 e0       	ldi	r24, 0x01	; 1
    3618:	f7 01       	movw	r30, r14
    361a:	80 83       	st	Z, r24
    361c:	07 c0       	rjmp	.+14     	; 0x362c <xTaskGenericNotifyFromISR+0x10e>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    361e:	80 e0       	ldi	r24, 0x00	; 0
    3620:	05 c0       	rjmp	.+10     	; 0x362c <xTaskGenericNotifyFromISR+0x10e>
    3622:	81 e0       	ldi	r24, 0x01	; 1
    3624:	03 c0       	rjmp	.+6      	; 0x362c <xTaskGenericNotifyFromISR+0x10e>
    3626:	81 e0       	ldi	r24, 0x01	; 1
    3628:	01 c0       	rjmp	.+2      	; 0x362c <xTaskGenericNotifyFromISR+0x10e>
    362a:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    362c:	df 91       	pop	r29
    362e:	cf 91       	pop	r28
    3630:	1f 91       	pop	r17
    3632:	0f 91       	pop	r16
    3634:	ff 90       	pop	r15
    3636:	ef 90       	pop	r14
    3638:	08 95       	ret

0000363a <vFrameReaderTask>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
}

void vFrameReaderTask( void *pvParameters ){
    363a:	cf 93       	push	r28
    363c:	df 93       	push	r29
    363e:	00 d0       	rcall	.+0      	; 0x3640 <vFrameReaderTask+0x6>
    3640:	1f 92       	push	r1
    3642:	cd b7       	in	r28, 0x3d	; 61
    3644:	de b7       	in	r29, 0x3e	; 62
	frame_receiver = xTaskGetCurrentTaskHandle();
    3646:	65 dd       	rcall	.-1334   	; 0x3112 <xTaskGetCurrentTaskHandle>
    3648:	90 93 cb 16 	sts	0x16CB, r25	; 0x8016cb <frame_receiver+0x1>
    364c:	80 93 ca 16 	sts	0x16CA, r24	; 0x8016ca <frame_receiver>
	uint32_t notification_value = 0;
    3650:	19 82       	std	Y+1, r1	; 0x01
    3652:	1a 82       	std	Y+2, r1	; 0x02
    3654:	1b 82       	std	Y+3, r1	; 0x03
    3656:	1c 82       	std	Y+4, r1	; 0x04
	while(1){
		xTaskNotifyWait(0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);
    3658:	ee 24       	eor	r14, r14
    365a:	ea 94       	dec	r14
    365c:	fe 2c       	mov	r15, r14
    365e:	8e 01       	movw	r16, r28
    3660:	0f 5f       	subi	r16, 0xFF	; 255
    3662:	1f 4f       	sbci	r17, 0xFF	; 255
    3664:	2f ef       	ldi	r18, 0xFF	; 255
    3666:	3f ef       	ldi	r19, 0xFF	; 255
    3668:	a9 01       	movw	r20, r18
    366a:	6f ef       	ldi	r22, 0xFF	; 255
    366c:	7f ef       	ldi	r23, 0xFF	; 255
    366e:	cb 01       	movw	r24, r22
    3670:	09 de       	rcall	.-1006   	; 0x3284 <xTaskNotifyWait>
		if(receive_callback != NULL) receive_callback(receive_buffer, (uint16_t)notification_value);
    3672:	e0 91 2f 17 	lds	r30, 0x172F	; 0x80172f <receive_callback>
    3676:	f0 91 30 17 	lds	r31, 0x1730	; 0x801730 <receive_callback+0x1>
    367a:	30 97       	sbiw	r30, 0x00	; 0
    367c:	69 f3       	breq	.-38     	; 0x3658 <vFrameReaderTask+0x1e>
    367e:	69 81       	ldd	r22, Y+1	; 0x01
    3680:	7a 81       	ldd	r23, Y+2	; 0x02
    3682:	81 e3       	ldi	r24, 0x31	; 49
    3684:	97 e1       	ldi	r25, 0x17	; 23
    3686:	19 95       	eicall
    3688:	e7 cf       	rjmp	.-50     	; 0x3658 <vFrameReaderTask+0x1e>

0000368a <vUartSendTask>:
	}
}

void vUartSendTask(void *pvParamters) {
    368a:	cf 93       	push	r28
    368c:	df 93       	push	r29
    368e:	cd b7       	in	r28, 0x3d	; 61
    3690:	de b7       	in	r29, 0x3e	; 62
    3692:	c4 56       	subi	r28, 0x64	; 100
    3694:	d1 09       	sbc	r29, r1
    3696:	0f b6       	in	r0, 0x3f	; 63
    3698:	f8 94       	cli
    369a:	de bf       	out	0x3e, r29	; 62
    369c:	0f be       	out	0x3f, r0	; 63
    369e:	cd bf       	out	0x3d, r28	; 61
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    36a0:	00 ed       	ldi	r16, 0xD0	; 208
    36a2:	10 e0       	ldi	r17, 0x00	; 0
				UDR2 = data[i];
    36a4:	0f 2e       	mov	r0, r31
    36a6:	f6 ed       	ldi	r31, 0xD6	; 214
    36a8:	ef 2e       	mov	r14, r31
    36aa:	f1 2c       	mov	r15, r1
    36ac:	f0 2d       	mov	r31, r0
void vUartSendTask(void *pvParamters) {
	uint8_t data[100];
	uint16_t num;
	uint16_t i;
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
    36ae:	20 e0       	ldi	r18, 0x00	; 0
    36b0:	4f ef       	ldi	r20, 0xFF	; 255
    36b2:	5f ef       	ldi	r21, 0xFF	; 255
    36b4:	60 e0       	ldi	r22, 0x00	; 0
    36b6:	70 e0       	ldi	r23, 0x00	; 0
    36b8:	80 91 f0 16 	lds	r24, 0x16F0	; 0x8016f0 <xUartMutex>
    36bc:	90 91 f1 16 	lds	r25, 0x16F1	; 0x8016f1 <xUartMutex+0x1>
    36c0:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
    36c4:	24 e6       	ldi	r18, 0x64	; 100
    36c6:	30 e0       	ldi	r19, 0x00	; 0
    36c8:	40 e0       	ldi	r20, 0x00	; 0
    36ca:	be 01       	movw	r22, r28
    36cc:	6f 5f       	subi	r22, 0xFF	; 255
    36ce:	7f 4f       	sbci	r23, 0xFF	; 255
    36d0:	85 e9       	ldi	r24, 0x95	; 149
    36d2:	97 e1       	ldi	r25, 0x17	; 23
    36d4:	0e 94 9a 03 	call	0x734	; 0x734 <buffer_remove_token>
    36d8:	6c 01       	movw	r12, r24
		xSemaphoreGive(xUartMutex);
    36da:	60 e0       	ldi	r22, 0x00	; 0
    36dc:	70 e0       	ldi	r23, 0x00	; 0
    36de:	80 91 f0 16 	lds	r24, 0x16F0	; 0x8016f0 <xUartMutex>
    36e2:	90 91 f1 16 	lds	r25, 0x16F1	; 0x8016f1 <xUartMutex+0x1>
    36e6:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueGive>
		if(num>0) {
    36ea:	c1 14       	cp	r12, r1
    36ec:	d1 04       	cpc	r13, r1
    36ee:	79 f0       	breq	.+30     	; 0x370e <vUartSendTask+0x84>
    36f0:	fe 01       	movw	r30, r28
    36f2:	31 96       	adiw	r30, 0x01	; 1
    36f4:	9f 01       	movw	r18, r30
    36f6:	2c 0d       	add	r18, r12
    36f8:	3d 1d       	adc	r19, r13
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    36fa:	d8 01       	movw	r26, r16
    36fc:	8c 91       	ld	r24, X
    36fe:	85 ff       	sbrs	r24, 5
    3700:	fc cf       	rjmp	.-8      	; 0x36fa <vUartSendTask+0x70>
				UDR2 = data[i];
    3702:	81 91       	ld	r24, Z+
    3704:	d7 01       	movw	r26, r14
    3706:	8c 93       	st	X, r24
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
    3708:	2e 17       	cp	r18, r30
    370a:	3f 07       	cpc	r19, r31
    370c:	b1 f7       	brne	.-20     	; 0x36fa <vUartSendTask+0x70>
				while ( !( UCSR2A & (1<<UDRE2)) );
				UDR2 = data[i];
			}
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
    370e:	8a e0       	ldi	r24, 0x0A	; 10
    3710:	90 e0       	ldi	r25, 0x00	; 0
    3712:	03 d8       	rcall	.-4090   	; 0x271a <vTaskDelay>
	}
    3714:	cc cf       	rjmp	.-104    	; 0x36ae <vUartSendTask+0x24>

00003716 <vUSART_init>:
/************************************************************************/
//Initialize USART driver, note that RXD0/TXD0 (PD0/PD1) is used
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    3716:	af 92       	push	r10
    3718:	bf 92       	push	r11
    371a:	cf 92       	push	r12
    371c:	df 92       	push	r13
    371e:	ef 92       	push	r14
    3720:	ff 92       	push	r15
    3722:	0f 93       	push	r16
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    3724:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    3728:	89 e1       	ldi	r24, 0x19	; 25
    372a:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
	
	UBRR0H = (unsigned char)(BAUD_PRESCALE>>8);
    372e:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__TEXT_REGION_LENGTH__+0x7000c5>
	UBRR0L = (unsigned char)BAUD_PRESCALE;
    3732:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__TEXT_REGION_LENGTH__+0x7000c4>

	UCSR0C = (3 << UCSZ00); /* 8-bit data */
    3736:	86 e0       	ldi	r24, 0x06	; 6
    3738:	80 93 c2 00 	sts	0x00C2, r24	; 0x8000c2 <__TEXT_REGION_LENGTH__+0x7000c2>
	UCSR0B = (1 << RXEN0) | (1 << TXEN0);   /* Enable RX and TX */
    373c:	98 e1       	ldi	r25, 0x18	; 24
    373e:	90 93 c1 00 	sts	0x00C1, r25	; 0x8000c1 <__TEXT_REGION_LENGTH__+0x7000c1>

    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    3742:	90 ee       	ldi	r25, 0xE0	; 224
    3744:	90 93 d0 00 	sts	0x00D0, r25	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    3748:	98 e9       	ldi	r25, 0x98	; 152
    374a:	90 93 d1 00 	sts	0x00D1, r25	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    374e:	e2 ed       	ldi	r30, 0xD2	; 210
    3750:	f0 e0       	ldi	r31, 0x00	; 0
    3752:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    3754:	80 81       	ld	r24, Z
    3756:	80 83       	st	Z, r24

	uint8_t *buf = pvPortMalloc(100);
    3758:	84 e6       	ldi	r24, 0x64	; 100
    375a:	90 e0       	ldi	r25, 0x00	; 0
    375c:	0e 94 5f 05 	call	0xabe	; 0xabe <pvPortMalloc>
	buffer_init(&send_buffer, buf, 100);
    3760:	44 e6       	ldi	r20, 0x64	; 100
    3762:	50 e0       	ldi	r21, 0x00	; 0
    3764:	bc 01       	movw	r22, r24
    3766:	85 e9       	ldi	r24, 0x95	; 149
    3768:	97 e1       	ldi	r25, 0x17	; 23
    376a:	0e 94 24 03 	call	0x648	; 0x648 <buffer_init>
	xTaskCreate(vFrameReaderTask, "FrameReader", 300, NULL, 4, NULL);
    376e:	a1 2c       	mov	r10, r1
    3770:	b1 2c       	mov	r11, r1
    3772:	c1 2c       	mov	r12, r1
    3774:	d1 2c       	mov	r13, r1
    3776:	e1 2c       	mov	r14, r1
    3778:	f1 2c       	mov	r15, r1
    377a:	04 e0       	ldi	r16, 0x04	; 4
    377c:	20 e0       	ldi	r18, 0x00	; 0
    377e:	30 e0       	ldi	r19, 0x00	; 0
    3780:	4c e2       	ldi	r20, 0x2C	; 44
    3782:	51 e0       	ldi	r21, 0x01	; 1
    3784:	65 ed       	ldi	r22, 0xD5	; 213
    3786:	72 e0       	ldi	r23, 0x02	; 2
    3788:	8d e1       	ldi	r24, 0x1D	; 29
    378a:	9b e1       	ldi	r25, 0x1B	; 27
    378c:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <xTaskGenericCreate>
	xTaskCreate(vUartSendTask, "UartSendTask", 300, NULL, 4, NULL);
    3790:	20 e0       	ldi	r18, 0x00	; 0
    3792:	30 e0       	ldi	r19, 0x00	; 0
    3794:	4c e2       	ldi	r20, 0x2C	; 44
    3796:	51 e0       	ldi	r21, 0x01	; 1
    3798:	61 ee       	ldi	r22, 0xE1	; 225
    379a:	72 e0       	ldi	r23, 0x02	; 2
    379c:	85 e4       	ldi	r24, 0x45	; 69
    379e:	9b e1       	ldi	r25, 0x1B	; 27
    37a0:	0e 94 7a 12 	call	0x24f4	; 0x24f4 <xTaskGenericCreate>
	
	xUartMutex = xSemaphoreCreateMutex();
    37a4:	81 e0       	ldi	r24, 0x01	; 1
    37a6:	0e 94 44 0c 	call	0x1888	; 0x1888 <xQueueCreateMutex>
    37aa:	90 93 f1 16 	sts	0x16F1, r25	; 0x8016f1 <xUartMutex+0x1>
    37ae:	80 93 f0 16 	sts	0x16F0, r24	; 0x8016f0 <xUartMutex>
}
    37b2:	0f 91       	pop	r16
    37b4:	ff 90       	pop	r15
    37b6:	ef 90       	pop	r14
    37b8:	df 90       	pop	r13
    37ba:	cf 90       	pop	r12
    37bc:	bf 90       	pop	r11
    37be:	af 90       	pop	r10
    37c0:	08 95       	ret

000037c2 <vUSART_send>:

void vUSART_send(uint8_t *data, uint16_t len) {
    37c2:	0f 93       	push	r16
    37c4:	1f 93       	push	r17
    37c6:	cf 93       	push	r28
    37c8:	df 93       	push	r29
    37ca:	ec 01       	movw	r28, r24
    37cc:	8b 01       	movw	r16, r22
	xSemaphoreTake(xUartMutex, portMAX_DELAY);
    37ce:	20 e0       	ldi	r18, 0x00	; 0
    37d0:	4f ef       	ldi	r20, 0xFF	; 255
    37d2:	5f ef       	ldi	r21, 0xFF	; 255
    37d4:	60 e0       	ldi	r22, 0x00	; 0
    37d6:	70 e0       	ldi	r23, 0x00	; 0
    37d8:	80 91 f0 16 	lds	r24, 0x16F0	; 0x8016f0 <xUartMutex>
    37dc:	90 91 f1 16 	lds	r25, 0x16F1	; 0x8016f1 <xUartMutex+0x1>
    37e0:	0e 94 58 0f 	call	0x1eb0	; 0x1eb0 <xQueueGenericReceive>
	buffer_append(&send_buffer, data, len);
    37e4:	a8 01       	movw	r20, r16
    37e6:	be 01       	movw	r22, r28
    37e8:	85 e9       	ldi	r24, 0x95	; 149
    37ea:	97 e1       	ldi	r25, 0x17	; 23
    37ec:	0e 94 36 03 	call	0x66c	; 0x66c <buffer_append>
	xSemaphoreGive(xUartMutex);
    37f0:	60 e0       	ldi	r22, 0x00	; 0
    37f2:	70 e0       	ldi	r23, 0x00	; 0
    37f4:	80 91 f0 16 	lds	r24, 0x16F0	; 0x8016f0 <xUartMutex>
    37f8:	90 91 f1 16 	lds	r25, 0x16F1	; 0x8016f1 <xUartMutex+0x1>
    37fc:	0e 94 c0 0d 	call	0x1b80	; 0x1b80 <xQueueGive>
}
    3800:	df 91       	pop	r29
    3802:	cf 91       	pop	r28
    3804:	1f 91       	pop	r17
    3806:	0f 91       	pop	r16
    3808:	08 95       	ret

0000380a <vUSART_set_receive_callback>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
    380a:	90 93 30 17 	sts	0x1730, r25	; 0x801730 <receive_callback+0x1>
    380e:	80 93 2f 17 	sts	0x172F, r24	; 0x80172f <receive_callback>
    3812:	08 95       	ret

00003814 <__vector_51>:
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
	}
}

ISR(USART2_RX_vect){
    3814:	1f 92       	push	r1
    3816:	0f 92       	push	r0
    3818:	0f b6       	in	r0, 0x3f	; 63
    381a:	0f 92       	push	r0
    381c:	11 24       	eor	r1, r1
    381e:	0b b6       	in	r0, 0x3b	; 59
    3820:	0f 92       	push	r0
    3822:	cf 92       	push	r12
    3824:	df 92       	push	r13
    3826:	ef 92       	push	r14
    3828:	ff 92       	push	r15
    382a:	0f 93       	push	r16
    382c:	1f 93       	push	r17
    382e:	2f 93       	push	r18
    3830:	3f 93       	push	r19
    3832:	4f 93       	push	r20
    3834:	5f 93       	push	r21
    3836:	6f 93       	push	r22
    3838:	7f 93       	push	r23
    383a:	8f 93       	push	r24
    383c:	9f 93       	push	r25
    383e:	af 93       	push	r26
    3840:	bf 93       	push	r27
    3842:	cf 93       	push	r28
    3844:	df 93       	push	r29
    3846:	ef 93       	push	r30
    3848:	ff 93       	push	r31
	static uint8_t input_buffer[100];
	static uint16_t input_index = 0;
	input_buffer[input_index++] = UDR2;
    384a:	80 91 c8 16 	lds	r24, 0x16C8	; 0x8016c8 <input_index.2064>
    384e:	90 91 c9 16 	lds	r25, 0x16C9	; 0x8016c9 <input_index.2064+0x1>
    3852:	ec 01       	movw	r28, r24
    3854:	21 96       	adiw	r28, 0x01	; 1
    3856:	d0 93 c9 16 	sts	0x16C9, r29	; 0x8016c9 <input_index.2064+0x1>
    385a:	c0 93 c8 16 	sts	0x16C8, r28	; 0x8016c8 <input_index.2064>
    385e:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    3862:	fc 01       	movw	r30, r24
    3864:	ec 59       	subi	r30, 0x9C	; 156
    3866:	f9 4e       	sbci	r31, 0xE9	; 233
    3868:	20 83       	st	Z, r18
	if(input_buffer[input_index-1] == 0x00) {
    386a:	21 11       	cpse	r18, r1
    386c:	1c c0       	rjmp	.+56     	; 0x38a6 <__vector_51+0x92>
		if(frame_receiver != NULL) {
    386e:	c0 90 ca 16 	lds	r12, 0x16CA	; 0x8016ca <frame_receiver>
    3872:	d0 90 cb 16 	lds	r13, 0x16CB	; 0x8016cb <frame_receiver+0x1>
    3876:	c1 14       	cp	r12, r1
    3878:	d1 04       	cpc	r13, r1
    387a:	81 f0       	breq	.+32     	; 0x389c <__vector_51+0x88>
			memcpy(receive_buffer, input_buffer, input_index);
    387c:	ae 01       	movw	r20, r28
    387e:	64 e6       	ldi	r22, 0x64	; 100
    3880:	76 e1       	ldi	r23, 0x16	; 22
    3882:	81 e3       	ldi	r24, 0x31	; 49
    3884:	97 e1       	ldi	r25, 0x17	; 23
    3886:	ac d4       	rcall	.+2392   	; 0x41e0 <memcpy>
			xTaskNotifyFromISR(frame_receiver, input_index, eSetValueWithoutOverwrite, NULL);
    3888:	ae 01       	movw	r20, r28
    388a:	60 e0       	ldi	r22, 0x00	; 0
    388c:	70 e0       	ldi	r23, 0x00	; 0
    388e:	e1 2c       	mov	r14, r1
    3890:	f1 2c       	mov	r15, r1
    3892:	00 e0       	ldi	r16, 0x00	; 0
    3894:	10 e0       	ldi	r17, 0x00	; 0
    3896:	24 e0       	ldi	r18, 0x04	; 4
    3898:	c6 01       	movw	r24, r12
    389a:	41 de       	rcall	.-894    	; 0x351e <xTaskGenericNotifyFromISR>
		}
		input_index = 0;
    389c:	10 92 c9 16 	sts	0x16C9, r1	; 0x8016c9 <input_index.2064+0x1>
    38a0:	10 92 c8 16 	sts	0x16C8, r1	; 0x8016c8 <input_index.2064>
    38a4:	07 c0       	rjmp	.+14     	; 0x38b4 <__vector_51+0xa0>
	}
	if(input_index > 100) input_index = 0; // Something went wrong, received too many bytes
    38a6:	c5 36       	cpi	r28, 0x65	; 101
    38a8:	d1 05       	cpc	r29, r1
    38aa:	20 f0       	brcs	.+8      	; 0x38b4 <__vector_51+0xa0>
    38ac:	10 92 c9 16 	sts	0x16C9, r1	; 0x8016c9 <input_index.2064+0x1>
    38b0:	10 92 c8 16 	sts	0x16C8, r1	; 0x8016c8 <input_index.2064>
    38b4:	ff 91       	pop	r31
    38b6:	ef 91       	pop	r30
    38b8:	df 91       	pop	r29
    38ba:	cf 91       	pop	r28
    38bc:	bf 91       	pop	r27
    38be:	af 91       	pop	r26
    38c0:	9f 91       	pop	r25
    38c2:	8f 91       	pop	r24
    38c4:	7f 91       	pop	r23
    38c6:	6f 91       	pop	r22
    38c8:	5f 91       	pop	r21
    38ca:	4f 91       	pop	r20
    38cc:	3f 91       	pop	r19
    38ce:	2f 91       	pop	r18
    38d0:	1f 91       	pop	r17
    38d2:	0f 91       	pop	r16
    38d4:	ff 90       	pop	r15
    38d6:	ef 90       	pop	r14
    38d8:	df 90       	pop	r13
    38da:	cf 90       	pop	r12
    38dc:	0f 90       	pop	r0
    38de:	0b be       	out	0x3b, r0	; 59
    38e0:	0f 90       	pop	r0
    38e2:	0f be       	out	0x3f, r0	; 63
    38e4:	0f 90       	pop	r0
    38e6:	1f 90       	pop	r1
    38e8:	18 95       	reti

000038ea <vfprintf>:
    38ea:	2f 92       	push	r2
    38ec:	3f 92       	push	r3
    38ee:	4f 92       	push	r4
    38f0:	5f 92       	push	r5
    38f2:	6f 92       	push	r6
    38f4:	7f 92       	push	r7
    38f6:	8f 92       	push	r8
    38f8:	9f 92       	push	r9
    38fa:	af 92       	push	r10
    38fc:	bf 92       	push	r11
    38fe:	cf 92       	push	r12
    3900:	df 92       	push	r13
    3902:	ef 92       	push	r14
    3904:	ff 92       	push	r15
    3906:	0f 93       	push	r16
    3908:	1f 93       	push	r17
    390a:	cf 93       	push	r28
    390c:	df 93       	push	r29
    390e:	cd b7       	in	r28, 0x3d	; 61
    3910:	de b7       	in	r29, 0x3e	; 62
    3912:	60 97       	sbiw	r28, 0x10	; 16
    3914:	0f b6       	in	r0, 0x3f	; 63
    3916:	f8 94       	cli
    3918:	de bf       	out	0x3e, r29	; 62
    391a:	0f be       	out	0x3f, r0	; 63
    391c:	cd bf       	out	0x3d, r28	; 61
    391e:	7c 01       	movw	r14, r24
    3920:	1b 01       	movw	r2, r22
    3922:	6a 01       	movw	r12, r20
    3924:	fc 01       	movw	r30, r24
    3926:	17 82       	std	Z+7, r1	; 0x07
    3928:	16 82       	std	Z+6, r1	; 0x06
    392a:	83 81       	ldd	r24, Z+3	; 0x03
    392c:	81 ff       	sbrs	r24, 1
    392e:	2a c3       	rjmp	.+1620   	; 0x3f84 <vfprintf+0x69a>
    3930:	9e 01       	movw	r18, r28
    3932:	2f 5f       	subi	r18, 0xFF	; 255
    3934:	3f 4f       	sbci	r19, 0xFF	; 255
    3936:	39 01       	movw	r6, r18
    3938:	f7 01       	movw	r30, r14
    393a:	93 81       	ldd	r25, Z+3	; 0x03
    393c:	f1 01       	movw	r30, r2
    393e:	93 fd       	sbrc	r25, 3
    3940:	85 91       	lpm	r24, Z+
    3942:	93 ff       	sbrs	r25, 3
    3944:	81 91       	ld	r24, Z+
    3946:	1f 01       	movw	r2, r30
    3948:	88 23       	and	r24, r24
    394a:	09 f4       	brne	.+2      	; 0x394e <vfprintf+0x64>
    394c:	17 c3       	rjmp	.+1582   	; 0x3f7c <vfprintf+0x692>
    394e:	85 32       	cpi	r24, 0x25	; 37
    3950:	39 f4       	brne	.+14     	; 0x3960 <vfprintf+0x76>
    3952:	93 fd       	sbrc	r25, 3
    3954:	85 91       	lpm	r24, Z+
    3956:	93 ff       	sbrs	r25, 3
    3958:	81 91       	ld	r24, Z+
    395a:	1f 01       	movw	r2, r30
    395c:	85 32       	cpi	r24, 0x25	; 37
    395e:	31 f4       	brne	.+12     	; 0x396c <vfprintf+0x82>
    3960:	b7 01       	movw	r22, r14
    3962:	90 e0       	ldi	r25, 0x00	; 0
    3964:	51 d4       	rcall	.+2210   	; 0x4208 <fputc>
    3966:	56 01       	movw	r10, r12
    3968:	65 01       	movw	r12, r10
    396a:	e6 cf       	rjmp	.-52     	; 0x3938 <vfprintf+0x4e>
    396c:	10 e0       	ldi	r17, 0x00	; 0
    396e:	51 2c       	mov	r5, r1
    3970:	91 2c       	mov	r9, r1
    3972:	ff e1       	ldi	r31, 0x1F	; 31
    3974:	f9 15       	cp	r31, r9
    3976:	d8 f0       	brcs	.+54     	; 0x39ae <vfprintf+0xc4>
    3978:	8b 32       	cpi	r24, 0x2B	; 43
    397a:	79 f0       	breq	.+30     	; 0x399a <vfprintf+0xb0>
    397c:	38 f4       	brcc	.+14     	; 0x398c <vfprintf+0xa2>
    397e:	80 32       	cpi	r24, 0x20	; 32
    3980:	79 f0       	breq	.+30     	; 0x39a0 <vfprintf+0xb6>
    3982:	83 32       	cpi	r24, 0x23	; 35
    3984:	a1 f4       	brne	.+40     	; 0x39ae <vfprintf+0xc4>
    3986:	f9 2d       	mov	r31, r9
    3988:	f0 61       	ori	r31, 0x10	; 16
    398a:	2e c0       	rjmp	.+92     	; 0x39e8 <vfprintf+0xfe>
    398c:	8d 32       	cpi	r24, 0x2D	; 45
    398e:	61 f0       	breq	.+24     	; 0x39a8 <vfprintf+0xbe>
    3990:	80 33       	cpi	r24, 0x30	; 48
    3992:	69 f4       	brne	.+26     	; 0x39ae <vfprintf+0xc4>
    3994:	29 2d       	mov	r18, r9
    3996:	21 60       	ori	r18, 0x01	; 1
    3998:	2d c0       	rjmp	.+90     	; 0x39f4 <vfprintf+0x10a>
    399a:	39 2d       	mov	r19, r9
    399c:	32 60       	ori	r19, 0x02	; 2
    399e:	93 2e       	mov	r9, r19
    39a0:	89 2d       	mov	r24, r9
    39a2:	84 60       	ori	r24, 0x04	; 4
    39a4:	98 2e       	mov	r9, r24
    39a6:	2a c0       	rjmp	.+84     	; 0x39fc <vfprintf+0x112>
    39a8:	e9 2d       	mov	r30, r9
    39aa:	e8 60       	ori	r30, 0x08	; 8
    39ac:	15 c0       	rjmp	.+42     	; 0x39d8 <vfprintf+0xee>
    39ae:	97 fc       	sbrc	r9, 7
    39b0:	2d c0       	rjmp	.+90     	; 0x3a0c <vfprintf+0x122>
    39b2:	20 ed       	ldi	r18, 0xD0	; 208
    39b4:	28 0f       	add	r18, r24
    39b6:	2a 30       	cpi	r18, 0x0A	; 10
    39b8:	88 f4       	brcc	.+34     	; 0x39dc <vfprintf+0xf2>
    39ba:	96 fe       	sbrs	r9, 6
    39bc:	06 c0       	rjmp	.+12     	; 0x39ca <vfprintf+0xe0>
    39be:	3a e0       	ldi	r19, 0x0A	; 10
    39c0:	13 9f       	mul	r17, r19
    39c2:	20 0d       	add	r18, r0
    39c4:	11 24       	eor	r1, r1
    39c6:	12 2f       	mov	r17, r18
    39c8:	19 c0       	rjmp	.+50     	; 0x39fc <vfprintf+0x112>
    39ca:	8a e0       	ldi	r24, 0x0A	; 10
    39cc:	58 9e       	mul	r5, r24
    39ce:	20 0d       	add	r18, r0
    39d0:	11 24       	eor	r1, r1
    39d2:	52 2e       	mov	r5, r18
    39d4:	e9 2d       	mov	r30, r9
    39d6:	e0 62       	ori	r30, 0x20	; 32
    39d8:	9e 2e       	mov	r9, r30
    39da:	10 c0       	rjmp	.+32     	; 0x39fc <vfprintf+0x112>
    39dc:	8e 32       	cpi	r24, 0x2E	; 46
    39de:	31 f4       	brne	.+12     	; 0x39ec <vfprintf+0x102>
    39e0:	96 fc       	sbrc	r9, 6
    39e2:	cc c2       	rjmp	.+1432   	; 0x3f7c <vfprintf+0x692>
    39e4:	f9 2d       	mov	r31, r9
    39e6:	f0 64       	ori	r31, 0x40	; 64
    39e8:	9f 2e       	mov	r9, r31
    39ea:	08 c0       	rjmp	.+16     	; 0x39fc <vfprintf+0x112>
    39ec:	8c 36       	cpi	r24, 0x6C	; 108
    39ee:	21 f4       	brne	.+8      	; 0x39f8 <vfprintf+0x10e>
    39f0:	29 2d       	mov	r18, r9
    39f2:	20 68       	ori	r18, 0x80	; 128
    39f4:	92 2e       	mov	r9, r18
    39f6:	02 c0       	rjmp	.+4      	; 0x39fc <vfprintf+0x112>
    39f8:	88 36       	cpi	r24, 0x68	; 104
    39fa:	41 f4       	brne	.+16     	; 0x3a0c <vfprintf+0x122>
    39fc:	f1 01       	movw	r30, r2
    39fe:	93 fd       	sbrc	r25, 3
    3a00:	85 91       	lpm	r24, Z+
    3a02:	93 ff       	sbrs	r25, 3
    3a04:	81 91       	ld	r24, Z+
    3a06:	1f 01       	movw	r2, r30
    3a08:	81 11       	cpse	r24, r1
    3a0a:	b3 cf       	rjmp	.-154    	; 0x3972 <vfprintf+0x88>
    3a0c:	9b eb       	ldi	r25, 0xBB	; 187
    3a0e:	98 0f       	add	r25, r24
    3a10:	93 30       	cpi	r25, 0x03	; 3
    3a12:	20 f4       	brcc	.+8      	; 0x3a1c <vfprintf+0x132>
    3a14:	99 2d       	mov	r25, r9
    3a16:	90 61       	ori	r25, 0x10	; 16
    3a18:	80 5e       	subi	r24, 0xE0	; 224
    3a1a:	07 c0       	rjmp	.+14     	; 0x3a2a <vfprintf+0x140>
    3a1c:	9b e9       	ldi	r25, 0x9B	; 155
    3a1e:	98 0f       	add	r25, r24
    3a20:	93 30       	cpi	r25, 0x03	; 3
    3a22:	08 f0       	brcs	.+2      	; 0x3a26 <vfprintf+0x13c>
    3a24:	59 c1       	rjmp	.+690    	; 0x3cd8 <vfprintf+0x3ee>
    3a26:	99 2d       	mov	r25, r9
    3a28:	9f 7e       	andi	r25, 0xEF	; 239
    3a2a:	96 ff       	sbrs	r25, 6
    3a2c:	16 e0       	ldi	r17, 0x06	; 6
    3a2e:	9f 73       	andi	r25, 0x3F	; 63
    3a30:	99 2e       	mov	r9, r25
    3a32:	85 36       	cpi	r24, 0x65	; 101
    3a34:	19 f4       	brne	.+6      	; 0x3a3c <vfprintf+0x152>
    3a36:	90 64       	ori	r25, 0x40	; 64
    3a38:	99 2e       	mov	r9, r25
    3a3a:	08 c0       	rjmp	.+16     	; 0x3a4c <vfprintf+0x162>
    3a3c:	86 36       	cpi	r24, 0x66	; 102
    3a3e:	21 f4       	brne	.+8      	; 0x3a48 <vfprintf+0x15e>
    3a40:	39 2f       	mov	r19, r25
    3a42:	30 68       	ori	r19, 0x80	; 128
    3a44:	93 2e       	mov	r9, r19
    3a46:	02 c0       	rjmp	.+4      	; 0x3a4c <vfprintf+0x162>
    3a48:	11 11       	cpse	r17, r1
    3a4a:	11 50       	subi	r17, 0x01	; 1
    3a4c:	97 fe       	sbrs	r9, 7
    3a4e:	07 c0       	rjmp	.+14     	; 0x3a5e <vfprintf+0x174>
    3a50:	1c 33       	cpi	r17, 0x3C	; 60
    3a52:	50 f4       	brcc	.+20     	; 0x3a68 <vfprintf+0x17e>
    3a54:	44 24       	eor	r4, r4
    3a56:	43 94       	inc	r4
    3a58:	41 0e       	add	r4, r17
    3a5a:	27 e0       	ldi	r18, 0x07	; 7
    3a5c:	0b c0       	rjmp	.+22     	; 0x3a74 <vfprintf+0x18a>
    3a5e:	18 30       	cpi	r17, 0x08	; 8
    3a60:	38 f0       	brcs	.+14     	; 0x3a70 <vfprintf+0x186>
    3a62:	27 e0       	ldi	r18, 0x07	; 7
    3a64:	17 e0       	ldi	r17, 0x07	; 7
    3a66:	05 c0       	rjmp	.+10     	; 0x3a72 <vfprintf+0x188>
    3a68:	27 e0       	ldi	r18, 0x07	; 7
    3a6a:	9c e3       	ldi	r25, 0x3C	; 60
    3a6c:	49 2e       	mov	r4, r25
    3a6e:	02 c0       	rjmp	.+4      	; 0x3a74 <vfprintf+0x18a>
    3a70:	21 2f       	mov	r18, r17
    3a72:	41 2c       	mov	r4, r1
    3a74:	56 01       	movw	r10, r12
    3a76:	84 e0       	ldi	r24, 0x04	; 4
    3a78:	a8 0e       	add	r10, r24
    3a7a:	b1 1c       	adc	r11, r1
    3a7c:	f6 01       	movw	r30, r12
    3a7e:	60 81       	ld	r22, Z
    3a80:	71 81       	ldd	r23, Z+1	; 0x01
    3a82:	82 81       	ldd	r24, Z+2	; 0x02
    3a84:	93 81       	ldd	r25, Z+3	; 0x03
    3a86:	04 2d       	mov	r16, r4
    3a88:	a3 01       	movw	r20, r6
    3a8a:	c7 d2       	rcall	.+1422   	; 0x401a <__ftoa_engine>
    3a8c:	6c 01       	movw	r12, r24
    3a8e:	f9 81       	ldd	r31, Y+1	; 0x01
    3a90:	fc 87       	std	Y+12, r31	; 0x0c
    3a92:	f0 ff       	sbrs	r31, 0
    3a94:	02 c0       	rjmp	.+4      	; 0x3a9a <vfprintf+0x1b0>
    3a96:	f3 ff       	sbrs	r31, 3
    3a98:	06 c0       	rjmp	.+12     	; 0x3aa6 <vfprintf+0x1bc>
    3a9a:	91 fc       	sbrc	r9, 1
    3a9c:	06 c0       	rjmp	.+12     	; 0x3aaa <vfprintf+0x1c0>
    3a9e:	92 fe       	sbrs	r9, 2
    3aa0:	06 c0       	rjmp	.+12     	; 0x3aae <vfprintf+0x1c4>
    3aa2:	00 e2       	ldi	r16, 0x20	; 32
    3aa4:	05 c0       	rjmp	.+10     	; 0x3ab0 <vfprintf+0x1c6>
    3aa6:	0d e2       	ldi	r16, 0x2D	; 45
    3aa8:	03 c0       	rjmp	.+6      	; 0x3ab0 <vfprintf+0x1c6>
    3aaa:	0b e2       	ldi	r16, 0x2B	; 43
    3aac:	01 c0       	rjmp	.+2      	; 0x3ab0 <vfprintf+0x1c6>
    3aae:	00 e0       	ldi	r16, 0x00	; 0
    3ab0:	8c 85       	ldd	r24, Y+12	; 0x0c
    3ab2:	8c 70       	andi	r24, 0x0C	; 12
    3ab4:	19 f0       	breq	.+6      	; 0x3abc <vfprintf+0x1d2>
    3ab6:	01 11       	cpse	r16, r1
    3ab8:	43 c2       	rjmp	.+1158   	; 0x3f40 <vfprintf+0x656>
    3aba:	80 c2       	rjmp	.+1280   	; 0x3fbc <vfprintf+0x6d2>
    3abc:	97 fe       	sbrs	r9, 7
    3abe:	10 c0       	rjmp	.+32     	; 0x3ae0 <vfprintf+0x1f6>
    3ac0:	4c 0c       	add	r4, r12
    3ac2:	fc 85       	ldd	r31, Y+12	; 0x0c
    3ac4:	f4 ff       	sbrs	r31, 4
    3ac6:	04 c0       	rjmp	.+8      	; 0x3ad0 <vfprintf+0x1e6>
    3ac8:	8a 81       	ldd	r24, Y+2	; 0x02
    3aca:	81 33       	cpi	r24, 0x31	; 49
    3acc:	09 f4       	brne	.+2      	; 0x3ad0 <vfprintf+0x1e6>
    3ace:	4a 94       	dec	r4
    3ad0:	14 14       	cp	r1, r4
    3ad2:	74 f5       	brge	.+92     	; 0x3b30 <vfprintf+0x246>
    3ad4:	28 e0       	ldi	r18, 0x08	; 8
    3ad6:	24 15       	cp	r18, r4
    3ad8:	78 f5       	brcc	.+94     	; 0x3b38 <vfprintf+0x24e>
    3ada:	88 e0       	ldi	r24, 0x08	; 8
    3adc:	48 2e       	mov	r4, r24
    3ade:	2c c0       	rjmp	.+88     	; 0x3b38 <vfprintf+0x24e>
    3ae0:	96 fc       	sbrc	r9, 6
    3ae2:	2a c0       	rjmp	.+84     	; 0x3b38 <vfprintf+0x24e>
    3ae4:	81 2f       	mov	r24, r17
    3ae6:	90 e0       	ldi	r25, 0x00	; 0
    3ae8:	8c 15       	cp	r24, r12
    3aea:	9d 05       	cpc	r25, r13
    3aec:	9c f0       	brlt	.+38     	; 0x3b14 <vfprintf+0x22a>
    3aee:	3c ef       	ldi	r19, 0xFC	; 252
    3af0:	c3 16       	cp	r12, r19
    3af2:	3f ef       	ldi	r19, 0xFF	; 255
    3af4:	d3 06       	cpc	r13, r19
    3af6:	74 f0       	brlt	.+28     	; 0x3b14 <vfprintf+0x22a>
    3af8:	89 2d       	mov	r24, r9
    3afa:	80 68       	ori	r24, 0x80	; 128
    3afc:	98 2e       	mov	r9, r24
    3afe:	0a c0       	rjmp	.+20     	; 0x3b14 <vfprintf+0x22a>
    3b00:	e2 e0       	ldi	r30, 0x02	; 2
    3b02:	f0 e0       	ldi	r31, 0x00	; 0
    3b04:	ec 0f       	add	r30, r28
    3b06:	fd 1f       	adc	r31, r29
    3b08:	e1 0f       	add	r30, r17
    3b0a:	f1 1d       	adc	r31, r1
    3b0c:	80 81       	ld	r24, Z
    3b0e:	80 33       	cpi	r24, 0x30	; 48
    3b10:	19 f4       	brne	.+6      	; 0x3b18 <vfprintf+0x22e>
    3b12:	11 50       	subi	r17, 0x01	; 1
    3b14:	11 11       	cpse	r17, r1
    3b16:	f4 cf       	rjmp	.-24     	; 0x3b00 <vfprintf+0x216>
    3b18:	97 fe       	sbrs	r9, 7
    3b1a:	0e c0       	rjmp	.+28     	; 0x3b38 <vfprintf+0x24e>
    3b1c:	44 24       	eor	r4, r4
    3b1e:	43 94       	inc	r4
    3b20:	41 0e       	add	r4, r17
    3b22:	81 2f       	mov	r24, r17
    3b24:	90 e0       	ldi	r25, 0x00	; 0
    3b26:	c8 16       	cp	r12, r24
    3b28:	d9 06       	cpc	r13, r25
    3b2a:	2c f4       	brge	.+10     	; 0x3b36 <vfprintf+0x24c>
    3b2c:	1c 19       	sub	r17, r12
    3b2e:	04 c0       	rjmp	.+8      	; 0x3b38 <vfprintf+0x24e>
    3b30:	44 24       	eor	r4, r4
    3b32:	43 94       	inc	r4
    3b34:	01 c0       	rjmp	.+2      	; 0x3b38 <vfprintf+0x24e>
    3b36:	10 e0       	ldi	r17, 0x00	; 0
    3b38:	97 fe       	sbrs	r9, 7
    3b3a:	06 c0       	rjmp	.+12     	; 0x3b48 <vfprintf+0x25e>
    3b3c:	1c 14       	cp	r1, r12
    3b3e:	1d 04       	cpc	r1, r13
    3b40:	34 f4       	brge	.+12     	; 0x3b4e <vfprintf+0x264>
    3b42:	c6 01       	movw	r24, r12
    3b44:	01 96       	adiw	r24, 0x01	; 1
    3b46:	05 c0       	rjmp	.+10     	; 0x3b52 <vfprintf+0x268>
    3b48:	85 e0       	ldi	r24, 0x05	; 5
    3b4a:	90 e0       	ldi	r25, 0x00	; 0
    3b4c:	02 c0       	rjmp	.+4      	; 0x3b52 <vfprintf+0x268>
    3b4e:	81 e0       	ldi	r24, 0x01	; 1
    3b50:	90 e0       	ldi	r25, 0x00	; 0
    3b52:	01 11       	cpse	r16, r1
    3b54:	01 96       	adiw	r24, 0x01	; 1
    3b56:	11 23       	and	r17, r17
    3b58:	31 f0       	breq	.+12     	; 0x3b66 <vfprintf+0x27c>
    3b5a:	21 2f       	mov	r18, r17
    3b5c:	30 e0       	ldi	r19, 0x00	; 0
    3b5e:	2f 5f       	subi	r18, 0xFF	; 255
    3b60:	3f 4f       	sbci	r19, 0xFF	; 255
    3b62:	82 0f       	add	r24, r18
    3b64:	93 1f       	adc	r25, r19
    3b66:	25 2d       	mov	r18, r5
    3b68:	30 e0       	ldi	r19, 0x00	; 0
    3b6a:	82 17       	cp	r24, r18
    3b6c:	93 07       	cpc	r25, r19
    3b6e:	14 f4       	brge	.+4      	; 0x3b74 <vfprintf+0x28a>
    3b70:	58 1a       	sub	r5, r24
    3b72:	01 c0       	rjmp	.+2      	; 0x3b76 <vfprintf+0x28c>
    3b74:	51 2c       	mov	r5, r1
    3b76:	89 2d       	mov	r24, r9
    3b78:	89 70       	andi	r24, 0x09	; 9
    3b7a:	41 f4       	brne	.+16     	; 0x3b8c <vfprintf+0x2a2>
    3b7c:	55 20       	and	r5, r5
    3b7e:	31 f0       	breq	.+12     	; 0x3b8c <vfprintf+0x2a2>
    3b80:	b7 01       	movw	r22, r14
    3b82:	80 e2       	ldi	r24, 0x20	; 32
    3b84:	90 e0       	ldi	r25, 0x00	; 0
    3b86:	40 d3       	rcall	.+1664   	; 0x4208 <fputc>
    3b88:	5a 94       	dec	r5
    3b8a:	f8 cf       	rjmp	.-16     	; 0x3b7c <vfprintf+0x292>
    3b8c:	00 23       	and	r16, r16
    3b8e:	21 f0       	breq	.+8      	; 0x3b98 <vfprintf+0x2ae>
    3b90:	b7 01       	movw	r22, r14
    3b92:	80 2f       	mov	r24, r16
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	38 d3       	rcall	.+1648   	; 0x4208 <fputc>
    3b98:	93 fc       	sbrc	r9, 3
    3b9a:	08 c0       	rjmp	.+16     	; 0x3bac <vfprintf+0x2c2>
    3b9c:	55 20       	and	r5, r5
    3b9e:	31 f0       	breq	.+12     	; 0x3bac <vfprintf+0x2c2>
    3ba0:	b7 01       	movw	r22, r14
    3ba2:	80 e3       	ldi	r24, 0x30	; 48
    3ba4:	90 e0       	ldi	r25, 0x00	; 0
    3ba6:	30 d3       	rcall	.+1632   	; 0x4208 <fputc>
    3ba8:	5a 94       	dec	r5
    3baa:	f8 cf       	rjmp	.-16     	; 0x3b9c <vfprintf+0x2b2>
    3bac:	97 fe       	sbrs	r9, 7
    3bae:	4a c0       	rjmp	.+148    	; 0x3c44 <vfprintf+0x35a>
    3bb0:	46 01       	movw	r8, r12
    3bb2:	d7 fe       	sbrs	r13, 7
    3bb4:	02 c0       	rjmp	.+4      	; 0x3bba <vfprintf+0x2d0>
    3bb6:	81 2c       	mov	r8, r1
    3bb8:	91 2c       	mov	r9, r1
    3bba:	c6 01       	movw	r24, r12
    3bbc:	88 19       	sub	r24, r8
    3bbe:	99 09       	sbc	r25, r9
    3bc0:	f3 01       	movw	r30, r6
    3bc2:	e8 0f       	add	r30, r24
    3bc4:	f9 1f       	adc	r31, r25
    3bc6:	fe 87       	std	Y+14, r31	; 0x0e
    3bc8:	ed 87       	std	Y+13, r30	; 0x0d
    3bca:	96 01       	movw	r18, r12
    3bcc:	24 19       	sub	r18, r4
    3bce:	31 09       	sbc	r19, r1
    3bd0:	38 8b       	std	Y+16, r19	; 0x10
    3bd2:	2f 87       	std	Y+15, r18	; 0x0f
    3bd4:	01 2f       	mov	r16, r17
    3bd6:	10 e0       	ldi	r17, 0x00	; 0
    3bd8:	11 95       	neg	r17
    3bda:	01 95       	neg	r16
    3bdc:	11 09       	sbc	r17, r1
    3bde:	3f ef       	ldi	r19, 0xFF	; 255
    3be0:	83 16       	cp	r8, r19
    3be2:	93 06       	cpc	r9, r19
    3be4:	21 f4       	brne	.+8      	; 0x3bee <vfprintf+0x304>
    3be6:	b7 01       	movw	r22, r14
    3be8:	8e e2       	ldi	r24, 0x2E	; 46
    3bea:	90 e0       	ldi	r25, 0x00	; 0
    3bec:	0d d3       	rcall	.+1562   	; 0x4208 <fputc>
    3bee:	c8 14       	cp	r12, r8
    3bf0:	d9 04       	cpc	r13, r9
    3bf2:	4c f0       	brlt	.+18     	; 0x3c06 <vfprintf+0x31c>
    3bf4:	8f 85       	ldd	r24, Y+15	; 0x0f
    3bf6:	98 89       	ldd	r25, Y+16	; 0x10
    3bf8:	88 15       	cp	r24, r8
    3bfa:	99 05       	cpc	r25, r9
    3bfc:	24 f4       	brge	.+8      	; 0x3c06 <vfprintf+0x31c>
    3bfe:	ed 85       	ldd	r30, Y+13	; 0x0d
    3c00:	fe 85       	ldd	r31, Y+14	; 0x0e
    3c02:	81 81       	ldd	r24, Z+1	; 0x01
    3c04:	01 c0       	rjmp	.+2      	; 0x3c08 <vfprintf+0x31e>
    3c06:	80 e3       	ldi	r24, 0x30	; 48
    3c08:	f1 e0       	ldi	r31, 0x01	; 1
    3c0a:	8f 1a       	sub	r8, r31
    3c0c:	91 08       	sbc	r9, r1
    3c0e:	2d 85       	ldd	r18, Y+13	; 0x0d
    3c10:	3e 85       	ldd	r19, Y+14	; 0x0e
    3c12:	2f 5f       	subi	r18, 0xFF	; 255
    3c14:	3f 4f       	sbci	r19, 0xFF	; 255
    3c16:	3e 87       	std	Y+14, r19	; 0x0e
    3c18:	2d 87       	std	Y+13, r18	; 0x0d
    3c1a:	80 16       	cp	r8, r16
    3c1c:	91 06       	cpc	r9, r17
    3c1e:	24 f0       	brlt	.+8      	; 0x3c28 <vfprintf+0x33e>
    3c20:	b7 01       	movw	r22, r14
    3c22:	90 e0       	ldi	r25, 0x00	; 0
    3c24:	f1 d2       	rcall	.+1506   	; 0x4208 <fputc>
    3c26:	db cf       	rjmp	.-74     	; 0x3bde <vfprintf+0x2f4>
    3c28:	c8 14       	cp	r12, r8
    3c2a:	d9 04       	cpc	r13, r9
    3c2c:	41 f4       	brne	.+16     	; 0x3c3e <vfprintf+0x354>
    3c2e:	9a 81       	ldd	r25, Y+2	; 0x02
    3c30:	96 33       	cpi	r25, 0x36	; 54
    3c32:	20 f4       	brcc	.+8      	; 0x3c3c <vfprintf+0x352>
    3c34:	95 33       	cpi	r25, 0x35	; 53
    3c36:	19 f4       	brne	.+6      	; 0x3c3e <vfprintf+0x354>
    3c38:	3c 85       	ldd	r19, Y+12	; 0x0c
    3c3a:	34 ff       	sbrs	r19, 4
    3c3c:	81 e3       	ldi	r24, 0x31	; 49
    3c3e:	b7 01       	movw	r22, r14
    3c40:	90 e0       	ldi	r25, 0x00	; 0
    3c42:	48 c0       	rjmp	.+144    	; 0x3cd4 <vfprintf+0x3ea>
    3c44:	8a 81       	ldd	r24, Y+2	; 0x02
    3c46:	81 33       	cpi	r24, 0x31	; 49
    3c48:	19 f0       	breq	.+6      	; 0x3c50 <vfprintf+0x366>
    3c4a:	9c 85       	ldd	r25, Y+12	; 0x0c
    3c4c:	9f 7e       	andi	r25, 0xEF	; 239
    3c4e:	9c 87       	std	Y+12, r25	; 0x0c
    3c50:	b7 01       	movw	r22, r14
    3c52:	90 e0       	ldi	r25, 0x00	; 0
    3c54:	d9 d2       	rcall	.+1458   	; 0x4208 <fputc>
    3c56:	11 11       	cpse	r17, r1
    3c58:	05 c0       	rjmp	.+10     	; 0x3c64 <vfprintf+0x37a>
    3c5a:	94 fc       	sbrc	r9, 4
    3c5c:	16 c0       	rjmp	.+44     	; 0x3c8a <vfprintf+0x3a0>
    3c5e:	85 e6       	ldi	r24, 0x65	; 101
    3c60:	90 e0       	ldi	r25, 0x00	; 0
    3c62:	15 c0       	rjmp	.+42     	; 0x3c8e <vfprintf+0x3a4>
    3c64:	b7 01       	movw	r22, r14
    3c66:	8e e2       	ldi	r24, 0x2E	; 46
    3c68:	90 e0       	ldi	r25, 0x00	; 0
    3c6a:	ce d2       	rcall	.+1436   	; 0x4208 <fputc>
    3c6c:	1e 5f       	subi	r17, 0xFE	; 254
    3c6e:	82 e0       	ldi	r24, 0x02	; 2
    3c70:	01 e0       	ldi	r16, 0x01	; 1
    3c72:	08 0f       	add	r16, r24
    3c74:	f3 01       	movw	r30, r6
    3c76:	e8 0f       	add	r30, r24
    3c78:	f1 1d       	adc	r31, r1
    3c7a:	80 81       	ld	r24, Z
    3c7c:	b7 01       	movw	r22, r14
    3c7e:	90 e0       	ldi	r25, 0x00	; 0
    3c80:	c3 d2       	rcall	.+1414   	; 0x4208 <fputc>
    3c82:	80 2f       	mov	r24, r16
    3c84:	01 13       	cpse	r16, r17
    3c86:	f4 cf       	rjmp	.-24     	; 0x3c70 <vfprintf+0x386>
    3c88:	e8 cf       	rjmp	.-48     	; 0x3c5a <vfprintf+0x370>
    3c8a:	85 e4       	ldi	r24, 0x45	; 69
    3c8c:	90 e0       	ldi	r25, 0x00	; 0
    3c8e:	b7 01       	movw	r22, r14
    3c90:	bb d2       	rcall	.+1398   	; 0x4208 <fputc>
    3c92:	d7 fc       	sbrc	r13, 7
    3c94:	06 c0       	rjmp	.+12     	; 0x3ca2 <vfprintf+0x3b8>
    3c96:	c1 14       	cp	r12, r1
    3c98:	d1 04       	cpc	r13, r1
    3c9a:	41 f4       	brne	.+16     	; 0x3cac <vfprintf+0x3c2>
    3c9c:	ec 85       	ldd	r30, Y+12	; 0x0c
    3c9e:	e4 ff       	sbrs	r30, 4
    3ca0:	05 c0       	rjmp	.+10     	; 0x3cac <vfprintf+0x3c2>
    3ca2:	d1 94       	neg	r13
    3ca4:	c1 94       	neg	r12
    3ca6:	d1 08       	sbc	r13, r1
    3ca8:	8d e2       	ldi	r24, 0x2D	; 45
    3caa:	01 c0       	rjmp	.+2      	; 0x3cae <vfprintf+0x3c4>
    3cac:	8b e2       	ldi	r24, 0x2B	; 43
    3cae:	b7 01       	movw	r22, r14
    3cb0:	90 e0       	ldi	r25, 0x00	; 0
    3cb2:	aa d2       	rcall	.+1364   	; 0x4208 <fputc>
    3cb4:	80 e3       	ldi	r24, 0x30	; 48
    3cb6:	2a e0       	ldi	r18, 0x0A	; 10
    3cb8:	c2 16       	cp	r12, r18
    3cba:	d1 04       	cpc	r13, r1
    3cbc:	2c f0       	brlt	.+10     	; 0x3cc8 <vfprintf+0x3de>
    3cbe:	8f 5f       	subi	r24, 0xFF	; 255
    3cc0:	fa e0       	ldi	r31, 0x0A	; 10
    3cc2:	cf 1a       	sub	r12, r31
    3cc4:	d1 08       	sbc	r13, r1
    3cc6:	f7 cf       	rjmp	.-18     	; 0x3cb6 <vfprintf+0x3cc>
    3cc8:	b7 01       	movw	r22, r14
    3cca:	90 e0       	ldi	r25, 0x00	; 0
    3ccc:	9d d2       	rcall	.+1338   	; 0x4208 <fputc>
    3cce:	b7 01       	movw	r22, r14
    3cd0:	c6 01       	movw	r24, r12
    3cd2:	c0 96       	adiw	r24, 0x30	; 48
    3cd4:	99 d2       	rcall	.+1330   	; 0x4208 <fputc>
    3cd6:	49 c1       	rjmp	.+658    	; 0x3f6a <vfprintf+0x680>
    3cd8:	83 36       	cpi	r24, 0x63	; 99
    3cda:	31 f0       	breq	.+12     	; 0x3ce8 <vfprintf+0x3fe>
    3cdc:	83 37       	cpi	r24, 0x73	; 115
    3cde:	79 f0       	breq	.+30     	; 0x3cfe <vfprintf+0x414>
    3ce0:	83 35       	cpi	r24, 0x53	; 83
    3ce2:	09 f0       	breq	.+2      	; 0x3ce6 <vfprintf+0x3fc>
    3ce4:	52 c0       	rjmp	.+164    	; 0x3d8a <vfprintf+0x4a0>
    3ce6:	1f c0       	rjmp	.+62     	; 0x3d26 <vfprintf+0x43c>
    3ce8:	56 01       	movw	r10, r12
    3cea:	32 e0       	ldi	r19, 0x02	; 2
    3cec:	a3 0e       	add	r10, r19
    3cee:	b1 1c       	adc	r11, r1
    3cf0:	f6 01       	movw	r30, r12
    3cf2:	80 81       	ld	r24, Z
    3cf4:	89 83       	std	Y+1, r24	; 0x01
    3cf6:	01 e0       	ldi	r16, 0x01	; 1
    3cf8:	10 e0       	ldi	r17, 0x00	; 0
    3cfa:	63 01       	movw	r12, r6
    3cfc:	11 c0       	rjmp	.+34     	; 0x3d20 <vfprintf+0x436>
    3cfe:	56 01       	movw	r10, r12
    3d00:	f2 e0       	ldi	r31, 0x02	; 2
    3d02:	af 0e       	add	r10, r31
    3d04:	b1 1c       	adc	r11, r1
    3d06:	f6 01       	movw	r30, r12
    3d08:	c0 80       	ld	r12, Z
    3d0a:	d1 80       	ldd	r13, Z+1	; 0x01
    3d0c:	96 fe       	sbrs	r9, 6
    3d0e:	03 c0       	rjmp	.+6      	; 0x3d16 <vfprintf+0x42c>
    3d10:	61 2f       	mov	r22, r17
    3d12:	70 e0       	ldi	r23, 0x00	; 0
    3d14:	02 c0       	rjmp	.+4      	; 0x3d1a <vfprintf+0x430>
    3d16:	6f ef       	ldi	r22, 0xFF	; 255
    3d18:	7f ef       	ldi	r23, 0xFF	; 255
    3d1a:	c6 01       	movw	r24, r12
    3d1c:	6a d2       	rcall	.+1236   	; 0x41f2 <strnlen>
    3d1e:	8c 01       	movw	r16, r24
    3d20:	f9 2d       	mov	r31, r9
    3d22:	ff 77       	andi	r31, 0x7F	; 127
    3d24:	13 c0       	rjmp	.+38     	; 0x3d4c <vfprintf+0x462>
    3d26:	56 01       	movw	r10, r12
    3d28:	22 e0       	ldi	r18, 0x02	; 2
    3d2a:	a2 0e       	add	r10, r18
    3d2c:	b1 1c       	adc	r11, r1
    3d2e:	f6 01       	movw	r30, r12
    3d30:	c0 80       	ld	r12, Z
    3d32:	d1 80       	ldd	r13, Z+1	; 0x01
    3d34:	96 fe       	sbrs	r9, 6
    3d36:	03 c0       	rjmp	.+6      	; 0x3d3e <vfprintf+0x454>
    3d38:	61 2f       	mov	r22, r17
    3d3a:	70 e0       	ldi	r23, 0x00	; 0
    3d3c:	02 c0       	rjmp	.+4      	; 0x3d42 <vfprintf+0x458>
    3d3e:	6f ef       	ldi	r22, 0xFF	; 255
    3d40:	7f ef       	ldi	r23, 0xFF	; 255
    3d42:	c6 01       	movw	r24, r12
    3d44:	42 d2       	rcall	.+1156   	; 0x41ca <strnlen_P>
    3d46:	8c 01       	movw	r16, r24
    3d48:	f9 2d       	mov	r31, r9
    3d4a:	f0 68       	ori	r31, 0x80	; 128
    3d4c:	9f 2e       	mov	r9, r31
    3d4e:	f3 fd       	sbrc	r31, 3
    3d50:	18 c0       	rjmp	.+48     	; 0x3d82 <vfprintf+0x498>
    3d52:	85 2d       	mov	r24, r5
    3d54:	90 e0       	ldi	r25, 0x00	; 0
    3d56:	08 17       	cp	r16, r24
    3d58:	19 07       	cpc	r17, r25
    3d5a:	98 f4       	brcc	.+38     	; 0x3d82 <vfprintf+0x498>
    3d5c:	b7 01       	movw	r22, r14
    3d5e:	80 e2       	ldi	r24, 0x20	; 32
    3d60:	90 e0       	ldi	r25, 0x00	; 0
    3d62:	52 d2       	rcall	.+1188   	; 0x4208 <fputc>
    3d64:	5a 94       	dec	r5
    3d66:	f5 cf       	rjmp	.-22     	; 0x3d52 <vfprintf+0x468>
    3d68:	f6 01       	movw	r30, r12
    3d6a:	97 fc       	sbrc	r9, 7
    3d6c:	85 91       	lpm	r24, Z+
    3d6e:	97 fe       	sbrs	r9, 7
    3d70:	81 91       	ld	r24, Z+
    3d72:	6f 01       	movw	r12, r30
    3d74:	b7 01       	movw	r22, r14
    3d76:	90 e0       	ldi	r25, 0x00	; 0
    3d78:	47 d2       	rcall	.+1166   	; 0x4208 <fputc>
    3d7a:	51 10       	cpse	r5, r1
    3d7c:	5a 94       	dec	r5
    3d7e:	01 50       	subi	r16, 0x01	; 1
    3d80:	11 09       	sbc	r17, r1
    3d82:	01 15       	cp	r16, r1
    3d84:	11 05       	cpc	r17, r1
    3d86:	81 f7       	brne	.-32     	; 0x3d68 <vfprintf+0x47e>
    3d88:	f0 c0       	rjmp	.+480    	; 0x3f6a <vfprintf+0x680>
    3d8a:	84 36       	cpi	r24, 0x64	; 100
    3d8c:	11 f0       	breq	.+4      	; 0x3d92 <vfprintf+0x4a8>
    3d8e:	89 36       	cpi	r24, 0x69	; 105
    3d90:	59 f5       	brne	.+86     	; 0x3de8 <vfprintf+0x4fe>
    3d92:	56 01       	movw	r10, r12
    3d94:	97 fe       	sbrs	r9, 7
    3d96:	09 c0       	rjmp	.+18     	; 0x3daa <vfprintf+0x4c0>
    3d98:	24 e0       	ldi	r18, 0x04	; 4
    3d9a:	a2 0e       	add	r10, r18
    3d9c:	b1 1c       	adc	r11, r1
    3d9e:	f6 01       	movw	r30, r12
    3da0:	60 81       	ld	r22, Z
    3da2:	71 81       	ldd	r23, Z+1	; 0x01
    3da4:	82 81       	ldd	r24, Z+2	; 0x02
    3da6:	93 81       	ldd	r25, Z+3	; 0x03
    3da8:	0a c0       	rjmp	.+20     	; 0x3dbe <vfprintf+0x4d4>
    3daa:	f2 e0       	ldi	r31, 0x02	; 2
    3dac:	af 0e       	add	r10, r31
    3dae:	b1 1c       	adc	r11, r1
    3db0:	f6 01       	movw	r30, r12
    3db2:	60 81       	ld	r22, Z
    3db4:	71 81       	ldd	r23, Z+1	; 0x01
    3db6:	07 2e       	mov	r0, r23
    3db8:	00 0c       	add	r0, r0
    3dba:	88 0b       	sbc	r24, r24
    3dbc:	99 0b       	sbc	r25, r25
    3dbe:	f9 2d       	mov	r31, r9
    3dc0:	ff 76       	andi	r31, 0x6F	; 111
    3dc2:	9f 2e       	mov	r9, r31
    3dc4:	97 ff       	sbrs	r25, 7
    3dc6:	09 c0       	rjmp	.+18     	; 0x3dda <vfprintf+0x4f0>
    3dc8:	90 95       	com	r25
    3dca:	80 95       	com	r24
    3dcc:	70 95       	com	r23
    3dce:	61 95       	neg	r22
    3dd0:	7f 4f       	sbci	r23, 0xFF	; 255
    3dd2:	8f 4f       	sbci	r24, 0xFF	; 255
    3dd4:	9f 4f       	sbci	r25, 0xFF	; 255
    3dd6:	f0 68       	ori	r31, 0x80	; 128
    3dd8:	9f 2e       	mov	r9, r31
    3dda:	2a e0       	ldi	r18, 0x0A	; 10
    3ddc:	30 e0       	ldi	r19, 0x00	; 0
    3dde:	a3 01       	movw	r20, r6
    3de0:	77 d2       	rcall	.+1262   	; 0x42d0 <__ultoa_invert>
    3de2:	c8 2e       	mov	r12, r24
    3de4:	c6 18       	sub	r12, r6
    3de6:	3e c0       	rjmp	.+124    	; 0x3e64 <vfprintf+0x57a>
    3de8:	09 2d       	mov	r16, r9
    3dea:	85 37       	cpi	r24, 0x75	; 117
    3dec:	21 f4       	brne	.+8      	; 0x3df6 <vfprintf+0x50c>
    3dee:	0f 7e       	andi	r16, 0xEF	; 239
    3df0:	2a e0       	ldi	r18, 0x0A	; 10
    3df2:	30 e0       	ldi	r19, 0x00	; 0
    3df4:	1d c0       	rjmp	.+58     	; 0x3e30 <vfprintf+0x546>
    3df6:	09 7f       	andi	r16, 0xF9	; 249
    3df8:	8f 36       	cpi	r24, 0x6F	; 111
    3dfa:	91 f0       	breq	.+36     	; 0x3e20 <vfprintf+0x536>
    3dfc:	18 f4       	brcc	.+6      	; 0x3e04 <vfprintf+0x51a>
    3dfe:	88 35       	cpi	r24, 0x58	; 88
    3e00:	59 f0       	breq	.+22     	; 0x3e18 <vfprintf+0x52e>
    3e02:	bc c0       	rjmp	.+376    	; 0x3f7c <vfprintf+0x692>
    3e04:	80 37       	cpi	r24, 0x70	; 112
    3e06:	19 f0       	breq	.+6      	; 0x3e0e <vfprintf+0x524>
    3e08:	88 37       	cpi	r24, 0x78	; 120
    3e0a:	11 f0       	breq	.+4      	; 0x3e10 <vfprintf+0x526>
    3e0c:	b7 c0       	rjmp	.+366    	; 0x3f7c <vfprintf+0x692>
    3e0e:	00 61       	ori	r16, 0x10	; 16
    3e10:	04 ff       	sbrs	r16, 4
    3e12:	09 c0       	rjmp	.+18     	; 0x3e26 <vfprintf+0x53c>
    3e14:	04 60       	ori	r16, 0x04	; 4
    3e16:	07 c0       	rjmp	.+14     	; 0x3e26 <vfprintf+0x53c>
    3e18:	94 fe       	sbrs	r9, 4
    3e1a:	08 c0       	rjmp	.+16     	; 0x3e2c <vfprintf+0x542>
    3e1c:	06 60       	ori	r16, 0x06	; 6
    3e1e:	06 c0       	rjmp	.+12     	; 0x3e2c <vfprintf+0x542>
    3e20:	28 e0       	ldi	r18, 0x08	; 8
    3e22:	30 e0       	ldi	r19, 0x00	; 0
    3e24:	05 c0       	rjmp	.+10     	; 0x3e30 <vfprintf+0x546>
    3e26:	20 e1       	ldi	r18, 0x10	; 16
    3e28:	30 e0       	ldi	r19, 0x00	; 0
    3e2a:	02 c0       	rjmp	.+4      	; 0x3e30 <vfprintf+0x546>
    3e2c:	20 e1       	ldi	r18, 0x10	; 16
    3e2e:	32 e0       	ldi	r19, 0x02	; 2
    3e30:	56 01       	movw	r10, r12
    3e32:	07 ff       	sbrs	r16, 7
    3e34:	09 c0       	rjmp	.+18     	; 0x3e48 <vfprintf+0x55e>
    3e36:	84 e0       	ldi	r24, 0x04	; 4
    3e38:	a8 0e       	add	r10, r24
    3e3a:	b1 1c       	adc	r11, r1
    3e3c:	f6 01       	movw	r30, r12
    3e3e:	60 81       	ld	r22, Z
    3e40:	71 81       	ldd	r23, Z+1	; 0x01
    3e42:	82 81       	ldd	r24, Z+2	; 0x02
    3e44:	93 81       	ldd	r25, Z+3	; 0x03
    3e46:	08 c0       	rjmp	.+16     	; 0x3e58 <vfprintf+0x56e>
    3e48:	f2 e0       	ldi	r31, 0x02	; 2
    3e4a:	af 0e       	add	r10, r31
    3e4c:	b1 1c       	adc	r11, r1
    3e4e:	f6 01       	movw	r30, r12
    3e50:	60 81       	ld	r22, Z
    3e52:	71 81       	ldd	r23, Z+1	; 0x01
    3e54:	80 e0       	ldi	r24, 0x00	; 0
    3e56:	90 e0       	ldi	r25, 0x00	; 0
    3e58:	a3 01       	movw	r20, r6
    3e5a:	3a d2       	rcall	.+1140   	; 0x42d0 <__ultoa_invert>
    3e5c:	c8 2e       	mov	r12, r24
    3e5e:	c6 18       	sub	r12, r6
    3e60:	0f 77       	andi	r16, 0x7F	; 127
    3e62:	90 2e       	mov	r9, r16
    3e64:	96 fe       	sbrs	r9, 6
    3e66:	0b c0       	rjmp	.+22     	; 0x3e7e <vfprintf+0x594>
    3e68:	09 2d       	mov	r16, r9
    3e6a:	0e 7f       	andi	r16, 0xFE	; 254
    3e6c:	c1 16       	cp	r12, r17
    3e6e:	50 f4       	brcc	.+20     	; 0x3e84 <vfprintf+0x59a>
    3e70:	94 fe       	sbrs	r9, 4
    3e72:	0a c0       	rjmp	.+20     	; 0x3e88 <vfprintf+0x59e>
    3e74:	92 fc       	sbrc	r9, 2
    3e76:	08 c0       	rjmp	.+16     	; 0x3e88 <vfprintf+0x59e>
    3e78:	09 2d       	mov	r16, r9
    3e7a:	0e 7e       	andi	r16, 0xEE	; 238
    3e7c:	05 c0       	rjmp	.+10     	; 0x3e88 <vfprintf+0x59e>
    3e7e:	dc 2c       	mov	r13, r12
    3e80:	09 2d       	mov	r16, r9
    3e82:	03 c0       	rjmp	.+6      	; 0x3e8a <vfprintf+0x5a0>
    3e84:	dc 2c       	mov	r13, r12
    3e86:	01 c0       	rjmp	.+2      	; 0x3e8a <vfprintf+0x5a0>
    3e88:	d1 2e       	mov	r13, r17
    3e8a:	04 ff       	sbrs	r16, 4
    3e8c:	0d c0       	rjmp	.+26     	; 0x3ea8 <vfprintf+0x5be>
    3e8e:	fe 01       	movw	r30, r28
    3e90:	ec 0d       	add	r30, r12
    3e92:	f1 1d       	adc	r31, r1
    3e94:	80 81       	ld	r24, Z
    3e96:	80 33       	cpi	r24, 0x30	; 48
    3e98:	11 f4       	brne	.+4      	; 0x3e9e <vfprintf+0x5b4>
    3e9a:	09 7e       	andi	r16, 0xE9	; 233
    3e9c:	09 c0       	rjmp	.+18     	; 0x3eb0 <vfprintf+0x5c6>
    3e9e:	02 ff       	sbrs	r16, 2
    3ea0:	06 c0       	rjmp	.+12     	; 0x3eae <vfprintf+0x5c4>
    3ea2:	d3 94       	inc	r13
    3ea4:	d3 94       	inc	r13
    3ea6:	04 c0       	rjmp	.+8      	; 0x3eb0 <vfprintf+0x5c6>
    3ea8:	80 2f       	mov	r24, r16
    3eaa:	86 78       	andi	r24, 0x86	; 134
    3eac:	09 f0       	breq	.+2      	; 0x3eb0 <vfprintf+0x5c6>
    3eae:	d3 94       	inc	r13
    3eb0:	03 fd       	sbrc	r16, 3
    3eb2:	10 c0       	rjmp	.+32     	; 0x3ed4 <vfprintf+0x5ea>
    3eb4:	00 ff       	sbrs	r16, 0
    3eb6:	06 c0       	rjmp	.+12     	; 0x3ec4 <vfprintf+0x5da>
    3eb8:	1c 2d       	mov	r17, r12
    3eba:	d5 14       	cp	r13, r5
    3ebc:	78 f4       	brcc	.+30     	; 0x3edc <vfprintf+0x5f2>
    3ebe:	15 0d       	add	r17, r5
    3ec0:	1d 19       	sub	r17, r13
    3ec2:	0c c0       	rjmp	.+24     	; 0x3edc <vfprintf+0x5f2>
    3ec4:	d5 14       	cp	r13, r5
    3ec6:	50 f4       	brcc	.+20     	; 0x3edc <vfprintf+0x5f2>
    3ec8:	b7 01       	movw	r22, r14
    3eca:	80 e2       	ldi	r24, 0x20	; 32
    3ecc:	90 e0       	ldi	r25, 0x00	; 0
    3ece:	9c d1       	rcall	.+824    	; 0x4208 <fputc>
    3ed0:	d3 94       	inc	r13
    3ed2:	f8 cf       	rjmp	.-16     	; 0x3ec4 <vfprintf+0x5da>
    3ed4:	d5 14       	cp	r13, r5
    3ed6:	10 f4       	brcc	.+4      	; 0x3edc <vfprintf+0x5f2>
    3ed8:	5d 18       	sub	r5, r13
    3eda:	01 c0       	rjmp	.+2      	; 0x3ede <vfprintf+0x5f4>
    3edc:	51 2c       	mov	r5, r1
    3ede:	04 ff       	sbrs	r16, 4
    3ee0:	0f c0       	rjmp	.+30     	; 0x3f00 <vfprintf+0x616>
    3ee2:	b7 01       	movw	r22, r14
    3ee4:	80 e3       	ldi	r24, 0x30	; 48
    3ee6:	90 e0       	ldi	r25, 0x00	; 0
    3ee8:	8f d1       	rcall	.+798    	; 0x4208 <fputc>
    3eea:	02 ff       	sbrs	r16, 2
    3eec:	16 c0       	rjmp	.+44     	; 0x3f1a <vfprintf+0x630>
    3eee:	01 fd       	sbrc	r16, 1
    3ef0:	03 c0       	rjmp	.+6      	; 0x3ef8 <vfprintf+0x60e>
    3ef2:	88 e7       	ldi	r24, 0x78	; 120
    3ef4:	90 e0       	ldi	r25, 0x00	; 0
    3ef6:	02 c0       	rjmp	.+4      	; 0x3efc <vfprintf+0x612>
    3ef8:	88 e5       	ldi	r24, 0x58	; 88
    3efa:	90 e0       	ldi	r25, 0x00	; 0
    3efc:	b7 01       	movw	r22, r14
    3efe:	0c c0       	rjmp	.+24     	; 0x3f18 <vfprintf+0x62e>
    3f00:	80 2f       	mov	r24, r16
    3f02:	86 78       	andi	r24, 0x86	; 134
    3f04:	51 f0       	breq	.+20     	; 0x3f1a <vfprintf+0x630>
    3f06:	01 ff       	sbrs	r16, 1
    3f08:	02 c0       	rjmp	.+4      	; 0x3f0e <vfprintf+0x624>
    3f0a:	8b e2       	ldi	r24, 0x2B	; 43
    3f0c:	01 c0       	rjmp	.+2      	; 0x3f10 <vfprintf+0x626>
    3f0e:	80 e2       	ldi	r24, 0x20	; 32
    3f10:	07 fd       	sbrc	r16, 7
    3f12:	8d e2       	ldi	r24, 0x2D	; 45
    3f14:	b7 01       	movw	r22, r14
    3f16:	90 e0       	ldi	r25, 0x00	; 0
    3f18:	77 d1       	rcall	.+750    	; 0x4208 <fputc>
    3f1a:	c1 16       	cp	r12, r17
    3f1c:	30 f4       	brcc	.+12     	; 0x3f2a <vfprintf+0x640>
    3f1e:	b7 01       	movw	r22, r14
    3f20:	80 e3       	ldi	r24, 0x30	; 48
    3f22:	90 e0       	ldi	r25, 0x00	; 0
    3f24:	71 d1       	rcall	.+738    	; 0x4208 <fputc>
    3f26:	11 50       	subi	r17, 0x01	; 1
    3f28:	f8 cf       	rjmp	.-16     	; 0x3f1a <vfprintf+0x630>
    3f2a:	ca 94       	dec	r12
    3f2c:	f3 01       	movw	r30, r6
    3f2e:	ec 0d       	add	r30, r12
    3f30:	f1 1d       	adc	r31, r1
    3f32:	80 81       	ld	r24, Z
    3f34:	b7 01       	movw	r22, r14
    3f36:	90 e0       	ldi	r25, 0x00	; 0
    3f38:	67 d1       	rcall	.+718    	; 0x4208 <fputc>
    3f3a:	c1 10       	cpse	r12, r1
    3f3c:	f6 cf       	rjmp	.-20     	; 0x3f2a <vfprintf+0x640>
    3f3e:	15 c0       	rjmp	.+42     	; 0x3f6a <vfprintf+0x680>
    3f40:	f4 e0       	ldi	r31, 0x04	; 4
    3f42:	f5 15       	cp	r31, r5
    3f44:	50 f5       	brcc	.+84     	; 0x3f9a <vfprintf+0x6b0>
    3f46:	84 e0       	ldi	r24, 0x04	; 4
    3f48:	58 1a       	sub	r5, r24
    3f4a:	93 fe       	sbrs	r9, 3
    3f4c:	1e c0       	rjmp	.+60     	; 0x3f8a <vfprintf+0x6a0>
    3f4e:	01 11       	cpse	r16, r1
    3f50:	25 c0       	rjmp	.+74     	; 0x3f9c <vfprintf+0x6b2>
    3f52:	2c 85       	ldd	r18, Y+12	; 0x0c
    3f54:	23 ff       	sbrs	r18, 3
    3f56:	27 c0       	rjmp	.+78     	; 0x3fa6 <vfprintf+0x6bc>
    3f58:	04 ee       	ldi	r16, 0xE4	; 228
    3f5a:	10 e0       	ldi	r17, 0x00	; 0
    3f5c:	39 2d       	mov	r19, r9
    3f5e:	30 71       	andi	r19, 0x10	; 16
    3f60:	93 2e       	mov	r9, r19
    3f62:	f8 01       	movw	r30, r16
    3f64:	84 91       	lpm	r24, Z
    3f66:	81 11       	cpse	r24, r1
    3f68:	21 c0       	rjmp	.+66     	; 0x3fac <vfprintf+0x6c2>
    3f6a:	55 20       	and	r5, r5
    3f6c:	09 f4       	brne	.+2      	; 0x3f70 <vfprintf+0x686>
    3f6e:	fc cc       	rjmp	.-1544   	; 0x3968 <vfprintf+0x7e>
    3f70:	b7 01       	movw	r22, r14
    3f72:	80 e2       	ldi	r24, 0x20	; 32
    3f74:	90 e0       	ldi	r25, 0x00	; 0
    3f76:	48 d1       	rcall	.+656    	; 0x4208 <fputc>
    3f78:	5a 94       	dec	r5
    3f7a:	f7 cf       	rjmp	.-18     	; 0x3f6a <vfprintf+0x680>
    3f7c:	f7 01       	movw	r30, r14
    3f7e:	86 81       	ldd	r24, Z+6	; 0x06
    3f80:	97 81       	ldd	r25, Z+7	; 0x07
    3f82:	23 c0       	rjmp	.+70     	; 0x3fca <vfprintf+0x6e0>
    3f84:	8f ef       	ldi	r24, 0xFF	; 255
    3f86:	9f ef       	ldi	r25, 0xFF	; 255
    3f88:	20 c0       	rjmp	.+64     	; 0x3fca <vfprintf+0x6e0>
    3f8a:	b7 01       	movw	r22, r14
    3f8c:	80 e2       	ldi	r24, 0x20	; 32
    3f8e:	90 e0       	ldi	r25, 0x00	; 0
    3f90:	3b d1       	rcall	.+630    	; 0x4208 <fputc>
    3f92:	5a 94       	dec	r5
    3f94:	51 10       	cpse	r5, r1
    3f96:	f9 cf       	rjmp	.-14     	; 0x3f8a <vfprintf+0x6a0>
    3f98:	da cf       	rjmp	.-76     	; 0x3f4e <vfprintf+0x664>
    3f9a:	51 2c       	mov	r5, r1
    3f9c:	b7 01       	movw	r22, r14
    3f9e:	80 2f       	mov	r24, r16
    3fa0:	90 e0       	ldi	r25, 0x00	; 0
    3fa2:	32 d1       	rcall	.+612    	; 0x4208 <fputc>
    3fa4:	d6 cf       	rjmp	.-84     	; 0x3f52 <vfprintf+0x668>
    3fa6:	08 ee       	ldi	r16, 0xE8	; 232
    3fa8:	10 e0       	ldi	r17, 0x00	; 0
    3faa:	d8 cf       	rjmp	.-80     	; 0x3f5c <vfprintf+0x672>
    3fac:	91 10       	cpse	r9, r1
    3fae:	80 52       	subi	r24, 0x20	; 32
    3fb0:	b7 01       	movw	r22, r14
    3fb2:	90 e0       	ldi	r25, 0x00	; 0
    3fb4:	29 d1       	rcall	.+594    	; 0x4208 <fputc>
    3fb6:	0f 5f       	subi	r16, 0xFF	; 255
    3fb8:	1f 4f       	sbci	r17, 0xFF	; 255
    3fba:	d3 cf       	rjmp	.-90     	; 0x3f62 <vfprintf+0x678>
    3fbc:	23 e0       	ldi	r18, 0x03	; 3
    3fbe:	25 15       	cp	r18, r5
    3fc0:	10 f4       	brcc	.+4      	; 0x3fc6 <vfprintf+0x6dc>
    3fc2:	83 e0       	ldi	r24, 0x03	; 3
    3fc4:	c1 cf       	rjmp	.-126    	; 0x3f48 <vfprintf+0x65e>
    3fc6:	51 2c       	mov	r5, r1
    3fc8:	c4 cf       	rjmp	.-120    	; 0x3f52 <vfprintf+0x668>
    3fca:	60 96       	adiw	r28, 0x10	; 16
    3fcc:	0f b6       	in	r0, 0x3f	; 63
    3fce:	f8 94       	cli
    3fd0:	de bf       	out	0x3e, r29	; 62
    3fd2:	0f be       	out	0x3f, r0	; 63
    3fd4:	cd bf       	out	0x3d, r28	; 61
    3fd6:	df 91       	pop	r29
    3fd8:	cf 91       	pop	r28
    3fda:	1f 91       	pop	r17
    3fdc:	0f 91       	pop	r16
    3fde:	ff 90       	pop	r15
    3fe0:	ef 90       	pop	r14
    3fe2:	df 90       	pop	r13
    3fe4:	cf 90       	pop	r12
    3fe6:	bf 90       	pop	r11
    3fe8:	af 90       	pop	r10
    3fea:	9f 90       	pop	r9
    3fec:	8f 90       	pop	r8
    3fee:	7f 90       	pop	r7
    3ff0:	6f 90       	pop	r6
    3ff2:	5f 90       	pop	r5
    3ff4:	4f 90       	pop	r4
    3ff6:	3f 90       	pop	r3
    3ff8:	2f 90       	pop	r2
    3ffa:	08 95       	ret

00003ffc <__umulhisi3>:
    3ffc:	a2 9f       	mul	r26, r18
    3ffe:	b0 01       	movw	r22, r0
    4000:	b3 9f       	mul	r27, r19
    4002:	c0 01       	movw	r24, r0
    4004:	a3 9f       	mul	r26, r19
    4006:	70 0d       	add	r23, r0
    4008:	81 1d       	adc	r24, r1
    400a:	11 24       	eor	r1, r1
    400c:	91 1d       	adc	r25, r1
    400e:	b2 9f       	mul	r27, r18
    4010:	70 0d       	add	r23, r0
    4012:	81 1d       	adc	r24, r1
    4014:	11 24       	eor	r1, r1
    4016:	91 1d       	adc	r25, r1
    4018:	08 95       	ret

0000401a <__ftoa_engine>:
    401a:	28 30       	cpi	r18, 0x08	; 8
    401c:	08 f0       	brcs	.+2      	; 0x4020 <__ftoa_engine+0x6>
    401e:	27 e0       	ldi	r18, 0x07	; 7
    4020:	33 27       	eor	r19, r19
    4022:	da 01       	movw	r26, r20
    4024:	99 0f       	add	r25, r25
    4026:	31 1d       	adc	r19, r1
    4028:	87 fd       	sbrc	r24, 7
    402a:	91 60       	ori	r25, 0x01	; 1
    402c:	00 96       	adiw	r24, 0x00	; 0
    402e:	61 05       	cpc	r22, r1
    4030:	71 05       	cpc	r23, r1
    4032:	39 f4       	brne	.+14     	; 0x4042 <__ftoa_engine+0x28>
    4034:	32 60       	ori	r19, 0x02	; 2
    4036:	2e 5f       	subi	r18, 0xFE	; 254
    4038:	3d 93       	st	X+, r19
    403a:	30 e3       	ldi	r19, 0x30	; 48
    403c:	2a 95       	dec	r18
    403e:	e1 f7       	brne	.-8      	; 0x4038 <__ftoa_engine+0x1e>
    4040:	08 95       	ret
    4042:	9f 3f       	cpi	r25, 0xFF	; 255
    4044:	30 f0       	brcs	.+12     	; 0x4052 <__ftoa_engine+0x38>
    4046:	80 38       	cpi	r24, 0x80	; 128
    4048:	71 05       	cpc	r23, r1
    404a:	61 05       	cpc	r22, r1
    404c:	09 f0       	breq	.+2      	; 0x4050 <__ftoa_engine+0x36>
    404e:	3c 5f       	subi	r19, 0xFC	; 252
    4050:	3c 5f       	subi	r19, 0xFC	; 252
    4052:	3d 93       	st	X+, r19
    4054:	91 30       	cpi	r25, 0x01	; 1
    4056:	08 f0       	brcs	.+2      	; 0x405a <__ftoa_engine+0x40>
    4058:	80 68       	ori	r24, 0x80	; 128
    405a:	91 1d       	adc	r25, r1
    405c:	df 93       	push	r29
    405e:	cf 93       	push	r28
    4060:	1f 93       	push	r17
    4062:	0f 93       	push	r16
    4064:	ff 92       	push	r15
    4066:	ef 92       	push	r14
    4068:	19 2f       	mov	r17, r25
    406a:	98 7f       	andi	r25, 0xF8	; 248
    406c:	96 95       	lsr	r25
    406e:	e9 2f       	mov	r30, r25
    4070:	96 95       	lsr	r25
    4072:	96 95       	lsr	r25
    4074:	e9 0f       	add	r30, r25
    4076:	ff 27       	eor	r31, r31
    4078:	ea 5b       	subi	r30, 0xBA	; 186
    407a:	fe 4f       	sbci	r31, 0xFE	; 254
    407c:	99 27       	eor	r25, r25
    407e:	33 27       	eor	r19, r19
    4080:	ee 24       	eor	r14, r14
    4082:	ff 24       	eor	r15, r15
    4084:	a7 01       	movw	r20, r14
    4086:	e7 01       	movw	r28, r14
    4088:	05 90       	lpm	r0, Z+
    408a:	08 94       	sec
    408c:	07 94       	ror	r0
    408e:	28 f4       	brcc	.+10     	; 0x409a <__ftoa_engine+0x80>
    4090:	36 0f       	add	r19, r22
    4092:	e7 1e       	adc	r14, r23
    4094:	f8 1e       	adc	r15, r24
    4096:	49 1f       	adc	r20, r25
    4098:	51 1d       	adc	r21, r1
    409a:	66 0f       	add	r22, r22
    409c:	77 1f       	adc	r23, r23
    409e:	88 1f       	adc	r24, r24
    40a0:	99 1f       	adc	r25, r25
    40a2:	06 94       	lsr	r0
    40a4:	a1 f7       	brne	.-24     	; 0x408e <__ftoa_engine+0x74>
    40a6:	05 90       	lpm	r0, Z+
    40a8:	07 94       	ror	r0
    40aa:	28 f4       	brcc	.+10     	; 0x40b6 <__ftoa_engine+0x9c>
    40ac:	e7 0e       	add	r14, r23
    40ae:	f8 1e       	adc	r15, r24
    40b0:	49 1f       	adc	r20, r25
    40b2:	56 1f       	adc	r21, r22
    40b4:	c1 1d       	adc	r28, r1
    40b6:	77 0f       	add	r23, r23
    40b8:	88 1f       	adc	r24, r24
    40ba:	99 1f       	adc	r25, r25
    40bc:	66 1f       	adc	r22, r22
    40be:	06 94       	lsr	r0
    40c0:	a1 f7       	brne	.-24     	; 0x40aa <__ftoa_engine+0x90>
    40c2:	05 90       	lpm	r0, Z+
    40c4:	07 94       	ror	r0
    40c6:	28 f4       	brcc	.+10     	; 0x40d2 <__ftoa_engine+0xb8>
    40c8:	f8 0e       	add	r15, r24
    40ca:	49 1f       	adc	r20, r25
    40cc:	56 1f       	adc	r21, r22
    40ce:	c7 1f       	adc	r28, r23
    40d0:	d1 1d       	adc	r29, r1
    40d2:	88 0f       	add	r24, r24
    40d4:	99 1f       	adc	r25, r25
    40d6:	66 1f       	adc	r22, r22
    40d8:	77 1f       	adc	r23, r23
    40da:	06 94       	lsr	r0
    40dc:	a1 f7       	brne	.-24     	; 0x40c6 <__ftoa_engine+0xac>
    40de:	05 90       	lpm	r0, Z+
    40e0:	07 94       	ror	r0
    40e2:	20 f4       	brcc	.+8      	; 0x40ec <__ftoa_engine+0xd2>
    40e4:	49 0f       	add	r20, r25
    40e6:	56 1f       	adc	r21, r22
    40e8:	c7 1f       	adc	r28, r23
    40ea:	d8 1f       	adc	r29, r24
    40ec:	99 0f       	add	r25, r25
    40ee:	66 1f       	adc	r22, r22
    40f0:	77 1f       	adc	r23, r23
    40f2:	88 1f       	adc	r24, r24
    40f4:	06 94       	lsr	r0
    40f6:	a9 f7       	brne	.-22     	; 0x40e2 <__ftoa_engine+0xc8>
    40f8:	84 91       	lpm	r24, Z
    40fa:	10 95       	com	r17
    40fc:	17 70       	andi	r17, 0x07	; 7
    40fe:	41 f0       	breq	.+16     	; 0x4110 <__ftoa_engine+0xf6>
    4100:	d6 95       	lsr	r29
    4102:	c7 95       	ror	r28
    4104:	57 95       	ror	r21
    4106:	47 95       	ror	r20
    4108:	f7 94       	ror	r15
    410a:	e7 94       	ror	r14
    410c:	1a 95       	dec	r17
    410e:	c1 f7       	brne	.-16     	; 0x4100 <__ftoa_engine+0xe6>
    4110:	ec ee       	ldi	r30, 0xEC	; 236
    4112:	f0 e0       	ldi	r31, 0x00	; 0
    4114:	68 94       	set
    4116:	15 90       	lpm	r1, Z+
    4118:	15 91       	lpm	r17, Z+
    411a:	35 91       	lpm	r19, Z+
    411c:	65 91       	lpm	r22, Z+
    411e:	95 91       	lpm	r25, Z+
    4120:	05 90       	lpm	r0, Z+
    4122:	7f e2       	ldi	r23, 0x2F	; 47
    4124:	73 95       	inc	r23
    4126:	e1 18       	sub	r14, r1
    4128:	f1 0a       	sbc	r15, r17
    412a:	43 0b       	sbc	r20, r19
    412c:	56 0b       	sbc	r21, r22
    412e:	c9 0b       	sbc	r28, r25
    4130:	d0 09       	sbc	r29, r0
    4132:	c0 f7       	brcc	.-16     	; 0x4124 <__ftoa_engine+0x10a>
    4134:	e1 0c       	add	r14, r1
    4136:	f1 1e       	adc	r15, r17
    4138:	43 1f       	adc	r20, r19
    413a:	56 1f       	adc	r21, r22
    413c:	c9 1f       	adc	r28, r25
    413e:	d0 1d       	adc	r29, r0
    4140:	7e f4       	brtc	.+30     	; 0x4160 <__ftoa_engine+0x146>
    4142:	70 33       	cpi	r23, 0x30	; 48
    4144:	11 f4       	brne	.+4      	; 0x414a <__ftoa_engine+0x130>
    4146:	8a 95       	dec	r24
    4148:	e6 cf       	rjmp	.-52     	; 0x4116 <__ftoa_engine+0xfc>
    414a:	e8 94       	clt
    414c:	01 50       	subi	r16, 0x01	; 1
    414e:	30 f0       	brcs	.+12     	; 0x415c <__ftoa_engine+0x142>
    4150:	08 0f       	add	r16, r24
    4152:	0a f4       	brpl	.+2      	; 0x4156 <__ftoa_engine+0x13c>
    4154:	00 27       	eor	r16, r16
    4156:	02 17       	cp	r16, r18
    4158:	08 f4       	brcc	.+2      	; 0x415c <__ftoa_engine+0x142>
    415a:	20 2f       	mov	r18, r16
    415c:	23 95       	inc	r18
    415e:	02 2f       	mov	r16, r18
    4160:	7a 33       	cpi	r23, 0x3A	; 58
    4162:	28 f0       	brcs	.+10     	; 0x416e <__ftoa_engine+0x154>
    4164:	79 e3       	ldi	r23, 0x39	; 57
    4166:	7d 93       	st	X+, r23
    4168:	2a 95       	dec	r18
    416a:	e9 f7       	brne	.-6      	; 0x4166 <__ftoa_engine+0x14c>
    416c:	10 c0       	rjmp	.+32     	; 0x418e <__ftoa_engine+0x174>
    416e:	7d 93       	st	X+, r23
    4170:	2a 95       	dec	r18
    4172:	89 f6       	brne	.-94     	; 0x4116 <__ftoa_engine+0xfc>
    4174:	06 94       	lsr	r0
    4176:	97 95       	ror	r25
    4178:	67 95       	ror	r22
    417a:	37 95       	ror	r19
    417c:	17 95       	ror	r17
    417e:	17 94       	ror	r1
    4180:	e1 18       	sub	r14, r1
    4182:	f1 0a       	sbc	r15, r17
    4184:	43 0b       	sbc	r20, r19
    4186:	56 0b       	sbc	r21, r22
    4188:	c9 0b       	sbc	r28, r25
    418a:	d0 09       	sbc	r29, r0
    418c:	98 f0       	brcs	.+38     	; 0x41b4 <__ftoa_engine+0x19a>
    418e:	23 95       	inc	r18
    4190:	7e 91       	ld	r23, -X
    4192:	73 95       	inc	r23
    4194:	7a 33       	cpi	r23, 0x3A	; 58
    4196:	08 f0       	brcs	.+2      	; 0x419a <__ftoa_engine+0x180>
    4198:	70 e3       	ldi	r23, 0x30	; 48
    419a:	7c 93       	st	X, r23
    419c:	20 13       	cpse	r18, r16
    419e:	b8 f7       	brcc	.-18     	; 0x418e <__ftoa_engine+0x174>
    41a0:	7e 91       	ld	r23, -X
    41a2:	70 61       	ori	r23, 0x10	; 16
    41a4:	7d 93       	st	X+, r23
    41a6:	30 f0       	brcs	.+12     	; 0x41b4 <__ftoa_engine+0x19a>
    41a8:	83 95       	inc	r24
    41aa:	71 e3       	ldi	r23, 0x31	; 49
    41ac:	7d 93       	st	X+, r23
    41ae:	70 e3       	ldi	r23, 0x30	; 48
    41b0:	2a 95       	dec	r18
    41b2:	e1 f7       	brne	.-8      	; 0x41ac <__ftoa_engine+0x192>
    41b4:	11 24       	eor	r1, r1
    41b6:	ef 90       	pop	r14
    41b8:	ff 90       	pop	r15
    41ba:	0f 91       	pop	r16
    41bc:	1f 91       	pop	r17
    41be:	cf 91       	pop	r28
    41c0:	df 91       	pop	r29
    41c2:	99 27       	eor	r25, r25
    41c4:	87 fd       	sbrc	r24, 7
    41c6:	90 95       	com	r25
    41c8:	08 95       	ret

000041ca <strnlen_P>:
    41ca:	fc 01       	movw	r30, r24
    41cc:	05 90       	lpm	r0, Z+
    41ce:	61 50       	subi	r22, 0x01	; 1
    41d0:	70 40       	sbci	r23, 0x00	; 0
    41d2:	01 10       	cpse	r0, r1
    41d4:	d8 f7       	brcc	.-10     	; 0x41cc <strnlen_P+0x2>
    41d6:	80 95       	com	r24
    41d8:	90 95       	com	r25
    41da:	8e 0f       	add	r24, r30
    41dc:	9f 1f       	adc	r25, r31
    41de:	08 95       	ret

000041e0 <memcpy>:
    41e0:	fb 01       	movw	r30, r22
    41e2:	dc 01       	movw	r26, r24
    41e4:	02 c0       	rjmp	.+4      	; 0x41ea <memcpy+0xa>
    41e6:	01 90       	ld	r0, Z+
    41e8:	0d 92       	st	X+, r0
    41ea:	41 50       	subi	r20, 0x01	; 1
    41ec:	50 40       	sbci	r21, 0x00	; 0
    41ee:	d8 f7       	brcc	.-10     	; 0x41e6 <memcpy+0x6>
    41f0:	08 95       	ret

000041f2 <strnlen>:
    41f2:	fc 01       	movw	r30, r24
    41f4:	61 50       	subi	r22, 0x01	; 1
    41f6:	70 40       	sbci	r23, 0x00	; 0
    41f8:	01 90       	ld	r0, Z+
    41fa:	01 10       	cpse	r0, r1
    41fc:	d8 f7       	brcc	.-10     	; 0x41f4 <strnlen+0x2>
    41fe:	80 95       	com	r24
    4200:	90 95       	com	r25
    4202:	8e 0f       	add	r24, r30
    4204:	9f 1f       	adc	r25, r31
    4206:	08 95       	ret

00004208 <fputc>:
    4208:	0f 93       	push	r16
    420a:	1f 93       	push	r17
    420c:	cf 93       	push	r28
    420e:	df 93       	push	r29
    4210:	fb 01       	movw	r30, r22
    4212:	23 81       	ldd	r18, Z+3	; 0x03
    4214:	21 fd       	sbrc	r18, 1
    4216:	03 c0       	rjmp	.+6      	; 0x421e <fputc+0x16>
    4218:	8f ef       	ldi	r24, 0xFF	; 255
    421a:	9f ef       	ldi	r25, 0xFF	; 255
    421c:	2c c0       	rjmp	.+88     	; 0x4276 <fputc+0x6e>
    421e:	22 ff       	sbrs	r18, 2
    4220:	16 c0       	rjmp	.+44     	; 0x424e <fputc+0x46>
    4222:	46 81       	ldd	r20, Z+6	; 0x06
    4224:	57 81       	ldd	r21, Z+7	; 0x07
    4226:	24 81       	ldd	r18, Z+4	; 0x04
    4228:	35 81       	ldd	r19, Z+5	; 0x05
    422a:	42 17       	cp	r20, r18
    422c:	53 07       	cpc	r21, r19
    422e:	44 f4       	brge	.+16     	; 0x4240 <fputc+0x38>
    4230:	a0 81       	ld	r26, Z
    4232:	b1 81       	ldd	r27, Z+1	; 0x01
    4234:	9d 01       	movw	r18, r26
    4236:	2f 5f       	subi	r18, 0xFF	; 255
    4238:	3f 4f       	sbci	r19, 0xFF	; 255
    423a:	31 83       	std	Z+1, r19	; 0x01
    423c:	20 83       	st	Z, r18
    423e:	8c 93       	st	X, r24
    4240:	26 81       	ldd	r18, Z+6	; 0x06
    4242:	37 81       	ldd	r19, Z+7	; 0x07
    4244:	2f 5f       	subi	r18, 0xFF	; 255
    4246:	3f 4f       	sbci	r19, 0xFF	; 255
    4248:	37 83       	std	Z+7, r19	; 0x07
    424a:	26 83       	std	Z+6, r18	; 0x06
    424c:	14 c0       	rjmp	.+40     	; 0x4276 <fputc+0x6e>
    424e:	8b 01       	movw	r16, r22
    4250:	ec 01       	movw	r28, r24
    4252:	fb 01       	movw	r30, r22
    4254:	00 84       	ldd	r0, Z+8	; 0x08
    4256:	f1 85       	ldd	r31, Z+9	; 0x09
    4258:	e0 2d       	mov	r30, r0
    425a:	19 95       	eicall
    425c:	89 2b       	or	r24, r25
    425e:	e1 f6       	brne	.-72     	; 0x4218 <fputc+0x10>
    4260:	d8 01       	movw	r26, r16
    4262:	16 96       	adiw	r26, 0x06	; 6
    4264:	8d 91       	ld	r24, X+
    4266:	9c 91       	ld	r25, X
    4268:	17 97       	sbiw	r26, 0x07	; 7
    426a:	01 96       	adiw	r24, 0x01	; 1
    426c:	17 96       	adiw	r26, 0x07	; 7
    426e:	9c 93       	st	X, r25
    4270:	8e 93       	st	-X, r24
    4272:	16 97       	sbiw	r26, 0x06	; 6
    4274:	ce 01       	movw	r24, r28
    4276:	df 91       	pop	r29
    4278:	cf 91       	pop	r28
    427a:	1f 91       	pop	r17
    427c:	0f 91       	pop	r16
    427e:	08 95       	ret

00004280 <vsprintf>:
    4280:	0f 93       	push	r16
    4282:	1f 93       	push	r17
    4284:	cf 93       	push	r28
    4286:	df 93       	push	r29
    4288:	cd b7       	in	r28, 0x3d	; 61
    428a:	de b7       	in	r29, 0x3e	; 62
    428c:	2e 97       	sbiw	r28, 0x0e	; 14
    428e:	0f b6       	in	r0, 0x3f	; 63
    4290:	f8 94       	cli
    4292:	de bf       	out	0x3e, r29	; 62
    4294:	0f be       	out	0x3f, r0	; 63
    4296:	cd bf       	out	0x3d, r28	; 61
    4298:	8c 01       	movw	r16, r24
    429a:	86 e0       	ldi	r24, 0x06	; 6
    429c:	8c 83       	std	Y+4, r24	; 0x04
    429e:	1a 83       	std	Y+2, r17	; 0x02
    42a0:	09 83       	std	Y+1, r16	; 0x01
    42a2:	8f ef       	ldi	r24, 0xFF	; 255
    42a4:	9f e7       	ldi	r25, 0x7F	; 127
    42a6:	9e 83       	std	Y+6, r25	; 0x06
    42a8:	8d 83       	std	Y+5, r24	; 0x05
    42aa:	ce 01       	movw	r24, r28
    42ac:	01 96       	adiw	r24, 0x01	; 1
    42ae:	1d db       	rcall	.-2502   	; 0x38ea <vfprintf>
    42b0:	ef 81       	ldd	r30, Y+7	; 0x07
    42b2:	f8 85       	ldd	r31, Y+8	; 0x08
    42b4:	e0 0f       	add	r30, r16
    42b6:	f1 1f       	adc	r31, r17
    42b8:	10 82       	st	Z, r1
    42ba:	2e 96       	adiw	r28, 0x0e	; 14
    42bc:	0f b6       	in	r0, 0x3f	; 63
    42be:	f8 94       	cli
    42c0:	de bf       	out	0x3e, r29	; 62
    42c2:	0f be       	out	0x3f, r0	; 63
    42c4:	cd bf       	out	0x3d, r28	; 61
    42c6:	df 91       	pop	r29
    42c8:	cf 91       	pop	r28
    42ca:	1f 91       	pop	r17
    42cc:	0f 91       	pop	r16
    42ce:	08 95       	ret

000042d0 <__ultoa_invert>:
    42d0:	fa 01       	movw	r30, r20
    42d2:	aa 27       	eor	r26, r26
    42d4:	28 30       	cpi	r18, 0x08	; 8
    42d6:	51 f1       	breq	.+84     	; 0x432c <__ultoa_invert+0x5c>
    42d8:	20 31       	cpi	r18, 0x10	; 16
    42da:	81 f1       	breq	.+96     	; 0x433c <__ultoa_invert+0x6c>
    42dc:	e8 94       	clt
    42de:	6f 93       	push	r22
    42e0:	6e 7f       	andi	r22, 0xFE	; 254
    42e2:	6e 5f       	subi	r22, 0xFE	; 254
    42e4:	7f 4f       	sbci	r23, 0xFF	; 255
    42e6:	8f 4f       	sbci	r24, 0xFF	; 255
    42e8:	9f 4f       	sbci	r25, 0xFF	; 255
    42ea:	af 4f       	sbci	r26, 0xFF	; 255
    42ec:	b1 e0       	ldi	r27, 0x01	; 1
    42ee:	3e d0       	rcall	.+124    	; 0x436c <__ultoa_invert+0x9c>
    42f0:	b4 e0       	ldi	r27, 0x04	; 4
    42f2:	3c d0       	rcall	.+120    	; 0x436c <__ultoa_invert+0x9c>
    42f4:	67 0f       	add	r22, r23
    42f6:	78 1f       	adc	r23, r24
    42f8:	89 1f       	adc	r24, r25
    42fa:	9a 1f       	adc	r25, r26
    42fc:	a1 1d       	adc	r26, r1
    42fe:	68 0f       	add	r22, r24
    4300:	79 1f       	adc	r23, r25
    4302:	8a 1f       	adc	r24, r26
    4304:	91 1d       	adc	r25, r1
    4306:	a1 1d       	adc	r26, r1
    4308:	6a 0f       	add	r22, r26
    430a:	71 1d       	adc	r23, r1
    430c:	81 1d       	adc	r24, r1
    430e:	91 1d       	adc	r25, r1
    4310:	a1 1d       	adc	r26, r1
    4312:	20 d0       	rcall	.+64     	; 0x4354 <__ultoa_invert+0x84>
    4314:	09 f4       	brne	.+2      	; 0x4318 <__ultoa_invert+0x48>
    4316:	68 94       	set
    4318:	3f 91       	pop	r19
    431a:	2a e0       	ldi	r18, 0x0A	; 10
    431c:	26 9f       	mul	r18, r22
    431e:	11 24       	eor	r1, r1
    4320:	30 19       	sub	r19, r0
    4322:	30 5d       	subi	r19, 0xD0	; 208
    4324:	31 93       	st	Z+, r19
    4326:	de f6       	brtc	.-74     	; 0x42de <__ultoa_invert+0xe>
    4328:	cf 01       	movw	r24, r30
    432a:	08 95       	ret
    432c:	46 2f       	mov	r20, r22
    432e:	47 70       	andi	r20, 0x07	; 7
    4330:	40 5d       	subi	r20, 0xD0	; 208
    4332:	41 93       	st	Z+, r20
    4334:	b3 e0       	ldi	r27, 0x03	; 3
    4336:	0f d0       	rcall	.+30     	; 0x4356 <__ultoa_invert+0x86>
    4338:	c9 f7       	brne	.-14     	; 0x432c <__ultoa_invert+0x5c>
    433a:	f6 cf       	rjmp	.-20     	; 0x4328 <__ultoa_invert+0x58>
    433c:	46 2f       	mov	r20, r22
    433e:	4f 70       	andi	r20, 0x0F	; 15
    4340:	40 5d       	subi	r20, 0xD0	; 208
    4342:	4a 33       	cpi	r20, 0x3A	; 58
    4344:	18 f0       	brcs	.+6      	; 0x434c <__ultoa_invert+0x7c>
    4346:	49 5d       	subi	r20, 0xD9	; 217
    4348:	31 fd       	sbrc	r19, 1
    434a:	40 52       	subi	r20, 0x20	; 32
    434c:	41 93       	st	Z+, r20
    434e:	02 d0       	rcall	.+4      	; 0x4354 <__ultoa_invert+0x84>
    4350:	a9 f7       	brne	.-22     	; 0x433c <__ultoa_invert+0x6c>
    4352:	ea cf       	rjmp	.-44     	; 0x4328 <__ultoa_invert+0x58>
    4354:	b4 e0       	ldi	r27, 0x04	; 4
    4356:	a6 95       	lsr	r26
    4358:	97 95       	ror	r25
    435a:	87 95       	ror	r24
    435c:	77 95       	ror	r23
    435e:	67 95       	ror	r22
    4360:	ba 95       	dec	r27
    4362:	c9 f7       	brne	.-14     	; 0x4356 <__ultoa_invert+0x86>
    4364:	00 97       	sbiw	r24, 0x00	; 0
    4366:	61 05       	cpc	r22, r1
    4368:	71 05       	cpc	r23, r1
    436a:	08 95       	ret
    436c:	9b 01       	movw	r18, r22
    436e:	ac 01       	movw	r20, r24
    4370:	0a 2e       	mov	r0, r26
    4372:	06 94       	lsr	r0
    4374:	57 95       	ror	r21
    4376:	47 95       	ror	r20
    4378:	37 95       	ror	r19
    437a:	27 95       	ror	r18
    437c:	ba 95       	dec	r27
    437e:	c9 f7       	brne	.-14     	; 0x4372 <__ultoa_invert+0xa2>
    4380:	62 0f       	add	r22, r18
    4382:	73 1f       	adc	r23, r19
    4384:	84 1f       	adc	r24, r20
    4386:	95 1f       	adc	r25, r21
    4388:	a0 1d       	adc	r26, r0
    438a:	08 95       	ret

0000438c <_exit>:
    438c:	f8 94       	cli

0000438e <__stop_program>:
    438e:	ff cf       	rjmp	.-2      	; 0x438e <__stop_program>
