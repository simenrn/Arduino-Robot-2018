
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000536  00800200  00007276  0000730a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007276  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000014c0  00800736  00800736  00007840  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  00007840  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000078cc  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000778  00000000  00000000  0000790c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a65f  00000000  00000000  00008084  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000216c  00000000  00000000  000126e3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00006019  00000000  00000000  0001484f  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  0000190c  00000000  00000000  0001a868  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000304c  00000000  00000000  0001c174  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000af96  00000000  00000000  0001f1c0  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000848  00000000  00000000  0002a156  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	20 c1       	rjmp	.+576    	; 0x242 <__ctors_end>
       2:	00 00       	nop
       4:	3f c1       	rjmp	.+638    	; 0x284 <__bad_interrupt>
       6:	00 00       	nop
       8:	3d c1       	rjmp	.+634    	; 0x284 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 e6 15 	jmp	0x2bcc	; 0x2bcc <__vector_3>
      10:	0c 94 f7 15 	jmp	0x2bee	; 0x2bee <__vector_4>
      14:	0c 94 08 16 	jmp	0x2c10	; 0x2c10 <__vector_5>
      18:	35 c1       	rjmp	.+618    	; 0x284 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	33 c1       	rjmp	.+614    	; 0x284 <__bad_interrupt>
      1e:	00 00       	nop
      20:	31 c1       	rjmp	.+610    	; 0x284 <__bad_interrupt>
      22:	00 00       	nop
      24:	2f c1       	rjmp	.+606    	; 0x284 <__bad_interrupt>
      26:	00 00       	nop
      28:	2d c1       	rjmp	.+602    	; 0x284 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	2b c1       	rjmp	.+598    	; 0x284 <__bad_interrupt>
      2e:	00 00       	nop
      30:	29 c1       	rjmp	.+594    	; 0x284 <__bad_interrupt>
      32:	00 00       	nop
      34:	27 c1       	rjmp	.+590    	; 0x284 <__bad_interrupt>
      36:	00 00       	nop
      38:	25 c1       	rjmp	.+586    	; 0x284 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	23 c1       	rjmp	.+582    	; 0x284 <__bad_interrupt>
      3e:	00 00       	nop
      40:	21 c1       	rjmp	.+578    	; 0x284 <__bad_interrupt>
      42:	00 00       	nop
      44:	1f c1       	rjmp	.+574    	; 0x284 <__bad_interrupt>
      46:	00 00       	nop
      48:	1d c1       	rjmp	.+570    	; 0x284 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1b c1       	rjmp	.+566    	; 0x284 <__bad_interrupt>
      4e:	00 00       	nop
      50:	19 c1       	rjmp	.+562    	; 0x284 <__bad_interrupt>
      52:	00 00       	nop
      54:	17 c1       	rjmp	.+558    	; 0x284 <__bad_interrupt>
      56:	00 00       	nop
      58:	15 c1       	rjmp	.+554    	; 0x284 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	13 c1       	rjmp	.+550    	; 0x284 <__bad_interrupt>
      5e:	00 00       	nop
      60:	11 c1       	rjmp	.+546    	; 0x284 <__bad_interrupt>
      62:	00 00       	nop
      64:	0f c1       	rjmp	.+542    	; 0x284 <__bad_interrupt>
      66:	00 00       	nop
      68:	0d c1       	rjmp	.+538    	; 0x284 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	0b c1       	rjmp	.+534    	; 0x284 <__bad_interrupt>
      6e:	00 00       	nop
      70:	09 c1       	rjmp	.+530    	; 0x284 <__bad_interrupt>
      72:	00 00       	nop
      74:	07 c1       	rjmp	.+526    	; 0x284 <__bad_interrupt>
      76:	00 00       	nop
      78:	05 c1       	rjmp	.+522    	; 0x284 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	03 c1       	rjmp	.+518    	; 0x284 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 a9 19 	jmp	0x3352	; 0x3352 <__vector_32>
      84:	ff c0       	rjmp	.+510    	; 0x284 <__bad_interrupt>
      86:	00 00       	nop
      88:	fd c0       	rjmp	.+506    	; 0x284 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fb c0       	rjmp	.+502    	; 0x284 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f9 c0       	rjmp	.+498    	; 0x284 <__bad_interrupt>
      92:	00 00       	nop
      94:	f7 c0       	rjmp	.+494    	; 0x284 <__bad_interrupt>
      96:	00 00       	nop
      98:	f5 c0       	rjmp	.+490    	; 0x284 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	f3 c0       	rjmp	.+486    	; 0x284 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	f1 c0       	rjmp	.+482    	; 0x284 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	ef c0       	rjmp	.+478    	; 0x284 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	ed c0       	rjmp	.+474    	; 0x284 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	eb c0       	rjmp	.+470    	; 0x284 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	e9 c0       	rjmp	.+466    	; 0x284 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	e7 c0       	rjmp	.+462    	; 0x284 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	e5 c0       	rjmp	.+458    	; 0x284 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	e3 c0       	rjmp	.+454    	; 0x284 <__bad_interrupt>
      be:	00 00       	nop
      c0:	e1 c0       	rjmp	.+450    	; 0x284 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	df c0       	rjmp	.+446    	; 0x284 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	dd c0       	rjmp	.+442    	; 0x284 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 ff 2f 	jmp	0x5ffe	; 0x5ffe <__vector_51>
      d0:	d9 c0       	rjmp	.+434    	; 0x284 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	d7 c0       	rjmp	.+430    	; 0x284 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	d5 c0       	rjmp	.+426    	; 0x284 <__bad_interrupt>
      da:	00 00       	nop
      dc:	d3 c0       	rjmp	.+422    	; 0x284 <__bad_interrupt>
      de:	00 00       	nop
      e0:	d1 c0       	rjmp	.+418    	; 0x284 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 05       	cpc	r19, r15
     112:	a8 4c       	sbci	r26, 0xC8	; 200
     114:	cd b2       	in	r12, 0x1d	; 29
     116:	d4 4e       	sbci	r29, 0xE4	; 228
     118:	b9 38       	cpi	r27, 0x89	; 137
     11a:	36 a9       	ldd	r19, Z+54	; 0x36
     11c:	02 0c       	add	r0, r2
     11e:	50 b9       	out	0x00, r21	; 0
     120:	91 86       	std	Z+9, r9	; 0x09
     122:	88 08       	sbc	r8, r8
     124:	3c a6       	std	Y+44, r3	; 0x2c
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	2a be       	out	0x3a, r2	; 58
     12a:	00 00       	nop
     12c:	00 80       	ld	r0, Z
     12e:	3f 00       	.word	0x003f	; ????

00000130 <__trampolines_end>:
     130:	6e 61       	ori	r22, 0x1E	; 30
     132:	6e 00       	.word	0x006e	; ????

00000134 <__c.2332>:
     134:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     144:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     154:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     164:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     174:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     184:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     194:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     1a4:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     1b4:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     1c4:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     1d4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     1e4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1f4:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     204:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     214:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     224:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000232 <prvIdleTask>:
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     232:	c7 e8       	ldi	r28, 0x87	; 135
     234:	da e1       	ldi	r29, 0x1A	; 26
     236:	88 81       	ld	r24, Y
     238:	82 30       	cpi	r24, 0x02	; 2
     23a:	f0 f3       	brcs	.-4      	; 0x238 <prvIdleTask+0x6>
     23c:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
     240:	fa cf       	rjmp	.-12     	; 0x236 <prvIdleTask+0x4>

00000242 <__ctors_end>:
     242:	11 24       	eor	r1, r1
     244:	1f be       	out	0x3f, r1	; 63
     246:	cf ef       	ldi	r28, 0xFF	; 255
     248:	d1 e2       	ldi	r29, 0x21	; 33
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	cd bf       	out	0x3d, r28	; 61
     24e:	00 e0       	ldi	r16, 0x00	; 0
     250:	0c bf       	out	0x3c, r16	; 60

00000252 <__do_copy_data>:
     252:	17 e0       	ldi	r17, 0x07	; 7
     254:	a0 e0       	ldi	r26, 0x00	; 0
     256:	b2 e0       	ldi	r27, 0x02	; 2
     258:	e6 e7       	ldi	r30, 0x76	; 118
     25a:	f2 e7       	ldi	r31, 0x72	; 114
     25c:	00 e0       	ldi	r16, 0x00	; 0
     25e:	0b bf       	out	0x3b, r16	; 59
     260:	02 c0       	rjmp	.+4      	; 0x266 <__do_copy_data+0x14>
     262:	07 90       	elpm	r0, Z+
     264:	0d 92       	st	X+, r0
     266:	a6 33       	cpi	r26, 0x36	; 54
     268:	b1 07       	cpc	r27, r17
     26a:	d9 f7       	brne	.-10     	; 0x262 <__do_copy_data+0x10>

0000026c <__do_clear_bss>:
     26c:	2b e1       	ldi	r18, 0x1B	; 27
     26e:	a6 e3       	ldi	r26, 0x36	; 54
     270:	b7 e0       	ldi	r27, 0x07	; 7
     272:	01 c0       	rjmp	.+2      	; 0x276 <.do_clear_bss_start>

00000274 <.do_clear_bss_loop>:
     274:	1d 92       	st	X+, r1

00000276 <.do_clear_bss_start>:
     276:	a6 3f       	cpi	r26, 0xF6	; 246
     278:	b2 07       	cpc	r27, r18
     27a:	e1 f7       	brne	.-8      	; 0x274 <.do_clear_bss_loop>
     27c:	0e 94 52 15 	call	0x2aa4	; 0x2aa4 <main>
     280:	0c 94 39 39 	jmp	0x7272	; 0x7272 <_exit>

00000284 <__bad_interrupt>:
     284:	bd ce       	rjmp	.-646    	; 0x0 <__vectors>

00000286 <arq_init>:
  return len;
}

uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}
     286:	cf 93       	push	r28
     288:	df 93       	push	r29
     28a:	6b e3       	ldi	r22, 0x3B	; 59
     28c:	74 e0       	ldi	r23, 0x04	; 4
     28e:	81 e0       	ldi	r24, 0x01	; 1
     290:	0e 94 99 17 	call	0x2f32	; 0x2f32 <network_set_callback>
     294:	10 92 37 07 	sts	0x0737, r1	; 0x800737 <__data_end+0x1>
     298:	10 92 36 07 	sts	0x0736, r1	; 0x800736 <__data_end>
     29c:	c8 e3       	ldi	r28, 0x38	; 56
     29e:	d7 e0       	ldi	r29, 0x07	; 7
     2a0:	8d e8       	ldi	r24, 0x8D	; 141
     2a2:	fe 01       	movw	r30, r28
     2a4:	11 92       	st	Z+, r1
     2a6:	8a 95       	dec	r24
     2a8:	e9 f7       	brne	.-6      	; 0x2a4 <arq_init+0x1e>
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	0e 94 fd 19 	call	0x33fa	; 0x33fa <xQueueCreateMutex>
     2b0:	90 93 c2 07 	sts	0x07C2, r25	; 0x8007c2 <connections+0x8a>
     2b4:	80 93 c1 07 	sts	0x07C1, r24	; 0x8007c1 <connections+0x89>
     2b8:	18 82       	st	Y, r1
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	08 95       	ret

000002c0 <arq_new_connection>:
     2c0:	80 91 38 07 	lds	r24, 0x0738	; 0x800738 <connections>
     2c4:	81 11       	cpse	r24, r1
     2c6:	16 c0       	rjmp	.+44     	; 0x2f4 <arq_new_connection+0x34>
     2c8:	e8 e3       	ldi	r30, 0x38	; 56
     2ca:	f7 e0       	ldi	r31, 0x07	; 7
     2cc:	16 8e       	std	Z+30, r1	; 0x1e
     2ce:	15 8e       	std	Z+29, r1	; 0x1d
     2d0:	16 8a       	std	Z+22, r1	; 0x16
     2d2:	15 8a       	std	Z+21, r1	; 0x15
     2d4:	14 a2       	std	Z+36, r1	; 0x24
     2d6:	13 a2       	std	Z+35, r1	; 0x23
     2d8:	12 a2       	std	Z+34, r1	; 0x22
     2da:	11 a2       	std	Z+33, r1	; 0x21
     2dc:	17 8e       	std	Z+31, r1	; 0x1f
     2de:	14 8e       	std	Z+28, r1	; 0x1c
     2e0:	12 8e       	std	Z+26, r1	; 0x1a
     2e2:	11 8e       	std	Z+25, r1	; 0x19
     2e4:	13 8e       	std	Z+27, r1	; 0x1b
     2e6:	10 92 c4 07 	sts	0x07C4, r1	; 0x8007c4 <connections+0x8c>
     2ea:	10 92 c3 07 	sts	0x07C3, r1	; 0x8007c3 <connections+0x8b>
     2ee:	91 e0       	ldi	r25, 0x01	; 1
     2f0:	90 83       	st	Z, r25
     2f2:	08 95       	ret
     2f4:	8f ef       	ldi	r24, 0xFF	; 255
     2f6:	08 95       	ret

000002f8 <arq_connect>:
     2f8:	cf 92       	push	r12
     2fa:	df 92       	push	r13
     2fc:	ef 92       	push	r14
     2fe:	ff 92       	push	r15
     300:	0f 93       	push	r16
     302:	1f 93       	push	r17
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	1f 92       	push	r1
     30a:	cd b7       	in	r28, 0x3d	; 61
     30c:	de b7       	in	r29, 0x3e	; 62
     30e:	69 01       	movw	r12, r18
     310:	e8 2e       	mov	r14, r24
     312:	f1 2c       	mov	r15, r1
     314:	9d e8       	ldi	r25, 0x8D	; 141
     316:	89 9f       	mul	r24, r25
     318:	80 01       	movw	r16, r0
     31a:	11 24       	eor	r1, r1
     31c:	08 5c       	subi	r16, 0xC8	; 200
     31e:	18 4f       	sbci	r17, 0xF8	; 248
     320:	83 e0       	ldi	r24, 0x03	; 3
     322:	f8 01       	movw	r30, r16
     324:	80 83       	st	Z, r24
     326:	50 8f       	std	Z+24, r21	; 0x18
     328:	47 8b       	std	Z+23, r20	; 0x17
     32a:	60 a3       	std	Z+32, r22	; 0x20
     32c:	82 e0       	ldi	r24, 0x02	; 2
     32e:	89 83       	std	Y+1, r24	; 0x01
     330:	0e 94 cb 2b 	call	0x5796	; 0x5796 <xTaskGetCurrentTaskHandle>
     334:	f8 01       	movw	r30, r16
     336:	e5 57       	subi	r30, 0x75	; 117
     338:	ff 4f       	sbci	r31, 0xFF	; 255
     33a:	91 83       	std	Z+1, r25	; 0x01
     33c:	80 83       	st	Z, r24
     33e:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskNotifyStateClear>
     342:	21 e0       	ldi	r18, 0x01	; 1
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	ae 01       	movw	r20, r28
     348:	4f 5f       	subi	r20, 0xFF	; 255
     34a:	5f 4f       	sbci	r21, 0xFF	; 255
     34c:	61 e0       	ldi	r22, 0x01	; 1
     34e:	f8 01       	movw	r30, r16
     350:	80 a1       	ldd	r24, Z+32	; 0x20
     352:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <network_send>
     356:	b6 01       	movw	r22, r12
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	0e 94 84 2c 	call	0x5908	; 0x5908 <ulTaskNotifyTake>
     35e:	67 2b       	or	r22, r23
     360:	68 2b       	or	r22, r24
     362:	69 2b       	or	r22, r25
     364:	61 f4       	brne	.+24     	; 0x37e <arq_connect+0x86>
     366:	8d e8       	ldi	r24, 0x8D	; 141
     368:	8e 9d       	mul	r24, r14
     36a:	f0 01       	movw	r30, r0
     36c:	8f 9d       	mul	r24, r15
     36e:	f0 0d       	add	r31, r0
     370:	11 24       	eor	r1, r1
     372:	e8 5c       	subi	r30, 0xC8	; 200
     374:	f8 4f       	sbci	r31, 0xF8	; 248
     376:	81 e0       	ldi	r24, 0x01	; 1
     378:	80 83       	st	Z, r24
     37a:	80 e0       	ldi	r24, 0x00	; 0
     37c:	2e c0       	rjmp	.+92     	; 0x3da <arq_connect+0xe2>
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	91 e0       	ldi	r25, 0x01	; 1
     382:	65 d6       	rcall	.+3274   	; 0x104e <pvPortMalloc>
     384:	00 97       	sbiw	r24, 0x00	; 0
     386:	31 f1       	breq	.+76     	; 0x3d4 <arq_connect+0xdc>
     388:	4d e8       	ldi	r20, 0x8D	; 141
     38a:	4e 9d       	mul	r20, r14
     38c:	90 01       	movw	r18, r0
     38e:	4f 9d       	mul	r20, r15
     390:	30 0d       	add	r19, r0
     392:	11 24       	eor	r1, r1
     394:	40 e0       	ldi	r20, 0x00	; 0
     396:	51 e0       	ldi	r21, 0x01	; 1
     398:	bc 01       	movw	r22, r24
     39a:	c9 01       	movw	r24, r18
     39c:	87 5c       	subi	r24, 0xC7	; 199
     39e:	98 4f       	sbci	r25, 0xF8	; 248
     3a0:	5b d3       	rcall	.+1718   	; 0xa58 <buffer_init>
     3a2:	84 e1       	ldi	r24, 0x14	; 20
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	53 d6       	rcall	.+3238   	; 0x104e <pvPortMalloc>
     3a8:	00 97       	sbiw	r24, 0x00	; 0
     3aa:	b1 f0       	breq	.+44     	; 0x3d8 <arq_connect+0xe0>
     3ac:	2d e8       	ldi	r18, 0x8D	; 141
     3ae:	2e 9d       	mul	r18, r14
     3b0:	80 01       	movw	r16, r0
     3b2:	2f 9d       	mul	r18, r15
     3b4:	10 0d       	add	r17, r0
     3b6:	11 24       	eor	r1, r1
     3b8:	44 e1       	ldi	r20, 0x14	; 20
     3ba:	50 e0       	ldi	r21, 0x00	; 0
     3bc:	bc 01       	movw	r22, r24
     3be:	c8 01       	movw	r24, r16
     3c0:	8d 5b       	subi	r24, 0xBD	; 189
     3c2:	98 4f       	sbci	r25, 0xF8	; 248
     3c4:	49 d3       	rcall	.+1682   	; 0xa58 <buffer_init>
     3c6:	f8 01       	movw	r30, r16
     3c8:	e8 5c       	subi	r30, 0xC8	; 200
     3ca:	f8 4f       	sbci	r31, 0xF8	; 248
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	80 83       	st	Z, r24
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	03 c0       	rjmp	.+6      	; 0x3da <arq_connect+0xe2>
     3d4:	8f ef       	ldi	r24, 0xFF	; 255
     3d6:	01 c0       	rjmp	.+2      	; 0x3da <arq_connect+0xe2>
     3d8:	8f ef       	ldi	r24, 0xFF	; 255
     3da:	0f 90       	pop	r0
     3dc:	df 91       	pop	r29
     3de:	cf 91       	pop	r28
     3e0:	1f 91       	pop	r17
     3e2:	0f 91       	pop	r16
     3e4:	ff 90       	pop	r15
     3e6:	ef 90       	pop	r14
     3e8:	df 90       	pop	r13
     3ea:	cf 90       	pop	r12
     3ec:	08 95       	ret

000003ee <arq_close_connection>:
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
     3f2:	81 11       	cpse	r24, r1
     3f4:	34 c0       	rjmp	.+104    	; 0x45e <__FUSE_REGION_LENGTH__+0x5e>
     3f6:	20 e0       	ldi	r18, 0x00	; 0
     3f8:	4f ef       	ldi	r20, 0xFF	; 255
     3fa:	5f ef       	ldi	r21, 0xFF	; 255
     3fc:	60 e0       	ldi	r22, 0x00	; 0
     3fe:	70 e0       	ldi	r23, 0x00	; 0
     400:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     404:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     408:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
     40c:	80 91 38 07 	lds	r24, 0x0738	; 0x800738 <connections>
     410:	82 30       	cpi	r24, 0x02	; 2
     412:	51 f0       	breq	.+20     	; 0x428 <__FUSE_REGION_LENGTH__+0x28>
     414:	60 e0       	ldi	r22, 0x00	; 0
     416:	70 e0       	ldi	r23, 0x00	; 0
     418:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     41c:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     420:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	1c c0       	rjmp	.+56     	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     428:	c8 e3       	ldi	r28, 0x38	; 56
     42a:	d7 e0       	ldi	r29, 0x07	; 7
     42c:	89 81       	ldd	r24, Y+1	; 0x01
     42e:	9a 81       	ldd	r25, Y+2	; 0x02
     430:	18 d7       	rcall	.+3632   	; 0x1262 <vPortFree>
     432:	8b 85       	ldd	r24, Y+11	; 0x0b
     434:	9c 85       	ldd	r25, Y+12	; 0x0c
     436:	15 d7       	rcall	.+3626   	; 0x1262 <vPortFree>
     438:	81 e0       	ldi	r24, 0x01	; 1
     43a:	88 83       	st	Y, r24
     43c:	ef 89       	ldd	r30, Y+23	; 0x17
     43e:	f8 8d       	ldd	r31, Y+24	; 0x18
     440:	60 e0       	ldi	r22, 0x00	; 0
     442:	70 e0       	ldi	r23, 0x00	; 0
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	19 95       	eicall
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     452:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     456:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
     45a:	81 e0       	ldi	r24, 0x01	; 1
     45c:	01 c0       	rjmp	.+2      	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	08 95       	ret

00000466 <arq_send>:
     466:	ef 92       	push	r14
     468:	ff 92       	push	r15
     46a:	0f 93       	push	r16
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	df 93       	push	r29
     472:	00 d0       	rcall	.+0      	; 0x474 <arq_send+0xe>
     474:	1f 92       	push	r1
     476:	cd b7       	in	r28, 0x3d	; 61
     478:	de b7       	in	r29, 0x3e	; 62
     47a:	5c 83       	std	Y+4, r21	; 0x04
     47c:	4b 83       	std	Y+3, r20	; 0x03
     47e:	81 11       	cpse	r24, r1
     480:	7b c0       	rjmp	.+246    	; 0x578 <arq_send+0x112>
     482:	7b 01       	movw	r14, r22
     484:	20 e0       	ldi	r18, 0x00	; 0
     486:	4f ef       	ldi	r20, 0xFF	; 255
     488:	5f ef       	ldi	r21, 0xFF	; 255
     48a:	60 e0       	ldi	r22, 0x00	; 0
     48c:	70 e0       	ldi	r23, 0x00	; 0
     48e:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     492:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     496:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
     49a:	80 91 38 07 	lds	r24, 0x0738	; 0x800738 <connections>
     49e:	82 30       	cpi	r24, 0x02	; 2
     4a0:	51 f4       	brne	.+20     	; 0x4b6 <arq_send+0x50>
     4a2:	e1 14       	cp	r14, r1
     4a4:	f1 04       	cpc	r15, r1
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <arq_send+0x50>
     4a8:	0b 81       	ldd	r16, Y+3	; 0x03
     4aa:	1c 81       	ldd	r17, Y+4	; 0x04
     4ac:	c8 01       	movw	r24, r16
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	84 36       	cpi	r24, 0x64	; 100
     4b2:	91 05       	cpc	r25, r1
     4b4:	50 f0       	brcs	.+20     	; 0x4ca <arq_send+0x64>
     4b6:	60 e0       	ldi	r22, 0x00	; 0
     4b8:	70 e0       	ldi	r23, 0x00	; 0
     4ba:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     4be:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     4c2:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	58 c0       	rjmp	.+176    	; 0x57a <arq_send+0x114>
     4ca:	0e 5f       	subi	r16, 0xFE	; 254
     4cc:	1f 4f       	sbci	r17, 0xFF	; 255
     4ce:	20 91 41 07 	lds	r18, 0x0741	; 0x800741 <connections+0x9>
     4d2:	30 91 42 07 	lds	r19, 0x0742	; 0x800742 <connections+0xa>
     4d6:	80 e0       	ldi	r24, 0x00	; 0
     4d8:	91 e0       	ldi	r25, 0x01	; 1
     4da:	82 1b       	sub	r24, r18
     4dc:	93 0b       	sbc	r25, r19
     4de:	08 17       	cp	r16, r24
     4e0:	19 07       	cpc	r17, r25
     4e2:	08 f0       	brcs	.+2      	; 0x4e6 <arq_send+0x80>
     4e4:	3f c0       	rjmp	.+126    	; 0x564 <arq_send+0xfe>
     4e6:	20 91 4b 07 	lds	r18, 0x074B	; 0x80074b <connections+0x13>
     4ea:	30 91 4c 07 	lds	r19, 0x074C	; 0x80074c <connections+0x14>
     4ee:	84 e1       	ldi	r24, 0x14	; 20
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	82 1b       	sub	r24, r18
     4f4:	93 0b       	sbc	r25, r19
     4f6:	02 97       	sbiw	r24, 0x02	; 2
     4f8:	a8 f1       	brcs	.+106    	; 0x564 <arq_send+0xfe>
     4fa:	8a e2       	ldi	r24, 0x2A	; 42
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	9a 83       	std	Y+2, r25	; 0x02
     500:	89 83       	std	Y+1, r24	; 0x01
     502:	42 e0       	ldi	r20, 0x02	; 2
     504:	50 e0       	ldi	r21, 0x00	; 0
     506:	be 01       	movw	r22, r28
     508:	6d 5f       	subi	r22, 0xFD	; 253
     50a:	7f 4f       	sbci	r23, 0xFF	; 255
     50c:	89 e3       	ldi	r24, 0x39	; 57
     50e:	97 e0       	ldi	r25, 0x07	; 7
     510:	b5 d2       	rcall	.+1386   	; 0xa7c <buffer_append>
     512:	4b 81       	ldd	r20, Y+3	; 0x03
     514:	5c 81       	ldd	r21, Y+4	; 0x04
     516:	b7 01       	movw	r22, r14
     518:	89 e3       	ldi	r24, 0x39	; 57
     51a:	97 e0       	ldi	r25, 0x07	; 7
     51c:	af d2       	rcall	.+1374   	; 0xa7c <buffer_append>
     51e:	01 15       	cp	r16, r1
     520:	11 05       	cpc	r17, r1
     522:	b1 f0       	breq	.+44     	; 0x550 <arq_send+0xea>
     524:	90 2f       	mov	r25, r16
     526:	81 2f       	mov	r24, r17
     528:	0b 32       	cpi	r16, 0x2B	; 43
     52a:	11 05       	cpc	r17, r1
     52c:	10 f0       	brcs	.+4      	; 0x532 <arq_send+0xcc>
     52e:	9a e2       	ldi	r25, 0x2A	; 42
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	99 83       	std	Y+1, r25	; 0x01
     534:	8a 83       	std	Y+2, r24	; 0x02
     536:	42 e0       	ldi	r20, 0x02	; 2
     538:	50 e0       	ldi	r21, 0x00	; 0
     53a:	be 01       	movw	r22, r28
     53c:	6f 5f       	subi	r22, 0xFF	; 255
     53e:	7f 4f       	sbci	r23, 0xFF	; 255
     540:	83 e4       	ldi	r24, 0x43	; 67
     542:	97 e0       	ldi	r25, 0x07	; 7
     544:	9b d2       	rcall	.+1334   	; 0xa7c <buffer_append>
     546:	89 81       	ldd	r24, Y+1	; 0x01
     548:	9a 81       	ldd	r25, Y+2	; 0x02
     54a:	08 1b       	sub	r16, r24
     54c:	19 0b       	sbc	r17, r25
     54e:	51 f7       	brne	.-44     	; 0x524 <arq_send+0xbe>
     550:	60 e0       	ldi	r22, 0x00	; 0
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     558:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     55c:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	0b c0       	rjmp	.+22     	; 0x57a <arq_send+0x114>
     564:	60 e0       	ldi	r22, 0x00	; 0
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     56c:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     570:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	01 c0       	rjmp	.+2      	; 0x57a <arq_send+0x114>
     578:	80 e0       	ldi	r24, 0x00	; 0
     57a:	0f 90       	pop	r0
     57c:	0f 90       	pop	r0
     57e:	0f 90       	pop	r0
     580:	0f 90       	pop	r0
     582:	df 91       	pop	r29
     584:	cf 91       	pop	r28
     586:	1f 91       	pop	r17
     588:	0f 91       	pop	r16
     58a:	ff 90       	pop	r15
     58c:	ef 90       	pop	r14
     58e:	08 95       	ret

00000590 <arq_send_ack>:

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	1f 92       	push	r1
     596:	1f 92       	push	r1
     598:	cd b7       	in	r28, 0x3d	; 61
     59a:	de b7       	in	r29, 0x3e	; 62
  if(id >= MAX_CONNECTIONS) return 0;
     59c:	81 11       	cpse	r24, r1
     59e:	14 c0       	rjmp	.+40     	; 0x5c8 <arq_send_ack+0x38>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
     5a0:	80 91 38 07 	lds	r24, 0x0738	; 0x800738 <connections>
     5a4:	82 30       	cpi	r24, 0x02	; 2
     5a6:	91 f4       	brne	.+36     	; 0x5cc <arq_send_ack+0x3c>
     5a8:	66 23       	and	r22, r22
     5aa:	94 f0       	brlt	.+36     	; 0x5d0 <arq_send_ack+0x40>
    return 0;
  }
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	89 83       	std	Y+1, r24	; 0x01
  data[1] = sequence_number;
     5b0:	6a 83       	std	Y+2, r22	; 0x02
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
     5b2:	22 e0       	ldi	r18, 0x02	; 2
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	ae 01       	movw	r20, r28
     5b8:	4f 5f       	subi	r20, 0xFF	; 255
     5ba:	5f 4f       	sbci	r21, 0xFF	; 255
     5bc:	61 e0       	ldi	r22, 0x01	; 1
     5be:	80 91 58 07 	lds	r24, 0x0758	; 0x800758 <connections+0x20>
     5c2:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <network_send>
     5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <arq_send_ack+0x42>
uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
  if(id >= MAX_CONNECTIONS) return 0;
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	03 c0       	rjmp	.+6      	; 0x5d2 <arq_send_ack+0x42>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
    return 0;
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <arq_send_ack+0x42>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}
     5d2:	0f 90       	pop	r0
     5d4:	0f 90       	pop	r0
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	08 95       	ret

000005dc <sender>:
/  When the transmit window has available space, it removes segments from the send buffer 
/  and sends them. It also increments a retransmit timer and timeout timer. When the retransmit timer
/  expires the function resends all the segments in the transmit window. On timeout the connection is
/  closed. 
*/
void sender(arq_connection id) { 
     5dc:	af 92       	push	r10
     5de:	bf 92       	push	r11
     5e0:	cf 92       	push	r12
     5e2:	df 92       	push	r13
     5e4:	ef 92       	push	r14
     5e6:	ff 92       	push	r15
     5e8:	0f 93       	push	r16
     5ea:	1f 93       	push	r17
     5ec:	cf 93       	push	r28
     5ee:	df 93       	push	r29
     5f0:	cd b7       	in	r28, 0x3d	; 61
     5f2:	de b7       	in	r29, 0x3e	; 62
     5f4:	ae 97       	sbiw	r28, 0x2e	; 46
     5f6:	0f b6       	in	r0, 0x3f	; 63
     5f8:	f8 94       	cli
     5fa:	de bf       	out	0x3e, r29	; 62
     5fc:	0f be       	out	0x3f, r0	; 63
     5fe:	cd bf       	out	0x3d, r28	; 61
  if(id >= MAX_CONNECTIONS) return;
     600:	81 11       	cpse	r24, r1
     602:	db c0       	rjmp	.+438    	; 0x7ba <sender+0x1de>
  arq_connection_t *con = &connections[id];
  if(con->status == STATUS_NONE) return;
     604:	80 91 38 07 	lds	r24, 0x0738	; 0x800738 <connections>
     608:	88 23       	and	r24, r24
     60a:	09 f4       	brne	.+2      	; 0x60e <sender+0x32>
     60c:	d6 c0       	rjmp	.+428    	; 0x7ba <sender+0x1de>
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     60e:	20 e0       	ldi	r18, 0x00	; 0
     610:	4f ef       	ldi	r20, 0xFF	; 255
     612:	5f ef       	ldi	r21, 0xFF	; 255
     614:	60 e0       	ldi	r22, 0x00	; 0
     616:	70 e0       	ldi	r23, 0x00	; 0
     618:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     61c:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     620:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
  
  if(con->status != STATUS_CONNECTED) {
     624:	80 91 38 07 	lds	r24, 0x0738	; 0x800738 <connections>
     628:	82 30       	cpi	r24, 0x02	; 2
     62a:	49 f0       	breq	.+18     	; 0x63e <sender+0x62>
    xSemaphoreGive(con->mutex);
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     634:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     638:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
    return;
     63c:	be c0       	rjmp	.+380    	; 0x7ba <sender+0x1de>
  }

  if(con->timer_started) {
     63e:	80 91 57 07 	lds	r24, 0x0757	; 0x800757 <connections+0x1f>
     642:	88 23       	and	r24, r24
     644:	09 f4       	brne	.+2      	; 0x648 <sender+0x6c>
     646:	62 c0       	rjmp	.+196    	; 0x70c <sender+0x130>
    con->timeout += 10;
     648:	e8 e3       	ldi	r30, 0x38	; 56
     64a:	f7 e0       	ldi	r31, 0x07	; 7
     64c:	85 8d       	ldd	r24, Z+29	; 0x1d
     64e:	96 8d       	ldd	r25, Z+30	; 0x1e
     650:	0a 96       	adiw	r24, 0x0a	; 10
     652:	96 8f       	std	Z+30, r25	; 0x1e
     654:	85 8f       	std	Z+29, r24	; 0x1d
    con->timer += 10;
     656:	24 8d       	ldd	r18, Z+28	; 0x1c
     658:	26 5f       	subi	r18, 0xF6	; 246
     65a:	24 8f       	std	Z+28, r18	; 0x1c
    if(con->timeout > LOST_CONNECTION_TIMEOUT_MS) { 
     65c:	89 3e       	cpi	r24, 0xE9	; 233
     65e:	93 40       	sbci	r25, 0x03	; 3
     660:	58 f0       	brcs	.+22     	; 0x678 <sender+0x9c>
      xSemaphoreGive(con->mutex);
     662:	60 e0       	ldi	r22, 0x00	; 0
     664:	70 e0       	ldi	r23, 0x00	; 0
     666:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     66a:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     66e:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
      arq_close_connection(id);
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	bc de       	rcall	.-648    	; 0x3ee <arq_close_connection>
      return;
     676:	a1 c0       	rjmp	.+322    	; 0x7ba <sender+0x1de>
    }
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
     678:	29 3c       	cpi	r18, 0xC9	; 201
     67a:	08 f4       	brcc	.+2      	; 0x67e <sender+0xa2>
     67c:	47 c0       	rjmp	.+142    	; 0x70c <sender+0x130>
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
     67e:	e8 e3       	ldi	r30, 0x38	; 56
     680:	f7 e0       	ldi	r31, 0x07	; 7
     682:	07 81       	ldd	r16, Z+7	; 0x07
     684:	10 85       	ldd	r17, Z+8	; 0x08
      uint16_t len = 0;
     686:	1e a6       	std	Y+46, r1	; 0x2e
     688:	1d a6       	std	Y+45, r1	; 0x2d
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
     68a:	a1 8c       	ldd	r10, Z+25	; 0x19
     68c:	83 8d       	ldd	r24, Z+27	; 0x1b
     68e:	a8 1a       	sub	r10, r24
     690:	8a 2d       	mov	r24, r10
     692:	8f 77       	andi	r24, 0x7F	; 127
     694:	a8 2e       	mov	r10, r24
      while(i < resend_count) {
     696:	c1 f1       	breq	.+112    	; 0x708 <sender+0x12c>
     698:	c1 2c       	mov	r12, r1
     69a:	d1 2c       	mov	r13, r1
     69c:	b1 2c       	mov	r11, r1
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
        data[1] = (con->sequence_base+i) & 127; 
     69e:	7f 01       	movw	r14, r30
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
     6a0:	19 82       	std	Y+1, r1	; 0x01
        data[1] = (con->sequence_base+i) & 127; 
     6a2:	f7 01       	movw	r30, r14
     6a4:	83 8d       	ldd	r24, Z+27	; 0x1b
     6a6:	8b 0d       	add	r24, r11
     6a8:	8f 77       	andi	r24, 0x7F	; 127
     6aa:	8a 83       	std	Y+2, r24	; 0x02
        buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*i, 2);
     6ac:	41 89       	ldd	r20, Z+17	; 0x11
     6ae:	52 89       	ldd	r21, Z+18	; 0x12
     6b0:	4c 0d       	add	r20, r12
     6b2:	5d 1d       	adc	r21, r13
     6b4:	22 e0       	ldi	r18, 0x02	; 2
     6b6:	30 e0       	ldi	r19, 0x00	; 0
     6b8:	be 01       	movw	r22, r28
     6ba:	63 5d       	subi	r22, 0xD3	; 211
     6bc:	7f 4f       	sbci	r23, 0xFF	; 255
     6be:	83 e4       	ldi	r24, 0x43	; 67
     6c0:	97 e0       	ldi	r25, 0x07	; 7
     6c2:	8b d2       	rcall	.+1302   	; 0xbda <buffer_read>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
     6c4:	2d a5       	ldd	r18, Y+45	; 0x2d
     6c6:	3e a5       	ldd	r19, Y+46	; 0x2e
     6c8:	a8 01       	movw	r20, r16
     6ca:	be 01       	movw	r22, r28
     6cc:	6d 5f       	subi	r22, 0xFD	; 253
     6ce:	7f 4f       	sbci	r23, 0xFF	; 255
     6d0:	89 e3       	ldi	r24, 0x39	; 57
     6d2:	97 e0       	ldi	r25, 0x07	; 7
     6d4:	82 d2       	rcall	.+1284   	; 0xbda <buffer_read>
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
     6d6:	2d a5       	ldd	r18, Y+45	; 0x2d
     6d8:	3e a5       	ldd	r19, Y+46	; 0x2e
     6da:	02 0f       	add	r16, r18
     6dc:	13 1f       	adc	r17, r19
     6de:	f7 01       	movw	r30, r14
     6e0:	83 81       	ldd	r24, Z+3	; 0x03
     6e2:	94 81       	ldd	r25, Z+4	; 0x04
     6e4:	01 97       	sbiw	r24, 0x01	; 1
     6e6:	08 23       	and	r16, r24
     6e8:	19 23       	and	r17, r25
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     6ea:	2e 5f       	subi	r18, 0xFE	; 254
     6ec:	3f 4f       	sbci	r19, 0xFF	; 255
     6ee:	ae 01       	movw	r20, r28
     6f0:	4f 5f       	subi	r20, 0xFF	; 255
     6f2:	5f 4f       	sbci	r21, 0xFF	; 255
     6f4:	61 e0       	ldi	r22, 0x01	; 1
     6f6:	80 a1       	ldd	r24, Z+32	; 0x20
     6f8:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <network_send>
        ++i;
     6fc:	b3 94       	inc	r11
     6fe:	f2 e0       	ldi	r31, 0x02	; 2
     700:	cf 0e       	add	r12, r31
     702:	d1 1c       	adc	r13, r1
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
     704:	ab 10       	cpse	r10, r11
     706:	cc cf       	rjmp	.-104    	; 0x6a0 <sender+0xc4>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
        ++i;
      }
      con->timer = 0;
     708:	10 92 54 07 	sts	0x0754, r1	; 0x800754 <connections+0x1c>
    }
  }
  if( ((con->sequence_number-con->sequence_base) & 127) < WINDOW_SIZE && con->send_buffer.head != con->send_buffer_window_end) {
     70c:	e8 e3       	ldi	r30, 0x38	; 56
     70e:	f7 e0       	ldi	r31, 0x07	; 7
     710:	81 8d       	ldd	r24, Z+25	; 0x19
     712:	48 2f       	mov	r20, r24
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	93 8d       	ldd	r25, Z+27	; 0x1b
     718:	49 1b       	sub	r20, r25
     71a:	51 09       	sbc	r21, r1
     71c:	4f 77       	andi	r20, 0x7F	; 127
     71e:	55 27       	eor	r21, r21
     720:	44 30       	cpi	r20, 0x04	; 4
     722:	51 05       	cpc	r21, r1
     724:	0c f0       	brlt	.+2      	; 0x728 <sender+0x14c>
     726:	41 c0       	rjmp	.+130    	; 0x7aa <sender+0x1ce>
     728:	65 81       	ldd	r22, Z+5	; 0x05
     72a:	76 81       	ldd	r23, Z+6	; 0x06
     72c:	25 89       	ldd	r18, Z+21	; 0x15
     72e:	36 89       	ldd	r19, Z+22	; 0x16
     730:	62 17       	cp	r22, r18
     732:	73 07       	cpc	r23, r19
     734:	d1 f1       	breq	.+116    	; 0x7aa <sender+0x1ce>
    uint8_t data[MAX_PAYLOAD_SIZE];
    uint16_t len;
    data[0] = TYPE_DATA;
     736:	19 82       	std	Y+1, r1	; 0x01
    data[1] = con->sequence_number;
     738:	8a 83       	std	Y+2, r24	; 0x02
    buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*((con->sequence_number-con->sequence_base) & 127), 2);
     73a:	8f 01       	movw	r16, r30
     73c:	44 0f       	add	r20, r20
     73e:	55 1f       	adc	r21, r21
     740:	81 89       	ldd	r24, Z+17	; 0x11
     742:	92 89       	ldd	r25, Z+18	; 0x12
     744:	48 0f       	add	r20, r24
     746:	59 1f       	adc	r21, r25
     748:	22 e0       	ldi	r18, 0x02	; 2
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	be 01       	movw	r22, r28
     74e:	63 5d       	subi	r22, 0xD3	; 211
     750:	7f 4f       	sbci	r23, 0xFF	; 255
     752:	83 e4       	ldi	r24, 0x43	; 67
     754:	97 e0       	ldi	r25, 0x07	; 7
     756:	41 d2       	rcall	.+1154   	; 0xbda <buffer_read>
    buffer_read(&con->send_buffer, &data[2], con->send_buffer_window_end, len);
     758:	2d a5       	ldd	r18, Y+45	; 0x2d
     75a:	3e a5       	ldd	r19, Y+46	; 0x2e
     75c:	f8 01       	movw	r30, r16
     75e:	45 89       	ldd	r20, Z+21	; 0x15
     760:	56 89       	ldd	r21, Z+22	; 0x16
     762:	be 01       	movw	r22, r28
     764:	6d 5f       	subi	r22, 0xFD	; 253
     766:	7f 4f       	sbci	r23, 0xFF	; 255
     768:	89 e3       	ldi	r24, 0x39	; 57
     76a:	97 e0       	ldi	r25, 0x07	; 7
     76c:	36 d2       	rcall	.+1132   	; 0xbda <buffer_read>
    con->send_buffer_window_end = (con->send_buffer_window_end+len) & (con->send_buffer.capacity-1);
     76e:	2d a5       	ldd	r18, Y+45	; 0x2d
     770:	3e a5       	ldd	r19, Y+46	; 0x2e
     772:	f8 01       	movw	r30, r16
     774:	85 89       	ldd	r24, Z+21	; 0x15
     776:	96 89       	ldd	r25, Z+22	; 0x16
     778:	a9 01       	movw	r20, r18
     77a:	48 0f       	add	r20, r24
     77c:	59 1f       	adc	r21, r25
     77e:	83 81       	ldd	r24, Z+3	; 0x03
     780:	94 81       	ldd	r25, Z+4	; 0x04
     782:	01 97       	sbiw	r24, 0x01	; 1
     784:	84 23       	and	r24, r20
     786:	95 23       	and	r25, r21
     788:	96 8b       	std	Z+22, r25	; 0x16
     78a:	85 8b       	std	Z+21, r24	; 0x15
    con->timer_started = 1;
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	87 8f       	std	Z+31, r24	; 0x1f
    con->sequence_number = (con->sequence_number+1) & 127;
     790:	81 8d       	ldd	r24, Z+25	; 0x19
     792:	8f 5f       	subi	r24, 0xFF	; 255
     794:	8f 77       	andi	r24, 0x7F	; 127
     796:	81 8f       	std	Z+25, r24	; 0x19
    network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     798:	2e 5f       	subi	r18, 0xFE	; 254
     79a:	3f 4f       	sbci	r19, 0xFF	; 255
     79c:	ae 01       	movw	r20, r28
     79e:	4f 5f       	subi	r20, 0xFF	; 255
     7a0:	5f 4f       	sbci	r21, 0xFF	; 255
     7a2:	61 e0       	ldi	r22, 0x01	; 1
     7a4:	80 a1       	ldd	r24, Z+32	; 0x20
     7a6:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <network_send>
  } 
  
  xSemaphoreGive(con->mutex);
     7aa:	60 e0       	ldi	r22, 0x00	; 0
     7ac:	70 e0       	ldi	r23, 0x00	; 0
     7ae:	80 91 c1 07 	lds	r24, 0x07C1	; 0x8007c1 <connections+0x89>
     7b2:	90 91 c2 07 	lds	r25, 0x07C2	; 0x8007c2 <connections+0x8a>
     7b6:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
}
     7ba:	ae 96       	adiw	r28, 0x2e	; 46
     7bc:	0f b6       	in	r0, 0x3f	; 63
     7be:	f8 94       	cli
     7c0:	de bf       	out	0x3e, r29	; 62
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	cd bf       	out	0x3d, r28	; 61
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	df 90       	pop	r13
     7d4:	cf 90       	pop	r12
     7d6:	bf 90       	pop	r11
     7d8:	af 90       	pop	r10
     7da:	08 95       	ret

000007dc <arq_reassembly>:

void arq_reassembly(arq_connection id, uint8_t *data, uint16_t len) { 
     7dc:	0f 93       	push	r16
     7de:	1f 93       	push	r17
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	ea 01       	movw	r28, r20
  if(id >= MAX_CONNECTIONS) return;
     7e6:	81 11       	cpse	r24, r1
     7e8:	41 c0       	rjmp	.+130    	; 0x86c <arq_reassembly+0x90>
  
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
     7ea:	80 91 5b 07 	lds	r24, 0x075B	; 0x80075b <connections+0x23>
     7ee:	90 91 5c 07 	lds	r25, 0x075C	; 0x80075c <connections+0x24>
     7f2:	89 2b       	or	r24, r25
     7f4:	99 f4       	brne	.+38     	; 0x81c <arq_reassembly+0x40>
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
     7f6:	db 01       	movw	r26, r22
     7f8:	11 96       	adiw	r26, 0x01	; 1
     7fa:	8c 91       	ld	r24, X
     7fc:	11 97       	sbiw	r26, 0x01	; 1
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	98 2f       	mov	r25, r24
     802:	88 27       	eor	r24, r24
     804:	2c 91       	ld	r18, X
     806:	82 2b       	or	r24, r18
     808:	90 93 5c 07 	sts	0x075C, r25	; 0x80075c <connections+0x24>
     80c:	80 93 5b 07 	sts	0x075B, r24	; 0x80075b <connections+0x23>
    len-=2; // Remove the header from the length, left with the length of the payload
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
     810:	85 36       	cpi	r24, 0x65	; 101
     812:	91 05       	cpc	r25, r1
     814:	58 f5       	brcc	.+86     	; 0x86c <arq_reassembly+0x90>
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
    len-=2; // Remove the header from the length, left with the length of the payload
     816:	22 97       	sbiw	r28, 0x02	; 2
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
     818:	6e 5f       	subi	r22, 0xFE	; 254
     81a:	7f 4f       	sbci	r23, 0xFF	; 255
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
      return;
    }
  } 
  memcpy(con->message+con->num_received_bytes, data, len);
     81c:	08 e3       	ldi	r16, 0x38	; 56
     81e:	17 e0       	ldi	r17, 0x07	; 7
     820:	f8 01       	movw	r30, r16
     822:	81 a1       	ldd	r24, Z+33	; 0x21
     824:	92 a1       	ldd	r25, Z+34	; 0x22
     826:	ae 01       	movw	r20, r28
     828:	83 5a       	subi	r24, 0xA3	; 163
     82a:	98 4f       	sbci	r25, 0xF8	; 248
     82c:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
  con->num_received_bytes += len;
     830:	d8 01       	movw	r26, r16
     832:	91 96       	adiw	r26, 0x21	; 33
     834:	6d 91       	ld	r22, X+
     836:	7c 91       	ld	r23, X
     838:	92 97       	sbiw	r26, 0x22	; 34
     83a:	6c 0f       	add	r22, r28
     83c:	7d 1f       	adc	r23, r29
     83e:	92 96       	adiw	r26, 0x22	; 34
     840:	7c 93       	st	X, r23
     842:	6e 93       	st	-X, r22
     844:	91 97       	sbiw	r26, 0x21	; 33
  
  if(con->num_received_bytes == con->receive_message_length) {
     846:	93 96       	adiw	r26, 0x23	; 35
     848:	8d 91       	ld	r24, X+
     84a:	9c 91       	ld	r25, X
     84c:	94 97       	sbiw	r26, 0x24	; 36
     84e:	68 17       	cp	r22, r24
     850:	79 07       	cpc	r23, r25
     852:	61 f4       	brne	.+24     	; 0x86c <arq_reassembly+0x90>
    con->callback_data_received(con->message, con->num_received_bytes);
     854:	57 96       	adiw	r26, 0x17	; 23
     856:	ed 91       	ld	r30, X+
     858:	fc 91       	ld	r31, X
     85a:	58 97       	sbiw	r26, 0x18	; 24
     85c:	8d e5       	ldi	r24, 0x5D	; 93
     85e:	97 e0       	ldi	r25, 0x07	; 7
     860:	19 95       	eicall
    con->num_received_bytes = con->receive_message_length = 0;
     862:	f8 01       	movw	r30, r16
     864:	14 a2       	std	Z+36, r1	; 0x24
     866:	13 a2       	std	Z+35, r1	; 0x23
     868:	12 a2       	std	Z+34, r1	; 0x22
     86a:	11 a2       	std	Z+33, r1	; 0x21
  }
}
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	1f 91       	pop	r17
     872:	0f 91       	pop	r16
     874:	08 95       	ret

00000876 <receiver>:
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
     876:	9f 92       	push	r9
     878:	af 92       	push	r10
     87a:	bf 92       	push	r11
     87c:	cf 92       	push	r12
     87e:	df 92       	push	r13
     880:	ef 92       	push	r14
     882:	ff 92       	push	r15
     884:	0f 93       	push	r16
     886:	1f 93       	push	r17
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	1f 92       	push	r1
     88e:	cd b7       	in	r28, 0x3d	; 61
     890:	de b7       	in	r29, 0x3e	; 62
     892:	8b 01       	movw	r16, r22
     894:	5a 01       	movw	r10, r20
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
     896:	90 91 58 07 	lds	r25, 0x0758	; 0x800758 <connections+0x20>
     89a:	98 13       	cpse	r25, r24
     89c:	b8 c0       	rjmp	.+368    	; 0xa0e <receiver+0x198>
     89e:	90 91 38 07 	lds	r25, 0x0738	; 0x800738 <connections>
     8a2:	99 23       	and	r25, r25
     8a4:	09 f4       	brne	.+2      	; 0x8a8 <receiver+0x32>
     8a6:	b3 c0       	rjmp	.+358    	; 0xa0e <receiver+0x198>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     8a8:	fb 01       	movw	r30, r22
     8aa:	d0 80       	ld	r13, Z
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
      con = &connections[i];
     8ac:	0f 2e       	mov	r0, r31
     8ae:	f8 e3       	ldi	r31, 0x38	; 56
     8b0:	ef 2e       	mov	r14, r31
     8b2:	f7 e0       	ldi	r31, 0x07	; 7
     8b4:	ff 2e       	mov	r15, r31
     8b6:	f0 2d       	mov	r31, r0
     8b8:	13 c0       	rjmp	.+38     	; 0x8e0 <receiver+0x6a>
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
  if(con == NULL && type == TYPE_SYN && listening_task != NULL) {
     8ba:	e0 91 36 07 	lds	r30, 0x0736	; 0x800736 <__data_end>
     8be:	f0 91 37 07 	lds	r31, 0x0737	; 0x800737 <__data_end+0x1>
     8c2:	30 97       	sbiw	r30, 0x00	; 0
     8c4:	59 f0       	breq	.+22     	; 0x8dc <receiver+0x66>
    xTaskNotify(listening_task, address, eSetValueWithOverwrite);
     8c6:	48 2f       	mov	r20, r24
     8c8:	50 e0       	ldi	r21, 0x00	; 0
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	70 e0       	ldi	r23, 0x00	; 0
     8ce:	00 e0       	ldi	r16, 0x00	; 0
     8d0:	10 e0       	ldi	r17, 0x00	; 0
     8d2:	23 e0       	ldi	r18, 0x03	; 3
     8d4:	cf 01       	movw	r24, r30
     8d6:	0e 94 fa 2d 	call	0x5bf4	; 0x5bf4 <xTaskGenericNotify>
    return;
     8da:	aa c0       	rjmp	.+340    	; 0xa30 <receiver+0x1ba>
     8dc:	e1 2c       	mov	r14, r1
     8de:	f1 2c       	mov	r15, r1
  }
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     8e0:	20 e0       	ldi	r18, 0x00	; 0
     8e2:	4f ef       	ldi	r20, 0xFF	; 255
     8e4:	5f ef       	ldi	r21, 0xFF	; 255
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	70 e0       	ldi	r23, 0x00	; 0
     8ea:	f7 01       	movw	r30, r14
     8ec:	e7 57       	subi	r30, 0x77	; 119
     8ee:	ff 4f       	sbci	r31, 0xFF	; 255
     8f0:	80 81       	ld	r24, Z
     8f2:	91 81       	ldd	r25, Z+1	; 0x01
     8f4:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
  
  if(con->status == STATUS_CLOSED || con->status == STATUS_NONE || len == 0 || data == NULL) {
     8f8:	f7 01       	movw	r30, r14
     8fa:	80 81       	ld	r24, Z
     8fc:	82 30       	cpi	r24, 0x02	; 2
     8fe:	30 f0       	brcs	.+12     	; 0x90c <receiver+0x96>
     900:	a1 14       	cp	r10, r1
     902:	b1 04       	cpc	r11, r1
     904:	19 f0       	breq	.+6      	; 0x90c <receiver+0x96>
     906:	01 15       	cp	r16, r1
     908:	11 05       	cpc	r17, r1
     90a:	51 f4       	brne	.+20     	; 0x920 <receiver+0xaa>
    xSemaphoreGive(con->mutex);
     90c:	f7 01       	movw	r30, r14
     90e:	e7 57       	subi	r30, 0x77	; 119
     910:	ff 4f       	sbci	r31, 0xFF	; 255
     912:	60 e0       	ldi	r22, 0x00	; 0
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	80 81       	ld	r24, Z
     918:	91 81       	ldd	r25, Z+1	; 0x01
     91a:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
    return;
     91e:	88 c0       	rjmp	.+272    	; 0xa30 <receiver+0x1ba>
  }
  
  if(con->status == STATUS_CONNECTING && type == TYPE_SYNACK) {
     920:	83 30       	cpi	r24, 0x03	; 3
     922:	21 f5       	brne	.+72     	; 0x96c <receiver+0xf6>
     924:	f3 e0       	ldi	r31, 0x03	; 3
     926:	df 12       	cpse	r13, r31
     928:	21 c0       	rjmp	.+66     	; 0x96c <receiver+0xf6>
    if(con->blocked_task != NULL) {
     92a:	f7 01       	movw	r30, r14
     92c:	e5 57       	subi	r30, 0x75	; 117
     92e:	ff 4f       	sbci	r31, 0xFF	; 255
     930:	80 81       	ld	r24, Z
     932:	91 81       	ldd	r25, Z+1	; 0x01
     934:	00 97       	sbiw	r24, 0x00	; 0
     936:	81 f0       	breq	.+32     	; 0x958 <receiver+0xe2>
      xTaskNotifyGive(con->blocked_task);
     938:	00 e0       	ldi	r16, 0x00	; 0
     93a:	10 e0       	ldi	r17, 0x00	; 0
     93c:	22 e0       	ldi	r18, 0x02	; 2
     93e:	40 e0       	ldi	r20, 0x00	; 0
     940:	50 e0       	ldi	r21, 0x00	; 0
     942:	ba 01       	movw	r22, r20
     944:	0e 94 fa 2d 	call	0x5bf4	; 0x5bf4 <xTaskGenericNotify>
      con->blocked_task = NULL;
     948:	f7 01       	movw	r30, r14
     94a:	e5 57       	subi	r30, 0x75	; 117
     94c:	ff 4f       	sbci	r31, 0xFF	; 255
     94e:	11 82       	std	Z+1, r1	; 0x01
     950:	10 82       	st	Z, r1
      arq_send_ack(id, 0x00);
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	1c de       	rcall	.-968    	; 0x590 <arq_send_ack>
    }
    
    xSemaphoreGive(con->mutex);
     958:	f7 01       	movw	r30, r14
     95a:	e7 57       	subi	r30, 0x77	; 119
     95c:	ff 4f       	sbci	r31, 0xFF	; 255
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	70 e0       	ldi	r23, 0x00	; 0
     962:	80 81       	ld	r24, Z
     964:	91 81       	ldd	r25, Z+1	; 0x01
     966:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
    return;
     96a:	62 c0       	rjmp	.+196    	; 0xa30 <receiver+0x1ba>
  }
  
  uint8_t sequence = data[1];
     96c:	f8 01       	movw	r30, r16
     96e:	c1 80       	ldd	r12, Z+1	; 0x01
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
     970:	dd 20       	and	r13, r13
     972:	09 f4       	brne	.+2      	; 0x976 <receiver+0x100>
     974:	52 c0       	rjmp	.+164    	; 0xa1a <receiver+0x1a4>
     976:	f4 e0       	ldi	r31, 0x04	; 4
     978:	df 12       	cpse	r13, r31
     97a:	13 c0       	rjmp	.+38     	; 0x9a2 <receiver+0x12c>
     97c:	53 c0       	rjmp	.+166    	; 0xa24 <receiver+0x1ae>
    if(sequence == con->request_number) {
      if(type == TYPE_DATA) arq_reassembly(id, &data[2], len-2);
     97e:	a5 01       	movw	r20, r10
     980:	42 50       	subi	r20, 0x02	; 2
     982:	51 09       	sbc	r21, r1
     984:	b8 01       	movw	r22, r16
     986:	6e 5f       	subi	r22, 0xFE	; 254
     988:	7f 4f       	sbci	r23, 0xFF	; 255
     98a:	80 e0       	ldi	r24, 0x00	; 0
     98c:	27 df       	rcall	.-434    	; 0x7dc <arq_reassembly>
      con->request_number = (con->request_number+1) & 127;
     98e:	f7 01       	movw	r30, r14
     990:	82 8d       	ldd	r24, Z+26	; 0x1a
     992:	8f 5f       	subi	r24, 0xFF	; 255
     994:	8f 77       	andi	r24, 0x7F	; 127
     996:	82 8f       	std	Z+26, r24	; 0x1a
    }
    arq_send_ack(id, con->request_number);
     998:	f7 01       	movw	r30, r14
     99a:	62 8d       	ldd	r22, Z+26	; 0x1a
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	f8 dd       	rcall	.-1040   	; 0x590 <arq_send_ack>
     9a0:	2c c0       	rjmp	.+88     	; 0x9fa <receiver+0x184>
  } else if(type == TYPE_ACK) {
     9a2:	f1 e0       	ldi	r31, 0x01	; 1
     9a4:	df 12       	cpse	r13, r31
     9a6:	29 c0       	rjmp	.+82     	; 0x9fa <receiver+0x184>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
     9a8:	f7 01       	movw	r30, r14
     9aa:	83 8d       	ldd	r24, Z+27	; 0x1b
     9ac:	fc 2d       	mov	r31, r12
     9ae:	f8 1b       	sub	r31, r24
     9b0:	8f 2f       	mov	r24, r31
     9b2:	8f 77       	andi	r24, 0x7F	; 127
     9b4:	98 2e       	mov	r9, r24
    if(count != 0) {
     9b6:	09 f1       	breq	.+66     	; 0x9fa <receiver+0x184>
     9b8:	d1 2c       	mov	r13, r1
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9ba:	57 01       	movw	r10, r14
     9bc:	8b e0       	ldi	r24, 0x0B	; 11
     9be:	a8 0e       	add	r10, r24
     9c0:	b1 1c       	adc	r11, r1
        buffer_remove(&con->send_buffer, NULL, len);
     9c2:	87 01       	movw	r16, r14
     9c4:	0f 5f       	subi	r16, 0xFF	; 255
     9c6:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9c8:	42 e0       	ldi	r20, 0x02	; 2
     9ca:	50 e0       	ldi	r21, 0x00	; 0
     9cc:	be 01       	movw	r22, r28
     9ce:	6f 5f       	subi	r22, 0xFF	; 255
     9d0:	7f 4f       	sbci	r23, 0xFF	; 255
     9d2:	c5 01       	movw	r24, r10
     9d4:	50 d1       	rcall	.+672    	; 0xc76 <buffer_remove>
        buffer_remove(&con->send_buffer, NULL, len);
     9d6:	49 81       	ldd	r20, Y+1	; 0x01
     9d8:	50 e0       	ldi	r21, 0x00	; 0
     9da:	60 e0       	ldi	r22, 0x00	; 0
     9dc:	70 e0       	ldi	r23, 0x00	; 0
     9de:	c8 01       	movw	r24, r16
     9e0:	4a d1       	rcall	.+660    	; 0xc76 <buffer_remove>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
     9e2:	d3 94       	inc	r13
     9e4:	9d 10       	cpse	r9, r13
     9e6:	f0 cf       	rjmp	.-32     	; 0x9c8 <receiver+0x152>
        buffer_remove(&con->segment_lengths, &len, 2);
        buffer_remove(&con->send_buffer, NULL, len);
      }
      con->sequence_base = sequence;
     9e8:	f7 01       	movw	r30, r14
     9ea:	c3 8e       	std	Z+27, r12	; 0x1b

      con->timer = 0;
     9ec:	14 8e       	std	Z+28, r1	; 0x1c
      con->timeout = 0;
     9ee:	16 8e       	std	Z+30, r1	; 0x1e
     9f0:	15 8e       	std	Z+29, r1	; 0x1d
      if(con->sequence_base == con->sequence_number) con->timer_started = 0; // No more un-acked packets
     9f2:	81 8d       	ldd	r24, Z+25	; 0x19
     9f4:	c8 12       	cpse	r12, r24
     9f6:	01 c0       	rjmp	.+2      	; 0x9fa <receiver+0x184>
     9f8:	17 8e       	std	Z+31, r1	; 0x1f
    }
  }
  
  xSemaphoreGive(con->mutex);
     9fa:	f7 01       	movw	r30, r14
     9fc:	e7 57       	subi	r30, 0x77	; 119
     9fe:	ff 4f       	sbci	r31, 0xFF	; 255
     a00:	60 e0       	ldi	r22, 0x00	; 0
     a02:	70 e0       	ldi	r23, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	91 81       	ldd	r25, Z+1	; 0x01
     a08:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
     a0c:	11 c0       	rjmp	.+34     	; 0xa30 <receiver+0x1ba>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     a0e:	f8 01       	movw	r30, r16
     a10:	d0 80       	ld	r13, Z
  
  if(con == NULL && type != TYPE_SYN) return;
     a12:	f2 e0       	ldi	r31, 0x02	; 2
     a14:	df 12       	cpse	r13, r31
     a16:	0c c0       	rjmp	.+24     	; 0xa30 <receiver+0x1ba>
     a18:	50 cf       	rjmp	.-352    	; 0x8ba <receiver+0x44>
    return;
  }
  
  uint8_t sequence = data[1];
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
    if(sequence == con->request_number) {
     a1a:	f7 01       	movw	r30, r14
     a1c:	82 8d       	ldd	r24, Z+26	; 0x1a
     a1e:	c8 12       	cpse	r12, r24
     a20:	bb cf       	rjmp	.-138    	; 0x998 <receiver+0x122>
     a22:	ad cf       	rjmp	.-166    	; 0x97e <receiver+0x108>
     a24:	f7 01       	movw	r30, r14
     a26:	82 8d       	ldd	r24, Z+26	; 0x1a
     a28:	c8 16       	cp	r12, r24
     a2a:	09 f4       	brne	.+2      	; 0xa2e <receiver+0x1b8>
     a2c:	b0 cf       	rjmp	.-160    	; 0x98e <receiver+0x118>
     a2e:	b4 cf       	rjmp	.-152    	; 0x998 <receiver+0x122>
    }
  }
  
  xSemaphoreGive(con->mutex);
  
}
     a30:	0f 90       	pop	r0
     a32:	df 91       	pop	r29
     a34:	cf 91       	pop	r28
     a36:	1f 91       	pop	r17
     a38:	0f 91       	pop	r16
     a3a:	ff 90       	pop	r15
     a3c:	ef 90       	pop	r14
     a3e:	df 90       	pop	r13
     a40:	cf 90       	pop	r12
     a42:	bf 90       	pop	r11
     a44:	af 90       	pop	r10
     a46:	9f 90       	pop	r9
     a48:	08 95       	ret

00000a4a <vARQTask>:
void vARQTask(void *pvParamters) {
  uint8_t i;
  
  while(1) {
    for(i=0;i<MAX_CONNECTIONS;i++) {
		sender(i);
     a4a:	80 e0       	ldi	r24, 0x00	; 0
     a4c:	c7 dd       	rcall	.-1138   	; 0x5dc <sender>
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
     a4e:	8a e0       	ldi	r24, 0x0A	; 10
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <vTaskDelay>
     a56:	f9 cf       	rjmp	.-14     	; 0xa4a <vARQTask>

00000a58 <buffer_init>:
     a58:	fc 01       	movw	r30, r24
     a5a:	61 15       	cp	r22, r1
     a5c:	71 05       	cpc	r23, r1
     a5e:	61 f0       	breq	.+24     	; 0xa78 <buffer_init+0x20>
     a60:	71 83       	std	Z+1, r23	; 0x01
     a62:	60 83       	st	Z, r22
     a64:	53 83       	std	Z+3, r21	; 0x03
     a66:	42 83       	std	Z+2, r20	; 0x02
     a68:	11 86       	std	Z+9, r1	; 0x09
     a6a:	10 86       	std	Z+8, r1	; 0x08
     a6c:	17 82       	std	Z+7, r1	; 0x07
     a6e:	16 82       	std	Z+6, r1	; 0x06
     a70:	15 82       	std	Z+5, r1	; 0x05
     a72:	14 82       	std	Z+4, r1	; 0x04
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	08 95       	ret
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	08 95       	ret

00000a7c <buffer_append>:
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	ec 01       	movw	r28, r24
     a8a:	2a 81       	ldd	r18, Y+2	; 0x02
     a8c:	3b 81       	ldd	r19, Y+3	; 0x03
     a8e:	88 85       	ldd	r24, Y+8	; 0x08
     a90:	99 85       	ldd	r25, Y+9	; 0x09
     a92:	f9 01       	movw	r30, r18
     a94:	e8 1b       	sub	r30, r24
     a96:	f9 0b       	sbc	r31, r25
     a98:	e4 17       	cp	r30, r20
     a9a:	f5 07       	cpc	r31, r21
     a9c:	08 f4       	brcc	.+2      	; 0xaa0 <buffer_append+0x24>
     a9e:	49 c0       	rjmp	.+146    	; 0xb32 <buffer_append+0xb6>
     aa0:	8a 01       	movw	r16, r20
     aa2:	7b 01       	movw	r14, r22
     aa4:	8c 81       	ldd	r24, Y+4	; 0x04
     aa6:	9d 81       	ldd	r25, Y+5	; 0x05
     aa8:	a9 01       	movw	r20, r18
     aaa:	48 1b       	sub	r20, r24
     aac:	59 0b       	sbc	r21, r25
     aae:	04 17       	cp	r16, r20
     ab0:	15 07       	cpc	r17, r21
     ab2:	a8 f4       	brcc	.+42     	; 0xade <buffer_append+0x62>
     ab4:	28 81       	ld	r18, Y
     ab6:	39 81       	ldd	r19, Y+1	; 0x01
     ab8:	a8 01       	movw	r20, r16
     aba:	82 0f       	add	r24, r18
     abc:	93 1f       	adc	r25, r19
     abe:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     ac2:	8c 81       	ldd	r24, Y+4	; 0x04
     ac4:	9d 81       	ldd	r25, Y+5	; 0x05
     ac6:	80 0f       	add	r24, r16
     ac8:	91 1f       	adc	r25, r17
     aca:	9d 83       	std	Y+5, r25	; 0x05
     acc:	8c 83       	std	Y+4, r24	; 0x04
     ace:	2a 81       	ldd	r18, Y+2	; 0x02
     ad0:	3b 81       	ldd	r19, Y+3	; 0x03
     ad2:	82 17       	cp	r24, r18
     ad4:	93 07       	cpc	r25, r19
     ad6:	21 f5       	brne	.+72     	; 0xb20 <buffer_append+0xa4>
     ad8:	1d 82       	std	Y+5, r1	; 0x05
     ada:	1c 82       	std	Y+4, r1	; 0x04
     adc:	21 c0       	rjmp	.+66     	; 0xb20 <buffer_append+0xa4>
     ade:	28 81       	ld	r18, Y
     ae0:	39 81       	ldd	r19, Y+1	; 0x01
     ae2:	82 0f       	add	r24, r18
     ae4:	93 1f       	adc	r25, r19
     ae6:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     aea:	8c 81       	ldd	r24, Y+4	; 0x04
     aec:	9d 81       	ldd	r25, Y+5	; 0x05
     aee:	6a 81       	ldd	r22, Y+2	; 0x02
     af0:	7b 81       	ldd	r23, Y+3	; 0x03
     af2:	ac 01       	movw	r20, r24
     af4:	46 1b       	sub	r20, r22
     af6:	57 0b       	sbc	r21, r23
     af8:	40 0f       	add	r20, r16
     afa:	51 1f       	adc	r21, r17
     afc:	68 1b       	sub	r22, r24
     afe:	79 0b       	sbc	r23, r25
     b00:	6e 0d       	add	r22, r14
     b02:	7f 1d       	adc	r23, r15
     b04:	88 81       	ld	r24, Y
     b06:	99 81       	ldd	r25, Y+1	; 0x01
     b08:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     b0c:	8c 81       	ldd	r24, Y+4	; 0x04
     b0e:	9d 81       	ldd	r25, Y+5	; 0x05
     b10:	2a 81       	ldd	r18, Y+2	; 0x02
     b12:	3b 81       	ldd	r19, Y+3	; 0x03
     b14:	82 1b       	sub	r24, r18
     b16:	93 0b       	sbc	r25, r19
     b18:	80 0f       	add	r24, r16
     b1a:	91 1f       	adc	r25, r17
     b1c:	9d 83       	std	Y+5, r25	; 0x05
     b1e:	8c 83       	std	Y+4, r24	; 0x04
     b20:	48 85       	ldd	r20, Y+8	; 0x08
     b22:	59 85       	ldd	r21, Y+9	; 0x09
     b24:	04 0f       	add	r16, r20
     b26:	15 1f       	adc	r17, r21
     b28:	19 87       	std	Y+9, r17	; 0x09
     b2a:	08 87       	std	Y+8, r16	; 0x08
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	02 c0       	rjmp	.+4      	; 0xb36 <buffer_append+0xba>
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	90 e0       	ldi	r25, 0x00	; 0
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	08 95       	ret

00000b44 <buffer_remove_token>:
     b44:	0f 93       	push	r16
     b46:	1f 93       	push	r17
     b48:	cf 93       	push	r28
     b4a:	df 93       	push	r29
     b4c:	fc 01       	movw	r30, r24
     b4e:	21 15       	cp	r18, r1
     b50:	31 05       	cpc	r19, r1
     b52:	c9 f1       	breq	.+114    	; 0xbc6 <buffer_remove_token+0x82>
     b54:	a6 81       	ldd	r26, Z+6	; 0x06
     b56:	b7 81       	ldd	r27, Z+7	; 0x07
     b58:	84 81       	ldd	r24, Z+4	; 0x04
     b5a:	95 81       	ldd	r25, Z+5	; 0x05
     b5c:	a8 17       	cp	r26, r24
     b5e:	b9 07       	cpc	r27, r25
     b60:	a9 f1       	breq	.+106    	; 0xbcc <buffer_remove_token+0x88>
     b62:	c6 2f       	mov	r28, r22
     b64:	d7 2f       	mov	r29, r23
     b66:	80 e0       	ldi	r24, 0x00	; 0
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	07 c0       	rjmp	.+14     	; 0xb7a <buffer_remove_token+0x36>
     b6c:	a6 81       	ldd	r26, Z+6	; 0x06
     b6e:	b7 81       	ldd	r27, Z+7	; 0x07
     b70:	64 81       	ldd	r22, Z+4	; 0x04
     b72:	75 81       	ldd	r23, Z+5	; 0x05
     b74:	a6 17       	cp	r26, r22
     b76:	b7 07       	cpc	r27, r23
     b78:	59 f1       	breq	.+86     	; 0xbd0 <buffer_remove_token+0x8c>
     b7a:	60 81       	ld	r22, Z
     b7c:	71 81       	ldd	r23, Z+1	; 0x01
     b7e:	a6 0f       	add	r26, r22
     b80:	b7 1f       	adc	r27, r23
     b82:	5c 91       	ld	r21, X
     b84:	8e 01       	movw	r16, r28
     b86:	58 83       	st	Y, r21
     b88:	66 81       	ldd	r22, Z+6	; 0x06
     b8a:	77 81       	ldd	r23, Z+7	; 0x07
     b8c:	6f 5f       	subi	r22, 0xFF	; 255
     b8e:	7f 4f       	sbci	r23, 0xFF	; 255
     b90:	77 83       	std	Z+7, r23	; 0x07
     b92:	66 83       	std	Z+6, r22	; 0x06
     b94:	a0 85       	ldd	r26, Z+8	; 0x08
     b96:	b1 85       	ldd	r27, Z+9	; 0x09
     b98:	11 97       	sbiw	r26, 0x01	; 1
     b9a:	b1 87       	std	Z+9, r27	; 0x09
     b9c:	a0 87       	std	Z+8, r26	; 0x08
     b9e:	a2 81       	ldd	r26, Z+2	; 0x02
     ba0:	b3 81       	ldd	r27, Z+3	; 0x03
     ba2:	6a 17       	cp	r22, r26
     ba4:	7b 07       	cpc	r23, r27
     ba6:	11 f4       	brne	.+4      	; 0xbac <buffer_remove_token+0x68>
     ba8:	17 82       	std	Z+7, r1	; 0x07
     baa:	16 82       	std	Z+6, r1	; 0x06
     bac:	21 96       	adiw	r28, 0x01	; 1
     bae:	d8 01       	movw	r26, r16
     bb0:	5c 91       	ld	r21, X
     bb2:	54 13       	cpse	r21, r20
     bb4:	02 c0       	rjmp	.+4      	; 0xbba <buffer_remove_token+0x76>
     bb6:	01 96       	adiw	r24, 0x01	; 1
     bb8:	0b c0       	rjmp	.+22     	; 0xbd0 <buffer_remove_token+0x8c>
     bba:	01 96       	adiw	r24, 0x01	; 1
     bbc:	28 17       	cp	r18, r24
     bbe:	39 07       	cpc	r19, r25
     bc0:	a9 f6       	brne	.-86     	; 0xb6c <buffer_remove_token+0x28>
     bc2:	c9 01       	movw	r24, r18
     bc4:	05 c0       	rjmp	.+10     	; 0xbd0 <buffer_remove_token+0x8c>
     bc6:	80 e0       	ldi	r24, 0x00	; 0
     bc8:	90 e0       	ldi	r25, 0x00	; 0
     bca:	02 c0       	rjmp	.+4      	; 0xbd0 <buffer_remove_token+0x8c>
     bcc:	80 e0       	ldi	r24, 0x00	; 0
     bce:	90 e0       	ldi	r25, 0x00	; 0
     bd0:	df 91       	pop	r29
     bd2:	cf 91       	pop	r28
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	08 95       	ret

00000bda <buffer_read>:
     bda:	cf 92       	push	r12
     bdc:	df 92       	push	r13
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	7c 01       	movw	r14, r24
     bec:	6b 01       	movw	r12, r22
     bee:	ea 01       	movw	r28, r20
     bf0:	89 01       	movw	r16, r18
     bf2:	67 2b       	or	r22, r23
     bf4:	a9 f1       	breq	.+106    	; 0xc60 <buffer_read+0x86>
     bf6:	fc 01       	movw	r30, r24
     bf8:	42 81       	ldd	r20, Z+2	; 0x02
     bfa:	53 81       	ldd	r21, Z+3	; 0x03
     bfc:	c4 17       	cp	r28, r20
     bfe:	d5 07       	cpc	r29, r21
     c00:	10 f0       	brcs	.+4      	; 0xc06 <buffer_read+0x2c>
     c02:	c4 1b       	sub	r28, r20
     c04:	d5 0b       	sbc	r29, r21
     c06:	4c 1b       	sub	r20, r28
     c08:	5d 0b       	sbc	r21, r29
     c0a:	40 17       	cp	r20, r16
     c0c:	51 07       	cpc	r21, r17
     c0e:	60 f0       	brcs	.+24     	; 0xc28 <buffer_read+0x4e>
     c10:	f7 01       	movw	r30, r14
     c12:	60 81       	ld	r22, Z
     c14:	71 81       	ldd	r23, Z+1	; 0x01
     c16:	6c 0f       	add	r22, r28
     c18:	7d 1f       	adc	r23, r29
     c1a:	a8 01       	movw	r20, r16
     c1c:	c6 01       	movw	r24, r12
     c1e:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     c22:	80 2f       	mov	r24, r16
     c24:	91 2f       	mov	r25, r17
     c26:	1e c0       	rjmp	.+60     	; 0xc64 <buffer_read+0x8a>
     c28:	f7 01       	movw	r30, r14
     c2a:	60 81       	ld	r22, Z
     c2c:	71 81       	ldd	r23, Z+1	; 0x01
     c2e:	6c 0f       	add	r22, r28
     c30:	7d 1f       	adc	r23, r29
     c32:	c6 01       	movw	r24, r12
     c34:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     c38:	f7 01       	movw	r30, r14
     c3a:	22 81       	ldd	r18, Z+2	; 0x02
     c3c:	33 81       	ldd	r19, Z+3	; 0x03
     c3e:	c9 01       	movw	r24, r18
     c40:	8c 1b       	sub	r24, r28
     c42:	9d 0b       	sbc	r25, r29
     c44:	a8 01       	movw	r20, r16
     c46:	42 1b       	sub	r20, r18
     c48:	53 0b       	sbc	r21, r19
     c4a:	4c 0f       	add	r20, r28
     c4c:	5d 1f       	adc	r21, r29
     c4e:	60 81       	ld	r22, Z
     c50:	71 81       	ldd	r23, Z+1	; 0x01
     c52:	8c 0d       	add	r24, r12
     c54:	9d 1d       	adc	r25, r13
     c56:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     c5a:	80 2f       	mov	r24, r16
     c5c:	91 2f       	mov	r25, r17
     c5e:	02 c0       	rjmp	.+4      	; 0xc64 <buffer_read+0x8a>
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	90 e0       	ldi	r25, 0x00	; 0
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	08 95       	ret

00000c76 <buffer_remove>:
     c76:	ef 92       	push	r14
     c78:	ff 92       	push	r15
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	ec 01       	movw	r28, r24
     c84:	7b 01       	movw	r14, r22
     c86:	08 85       	ldd	r16, Y+8	; 0x08
     c88:	19 85       	ldd	r17, Y+9	; 0x09
     c8a:	40 17       	cp	r20, r16
     c8c:	51 07       	cpc	r21, r17
     c8e:	08 f4       	brcc	.+2      	; 0xc92 <buffer_remove+0x1c>
     c90:	8a 01       	movw	r16, r20
     c92:	8e 81       	ldd	r24, Y+6	; 0x06
     c94:	9f 81       	ldd	r25, Y+7	; 0x07
     c96:	4a 81       	ldd	r20, Y+2	; 0x02
     c98:	5b 81       	ldd	r21, Y+3	; 0x03
     c9a:	48 1b       	sub	r20, r24
     c9c:	59 0b       	sbc	r21, r25
     c9e:	40 17       	cp	r20, r16
     ca0:	51 07       	cpc	r21, r17
     ca2:	c8 f0       	brcs	.+50     	; 0xcd6 <buffer_remove+0x60>
     ca4:	e1 14       	cp	r14, r1
     ca6:	f1 04       	cpc	r15, r1
     ca8:	41 f0       	breq	.+16     	; 0xcba <buffer_remove+0x44>
     caa:	68 81       	ld	r22, Y
     cac:	79 81       	ldd	r23, Y+1	; 0x01
     cae:	68 0f       	add	r22, r24
     cb0:	79 1f       	adc	r23, r25
     cb2:	a8 01       	movw	r20, r16
     cb4:	c7 01       	movw	r24, r14
     cb6:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     cba:	8e 81       	ldd	r24, Y+6	; 0x06
     cbc:	9f 81       	ldd	r25, Y+7	; 0x07
     cbe:	80 0f       	add	r24, r16
     cc0:	91 1f       	adc	r25, r17
     cc2:	9f 83       	std	Y+7, r25	; 0x07
     cc4:	8e 83       	std	Y+6, r24	; 0x06
     cc6:	2a 81       	ldd	r18, Y+2	; 0x02
     cc8:	3b 81       	ldd	r19, Y+3	; 0x03
     cca:	82 17       	cp	r24, r18
     ccc:	93 07       	cpc	r25, r19
     cce:	41 f5       	brne	.+80     	; 0xd20 <buffer_remove+0xaa>
     cd0:	1f 82       	std	Y+7, r1	; 0x07
     cd2:	1e 82       	std	Y+6, r1	; 0x06
     cd4:	25 c0       	rjmp	.+74     	; 0xd20 <buffer_remove+0xaa>
     cd6:	e1 14       	cp	r14, r1
     cd8:	f1 04       	cpc	r15, r1
     cda:	c1 f0       	breq	.+48     	; 0xd0c <buffer_remove+0x96>
     cdc:	68 81       	ld	r22, Y
     cde:	79 81       	ldd	r23, Y+1	; 0x01
     ce0:	68 0f       	add	r22, r24
     ce2:	79 1f       	adc	r23, r25
     ce4:	c7 01       	movw	r24, r14
     ce6:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     cea:	4e 81       	ldd	r20, Y+6	; 0x06
     cec:	5f 81       	ldd	r21, Y+7	; 0x07
     cee:	2a 81       	ldd	r18, Y+2	; 0x02
     cf0:	3b 81       	ldd	r19, Y+3	; 0x03
     cf2:	c9 01       	movw	r24, r18
     cf4:	84 1b       	sub	r24, r20
     cf6:	95 0b       	sbc	r25, r21
     cf8:	42 1b       	sub	r20, r18
     cfa:	53 0b       	sbc	r21, r19
     cfc:	40 0f       	add	r20, r16
     cfe:	51 1f       	adc	r21, r17
     d00:	68 81       	ld	r22, Y
     d02:	79 81       	ldd	r23, Y+1	; 0x01
     d04:	8e 0d       	add	r24, r14
     d06:	9f 1d       	adc	r25, r15
     d08:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
     d0c:	8e 81       	ldd	r24, Y+6	; 0x06
     d0e:	9f 81       	ldd	r25, Y+7	; 0x07
     d10:	2a 81       	ldd	r18, Y+2	; 0x02
     d12:	3b 81       	ldd	r19, Y+3	; 0x03
     d14:	82 1b       	sub	r24, r18
     d16:	93 0b       	sbc	r25, r19
     d18:	80 0f       	add	r24, r16
     d1a:	91 1f       	adc	r25, r17
     d1c:	9f 83       	std	Y+7, r25	; 0x07
     d1e:	8e 83       	std	Y+6, r24	; 0x06
     d20:	88 85       	ldd	r24, Y+8	; 0x08
     d22:	99 85       	ldd	r25, Y+9	; 0x09
     d24:	80 1b       	sub	r24, r16
     d26:	91 0b       	sbc	r25, r17
     d28:	99 87       	std	Y+9, r25	; 0x09
     d2a:	88 87       	std	Y+8, r24	; 0x08
     d2c:	c8 01       	movw	r24, r16
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	08 95       	ret

00000d3c <cobs_encode>:
     d3c:	ef 92       	push	r14
     d3e:	ff 92       	push	r15
     d40:	0f 93       	push	r16
     d42:	1f 93       	push	r17
     d44:	cf 93       	push	r28
     d46:	df 93       	push	r29
     d48:	7c 01       	movw	r14, r24
     d4a:	68 0f       	add	r22, r24
     d4c:	79 1f       	adc	r23, r25
     d4e:	fc 01       	movw	r30, r24
     d50:	31 96       	adiw	r30, 0x01	; 1
     d52:	00 97       	sbiw	r24, 0x00	; 0
     d54:	19 f0       	breq	.+6      	; 0xd5c <cobs_encode+0x20>
     d56:	41 15       	cp	r20, r1
     d58:	51 05       	cpc	r21, r1
     d5a:	21 f4       	brne	.+8      	; 0xd64 <cobs_encode+0x28>
     d5c:	60 e0       	ldi	r22, 0x00	; 0
     d5e:	70 e0       	ldi	r23, 0x00	; 0
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	4b c0       	rjmp	.+150    	; 0xdfa <cobs_encode+0xbe>
     d64:	21 15       	cp	r18, r1
     d66:	31 05       	cpc	r19, r1
     d68:	59 f1       	breq	.+86     	; 0xdc0 <cobs_encode+0x84>
     d6a:	e6 17       	cp	r30, r22
     d6c:	f7 07       	cpc	r31, r23
     d6e:	60 f5       	brcc	.+88     	; 0xdc8 <cobs_encode+0x8c>
     d70:	8a 01       	movw	r16, r20
     d72:	02 0f       	add	r16, r18
     d74:	13 1f       	adc	r17, r19
     d76:	da 01       	movw	r26, r20
     d78:	ec 01       	movw	r28, r24
     d7a:	91 e0       	ldi	r25, 0x01	; 1
     d7c:	2f ef       	ldi	r18, 0xFF	; 255
     d7e:	04 c0       	rjmp	.+8      	; 0xd88 <cobs_encode+0x4c>
     d80:	fa 01       	movw	r30, r20
     d82:	e6 17       	cp	r30, r22
     d84:	f7 07       	cpc	r31, r23
     d86:	20 f5       	brcc	.+72     	; 0xdd0 <cobs_encode+0x94>
     d88:	3d 91       	ld	r19, X+
     d8a:	31 11       	cpse	r19, r1
     d8c:	0a c0       	rjmp	.+20     	; 0xda2 <cobs_encode+0x66>
     d8e:	98 83       	st	Y, r25
     d90:	cf 01       	movw	r24, r30
     d92:	01 96       	adiw	r24, 0x01	; 1
     d94:	a0 17       	cp	r26, r16
     d96:	b1 07       	cpc	r27, r17
     d98:	e8 f4       	brcc	.+58     	; 0xdd4 <cobs_encode+0x98>
     d9a:	ef 01       	movw	r28, r30
     d9c:	fc 01       	movw	r30, r24
     d9e:	91 e0       	ldi	r25, 0x01	; 1
     da0:	f0 cf       	rjmp	.-32     	; 0xd82 <cobs_encode+0x46>
     da2:	af 01       	movw	r20, r30
     da4:	4f 5f       	subi	r20, 0xFF	; 255
     da6:	5f 4f       	sbci	r21, 0xFF	; 255
     da8:	30 83       	st	Z, r19
     daa:	9f 5f       	subi	r25, 0xFF	; 255
     dac:	a0 17       	cp	r26, r16
     dae:	b1 07       	cpc	r27, r17
     db0:	b0 f4       	brcc	.+44     	; 0xdde <cobs_encode+0xa2>
     db2:	9f 3f       	cpi	r25, 0xFF	; 255
     db4:	29 f7       	brne	.-54     	; 0xd80 <cobs_encode+0x44>
     db6:	28 83       	st	Y, r18
     db8:	32 96       	adiw	r30, 0x02	; 2
     dba:	ea 01       	movw	r28, r20
     dbc:	91 e0       	ldi	r25, 0x01	; 1
     dbe:	e1 cf       	rjmp	.-62     	; 0xd82 <cobs_encode+0x46>
     dc0:	ec 01       	movw	r28, r24
     dc2:	80 e0       	ldi	r24, 0x00	; 0
     dc4:	91 e0       	ldi	r25, 0x01	; 1
     dc6:	0d c0       	rjmp	.+26     	; 0xde2 <cobs_encode+0xa6>
     dc8:	ec 01       	movw	r28, r24
     dca:	82 e0       	ldi	r24, 0x02	; 2
     dcc:	91 e0       	ldi	r25, 0x01	; 1
     dce:	09 c0       	rjmp	.+18     	; 0xde2 <cobs_encode+0xa6>
     dd0:	82 e0       	ldi	r24, 0x02	; 2
     dd2:	07 c0       	rjmp	.+14     	; 0xde2 <cobs_encode+0xa6>
     dd4:	ef 01       	movw	r28, r30
     dd6:	fc 01       	movw	r30, r24
     dd8:	80 e0       	ldi	r24, 0x00	; 0
     dda:	91 e0       	ldi	r25, 0x01	; 1
     ddc:	02 c0       	rjmp	.+4      	; 0xde2 <cobs_encode+0xa6>
     dde:	fa 01       	movw	r30, r20
     de0:	80 e0       	ldi	r24, 0x00	; 0
     de2:	c6 17       	cp	r28, r22
     de4:	d7 07       	cpc	r29, r23
     de6:	18 f4       	brcc	.+6      	; 0xdee <cobs_encode+0xb2>
     de8:	98 83       	st	Y, r25
     dea:	bf 01       	movw	r22, r30
     dec:	01 c0       	rjmp	.+2      	; 0xdf0 <cobs_encode+0xb4>
     dee:	82 e0       	ldi	r24, 0x02	; 2
     df0:	9b 01       	movw	r18, r22
     df2:	2e 19       	sub	r18, r14
     df4:	3f 09       	sbc	r19, r15
     df6:	62 2f       	mov	r22, r18
     df8:	73 2f       	mov	r23, r19
     dfa:	df 91       	pop	r29
     dfc:	cf 91       	pop	r28
     dfe:	1f 91       	pop	r17
     e00:	0f 91       	pop	r16
     e02:	ff 90       	pop	r15
     e04:	ef 90       	pop	r14
     e06:	08 95       	ret

00000e08 <cobs_decode>:
     e08:	af 92       	push	r10
     e0a:	bf 92       	push	r11
     e0c:	cf 92       	push	r12
     e0e:	df 92       	push	r13
     e10:	ef 92       	push	r14
     e12:	ff 92       	push	r15
     e14:	0f 93       	push	r16
     e16:	1f 93       	push	r17
     e18:	cf 93       	push	r28
     e1a:	df 93       	push	r29
     e1c:	7c 01       	movw	r14, r24
     e1e:	da 01       	movw	r26, r20
     e20:	00 97       	sbiw	r24, 0x00	; 0
     e22:	11 f0       	breq	.+4      	; 0xe28 <cobs_decode+0x20>
     e24:	10 97       	sbiw	r26, 0x00	; 0
     e26:	21 f4       	brne	.+8      	; 0xe30 <cobs_decode+0x28>
     e28:	60 e0       	ldi	r22, 0x00	; 0
     e2a:	70 e0       	ldi	r23, 0x00	; 0
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	5f c0       	rjmp	.+190    	; 0xeee <cobs_decode+0xe6>
     e30:	21 15       	cp	r18, r1
     e32:	31 05       	cpc	r19, r1
     e34:	09 f4       	brne	.+2      	; 0xe38 <cobs_decode+0x30>
     e36:	4b c0       	rjmp	.+150    	; 0xece <cobs_decode+0xc6>
     e38:	6a 01       	movw	r12, r20
     e3a:	c2 0e       	add	r12, r18
     e3c:	d3 1e       	adc	r13, r19
     e3e:	5c 01       	movw	r10, r24
     e40:	a6 0e       	add	r10, r22
     e42:	b7 1e       	adc	r11, r23
     e44:	8c 01       	movw	r16, r24
     e46:	50 e0       	ldi	r21, 0x00	; 0
     e48:	01 c0       	rjmp	.+2      	; 0xe4c <cobs_decode+0x44>
     e4a:	8f 01       	movw	r16, r30
     e4c:	ed 01       	movw	r28, r26
     e4e:	21 96       	adiw	r28, 0x01	; 1
     e50:	7c 91       	ld	r23, X
     e52:	71 11       	cpse	r23, r1
     e54:	03 c0       	rjmp	.+6      	; 0xe5c <cobs_decode+0x54>
     e56:	54 60       	ori	r21, 0x04	; 4
     e58:	f8 01       	movw	r30, r16
     e5a:	3d c0       	rjmp	.+122    	; 0xed6 <cobs_decode+0xce>
     e5c:	71 50       	subi	r23, 0x01	; 1
     e5e:	c6 01       	movw	r24, r12
     e60:	8c 1b       	sub	r24, r28
     e62:	9d 0b       	sbc	r25, r29
     e64:	27 2f       	mov	r18, r23
     e66:	30 e0       	ldi	r19, 0x00	; 0
     e68:	82 17       	cp	r24, r18
     e6a:	93 07       	cpc	r25, r19
     e6c:	10 f4       	brcc	.+4      	; 0xe72 <cobs_decode+0x6a>
     e6e:	78 2f       	mov	r23, r24
     e70:	58 60       	ori	r21, 0x08	; 8
     e72:	c5 01       	movw	r24, r10
     e74:	80 1b       	sub	r24, r16
     e76:	91 0b       	sbc	r25, r17
     e78:	27 2f       	mov	r18, r23
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	82 17       	cp	r24, r18
     e7e:	93 07       	cpc	r25, r19
     e80:	10 f4       	brcc	.+4      	; 0xe86 <cobs_decode+0x7e>
     e82:	78 2f       	mov	r23, r24
     e84:	52 60       	ori	r21, 0x02	; 2
     e86:	77 23       	and	r23, r23
     e88:	61 f1       	breq	.+88     	; 0xee2 <cobs_decode+0xda>
     e8a:	de 01       	movw	r26, r28
     e8c:	f8 01       	movw	r30, r16
     e8e:	97 2f       	mov	r25, r23
     e90:	3d 91       	ld	r19, X+
     e92:	31 11       	cpse	r19, r1
     e94:	01 c0       	rjmp	.+2      	; 0xe98 <cobs_decode+0x90>
     e96:	54 60       	ori	r21, 0x04	; 4
     e98:	31 93       	st	Z+, r19
     e9a:	91 50       	subi	r25, 0x01	; 1
     e9c:	c9 f7       	brne	.-14     	; 0xe90 <cobs_decode+0x88>
     e9e:	ef ef       	ldi	r30, 0xFF	; 255
     ea0:	e7 0f       	add	r30, r23
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	31 96       	adiw	r30, 0x01	; 1
     ea6:	de 01       	movw	r26, r28
     ea8:	ae 0f       	add	r26, r30
     eaa:	bf 1f       	adc	r27, r31
     eac:	e0 0f       	add	r30, r16
     eae:	f1 1f       	adc	r31, r17
     eb0:	ac 15       	cp	r26, r12
     eb2:	bd 05       	cpc	r27, r13
     eb4:	80 f4       	brcc	.+32     	; 0xed6 <cobs_decode+0xce>
     eb6:	7e 3f       	cpi	r23, 0xFE	; 254
     eb8:	41 f2       	breq	.-112    	; 0xe4a <cobs_decode+0x42>
     eba:	ea 15       	cp	r30, r10
     ebc:	fb 05       	cpc	r31, r11
     ebe:	10 f0       	brcs	.+4      	; 0xec4 <cobs_decode+0xbc>
     ec0:	52 60       	ori	r21, 0x02	; 2
     ec2:	09 c0       	rjmp	.+18     	; 0xed6 <cobs_decode+0xce>
     ec4:	8f 01       	movw	r16, r30
     ec6:	0f 5f       	subi	r16, 0xFF	; 255
     ec8:	1f 4f       	sbci	r17, 0xFF	; 255
     eca:	10 82       	st	Z, r1
     ecc:	bf cf       	rjmp	.-130    	; 0xe4c <cobs_decode+0x44>
     ece:	fc 01       	movw	r30, r24
     ed0:	50 e0       	ldi	r21, 0x00	; 0
     ed2:	01 c0       	rjmp	.+2      	; 0xed6 <cobs_decode+0xce>
     ed4:	f8 01       	movw	r30, r16
     ed6:	ee 19       	sub	r30, r14
     ed8:	ff 09       	sbc	r31, r15
     eda:	6e 2f       	mov	r22, r30
     edc:	7f 2f       	mov	r23, r31
     ede:	85 2f       	mov	r24, r21
     ee0:	06 c0       	rjmp	.+12     	; 0xeee <cobs_decode+0xe6>
     ee2:	cc 15       	cp	r28, r12
     ee4:	dd 05       	cpc	r29, r13
     ee6:	b0 f7       	brcc	.-20     	; 0xed4 <cobs_decode+0xcc>
     ee8:	f8 01       	movw	r30, r16
     eea:	de 01       	movw	r26, r28
     eec:	e6 cf       	rjmp	.-52     	; 0xeba <cobs_decode+0xb2>
     eee:	df 91       	pop	r29
     ef0:	cf 91       	pop	r28
     ef2:	1f 91       	pop	r17
     ef4:	0f 91       	pop	r16
     ef6:	ff 90       	pop	r15
     ef8:	ef 90       	pop	r14
     efa:	df 90       	pop	r13
     efc:	cf 90       	pop	r12
     efe:	bf 90       	pop	r11
     f00:	af 90       	pop	r10
     f02:	08 95       	ret

00000f04 <crc_ibutton_update>:
     f04:	86 27       	eor	r24, r22
     f06:	98 e0       	ldi	r25, 0x08	; 8
     f08:	2c e8       	ldi	r18, 0x8C	; 140
     f0a:	80 ff       	sbrs	r24, 0
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <crc_ibutton_update+0x10>
     f0e:	86 95       	lsr	r24
     f10:	82 27       	eor	r24, r18
     f12:	01 c0       	rjmp	.+2      	; 0xf16 <crc_ibutton_update+0x12>
     f14:	86 95       	lsr	r24
     f16:	91 50       	subi	r25, 0x01	; 1
     f18:	c1 f7       	brne	.-16     	; 0xf0a <crc_ibutton_update+0x6>
     f1a:	08 95       	ret

00000f1c <calculate_crc>:
     f1c:	0f 93       	push	r16
     f1e:	1f 93       	push	r17
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
     f24:	66 23       	and	r22, r22
     f26:	59 f0       	breq	.+22     	; 0xf3e <calculate_crc+0x22>
     f28:	8c 01       	movw	r16, r24
     f2a:	ec 01       	movw	r28, r24
     f2c:	06 0f       	add	r16, r22
     f2e:	11 1d       	adc	r17, r1
     f30:	80 e0       	ldi	r24, 0x00	; 0
     f32:	69 91       	ld	r22, Y+
     f34:	e7 df       	rcall	.-50     	; 0xf04 <crc_ibutton_update>
     f36:	c0 17       	cp	r28, r16
     f38:	d1 07       	cpc	r29, r17
     f3a:	d9 f7       	brne	.-10     	; 0xf32 <calculate_crc+0x16>
     f3c:	01 c0       	rjmp	.+2      	; 0xf40 <calculate_crc+0x24>
     f3e:	80 e0       	ldi	r24, 0x00	; 0
     f40:	df 91       	pop	r29
     f42:	cf 91       	pop	r28
     f44:	1f 91       	pop	r17
     f46:	0f 91       	pop	r16
     f48:	08 95       	ret

00000f4a <vDistSens_init>:
*/

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
     f4a:	80 b3       	in	r24, 0x10	; 16
     f4c:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     f4e:	ec e7       	ldi	r30, 0x7C	; 124
     f50:	f0 e0       	ldi	r31, 0x00	; 0
     f52:	80 81       	ld	r24, Z
     f54:	80 6c       	ori	r24, 0xC0	; 192
     f56:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
     f58:	ea e7       	ldi	r30, 0x7A	; 122
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	80 81       	ld	r24, Z
     f5e:	80 68       	ori	r24, 0x80	; 128
     f60:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
     f62:	80 81       	ld	r24, Z
     f64:	84 60       	ori	r24, 0x04	; 4
     f66:	80 83       	st	Z, r24
     f68:	08 95       	ret

00000f6a <ui8DistSens_readCM>:
uint8_t ui8DistSens_readCM(uint8_t sensorDirection){
    
    uint8_t ui8_analogValue;
    
    /* Choose channel */
    ADMUX = sensorDirection;
     f6a:	ec e7       	ldi	r30, 0x7C	; 124
     f6c:	f0 e0       	ldi	r31, 0x00	; 0
     f6e:	80 83       	st	Z, r24
    
    /* Enable internal 2,54V AREF */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     f70:	90 81       	ld	r25, Z
     f72:	90 6c       	ori	r25, 0xC0	; 192
     f74:	90 83       	st	Z, r25
    
    /* Start conversion */
    ADCSRA |= (1<<ADSC);
     f76:	ea e7       	ldi	r30, 0x7A	; 122
     f78:	f0 e0       	ldi	r31, 0x00	; 0
     f7a:	90 81       	ld	r25, Z
     f7c:	90 64       	ori	r25, 0x40	; 64
     f7e:	90 83       	st	Z, r25
    loop_until_bit_is_clear(ADCSRA, ADSC); // Macro from <avr/io.h>, wait until bit bit in IO register is set.
     f80:	90 81       	ld	r25, Z
     f82:	96 fd       	sbrc	r25, 6
     f84:	fd cf       	rjmp	.-6      	; 0xf80 <ui8DistSens_readCM+0x16>

    /* Return the 8 most significant bits from the 10 bit register */
    ui8_analogValue = (ADCL >> 2) | (ADCH << 6);
     f86:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     f8a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    // Returns corresponding distance in CM
    return ui8_analogToCM[sensorDirection][ui8_analogValue];
     f8e:	e8 2f       	mov	r30, r24
     f90:	f0 e0       	ldi	r31, 0x00	; 0
     f92:	26 95       	lsr	r18
     f94:	26 95       	lsr	r18
     f96:	30 e4       	ldi	r19, 0x40	; 64
     f98:	93 9f       	mul	r25, r19
     f9a:	c0 01       	movw	r24, r0
     f9c:	11 24       	eor	r1, r1
     f9e:	82 2b       	or	r24, r18
     fa0:	fe 2f       	mov	r31, r30
     fa2:	ee 27       	eor	r30, r30
     fa4:	e0 50       	subi	r30, 0x00	; 0
     fa6:	fe 4f       	sbci	r31, 0xFE	; 254
     fa8:	e8 0f       	add	r30, r24
     faa:	f1 1d       	adc	r31, r1
}
     fac:	80 81       	ld	r24, Z
     fae:	08 95       	ret

00000fb0 <vFunc_Inf2pi>:
     fb0:	cf 92       	push	r12
     fb2:	df 92       	push	r13
     fb4:	ef 92       	push	r14
     fb6:	ff 92       	push	r15
     fb8:	cf 93       	push	r28
     fba:	df 93       	push	r29
     fbc:	ec 01       	movw	r28, r24
     fbe:	c8 80       	ld	r12, Y
     fc0:	d9 80       	ldd	r13, Y+1	; 0x01
     fc2:	ea 80       	ldd	r14, Y+2	; 0x02
     fc4:	fb 80       	ldd	r15, Y+3	; 0x03
     fc6:	2b ed       	ldi	r18, 0xDB	; 219
     fc8:	3f e0       	ldi	r19, 0x0F	; 15
     fca:	49 e4       	ldi	r20, 0x49	; 73
     fcc:	50 e4       	ldi	r21, 0x40	; 64
     fce:	c7 01       	movw	r24, r14
     fd0:	b6 01       	movw	r22, r12
     fd2:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
     fd6:	18 16       	cp	r1, r24
     fd8:	6c f4       	brge	.+26     	; 0xff4 <vFunc_Inf2pi+0x44>
     fda:	2b ed       	ldi	r18, 0xDB	; 219
     fdc:	3f e0       	ldi	r19, 0x0F	; 15
     fde:	49 ec       	ldi	r20, 0xC9	; 201
     fe0:	50 e4       	ldi	r21, 0x40	; 64
     fe2:	c7 01       	movw	r24, r14
     fe4:	b6 01       	movw	r22, r12
     fe6:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
     fea:	68 83       	st	Y, r22
     fec:	79 83       	std	Y+1, r23	; 0x01
     fee:	8a 83       	std	Y+2, r24	; 0x02
     ff0:	9b 83       	std	Y+3, r25	; 0x03
     ff2:	16 c0       	rjmp	.+44     	; 0x1020 <vFunc_Inf2pi+0x70>
     ff4:	2b ed       	ldi	r18, 0xDB	; 219
     ff6:	3f e0       	ldi	r19, 0x0F	; 15
     ff8:	49 e4       	ldi	r20, 0x49	; 73
     ffa:	50 ec       	ldi	r21, 0xC0	; 192
     ffc:	c7 01       	movw	r24, r14
     ffe:	b6 01       	movw	r22, r12
    1000:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    1004:	88 23       	and	r24, r24
    1006:	64 f4       	brge	.+24     	; 0x1020 <vFunc_Inf2pi+0x70>
    1008:	2b ed       	ldi	r18, 0xDB	; 219
    100a:	3f e0       	ldi	r19, 0x0F	; 15
    100c:	49 ec       	ldi	r20, 0xC9	; 201
    100e:	50 e4       	ldi	r21, 0x40	; 64
    1010:	c7 01       	movw	r24, r14
    1012:	b6 01       	movw	r22, r12
    1014:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    1018:	68 83       	st	Y, r22
    101a:	79 83       	std	Y+1, r23	; 0x01
    101c:	8a 83       	std	Y+2, r24	; 0x02
    101e:	9b 83       	std	Y+3, r25	; 0x03
    1020:	88 81       	ld	r24, Y
    1022:	99 81       	ldd	r25, Y+1	; 0x01
    1024:	aa 81       	ldd	r26, Y+2	; 0x02
    1026:	bb 81       	ldd	r27, Y+3	; 0x03
    1028:	bc 01       	movw	r22, r24
    102a:	cd 01       	movw	r24, r26
    102c:	9f 77       	andi	r25, 0x7F	; 127
    102e:	2b ed       	ldi	r18, 0xDB	; 219
    1030:	3f e0       	ldi	r19, 0x0F	; 15
    1032:	49 e4       	ldi	r20, 0x49	; 73
    1034:	50 e4       	ldi	r21, 0x40	; 64
    1036:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    103a:	18 16       	cp	r1, r24
    103c:	0c f4       	brge	.+2      	; 0x1040 <vFunc_Inf2pi+0x90>
    103e:	bf cf       	rjmp	.-130    	; 0xfbe <vFunc_Inf2pi+0xe>
    1040:	df 91       	pop	r29
    1042:	cf 91       	pop	r28
    1044:	ff 90       	pop	r15
    1046:	ef 90       	pop	r14
    1048:	df 90       	pop	r13
    104a:	cf 90       	pop	r12
    104c:	08 95       	ret

0000104e <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    104e:	ef 92       	push	r14
    1050:	ff 92       	push	r15
    1052:	0f 93       	push	r16
    1054:	1f 93       	push	r17
    1056:	cf 93       	push	r28
    1058:	df 93       	push	r29
    105a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    105c:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    1060:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <pxEnd>
    1064:	90 91 cc 07 	lds	r25, 0x07CC	; 0x8007cc <pxEnd+0x1>
    1068:	89 2b       	or	r24, r25
    106a:	41 f5       	brne	.+80     	; 0x10bc <pvPortMalloc+0x6e>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    106c:	ed ec       	ldi	r30, 0xCD	; 205
    106e:	f7 e0       	ldi	r31, 0x07	; 7
    1070:	a1 ed       	ldi	r26, 0xD1	; 209
    1072:	b7 e0       	ldi	r27, 0x07	; 7
    1074:	b1 83       	std	Z+1, r27	; 0x01
    1076:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    1078:	13 82       	std	Z+3, r1	; 0x03
    107a:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    107c:	ed ec       	ldi	r30, 0xCD	; 205
    107e:	f9 e1       	ldi	r31, 0x19	; 25
    1080:	f0 93 cc 07 	sts	0x07CC, r31	; 0x8007cc <pxEnd+0x1>
    1084:	e0 93 cb 07 	sts	0x07CB, r30	; 0x8007cb <pxEnd>
	pxEnd->xBlockSize = 0;
    1088:	13 82       	std	Z+3, r1	; 0x03
    108a:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    108c:	11 82       	std	Z+1, r1	; 0x01
    108e:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    1090:	8c ef       	ldi	r24, 0xFC	; 252
    1092:	91 e1       	ldi	r25, 0x11	; 17
    1094:	13 96       	adiw	r26, 0x03	; 3
    1096:	9c 93       	st	X, r25
    1098:	8e 93       	st	-X, r24
    109a:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    109c:	ed 93       	st	X+, r30
    109e:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    10a0:	90 93 c8 07 	sts	0x07C8, r25	; 0x8007c8 <xMinimumEverFreeBytesRemaining+0x1>
    10a4:	80 93 c7 07 	sts	0x07C7, r24	; 0x8007c7 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    10a8:	90 93 ca 07 	sts	0x07CA, r25	; 0x8007ca <xFreeBytesRemaining+0x1>
    10ac:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    10b0:	80 e0       	ldi	r24, 0x00	; 0
    10b2:	90 e8       	ldi	r25, 0x80	; 128
    10b4:	90 93 c6 07 	sts	0x07C6, r25	; 0x8007c6 <xBlockAllocatedBit+0x1>
    10b8:	80 93 c5 07 	sts	0x07C5, r24	; 0x8007c5 <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    10bc:	80 91 c5 07 	lds	r24, 0x07C5	; 0x8007c5 <xBlockAllocatedBit>
    10c0:	90 91 c6 07 	lds	r25, 0x07C6	; 0x8007c6 <xBlockAllocatedBit+0x1>
    10c4:	8c 23       	and	r24, r28
    10c6:	9d 23       	and	r25, r29
    10c8:	89 2b       	or	r24, r25
    10ca:	09 f0       	breq	.+2      	; 0x10ce <pvPortMalloc+0x80>
    10cc:	b2 c0       	rjmp	.+356    	; 0x1232 <pvPortMalloc+0x1e4>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    10ce:	20 97       	sbiw	r28, 0x00	; 0
    10d0:	09 f4       	brne	.+2      	; 0x10d4 <pvPortMalloc+0x86>
    10d2:	b2 c0       	rjmp	.+356    	; 0x1238 <pvPortMalloc+0x1ea>
			{
				xWantedSize += xHeapStructSize;
    10d4:	ae 01       	movw	r20, r28
    10d6:	4c 5f       	subi	r20, 0xFC	; 252
    10d8:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    10da:	09 f4       	brne	.+2      	; 0x10de <pvPortMalloc+0x90>
    10dc:	b0 c0       	rjmp	.+352    	; 0x123e <pvPortMalloc+0x1f0>
    10de:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <xFreeBytesRemaining>
    10e2:	90 91 ca 07 	lds	r25, 0x07CA	; 0x8007ca <xFreeBytesRemaining+0x1>
    10e6:	84 17       	cp	r24, r20
    10e8:	95 07       	cpc	r25, r21
    10ea:	08 f4       	brcc	.+2      	; 0x10ee <pvPortMalloc+0xa0>
    10ec:	ab c0       	rjmp	.+342    	; 0x1244 <pvPortMalloc+0x1f6>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    10ee:	e0 91 cd 07 	lds	r30, 0x07CD	; 0x8007cd <xStart>
    10f2:	f0 91 ce 07 	lds	r31, 0x07CE	; 0x8007ce <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    10f6:	ad ec       	ldi	r26, 0xCD	; 205
    10f8:	b7 e0       	ldi	r27, 0x07	; 7
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    10fa:	02 c0       	rjmp	.+4      	; 0x1100 <pvPortMalloc+0xb2>
    10fc:	df 01       	movw	r26, r30
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    10fe:	f9 01       	movw	r30, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1100:	22 81       	ldd	r18, Z+2	; 0x02
    1102:	33 81       	ldd	r19, Z+3	; 0x03
    1104:	24 17       	cp	r18, r20
    1106:	35 07       	cpc	r19, r21
    1108:	28 f4       	brcc	.+10     	; 0x1114 <pvPortMalloc+0xc6>
    110a:	20 81       	ld	r18, Z
    110c:	31 81       	ldd	r19, Z+1	; 0x01
    110e:	21 15       	cp	r18, r1
    1110:	31 05       	cpc	r19, r1
    1112:	a1 f7       	brne	.-24     	; 0x10fc <pvPortMalloc+0xae>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    1114:	60 91 cb 07 	lds	r22, 0x07CB	; 0x8007cb <pxEnd>
    1118:	70 91 cc 07 	lds	r23, 0x07CC	; 0x8007cc <pxEnd+0x1>
    111c:	e6 17       	cp	r30, r22
    111e:	f7 07       	cpc	r31, r23
    1120:	09 f4       	brne	.+2      	; 0x1124 <pvPortMalloc+0xd6>
    1122:	93 c0       	rjmp	.+294    	; 0x124a <pvPortMalloc+0x1fc>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    1124:	cd 91       	ld	r28, X+
    1126:	dc 91       	ld	r29, X
    1128:	11 97       	sbiw	r26, 0x01	; 1
    112a:	7e 01       	movw	r14, r28
    112c:	84 e0       	ldi	r24, 0x04	; 4
    112e:	e8 0e       	add	r14, r24
    1130:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1132:	80 81       	ld	r24, Z
    1134:	91 81       	ldd	r25, Z+1	; 0x01
    1136:	8d 93       	st	X+, r24
    1138:	9c 93       	st	X, r25

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    113a:	82 81       	ldd	r24, Z+2	; 0x02
    113c:	93 81       	ldd	r25, Z+3	; 0x03
    113e:	84 1b       	sub	r24, r20
    1140:	95 0b       	sbc	r25, r21
    1142:	89 30       	cpi	r24, 0x09	; 9
    1144:	91 05       	cpc	r25, r1
    1146:	08 f4       	brcc	.+2      	; 0x114a <pvPortMalloc+0xfc>
    1148:	52 c0       	rjmp	.+164    	; 0x11ee <pvPortMalloc+0x1a0>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    114a:	9f 01       	movw	r18, r30
    114c:	24 0f       	add	r18, r20
    114e:	35 1f       	adc	r19, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1150:	d9 01       	movw	r26, r18
    1152:	13 96       	adiw	r26, 0x03	; 3
    1154:	9c 93       	st	X, r25
    1156:	8e 93       	st	-X, r24
    1158:	12 97       	sbiw	r26, 0x02	; 2
						pxBlock->xBlockSize = xWantedSize;
    115a:	53 83       	std	Z+3, r21	; 0x03
    115c:	42 83       	std	Z+2, r20	; 0x02
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    115e:	ad ec       	ldi	r26, 0xCD	; 205
    1160:	b7 e0       	ldi	r27, 0x07	; 7
    1162:	01 c0       	rjmp	.+2      	; 0x1166 <pvPortMalloc+0x118>
    1164:	dc 01       	movw	r26, r24
    1166:	8d 91       	ld	r24, X+
    1168:	9c 91       	ld	r25, X
    116a:	11 97       	sbiw	r26, 0x01	; 1
    116c:	82 17       	cp	r24, r18
    116e:	93 07       	cpc	r25, r19
    1170:	c8 f3       	brcs	.-14     	; 0x1164 <pvPortMalloc+0x116>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1172:	12 96       	adiw	r26, 0x02	; 2
    1174:	4d 91       	ld	r20, X+
    1176:	5c 91       	ld	r21, X
    1178:	13 97       	sbiw	r26, 0x03	; 3
    117a:	8d 01       	movw	r16, r26
    117c:	04 0f       	add	r16, r20
    117e:	15 1f       	adc	r17, r21
    1180:	20 17       	cp	r18, r16
    1182:	31 07       	cpc	r19, r17
    1184:	51 f4       	brne	.+20     	; 0x119a <pvPortMalloc+0x14c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    1186:	e9 01       	movw	r28, r18
    1188:	2a 81       	ldd	r18, Y+2	; 0x02
    118a:	3b 81       	ldd	r19, Y+3	; 0x03
    118c:	42 0f       	add	r20, r18
    118e:	53 1f       	adc	r21, r19
    1190:	13 96       	adiw	r26, 0x03	; 3
    1192:	5c 93       	st	X, r21
    1194:	4e 93       	st	-X, r20
    1196:	12 97       	sbiw	r26, 0x02	; 2
    1198:	9d 01       	movw	r18, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    119a:	e9 01       	movw	r28, r18
    119c:	4a 81       	ldd	r20, Y+2	; 0x02
    119e:	5b 81       	ldd	r21, Y+3	; 0x03
    11a0:	89 01       	movw	r16, r18
    11a2:	04 0f       	add	r16, r20
    11a4:	15 1f       	adc	r17, r21
    11a6:	80 17       	cp	r24, r16
    11a8:	91 07       	cpc	r25, r17
    11aa:	c9 f4       	brne	.+50     	; 0x11de <pvPortMalloc+0x190>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    11ac:	60 17       	cp	r22, r16
    11ae:	71 07       	cpc	r23, r17
    11b0:	91 f0       	breq	.+36     	; 0x11d6 <pvPortMalloc+0x188>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    11b2:	e8 01       	movw	r28, r16
    11b4:	8a 81       	ldd	r24, Y+2	; 0x02
    11b6:	9b 81       	ldd	r25, Y+3	; 0x03
    11b8:	48 0f       	add	r20, r24
    11ba:	59 1f       	adc	r21, r25
    11bc:	e9 01       	movw	r28, r18
    11be:	5b 83       	std	Y+3, r21	; 0x03
    11c0:	4a 83       	std	Y+2, r20	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    11c2:	8d 91       	ld	r24, X+
    11c4:	9c 91       	ld	r25, X
    11c6:	11 97       	sbiw	r26, 0x01	; 1
    11c8:	ec 01       	movw	r28, r24
    11ca:	88 81       	ld	r24, Y
    11cc:	99 81       	ldd	r25, Y+1	; 0x01
    11ce:	e9 01       	movw	r28, r18
    11d0:	99 83       	std	Y+1, r25	; 0x01
    11d2:	88 83       	st	Y, r24
    11d4:	07 c0       	rjmp	.+14     	; 0x11e4 <pvPortMalloc+0x196>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    11d6:	e9 01       	movw	r28, r18
    11d8:	79 83       	std	Y+1, r23	; 0x01
    11da:	68 83       	st	Y, r22
    11dc:	03 c0       	rjmp	.+6      	; 0x11e4 <pvPortMalloc+0x196>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    11de:	e9 01       	movw	r28, r18
    11e0:	99 83       	std	Y+1, r25	; 0x01
    11e2:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    11e4:	a2 17       	cp	r26, r18
    11e6:	b3 07       	cpc	r27, r19
    11e8:	11 f0       	breq	.+4      	; 0x11ee <pvPortMalloc+0x1a0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    11ea:	2d 93       	st	X+, r18
    11ec:	3c 93       	st	X, r19
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    11ee:	22 81       	ldd	r18, Z+2	; 0x02
    11f0:	33 81       	ldd	r19, Z+3	; 0x03
    11f2:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <xFreeBytesRemaining>
    11f6:	90 91 ca 07 	lds	r25, 0x07CA	; 0x8007ca <xFreeBytesRemaining+0x1>
    11fa:	82 1b       	sub	r24, r18
    11fc:	93 0b       	sbc	r25, r19
    11fe:	90 93 ca 07 	sts	0x07CA, r25	; 0x8007ca <xFreeBytesRemaining+0x1>
    1202:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    1206:	40 91 c7 07 	lds	r20, 0x07C7	; 0x8007c7 <xMinimumEverFreeBytesRemaining>
    120a:	50 91 c8 07 	lds	r21, 0x07C8	; 0x8007c8 <xMinimumEverFreeBytesRemaining+0x1>
    120e:	84 17       	cp	r24, r20
    1210:	95 07       	cpc	r25, r21
    1212:	20 f4       	brcc	.+8      	; 0x121c <pvPortMalloc+0x1ce>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1214:	90 93 c8 07 	sts	0x07C8, r25	; 0x8007c8 <xMinimumEverFreeBytesRemaining+0x1>
    1218:	80 93 c7 07 	sts	0x07C7, r24	; 0x8007c7 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    121c:	80 91 c5 07 	lds	r24, 0x07C5	; 0x8007c5 <xBlockAllocatedBit>
    1220:	90 91 c6 07 	lds	r25, 0x07C6	; 0x8007c6 <xBlockAllocatedBit+0x1>
    1224:	28 2b       	or	r18, r24
    1226:	39 2b       	or	r19, r25
    1228:	33 83       	std	Z+3, r19	; 0x03
    122a:	22 83       	std	Z+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    122c:	11 82       	std	Z+1, r1	; 0x01
    122e:	10 82       	st	Z, r1
    1230:	0e c0       	rjmp	.+28     	; 0x124e <pvPortMalloc+0x200>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    1232:	e1 2c       	mov	r14, r1
    1234:	f1 2c       	mov	r15, r1
    1236:	0b c0       	rjmp	.+22     	; 0x124e <pvPortMalloc+0x200>
    1238:	e1 2c       	mov	r14, r1
    123a:	f1 2c       	mov	r15, r1
    123c:	08 c0       	rjmp	.+16     	; 0x124e <pvPortMalloc+0x200>
    123e:	e1 2c       	mov	r14, r1
    1240:	f1 2c       	mov	r15, r1
    1242:	05 c0       	rjmp	.+10     	; 0x124e <pvPortMalloc+0x200>
    1244:	e1 2c       	mov	r14, r1
    1246:	f1 2c       	mov	r15, r1
    1248:	02 c0       	rjmp	.+4      	; 0x124e <pvPortMalloc+0x200>
    124a:	e1 2c       	mov	r14, r1
    124c:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    124e:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    1252:	c7 01       	movw	r24, r14
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	1f 91       	pop	r17
    125a:	0f 91       	pop	r16
    125c:	ff 90       	pop	r15
    125e:	ef 90       	pop	r14
    1260:	08 95       	ret

00001262 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    1266:	00 97       	sbiw	r24, 0x00	; 0
    1268:	09 f4       	brne	.+2      	; 0x126c <vPortFree+0xa>
    126a:	68 c0       	rjmp	.+208    	; 0x133c <vPortFree+0xda>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    126c:	fc 01       	movw	r30, r24
    126e:	34 97       	sbiw	r30, 0x04	; 4
    1270:	22 81       	ldd	r18, Z+2	; 0x02
    1272:	33 81       	ldd	r19, Z+3	; 0x03
    1274:	40 91 c5 07 	lds	r20, 0x07C5	; 0x8007c5 <xBlockAllocatedBit>
    1278:	50 91 c6 07 	lds	r21, 0x07C6	; 0x8007c6 <xBlockAllocatedBit+0x1>
    127c:	b9 01       	movw	r22, r18
    127e:	64 23       	and	r22, r20
    1280:	75 23       	and	r23, r21
    1282:	67 2b       	or	r22, r23
    1284:	09 f4       	brne	.+2      	; 0x1288 <vPortFree+0x26>
    1286:	5a c0       	rjmp	.+180    	; 0x133c <vPortFree+0xda>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    1288:	60 81       	ld	r22, Z
    128a:	71 81       	ldd	r23, Z+1	; 0x01
    128c:	67 2b       	or	r22, r23
    128e:	09 f0       	breq	.+2      	; 0x1292 <vPortFree+0x30>
    1290:	55 c0       	rjmp	.+170    	; 0x133c <vPortFree+0xda>

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    1292:	ef 01       	movw	r28, r30
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    1294:	40 95       	com	r20
    1296:	50 95       	com	r21
    1298:	24 23       	and	r18, r20
    129a:	35 23       	and	r19, r21
    129c:	33 83       	std	Z+3, r19	; 0x03
    129e:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    12a0:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    12a4:	4a 81       	ldd	r20, Y+2	; 0x02
    12a6:	5b 81       	ldd	r21, Y+3	; 0x03
    12a8:	80 91 c9 07 	lds	r24, 0x07C9	; 0x8007c9 <xFreeBytesRemaining>
    12ac:	90 91 ca 07 	lds	r25, 0x07CA	; 0x8007ca <xFreeBytesRemaining+0x1>
    12b0:	84 0f       	add	r24, r20
    12b2:	95 1f       	adc	r25, r21
    12b4:	90 93 ca 07 	sts	0x07CA, r25	; 0x8007ca <xFreeBytesRemaining+0x1>
    12b8:	80 93 c9 07 	sts	0x07C9, r24	; 0x8007c9 <xFreeBytesRemaining>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    12bc:	ed ec       	ldi	r30, 0xCD	; 205
    12be:	f7 e0       	ldi	r31, 0x07	; 7
    12c0:	01 c0       	rjmp	.+2      	; 0x12c4 <vPortFree+0x62>
    12c2:	fc 01       	movw	r30, r24
    12c4:	80 81       	ld	r24, Z
    12c6:	91 81       	ldd	r25, Z+1	; 0x01
    12c8:	8c 17       	cp	r24, r28
    12ca:	9d 07       	cpc	r25, r29
    12cc:	d0 f3       	brcs	.-12     	; 0x12c2 <vPortFree+0x60>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    12ce:	22 81       	ldd	r18, Z+2	; 0x02
    12d0:	33 81       	ldd	r19, Z+3	; 0x03
    12d2:	bf 01       	movw	r22, r30
    12d4:	62 0f       	add	r22, r18
    12d6:	73 1f       	adc	r23, r19
    12d8:	c6 17       	cp	r28, r22
    12da:	d7 07       	cpc	r29, r23
    12dc:	29 f4       	brne	.+10     	; 0x12e8 <vPortFree+0x86>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    12de:	24 0f       	add	r18, r20
    12e0:	35 1f       	adc	r19, r21
    12e2:	33 83       	std	Z+3, r19	; 0x03
    12e4:	22 83       	std	Z+2, r18	; 0x02
    12e6:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    12e8:	2a 81       	ldd	r18, Y+2	; 0x02
    12ea:	3b 81       	ldd	r19, Y+3	; 0x03
    12ec:	de 01       	movw	r26, r28
    12ee:	a2 0f       	add	r26, r18
    12f0:	b3 1f       	adc	r27, r19
    12f2:	8a 17       	cp	r24, r26
    12f4:	9b 07       	cpc	r25, r27
    12f6:	c9 f4       	brne	.+50     	; 0x132a <vPortFree+0xc8>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    12f8:	80 91 cb 07 	lds	r24, 0x07CB	; 0x8007cb <pxEnd>
    12fc:	90 91 cc 07 	lds	r25, 0x07CC	; 0x8007cc <pxEnd+0x1>
    1300:	a8 17       	cp	r26, r24
    1302:	b9 07       	cpc	r27, r25
    1304:	79 f0       	breq	.+30     	; 0x1324 <vPortFree+0xc2>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    1306:	12 96       	adiw	r26, 0x02	; 2
    1308:	8d 91       	ld	r24, X+
    130a:	9c 91       	ld	r25, X
    130c:	13 97       	sbiw	r26, 0x03	; 3
    130e:	28 0f       	add	r18, r24
    1310:	39 1f       	adc	r19, r25
    1312:	3b 83       	std	Y+3, r19	; 0x03
    1314:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1316:	a0 81       	ld	r26, Z
    1318:	b1 81       	ldd	r27, Z+1	; 0x01
    131a:	8d 91       	ld	r24, X+
    131c:	9c 91       	ld	r25, X
    131e:	99 83       	std	Y+1, r25	; 0x01
    1320:	88 83       	st	Y, r24
    1322:	05 c0       	rjmp	.+10     	; 0x132e <vPortFree+0xcc>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    1324:	b9 83       	std	Y+1, r27	; 0x01
    1326:	a8 83       	st	Y, r26
    1328:	02 c0       	rjmp	.+4      	; 0x132e <vPortFree+0xcc>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    132a:	99 83       	std	Y+1, r25	; 0x01
    132c:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    132e:	ec 17       	cp	r30, r28
    1330:	fd 07       	cpc	r31, r29
    1332:	11 f0       	breq	.+4      	; 0x1338 <vPortFree+0xd6>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    1334:	d1 83       	std	Z+1, r29	; 0x01
    1336:	c0 83       	st	Z, r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
    1338:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	08 95       	ret

00001342 <sIMU_readRegisterRegion>:
}
float fIMU_readFloatGyroY( void ){
    
    float output = fIMU_calcGyro(i16IMU_readRawGyroY());
    return output;
}
    1342:	ef 92       	push	r14
    1344:	ff 92       	push	r15
    1346:	0f 93       	push	r16
    1348:	1f 93       	push	r17
    134a:	cf 93       	push	r28
    134c:	df 93       	push	r29
    134e:	ec 01       	movw	r28, r24
    1350:	e4 2e       	mov	r14, r20
    1352:	28 98       	cbi	0x05, 0	; 5
    1354:	86 2f       	mov	r24, r22
    1356:	80 68       	ori	r24, 0x80	; 128
    1358:	0e 94 23 23 	call	0x4646	; 0x4646 <ui8SPI_MasterTransmit>
    135c:	ee 20       	and	r14, r14
    135e:	b1 f0       	breq	.+44     	; 0x138c <sIMU_readRegisterRegion+0x4a>
    1360:	0f ef       	ldi	r16, 0xFF	; 255
    1362:	0e 0d       	add	r16, r14
    1364:	10 e0       	ldi	r17, 0x00	; 0
    1366:	0f 5f       	subi	r16, 0xFF	; 255
    1368:	1f 4f       	sbci	r17, 0xFF	; 255
    136a:	0c 0f       	add	r16, r28
    136c:	1d 1f       	adc	r17, r29
    136e:	f1 2c       	mov	r15, r1
    1370:	80 e0       	ldi	r24, 0x00	; 0
    1372:	0e 94 23 23 	call	0x4646	; 0x4646 <ui8SPI_MasterTransmit>
    1376:	8f 3f       	cpi	r24, 0xFF	; 255
    1378:	09 f4       	brne	.+2      	; 0x137c <sIMU_readRegisterRegion+0x3a>
    137a:	f3 94       	inc	r15
    137c:	89 93       	st	Y+, r24
    137e:	0c 17       	cp	r16, r28
    1380:	1d 07       	cpc	r17, r29
    1382:	b1 f7       	brne	.-20     	; 0x1370 <sIMU_readRegisterRegion+0x2e>
    1384:	fe 10       	cpse	r15, r14
    1386:	04 c0       	rjmp	.+8      	; 0x1390 <sIMU_readRegisterRegion+0x4e>
    1388:	85 e0       	ldi	r24, 0x05	; 5
    138a:	03 c0       	rjmp	.+6      	; 0x1392 <sIMU_readRegisterRegion+0x50>
    138c:	85 e0       	ldi	r24, 0x05	; 5
    138e:	01 c0       	rjmp	.+2      	; 0x1392 <sIMU_readRegisterRegion+0x50>
    1390:	80 e0       	ldi	r24, 0x00	; 0
    1392:	28 9a       	sbi	0x05, 0	; 5
    1394:	df 91       	pop	r29
    1396:	cf 91       	pop	r28
    1398:	1f 91       	pop	r17
    139a:	0f 91       	pop	r16
    139c:	ff 90       	pop	r15
    139e:	ef 90       	pop	r14
    13a0:	08 95       	ret

000013a2 <sIMU_readRegister>:
    13a2:	cf 93       	push	r28
    13a4:	df 93       	push	r29
    13a6:	ec 01       	movw	r28, r24
    13a8:	28 98       	cbi	0x05, 0	; 5
    13aa:	86 2f       	mov	r24, r22
    13ac:	80 68       	ori	r24, 0x80	; 128
    13ae:	0e 94 23 23 	call	0x4646	; 0x4646 <ui8SPI_MasterTransmit>
    13b2:	80 e0       	ldi	r24, 0x00	; 0
    13b4:	0e 94 23 23 	call	0x4646	; 0x4646 <ui8SPI_MasterTransmit>
    13b8:	28 9a       	sbi	0x05, 0	; 5
    13ba:	8f 3f       	cpi	r24, 0xFF	; 255
    13bc:	11 f4       	brne	.+4      	; 0x13c2 <sIMU_readRegister+0x20>
    13be:	95 e0       	ldi	r25, 0x05	; 5
    13c0:	01 c0       	rjmp	.+2      	; 0x13c4 <sIMU_readRegister+0x22>
    13c2:	90 e0       	ldi	r25, 0x00	; 0
    13c4:	88 83       	st	Y, r24
    13c6:	89 2f       	mov	r24, r25
    13c8:	df 91       	pop	r29
    13ca:	cf 91       	pop	r28
    13cc:	08 95       	ret

000013ce <sIMU_Init>:
    13ce:	cf 93       	push	r28
    13d0:	df 93       	push	r29
    13d2:	1f 92       	push	r1
    13d4:	1f 92       	push	r1
    13d6:	cd b7       	in	r28, 0x3d	; 61
    13d8:	de b7       	in	r29, 0x3e	; 62
    13da:	e7 e2       	ldi	r30, 0x27	; 39
    13dc:	fb e1       	ldi	r31, 0x1B	; 27
    13de:	81 e0       	ldi	r24, 0x01	; 1
    13e0:	80 83       	st	Z, r24
    13e2:	24 ef       	ldi	r18, 0xF4	; 244
    13e4:	31 e0       	ldi	r19, 0x01	; 1
    13e6:	32 83       	std	Z+2, r19	; 0x02
    13e8:	21 83       	std	Z+1, r18	; 0x01
    13ea:	22 e8       	ldi	r18, 0x82	; 130
    13ec:	36 e0       	ldi	r19, 0x06	; 6
    13ee:	34 83       	std	Z+4, r19	; 0x04
    13f0:	23 83       	std	Z+3, r18	; 0x03
    13f2:	20 e9       	ldi	r18, 0x90	; 144
    13f4:	31 e0       	ldi	r19, 0x01	; 1
    13f6:	36 83       	std	Z+6, r19	; 0x06
    13f8:	25 83       	std	Z+5, r18	; 0x05
    13fa:	17 82       	std	Z+7, r1	; 0x07
    13fc:	10 86       	std	Z+8, r1	; 0x08
    13fe:	81 87       	std	Z+9, r24	; 0x09
    1400:	82 87       	std	Z+10, r24	; 0x0a
    1402:	20 e1       	ldi	r18, 0x10	; 16
    1404:	30 e0       	ldi	r19, 0x00	; 0
    1406:	34 87       	std	Z+12, r19	; 0x0c
    1408:	23 87       	std	Z+11, r18	; 0x0b
    140a:	2d e0       	ldi	r18, 0x0D	; 13
    140c:	30 e0       	ldi	r19, 0x00	; 0
    140e:	36 87       	std	Z+14, r19	; 0x0e
    1410:	25 87       	std	Z+13, r18	; 0x0d
    1412:	22 e3       	ldi	r18, 0x32	; 50
    1414:	30 e0       	ldi	r19, 0x00	; 0
    1416:	30 8b       	std	Z+16, r19	; 0x10
    1418:	27 87       	std	Z+15, r18	; 0x0f
    141a:	11 8a       	std	Z+17, r1	; 0x11
    141c:	12 8a       	std	Z+18, r1	; 0x12
    141e:	83 8b       	std	Z+19, r24	; 0x13
    1420:	84 8b       	std	Z+20, r24	; 0x14
    1422:	88 eb       	ldi	r24, 0xB8	; 184
    1424:	9b e0       	ldi	r25, 0x0B	; 11
    1426:	96 8b       	std	Z+22, r25	; 0x16
    1428:	85 8b       	std	Z+21, r24	; 0x15
    142a:	8a e0       	ldi	r24, 0x0A	; 10
    142c:	90 e0       	ldi	r25, 0x00	; 0
    142e:	90 8f       	std	Z+24, r25	; 0x18
    1430:	87 8b       	std	Z+23, r24	; 0x17
    1432:	11 8e       	std	Z+25, r1	; 0x19
    1434:	10 92 42 1b 	sts	0x1B42, r1	; 0x801b42 <allOnesCounter+0x1>
    1438:	10 92 41 1b 	sts	0x1B41, r1	; 0x801b41 <allOnesCounter>
    143c:	10 92 44 1b 	sts	0x1B44, r1	; 0x801b44 <nonSuccessCounter+0x1>
    1440:	10 92 43 1b 	sts	0x1B43, r1	; 0x801b43 <nonSuccessCounter>
    1444:	0e 94 15 23 	call	0x462a	; 0x462a <vSPI_MasterInit>
    1448:	20 9a       	sbi	0x04, 0	; 4
    144a:	28 9a       	sbi	0x05, 0	; 5
    144c:	19 82       	std	Y+1, r1	; 0x01
    144e:	20 e1       	ldi	r18, 0x10	; 16
    1450:	37 e2       	ldi	r19, 0x27	; 39
    1452:	89 81       	ldd	r24, Y+1	; 0x01
    1454:	8f 5f       	subi	r24, 0xFF	; 255
    1456:	89 83       	std	Y+1, r24	; 0x01
    1458:	21 50       	subi	r18, 0x01	; 1
    145a:	31 09       	sbc	r19, r1
    145c:	d1 f7       	brne	.-12     	; 0x1452 <sIMU_Init+0x84>
    145e:	6f e0       	ldi	r22, 0x0F	; 15
    1460:	ce 01       	movw	r24, r28
    1462:	02 96       	adiw	r24, 0x02	; 2
    1464:	9e df       	rcall	.-196    	; 0x13a2 <sIMU_readRegister>
    1466:	8a 81       	ldd	r24, Y+2	; 0x02
    1468:	89 36       	cpi	r24, 0x69	; 105
    146a:	c9 f7       	brne	.-14     	; 0x145e <sIMU_Init+0x90>
    146c:	80 e0       	ldi	r24, 0x00	; 0
    146e:	0f 90       	pop	r0
    1470:	0f 90       	pop	r0
    1472:	df 91       	pop	r29
    1474:	cf 91       	pop	r28
    1476:	08 95       	ret

00001478 <sIMU_readRegisterInt16>:
    1478:	0f 93       	push	r16
    147a:	1f 93       	push	r17
    147c:	cf 93       	push	r28
    147e:	df 93       	push	r29
    1480:	1f 92       	push	r1
    1482:	1f 92       	push	r1
    1484:	cd b7       	in	r28, 0x3d	; 61
    1486:	de b7       	in	r29, 0x3e	; 62
    1488:	8c 01       	movw	r16, r24
    148a:	42 e0       	ldi	r20, 0x02	; 2
    148c:	ce 01       	movw	r24, r28
    148e:	01 96       	adiw	r24, 0x01	; 1
    1490:	58 df       	rcall	.-336    	; 0x1342 <sIMU_readRegisterRegion>
    1492:	2a 81       	ldd	r18, Y+2	; 0x02
    1494:	30 e0       	ldi	r19, 0x00	; 0
    1496:	32 2f       	mov	r19, r18
    1498:	22 27       	eor	r18, r18
    149a:	99 81       	ldd	r25, Y+1	; 0x01
    149c:	29 2b       	or	r18, r25
    149e:	f8 01       	movw	r30, r16
    14a0:	31 83       	std	Z+1, r19	; 0x01
    14a2:	20 83       	st	Z, r18
    14a4:	0f 90       	pop	r0
    14a6:	0f 90       	pop	r0
    14a8:	df 91       	pop	r29
    14aa:	cf 91       	pop	r28
    14ac:	1f 91       	pop	r17
    14ae:	0f 91       	pop	r16
    14b0:	08 95       	ret

000014b2 <sIMU_writeRegister>:
    14b2:	cf 93       	push	r28
    14b4:	c6 2f       	mov	r28, r22
    14b6:	28 98       	cbi	0x05, 0	; 5
    14b8:	0e 94 23 23 	call	0x4646	; 0x4646 <ui8SPI_MasterTransmit>
    14bc:	8c 2f       	mov	r24, r28
    14be:	0e 94 23 23 	call	0x4646	; 0x4646 <ui8SPI_MasterTransmit>
    14c2:	28 9a       	sbi	0x05, 0	; 5
    14c4:	80 e0       	ldi	r24, 0x00	; 0
    14c6:	cf 91       	pop	r28
    14c8:	08 95       	ret

000014ca <sIMU_begin>:
    14ca:	1f 93       	push	r17
    14cc:	cf 93       	push	r28
    14ce:	df 93       	push	r29
    14d0:	1f 92       	push	r1
    14d2:	1f 92       	push	r1
    14d4:	cd b7       	in	r28, 0x3d	; 61
    14d6:	de b7       	in	r29, 0x3e	; 62
    14d8:	19 82       	std	Y+1, r1	; 0x01
    14da:	79 df       	rcall	.-270    	; 0x13ce <sIMU_Init>
    14dc:	18 2f       	mov	r17, r24
    14de:	19 82       	std	Y+1, r1	; 0x01
    14e0:	80 91 30 1b 	lds	r24, 0x1B30	; 0x801b30 <settings+0x9>
    14e4:	81 30       	cpi	r24, 0x01	; 1
    14e6:	09 f0       	breq	.+2      	; 0x14ea <sIMU_begin+0x20>
    14e8:	83 c0       	rjmp	.+262    	; 0x15f0 <sIMU_begin+0x126>
    14ea:	80 91 36 1b 	lds	r24, 0x1B36	; 0x801b36 <settings+0xf>
    14ee:	90 91 37 1b 	lds	r25, 0x1B37	; 0x801b37 <settings+0x10>
    14f2:	84 36       	cpi	r24, 0x64	; 100
    14f4:	91 05       	cpc	r25, r1
    14f6:	41 f0       	breq	.+16     	; 0x1508 <sIMU_begin+0x3e>
    14f8:	88 3c       	cpi	r24, 0xC8	; 200
    14fa:	91 05       	cpc	r25, r1
    14fc:	41 f0       	breq	.+16     	; 0x150e <sIMU_begin+0x44>
    14fe:	c2 97       	sbiw	r24, 0x32	; 50
    1500:	41 f4       	brne	.+16     	; 0x1512 <sIMU_begin+0x48>
    1502:	83 e0       	ldi	r24, 0x03	; 3
    1504:	89 83       	std	Y+1, r24	; 0x01
    1506:	05 c0       	rjmp	.+10     	; 0x1512 <sIMU_begin+0x48>
    1508:	82 e0       	ldi	r24, 0x02	; 2
    150a:	89 83       	std	Y+1, r24	; 0x01
    150c:	02 c0       	rjmp	.+4      	; 0x1512 <sIMU_begin+0x48>
    150e:	81 e0       	ldi	r24, 0x01	; 1
    1510:	89 83       	std	Y+1, r24	; 0x01
    1512:	80 91 32 1b 	lds	r24, 0x1B32	; 0x801b32 <settings+0xb>
    1516:	90 91 33 1b 	lds	r25, 0x1B33	; 0x801b33 <settings+0xc>
    151a:	84 30       	cpi	r24, 0x04	; 4
    151c:	91 05       	cpc	r25, r1
    151e:	31 f0       	breq	.+12     	; 0x152c <sIMU_begin+0x62>
    1520:	88 30       	cpi	r24, 0x08	; 8
    1522:	91 05       	cpc	r25, r1
    1524:	39 f0       	breq	.+14     	; 0x1534 <sIMU_begin+0x6a>
    1526:	02 97       	sbiw	r24, 0x02	; 2
    1528:	49 f4       	brne	.+18     	; 0x153c <sIMU_begin+0x72>
    152a:	0b c0       	rjmp	.+22     	; 0x1542 <sIMU_begin+0x78>
    152c:	89 81       	ldd	r24, Y+1	; 0x01
    152e:	88 60       	ori	r24, 0x08	; 8
    1530:	89 83       	std	Y+1, r24	; 0x01
    1532:	07 c0       	rjmp	.+14     	; 0x1542 <sIMU_begin+0x78>
    1534:	89 81       	ldd	r24, Y+1	; 0x01
    1536:	8c 60       	ori	r24, 0x0C	; 12
    1538:	89 83       	std	Y+1, r24	; 0x01
    153a:	03 c0       	rjmp	.+6      	; 0x1542 <sIMU_begin+0x78>
    153c:	89 81       	ldd	r24, Y+1	; 0x01
    153e:	84 60       	ori	r24, 0x04	; 4
    1540:	89 83       	std	Y+1, r24	; 0x01
    1542:	80 91 34 1b 	lds	r24, 0x1B34	; 0x801b34 <settings+0xd>
    1546:	90 91 35 1b 	lds	r25, 0x1B35	; 0x801b35 <settings+0xe>
    154a:	80 3a       	cpi	r24, 0xA0	; 160
    154c:	21 e0       	ldi	r18, 0x01	; 1
    154e:	92 07       	cpc	r25, r18
    1550:	c1 f1       	breq	.+112    	; 0x15c2 <sIMU_begin+0xf8>
    1552:	70 f4       	brcc	.+28     	; 0x1570 <sIMU_begin+0xa6>
    1554:	8a 31       	cpi	r24, 0x1A	; 26
    1556:	91 05       	cpc	r25, r1
    1558:	21 f1       	breq	.+72     	; 0x15a2 <sIMU_begin+0xd8>
    155a:	18 f4       	brcc	.+6      	; 0x1562 <sIMU_begin+0x98>
    155c:	0d 97       	sbiw	r24, 0x0d	; 13
    155e:	e9 f0       	breq	.+58     	; 0x159a <sIMU_begin+0xd0>
    1560:	28 c0       	rjmp	.+80     	; 0x15b2 <sIMU_begin+0xe8>
    1562:	84 33       	cpi	r24, 0x34	; 52
    1564:	91 05       	cpc	r25, r1
    1566:	09 f1       	breq	.+66     	; 0x15aa <sIMU_begin+0xe0>
    1568:	80 3d       	cpi	r24, 0xD0	; 208
    156a:	91 05       	cpc	r25, r1
    156c:	31 f1       	breq	.+76     	; 0x15ba <sIMU_begin+0xf0>
    156e:	21 c0       	rjmp	.+66     	; 0x15b2 <sIMU_begin+0xe8>
    1570:	82 30       	cpi	r24, 0x02	; 2
    1572:	2d e0       	ldi	r18, 0x0D	; 13
    1574:	92 07       	cpc	r25, r18
    1576:	89 f1       	breq	.+98     	; 0x15da <sIMU_begin+0x110>
    1578:	40 f4       	brcc	.+16     	; 0x158a <sIMU_begin+0xc0>
    157a:	81 34       	cpi	r24, 0x41	; 65
    157c:	23 e0       	ldi	r18, 0x03	; 3
    157e:	92 07       	cpc	r25, r18
    1580:	21 f1       	breq	.+72     	; 0x15ca <sIMU_begin+0x100>
    1582:	8c 37       	cpi	r24, 0x7C	; 124
    1584:	96 40       	sbci	r25, 0x06	; 6
    1586:	29 f1       	breq	.+74     	; 0x15d2 <sIMU_begin+0x108>
    1588:	14 c0       	rjmp	.+40     	; 0x15b2 <sIMU_begin+0xe8>
    158a:	84 30       	cpi	r24, 0x04	; 4
    158c:	2a e1       	ldi	r18, 0x1A	; 26
    158e:	92 07       	cpc	r25, r18
    1590:	41 f1       	breq	.+80     	; 0x15e2 <sIMU_begin+0x118>
    1592:	82 31       	cpi	r24, 0x12	; 18
    1594:	94 43       	sbci	r25, 0x34	; 52
    1596:	49 f1       	breq	.+82     	; 0x15ea <sIMU_begin+0x120>
    1598:	0c c0       	rjmp	.+24     	; 0x15b2 <sIMU_begin+0xe8>
    159a:	89 81       	ldd	r24, Y+1	; 0x01
    159c:	80 61       	ori	r24, 0x10	; 16
    159e:	89 83       	std	Y+1, r24	; 0x01
    15a0:	27 c0       	rjmp	.+78     	; 0x15f0 <sIMU_begin+0x126>
    15a2:	89 81       	ldd	r24, Y+1	; 0x01
    15a4:	80 62       	ori	r24, 0x20	; 32
    15a6:	89 83       	std	Y+1, r24	; 0x01
    15a8:	23 c0       	rjmp	.+70     	; 0x15f0 <sIMU_begin+0x126>
    15aa:	89 81       	ldd	r24, Y+1	; 0x01
    15ac:	80 63       	ori	r24, 0x30	; 48
    15ae:	89 83       	std	Y+1, r24	; 0x01
    15b0:	1f c0       	rjmp	.+62     	; 0x15f0 <sIMU_begin+0x126>
    15b2:	89 81       	ldd	r24, Y+1	; 0x01
    15b4:	80 64       	ori	r24, 0x40	; 64
    15b6:	89 83       	std	Y+1, r24	; 0x01
    15b8:	1b c0       	rjmp	.+54     	; 0x15f0 <sIMU_begin+0x126>
    15ba:	89 81       	ldd	r24, Y+1	; 0x01
    15bc:	80 65       	ori	r24, 0x50	; 80
    15be:	89 83       	std	Y+1, r24	; 0x01
    15c0:	17 c0       	rjmp	.+46     	; 0x15f0 <sIMU_begin+0x126>
    15c2:	89 81       	ldd	r24, Y+1	; 0x01
    15c4:	80 66       	ori	r24, 0x60	; 96
    15c6:	89 83       	std	Y+1, r24	; 0x01
    15c8:	13 c0       	rjmp	.+38     	; 0x15f0 <sIMU_begin+0x126>
    15ca:	89 81       	ldd	r24, Y+1	; 0x01
    15cc:	80 67       	ori	r24, 0x70	; 112
    15ce:	89 83       	std	Y+1, r24	; 0x01
    15d0:	0f c0       	rjmp	.+30     	; 0x15f0 <sIMU_begin+0x126>
    15d2:	89 81       	ldd	r24, Y+1	; 0x01
    15d4:	80 68       	ori	r24, 0x80	; 128
    15d6:	89 83       	std	Y+1, r24	; 0x01
    15d8:	0b c0       	rjmp	.+22     	; 0x15f0 <sIMU_begin+0x126>
    15da:	89 81       	ldd	r24, Y+1	; 0x01
    15dc:	80 69       	ori	r24, 0x90	; 144
    15de:	89 83       	std	Y+1, r24	; 0x01
    15e0:	07 c0       	rjmp	.+14     	; 0x15f0 <sIMU_begin+0x126>
    15e2:	89 81       	ldd	r24, Y+1	; 0x01
    15e4:	80 6a       	ori	r24, 0xA0	; 160
    15e6:	89 83       	std	Y+1, r24	; 0x01
    15e8:	03 c0       	rjmp	.+6      	; 0x15f0 <sIMU_begin+0x126>
    15ea:	89 81       	ldd	r24, Y+1	; 0x01
    15ec:	80 6b       	ori	r24, 0xB0	; 176
    15ee:	89 83       	std	Y+1, r24	; 0x01
    15f0:	69 81       	ldd	r22, Y+1	; 0x01
    15f2:	80 e1       	ldi	r24, 0x10	; 16
    15f4:	5e df       	rcall	.-324    	; 0x14b2 <sIMU_writeRegister>
    15f6:	63 e1       	ldi	r22, 0x13	; 19
    15f8:	ce 01       	movw	r24, r28
    15fa:	01 96       	adiw	r24, 0x01	; 1
    15fc:	d2 de       	rcall	.-604    	; 0x13a2 <sIMU_readRegister>
    15fe:	89 81       	ldd	r24, Y+1	; 0x01
    1600:	8f 77       	andi	r24, 0x7F	; 127
    1602:	89 83       	std	Y+1, r24	; 0x01
    1604:	90 91 31 1b 	lds	r25, 0x1B31	; 0x801b31 <settings+0xa>
    1608:	91 30       	cpi	r25, 0x01	; 1
    160a:	11 f4       	brne	.+4      	; 0x1610 <sIMU_begin+0x146>
    160c:	80 68       	ori	r24, 0x80	; 128
    160e:	89 83       	std	Y+1, r24	; 0x01
    1610:	69 81       	ldd	r22, Y+1	; 0x01
    1612:	83 e1       	ldi	r24, 0x13	; 19
    1614:	4e df       	rcall	.-356    	; 0x14b2 <sIMU_writeRegister>
    1616:	19 82       	std	Y+1, r1	; 0x01
    1618:	80 91 27 1b 	lds	r24, 0x1B27	; 0x801b27 <settings>
    161c:	81 30       	cpi	r24, 0x01	; 1
    161e:	09 f0       	breq	.+2      	; 0x1622 <sIMU_begin+0x158>
    1620:	5b c0       	rjmp	.+182    	; 0x16d8 <sIMU_begin+0x20e>
    1622:	80 91 28 1b 	lds	r24, 0x1B28	; 0x801b28 <settings+0x1>
    1626:	90 91 29 1b 	lds	r25, 0x1B29	; 0x801b29 <settings+0x2>
    162a:	85 3f       	cpi	r24, 0xF5	; 245
    162c:	91 05       	cpc	r25, r1
    162e:	c1 f0       	breq	.+48     	; 0x1660 <sIMU_begin+0x196>
    1630:	20 f4       	brcc	.+8      	; 0x163a <sIMU_begin+0x170>
    1632:	8d 37       	cpi	r24, 0x7D	; 125
    1634:	91 05       	cpc	r25, r1
    1636:	49 f0       	breq	.+18     	; 0x164a <sIMU_begin+0x180>
    1638:	11 c0       	rjmp	.+34     	; 0x165c <sIMU_begin+0x192>
    163a:	84 3f       	cpi	r24, 0xF4	; 244
    163c:	21 e0       	ldi	r18, 0x01	; 1
    163e:	92 07       	cpc	r25, r18
    1640:	39 f0       	breq	.+14     	; 0x1650 <sIMU_begin+0x186>
    1642:	88 3e       	cpi	r24, 0xE8	; 232
    1644:	93 40       	sbci	r25, 0x03	; 3
    1646:	39 f0       	breq	.+14     	; 0x1656 <sIMU_begin+0x18c>
    1648:	09 c0       	rjmp	.+18     	; 0x165c <sIMU_begin+0x192>
    164a:	82 e0       	ldi	r24, 0x02	; 2
    164c:	89 83       	std	Y+1, r24	; 0x01
    164e:	08 c0       	rjmp	.+16     	; 0x1660 <sIMU_begin+0x196>
    1650:	84 e0       	ldi	r24, 0x04	; 4
    1652:	89 83       	std	Y+1, r24	; 0x01
    1654:	05 c0       	rjmp	.+10     	; 0x1660 <sIMU_begin+0x196>
    1656:	88 e0       	ldi	r24, 0x08	; 8
    1658:	89 83       	std	Y+1, r24	; 0x01
    165a:	02 c0       	rjmp	.+4      	; 0x1660 <sIMU_begin+0x196>
    165c:	8c e0       	ldi	r24, 0x0C	; 12
    165e:	89 83       	std	Y+1, r24	; 0x01
    1660:	80 91 2a 1b 	lds	r24, 0x1B2A	; 0x801b2a <settings+0x3>
    1664:	90 91 2b 1b 	lds	r25, 0x1B2B	; 0x801b2b <settings+0x4>
    1668:	80 3d       	cpi	r24, 0xD0	; 208
    166a:	91 05       	cpc	r25, r1
    166c:	31 f1       	breq	.+76     	; 0x16ba <sIMU_begin+0x1f0>
    166e:	48 f4       	brcc	.+18     	; 0x1682 <sIMU_begin+0x1b8>
    1670:	8a 31       	cpi	r24, 0x1A	; 26
    1672:	91 05       	cpc	r25, r1
    1674:	b1 f0       	breq	.+44     	; 0x16a2 <sIMU_begin+0x1d8>
    1676:	84 33       	cpi	r24, 0x34	; 52
    1678:	91 05       	cpc	r25, r1
    167a:	b9 f0       	breq	.+46     	; 0x16aa <sIMU_begin+0x1e0>
    167c:	0d 97       	sbiw	r24, 0x0d	; 13
    167e:	c9 f4       	brne	.+50     	; 0x16b2 <sIMU_begin+0x1e8>
    1680:	0c c0       	rjmp	.+24     	; 0x169a <sIMU_begin+0x1d0>
    1682:	81 34       	cpi	r24, 0x41	; 65
    1684:	23 e0       	ldi	r18, 0x03	; 3
    1686:	92 07       	cpc	r25, r18
    1688:	01 f1       	breq	.+64     	; 0x16ca <sIMU_begin+0x200>
    168a:	8c 37       	cpi	r24, 0x7C	; 124
    168c:	26 e0       	ldi	r18, 0x06	; 6
    168e:	92 07       	cpc	r25, r18
    1690:	01 f1       	breq	.+64     	; 0x16d2 <sIMU_begin+0x208>
    1692:	80 3a       	cpi	r24, 0xA0	; 160
    1694:	91 40       	sbci	r25, 0x01	; 1
    1696:	69 f4       	brne	.+26     	; 0x16b2 <sIMU_begin+0x1e8>
    1698:	14 c0       	rjmp	.+40     	; 0x16c2 <sIMU_begin+0x1f8>
    169a:	89 81       	ldd	r24, Y+1	; 0x01
    169c:	80 61       	ori	r24, 0x10	; 16
    169e:	89 83       	std	Y+1, r24	; 0x01
    16a0:	1b c0       	rjmp	.+54     	; 0x16d8 <sIMU_begin+0x20e>
    16a2:	89 81       	ldd	r24, Y+1	; 0x01
    16a4:	80 62       	ori	r24, 0x20	; 32
    16a6:	89 83       	std	Y+1, r24	; 0x01
    16a8:	17 c0       	rjmp	.+46     	; 0x16d8 <sIMU_begin+0x20e>
    16aa:	89 81       	ldd	r24, Y+1	; 0x01
    16ac:	80 63       	ori	r24, 0x30	; 48
    16ae:	89 83       	std	Y+1, r24	; 0x01
    16b0:	13 c0       	rjmp	.+38     	; 0x16d8 <sIMU_begin+0x20e>
    16b2:	89 81       	ldd	r24, Y+1	; 0x01
    16b4:	80 64       	ori	r24, 0x40	; 64
    16b6:	89 83       	std	Y+1, r24	; 0x01
    16b8:	0f c0       	rjmp	.+30     	; 0x16d8 <sIMU_begin+0x20e>
    16ba:	89 81       	ldd	r24, Y+1	; 0x01
    16bc:	80 65       	ori	r24, 0x50	; 80
    16be:	89 83       	std	Y+1, r24	; 0x01
    16c0:	0b c0       	rjmp	.+22     	; 0x16d8 <sIMU_begin+0x20e>
    16c2:	89 81       	ldd	r24, Y+1	; 0x01
    16c4:	80 66       	ori	r24, 0x60	; 96
    16c6:	89 83       	std	Y+1, r24	; 0x01
    16c8:	07 c0       	rjmp	.+14     	; 0x16d8 <sIMU_begin+0x20e>
    16ca:	89 81       	ldd	r24, Y+1	; 0x01
    16cc:	80 67       	ori	r24, 0x70	; 112
    16ce:	89 83       	std	Y+1, r24	; 0x01
    16d0:	03 c0       	rjmp	.+6      	; 0x16d8 <sIMU_begin+0x20e>
    16d2:	89 81       	ldd	r24, Y+1	; 0x01
    16d4:	80 68       	ori	r24, 0x80	; 128
    16d6:	89 83       	std	Y+1, r24	; 0x01
    16d8:	69 81       	ldd	r22, Y+1	; 0x01
    16da:	81 e1       	ldi	r24, 0x11	; 17
    16dc:	ea de       	rcall	.-556    	; 0x14b2 <sIMU_writeRegister>
    16de:	6f e0       	ldi	r22, 0x0F	; 15
    16e0:	ce 01       	movw	r24, r28
    16e2:	02 96       	adiw	r24, 0x02	; 2
    16e4:	5e de       	rcall	.-836    	; 0x13a2 <sIMU_readRegister>
    16e6:	81 2f       	mov	r24, r17
    16e8:	0f 90       	pop	r0
    16ea:	0f 90       	pop	r0
    16ec:	df 91       	pop	r29
    16ee:	cf 91       	pop	r28
    16f0:	1f 91       	pop	r17
    16f2:	08 95       	ret

000016f4 <i16IMU_readRawGyroZ>:
    16f4:	cf 93       	push	r28
    16f6:	df 93       	push	r29
    16f8:	1f 92       	push	r1
    16fa:	1f 92       	push	r1
    16fc:	cd b7       	in	r28, 0x3d	; 61
    16fe:	de b7       	in	r29, 0x3e	; 62
    1700:	66 e2       	ldi	r22, 0x26	; 38
    1702:	ce 01       	movw	r24, r28
    1704:	01 96       	adiw	r24, 0x01	; 1
    1706:	b8 de       	rcall	.-656    	; 0x1478 <sIMU_readRegisterInt16>
    1708:	88 23       	and	r24, r24
    170a:	a9 f0       	breq	.+42     	; 0x1736 <i16IMU_readRawGyroZ+0x42>
    170c:	85 30       	cpi	r24, 0x05	; 5
    170e:	51 f4       	brne	.+20     	; 0x1724 <i16IMU_readRawGyroZ+0x30>
    1710:	80 91 41 1b 	lds	r24, 0x1B41	; 0x801b41 <allOnesCounter>
    1714:	90 91 42 1b 	lds	r25, 0x1B42	; 0x801b42 <allOnesCounter+0x1>
    1718:	01 96       	adiw	r24, 0x01	; 1
    171a:	90 93 42 1b 	sts	0x1B42, r25	; 0x801b42 <allOnesCounter+0x1>
    171e:	80 93 41 1b 	sts	0x1B41, r24	; 0x801b41 <allOnesCounter>
    1722:	09 c0       	rjmp	.+18     	; 0x1736 <i16IMU_readRawGyroZ+0x42>
    1724:	80 91 43 1b 	lds	r24, 0x1B43	; 0x801b43 <nonSuccessCounter>
    1728:	90 91 44 1b 	lds	r25, 0x1B44	; 0x801b44 <nonSuccessCounter+0x1>
    172c:	01 96       	adiw	r24, 0x01	; 1
    172e:	90 93 44 1b 	sts	0x1B44, r25	; 0x801b44 <nonSuccessCounter+0x1>
    1732:	80 93 43 1b 	sts	0x1B43, r24	; 0x801b43 <nonSuccessCounter>
    1736:	89 81       	ldd	r24, Y+1	; 0x01
    1738:	9a 81       	ldd	r25, Y+2	; 0x02
    173a:	0f 90       	pop	r0
    173c:	0f 90       	pop	r0
    173e:	df 91       	pop	r29
    1740:	cf 91       	pop	r28
    1742:	08 95       	ret

00001744 <fIMU_calcGyro>:
    1744:	cf 92       	push	r12
    1746:	df 92       	push	r13
    1748:	ef 92       	push	r14
    174a:	ff 92       	push	r15
    174c:	cf 93       	push	r28
    174e:	fc 01       	movw	r30, r24
    1750:	40 91 28 1b 	lds	r20, 0x1B28	; 0x801b28 <settings+0x1>
    1754:	50 91 29 1b 	lds	r21, 0x1B29	; 0x801b29 <settings+0x2>
    1758:	45 3f       	cpi	r20, 0xF5	; 245
    175a:	51 05       	cpc	r21, r1
    175c:	b1 f0       	breq	.+44     	; 0x178a <fIMU_calcGyro+0x46>
    175e:	9a 01       	movw	r18, r20
    1760:	a5 e2       	ldi	r26, 0x25	; 37
    1762:	b6 e0       	ldi	r27, 0x06	; 6
    1764:	0e 94 5d 37 	call	0x6eba	; 0x6eba <__umulhisi3>
    1768:	48 1b       	sub	r20, r24
    176a:	59 0b       	sbc	r21, r25
    176c:	56 95       	lsr	r21
    176e:	47 95       	ror	r20
    1770:	84 0f       	add	r24, r20
    1772:	95 1f       	adc	r25, r21
    1774:	00 24       	eor	r0, r0
    1776:	88 0f       	add	r24, r24
    1778:	99 1f       	adc	r25, r25
    177a:	00 1c       	adc	r0, r0
    177c:	88 0f       	add	r24, r24
    177e:	99 1f       	adc	r25, r25
    1780:	00 1c       	adc	r0, r0
    1782:	89 2f       	mov	r24, r25
    1784:	90 2d       	mov	r25, r0
    1786:	c8 2f       	mov	r28, r24
    1788:	01 c0       	rjmp	.+2      	; 0x178c <fIMU_calcGyro+0x48>
    178a:	c2 e0       	ldi	r28, 0x02	; 2
    178c:	bf 01       	movw	r22, r30
    178e:	ff 0f       	add	r31, r31
    1790:	88 0b       	sbc	r24, r24
    1792:	99 0b       	sbc	r25, r25
    1794:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    1798:	20 e0       	ldi	r18, 0x00	; 0
    179a:	30 e0       	ldi	r19, 0x00	; 0
    179c:	4c e8       	ldi	r20, 0x8C	; 140
    179e:	50 e4       	ldi	r21, 0x40	; 64
    17a0:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    17a4:	6b 01       	movw	r12, r22
    17a6:	7c 01       	movw	r14, r24
    17a8:	6c 2f       	mov	r22, r28
    17aa:	70 e0       	ldi	r23, 0x00	; 0
    17ac:	80 e0       	ldi	r24, 0x00	; 0
    17ae:	90 e0       	ldi	r25, 0x00	; 0
    17b0:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    17b4:	9b 01       	movw	r18, r22
    17b6:	ac 01       	movw	r20, r24
    17b8:	c7 01       	movw	r24, r14
    17ba:	b6 01       	movw	r22, r12
    17bc:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    17c0:	20 e0       	ldi	r18, 0x00	; 0
    17c2:	30 e0       	ldi	r19, 0x00	; 0
    17c4:	4a e7       	ldi	r20, 0x7A	; 122
    17c6:	54 e4       	ldi	r21, 0x44	; 68
    17c8:	0e 94 39 31 	call	0x6272	; 0x6272 <__divsf3>
    17cc:	cf 91       	pop	r28
    17ce:	ff 90       	pop	r15
    17d0:	ef 90       	pop	r14
    17d2:	df 90       	pop	r13
    17d4:	cf 90       	pop	r12
    17d6:	08 95       	ret

000017d8 <fIMU_readFloatGyroZ>:
    }
    
    return output;
}
float fIMU_readFloatGyroZ(){
    float output = fIMU_calcGyro(i16IMU_readRawGyroZ());
    17d8:	8d df       	rcall	.-230    	; 0x16f4 <i16IMU_readRawGyroZ>
    17da:	b4 cf       	rjmp	.-152    	; 0x1744 <fIMU_calcGyro>
    
    return output;
}
    17dc:	08 95       	ret

000017de <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    17de:	ea e0       	ldi	r30, 0x0A	; 10
    17e0:	f1 e0       	ldi	r31, 0x01	; 1
    17e2:	80 81       	ld	r24, Z
    17e4:	87 60       	ori	r24, 0x07	; 7
    17e6:	80 83       	st	Z, r24
    17e8:	08 95       	ret

000017ea <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
    17ea:	82 30       	cpi	r24, 0x02	; 2
    17ec:	91 05       	cpc	r25, r1
    17ee:	31 f4       	brne	.+12     	; 0x17fc <vLED_singleHigh+0x12>
    17f0:	eb e0       	ldi	r30, 0x0B	; 11
    17f2:	f1 e0       	ldi	r31, 0x01	; 1
    17f4:	80 81       	ld	r24, Z
    17f6:	84 60       	ori	r24, 0x04	; 4
    17f8:	80 83       	st	Z, r24
    17fa:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
    17fc:	81 30       	cpi	r24, 0x01	; 1
    17fe:	91 05       	cpc	r25, r1
    1800:	31 f4       	brne	.+12     	; 0x180e <vLED_singleHigh+0x24>
    1802:	eb e0       	ldi	r30, 0x0B	; 11
    1804:	f1 e0       	ldi	r31, 0x01	; 1
    1806:	80 81       	ld	r24, Z
    1808:	82 60       	ori	r24, 0x02	; 2
    180a:	80 83       	st	Z, r24
    180c:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
    180e:	89 2b       	or	r24, r25
    1810:	29 f4       	brne	.+10     	; 0x181c <vLED_singleHigh+0x32>
    1812:	eb e0       	ldi	r30, 0x0B	; 11
    1814:	f1 e0       	ldi	r31, 0x01	; 1
    1816:	80 81       	ld	r24, Z
    1818:	81 60       	ori	r24, 0x01	; 1
    181a:	80 83       	st	Z, r24
    181c:	08 95       	ret

0000181e <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
    181e:	82 30       	cpi	r24, 0x02	; 2
    1820:	91 05       	cpc	r25, r1
    1822:	31 f4       	brne	.+12     	; 0x1830 <vLED_singleLow+0x12>
    1824:	eb e0       	ldi	r30, 0x0B	; 11
    1826:	f1 e0       	ldi	r31, 0x01	; 1
    1828:	80 81       	ld	r24, Z
    182a:	8b 7f       	andi	r24, 0xFB	; 251
    182c:	80 83       	st	Z, r24
    182e:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
    1830:	81 30       	cpi	r24, 0x01	; 1
    1832:	91 05       	cpc	r25, r1
    1834:	31 f4       	brne	.+12     	; 0x1842 <vLED_singleLow+0x24>
    1836:	eb e0       	ldi	r30, 0x0B	; 11
    1838:	f1 e0       	ldi	r31, 0x01	; 1
    183a:	80 81       	ld	r24, Z
    183c:	8d 7f       	andi	r24, 0xFD	; 253
    183e:	80 83       	st	Z, r24
    1840:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
    1842:	89 2b       	or	r24, r25
    1844:	29 f4       	brne	.+10     	; 0x1850 <vLED_singleLow+0x32>
    1846:	eb e0       	ldi	r30, 0x0B	; 11
    1848:	f1 e0       	ldi	r31, 0x01	; 1
    184a:	80 81       	ld	r24, Z
    184c:	8e 7f       	andi	r24, 0xFE	; 254
    184e:	80 83       	st	Z, r24
    1850:	08 95       	ret

00001852 <vLED_toggle>:
}

/* Toggle a single LED */
void vLED_toggle(int ledCOLOR){
	if (ledCOLOR == ledGREEN)		ledPORT ^= (1<<ledGREEN);
    1852:	82 30       	cpi	r24, 0x02	; 2
    1854:	91 05       	cpc	r25, r1
    1856:	39 f4       	brne	.+14     	; 0x1866 <vLED_toggle+0x14>
    1858:	eb e0       	ldi	r30, 0x0B	; 11
    185a:	f1 e0       	ldi	r31, 0x01	; 1
    185c:	90 81       	ld	r25, Z
    185e:	84 e0       	ldi	r24, 0x04	; 4
    1860:	89 27       	eor	r24, r25
    1862:	80 83       	st	Z, r24
    1864:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)	ledPORT ^= (1<<ledYELLOW);
    1866:	81 30       	cpi	r24, 0x01	; 1
    1868:	91 05       	cpc	r25, r1
    186a:	39 f4       	brne	.+14     	; 0x187a <vLED_toggle+0x28>
    186c:	eb e0       	ldi	r30, 0x0B	; 11
    186e:	f1 e0       	ldi	r31, 0x01	; 1
    1870:	90 81       	ld	r25, Z
    1872:	82 e0       	ldi	r24, 0x02	; 2
    1874:	89 27       	eor	r24, r25
    1876:	80 83       	st	Z, r24
    1878:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT ^= (1<<ledRED);
    187a:	89 2b       	or	r24, r25
    187c:	31 f4       	brne	.+12     	; 0x188a <vLED_toggle+0x38>
    187e:	eb e0       	ldi	r30, 0x0B	; 11
    1880:	f1 e0       	ldi	r31, 0x01	; 1
    1882:	90 81       	ld	r25, Z
    1884:	81 e0       	ldi	r24, 0x01	; 1
    1886:	89 27       	eor	r24, r25
    1888:	80 83       	st	Z, r24
    188a:	08 95       	ret

0000188c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    188c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    188e:	03 96       	adiw	r24, 0x03	; 3
    1890:	92 83       	std	Z+2, r25	; 0x02
    1892:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1894:	2f ef       	ldi	r18, 0xFF	; 255
    1896:	3f ef       	ldi	r19, 0xFF	; 255
    1898:	34 83       	std	Z+4, r19	; 0x04
    189a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    189c:	96 83       	std	Z+6, r25	; 0x06
    189e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18a0:	90 87       	std	Z+8, r25	; 0x08
    18a2:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    18a4:	10 82       	st	Z, r1
    18a6:	08 95       	ret

000018a8 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    18a8:	fc 01       	movw	r30, r24
    18aa:	11 86       	std	Z+9, r1	; 0x09
    18ac:	10 86       	std	Z+8, r1	; 0x08
    18ae:	08 95       	ret

000018b0 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    18b0:	cf 93       	push	r28
    18b2:	df 93       	push	r29
    18b4:	9c 01       	movw	r18, r24
    18b6:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    18b8:	dc 01       	movw	r26, r24
    18ba:	11 96       	adiw	r26, 0x01	; 1
    18bc:	cd 91       	ld	r28, X+
    18be:	dc 91       	ld	r29, X
    18c0:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    18c2:	d3 83       	std	Z+3, r29	; 0x03
    18c4:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    18c6:	8c 81       	ldd	r24, Y+4	; 0x04
    18c8:	9d 81       	ldd	r25, Y+5	; 0x05
    18ca:	95 83       	std	Z+5, r25	; 0x05
    18cc:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    18ce:	8c 81       	ldd	r24, Y+4	; 0x04
    18d0:	9d 81       	ldd	r25, Y+5	; 0x05
    18d2:	dc 01       	movw	r26, r24
    18d4:	13 96       	adiw	r26, 0x03	; 3
    18d6:	7c 93       	st	X, r23
    18d8:	6e 93       	st	-X, r22
    18da:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    18dc:	7d 83       	std	Y+5, r23	; 0x05
    18de:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    18e0:	31 87       	std	Z+9, r19	; 0x09
    18e2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    18e4:	f9 01       	movw	r30, r18
    18e6:	80 81       	ld	r24, Z
    18e8:	8f 5f       	subi	r24, 0xFF	; 255
    18ea:	80 83       	st	Z, r24
}
    18ec:	df 91       	pop	r29
    18ee:	cf 91       	pop	r28
    18f0:	08 95       	ret

000018f2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    18f2:	cf 93       	push	r28
    18f4:	df 93       	push	r29
    18f6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    18f8:	48 81       	ld	r20, Y
    18fa:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    18fc:	4f 3f       	cpi	r20, 0xFF	; 255
    18fe:	2f ef       	ldi	r18, 0xFF	; 255
    1900:	52 07       	cpc	r21, r18
    1902:	21 f4       	brne	.+8      	; 0x190c <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1904:	fc 01       	movw	r30, r24
    1906:	a7 81       	ldd	r26, Z+7	; 0x07
    1908:	b0 85       	ldd	r27, Z+8	; 0x08
    190a:	0d c0       	rjmp	.+26     	; 0x1926 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    190c:	dc 01       	movw	r26, r24
    190e:	13 96       	adiw	r26, 0x03	; 3
    1910:	01 c0       	rjmp	.+2      	; 0x1914 <vListInsert+0x22>
    1912:	df 01       	movw	r26, r30
    1914:	12 96       	adiw	r26, 0x02	; 2
    1916:	ed 91       	ld	r30, X+
    1918:	fc 91       	ld	r31, X
    191a:	13 97       	sbiw	r26, 0x03	; 3
    191c:	20 81       	ld	r18, Z
    191e:	31 81       	ldd	r19, Z+1	; 0x01
    1920:	42 17       	cp	r20, r18
    1922:	53 07       	cpc	r21, r19
    1924:	b0 f7       	brcc	.-20     	; 0x1912 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1926:	12 96       	adiw	r26, 0x02	; 2
    1928:	ed 91       	ld	r30, X+
    192a:	fc 91       	ld	r31, X
    192c:	13 97       	sbiw	r26, 0x03	; 3
    192e:	fb 83       	std	Y+3, r31	; 0x03
    1930:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1932:	d5 83       	std	Z+5, r29	; 0x05
    1934:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1936:	bd 83       	std	Y+5, r27	; 0x05
    1938:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    193a:	13 96       	adiw	r26, 0x03	; 3
    193c:	dc 93       	st	X, r29
    193e:	ce 93       	st	-X, r28
    1940:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1942:	99 87       	std	Y+9, r25	; 0x09
    1944:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1946:	fc 01       	movw	r30, r24
    1948:	20 81       	ld	r18, Z
    194a:	2f 5f       	subi	r18, 0xFF	; 255
    194c:	20 83       	st	Z, r18
}
    194e:	df 91       	pop	r29
    1950:	cf 91       	pop	r28
    1952:	08 95       	ret

00001954 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1954:	cf 93       	push	r28
    1956:	df 93       	push	r29
    1958:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    195a:	a0 85       	ldd	r26, Z+8	; 0x08
    195c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    195e:	c2 81       	ldd	r28, Z+2	; 0x02
    1960:	d3 81       	ldd	r29, Z+3	; 0x03
    1962:	84 81       	ldd	r24, Z+4	; 0x04
    1964:	95 81       	ldd	r25, Z+5	; 0x05
    1966:	9d 83       	std	Y+5, r25	; 0x05
    1968:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    196a:	c4 81       	ldd	r28, Z+4	; 0x04
    196c:	d5 81       	ldd	r29, Z+5	; 0x05
    196e:	82 81       	ldd	r24, Z+2	; 0x02
    1970:	93 81       	ldd	r25, Z+3	; 0x03
    1972:	9b 83       	std	Y+3, r25	; 0x03
    1974:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1976:	11 96       	adiw	r26, 0x01	; 1
    1978:	8d 91       	ld	r24, X+
    197a:	9c 91       	ld	r25, X
    197c:	12 97       	sbiw	r26, 0x02	; 2
    197e:	e8 17       	cp	r30, r24
    1980:	f9 07       	cpc	r31, r25
    1982:	31 f4       	brne	.+12     	; 0x1990 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1984:	84 81       	ldd	r24, Z+4	; 0x04
    1986:	95 81       	ldd	r25, Z+5	; 0x05
    1988:	12 96       	adiw	r26, 0x02	; 2
    198a:	9c 93       	st	X, r25
    198c:	8e 93       	st	-X, r24
    198e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1990:	11 86       	std	Z+9, r1	; 0x09
    1992:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1994:	8c 91       	ld	r24, X
    1996:	81 50       	subi	r24, 0x01	; 1
    1998:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    199a:	df 91       	pop	r29
    199c:	cf 91       	pop	r28
    199e:	08 95       	ret

000019a0 <vMainCommunicationTask>:
    #define toc PORTH &= ~(1<<PINH5)
#endif

/*  Communication task */
/*  Communication task */
void vMainCommunicationTask( void *pvParameters ){
    19a0:	cf 93       	push	r28
    19a2:	df 93       	push	r29
    19a4:	cd b7       	in	r28, 0x3d	; 61
    19a6:	de b7       	in	r29, 0x3e	; 62
    19a8:	28 97       	sbiw	r28, 0x08	; 8
    19aa:	0f b6       	in	r0, 0x3f	; 63
    19ac:	f8 94       	cli
    19ae:	de bf       	out	0x3e, r29	; 62
    19b0:	0f be       	out	0x3f, r0	; 63
    19b2:	cd bf       	out	0x3d, r28	; 61
	// Setup for the communication task
	struct sCartesian Setpoint = {0,0}; // Struct for setpoints from server
    19b4:	19 82       	std	Y+1, r1	; 0x01
    19b6:	1a 82       	std	Y+2, r1	; 0x02
    19b8:	1b 82       	std	Y+3, r1	; 0x03
    19ba:	1c 82       	std	Y+4, r1	; 0x04
    19bc:	1d 82       	std	Y+5, r1	; 0x05
    19be:	1e 82       	std	Y+6, r1	; 0x06
    19c0:	1f 82       	std	Y+7, r1	; 0x07
    19c2:	18 86       	std	Y+8, r1	; 0x08

	message_t command_in; // Buffer for recieved messages

	server_communication_init();
    19c4:	0e 94 9d 20 	call	0x413a	; 0x413a <server_communication_init>
	if(xTaskCreate(vARQTask, "ARQ", 200, NULL, 3, NULL) != pdPASS) {
    19c8:	a1 2c       	mov	r10, r1
    19ca:	b1 2c       	mov	r11, r1
    19cc:	c1 2c       	mov	r12, r1
    19ce:	d1 2c       	mov	r13, r1
    19d0:	e1 2c       	mov	r14, r1
    19d2:	f1 2c       	mov	r15, r1
    19d4:	03 e0       	ldi	r16, 0x03	; 3
    19d6:	20 e0       	ldi	r18, 0x00	; 0
    19d8:	30 e0       	ldi	r19, 0x00	; 0
    19da:	48 ec       	ldi	r20, 0xC8	; 200
    19dc:	50 e0       	ldi	r21, 0x00	; 0
    19de:	6b e0       	ldi	r22, 0x0B	; 11
    19e0:	76 e0       	ldi	r23, 0x06	; 6
    19e2:	85 e2       	ldi	r24, 0x25	; 37
    19e4:	95 e0       	ldi	r25, 0x05	; 5
    19e6:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskGenericCreate>
    19ea:	81 30       	cpi	r24, 0x01	; 1
    19ec:	19 f0       	breq	.+6      	; 0x19f4 <vMainCommunicationTask+0x54>
		vLED_singleHigh(ledRED);
    19ee:	80 e0       	ldi	r24, 0x00	; 0
    19f0:	90 e0       	ldi	r25, 0x00	; 0
    19f2:	fb de       	rcall	.-522    	; 0x17ea <vLED_singleHigh>
	}
	uint8_t success = 0;
	
	while(!success) {
		success = server_connect();
    19f4:	0e 94 a6 20 	call	0x414c	; 0x414c <server_connect>
    19f8:	18 2f       	mov	r17, r24
		vTaskDelay(1000 / portTICK_PERIOD_MS);
    19fa:	88 ee       	ldi	r24, 0xE8	; 232
    19fc:	93 e0       	ldi	r25, 0x03	; 3
    19fe:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <vTaskDelay>
		vLED_toggle(ledGREEN);
    1a02:	82 e0       	ldi	r24, 0x02	; 2
    1a04:	90 e0       	ldi	r25, 0x00	; 0
    1a06:	25 df       	rcall	.-438    	; 0x1852 <vLED_toggle>
	if(xTaskCreate(vARQTask, "ARQ", 200, NULL, 3, NULL) != pdPASS) {
		vLED_singleHigh(ledRED);
	}
	uint8_t success = 0;
	
	while(!success) {
    1a08:	11 23       	and	r17, r17
    1a0a:	a1 f3       	breq	.-24     	; 0x19f4 <vMainCommunicationTask+0x54>
		success = server_connect();
		vTaskDelay(1000 / portTICK_PERIOD_MS);
		vLED_toggle(ledGREEN);
	}
	
	send_handshake();
    1a0c:	0e 94 b2 20 	call	0x4164	; 0x4164 <send_handshake>
	while(1){
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
			taskENTER_CRITICAL();
			command_in = message_in;
    1a10:	0f 2e       	mov	r0, r31
    1a12:	f1 e5       	ldi	r31, 0x51	; 81
    1a14:	ef 2e       	mov	r14, r31
    1a16:	fb e1       	ldi	r31, 0x1B	; 27
    1a18:	ff 2e       	mov	r15, r31
    1a1a:	f0 2d       	mov	r31, r0
			
		
			switch(command_in.type){
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
					gHandshook = TRUE; // Set start flag true
    1a1c:	01 e0       	ldi	r16, 0x01	; 1
	}
	
	send_handshake();
	
	while(1){
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
    1a1e:	20 e0       	ldi	r18, 0x00	; 0
    1a20:	4f ef       	ldi	r20, 0xFF	; 255
    1a22:	5f ef       	ldi	r21, 0xFF	; 255
    1a24:	60 e0       	ldi	r22, 0x00	; 0
    1a26:	70 e0       	ldi	r23, 0x00	; 0
    1a28:	80 91 4d 1b 	lds	r24, 0x1B4D	; 0x801b4d <xCommandReadyBSem>
    1a2c:	90 91 4e 1b 	lds	r25, 0x1B4E	; 0x801b4e <xCommandReadyBSem+0x1>
    1a30:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
    1a34:	81 30       	cpi	r24, 0x01	; 1
    1a36:	99 f7       	brne	.-26     	; 0x1a1e <vMainCommunicationTask+0x7e>
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
    1a38:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspendAll>
			taskENTER_CRITICAL();
    1a3c:	0f b6       	in	r0, 0x3f	; 63
    1a3e:	f8 94       	cli
    1a40:	0f 92       	push	r0
			command_in = message_in;
    1a42:	f7 01       	movw	r30, r14
    1a44:	10 81       	ld	r17, Z
    1a46:	a1 80       	ldd	r10, Z+1	; 0x01
    1a48:	b2 80       	ldd	r11, Z+2	; 0x02
    1a4a:	c3 80       	ldd	r12, Z+3	; 0x03
    1a4c:	d4 80       	ldd	r13, Z+4	; 0x04
			//debug("Message received: \n");
			//debug("Type: %i", command_in.type);
			
			//debug("Distance, Heading: %i %i\n",command_in.message.order.x, command_in.message.order.y);
			taskEXIT_CRITICAL();
    1a4e:	0f 90       	pop	r0
    1a50:	0f be       	out	0x3f, r0	; 63
			xTaskResumeAll ();      // Enable context switching
    1a52:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
			
		
			switch(command_in.type){
    1a56:	15 30       	cpi	r17, 0x05	; 5
    1a58:	09 f4       	brne	.+2      	; 0x1a5c <vMainCommunicationTask+0xbc>
    1a5a:	55 c0       	rjmp	.+170    	; 0x1b06 <vMainCommunicationTask+0x166>
    1a5c:	28 f4       	brcc	.+10     	; 0x1a68 <vMainCommunicationTask+0xc8>
    1a5e:	12 30       	cpi	r17, 0x02	; 2
    1a60:	a9 f0       	breq	.+42     	; 0x1a8c <vMainCommunicationTask+0xec>
    1a62:	14 30       	cpi	r17, 0x04	; 4
    1a64:	a1 f1       	breq	.+104    	; 0x1ace <vMainCommunicationTask+0x12e>
    1a66:	db cf       	rjmp	.-74     	; 0x1a1e <vMainCommunicationTask+0x7e>
    1a68:	17 30       	cpi	r17, 0x07	; 7
    1a6a:	09 f4       	brne	.+2      	; 0x1a6e <vMainCommunicationTask+0xce>
    1a6c:	54 c0       	rjmp	.+168    	; 0x1b16 <vMainCommunicationTask+0x176>
    1a6e:	18 f0       	brcs	.+6      	; 0x1a76 <vMainCommunicationTask+0xd6>
    1a70:	18 30       	cpi	r17, 0x08	; 8
    1a72:	49 f0       	breq	.+18     	; 0x1a86 <vMainCommunicationTask+0xe6>
    1a74:	d4 cf       	rjmp	.-88     	; 0x1a1e <vMainCommunicationTask+0x7e>
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
    1a76:	0f b6       	in	r0, 0x3f	; 63
    1a78:	f8 94       	cli
    1a7a:	0f 92       	push	r0
					gHandshook = TRUE; // Set start flag true
    1a7c:	00 93 de 19 	sts	0x19DE, r16	; 0x8019de <gHandshook>
					taskEXIT_CRITICAL();
    1a80:	0f 90       	pop	r0
    1a82:	0f be       	out	0x3f, r0	; 63

					break;
    1a84:	cc cf       	rjmp	.-104    	; 0x1a1e <vMainCommunicationTask+0x7e>
				case TYPE_PING:
					send_ping_response();
    1a86:	0e 94 ba 21 	call	0x4374	; 0x4374 <send_ping_response>
					break;
    1a8a:	c9 cf       	rjmp	.-110    	; 0x1a1e <vMainCommunicationTask+0x7e>
				case TYPE_ORDER:
					Setpoint.x = command_in.message.order.x;
    1a8c:	b5 01       	movw	r22, r10
    1a8e:	bb 0c       	add	r11, r11
    1a90:	88 0b       	sbc	r24, r24
    1a92:	99 0b       	sbc	r25, r25
    1a94:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    1a98:	69 83       	std	Y+1, r22	; 0x01
    1a9a:	7a 83       	std	Y+2, r23	; 0x02
    1a9c:	8b 83       	std	Y+3, r24	; 0x03
    1a9e:	9c 83       	std	Y+4, r25	; 0x04
					Setpoint.y = command_in.message.order.y;
    1aa0:	b6 01       	movw	r22, r12
    1aa2:	dd 0c       	add	r13, r13
    1aa4:	88 0b       	sbc	r24, r24
    1aa6:	99 0b       	sbc	r25, r25
    1aa8:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    1aac:	6d 83       	std	Y+5, r22	; 0x05
    1aae:	7e 83       	std	Y+6, r23	; 0x06
    1ab0:	8f 83       	std	Y+7, r24	; 0x07
    1ab2:	98 87       	std	Y+8, r25	; 0x08
					
					//debug("order x,y: %f, %f",Setpoint.x,Setpoint.y);
					/* Relay new coordinates to position controller */
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1ab4:	20 e0       	ldi	r18, 0x00	; 0
    1ab6:	44 e6       	ldi	r20, 0x64	; 100
    1ab8:	50 e0       	ldi	r21, 0x00	; 0
    1aba:	be 01       	movw	r22, r28
    1abc:	6f 5f       	subi	r22, 0xFF	; 255
    1abe:	7f 4f       	sbci	r23, 0xFF	; 255
    1ac0:	80 91 e5 19 	lds	r24, 0x19E5	; 0x8019e5 <poseControllerQ>
    1ac4:	90 91 e6 19 	lds	r25, 0x19E6	; 0x8019e6 <poseControllerQ+0x1>
    1ac8:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <xQueueGenericSend>
					break;
    1acc:	a8 cf       	rjmp	.-176    	; 0x1a1e <vMainCommunicationTask+0x7e>
				case TYPE_PAUSE:
					// Stop sending update messages
					taskENTER_CRITICAL();
    1ace:	0f b6       	in	r0, 0x3f	; 63
    1ad0:	f8 94       	cli
    1ad2:	0f 92       	push	r0
					gPaused = TRUE;
    1ad4:	00 93 dd 19 	sts	0x19DD, r16	; 0x8019dd <gPaused>
					taskEXIT_CRITICAL();
    1ad8:	0f 90       	pop	r0
    1ada:	0f be       	out	0x3f, r0	; 63
					// Stop controller
					Setpoint.x = 0;
    1adc:	19 82       	std	Y+1, r1	; 0x01
    1ade:	1a 82       	std	Y+2, r1	; 0x02
    1ae0:	1b 82       	std	Y+3, r1	; 0x03
    1ae2:	1c 82       	std	Y+4, r1	; 0x04
					Setpoint.y = 0;
    1ae4:	1d 82       	std	Y+5, r1	; 0x05
    1ae6:	1e 82       	std	Y+6, r1	; 0x06
    1ae8:	1f 82       	std	Y+7, r1	; 0x07
    1aea:	18 86       	std	Y+8, r1	; 0x08
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1aec:	20 e0       	ldi	r18, 0x00	; 0
    1aee:	44 e6       	ldi	r20, 0x64	; 100
    1af0:	50 e0       	ldi	r21, 0x00	; 0
    1af2:	be 01       	movw	r22, r28
    1af4:	6f 5f       	subi	r22, 0xFF	; 255
    1af6:	7f 4f       	sbci	r23, 0xFF	; 255
    1af8:	80 91 e5 19 	lds	r24, 0x19E5	; 0x8019e5 <poseControllerQ>
    1afc:	90 91 e6 19 	lds	r25, 0x19E6	; 0x8019e6 <poseControllerQ+0x1>
    1b00:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <xQueueGenericSend>
					break;
    1b04:	8c cf       	rjmp	.-232    	; 0x1a1e <vMainCommunicationTask+0x7e>
				case TYPE_UNPAUSE:
					taskENTER_CRITICAL();
    1b06:	0f b6       	in	r0, 0x3f	; 63
    1b08:	f8 94       	cli
    1b0a:	0f 92       	push	r0
					gPaused = FALSE;
    1b0c:	10 92 dd 19 	sts	0x19DD, r1	; 0x8019dd <gPaused>
					taskEXIT_CRITICAL();
    1b10:	0f 90       	pop	r0
    1b12:	0f be       	out	0x3f, r0	; 63
					break;
    1b14:	84 cf       	rjmp	.-248    	; 0x1a1e <vMainCommunicationTask+0x7e>
				case TYPE_FINISH:
					taskENTER_CRITICAL();
    1b16:	0f b6       	in	r0, 0x3f	; 63
    1b18:	f8 94       	cli
    1b1a:	0f 92       	push	r0
					gHandshook = FALSE;
    1b1c:	10 92 de 19 	sts	0x19DE, r1	; 0x8019de <gHandshook>
					taskEXIT_CRITICAL();
    1b20:	0f 90       	pop	r0
    1b22:	0f be       	out	0x3f, r0	; 63
					break;
    1b24:	7c cf       	rjmp	.-264    	; 0x1a1e <vMainCommunicationTask+0x7e>

00001b26 <vMainSensorTowerTask>:
		} // if (xCommandReady) end
	}// While(1) end
}// vMainComtask end

/*  Sensor tower task */
void vMainSensorTowerTask( void *pvParameters){
    1b26:	cf 93       	push	r28
    1b28:	df 93       	push	r29
    1b2a:	cd b7       	in	r28, 0x3d	; 61
    1b2c:	de b7       	in	r29, 0x3e	; 62
    1b2e:	63 97       	sbiw	r28, 0x13	; 19
    1b30:	0f b6       	in	r0, 0x3f	; 63
    1b32:	f8 94       	cli
    1b34:	de bf       	out	0x3e, r29	; 62
    1b36:	0f be       	out	0x3f, r0	; 63
    1b38:	cd bf       	out	0x3d, r28	; 61
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    uint8_t robotMovement = moveStop;
    1b3a:	19 82       	std	Y+1, r1	; 0x01
    
    uint8_t idleCounter = 0;
    1b3c:	10 e0       	ldi	r17, 0x00	; 0
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    1b3e:	21 e0       	ldi	r18, 0x01	; 1
    1b40:	28 8b       	std	Y+16, r18	; 0x10
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    1b42:	f1 2c       	mov	r15, r1
        
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    1b44:	68 94       	set
    1b46:	22 24       	eor	r2, r2
    1b48:	22 f8       	bld	r2, 2
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1b4a:	68 94       	set
    1b4c:	33 24       	eor	r3, r3
    1b4e:	32 f8       	bld	r3, 2
    1b50:	0e c0       	rjmp	.+28     	; 0x1b6e <vMainSensorTowerTask+0x48>
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
                rotationDirection = moveClockwise;
    1b52:	0f 2e       	mov	r0, r31
    1b54:	f3 e0       	ldi	r31, 0x03	; 3
    1b56:	2f 2e       	mov	r2, r31
    1b58:	f0 2d       	mov	r31, r0
    1b5a:	09 c0       	rjmp	.+18     	; 0x1b6e <vMainSensorTowerTask+0x48>
    1b5c:	0f 2e       	mov	r0, r31
    1b5e:	f3 e0       	ldi	r31, 0x03	; 3
    1b60:	2f 2e       	mov	r2, r31
    1b62:	f0 2d       	mov	r31, r0
    1b64:	04 c0       	rjmp	.+8      	; 0x1b6e <vMainSensorTowerTask+0x48>
    1b66:	0f 2e       	mov	r0, r31
    1b68:	f3 e0       	ldi	r31, 0x03	; 3
    1b6a:	2f 2e       	mov	r2, r31
    1b6c:	f0 2d       	mov	r31, r0
    // Initialize the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    
    while(1){
        // Loop
        if ((gHandshook == TRUE) && (gPaused == FALSE)){
    1b6e:	80 91 de 19 	lds	r24, 0x19DE	; 0x8019de <gHandshook>
    1b72:	81 30       	cpi	r24, 0x01	; 1
    1b74:	09 f0       	breq	.+2      	; 0x1b78 <vMainSensorTowerTask+0x52>
    1b76:	20 c1       	rjmp	.+576    	; 0x1db8 <vMainSensorTowerTask+0x292>
    1b78:	80 91 dd 19 	lds	r24, 0x19DD	; 0x8019dd <gPaused>
    1b7c:	81 11       	cpse	r24, r1
    1b7e:	1c c1       	rjmp	.+568    	; 0x1db8 <vMainSensorTowerTask+0x292>
            // xLastWakeTime variable with the current time.
            xLastWakeTime = xTaskGetTickCount();
    1b80:	0e 94 8b 29 	call	0x5316	; 0x5316 <xTaskGetTickCount>
    1b84:	9b 83       	std	Y+3, r25	; 0x03
    1b86:	8a 83       	std	Y+2, r24	; 0x02
            // Set scanning resolution depending on which movement the robot is executing.
            if (xQueueReceive(scanStatusQ, &robotMovement,150 / portTICK_PERIOD_MS) == pdTRUE){
    1b88:	20 e0       	ldi	r18, 0x00	; 0
    1b8a:	46 e9       	ldi	r20, 0x96	; 150
    1b8c:	50 e0       	ldi	r21, 0x00	; 0
    1b8e:	be 01       	movw	r22, r28
    1b90:	6f 5f       	subi	r22, 0xFF	; 255
    1b92:	7f 4f       	sbci	r23, 0xFF	; 255
    1b94:	80 91 e3 19 	lds	r24, 0x19E3	; 0x8019e3 <scanStatusQ>
    1b98:	90 91 e4 19 	lds	r25, 0x19E4	; 0x8019e4 <scanStatusQ+0x1>
    1b9c:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
    1ba0:	81 30       	cpi	r24, 0x01	; 1
    1ba2:	c9 f4       	brne	.+50     	; 0x1bd6 <vMainSensorTowerTask+0xb0>
                // Set servo step length according to movement, 
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
    1ba4:	89 81       	ldd	r24, Y+1	; 0x01
    1ba6:	88 23       	and	r24, r24
    1ba8:	19 f0       	breq	.+6      	; 0x1bb0 <vMainSensorTowerTask+0x8a>
    1baa:	83 30       	cpi	r24, 0x03	; 3
    1bac:	98 f4       	brcc	.+38     	; 0x1bd4 <vMainSensorTowerTask+0xae>
    1bae:	08 c0       	rjmp	.+16     	; 0x1bc0 <vMainSensorTowerTask+0x9a>
                {
                    case moveStop:
                        servoStep *= servoResolution;
    1bb0:	38 89       	ldd	r19, Y+16	; 0x10
    1bb2:	f3 9e       	mul	r15, r19
    1bb4:	f0 2c       	mov	r15, r0
    1bb6:	11 24       	eor	r1, r1
                        servoResolution = 1;
                        idleCounter = 1;
    1bb8:	11 e0       	ldi	r17, 0x01	; 1
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
                {
                    case moveStop:
                        servoStep *= servoResolution;
                        servoResolution = 1;
    1bba:	81 e0       	ldi	r24, 0x01	; 1
    1bbc:	88 8b       	std	Y+16, r24	; 0x10
                        idleCounter = 1;
                    break;
    1bbe:	0b c0       	rjmp	.+22     	; 0x1bd6 <vMainSensorTowerTask+0xb0>
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
                        servoStep /= servoResolution;
    1bc0:	9d ec       	ldi	r25, 0xCD	; 205
    1bc2:	f9 9e       	mul	r15, r25
    1bc4:	f1 2c       	mov	r15, r1
    1bc6:	11 24       	eor	r1, r1
    1bc8:	f6 94       	lsr	r15
    1bca:	f6 94       	lsr	r15
                        idleCounter = 0;
    1bcc:	10 e0       	ldi	r17, 0x00	; 0
                        servoResolution = 1;
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
    1bce:	25 e0       	ldi	r18, 0x05	; 5
    1bd0:	28 8b       	std	Y+16, r18	; 0x10
                        servoStep /= servoResolution;
                        idleCounter = 0;
                    break;
    1bd2:	01 c0       	rjmp	.+2      	; 0x1bd6 <vMainSensorTowerTask+0xb0>
                    case moveClockwise:
                    case moveCounterClockwise:
                        // Iterations are frozen while rotating, see further down
                        idleCounter = 0;
    1bd4:	10 e0       	ldi	r17, 0x00	; 0
                    default:
                        idleCounter = 0;
                    break;
                }
            }
            vServo_setAngle(servoStep*servoResolution);
    1bd6:	38 89       	ldd	r19, Y+16	; 0x10
    1bd8:	f3 9e       	mul	r15, r19
    1bda:	80 2d       	mov	r24, r0
    1bdc:	11 24       	eor	r1, r1
    1bde:	0e 94 de 21 	call	0x43bc	; 0x43bc <vServo_setAngle>
            vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_PERIOD_MS); // Wait total of 200 ms for servo to reach set point
    1be2:	68 ec       	ldi	r22, 0xC8	; 200
    1be4:	70 e0       	ldi	r23, 0x00	; 0
    1be6:	ce 01       	movw	r24, r28
    1be8:	02 96       	adiw	r24, 0x02	; 2
    1bea:	0e 94 3e 24 	call	0x487c	; 0x487c <vTaskDelayUntil>
            
            uint8_t forwardSensor = ui8DistSens_readCM(distSensFwd);
    1bee:	80 e0       	ldi	r24, 0x00	; 0
    1bf0:	bc d9       	rcall	.-3208   	; 0xf6a <ui8DistSens_readCM>
    1bf2:	d8 2e       	mov	r13, r24
            uint8_t leftSensor = ui8DistSens_readCM(distSensLeft);
    1bf4:	81 e0       	ldi	r24, 0x01	; 1
    1bf6:	b9 d9       	rcall	.-3214   	; 0xf6a <ui8DistSens_readCM>
    1bf8:	e8 2e       	mov	r14, r24
            uint8_t rearSensor = ui8DistSens_readCM(distSensRear);
    1bfa:	83 e0       	ldi	r24, 0x03	; 3
    1bfc:	b6 d9       	rcall	.-3220   	; 0xf6a <ui8DistSens_readCM>
    1bfe:	c8 2e       	mov	r12, r24
            uint8_t rightSensor = ui8DistSens_readCM(distSensRight);
    1c00:	82 e0       	ldi	r24, 0x02	; 2
    1c02:	b3 d9       	rcall	.-3226   	; 0xf6a <ui8DistSens_readCM>
    1c04:	89 8b       	std	Y+17, r24	; 0x11
    1c06:	20 e0       	ldi	r18, 0x00	; 0
		
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
    1c08:	48 e2       	ldi	r20, 0x28	; 40
    1c0a:	50 e0       	ldi	r21, 0x00	; 0
    1c0c:	60 e0       	ldi	r22, 0x00	; 0
    1c0e:	70 e0       	ldi	r23, 0x00	; 0
    1c10:	80 91 4f 1b 	lds	r24, 0x1B4F	; 0x801b4f <xPoseMutex>
    1c14:	90 91 50 1b 	lds	r25, 0x1B50	; 0x801b50 <xPoseMutex+0x1>
    1c18:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
    1c1c:	40 90 d9 19 	lds	r4, 0x19D9	; 0x8019d9 <gTheta_hat>
                thetahat = gTheta_hat;
    1c20:	50 90 da 19 	lds	r5, 0x19DA	; 0x8019da <gTheta_hat+0x1>
    1c24:	60 90 db 19 	lds	r6, 0x19DB	; 0x8019db <gTheta_hat+0x2>
    1c28:	70 90 dc 19 	lds	r7, 0x19DC	; 0x8019dc <gTheta_hat+0x3>
    1c2c:	a0 90 d7 19 	lds	r10, 0x19D7	; 0x8019d7 <gX_hat>
                xhat = gX_hat;
    1c30:	b0 90 d8 19 	lds	r11, 0x19D8	; 0x8019d8 <gX_hat+0x1>
    1c34:	80 91 d5 19 	lds	r24, 0x19D5	; 0x8019d5 <gY_hat>
                yhat = gY_hat;
    1c38:	90 91 d6 19 	lds	r25, 0x19D6	; 0x8019d6 <gY_hat+0x1>
    1c3c:	9d 87       	std	Y+13, r25	; 0x0d
    1c3e:	8c 87       	std	Y+12, r24	; 0x0c
    1c40:	60 e0       	ldi	r22, 0x00	; 0
            xSemaphoreGive(xPoseMutex);
    1c42:	70 e0       	ldi	r23, 0x00	; 0
    1c44:	80 91 4f 1b 	lds	r24, 0x1B4F	; 0x801b4f <xPoseMutex>
    1c48:	90 91 50 1b 	lds	r25, 0x1B50	; 0x801b50 <xPoseMutex+0x1>
    1c4c:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
    1c50:	1b 30       	cpi	r17, 0x0B	; 11
            
            // Experimental
            if ((idleCounter > 10) && (robotMovement == moveStop)){
    1c52:	38 f0       	brcs	.+14     	; 0x1c62 <vMainSensorTowerTask+0x13c>
    1c54:	89 81       	ldd	r24, Y+1	; 0x01
    1c56:	81 11       	cpse	r24, r1
    1c58:	04 c0       	rjmp	.+8      	; 0x1c62 <vMainSensorTowerTask+0x13c>
    1c5a:	0e 94 59 21 	call	0x42b2	; 0x42b2 <send_idle>
                // If the robot stands idle for 1 second, send 'status:idle' in case the server missed it.
                send_idle();
    1c5e:	11 e0       	ldi	r17, 0x01	; 1
				//debug("idle i vMainSensortask");
                idleCounter = 1;
    1c60:	06 c0       	rjmp	.+12     	; 0x1c6e <vMainSensorTowerTask+0x148>
    1c62:	11 23       	and	r17, r17
            }
            else if ((idleCounter >= 1) && (robotMovement == moveStop)){
    1c64:	21 f0       	breq	.+8      	; 0x1c6e <vMainSensorTowerTask+0x148>
    1c66:	89 81       	ldd	r24, Y+1	; 0x01
    1c68:	81 11       	cpse	r24, r1
    1c6a:	01 c0       	rjmp	.+2      	; 0x1c6e <vMainSensorTowerTask+0x148>
    1c6c:	1f 5f       	subi	r17, 0xFF	; 255
                idleCounter++;
    1c6e:	38 89       	ldd	r19, Y+16	; 0x10
            }             

            // Send updates to server
			
			//[Commented out to decrease messages, ]
            send_update(xhat/10,yhat/10,thetahat*RAD2DEG,servoStep*servoResolution,forwardSensor,leftSensor,rearSensor,rightSensor);
    1c70:	23 2f       	mov	r18, r19
    1c72:	30 e0       	ldi	r19, 0x00	; 0
    1c74:	3b 8b       	std	Y+19, r19	; 0x13
    1c76:	2a 8b       	std	Y+18, r18	; 0x12
    1c78:	f2 9e       	mul	r15, r18
    1c7a:	40 01       	movw	r8, r0
    1c7c:	f3 9e       	mul	r15, r19
    1c7e:	90 0c       	add	r9, r0
    1c80:	11 24       	eor	r1, r1
    1c82:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c84:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c86:	6a e0       	ldi	r22, 0x0A	; 10
    1c88:	70 e0       	ldi	r23, 0x00	; 0
    1c8a:	0e 94 4a 37 	call	0x6e94	; 0x6e94 <__divmodhi4>
    1c8e:	7d 87       	std	Y+13, r23	; 0x0d
    1c90:	6c 87       	std	Y+12, r22	; 0x0c
    1c92:	c5 01       	movw	r24, r10
    1c94:	6a e0       	ldi	r22, 0x0A	; 10
    1c96:	70 e0       	ldi	r23, 0x00	; 0
    1c98:	0e 94 4a 37 	call	0x6e94	; 0x6e94 <__divmodhi4>
    1c9c:	7f 87       	std	Y+15, r23	; 0x0f
    1c9e:	6e 87       	std	Y+14, r22	; 0x0e
    1ca0:	20 e0       	ldi	r18, 0x00	; 0
    1ca2:	30 e0       	ldi	r19, 0x00	; 0
    1ca4:	44 e3       	ldi	r20, 0x34	; 52
    1ca6:	53 e4       	ldi	r21, 0x43	; 67
    1ca8:	c3 01       	movw	r24, r6
    1caa:	b2 01       	movw	r22, r4
    1cac:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    1cb0:	2b ed       	ldi	r18, 0xDB	; 219
    1cb2:	3f e0       	ldi	r19, 0x0F	; 15
    1cb4:	49 e4       	ldi	r20, 0x49	; 73
    1cb6:	50 e4       	ldi	r21, 0x40	; 64
    1cb8:	0e 94 39 31 	call	0x6272	; 0x6272 <__divsf3>
    1cbc:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
    1cc0:	a9 88       	ldd	r10, Y+17	; 0x11
    1cc2:	0d 2d       	mov	r16, r13
    1cc4:	94 01       	movw	r18, r8
    1cc6:	ab 01       	movw	r20, r22
    1cc8:	6c 85       	ldd	r22, Y+12	; 0x0c
    1cca:	7d 85       	ldd	r23, Y+13	; 0x0d
    1ccc:	8e 85       	ldd	r24, Y+14	; 0x0e
    1cce:	9f 85       	ldd	r25, Y+15	; 0x0f
    1cd0:	0e 94 17 21 	call	0x422e	; 0x422e <send_update>
    1cd4:	8f e1       	ldi	r24, 0x1F	; 31
            
            
            // Low level anti collision
            uint8_t objectX;
            if ((servoStep*servoResolution) <= 30) objectX = forwardSensor;// * cos(servoStep*5);
    1cd6:	88 16       	cp	r8, r24
    1cd8:	91 04       	cpc	r9, r1
    1cda:	2c f0       	brlt	.+10     	; 0x1ce6 <vMainSensorTowerTask+0x1c0>
    1cdc:	9c e3       	ldi	r25, 0x3C	; 60
            else if((servoStep*servoResolution) >= 60) objectX = rightSensor;// * cos(270 + servoStep*5);
    1cde:	89 16       	cp	r8, r25
    1ce0:	91 04       	cpc	r9, r1
    1ce2:	8c f1       	brlt	.+98     	; 0x1d46 <vMainSensorTowerTask+0x220>
    1ce4:	d9 88       	ldd	r13, Y+17	; 0x11
    1ce6:	8f ef       	ldi	r24, 0xFF	; 255
            else objectX = 0;
            

			
            if ((objectX > 0) && (objectX < 20)){
    1ce8:	8d 0d       	add	r24, r13
    1cea:	83 31       	cpi	r24, 0x13	; 19
    1cec:	60 f5       	brcc	.+88     	; 0x1d46 <vMainSensorTowerTask+0x220>
    1cee:	2e 85       	ldd	r18, Y+14	; 0x0e
                // Stop controller
                struct sCartesian Setpoint = {xhat/10, yhat/10};
    1cf0:	3f 85       	ldd	r19, Y+15	; 0x0f
    1cf2:	b9 01       	movw	r22, r18
    1cf4:	33 0f       	add	r19, r19
    1cf6:	88 0b       	sbc	r24, r24
    1cf8:	99 0b       	sbc	r25, r25
    1cfa:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    1cfe:	6c 83       	std	Y+4, r22	; 0x04
    1d00:	7d 83       	std	Y+5, r23	; 0x05
    1d02:	8e 83       	std	Y+6, r24	; 0x06
    1d04:	9f 83       	std	Y+7, r25	; 0x07
    1d06:	2c 85       	ldd	r18, Y+12	; 0x0c
    1d08:	3d 85       	ldd	r19, Y+13	; 0x0d
    1d0a:	b9 01       	movw	r22, r18
    1d0c:	33 0f       	add	r19, r19
    1d0e:	88 0b       	sbc	r24, r24
    1d10:	99 0b       	sbc	r25, r25
    1d12:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    1d16:	68 87       	std	Y+8, r22	; 0x08
    1d18:	79 87       	std	Y+9, r23	; 0x09
    1d1a:	8a 87       	std	Y+10, r24	; 0x0a
    1d1c:	9b 87       	std	Y+11, r25	; 0x0b
    1d1e:	8f e0       	ldi	r24, 0x0F	; 15
					debug("anti kollisjon");
    1d20:	96 e0       	ldi	r25, 0x06	; 6
    1d22:	9f 93       	push	r25
    1d24:	8f 93       	push	r24
    1d26:	0e 94 7d 21 	call	0x42fa	; 0x42fa <debug>
    1d2a:	20 e0       	ldi	r18, 0x00	; 0
                xQueueSend(poseControllerQ, &Setpoint, 100);
    1d2c:	44 e6       	ldi	r20, 0x64	; 100
    1d2e:	50 e0       	ldi	r21, 0x00	; 0
    1d30:	be 01       	movw	r22, r28
    1d32:	6c 5f       	subi	r22, 0xFC	; 252
    1d34:	7f 4f       	sbci	r23, 0xFF	; 255
    1d36:	80 91 e5 19 	lds	r24, 0x19E5	; 0x8019e5 <poseControllerQ>
    1d3a:	90 91 e6 19 	lds	r25, 0x19E6	; 0x8019e6 <poseControllerQ+0x1>
    1d3e:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <xQueueGenericSend>
    1d42:	0f 90       	pop	r0
    1d44:	0f 90       	pop	r0
    1d46:	3b e5       	ldi	r19, 0x5B	; 91
				
				
            }
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
    1d48:	83 16       	cp	r8, r19
    1d4a:	91 04       	cpc	r9, r1
    1d4c:	ac f4       	brge	.+42     	; 0x1d78 <vMainSensorTowerTask+0x252>
    1d4e:	84 e0       	ldi	r24, 0x04	; 4
    1d50:	28 12       	cpse	r2, r24
    1d52:	12 c0       	rjmp	.+36     	; 0x1d78 <vMainSensorTowerTask+0x252>
    1d54:	89 81       	ldd	r24, Y+1	; 0x01
    1d56:	83 30       	cpi	r24, 0x03	; 3
    1d58:	08 f0       	brcs	.+2      	; 0x1d5c <vMainSensorTowerTask+0x236>
    1d5a:	44 c0       	rjmp	.+136    	; 0x1de4 <vMainSensorTowerTask+0x2be>
    1d5c:	f3 94       	inc	r15
                servoStep++;
    1d5e:	2a 89       	ldd	r18, Y+18	; 0x12
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1d60:	3b 89       	ldd	r19, Y+19	; 0x13
    1d62:	f2 9e       	mul	r15, r18
    1d64:	40 01       	movw	r8, r0
    1d66:	f3 9e       	mul	r15, r19
    1d68:	90 0c       	add	r9, r0
    1d6a:	11 24       	eor	r1, r1
    1d6c:	3a e5       	ldi	r19, 0x5A	; 90
    1d6e:	83 16       	cp	r8, r19
    1d70:	91 04       	cpc	r9, r1
    1d72:	0c f0       	brlt	.+2      	; 0x1d76 <vMainSensorTowerTask+0x250>
    1d74:	ee ce       	rjmp	.-548    	; 0x1b52 <vMainSensorTowerTask+0x2c>
    1d76:	17 c0       	rjmp	.+46     	; 0x1da6 <vMainSensorTowerTask+0x280>
    1d78:	18 14       	cp	r1, r8
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1d7a:	19 04       	cpc	r1, r9
    1d7c:	44 f5       	brge	.+80     	; 0x1dce <vMainSensorTowerTask+0x2a8>
    1d7e:	83 e0       	ldi	r24, 0x03	; 3
    1d80:	28 12       	cpse	r2, r24
    1d82:	2a c0       	rjmp	.+84     	; 0x1dd8 <vMainSensorTowerTask+0x2b2>
    1d84:	89 81       	ldd	r24, Y+1	; 0x01
    1d86:	83 30       	cpi	r24, 0x03	; 3
    1d88:	08 f0       	brcs	.+2      	; 0x1d8c <vMainSensorTowerTask+0x266>
    1d8a:	f1 ce       	rjmp	.-542    	; 0x1b6e <vMainSensorTowerTask+0x48>
    1d8c:	fa 94       	dec	r15
                servoStep --;
    1d8e:	2a 89       	ldd	r18, Y+18	; 0x12
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1d90:	3b 89       	ldd	r19, Y+19	; 0x13
    1d92:	f2 9e       	mul	r15, r18
    1d94:	40 01       	movw	r8, r0
    1d96:	f3 9e       	mul	r15, r19
    1d98:	90 0c       	add	r9, r0
    1d9a:	11 24       	eor	r1, r1
    1d9c:	04 c0       	rjmp	.+8      	; 0x1da6 <vMainSensorTowerTask+0x280>
    1d9e:	34 e0       	ldi	r19, 0x04	; 4
    1da0:	23 16       	cp	r2, r19
    1da2:	09 f4       	brne	.+2      	; 0x1da6 <vMainSensorTowerTask+0x280>
    1da4:	db ce       	rjmp	.-586    	; 0x1b5c <vMainSensorTowerTask+0x36>
    1da6:	18 14       	cp	r1, r8
                rotationDirection = moveClockwise;
            }
            else if ((servoStep*servoResolution <= 0) && (rotationDirection == moveClockwise)){
    1da8:	19 04       	cpc	r1, r9
    1daa:	0c f4       	brge	.+2      	; 0x1dae <vMainSensorTowerTask+0x288>
    1dac:	e0 ce       	rjmp	.-576    	; 0x1b6e <vMainSensorTowerTask+0x48>
    1dae:	83 e0       	ldi	r24, 0x03	; 3
    1db0:	28 12       	cpse	r2, r24
    1db2:	dd ce       	rjmp	.-582    	; 0x1b6e <vMainSensorTowerTask+0x48>
    1db4:	23 2c       	mov	r2, r3
                rotationDirection = moveCounterClockwise;
    1db6:	db ce       	rjmp	.-586    	; 0x1b6e <vMainSensorTowerTask+0x48>
    1db8:	80 e0       	ldi	r24, 0x00	; 0
            }    
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
    1dba:	0e 94 de 21 	call	0x43bc	; 0x43bc <vServo_setAngle>
    1dbe:	84 e6       	ldi	r24, 0x64	; 100
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
            vTaskDelay(100/portTICK_PERIOD_MS);
    1dc0:	90 e0       	ldi	r25, 0x00	; 0
    1dc2:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <vTaskDelay>
    1dc6:	10 e0       	ldi	r17, 0x00	; 0
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
    1dc8:	f1 2c       	mov	r15, r1
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
    1dca:	23 2c       	mov	r2, r3
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1dcc:	d0 ce       	rjmp	.-608    	; 0x1b6e <vMainSensorTowerTask+0x48>
    1dce:	9a e5       	ldi	r25, 0x5A	; 90
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1dd0:	89 16       	cp	r8, r25
    1dd2:	91 04       	cpc	r9, r1
    1dd4:	64 f3       	brlt	.-40     	; 0x1dae <vMainSensorTowerTask+0x288>
    1dd6:	0a c0       	rjmp	.+20     	; 0x1dec <vMainSensorTowerTask+0x2c6>
    1dd8:	2a e5       	ldi	r18, 0x5A	; 90
    1dda:	82 16       	cp	r8, r18
    1ddc:	91 04       	cpc	r9, r1
    1dde:	0c f4       	brge	.+2      	; 0x1de2 <vMainSensorTowerTask+0x2bc>
    1de0:	c6 ce       	rjmp	.-628    	; 0x1b6e <vMainSensorTowerTask+0x48>
    1de2:	dd cf       	rjmp	.-70     	; 0x1d9e <vMainSensorTowerTask+0x278>
    1de4:	18 14       	cp	r1, r8
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1de6:	19 04       	cpc	r1, r9
    1de8:	bc f3       	brlt	.-18     	; 0x1dd8 <vMainSensorTowerTask+0x2b2>
    1dea:	f1 cf       	rjmp	.-30     	; 0x1dce <vMainSensorTowerTask+0x2a8>
    1dec:	34 e0       	ldi	r19, 0x04	; 4
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1dee:	23 16       	cp	r2, r19
    1df0:	09 f4       	brne	.+2      	; 0x1df4 <vMainSensorTowerTask+0x2ce>
    1df2:	b9 ce       	rjmp	.-654    	; 0x1b66 <vMainSensorTowerTask+0x40>
    1df4:	dc cf       	rjmp	.-72     	; 0x1dae <vMainSensorTowerTask+0x288>

00001df6 <vMainPoseControllerTask>:
    1df6:	cf 93       	push	r28
        }
    }// While end
}

/*  Calculates new settings for the movement task */
void vMainPoseControllerTask( void *pvParameters ){
    1df8:	df 93       	push	r29
    1dfa:	cd b7       	in	r28, 0x3d	; 61
    1dfc:	de b7       	in	r29, 0x3e	; 62
    1dfe:	c1 54       	subi	r28, 0x41	; 65
    1e00:	d1 09       	sbc	r29, r1
    1e02:	0f b6       	in	r0, 0x3f	; 63
    1e04:	f8 94       	cli
    1e06:	de bf       	out	0x3e, r29	; 62
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	cd bf       	out	0x3d, r28	; 61
    #ifdef DEBUG
        printf("PoseController OK\n");
        uint8_t tellar = 0;
    #endif
    /* Task init */    
    struct sCartesian Setpoint = {0,0}; // Updates from server
    1e0c:	19 82       	std	Y+1, r1	; 0x01
    1e0e:	1a 82       	std	Y+2, r1	; 0x02
    1e10:	1b 82       	std	Y+3, r1	; 0x03
    1e12:	1c 82       	std	Y+4, r1	; 0x04
    1e14:	1d 82       	std	Y+5, r1	; 0x05
    1e16:	1e 82       	std	Y+6, r1	; 0x06
    1e18:	1f 82       	std	Y+7, r1	; 0x07
    1e1a:	18 86       	std	Y+8, r1	; 0x08
    struct sCartesian Error = {0,0}; // Error values
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
	float radiusEpsilon = 15; //[mm]The acceptable radius from goal for completion
	uint8_t lastMovement = 0;
    1e1c:	19 86       	std	Y+9, r1	; 0x09
	int16_t xhat = 0;
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
    1e1e:	1a 86       	std	Y+10, r1	; 0x0a
    1e20:	1b 86       	std	Y+11, r1	; 0x0b
    1e22:	1c 86       	std	Y+12, r1	; 0x0c
    1e24:	1d 86       	std	Y+13, r1	; 0x0d
	float leftIntError = 0;
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
	
	int16_t leftWheelTicks = 0;
    1e26:	1f 86       	std	Y+15, r1	; 0x0f
    1e28:	1e 86       	std	Y+14, r1	; 0x0e
	int16_t rightWheelTicks = 0;
    1e2a:	19 8a       	std	Y+17, r1	; 0x11
    1e2c:	18 8a       	std	Y+16, r1	; 0x10
	
	uint8_t leftEncoderVal = 0;
	uint8_t rightEncoderVal = 0;
	
	uint8_t gLeftWheelDirection = 0;
    1e2e:	1a 8a       	std	Y+18, r1	; 0x12
	uint8_t gRightWheelDirection = 0;
    1e30:	1b 8a       	std	Y+19, r1	; 0x13
	uint8_t idleSendt = FALSE;
	
	/* TESTING VARIABLES */
	float distanceStart = 0;
	float thetaOldDiff = 0;
	float StartDiff = 0;
    1e32:	1c 8a       	std	Y+20, r1	; 0x14
    1e34:	1d 8a       	std	Y+21, r1	; 0x15
    1e36:	1e 8a       	std	Y+22, r1	; 0x16
    1e38:	1f 8a       	std	Y+23, r1	; 0x17
	float thetahatStart = 0;
	float xhatStart = 0;
	float yhatStart = 0;
    1e3a:	1a ae       	std	Y+58, r1	; 0x3a
    1e3c:	1b ae       	std	Y+59, r1	; 0x3b
    1e3e:	1c ae       	std	Y+60, r1	; 0x3c
    1e40:	1d ae       	std	Y+61, r1	; 0x3d
	/* TESTING VARIABLES */
	float distanceStart = 0;
	float thetaOldDiff = 0;
	float StartDiff = 0;
	float thetahatStart = 0;
	float xhatStart = 0;
    1e42:	1e aa       	std	Y+54, r1	; 0x36
    1e44:	1f aa       	std	Y+55, r1	; 0x37
    1e46:	18 ae       	std	Y+56, r1	; 0x38
    1e48:	19 ae       	std	Y+57, r1	; 0x39
	
	/* TESTING VARIABLES */
	float distanceStart = 0;
	float thetaOldDiff = 0;
	float StartDiff = 0;
	float thetahatStart = 0;
    1e4a:	1e ae       	std	Y+62, r1	; 0x3e
    1e4c:	1f ae       	std	Y+63, r1	; 0x3f
    1e4e:	21 96       	adiw	r28, 0x01	; 1
    1e50:	1f ae       	std	Y+63, r1	; 0x3f
    1e52:	21 97       	sbiw	r28, 0x01	; 1
    1e54:	22 96       	adiw	r28, 0x02	; 2
    1e56:	1f ae       	std	Y+63, r1	; 0x3f
    1e58:	22 97       	sbiw	r28, 0x02	; 2
	uint8_t rightEncoderVal = 0;
	
	uint8_t gLeftWheelDirection = 0;
	uint8_t gRightWheelDirection = 0;
	
	uint8_t idleSendt = FALSE;
    1e5a:	1d a6       	std	Y+45, r1	; 0x2d
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
    1e5c:	21 e0       	ldi	r18, 0x01	; 1
    1e5e:	2c a7       	std	Y+44, r18	; 0x2c
	float thetaTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
    1e60:	1a aa       	std	Y+50, r1	; 0x32
    1e62:	1b aa       	std	Y+51, r1	; 0x33
    1e64:	1c aa       	std	Y+52, r1	; 0x34
    1e66:	1d aa       	std	Y+53, r1	; 0x35
	float ydiff = 0;
	float thetaTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
    1e68:	1e a6       	std	Y+46, r1	; 0x2e
    1e6a:	1f a6       	std	Y+47, r1	; 0x2f
    1e6c:	18 aa       	std	Y+48, r1	; 0x30
    1e6e:	19 aa       	std	Y+49, r1	; 0x31
	float xTargt = 0;
	float yTargt = 0;
	
	float xdiff = 0;
	float ydiff = 0;
	float thetaTargt = 0;
    1e70:	18 a2       	std	Y+32, r1	; 0x20
    1e72:	19 a2       	std	Y+33, r1	; 0x21
    1e74:	1a a2       	std	Y+34, r1	; 0x22
    1e76:	1b a2       	std	Y+35, r1	; 0x23
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
	float yTargt = 0;
    1e78:	18 a6       	std	Y+40, r1	; 0x28
    1e7a:	19 a6       	std	Y+41, r1	; 0x29
    1e7c:	1a a6       	std	Y+42, r1	; 0x2a
    1e7e:	1b a6       	std	Y+43, r1	; 0x2b
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
    1e80:	1c a2       	std	Y+36, r1	; 0x24
    1e82:	1d a2       	std	Y+37, r1	; 0x25
    1e84:	1e a2       	std	Y+38, r1	; 0x26
    1e86:	1f a2       	std	Y+39, r1	; 0x27
	
	uint8_t bBaseActuationFound = FALSE;
      
	while(1){
		// Checking if server is ready
		if (gHandshook){
    1e88:	80 91 de 19 	lds	r24, 0x19DE	; 0x8019de <gHandshook>
    1e8c:	88 23       	and	r24, r24
    1e8e:	e1 f3       	breq	.-8      	; 0x1e88 <vMainPoseControllerTask+0x92>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1e90:	f8 94       	cli
		
			ATOMIC_BLOCK(ATOMIC_FORCEON){
				leftEncoderVal = gISR_leftWheelTicks;
    1e92:	40 91 df 19 	lds	r20, 0x19DF	; 0x8019df <gISR_leftWheelTicks>
				gISR_leftWheelTicks = 0;
    1e96:	10 92 df 19 	sts	0x19DF, r1	; 0x8019df <gISR_leftWheelTicks>
				rightEncoderVal = gISR_rightWheelTicks;
    1e9a:	10 91 e0 19 	lds	r17, 0x19E0	; 0x8019e0 <gISR_rightWheelTicks>
				gISR_rightWheelTicks = 0;
    1e9e:	10 92 e0 19 	sts	0x19E0, r1	; 0x8019e0 <gISR_rightWheelTicks>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1ea2:	78 94       	sei
			}

			vMotorEncoderLeftTickFromISR(gLeftWheelDirection, &leftWheelTicks, leftEncoderVal);
    1ea4:	be 01       	movw	r22, r28
    1ea6:	62 5f       	subi	r22, 0xF2	; 242
    1ea8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eaa:	8a 89       	ldd	r24, Y+18	; 0x12
    1eac:	bc d7       	rcall	.+3960   	; 0x2e26 <vMotorEncoderLeftTickFromISR>
			vMotorEncoderRightTickFromISR(gRightWheelDirection, &rightWheelTicks, rightEncoderVal);
    1eae:	41 2f       	mov	r20, r17
    1eb0:	be 01       	movw	r22, r28
    1eb2:	60 5f       	subi	r22, 0xF0	; 240
    1eb4:	7f 4f       	sbci	r23, 0xFF	; 255
    1eb6:	8b 89       	ldd	r24, Y+19	; 0x13
    1eb8:	cb d7       	rcall	.+3990   	; 0x2e50 <vMotorEncoderRightTickFromISR>
			
			xSemaphoreTake(xTickMutex,1 / portTICK_PERIOD_MS);
    1eba:	20 e0       	ldi	r18, 0x00	; 0
    1ebc:	41 e0       	ldi	r20, 0x01	; 1
    1ebe:	50 e0       	ldi	r21, 0x00	; 0
    1ec0:	60 e0       	ldi	r22, 0x00	; 0
    1ec2:	70 e0       	ldi	r23, 0x00	; 0
    1ec4:	80 91 49 1b 	lds	r24, 0x1B49	; 0x801b49 <xTickMutex>
    1ec8:	90 91 4a 1b 	lds	r25, 0x1B4A	; 0x801b4a <xTickMutex+0x1>
    1ecc:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
			gLeftWheelTicks = leftWheelTicks;
    1ed0:	8e 85       	ldd	r24, Y+14	; 0x0e
    1ed2:	9f 85       	ldd	r25, Y+15	; 0x0f
    1ed4:	90 93 d2 19 	sts	0x19D2, r25	; 0x8019d2 <gLeftWheelTicks+0x1>
    1ed8:	80 93 d1 19 	sts	0x19D1, r24	; 0x8019d1 <gLeftWheelTicks>
			gRightWheelTicks = rightWheelTicks;
    1edc:	88 89       	ldd	r24, Y+16	; 0x10
    1ede:	99 89       	ldd	r25, Y+17	; 0x11
    1ee0:	90 93 d4 19 	sts	0x19D4, r25	; 0x8019d4 <gRightWheelTicks+0x1>
    1ee4:	80 93 d3 19 	sts	0x19D3, r24	; 0x8019d3 <gRightWheelTicks>
			xSemaphoreGive(xTickMutex);
    1ee8:	60 e0       	ldi	r22, 0x00	; 0
    1eea:	70 e0       	ldi	r23, 0x00	; 0
    1eec:	80 91 49 1b 	lds	r24, 0x1B49	; 0x801b49 <xTickMutex>
    1ef0:	90 91 4a 1b 	lds	r25, 0x1B4A	; 0x801b4a <xTickMutex+0x1>
    1ef4:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
	
			if (xSemaphoreTake(xControllerBSem, portMAX_DELAY) == pdTRUE){    // Wait for synchronization from estimator
    1ef8:	20 e0       	ldi	r18, 0x00	; 0
    1efa:	4f ef       	ldi	r20, 0xFF	; 255
    1efc:	5f ef       	ldi	r21, 0xFF	; 255
    1efe:	60 e0       	ldi	r22, 0x00	; 0
    1f00:	70 e0       	ldi	r23, 0x00	; 0
    1f02:	80 91 47 1b 	lds	r24, 0x1B47	; 0x801b47 <xControllerBSem>
    1f06:	90 91 48 1b 	lds	r25, 0x1B48	; 0x801b48 <xControllerBSem+0x1>
    1f0a:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
    1f0e:	81 30       	cpi	r24, 0x01	; 1
    1f10:	09 f0       	breq	.+2      	; 0x1f14 <vMainPoseControllerTask+0x11e>
    1f12:	ba cf       	rjmp	.-140    	; 0x1e88 <vMainPoseControllerTask+0x92>
				// Get robot pose
				xSemaphoreTake(xPoseMutex,portMAX_DELAY);
    1f14:	20 e0       	ldi	r18, 0x00	; 0
    1f16:	4f ef       	ldi	r20, 0xFF	; 255
    1f18:	5f ef       	ldi	r21, 0xFF	; 255
    1f1a:	60 e0       	ldi	r22, 0x00	; 0
    1f1c:	70 e0       	ldi	r23, 0x00	; 0
    1f1e:	80 91 4f 1b 	lds	r24, 0x1B4F	; 0x801b4f <xPoseMutex>
    1f22:	90 91 50 1b 	lds	r25, 0x1B50	; 0x801b50 <xPoseMutex+0x1>
    1f26:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
					thetahat = gTheta_hat;
    1f2a:	30 90 d9 19 	lds	r3, 0x19D9	; 0x8019d9 <gTheta_hat>
    1f2e:	20 90 da 19 	lds	r2, 0x19DA	; 0x8019da <gTheta_hat+0x1>
    1f32:	40 90 db 19 	lds	r4, 0x19DB	; 0x8019db <gTheta_hat+0x2>
    1f36:	50 90 dc 19 	lds	r5, 0x19DC	; 0x8019dc <gTheta_hat+0x3>
					xhat = gX_hat;
    1f3a:	e0 90 d7 19 	lds	r14, 0x19D7	; 0x8019d7 <gX_hat>
    1f3e:	f0 90 d8 19 	lds	r15, 0x19D8	; 0x8019d8 <gX_hat+0x1>
					yhat = gY_hat;
    1f42:	00 91 d5 19 	lds	r16, 0x19D5	; 0x8019d5 <gY_hat>
    1f46:	10 91 d6 19 	lds	r17, 0x19D6	; 0x8019d6 <gY_hat+0x1>
				xSemaphoreGive(xPoseMutex);
    1f4a:	60 e0       	ldi	r22, 0x00	; 0
    1f4c:	70 e0       	ldi	r23, 0x00	; 0
    1f4e:	80 91 4f 1b 	lds	r24, 0x1B4F	; 0x801b4f <xPoseMutex>
    1f52:	90 91 50 1b 	lds	r25, 0x1B50	; 0x801b50 <xPoseMutex+0x1>
    1f56:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
				
				// Check if a new update is received
				if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
    1f5a:	20 e0       	ldi	r18, 0x00	; 0
    1f5c:	40 e0       	ldi	r20, 0x00	; 0
    1f5e:	50 e0       	ldi	r21, 0x00	; 0
    1f60:	be 01       	movw	r22, r28
    1f62:	6f 5f       	subi	r22, 0xFF	; 255
    1f64:	7f 4f       	sbci	r23, 0xFF	; 255
    1f66:	80 91 e5 19 	lds	r24, 0x19E5	; 0x8019e5 <poseControllerQ>
    1f6a:	90 91 e6 19 	lds	r25, 0x19E6	; 0x8019e6 <poseControllerQ+0x1>
    1f6e:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
    1f72:	81 30       	cpi	r24, 0x01	; 1
    1f74:	09 f0       	breq	.+2      	; 0x1f78 <vMainPoseControllerTask+0x182>
    1f76:	63 c0       	rjmp	.+198    	; 0x203e <vMainPoseControllerTask+0x248>
					//xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
					xTargt = Setpoint.x*10;	//Distance is received in cm, convert to mm for continuity
    1f78:	20 e0       	ldi	r18, 0x00	; 0
    1f7a:	30 e0       	ldi	r19, 0x00	; 0
    1f7c:	40 e2       	ldi	r20, 0x20	; 32
    1f7e:	51 e4       	ldi	r21, 0x41	; 65
    1f80:	69 81       	ldd	r22, Y+1	; 0x01
    1f82:	7a 81       	ldd	r23, Y+2	; 0x02
    1f84:	8b 81       	ldd	r24, Y+3	; 0x03
    1f86:	9c 81       	ldd	r25, Y+4	; 0x04
    1f88:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    1f8c:	66 2e       	mov	r6, r22
    1f8e:	77 2e       	mov	r7, r23
    1f90:	88 2e       	mov	r8, r24
    1f92:	99 2e       	mov	r9, r25
    1f94:	6c a3       	std	Y+36, r22	; 0x24
    1f96:	7d a3       	std	Y+37, r23	; 0x25
    1f98:	8e a3       	std	Y+38, r24	; 0x26
    1f9a:	9f a3       	std	Y+39, r25	; 0x27
					yTargt = Setpoint.y*10;	//Distance is received in cm, convert to mm for continuity
    1f9c:	20 e0       	ldi	r18, 0x00	; 0
    1f9e:	30 e0       	ldi	r19, 0x00	; 0
    1fa0:	40 e2       	ldi	r20, 0x20	; 32
    1fa2:	51 e4       	ldi	r21, 0x41	; 65
    1fa4:	6d 81       	ldd	r22, Y+5	; 0x05
    1fa6:	7e 81       	ldd	r23, Y+6	; 0x06
    1fa8:	8f 81       	ldd	r24, Y+7	; 0x07
    1faa:	98 85       	ldd	r25, Y+8	; 0x08
    1fac:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    1fb0:	d6 2e       	mov	r13, r22
    1fb2:	c7 2e       	mov	r12, r23
    1fb4:	b8 2e       	mov	r11, r24
    1fb6:	a9 2e       	mov	r10, r25
    1fb8:	68 a7       	std	Y+40, r22	; 0x28
    1fba:	79 a7       	std	Y+41, r23	; 0x29
    1fbc:	8a a7       	std	Y+42, r24	; 0x2a
    1fbe:	9b a7       	std	Y+43, r25	; 0x2b
					thetahatStart = thetahat;
					xhatStart = xhat;
    1fc0:	b7 01       	movw	r22, r14
    1fc2:	0f 2c       	mov	r0, r15
    1fc4:	00 0c       	add	r0, r0
    1fc6:	88 0b       	sbc	r24, r24
    1fc8:	99 0b       	sbc	r25, r25
    1fca:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    1fce:	6e ab       	std	Y+54, r22	; 0x36
    1fd0:	7f ab       	std	Y+55, r23	; 0x37
    1fd2:	88 af       	std	Y+56, r24	; 0x38
    1fd4:	99 af       	std	Y+57, r25	; 0x39
					yhatStart = yhat;
    1fd6:	b8 01       	movw	r22, r16
    1fd8:	01 2e       	mov	r0, r17
    1fda:	00 0c       	add	r0, r0
    1fdc:	88 0b       	sbc	r24, r24
    1fde:	99 0b       	sbc	r25, r25
    1fe0:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    1fe4:	6a af       	std	Y+58, r22	; 0x3a
    1fe6:	7b af       	std	Y+59, r23	; 0x3b
    1fe8:	8c af       	std	Y+60, r24	; 0x3c
    1fea:	9d af       	std	Y+61, r25	; 0x3d
					StartDiff = thetaTargt - thetahatStart;
    1fec:	23 2d       	mov	r18, r3
    1fee:	32 2d       	mov	r19, r2
    1ff0:	44 2d       	mov	r20, r4
    1ff2:	55 2d       	mov	r21, r5
    1ff4:	68 a1       	ldd	r22, Y+32	; 0x20
    1ff6:	79 a1       	ldd	r23, Y+33	; 0x21
    1ff8:	8a a1       	ldd	r24, Y+34	; 0x22
    1ffa:	9b a1       	ldd	r25, Y+35	; 0x23
    1ffc:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2000:	6c 8b       	std	Y+20, r22	; 0x14
    2002:	7d 8b       	std	Y+21, r23	; 0x15
    2004:	8e 8b       	std	Y+22, r24	; 0x16
    2006:	9f 8b       	std	Y+23, r25	; 0x17
					debug("xtargt,ytargt %f, %f", xTargt,yTargt);
    2008:	af 92       	push	r10
    200a:	bf 92       	push	r11
    200c:	cf 92       	push	r12
    200e:	df 92       	push	r13
    2010:	9f 92       	push	r9
    2012:	8f 92       	push	r8
    2014:	7f 92       	push	r7
    2016:	6f 92       	push	r6
    2018:	8e e1       	ldi	r24, 0x1E	; 30
    201a:	96 e0       	ldi	r25, 0x06	; 6
    201c:	9f 93       	push	r25
    201e:	8f 93       	push	r24
    2020:	0e 94 7d 21 	call	0x42fa	; 0x42fa <debug>
    2024:	0f b6       	in	r0, 0x3f	; 63
    2026:	f8 94       	cli
    2028:	de bf       	out	0x3e, r29	; 62
    202a:	0f be       	out	0x3f, r0	; 63
    202c:	cd bf       	out	0x3d, r28	; 61
				// Check if a new update is received
				if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
					//xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
					xTargt = Setpoint.x*10;	//Distance is received in cm, convert to mm for continuity
					yTargt = Setpoint.y*10;	//Distance is received in cm, convert to mm for continuity
					thetahatStart = thetahat;
    202e:	3e ae       	std	Y+62, r3	; 0x3e
    2030:	2f ae       	std	Y+63, r2	; 0x3f
    2032:	21 96       	adiw	r28, 0x01	; 1
    2034:	4f ae       	std	Y+63, r4	; 0x3f
    2036:	21 97       	sbiw	r28, 0x01	; 1
    2038:	22 96       	adiw	r28, 0x02	; 2
    203a:	5f ae       	std	Y+63, r5	; 0x3f
    203c:	22 97       	sbiw	r28, 0x02	; 2
					StartDiff = thetaTargt - thetahatStart;
					debug("xtargt,ytargt %f, %f", xTargt,yTargt);
					
				} 
				float temp_dist = distance;
				distance = (float)sqrt((xTargt-xhat)*(xTargt-xhat) + (yTargt-yhat)*(yTargt-yhat));
    203e:	b7 01       	movw	r22, r14
    2040:	ff 0c       	add	r15, r15
    2042:	88 0b       	sbc	r24, r24
    2044:	99 0b       	sbc	r25, r25
    2046:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    204a:	9b 01       	movw	r18, r22
    204c:	ac 01       	movw	r20, r24
    204e:	bc a1       	ldd	r27, Y+36	; 0x24
    2050:	ad a1       	ldd	r26, Y+37	; 0x25
    2052:	fe a1       	ldd	r31, Y+38	; 0x26
    2054:	ef a1       	ldd	r30, Y+39	; 0x27
    2056:	6b 2f       	mov	r22, r27
    2058:	7a 2f       	mov	r23, r26
    205a:	8f 2f       	mov	r24, r31
    205c:	9e 2f       	mov	r25, r30
    205e:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2062:	4b 01       	movw	r8, r22
    2064:	5c 01       	movw	r10, r24
    2066:	b8 01       	movw	r22, r16
    2068:	11 0f       	add	r17, r17
    206a:	88 0b       	sbc	r24, r24
    206c:	99 0b       	sbc	r25, r25
    206e:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    2072:	9b 01       	movw	r18, r22
    2074:	ac 01       	movw	r20, r24
    2076:	b8 a5       	ldd	r27, Y+40	; 0x28
    2078:	a9 a5       	ldd	r26, Y+41	; 0x29
    207a:	fa a5       	ldd	r31, Y+42	; 0x2a
    207c:	eb a5       	ldd	r30, Y+43	; 0x2b
    207e:	6b 2f       	mov	r22, r27
    2080:	7a 2f       	mov	r23, r26
    2082:	8f 2f       	mov	r24, r31
    2084:	9e 2f       	mov	r25, r30
    2086:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    208a:	6b 01       	movw	r12, r22
    208c:	7c 01       	movw	r14, r24
    208e:	a5 01       	movw	r20, r10
    2090:	94 01       	movw	r18, r8
    2092:	c5 01       	movw	r24, r10
    2094:	b4 01       	movw	r22, r8
    2096:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    209a:	68 8f       	std	Y+24, r22	; 0x18
    209c:	79 8f       	std	Y+25, r23	; 0x19
    209e:	8a 8f       	std	Y+26, r24	; 0x1a
    20a0:	9b 8f       	std	Y+27, r25	; 0x1b
    20a2:	a7 01       	movw	r20, r14
    20a4:	96 01       	movw	r18, r12
    20a6:	c7 01       	movw	r24, r14
    20a8:	b6 01       	movw	r22, r12
    20aa:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    20ae:	6c 8f       	std	Y+28, r22	; 0x1c
    20b0:	7d 8f       	std	Y+29, r23	; 0x1d
    20b2:	8e 8f       	std	Y+30, r24	; 0x1e
    20b4:	9f 8f       	std	Y+31, r25	; 0x1f
    20b6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    20b8:	3d 8d       	ldd	r19, Y+29	; 0x1d
    20ba:	4e 8d       	ldd	r20, Y+30	; 0x1e
    20bc:	5f 8d       	ldd	r21, Y+31	; 0x1f
    20be:	68 8d       	ldd	r22, Y+24	; 0x18
    20c0:	79 8d       	ldd	r23, Y+25	; 0x19
    20c2:	8a 8d       	ldd	r24, Y+26	; 0x1a
    20c4:	9b 8d       	ldd	r25, Y+27	; 0x1b
    20c6:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    20ca:	0e 94 5a 33 	call	0x66b4	; 0x66b4 <sqrt>
    20ce:	16 2f       	mov	r17, r22
    20d0:	07 2f       	mov	r16, r23
    20d2:	88 8f       	std	Y+24, r24	; 0x18
    20d4:	9c 8f       	std	Y+28, r25	; 0x1c
				
				xdiff = xTargt - xhat;
				ydiff = yTargt - yhat;
				thetaTargt = atan2(ydiff,xdiff); //atan() returns radians
    20d6:	a5 01       	movw	r20, r10
    20d8:	94 01       	movw	r18, r8
    20da:	c7 01       	movw	r24, r14
    20dc:	b6 01       	movw	r22, r12
    20de:	0e 94 df 30 	call	0x61be	; 0x61be <atan2>
    20e2:	68 a3       	std	Y+32, r22	; 0x20
    20e4:	79 a3       	std	Y+33, r23	; 0x21
    20e6:	8a a3       	std	Y+34, r24	; 0x22
    20e8:	9b a3       	std	Y+35, r25	; 0x23
				thetaOldDiff = thetaDiff;
    20ea:	ca 84       	ldd	r12, Y+10	; 0x0a
    20ec:	db 84       	ldd	r13, Y+11	; 0x0b
    20ee:	ec 84       	ldd	r14, Y+12	; 0x0c
    20f0:	fd 84       	ldd	r15, Y+13	; 0x0d
				thetaOldDiffChanged = TRUE;
				thetaDiff = thetaTargt-thetahat; //Might be outside pi to -pi degrees
    20f2:	23 2d       	mov	r18, r3
    20f4:	32 2d       	mov	r19, r2
    20f6:	44 2d       	mov	r20, r4
    20f8:	55 2d       	mov	r21, r5
    20fa:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    20fe:	2b 01       	movw	r4, r22
    2100:	3c 01       	movw	r6, r24
    2102:	6a 87       	std	Y+10, r22	; 0x0a
    2104:	7b 87       	std	Y+11, r23	; 0x0b
    2106:	8c 87       	std	Y+12, r24	; 0x0c
    2108:	9d 87       	std	Y+13, r25	; 0x0d
				vFunc_Inf2pi(&thetaDiff);
    210a:	ce 01       	movw	r24, r28
    210c:	0a 96       	adiw	r24, 0x0a	; 10
    210e:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
				if ((thetaOldDiff-thetaDiff)>(M_PI/2) || ((thetaOldDiff-thetaDiff)<(-M_PI/2)))
    2112:	2a 85       	ldd	r18, Y+10	; 0x0a
    2114:	3b 85       	ldd	r19, Y+11	; 0x0b
    2116:	4c 85       	ldd	r20, Y+12	; 0x0c
    2118:	5d 85       	ldd	r21, Y+13	; 0x0d
    211a:	c7 01       	movw	r24, r14
    211c:	b6 01       	movw	r22, r12
    211e:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2122:	4b 01       	movw	r8, r22
    2124:	5c 01       	movw	r10, r24
    2126:	2b ed       	ldi	r18, 0xDB	; 219
    2128:	3f e0       	ldi	r19, 0x0F	; 15
    212a:	49 ec       	ldi	r20, 0xC9	; 201
    212c:	5f e3       	ldi	r21, 0x3F	; 63
    212e:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    2132:	18 16       	cp	r1, r24
    2134:	54 f0       	brlt	.+20     	; 0x214a <vMainPoseControllerTask+0x354>
    2136:	2b ed       	ldi	r18, 0xDB	; 219
    2138:	3f e0       	ldi	r19, 0x0F	; 15
    213a:	49 ec       	ldi	r20, 0xC9	; 201
    213c:	5f eb       	ldi	r21, 0xBF	; 191
    213e:	c5 01       	movw	r24, r10
    2140:	b4 01       	movw	r22, r8
    2142:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    2146:	88 23       	and	r24, r24
    2148:	2c f4       	brge	.+10     	; 0x2154 <vMainPoseControllerTask+0x35e>
				{
					StartDiff = thetaTargt-thetahat;
    214a:	4c 8a       	std	Y+20, r4	; 0x14
    214c:	5d 8a       	std	Y+21, r5	; 0x15
    214e:	6e 8a       	std	Y+22, r6	; 0x16
    2150:	7f 8a       	std	Y+23, r7	; 0x17
    2152:	12 c0       	rjmp	.+36     	; 0x2178 <vMainPoseControllerTask+0x382>
					} else {
					StartDiff = thetaTargt - thetahatStart;
    2154:	2e ad       	ldd	r18, Y+62	; 0x3e
    2156:	3f ad       	ldd	r19, Y+63	; 0x3f
    2158:	21 96       	adiw	r28, 0x01	; 1
    215a:	4f ad       	ldd	r20, Y+63	; 0x3f
    215c:	21 97       	sbiw	r28, 0x01	; 1
    215e:	22 96       	adiw	r28, 0x02	; 2
    2160:	5f ad       	ldd	r21, Y+63	; 0x3f
    2162:	22 97       	sbiw	r28, 0x02	; 2
    2164:	68 a1       	ldd	r22, Y+32	; 0x20
    2166:	79 a1       	ldd	r23, Y+33	; 0x21
    2168:	8a a1       	ldd	r24, Y+34	; 0x22
    216a:	9b a1       	ldd	r25, Y+35	; 0x23
    216c:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2170:	6c 8b       	std	Y+20, r22	; 0x14
    2172:	7d 8b       	std	Y+21, r23	; 0x15
    2174:	8e 8b       	std	Y+22, r24	; 0x16
    2176:	9f 8b       	std	Y+23, r25	; 0x17
				}
				
				vFunc_Inf2pi(&StartDiff);
    2178:	ce 01       	movw	r24, r28
    217a:	44 96       	adiw	r24, 0x14	; 20
    217c:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
				StartDiff = fabs(StartDiff);
    2180:	8c 89       	ldd	r24, Y+20	; 0x14
    2182:	9d 89       	ldd	r25, Y+21	; 0x15
    2184:	ae 89       	ldd	r26, Y+22	; 0x16
    2186:	bf 89       	ldd	r27, Y+23	; 0x17
    2188:	bf 77       	andi	r27, 0x7F	; 127
    218a:	8c 8b       	std	Y+20, r24	; 0x14
    218c:	9d 8b       	std	Y+21, r25	; 0x15
    218e:	ae 8b       	std	Y+22, r26	; 0x16
    2190:	bf 8b       	std	Y+23, r27	; 0x17
				
				
				//Hysteresis mechanics
				if (fabs(thetaDiff) > rotateThreshold){
    2192:	4a 84       	ldd	r4, Y+10	; 0x0a
    2194:	5b 84       	ldd	r5, Y+11	; 0x0b
    2196:	6c 84       	ldd	r6, Y+12	; 0x0c
    2198:	7d 84       	ldd	r7, Y+13	; 0x0d
    219a:	53 01       	movw	r10, r6
    219c:	42 01       	movw	r8, r4
    219e:	e8 94       	clt
    21a0:	b7 f8       	bld	r11, 7
    21a2:	29 e1       	ldi	r18, 0x19	; 25
    21a4:	34 e0       	ldi	r19, 0x04	; 4
    21a6:	46 e0       	ldi	r20, 0x06	; 6
    21a8:	5f e3       	ldi	r21, 0x3F	; 63
    21aa:	c5 01       	movw	r24, r10
    21ac:	b4 01       	movw	r22, r8
    21ae:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    21b2:	18 16       	cp	r1, r24
    21b4:	6c f0       	brlt	.+26     	; 0x21d0 <vMainPoseControllerTask+0x3da>
					doneTurning = FALSE;
					
				}else if (fabs(thetaDiff) < driveThreshold){
    21b6:	22 e7       	ldi	r18, 0x72	; 114
    21b8:	3a e8       	ldi	r19, 0x8A	; 138
    21ba:	4e e8       	ldi	r20, 0x8E	; 142
    21bc:	5c e3       	ldi	r21, 0x3C	; 60
    21be:	c5 01       	movw	r24, r10
    21c0:	b4 01       	movw	r22, r8
    21c2:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    21c6:	88 23       	and	r24, r24
    21c8:	24 f4       	brge	.+8      	; 0x21d2 <vMainPoseControllerTask+0x3dc>
					doneTurning = TRUE;
    21ca:	91 e0       	ldi	r25, 0x01	; 1
    21cc:	9c a7       	std	Y+44, r25	; 0x2c
    21ce:	01 c0       	rjmp	.+2      	; 0x21d2 <vMainPoseControllerTask+0x3dc>
				StartDiff = fabs(StartDiff);
				
				
				//Hysteresis mechanics
				if (fabs(thetaDiff) > rotateThreshold){
					doneTurning = FALSE;
    21d0:	1c a6       	std	Y+44, r1	; 0x2c
					}
				*/
				
				if (thetaOldDiffChanged)
				{
					if ((thetaOldDiff-thetaDiff)>(M_PI/2) || ((thetaOldDiff-thetaDiff)<(-M_PI/2))){
    21d2:	a3 01       	movw	r20, r6
    21d4:	92 01       	movw	r18, r4
    21d6:	c7 01       	movw	r24, r14
    21d8:	b6 01       	movw	r22, r12
    21da:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    21de:	6b 01       	movw	r12, r22
    21e0:	7c 01       	movw	r14, r24
    21e2:	2b ed       	ldi	r18, 0xDB	; 219
    21e4:	3f e0       	ldi	r19, 0x0F	; 15
    21e6:	49 ec       	ldi	r20, 0xC9	; 201
    21e8:	5f e3       	ldi	r21, 0x3F	; 63
    21ea:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    21ee:	18 16       	cp	r1, r24
    21f0:	0c f4       	brge	.+2      	; 0x21f4 <vMainPoseControllerTask+0x3fe>
    21f2:	46 c0       	rjmp	.+140    	; 0x2280 <__stack+0x81>
    21f4:	2b ed       	ldi	r18, 0xDB	; 219
    21f6:	3f e0       	ldi	r19, 0x0F	; 15
    21f8:	49 ec       	ldi	r20, 0xC9	; 201
    21fa:	5f eb       	ldi	r21, 0xBF	; 191
    21fc:	c7 01       	movw	r24, r14
    21fe:	b6 01       	movw	r22, r12
    2200:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    2204:	88 23       	and	r24, r24
    2206:	0c f4       	brge	.+2      	; 0x220a <__stack+0xb>
    2208:	40 c0       	rjmp	.+128    	; 0x228a <__stack+0x8b>
						distanceStart = distance;
					} else {
						distanceStart = (float)sqrt((xTargt-xhatStart)*(xTargt-xhatStart) + (yTargt-yhatStart)*(yTargt-yhatStart));
    220a:	2e a9       	ldd	r18, Y+54	; 0x36
    220c:	3f a9       	ldd	r19, Y+55	; 0x37
    220e:	48 ad       	ldd	r20, Y+56	; 0x38
    2210:	59 ad       	ldd	r21, Y+57	; 0x39
    2212:	bc a1       	ldd	r27, Y+36	; 0x24
    2214:	ad a1       	ldd	r26, Y+37	; 0x25
    2216:	fe a1       	ldd	r31, Y+38	; 0x26
    2218:	ef a1       	ldd	r30, Y+39	; 0x27
    221a:	6b 2f       	mov	r22, r27
    221c:	7a 2f       	mov	r23, r26
    221e:	8f 2f       	mov	r24, r31
    2220:	9e 2f       	mov	r25, r30
    2222:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2226:	2b 01       	movw	r4, r22
    2228:	3c 01       	movw	r6, r24
    222a:	2a ad       	ldd	r18, Y+58	; 0x3a
    222c:	3b ad       	ldd	r19, Y+59	; 0x3b
    222e:	4c ad       	ldd	r20, Y+60	; 0x3c
    2230:	5d ad       	ldd	r21, Y+61	; 0x3d
    2232:	b8 a5       	ldd	r27, Y+40	; 0x28
    2234:	a9 a5       	ldd	r26, Y+41	; 0x29
    2236:	fa a5       	ldd	r31, Y+42	; 0x2a
    2238:	eb a5       	ldd	r30, Y+43	; 0x2b
    223a:	6b 2f       	mov	r22, r27
    223c:	7a 2f       	mov	r23, r26
    223e:	8f 2f       	mov	r24, r31
    2240:	9e 2f       	mov	r25, r30
    2242:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2246:	6b 01       	movw	r12, r22
    2248:	7c 01       	movw	r14, r24
    224a:	a3 01       	movw	r20, r6
    224c:	92 01       	movw	r18, r4
    224e:	c3 01       	movw	r24, r6
    2250:	b2 01       	movw	r22, r4
    2252:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2256:	2b 01       	movw	r4, r22
    2258:	3c 01       	movw	r6, r24
    225a:	a7 01       	movw	r20, r14
    225c:	96 01       	movw	r18, r12
    225e:	c7 01       	movw	r24, r14
    2260:	b6 01       	movw	r22, r12
    2262:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2266:	9b 01       	movw	r18, r22
    2268:	ac 01       	movw	r20, r24
    226a:	c3 01       	movw	r24, r6
    226c:	b2 01       	movw	r22, r4
    226e:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    2272:	0e 94 5a 33 	call	0x66b4	; 0x66b4 <sqrt>
    2276:	96 2e       	mov	r9, r22
    2278:	87 2e       	mov	r8, r23
    227a:	78 2e       	mov	r7, r24
    227c:	69 2e       	mov	r6, r25
    227e:	09 c0       	rjmp	.+18     	; 0x2292 <__stack+0x93>
				*/
				
				if (thetaOldDiffChanged)
				{
					if ((thetaOldDiff-thetaDiff)>(M_PI/2) || ((thetaOldDiff-thetaDiff)<(-M_PI/2))){
						distanceStart = distance;
    2280:	91 2e       	mov	r9, r17
    2282:	80 2e       	mov	r8, r16
    2284:	78 8c       	ldd	r7, Y+24	; 0x18
    2286:	6c 8c       	ldd	r6, Y+28	; 0x1c
    2288:	04 c0       	rjmp	.+8      	; 0x2292 <__stack+0x93>
    228a:	91 2e       	mov	r9, r17
    228c:	80 2e       	mov	r8, r16
    228e:	78 8c       	ldd	r7, Y+24	; 0x18
    2290:	6c 8c       	ldd	r6, Y+28	; 0x1c
				}
				
				float shortDistIncRatio = 1.0;
				float distdiff = distanceStart-distance;
				speedIncreaseThreshold = 100;
				if(distanceStart > 0 && distanceStart < (2*speedIncreaseThreshold)){
    2292:	20 e0       	ldi	r18, 0x00	; 0
    2294:	30 e0       	ldi	r19, 0x00	; 0
    2296:	a9 01       	movw	r20, r18
    2298:	69 2d       	mov	r22, r9
    229a:	78 2d       	mov	r23, r8
    229c:	87 2d       	mov	r24, r7
    229e:	96 2d       	mov	r25, r6
    22a0:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    22a4:	18 16       	cp	r1, r24
    22a6:	1c f5       	brge	.+70     	; 0x22ee <__stack+0xef>
    22a8:	20 e0       	ldi	r18, 0x00	; 0
    22aa:	30 e0       	ldi	r19, 0x00	; 0
    22ac:	48 e4       	ldi	r20, 0x48	; 72
    22ae:	53 e4       	ldi	r21, 0x43	; 67
    22b0:	69 2d       	mov	r22, r9
    22b2:	78 2d       	mov	r23, r8
    22b4:	87 2d       	mov	r24, r7
    22b6:	96 2d       	mov	r25, r6
    22b8:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    22bc:	88 23       	and	r24, r24
    22be:	4c f5       	brge	.+82     	; 0x2312 <__stack+0x113>
					float temp = speedIncreaseThreshold;
					speedIncreaseThreshold = distanceStart/2;
    22c0:	20 e0       	ldi	r18, 0x00	; 0
    22c2:	30 e0       	ldi	r19, 0x00	; 0
    22c4:	40 e0       	ldi	r20, 0x00	; 0
    22c6:	5f e3       	ldi	r21, 0x3F	; 63
    22c8:	69 2d       	mov	r22, r9
    22ca:	78 2d       	mov	r23, r8
    22cc:	87 2d       	mov	r24, r7
    22ce:	96 2d       	mov	r25, r6
    22d0:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    22d4:	6b 01       	movw	r12, r22
    22d6:	7c 01       	movw	r14, r24
					shortDistIncRatio = speedIncreaseThreshold/temp;
    22d8:	20 e0       	ldi	r18, 0x00	; 0
    22da:	30 e0       	ldi	r19, 0x00	; 0
    22dc:	48 ec       	ldi	r20, 0xC8	; 200
    22de:	52 e4       	ldi	r21, 0x42	; 66
    22e0:	0e 94 39 31 	call	0x6272	; 0x6272 <__divsf3>
    22e4:	36 2e       	mov	r3, r22
    22e6:	27 2e       	mov	r2, r23
    22e8:	a8 2e       	mov	r10, r24
    22ea:	b9 2e       	mov	r11, r25
    22ec:	23 c0       	rjmp	.+70     	; 0x2334 <__stack+0x135>
					}
				} else {
					distanceStart = distance;
				}
				
				float shortDistIncRatio = 1.0;
    22ee:	31 2c       	mov	r3, r1
    22f0:	21 2c       	mov	r2, r1
    22f2:	68 94       	set
    22f4:	aa 24       	eor	r10, r10
    22f6:	a7 f8       	bld	r10, 7
    22f8:	0f 2e       	mov	r0, r31
    22fa:	ff e3       	ldi	r31, 0x3F	; 63
    22fc:	bf 2e       	mov	r11, r31
    22fe:	f0 2d       	mov	r31, r0
				float distdiff = distanceStart-distance;
				speedIncreaseThreshold = 100;
    2300:	0f 2e       	mov	r0, r31
    2302:	c1 2c       	mov	r12, r1
    2304:	d1 2c       	mov	r13, r1
    2306:	f8 ec       	ldi	r31, 0xC8	; 200
    2308:	ef 2e       	mov	r14, r31
    230a:	f2 e4       	ldi	r31, 0x42	; 66
    230c:	ff 2e       	mov	r15, r31
    230e:	f0 2d       	mov	r31, r0
    2310:	11 c0       	rjmp	.+34     	; 0x2334 <__stack+0x135>
					}
				} else {
					distanceStart = distance;
				}
				
				float shortDistIncRatio = 1.0;
    2312:	31 2c       	mov	r3, r1
    2314:	21 2c       	mov	r2, r1
    2316:	68 94       	set
    2318:	aa 24       	eor	r10, r10
    231a:	a7 f8       	bld	r10, 7
    231c:	0f 2e       	mov	r0, r31
    231e:	ff e3       	ldi	r31, 0x3F	; 63
    2320:	bf 2e       	mov	r11, r31
    2322:	f0 2d       	mov	r31, r0
				float distdiff = distanceStart-distance;
				speedIncreaseThreshold = 100;
    2324:	0f 2e       	mov	r0, r31
    2326:	c1 2c       	mov	r12, r1
    2328:	d1 2c       	mov	r13, r1
    232a:	f8 ec       	ldi	r31, 0xC8	; 200
    232c:	ef 2e       	mov	r14, r31
    232e:	f2 e4       	ldi	r31, 0x42	; 66
    2330:	ff 2e       	mov	r15, r31
    2332:	f0 2d       	mov	r31, r0
					shortDistIncRatio = speedIncreaseThreshold/temp;
				}
				
				
				
				if(distance > radiusEpsilon){//Not close enough to target
    2334:	20 e0       	ldi	r18, 0x00	; 0
    2336:	30 e0       	ldi	r19, 0x00	; 0
    2338:	40 e7       	ldi	r20, 0x70	; 112
    233a:	51 e4       	ldi	r21, 0x41	; 65
    233c:	61 2f       	mov	r22, r17
    233e:	70 2f       	mov	r23, r16
    2340:	88 8d       	ldd	r24, Y+24	; 0x18
    2342:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2344:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    2348:	18 16       	cp	r1, r24
    234a:	0c f0       	brlt	.+2      	; 0x234e <__stack+0x14f>
    234c:	a7 c1       	rjmp	.+846    	; 0x269c <__stack+0x49d>
					
					//Simple speed controller as the robot nears the target
					
					
					if ((distanceStart-distance) >= 0 && (distanceStart-distance) <= speedIncreaseThreshold){
    234e:	21 2f       	mov	r18, r17
    2350:	30 2f       	mov	r19, r16
    2352:	48 8d       	ldd	r20, Y+24	; 0x18
    2354:	5c 8d       	ldd	r21, Y+28	; 0x1c
    2356:	69 2d       	mov	r22, r9
    2358:	78 2d       	mov	r23, r8
    235a:	87 2d       	mov	r24, r7
    235c:	96 2d       	mov	r25, r6
    235e:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2362:	2b 01       	movw	r4, r22
    2364:	3c 01       	movw	r6, r24
    2366:	20 e0       	ldi	r18, 0x00	; 0
    2368:	30 e0       	ldi	r19, 0x00	; 0
    236a:	a9 01       	movw	r20, r18
    236c:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    2370:	88 23       	and	r24, r24
    2372:	54 f1       	brlt	.+84     	; 0x23c8 <__stack+0x1c9>
    2374:	a3 01       	movw	r20, r6
    2376:	92 01       	movw	r18, r4
    2378:	c7 01       	movw	r24, r14
    237a:	b6 01       	movw	r22, r12
    237c:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    2380:	88 23       	and	r24, r24
    2382:	14 f1       	brlt	.+68     	; 0x23c8 <__stack+0x1c9>
						currentDriveActuation =	((0.68*(maxDriveActuation*shortDistIncRatio))*(distanceStart-distance)/speedIncreaseThreshold) + (baseActuation+stuckIncrement);
    2384:	20 e0       	ldi	r18, 0x00	; 0
    2386:	30 e0       	ldi	r19, 0x00	; 0
    2388:	48 ec       	ldi	r20, 0xC8	; 200
    238a:	52 e4       	ldi	r21, 0x42	; 66
    238c:	63 2d       	mov	r22, r3
    238e:	72 2d       	mov	r23, r2
    2390:	8a 2d       	mov	r24, r10
    2392:	9b 2d       	mov	r25, r11
    2394:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2398:	2b e7       	ldi	r18, 0x7B	; 123
    239a:	34 e1       	ldi	r19, 0x14	; 20
    239c:	4e e2       	ldi	r20, 0x2E	; 46
    239e:	5f e3       	ldi	r21, 0x3F	; 63
    23a0:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    23a4:	a3 01       	movw	r20, r6
    23a6:	92 01       	movw	r18, r4
    23a8:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    23ac:	a7 01       	movw	r20, r14
    23ae:	96 01       	movw	r18, r12
    23b0:	0e 94 39 31 	call	0x6272	; 0x6272 <__divsf3>
    23b4:	20 e0       	ldi	r18, 0x00	; 0
    23b6:	30 e0       	ldi	r19, 0x00	; 0
    23b8:	4c e0       	ldi	r20, 0x0C	; 12
    23ba:	52 e4       	ldi	r21, 0x42	; 66
    23bc:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    23c0:	0e 94 a6 31 	call	0x634c	; 0x634c <__fixunssfsi>
    23c4:	96 2e       	mov	r9, r22
						if(currentDriveActuation != 35){
    23c6:	4a c0       	rjmp	.+148    	; 0x245c <__stack+0x25d>
							//debug("xt:%f,xh:%f",xTargt,xhat);
							//debug("Dis:%f",distance);
						}
					}
					else if (distance < speedDecreaseThreshold){
    23c8:	20 e0       	ldi	r18, 0x00	; 0
    23ca:	30 e0       	ldi	r19, 0x00	; 0
    23cc:	46 e9       	ldi	r20, 0x96	; 150
    23ce:	53 e4       	ldi	r21, 0x43	; 67
    23d0:	61 2f       	mov	r22, r17
    23d2:	70 2f       	mov	r23, r16
    23d4:	88 8d       	ldd	r24, Y+24	; 0x18
    23d6:	9c 8d       	ldd	r25, Y+28	; 0x1c
    23d8:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    23dc:	88 23       	and	r24, r24
    23de:	94 f5       	brge	.+100    	; 0x2444 <__stack+0x245>
						currentDriveActuation = (maxDriveActuation - 0.3*maxDriveActuation)*distance/speedDecreaseThreshold + 0.3*maxDriveActuation; //Reverse proportional + a constant so it reaches.
    23e0:	20 e0       	ldi	r18, 0x00	; 0
    23e2:	30 e0       	ldi	r19, 0x00	; 0
    23e4:	4c e8       	ldi	r20, 0x8C	; 140
    23e6:	52 e4       	ldi	r21, 0x42	; 66
    23e8:	61 2f       	mov	r22, r17
    23ea:	70 2f       	mov	r23, r16
    23ec:	88 8d       	ldd	r24, Y+24	; 0x18
    23ee:	9c 8d       	ldd	r25, Y+28	; 0x1c
    23f0:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    23f4:	20 e0       	ldi	r18, 0x00	; 0
    23f6:	30 e0       	ldi	r19, 0x00	; 0
    23f8:	46 e9       	ldi	r20, 0x96	; 150
    23fa:	53 e4       	ldi	r21, 0x43	; 67
    23fc:	0e 94 39 31 	call	0x6272	; 0x6272 <__divsf3>
    2400:	21 e0       	ldi	r18, 0x01	; 1
    2402:	30 e0       	ldi	r19, 0x00	; 0
    2404:	40 ef       	ldi	r20, 0xF0	; 240
    2406:	51 e4       	ldi	r21, 0x41	; 65
    2408:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    240c:	0e 94 a6 31 	call	0x634c	; 0x634c <__fixunssfsi>
    2410:	96 2e       	mov	r9, r22
						if (distance<10)
    2412:	20 e0       	ldi	r18, 0x00	; 0
    2414:	30 e0       	ldi	r19, 0x00	; 0
    2416:	40 e2       	ldi	r20, 0x20	; 32
    2418:	51 e4       	ldi	r21, 0x41	; 65
    241a:	61 2f       	mov	r22, r17
    241c:	70 2f       	mov	r23, r16
    241e:	88 8d       	ldd	r24, Y+24	; 0x18
    2420:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2422:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    2426:	88 23       	and	r24, r24
    2428:	cc f4       	brge	.+50     	; 0x245c <__stack+0x25d>
						{
							debug("Dr: %i",currentDriveActuation);
    242a:	1f 92       	push	r1
    242c:	9f 92       	push	r9
    242e:	83 e3       	ldi	r24, 0x33	; 51
    2430:	96 e0       	ldi	r25, 0x06	; 6
    2432:	9f 93       	push	r25
    2434:	8f 93       	push	r24
    2436:	0e 94 7d 21 	call	0x42fa	; 0x42fa <debug>
    243a:	0f 90       	pop	r0
    243c:	0f 90       	pop	r0
    243e:	0f 90       	pop	r0
    2440:	0f 90       	pop	r0
    2442:	0c c0       	rjmp	.+24     	; 0x245c <__stack+0x25d>
						}
						
						} else	{
						currentDriveActuation = maxDriveActuation;
						debug("3");
    2444:	8a e3       	ldi	r24, 0x3A	; 58
    2446:	96 e0       	ldi	r25, 0x06	; 6
    2448:	9f 93       	push	r25
    244a:	8f 93       	push	r24
    244c:	0e 94 7d 21 	call	0x42fa	; 0x42fa <debug>
    2450:	0f 90       	pop	r0
    2452:	0f 90       	pop	r0
						{
							debug("Dr: %i",currentDriveActuation);
						}
						
						} else	{
						currentDriveActuation = maxDriveActuation;
    2454:	0f 2e       	mov	r0, r31
    2456:	f4 e6       	ldi	r31, 0x64	; 100
    2458:	9f 2e       	mov	r9, r31
    245a:	f0 2d       	mov	r31, r0
					
					
					int16_t LSpeed = 0;
					int16_t RSpeed = 0;
					
					if (doneTurning){//Start forward movement
    245c:	8c a5       	ldd	r24, Y+44	; 0x2c
    245e:	88 23       	and	r24, r24
    2460:	09 f4       	brne	.+2      	; 0x2464 <__stack+0x265>
    2462:	9d c0       	rjmp	.+314    	; 0x259e <__stack+0x39f>
						if (thetaDiff >= 0){//Moving left
    2464:	ca 84       	ldd	r12, Y+10	; 0x0a
    2466:	db 84       	ldd	r13, Y+11	; 0x0b
    2468:	ec 84       	ldd	r14, Y+12	; 0x0c
    246a:	fd 84       	ldd	r15, Y+13	; 0x0d
    246c:	20 e0       	ldi	r18, 0x00	; 0
    246e:	30 e0       	ldi	r19, 0x00	; 0
    2470:	a9 01       	movw	r20, r18
    2472:	c7 01       	movw	r24, r14
    2474:	b6 01       	movw	r22, r12
    2476:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    247a:	88 23       	and	r24, r24
    247c:	bc f1       	brlt	.+110    	; 0x24ec <__stack+0x2ed>
							LSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*leftIntError; //Simple PI controller for theta
    247e:	a9 2c       	mov	r10, r9
    2480:	b1 2c       	mov	r11, r1
    2482:	b5 01       	movw	r22, r10
    2484:	0b 2c       	mov	r0, r11
    2486:	00 0c       	add	r0, r0
    2488:	88 0b       	sbc	r24, r24
    248a:	99 0b       	sbc	r25, r25
    248c:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    2490:	2b 01       	movw	r4, r22
    2492:	3c 01       	movw	r6, r24
    2494:	20 e0       	ldi	r18, 0x00	; 0
    2496:	30 e0       	ldi	r19, 0x00	; 0
    2498:	46 e1       	ldi	r20, 0x16	; 22
    249a:	54 e4       	ldi	r21, 0x44	; 68
    249c:	c7 01       	movw	r24, r14
    249e:	b6 01       	movw	r22, r12
    24a0:	9f 77       	andi	r25, 0x7F	; 127
    24a2:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    24a6:	9b 01       	movw	r18, r22
    24a8:	ac 01       	movw	r20, r24
    24aa:	c3 01       	movw	r24, r6
    24ac:	b2 01       	movw	r22, r4
    24ae:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    24b2:	2b 01       	movw	r4, r22
    24b4:	3c 01       	movw	r6, r24
    24b6:	20 e0       	ldi	r18, 0x00	; 0
    24b8:	30 e0       	ldi	r19, 0x00	; 0
    24ba:	40 e2       	ldi	r20, 0x20	; 32
    24bc:	51 e4       	ldi	r21, 0x41	; 65
    24be:	6e a5       	ldd	r22, Y+46	; 0x2e
    24c0:	7f a5       	ldd	r23, Y+47	; 0x2f
    24c2:	88 a9       	ldd	r24, Y+48	; 0x30
    24c4:	99 a9       	ldd	r25, Y+49	; 0x31
    24c6:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    24ca:	9b 01       	movw	r18, r22
    24cc:	ac 01       	movw	r20, r24
    24ce:	c3 01       	movw	r24, r6
    24d0:	b2 01       	movw	r22, r4
    24d2:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    24d6:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
							
							//Saturation
							if (LSpeed > currentDriveActuation){
    24da:	a6 16       	cp	r10, r22
    24dc:	b7 06       	cpc	r11, r23
    24de:	ec f1       	brlt	.+122    	; 0x255a <__stack+0x35b>
    24e0:	8b 01       	movw	r16, r22
    24e2:	77 23       	and	r23, r23
    24e4:	ec f5       	brge	.+122    	; 0x2560 <__stack+0x361>
    24e6:	00 e0       	ldi	r16, 0x00	; 0
    24e8:	10 e0       	ldi	r17, 0x00	; 0
    24ea:	3a c0       	rjmp	.+116    	; 0x2560 <__stack+0x361>
								LSpeed = 0;
							}
							RSpeed = currentDriveActuation;
							
						}else{//Moving right
							RSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*rightIntError; //Simple PI controller for theta
    24ec:	09 2d       	mov	r16, r9
    24ee:	10 e0       	ldi	r17, 0x00	; 0
    24f0:	b8 01       	movw	r22, r16
    24f2:	01 2e       	mov	r0, r17
    24f4:	00 0c       	add	r0, r0
    24f6:	88 0b       	sbc	r24, r24
    24f8:	99 0b       	sbc	r25, r25
    24fa:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    24fe:	4b 01       	movw	r8, r22
    2500:	5c 01       	movw	r10, r24
    2502:	20 e0       	ldi	r18, 0x00	; 0
    2504:	30 e0       	ldi	r19, 0x00	; 0
    2506:	46 e1       	ldi	r20, 0x16	; 22
    2508:	54 e4       	ldi	r21, 0x44	; 68
    250a:	c7 01       	movw	r24, r14
    250c:	b6 01       	movw	r22, r12
    250e:	9f 77       	andi	r25, 0x7F	; 127
    2510:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2514:	9b 01       	movw	r18, r22
    2516:	ac 01       	movw	r20, r24
    2518:	c5 01       	movw	r24, r10
    251a:	b4 01       	movw	r22, r8
    251c:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2520:	4b 01       	movw	r8, r22
    2522:	5c 01       	movw	r10, r24
    2524:	20 e0       	ldi	r18, 0x00	; 0
    2526:	30 e0       	ldi	r19, 0x00	; 0
    2528:	40 e2       	ldi	r20, 0x20	; 32
    252a:	51 e4       	ldi	r21, 0x41	; 65
    252c:	6a a9       	ldd	r22, Y+50	; 0x32
    252e:	7b a9       	ldd	r23, Y+51	; 0x33
    2530:	8c a9       	ldd	r24, Y+52	; 0x34
    2532:	9d a9       	ldd	r25, Y+53	; 0x35
    2534:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2538:	9b 01       	movw	r18, r22
    253a:	ac 01       	movw	r20, r24
    253c:	c5 01       	movw	r24, r10
    253e:	b4 01       	movw	r22, r8
    2540:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2544:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
							
							//Saturation
							if (RSpeed > currentDriveActuation){
    2548:	06 17       	cp	r16, r22
    254a:	17 07       	cpc	r17, r23
    254c:	44 f0       	brlt	.+16     	; 0x255e <__stack+0x35f>
    254e:	5b 01       	movw	r10, r22
    2550:	77 23       	and	r23, r23
    2552:	34 f4       	brge	.+12     	; 0x2560 <__stack+0x361>
    2554:	a1 2c       	mov	r10, r1
    2556:	b1 2c       	mov	r11, r1
    2558:	03 c0       	rjmp	.+6      	; 0x2560 <__stack+0x361>
						if (thetaDiff >= 0){//Moving left
							LSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*leftIntError; //Simple PI controller for theta
							
							//Saturation
							if (LSpeed > currentDriveActuation){
								LSpeed = currentDriveActuation;
    255a:	85 01       	movw	r16, r10
    255c:	01 c0       	rjmp	.+2      	; 0x2560 <__stack+0x361>
						}else{//Moving right
							RSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*rightIntError; //Simple PI controller for theta
							
							//Saturation
							if (RSpeed > currentDriveActuation){
								RSpeed = currentDriveActuation;
    255e:	58 01       	movw	r10, r16
								RSpeed = 0;
							}
							LSpeed = currentDriveActuation;	
						}
						
						leftIntError += thetaDiff;
    2560:	a7 01       	movw	r20, r14
    2562:	96 01       	movw	r18, r12
    2564:	6e a5       	ldd	r22, Y+46	; 0x2e
    2566:	7f a5       	ldd	r23, Y+47	; 0x2f
    2568:	88 a9       	ldd	r24, Y+48	; 0x30
    256a:	99 a9       	ldd	r25, Y+49	; 0x31
    256c:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    2570:	6e a7       	std	Y+46, r22	; 0x2e
    2572:	7f a7       	std	Y+47, r23	; 0x2f
    2574:	88 ab       	std	Y+48, r24	; 0x30
    2576:	99 ab       	std	Y+49, r25	; 0x31
						rightIntError -= thetaDiff;
    2578:	a7 01       	movw	r20, r14
    257a:	96 01       	movw	r18, r12
    257c:	6a a9       	ldd	r22, Y+50	; 0x32
    257e:	7b a9       	ldd	r23, Y+51	; 0x33
    2580:	8c a9       	ldd	r24, Y+52	; 0x34
    2582:	9d a9       	ldd	r25, Y+53	; 0x35
    2584:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2588:	6a ab       	std	Y+50, r22	; 0x32
    258a:	7b ab       	std	Y+51, r23	; 0x33
    258c:	8c ab       	std	Y+52, r24	; 0x34
    258e:	9d ab       	std	Y+53, r25	; 0x35
						
						
						gRightWheelDirection = motorRightForward;
    2590:	86 e0       	ldi	r24, 0x06	; 6
    2592:	8b 8b       	std	Y+19, r24	; 0x13
						gLeftWheelDirection = motorLeftForward;
    2594:	84 e0       	ldi	r24, 0x04	; 4
    2596:	8a 8b       	std	Y+18, r24	; 0x12
						lastMovement = moveForward;
    2598:	91 e0       	ldi	r25, 0x01	; 1
    259a:	99 87       	std	Y+9, r25	; 0x09
    259c:	74 c0       	rjmp	.+232    	; 0x2686 <__stack+0x487>
						
						
						
					}else{ //Turn within 1 degree of target
						if (thetaDiff >= 0){//Rotating left
    259e:	ca 84       	ldd	r12, Y+10	; 0x0a
    25a0:	db 84       	ldd	r13, Y+11	; 0x0b
    25a2:	ec 84       	ldd	r14, Y+12	; 0x0c
    25a4:	fd 84       	ldd	r15, Y+13	; 0x0d
    25a6:	20 e0       	ldi	r18, 0x00	; 0
    25a8:	30 e0       	ldi	r19, 0x00	; 0
    25aa:	a9 01       	movw	r20, r18
    25ac:	c7 01       	movw	r24, r14
    25ae:	b6 01       	movw	r22, r12
    25b0:	0e 94 e2 32 	call	0x65c4	; 0x65c4 <__gesf2>
    25b4:	88 23       	and	r24, r24
    25b6:	a4 f1       	brlt	.+104    	; 0x2620 <__stack+0x421>
							LSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    25b8:	c7 01       	movw	r24, r14
    25ba:	b6 01       	movw	r22, r12
    25bc:	9f 77       	andi	r25, 0x7F	; 127
    25be:	2e ea       	ldi	r18, 0xAE	; 174
    25c0:	37 e4       	ldi	r19, 0x47	; 71
    25c2:	41 e6       	ldi	r20, 0x61	; 97
    25c4:	5e e3       	ldi	r21, 0x3E	; 62
    25c6:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    25ca:	2a e9       	ldi	r18, 0x9A	; 154
    25cc:	39 e9       	ldi	r19, 0x99	; 153
    25ce:	49 e9       	ldi	r20, 0x99	; 153
    25d0:	5e e3       	ldi	r21, 0x3E	; 62
    25d2:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    25d6:	6b 01       	movw	r12, r22
    25d8:	7c 01       	movw	r14, r24
    25da:	20 e0       	ldi	r18, 0x00	; 0
    25dc:	30 e0       	ldi	r19, 0x00	; 0
    25de:	48 ec       	ldi	r20, 0xC8	; 200
    25e0:	52 ec       	ldi	r21, 0xC2	; 194
    25e2:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    25e6:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
    25ea:	8b 01       	movw	r16, r22
							gLeftWheelDirection = motorLeftBackward;
    25ec:	85 e0       	ldi	r24, 0x05	; 5
    25ee:	8a 8b       	std	Y+18, r24	; 0x12
							RSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    25f0:	20 e0       	ldi	r18, 0x00	; 0
    25f2:	30 e0       	ldi	r19, 0x00	; 0
    25f4:	48 ec       	ldi	r20, 0xC8	; 200
    25f6:	52 e4       	ldi	r21, 0x42	; 66
    25f8:	c7 01       	movw	r24, r14
    25fa:	b6 01       	movw	r22, r12
    25fc:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2600:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
    2604:	5b 01       	movw	r10, r22
							gRightWheelDirection = motorRightForward;
    2606:	86 e0       	ldi	r24, 0x06	; 6
    2608:	8b 8b       	std	Y+19, r24	; 0x13
							lastMovement = moveCounterClockwise;
    260a:	84 e0       	ldi	r24, 0x04	; 4
    260c:	89 87       	std	Y+9, r24	; 0x09
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
					}
						leftIntError = 0;
						rightIntError = 0;
    260e:	1a aa       	std	Y+50, r1	; 0x32
    2610:	1b aa       	std	Y+51, r1	; 0x33
    2612:	1c aa       	std	Y+52, r1	; 0x34
    2614:	1d aa       	std	Y+53, r1	; 0x35
							gLeftWheelDirection = motorLeftForward;
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
					}
						leftIntError = 0;
    2616:	1e a6       	std	Y+46, r1	; 0x2e
    2618:	1f a6       	std	Y+47, r1	; 0x2f
    261a:	18 aa       	std	Y+48, r1	; 0x30
    261c:	19 aa       	std	Y+49, r1	; 0x31
    261e:	33 c0       	rjmp	.+102    	; 0x2686 <__stack+0x487>
							gLeftWheelDirection = motorLeftBackward;
							RSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightForward;
							lastMovement = moveCounterClockwise;
							}else{//Rotating right
							LSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    2620:	c7 01       	movw	r24, r14
    2622:	b6 01       	movw	r22, r12
    2624:	9f 77       	andi	r25, 0x7F	; 127
    2626:	2e ea       	ldi	r18, 0xAE	; 174
    2628:	37 e4       	ldi	r19, 0x47	; 71
    262a:	41 e6       	ldi	r20, 0x61	; 97
    262c:	5e e3       	ldi	r21, 0x3E	; 62
    262e:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2632:	2a e9       	ldi	r18, 0x9A	; 154
    2634:	39 e9       	ldi	r19, 0x99	; 153
    2636:	49 e9       	ldi	r20, 0x99	; 153
    2638:	5e e3       	ldi	r21, 0x3E	; 62
    263a:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    263e:	6b 01       	movw	r12, r22
    2640:	7c 01       	movw	r14, r24
    2642:	20 e0       	ldi	r18, 0x00	; 0
    2644:	30 e0       	ldi	r19, 0x00	; 0
    2646:	48 ec       	ldi	r20, 0xC8	; 200
    2648:	52 e4       	ldi	r21, 0x42	; 66
    264a:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    264e:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
    2652:	8b 01       	movw	r16, r22
							gLeftWheelDirection = motorLeftForward;
    2654:	84 e0       	ldi	r24, 0x04	; 4
    2656:	8a 8b       	std	Y+18, r24	; 0x12
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    2658:	20 e0       	ldi	r18, 0x00	; 0
    265a:	30 e0       	ldi	r19, 0x00	; 0
    265c:	48 ec       	ldi	r20, 0xC8	; 200
    265e:	52 ec       	ldi	r21, 0xC2	; 194
    2660:	c7 01       	movw	r24, r14
    2662:	b6 01       	movw	r22, r12
    2664:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2668:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
    266c:	5b 01       	movw	r10, r22
							gRightWheelDirection = motorRightBackward;
    266e:	85 e0       	ldi	r24, 0x05	; 5
    2670:	8b 8b       	std	Y+19, r24	; 0x13
							lastMovement = moveClockwise;
    2672:	83 e0       	ldi	r24, 0x03	; 3
    2674:	89 87       	std	Y+9, r24	; 0x09
					}
						leftIntError = 0;
						rightIntError = 0;
    2676:	1a aa       	std	Y+50, r1	; 0x32
    2678:	1b aa       	std	Y+51, r1	; 0x33
    267a:	1c aa       	std	Y+52, r1	; 0x34
    267c:	1d aa       	std	Y+53, r1	; 0x35
							gLeftWheelDirection = motorLeftForward;
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
					}
						leftIntError = 0;
    267e:	1e a6       	std	Y+46, r1	; 0x2e
    2680:	1f a6       	std	Y+47, r1	; 0x2f
    2682:	18 aa       	std	Y+48, r1	; 0x30
    2684:	19 aa       	std	Y+49, r1	; 0x31
						dummy=0;
					} else {
						dummy++;
					}*/
	
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
    2686:	9e 01       	movw	r18, r28
    2688:	2d 5e       	subi	r18, 0xED	; 237
    268a:	3f 4f       	sbci	r19, 0xFF	; 255
    268c:	ae 01       	movw	r20, r28
    268e:	4e 5e       	subi	r20, 0xEE	; 238
    2690:	5f 4f       	sbci	r21, 0xFF	; 255
    2692:	b5 01       	movw	r22, r10
    2694:	c8 01       	movw	r24, r16
    2696:	a0 d3       	rcall	.+1856   	; 0x2dd8 <vMotorMovementSwitch>
						} else	{
						currentDriveActuation = maxDriveActuation;
						debug("3");
					}
					
					idleSendt = FALSE;
    2698:	1d a6       	std	Y+45, r1	; 0x2d
    269a:	0a c0       	rjmp	.+20     	; 0x26b0 <__stack+0x4b1>
	
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
					
				}else{
					
					if (idleSendt == FALSE){
    269c:	2d a5       	ldd	r18, Y+45	; 0x2d
    269e:	21 11       	cpse	r18, r1
    26a0:	04 c0       	rjmp	.+8      	; 0x26aa <__stack+0x4ab>
						send_idle();
    26a2:	0e 94 59 21 	call	0x42b2	; 0x42b2 <send_idle>
						idleSendt = TRUE;
						//debug("send idle i vMainPoseControllerTask");
					}
					//debug("motorbrake");
					vMotorBrakeLeft();
    26a6:	81 e0       	ldi	r24, 0x01	; 1
    26a8:	8d a7       	std	Y+45, r24	; 0x2d
					vMotorBrakeRight();
    26aa:	82 d3       	rcall	.+1796   	; 0x2db0 <vMotorBrakeLeft>
    26ac:	86 d3       	rcall	.+1804   	; 0x2dba <vMotorBrakeRight>
					lastMovement = moveStop;
    26ae:	19 86       	std	Y+9, r1	; 0x09
				}
				xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
    26b0:	20 e0       	ldi	r18, 0x00	; 0
    26b2:	40 e0       	ldi	r20, 0x00	; 0
    26b4:	50 e0       	ldi	r21, 0x00	; 0
    26b6:	be 01       	movw	r22, r28
    26b8:	67 5f       	subi	r22, 0xF7	; 247
    26ba:	7f 4f       	sbci	r23, 0xFF	; 255
    26bc:	80 91 e3 19 	lds	r24, 0x19E3	; 0x8019e3 <scanStatusQ>
    26c0:	90 91 e4 19 	lds	r25, 0x19E4	; 0x8019e4 <scanStatusQ+0x1>
    26c4:	0e 94 7f 1b 	call	0x36fe	; 0x36fe <xQueueGenericSend>
    26c8:	df cb       	rjmp	.-2114   	; 0x1e88 <vMainPoseControllerTask+0x92>

000026ca <vMainPoseEstimatorTask>:
		} //if(gHandshook) end
	}
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    26ca:	cf 93       	push	r28
    26cc:	df 93       	push	r29
    26ce:	cd b7       	in	r28, 0x3d	; 61
    26d0:	de b7       	in	r29, 0x3e	; 62
    26d2:	a2 97       	sbiw	r28, 0x22	; 34
    26d4:	0f b6       	in	r0, 0x3f	; 63
    26d6:	f8 94       	cli
    26d8:	de bf       	out	0x3e, r29	; 62
    26da:	0f be       	out	0x3f, r0	; 63
    26dc:	cd bf       	out	0x3d, r28	; 61
    const TickType_t xDelay = PERIOD_ESTIMATOR_MS;
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    26de:	19 82       	std	Y+1, r1	; 0x01
    26e0:	1a 82       	std	Y+2, r1	; 0x02
    26e2:	1b 82       	std	Y+3, r1	; 0x03
    26e4:	1c 82       	std	Y+4, r1	; 0x04
        uint8_t printerTellar = 0;     
    #endif
    
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    26e6:	0e 94 8b 29 	call	0x5316	; 0x5316 <xTaskGetTickCount>
    26ea:	9e 83       	std	Y+6, r25	; 0x06
    26ec:	8d 83       	std	Y+5, r24	; 0x05
    
    float variance_gyro = 0.0482f; // [rad] calculated offline, see report
    float variance_encoder = (2.0f * WHEEL_FACTOR_MM) / (WHEELBASE_MM / 2.0f); // approximation, 0.0257 [rad]
    
    float variance_gyro_encoder = (variance_gyro + variance_encoder) * period_in_S; // (Var gyro + var encoder) * timestep
    float covariance_filter_predicted = 0;
    26ee:	1e 8e       	std	Y+30, r1	; 0x1e
    26f0:	1f 8e       	std	Y+31, r1	; 0x1f
    26f2:	18 a2       	std	Y+32, r1	; 0x20
    26f4:	19 a2       	std	Y+33, r1	; 0x21
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    26f6:	1b 86       	std	Y+11, r1	; 0x0b
    26f8:	1c 86       	std	Y+12, r1	; 0x0c
    26fa:	1d 86       	std	Y+13, r1	; 0x0d
    26fc:	1e 86       	std	Y+14, r1	; 0x0e
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    26fe:	1f 8a       	std	Y+23, r1	; 0x17
    2700:	18 8e       	std	Y+24, r1	; 0x18
    2702:	19 8e       	std	Y+25, r1	; 0x19
    2704:	1a 8e       	std	Y+26, r1	; 0x1a
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    2706:	1b 8a       	std	Y+19, r1	; 0x13
    2708:	1c 8a       	std	Y+20, r1	; 0x14
    270a:	1d 8a       	std	Y+21, r1	; 0x15
    270c:	1e 8a       	std	Y+22, r1	; 0x16
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    int16_t previous_ticksRight = 0;  
    270e:	e1 2c       	mov	r14, r1
    2710:	f1 2c       	mov	r15, r1
	}
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    2712:	81 2c       	mov	r8, r1
    2714:	91 2c       	mov	r9, r1
    2716:	41 2c       	mov	r4, r1
    2718:	31 2c       	mov	r3, r1
    271a:	21 2c       	mov	r2, r1
    271c:	51 2c       	mov	r5, r1
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    
    while(1){
        // Loop
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    271e:	68 e2       	ldi	r22, 0x28	; 40
    2720:	70 e0       	ldi	r23, 0x00	; 0
    2722:	ce 01       	movw	r24, r28
    2724:	05 96       	adiw	r24, 0x05	; 5
    2726:	0e 94 3e 24 	call	0x487c	; 0x487c <vTaskDelayUntil>
        if (gHandshook){ // Check if we are ready    
    272a:	80 91 de 19 	lds	r24, 0x19DE	; 0x8019de <gHandshook>
    272e:	88 23       	and	r24, r24
    2730:	09 f4       	brne	.+2      	; 0x2734 <vMainPoseEstimatorTask+0x6a>
    2732:	90 c1       	rjmp	.+800    	; 0x2a54 <vMainPoseEstimatorTask+0x38a>
            int16_t leftWheelTicks = 0;
            int16_t rightWheelTicks = 0;
            float dRobot = 0;
			float dTheta = 0;
            // Get encoder data, protect the global tick variables
            xSemaphoreTake(xTickMutex, 15 / portTICK_PERIOD_MS);
    2734:	20 e0       	ldi	r18, 0x00	; 0
    2736:	4f e0       	ldi	r20, 0x0F	; 15
    2738:	50 e0       	ldi	r21, 0x00	; 0
    273a:	60 e0       	ldi	r22, 0x00	; 0
    273c:	70 e0       	ldi	r23, 0x00	; 0
    273e:	80 91 49 1b 	lds	r24, 0x1B49	; 0x801b49 <xTickMutex>
    2742:	90 91 4a 1b 	lds	r25, 0x1B4A	; 0x801b4a <xTickMutex+0x1>
    2746:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
                leftWheelTicks = gLeftWheelTicks;
    274a:	60 90 d1 19 	lds	r6, 0x19D1	; 0x8019d1 <gLeftWheelTicks>
    274e:	70 90 d2 19 	lds	r7, 0x19D2	; 0x8019d2 <gLeftWheelTicks+0x1>
                rightWheelTicks = gRightWheelTicks;
    2752:	00 91 d3 19 	lds	r16, 0x19D3	; 0x8019d3 <gRightWheelTicks>
    2756:	10 91 d4 19 	lds	r17, 0x19D4	; 0x8019d4 <gRightWheelTicks+0x1>
            xSemaphoreGive(xTickMutex);
    275a:	60 e0       	ldi	r22, 0x00	; 0
    275c:	70 e0       	ldi	r23, 0x00	; 0
    275e:	80 91 49 1b 	lds	r24, 0x1B49	; 0x801b49 <xTickMutex>
    2762:	90 91 4a 1b 	lds	r25, 0x1B4A	; 0x801b4a <xTickMutex+0x1>
    2766:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>

            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
    276a:	b3 01       	movw	r22, r6
    276c:	68 19       	sub	r22, r8
    276e:	79 09       	sbc	r23, r9
    2770:	07 2e       	mov	r0, r23
    2772:	00 0c       	add	r0, r0
    2774:	88 0b       	sbc	r24, r24
    2776:	99 0b       	sbc	r25, r25
    2778:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    277c:	28 ef       	ldi	r18, 0xF8	; 248
    277e:	33 e5       	ldi	r19, 0x53	; 83
    2780:	43 ea       	ldi	r20, 0xA3	; 163
    2782:	5f e3       	ldi	r21, 0x3F	; 63
    2784:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2788:	4b 01       	movw	r8, r22
    278a:	5c 01       	movw	r10, r24
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
    278c:	b8 01       	movw	r22, r16
    278e:	6e 19       	sub	r22, r14
    2790:	7f 09       	sbc	r23, r15
    2792:	07 2e       	mov	r0, r23
    2794:	00 0c       	add	r0, r0
    2796:	88 0b       	sbc	r24, r24
    2798:	99 0b       	sbc	r25, r25
    279a:	0e 94 d4 31 	call	0x63a8	; 0x63a8 <__floatsisf>
    279e:	28 ef       	ldi	r18, 0xF8	; 248
    27a0:	33 e5       	ldi	r19, 0x53	; 83
    27a2:	43 ea       	ldi	r20, 0xA3	; 163
    27a4:	5f e3       	ldi	r21, 0x3F	; 63
    27a6:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    27aa:	6b 01       	movw	r12, r22
    27ac:	7c 01       	movw	r14, r24
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
            	   
            dRobot = (dLeft + dRight) / 2;           
    27ae:	9b 01       	movw	r18, r22
    27b0:	ac 01       	movw	r20, r24
    27b2:	c5 01       	movw	r24, r10
    27b4:	b4 01       	movw	r22, r8
    27b6:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    27ba:	20 e0       	ldi	r18, 0x00	; 0
    27bc:	30 e0       	ldi	r19, 0x00	; 0
    27be:	40 e0       	ldi	r20, 0x00	; 0
    27c0:	5f e3       	ldi	r21, 0x3F	; 63
    27c2:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    27c6:	6f 87       	std	Y+15, r22	; 0x0f
    27c8:	78 8b       	std	Y+16, r23	; 0x10
    27ca:	89 8b       	std	Y+17, r24	; 0x11
    27cc:	9a 8b       	std	Y+18, r25	; 0x12
            dTheta = (dRight - dLeft) / WHEELBASE_MM; // Get angle from encoders, dervied from arch of circles formula
    27ce:	a5 01       	movw	r20, r10
    27d0:	94 01       	movw	r18, r8
    27d2:	c7 01       	movw	r24, r14
    27d4:	b6 01       	movw	r22, r12
    27d6:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    27da:	20 e0       	ldi	r18, 0x00	; 0
    27dc:	30 e0       	ldi	r19, 0x00	; 0
    27de:	43 e1       	ldi	r20, 0x13	; 19
    27e0:	53 e4       	ldi	r21, 0x43	; 67
    27e2:	0e 94 39 31 	call	0x6272	; 0x6272 <__divsf3>
    27e6:	4b 01       	movw	r8, r22
    27e8:	5c 01       	movw	r10, r24
            */
			
			 
            /* PREDICT */
            // Get gyro data:
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
    27ea:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <fIMU_readFloatGyroZ>
    27ee:	2b 85       	ldd	r18, Y+11	; 0x0b
    27f0:	3c 85       	ldd	r19, Y+12	; 0x0c
    27f2:	4d 85       	ldd	r20, Y+13	; 0x0d
    27f4:	5e 85       	ldd	r21, Y+14	; 0x0e
    27f6:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    27fa:	6b 01       	movw	r12, r22
    27fc:	7c 01       	movw	r14, r24
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
    27fe:	9f 77       	andi	r25, 0x7F	; 127
    2800:	20 e0       	ldi	r18, 0x00	; 0
    2802:	30 e0       	ldi	r19, 0x00	; 0
    2804:	40 e2       	ldi	r20, 0x20	; 32
    2806:	51 e4       	ldi	r21, 0x41	; 65
    2808:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    280c:	88 23       	and	r24, r24
    280e:	4c f0       	brlt	.+18     	; 0x2822 <vMainPoseEstimatorTask+0x158>
                gyroWeight = 0; // Disregard gyro while driving in a straight line
                robot_is_turning = FALSE; // Don't update angle estimates
                }
            else {
                robot_is_turning = TRUE;
    2810:	81 e0       	ldi	r24, 0x01	; 1
    2812:	8a a3       	std	Y+34, r24	; 0x22
                gyroWeight = 0.75; // Found by experiment, after 20x90 degree turns, gyro seems 85% more accurate than encoders
    2814:	1f 82       	std	Y+7, r1	; 0x07
    2816:	1b 8e       	std	Y+27, r1	; 0x1b
    2818:	80 e4       	ldi	r24, 0x40	; 64
    281a:	8c 8f       	std	Y+28, r24	; 0x1c
    281c:	8f e3       	ldi	r24, 0x3F	; 63
    281e:	8d 8f       	std	Y+29, r24	; 0x1d
    2820:	05 c0       	rjmp	.+10     	; 0x282c <vMainPoseEstimatorTask+0x162>
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
                gyroWeight = 0; // Disregard gyro while driving in a straight line
                robot_is_turning = FALSE; // Don't update angle estimates
    2822:	1a a2       	std	Y+34, r1	; 0x22
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
                gyroWeight = 0; // Disregard gyro while driving in a straight line
    2824:	4f 82       	std	Y+7, r4	; 0x07
    2826:	3b 8e       	std	Y+27, r3	; 0x1b
    2828:	2c 8e       	std	Y+28, r2	; 0x1c
    282a:	5d 8e       	std	Y+29, r5	; 0x1d
            gyrZ *= period_in_S * DEG2RAD; // Scale gyro measurement      
            
			
			
            // Fuse heading from sensors to predict heading:
            dTheta =  (1 - gyroWeight) * dTheta + gyroWeight * gyrZ;
    282c:	2f 81       	ldd	r18, Y+7	; 0x07
    282e:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2830:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2832:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2834:	60 e0       	ldi	r22, 0x00	; 0
    2836:	70 e0       	ldi	r23, 0x00	; 0
    2838:	80 e8       	ldi	r24, 0x80	; 128
    283a:	9f e3       	ldi	r25, 0x3F	; 63
    283c:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    2840:	a5 01       	movw	r20, r10
    2842:	94 01       	movw	r18, r8
    2844:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2848:	4b 01       	movw	r8, r22
    284a:	5c 01       	movw	r10, r24
    284c:	24 ed       	ldi	r18, 0xD4	; 212
    284e:	32 e0       	ldi	r19, 0x02	; 2
    2850:	47 e3       	ldi	r20, 0x37	; 55
    2852:	5a e3       	ldi	r21, 0x3A	; 58
    2854:	c7 01       	movw	r24, r14
    2856:	b6 01       	movw	r22, r12
    2858:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    285c:	2f 81       	ldd	r18, Y+7	; 0x07
    285e:	3b 8d       	ldd	r19, Y+27	; 0x1b
    2860:	4c 8d       	ldd	r20, Y+28	; 0x1c
    2862:	5d 8d       	ldd	r21, Y+29	; 0x1d
    2864:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2868:	a5 01       	movw	r20, r10
    286a:	94 01       	movw	r18, r8
    286c:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    2870:	6f 83       	std	Y+7, r22	; 0x07
    2872:	78 87       	std	Y+8, r23	; 0x08
    2874:	89 87       	std	Y+9, r24	; 0x09
    2876:	9a 87       	std	Y+10, r25	; 0x0a
            
            
            // Estimate global X and Y pos
            // Todo; Include accelerator measurements to estimate position and handle wheel slippage
            predictedX = predictedX + (dRobot * cos(predictedTheta + 0.5 * dTheta)); 
    2878:	c9 80       	ldd	r12, Y+1	; 0x01
    287a:	da 80       	ldd	r13, Y+2	; 0x02
    287c:	eb 80       	ldd	r14, Y+3	; 0x03
    287e:	fc 80       	ldd	r15, Y+4	; 0x04
    2880:	20 e0       	ldi	r18, 0x00	; 0
    2882:	30 e0       	ldi	r19, 0x00	; 0
    2884:	40 e0       	ldi	r20, 0x00	; 0
    2886:	5f e3       	ldi	r21, 0x3F	; 63
    2888:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    288c:	a7 01       	movw	r20, r14
    288e:	96 01       	movw	r18, r12
    2890:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    2894:	4b 01       	movw	r8, r22
    2896:	5c 01       	movw	r10, r24
    2898:	0e 94 36 31 	call	0x626c	; 0x626c <cos>
    289c:	9b 01       	movw	r18, r22
    289e:	ac 01       	movw	r20, r24
    28a0:	6f 85       	ldd	r22, Y+15	; 0x0f
    28a2:	78 89       	ldd	r23, Y+16	; 0x10
    28a4:	89 89       	ldd	r24, Y+17	; 0x11
    28a6:	9a 89       	ldd	r25, Y+18	; 0x12
    28a8:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    28ac:	9b 01       	movw	r18, r22
    28ae:	ac 01       	movw	r20, r24
    28b0:	6b 89       	ldd	r22, Y+19	; 0x13
    28b2:	7c 89       	ldd	r23, Y+20	; 0x14
    28b4:	8d 89       	ldd	r24, Y+21	; 0x15
    28b6:	9e 89       	ldd	r25, Y+22	; 0x16
    28b8:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    28bc:	6b 8b       	std	Y+19, r22	; 0x13
    28be:	7c 8b       	std	Y+20, r23	; 0x14
    28c0:	8d 8b       	std	Y+21, r24	; 0x15
    28c2:	9e 8b       	std	Y+22, r25	; 0x16
            predictedY = predictedY + (dRobot * sin(predictedTheta + 0.5 * dTheta));
    28c4:	c5 01       	movw	r24, r10
    28c6:	b4 01       	movw	r22, r8
    28c8:	0e 94 50 33 	call	0x66a0	; 0x66a0 <sin>
    28cc:	9b 01       	movw	r18, r22
    28ce:	ac 01       	movw	r20, r24
    28d0:	6f 85       	ldd	r22, Y+15	; 0x0f
    28d2:	78 89       	ldd	r23, Y+16	; 0x10
    28d4:	89 89       	ldd	r24, Y+17	; 0x11
    28d6:	9a 89       	ldd	r25, Y+18	; 0x12
    28d8:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    28dc:	9b 01       	movw	r18, r22
    28de:	ac 01       	movw	r20, r24
    28e0:	6f 89       	ldd	r22, Y+23	; 0x17
    28e2:	78 8d       	ldd	r23, Y+24	; 0x18
    28e4:	89 8d       	ldd	r24, Y+25	; 0x19
    28e6:	9a 8d       	ldd	r25, Y+26	; 0x1a
    28e8:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    28ec:	6f 8b       	std	Y+23, r22	; 0x17
    28ee:	78 8f       	std	Y+24, r23	; 0x18
    28f0:	89 8f       	std	Y+25, r24	; 0x19
    28f2:	9a 8f       	std	Y+26, r25	; 0x1a

            // Predicted (a priori) state estimate for theta
            predictedTheta += dTheta;
    28f4:	a7 01       	movw	r20, r14
    28f6:	96 01       	movw	r18, r12
    28f8:	6f 81       	ldd	r22, Y+7	; 0x07
    28fa:	78 85       	ldd	r23, Y+8	; 0x08
    28fc:	89 85       	ldd	r24, Y+9	; 0x09
    28fe:	9a 85       	ldd	r25, Y+10	; 0x0a
    2900:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    2904:	69 83       	std	Y+1, r22	; 0x01
    2906:	7a 83       	std	Y+2, r23	; 0x02
    2908:	8b 83       	std	Y+3, r24	; 0x03
    290a:	9c 83       	std	Y+4, r25	; 0x04
                  
            // Predicted (a priori) estimate covariance
            covariance_filter_predicted += variance_gyro_encoder;
    290c:	26 e6       	ldi	r18, 0x66	; 102
    290e:	3f e5       	ldi	r19, 0x5F	; 95
    2910:	49 e5       	ldi	r20, 0x59	; 89
    2912:	5b e3       	ldi	r21, 0x3B	; 59
    2914:	6e 8d       	ldd	r22, Y+30	; 0x1e
    2916:	7f 8d       	ldd	r23, Y+31	; 0x1f
    2918:	88 a1       	ldd	r24, Y+32	; 0x20
    291a:	99 a1       	ldd	r25, Y+33	; 0x21
    291c:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    2920:	6b 01       	movw	r12, r22
    2922:	7c 01       	movw	r14, r24
                // If we have a reading over this, we can safely ignore the compass
                // Ignore compass while driving in a straight line
                kalmanGain = 0;
                vLED_singleLow(ledYELLOW);
            }
            else if ((robot_is_turning == FALSE) && (dRobot == 0)){
    2924:	8a a1       	ldd	r24, Y+34	; 0x22
    2926:	81 11       	cpse	r24, r1
    2928:	23 c0       	rjmp	.+70     	; 0x2970 <vMainPoseEstimatorTask+0x2a6>
    292a:	24 2d       	mov	r18, r4
    292c:	33 2d       	mov	r19, r3
    292e:	42 2d       	mov	r20, r2
    2930:	55 2d       	mov	r21, r5
    2932:	6f 85       	ldd	r22, Y+15	; 0x0f
    2934:	78 89       	ldd	r23, Y+16	; 0x10
    2936:	89 89       	ldd	r24, Y+17	; 0x11
    2938:	9a 89       	ldd	r25, Y+18	; 0x12
    293a:	0e 94 32 31 	call	0x6264	; 0x6264 <__cmpsf2>
    293e:	81 11       	cpse	r24, r1
    2940:	17 c0       	rjmp	.+46     	; 0x2970 <vMainPoseEstimatorTask+0x2a6>
                // Updated (a posteriori) state estimate
                kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
    2942:	24 2d       	mov	r18, r4
    2944:	33 2d       	mov	r19, r3
    2946:	42 2d       	mov	r20, r2
    2948:	55 2d       	mov	r21, r5
    294a:	c7 01       	movw	r24, r14
    294c:	b6 01       	movw	r22, r12
    294e:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    2952:	9b 01       	movw	r18, r22
    2954:	ac 01       	movw	r20, r24
    2956:	c7 01       	movw	r24, r14
    2958:	b6 01       	movw	r22, r12
    295a:	0e 94 39 31 	call	0x6272	; 0x6272 <__divsf3>
    295e:	b6 2e       	mov	r11, r22
    2960:	a7 2e       	mov	r10, r23
    2962:	98 2e       	mov	r9, r24
    2964:	89 2e       	mov	r8, r25
                vLED_singleHigh(ledYELLOW);
    2966:	81 e0       	ldi	r24, 0x01	; 1
    2968:	90 e0       	ldi	r25, 0x00	; 0
    296a:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vLED_singleHigh>
    296e:	08 c0       	rjmp	.+16     	; 0x2980 <vMainPoseEstimatorTask+0x2b6>
            }
            else{
                kalmanGain = 0;
                vLED_singleLow(ledYELLOW);
    2970:	81 e0       	ldi	r24, 0x01	; 1
    2972:	90 e0       	ldi	r25, 0x00	; 0
    2974:	0e 94 0f 0c 	call	0x181e	; 0x181e <vLED_singleLow>
                // Updated (a posteriori) state estimate
                kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
                vLED_singleHigh(ledYELLOW);
            }
            else{
                kalmanGain = 0;
    2978:	b4 2c       	mov	r11, r4
    297a:	a3 2c       	mov	r10, r3
    297c:	92 2c       	mov	r9, r2
    297e:	85 2c       	mov	r8, r5
                vLED_singleLow(ledYELLOW);
            }            
            //*/
           
            predictedTheta  += kalmanGain*(error);
    2980:	24 2d       	mov	r18, r4
    2982:	33 2d       	mov	r19, r3
    2984:	42 2d       	mov	r20, r2
    2986:	55 2d       	mov	r21, r5
    2988:	6b 2d       	mov	r22, r11
    298a:	7a 2d       	mov	r23, r10
    298c:	89 2d       	mov	r24, r9
    298e:	98 2d       	mov	r25, r8
    2990:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    2994:	9b 01       	movw	r18, r22
    2996:	ac 01       	movw	r20, r24
    2998:	69 81       	ldd	r22, Y+1	; 0x01
    299a:	7a 81       	ldd	r23, Y+2	; 0x02
    299c:	8b 81       	ldd	r24, Y+3	; 0x03
    299e:	9c 81       	ldd	r25, Y+4	; 0x04
    29a0:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    29a4:	69 83       	std	Y+1, r22	; 0x01
    29a6:	7a 83       	std	Y+2, r23	; 0x02
    29a8:	8b 83       	std	Y+3, r24	; 0x03
    29aa:	9c 83       	std	Y+4, r25	; 0x04
			vFunc_Inf2pi(&predictedTheta);            
    29ac:	ce 01       	movw	r24, r28
    29ae:	01 96       	adiw	r24, 0x01	; 1
    29b0:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
            
            // Updated (a posteriori) estimate covariance
            covariance_filter_predicted = (1 - kalmanGain) * covariance_filter_predicted;  
    29b4:	2b 2d       	mov	r18, r11
    29b6:	3a 2d       	mov	r19, r10
    29b8:	49 2d       	mov	r20, r9
    29ba:	58 2d       	mov	r21, r8
    29bc:	60 e0       	ldi	r22, 0x00	; 0
    29be:	70 e0       	ldi	r23, 0x00	; 0
    29c0:	80 e8       	ldi	r24, 0x80	; 128
    29c2:	9f e3       	ldi	r25, 0x3F	; 63
    29c4:	0e 94 6b 30 	call	0x60d6	; 0x60d6 <__subsf3>
    29c8:	a7 01       	movw	r20, r14
    29ca:	96 01       	movw	r18, r12
    29cc:	0e 94 ed 32 	call	0x65da	; 0x65da <__mulsf3>
    29d0:	6e 8f       	std	Y+30, r22	; 0x1e
    29d2:	7f 8f       	std	Y+31, r23	; 0x1f
    29d4:	88 a3       	std	Y+32, r24	; 0x20
    29d6:	99 a3       	std	Y+33, r25	; 0x21
			if(predictedX!= gX_hat){
				debug("predictedx,predictedy,predictedtheta: %f,%f,%f",predictedX,predictedY,predictedTheta);
			}*/

            // Update pose
            xSemaphoreTake(xPoseMutex, 15 / portTICK_PERIOD_MS);
    29d8:	20 e0       	ldi	r18, 0x00	; 0
    29da:	4f e0       	ldi	r20, 0x0F	; 15
    29dc:	50 e0       	ldi	r21, 0x00	; 0
    29de:	60 e0       	ldi	r22, 0x00	; 0
    29e0:	70 e0       	ldi	r23, 0x00	; 0
    29e2:	80 91 4f 1b 	lds	r24, 0x1B4F	; 0x801b4f <xPoseMutex>
    29e6:	90 91 50 1b 	lds	r25, 0x1B50	; 0x801b50 <xPoseMutex+0x1>
    29ea:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
                gTheta_hat = predictedTheta;
    29ee:	89 81       	ldd	r24, Y+1	; 0x01
    29f0:	9a 81       	ldd	r25, Y+2	; 0x02
    29f2:	ab 81       	ldd	r26, Y+3	; 0x03
    29f4:	bc 81       	ldd	r27, Y+4	; 0x04
    29f6:	80 93 d9 19 	sts	0x19D9, r24	; 0x8019d9 <gTheta_hat>
    29fa:	90 93 da 19 	sts	0x19DA, r25	; 0x8019da <gTheta_hat+0x1>
    29fe:	a0 93 db 19 	sts	0x19DB, r26	; 0x8019db <gTheta_hat+0x2>
    2a02:	b0 93 dc 19 	sts	0x19DC, r27	; 0x8019dc <gTheta_hat+0x3>
                gX_hat = predictedX;
    2a06:	6b 89       	ldd	r22, Y+19	; 0x13
    2a08:	7c 89       	ldd	r23, Y+20	; 0x14
    2a0a:	8d 89       	ldd	r24, Y+21	; 0x15
    2a0c:	9e 89       	ldd	r25, Y+22	; 0x16
    2a0e:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
    2a12:	70 93 d8 19 	sts	0x19D8, r23	; 0x8019d8 <gX_hat+0x1>
    2a16:	60 93 d7 19 	sts	0x19D7, r22	; 0x8019d7 <gX_hat>
                gY_hat = predictedY;
    2a1a:	6f 89       	ldd	r22, Y+23	; 0x17
    2a1c:	78 8d       	ldd	r23, Y+24	; 0x18
    2a1e:	89 8d       	ldd	r24, Y+25	; 0x19
    2a20:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2a22:	0e 94 a1 31 	call	0x6342	; 0x6342 <__fixsfsi>
    2a26:	70 93 d6 19 	sts	0x19D6, r23	; 0x8019d6 <gY_hat+0x1>
    2a2a:	60 93 d5 19 	sts	0x19D5, r22	; 0x8019d5 <gY_hat>
				
            xSemaphoreGive(xPoseMutex);
    2a2e:	60 e0       	ldi	r22, 0x00	; 0
    2a30:	70 e0       	ldi	r23, 0x00	; 0
    2a32:	80 91 4f 1b 	lds	r24, 0x1B4F	; 0x801b4f <xPoseMutex>
    2a36:	90 91 50 1b 	lds	r25, 0x1B50	; 0x801b50 <xPoseMutex+0x1>
    2a3a:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
			
            // Send semaphore to controller
            xSemaphoreGive(xControllerBSem);
    2a3e:	60 e0       	ldi	r22, 0x00	; 0
    2a40:	70 e0       	ldi	r23, 0x00	; 0
    2a42:	80 91 47 1b 	lds	r24, 0x1B47	; 0x801b47 <xControllerBSem>
    2a46:	90 91 48 1b 	lds	r25, 0x1B48	; 0x801b48 <xControllerBSem+0x1>
    2a4a:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
            xSemaphoreGive(xTickMutex);

            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
    2a4e:	78 01       	movw	r14, r16
                rightWheelTicks = gRightWheelTicks;
            xSemaphoreGive(xTickMutex);

            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
    2a50:	43 01       	movw	r8, r6
    2a52:	65 ce       	rjmp	.-822    	; 0x271e <vMainPoseEstimatorTask+0x54>
    2a54:	05 e6       	ldi	r16, 0x65	; 101
    2a56:	10 e0       	ldi	r17, 0x00	; 0
    2a58:	a4 2c       	mov	r10, r4
    2a5a:	b3 2c       	mov	r11, r3
    2a5c:	c2 2c       	mov	r12, r2
    2a5e:	d5 2c       	mov	r13, r5
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
                gyro+= fIMU_readFloatGyroZ();
    2a60:	0e 94 ec 0b 	call	0x17d8	; 0x17d8 <fIMU_readFloatGyroZ>
    2a64:	9b 01       	movw	r18, r22
    2a66:	ac 01       	movw	r20, r24
    2a68:	6a 2d       	mov	r22, r10
    2a6a:	7b 2d       	mov	r23, r11
    2a6c:	8c 2d       	mov	r24, r12
    2a6e:	9d 2d       	mov	r25, r13
    2a70:	0e 94 6c 30 	call	0x60d8	; 0x60d8 <__addsf3>
    2a74:	a6 2e       	mov	r10, r22
    2a76:	b7 2e       	mov	r11, r23
    2a78:	c8 2e       	mov	r12, r24
    2a7a:	d9 2e       	mov	r13, r25
    2a7c:	01 50       	subi	r16, 0x01	; 1
    2a7e:	11 09       	sbc	r17, r1
        else{
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
    2a80:	79 f7       	brne	.-34     	; 0x2a60 <vMainPoseEstimatorTask+0x396>
                gyro+= fIMU_readFloatGyroZ();
            }
			gyroOffset = gyro / (float)i;   
    2a82:	20 e0       	ldi	r18, 0x00	; 0
    2a84:	30 e0       	ldi	r19, 0x00	; 0
    2a86:	4a ec       	ldi	r20, 0xCA	; 202
    2a88:	52 e4       	ldi	r21, 0x42	; 66
    2a8a:	0e 94 39 31 	call	0x6272	; 0x6272 <__divsf3>
    2a8e:	6b 87       	std	Y+11, r22	; 0x0b
    2a90:	7c 87       	std	Y+12, r23	; 0x0c
    2a92:	8d 87       	std	Y+13, r24	; 0x0d
    2a94:	9e 87       	std	Y+14, r25	; 0x0e
    2a96:	43 ce       	rjmp	.-890    	; 0x271e <vMainPoseEstimatorTask+0x54>

00002a98 <vApplicationStackOverflowHook>:
    } // While(1) end
}

/*  In case of stack overflow, disable all interrupts and handle it  */
void vApplicationStackOverflowHook(TaskHandle_t *pxTask, signed char *pcTaskName){
    cli();
    2a98:	f8 94       	cli
    /*  Handle overflow */
    #ifdef DEBUG
       debug("Overflow\n");
    #endif
    while(1){
        vLED_toggle(ledRED);
    2a9a:	80 e0       	ldi	r24, 0x00	; 0
    2a9c:	90 e0       	ldi	r25, 0x00	; 0
    2a9e:	0e 94 29 0c 	call	0x1852	; 0x1852 <vLED_toggle>
    2aa2:	fb cf       	rjmp	.-10     	; 0x2a9a <vApplicationStackOverflowHook+0x2>

00002aa4 <main>:

/*  Main function   */
int main(void){
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */
    vLED_init();
    2aa4:	0e 94 ef 0b 	call	0x17de	; 0x17de <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    2aa8:	80 e0       	ldi	r24, 0x00	; 0
    2aaa:	90 e0       	ldi	r25, 0x00	; 0
    2aac:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    2ab0:	0e 94 89 2f 	call	0x5f12	; 0x5f12 <vUSART_init>
    network_init();
    2ab4:	39 d2       	rcall	.+1138   	; 0x2f28 <network_init>
    arq_init();
    2ab6:	0e 94 43 01 	call	0x286	; 0x286 <arq_init>
    simple_p_init(server_receiver);
    2aba:	8b e8       	ldi	r24, 0x8B	; 139
    2abc:	90 e2       	ldi	r25, 0x20	; 32
    2abe:	0e 94 89 22 	call	0x4512	; 0x4512 <simple_p_init>
        debug("tictoc!\n");
        tic;
    #endif
    
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    2ac2:	80 e0       	ldi	r24, 0x00	; 0
    2ac4:	0e 94 01 22 	call	0x4402	; 0x4402 <vServo_init>
    /* Initialize sensors */
    vDistSens_init();
    2ac8:	0e 94 a5 07 	call	0xf4a	; 0xf4a <vDistSens_init>
    /* Initialize motor controller */
    vMotor_init();
    2acc:	ee d0       	rcall	.+476    	; 0x2caa <vMotor_init>
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        debug("IMU init..\n");
    #endif
    sIMU_begin(); 
    2ace:	0e 94 65 0a 	call	0x14ca	; 0x14ca <sIMU_begin>

	
    
    /* Initialize RTOS utilities  */

    poseControllerQ = xQueueCreate(1, sizeof(struct sCartesian)); // For setpoints to controller
    2ad2:	40 e0       	ldi	r20, 0x00	; 0
    2ad4:	68 e0       	ldi	r22, 0x08	; 8
    2ad6:	81 e0       	ldi	r24, 0x01	; 1
    2ad8:	3e d4       	rcall	.+2172   	; 0x3356 <xQueueGenericCreate>
    2ada:	90 93 e6 19 	sts	0x19E6, r25	; 0x8019e6 <poseControllerQ+0x1>
    2ade:	80 93 e5 19 	sts	0x19E5, r24	; 0x8019e5 <poseControllerQ>
    scanStatusQ = xQueueCreate(1,sizeof(uint8_t)); // For robot status
    2ae2:	40 e0       	ldi	r20, 0x00	; 0
    2ae4:	61 e0       	ldi	r22, 0x01	; 1
    2ae6:	81 e0       	ldi	r24, 0x01	; 1
    2ae8:	36 d4       	rcall	.+2156   	; 0x3356 <xQueueGenericCreate>
    2aea:	90 93 e4 19 	sts	0x19E4, r25	; 0x8019e4 <scanStatusQ+0x1>
    2aee:	80 93 e3 19 	sts	0x19E3, r24	; 0x8019e3 <scanStatusQ>
    actuationQ = xQueueCreate(2,sizeof(uint8_t)); // To send variable actuation to motors
    2af2:	40 e0       	ldi	r20, 0x00	; 0
    2af4:	61 e0       	ldi	r22, 0x01	; 1
    2af6:	82 e0       	ldi	r24, 0x02	; 2
    2af8:	2e d4       	rcall	.+2140   	; 0x3356 <xQueueGenericCreate>
    2afa:	90 93 e2 19 	sts	0x19E2, r25	; 0x8019e2 <actuationQ+0x1>
    2afe:	80 93 e1 19 	sts	0x19E1, r24	; 0x8019e1 <actuationQ>
    
    xPoseMutex = xSemaphoreCreateMutex(); // Global variables for robot pose. Only updated from estimator, accessed from many
    2b02:	81 e0       	ldi	r24, 0x01	; 1
    2b04:	7a d4       	rcall	.+2292   	; 0x33fa <xQueueCreateMutex>
    2b06:	90 93 50 1b 	sts	0x1B50, r25	; 0x801b50 <xPoseMutex+0x1>
    2b0a:	80 93 4f 1b 	sts	0x1B4F, r24	; 0x801b4f <xPoseMutex>
    xUartMutex = xSemaphoreCreateMutex(); // Protected printf with a mutex, may cause fragmented bytes if higher priority task want to print as well
    2b0e:	81 e0       	ldi	r24, 0x01	; 1
    2b10:	74 d4       	rcall	.+2280   	; 0x33fa <xQueueCreateMutex>
    2b12:	90 93 4c 1b 	sts	0x1B4C, r25	; 0x801b4c <xUartMutex+0x1>
    2b16:	80 93 4b 1b 	sts	0x1B4B, r24	; 0x801b4b <xUartMutex>
    xTickMutex = xSemaphoreCreateMutex(); // Global variable to hold robot tick values
    2b1a:	81 e0       	ldi	r24, 0x01	; 1
    2b1c:	6e d4       	rcall	.+2268   	; 0x33fa <xQueueCreateMutex>
    2b1e:	90 93 4a 1b 	sts	0x1B4A, r25	; 0x801b4a <xTickMutex+0x1>
    2b22:	80 93 49 1b 	sts	0x1B49, r24	; 0x801b49 <xTickMutex>
    
    xControllerBSem = xSemaphoreCreateBinary(); // Estimator to Controller synchronization
    2b26:	43 e0       	ldi	r20, 0x03	; 3
    2b28:	60 e0       	ldi	r22, 0x00	; 0
    2b2a:	81 e0       	ldi	r24, 0x01	; 1
    2b2c:	14 d4       	rcall	.+2088   	; 0x3356 <xQueueGenericCreate>
    2b2e:	90 93 48 1b 	sts	0x1B48, r25	; 0x801b48 <xControllerBSem+0x1>
    2b32:	80 93 47 1b 	sts	0x1B47, r24	; 0x801b47 <xControllerBSem>
    xCommandReadyBSem = xSemaphoreCreateBinary(); // uart ISR to comm task sync
    2b36:	43 e0       	ldi	r20, 0x03	; 3
    2b38:	60 e0       	ldi	r22, 0x00	; 0
    2b3a:	81 e0       	ldi	r24, 0x01	; 1
    2b3c:	0c d4       	rcall	.+2072   	; 0x3356 <xQueueGenericCreate>
    2b3e:	90 93 4e 1b 	sts	0x1B4E, r25	; 0x801b4e <xCommandReadyBSem+0x1>
    2b42:	80 93 4d 1b 	sts	0x1B4D, r24	; 0x801b4d <xCommandReadyBSem>
    2b46:	a1 2c       	mov	r10, r1
    
    // Todo: Check return variable to ensure RTOS utilities were successfully initialized before continue
    
    xTaskCreate(vMainCommunicationTask, "Comm", 300, NULL, 3, NULL); // Dependant on ISR from UART, sends instructions to other tasks
    2b48:	b1 2c       	mov	r11, r1
    2b4a:	c1 2c       	mov	r12, r1
    2b4c:	d1 2c       	mov	r13, r1
    2b4e:	e1 2c       	mov	r14, r1
    2b50:	f1 2c       	mov	r15, r1
    2b52:	03 e0       	ldi	r16, 0x03	; 3
    2b54:	20 e0       	ldi	r18, 0x00	; 0
    2b56:	30 e0       	ldi	r19, 0x00	; 0
    2b58:	4c e2       	ldi	r20, 0x2C	; 44
    2b5a:	51 e0       	ldi	r21, 0x01	; 1
    2b5c:	6c e3       	ldi	r22, 0x3C	; 60
    2b5e:	76 e0       	ldi	r23, 0x06	; 6
    2b60:	80 ed       	ldi	r24, 0xD0	; 208
    2b62:	9c e0       	ldi	r25, 0x0C	; 12
    2b64:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskGenericCreate>
    2b68:	02 e0       	ldi	r16, 0x02	; 2
    xTaskCreate(vMainPoseControllerTask, "PoseCon", 300, NULL, 2, NULL); // Dependant on estimator, sends instructions to movement task
    2b6a:	20 e0       	ldi	r18, 0x00	; 0
    2b6c:	30 e0       	ldi	r19, 0x00	; 0
    2b6e:	4c e2       	ldi	r20, 0x2C	; 44
    2b70:	51 e0       	ldi	r21, 0x01	; 1
    2b72:	61 e4       	ldi	r22, 0x41	; 65
    2b74:	76 e0       	ldi	r23, 0x06	; 6
    2b76:	8b ef       	ldi	r24, 0xFB	; 251
    2b78:	9e e0       	ldi	r25, 0x0E	; 14
    2b7a:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskGenericCreate>
    2b7e:	05 e0       	ldi	r16, 0x05	; 5
	xTaskCreate(vMainPoseEstimatorTask, "PoseEst", 300, NULL, 5, NULL); // Independent task, uses ticks from ISR
    2b80:	20 e0       	ldi	r18, 0x00	; 0
    2b82:	30 e0       	ldi	r19, 0x00	; 0
    2b84:	4c e2       	ldi	r20, 0x2C	; 44
    2b86:	51 e0       	ldi	r21, 0x01	; 1
    2b88:	69 e4       	ldi	r22, 0x49	; 73
    2b8a:	76 e0       	ldi	r23, 0x06	; 6
    2b8c:	85 e6       	ldi	r24, 0x65	; 101
    2b8e:	93 e1       	ldi	r25, 0x13	; 19
    2b90:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskGenericCreate>
    2b94:	01 e0       	ldi	r16, 0x01	; 1
    xTaskCreate(vMainSensorTowerTask,"Tower",300, NULL, 1, NULL); // Independent task, but use pose updates from estimator
    2b96:	20 e0       	ldi	r18, 0x00	; 0
    2b98:	30 e0       	ldi	r19, 0x00	; 0
    2b9a:	4c e2       	ldi	r20, 0x2C	; 44
    2b9c:	51 e0       	ldi	r21, 0x01	; 1
    2b9e:	61 e5       	ldi	r22, 0x51	; 81
    2ba0:	76 e0       	ldi	r23, 0x06	; 6
    2ba2:	83 e9       	ldi	r24, 0x93	; 147
    2ba4:	9d e0       	ldi	r25, 0x0D	; 13
    2ba6:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskGenericCreate>
    2baa:	78 94       	sei

    sei();
    2bac:	80 e0       	ldi	r24, 0x00	; 0
    vLED_singleLow(ledRED);
    2bae:	90 e0       	ldi	r25, 0x00	; 0
    2bb0:	0e 94 0f 0c 	call	0x181e	; 0x181e <vLED_singleLow>
    2bb4:	0e 94 66 27 	call	0x4ecc	; 0x4ecc <vTaskStartScheduler>
    #ifdef DEBUG
    debug("Starting scheduler ....\n");
    #endif
    /*  Start scheduler */
    vTaskStartScheduler();
    2bb8:	c7 e5       	ldi	r28, 0x57	; 87

    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
        debug("RAM fail\n");
    2bba:	d6 e0       	ldi	r29, 0x06	; 6
    2bbc:	f8 94       	cli
    /*  Start scheduler */
    vTaskStartScheduler();

    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
    2bbe:	df 93       	push	r29
        debug("RAM fail\n");
    2bc0:	cf 93       	push	r28
    2bc2:	0e 94 7d 21 	call	0x42fa	; 0x42fa <debug>
    2bc6:	0f 90       	pop	r0
    2bc8:	0f 90       	pop	r0
    2bca:	f8 cf       	rjmp	.-16     	; 0x2bbc <main+0x118>

00002bcc <__vector_3>:
    2bcc:	1f 92       	push	r1

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    2bce:	0f 92       	push	r0
    2bd0:	0f b6       	in	r0, 0x3f	; 63
    2bd2:	0f 92       	push	r0
    2bd4:	11 24       	eor	r1, r1
    2bd6:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    2bd8:	80 91 df 19 	lds	r24, 0x19DF	; 0x8019df <gISR_leftWheelTicks>
    2bdc:	8f 5f       	subi	r24, 0xFF	; 255
    2bde:	80 93 df 19 	sts	0x19DF, r24	; 0x8019df <gISR_leftWheelTicks>
}
    2be2:	8f 91       	pop	r24
    2be4:	0f 90       	pop	r0
    2be6:	0f be       	out	0x3f, r0	; 63
    2be8:	0f 90       	pop	r0
    2bea:	1f 90       	pop	r1
    2bec:	18 95       	reti

00002bee <__vector_4>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    2bee:	1f 92       	push	r1
    2bf0:	0f 92       	push	r0
    2bf2:	0f b6       	in	r0, 0x3f	; 63
    2bf4:	0f 92       	push	r0
    2bf6:	11 24       	eor	r1, r1
    2bf8:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    2bfa:	80 91 e0 19 	lds	r24, 0x19E0	; 0x8019e0 <gISR_rightWheelTicks>
    2bfe:	8f 5f       	subi	r24, 0xFF	; 255
    2c00:	80 93 e0 19 	sts	0x19E0, r24	; 0x8019e0 <gISR_rightWheelTicks>
}
    2c04:	8f 91       	pop	r24
    2c06:	0f 90       	pop	r0
    2c08:	0f be       	out	0x3f, r0	; 63
    2c0a:	0f 90       	pop	r0
    2c0c:	1f 90       	pop	r1
    2c0e:	18 95       	reti

00002c10 <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    2c10:	1f 92       	push	r1
    2c12:	0f 92       	push	r0
    2c14:	0f b6       	in	r0, 0x3f	; 63
    2c16:	0f 92       	push	r0
    2c18:	11 24       	eor	r1, r1
    2c1a:	0b b6       	in	r0, 0x3b	; 59
    2c1c:	0f 92       	push	r0
    2c1e:	2f 93       	push	r18
    2c20:	3f 93       	push	r19
    2c22:	4f 93       	push	r20
    2c24:	5f 93       	push	r21
    2c26:	6f 93       	push	r22
    2c28:	7f 93       	push	r23
    2c2a:	8f 93       	push	r24
    2c2c:	9f 93       	push	r25
    2c2e:	af 93       	push	r26
    2c30:	bf 93       	push	r27
    2c32:	ef 93       	push	r30
    2c34:	ff 93       	push	r31
    if (nRFconnected){
    2c36:	64 99       	sbic	0x0c, 4	; 12
    2c38:	05 c0       	rjmp	.+10     	; 0x2c44 <__vector_5+0x34>
        // indicate we are connected
        vLED_singleHigh(ledGREEN);
    2c3a:	82 e0       	ldi	r24, 0x02	; 2
    2c3c:	90 e0       	ldi	r25, 0x00	; 0
    2c3e:	0e 94 f5 0b 	call	0x17ea	; 0x17ea <vLED_singleHigh>
    2c42:	18 c0       	rjmp	.+48     	; 0x2c74 <__vector_5+0x64>
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    2c44:	10 92 de 19 	sts	0x19DE, r1	; 0x8019de <gHandshook>
        gPaused = FALSE;
    2c48:	10 92 dd 19 	sts	0x19DD, r1	; 0x8019dd <gPaused>
        vLED_singleLow(ledGREEN);
    2c4c:	82 e0       	ldi	r24, 0x02	; 2
    2c4e:	90 e0       	ldi	r25, 0x00	; 0
    2c50:	0e 94 0f 0c 	call	0x181e	; 0x181e <vLED_singleLow>
        vLED_singleLow(ledYELLOW);
    2c54:	81 e0       	ldi	r24, 0x01	; 1
    2c56:	90 e0       	ldi	r25, 0x00	; 0
    2c58:	0e 94 0f 0c 	call	0x181e	; 0x181e <vLED_singleLow>
        vLED_singleLow(ledRED);
    2c5c:	80 e0       	ldi	r24, 0x00	; 0
    2c5e:	90 e0       	ldi	r25, 0x00	; 0
    2c60:	0e 94 0f 0c 	call	0x181e	; 0x181e <vLED_singleLow>
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    2c64:	60 e0       	ldi	r22, 0x00	; 0
    2c66:	70 e0       	ldi	r23, 0x00	; 0
    2c68:	80 91 4d 1b 	lds	r24, 0x1B4D	; 0x801b4d <xCommandReadyBSem>
    2c6c:	90 91 4e 1b 	lds	r25, 0x1B4E	; 0x801b4e <xCommandReadyBSem+0x1>
    2c70:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <xQueueGiveFromISR>
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    2c74:	60 e0       	ldi	r22, 0x00	; 0
    2c76:	70 e0       	ldi	r23, 0x00	; 0
    2c78:	80 91 47 1b 	lds	r24, 0x1B47	; 0x801b47 <xControllerBSem>
    2c7c:	90 91 48 1b 	lds	r25, 0x1B48	; 0x801b48 <xControllerBSem+0x1>
    2c80:	0e 94 c0 1e 	call	0x3d80	; 0x3d80 <xQueueGiveFromISR>
}
    2c84:	ff 91       	pop	r31
    2c86:	ef 91       	pop	r30
    2c88:	bf 91       	pop	r27
    2c8a:	af 91       	pop	r26
    2c8c:	9f 91       	pop	r25
    2c8e:	8f 91       	pop	r24
    2c90:	7f 91       	pop	r23
    2c92:	6f 91       	pop	r22
    2c94:	5f 91       	pop	r21
    2c96:	4f 91       	pop	r20
    2c98:	3f 91       	pop	r19
    2c9a:	2f 91       	pop	r18
    2c9c:	0f 90       	pop	r0
    2c9e:	0b be       	out	0x3b, r0	; 59
    2ca0:	0f 90       	pop	r0
    2ca2:	0f be       	out	0x3f, r0	; 63
    2ca4:	0f 90       	pop	r0
    2ca6:	1f 90       	pop	r1
    2ca8:	18 95       	reti

00002caa <vMotor_init>:

void vMotorGlideRight(){
    motorRightPWM = 0;
    //PORTH &= ~(1<<motorRightOn);
    PORTH &= ~(1<<motorRightForward);
    PORTH &= ~(1<<motorRightBackward);
    2caa:	e1 e0       	ldi	r30, 0x01	; 1
    2cac:	f1 e0       	ldi	r31, 0x01	; 1
    2cae:	80 81       	ld	r24, Z
    2cb0:	80 63       	ori	r24, 0x30	; 48
    2cb2:	80 83       	st	Z, r24
    2cb4:	26 9a       	sbi	0x04, 6	; 4
    2cb6:	84 b1       	in	r24, 0x04	; 4
    2cb8:	80 66       	ori	r24, 0x60	; 96
    2cba:	84 b9       	out	0x04, r24	; 4
    2cbc:	27 9a       	sbi	0x04, 7	; 4
    2cbe:	2f 98       	cbi	0x05, 7	; 5
    2cc0:	2e 98       	cbi	0x05, 6	; 5
    2cc2:	85 b1       	in	r24, 0x05	; 5
    2cc4:	8f 79       	andi	r24, 0x9F	; 159
    2cc6:	85 b9       	out	0x05, r24	; 5
    2cc8:	e2 e0       	ldi	r30, 0x02	; 2
    2cca:	f1 e0       	ldi	r31, 0x01	; 1
    2ccc:	80 81       	ld	r24, Z
    2cce:	8f 7c       	andi	r24, 0xCF	; 207
    2cd0:	80 83       	st	Z, r24
    2cd2:	8a b1       	in	r24, 0x0a	; 10
    2cd4:	8a b9       	out	0x0a, r24	; 10
    2cd6:	8b b1       	in	r24, 0x0b	; 11
    2cd8:	8c 60       	ori	r24, 0x0C	; 12
    2cda:	8b b9       	out	0x0b, r24	; 11
    2cdc:	6c 98       	cbi	0x0d, 4	; 13
    2cde:	8d b3       	in	r24, 0x1d	; 29
    2ce0:	8d bb       	out	0x1d, r24	; 29
    2ce2:	e9 e6       	ldi	r30, 0x69	; 105
    2ce4:	f0 e0       	ldi	r31, 0x00	; 0
    2ce6:	80 81       	ld	r24, Z
    2ce8:	80 6f       	ori	r24, 0xF0	; 240
    2cea:	80 83       	st	Z, r24
    2cec:	ea e6       	ldi	r30, 0x6A	; 106
    2cee:	f0 e0       	ldi	r31, 0x00	; 0
    2cf0:	80 81       	ld	r24, Z
    2cf2:	81 60       	ori	r24, 0x01	; 1
    2cf4:	80 83       	st	Z, r24
    2cf6:	8c e1       	ldi	r24, 0x1C	; 28
    2cf8:	8c bb       	out	0x1c, r24	; 28
    2cfa:	8d b3       	in	r24, 0x1d	; 29
    2cfc:	8c 61       	ori	r24, 0x1C	; 28
    2cfe:	8d bb       	out	0x1d, r24	; 29
    2d00:	84 b5       	in	r24, 0x24	; 36
    2d02:	80 68       	ori	r24, 0x80	; 128
    2d04:	84 bd       	out	0x24, r24	; 36
    2d06:	e0 e8       	ldi	r30, 0x80	; 128
    2d08:	f0 e0       	ldi	r31, 0x00	; 0
    2d0a:	80 81       	ld	r24, Z
    2d0c:	80 62       	ori	r24, 0x20	; 32
    2d0e:	80 83       	st	Z, r24
    2d10:	84 b5       	in	r24, 0x24	; 36
    2d12:	83 60       	ori	r24, 0x03	; 3
    2d14:	84 bd       	out	0x24, r24	; 36
    2d16:	85 b5       	in	r24, 0x25	; 37
    2d18:	85 bd       	out	0x25, r24	; 37
    2d1a:	80 81       	ld	r24, Z
    2d1c:	81 60       	ori	r24, 0x01	; 1
    2d1e:	80 83       	st	Z, r24
    2d20:	a1 e8       	ldi	r26, 0x81	; 129
    2d22:	b0 e0       	ldi	r27, 0x00	; 0
    2d24:	8c 91       	ld	r24, X
    2d26:	88 60       	ori	r24, 0x08	; 8
    2d28:	8c 93       	st	X, r24
    2d2a:	85 b5       	in	r24, 0x25	; 37
    2d2c:	85 60       	ori	r24, 0x05	; 5
    2d2e:	85 bd       	out	0x25, r24	; 37
    2d30:	8c 91       	ld	r24, X
    2d32:	85 60       	ori	r24, 0x05	; 5
    2d34:	8c 93       	st	X, r24
    2d36:	80 81       	ld	r24, Z
    2d38:	80 83       	st	Z, r24
    2d3a:	e0 eb       	ldi	r30, 0xB0	; 176
    2d3c:	f0 e0       	ldi	r31, 0x00	; 0
    2d3e:	80 81       	ld	r24, Z
    2d40:	80 83       	st	Z, r24
    2d42:	80 81       	ld	r24, Z
    2d44:	80 83       	st	Z, r24
    2d46:	e0 ea       	ldi	r30, 0xA0	; 160
    2d48:	f0 e0       	ldi	r31, 0x00	; 0
    2d4a:	80 81       	ld	r24, Z
    2d4c:	80 83       	st	Z, r24
    2d4e:	08 95       	ret

00002d50 <vMotorMoveLeftForward>:
    2d50:	87 bd       	out	0x27, r24	; 39
    2d52:	2c 9a       	sbi	0x05, 4	; 5
    2d54:	2d 98       	cbi	0x05, 5	; 5
    2d56:	84 e0       	ldi	r24, 0x04	; 4
    2d58:	fb 01       	movw	r30, r22
    2d5a:	80 83       	st	Z, r24
    2d5c:	08 95       	ret

00002d5e <vMotorMoveRightForward>:
    2d5e:	90 e0       	ldi	r25, 0x00	; 0
    2d60:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    2d64:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    2d68:	e2 e0       	ldi	r30, 0x02	; 2
    2d6a:	f1 e0       	ldi	r31, 0x01	; 1
    2d6c:	80 81       	ld	r24, Z
    2d6e:	80 64       	ori	r24, 0x40	; 64
    2d70:	80 83       	st	Z, r24
    2d72:	80 81       	ld	r24, Z
    2d74:	8f 7d       	andi	r24, 0xDF	; 223
    2d76:	80 83       	st	Z, r24
    2d78:	86 e0       	ldi	r24, 0x06	; 6
    2d7a:	fb 01       	movw	r30, r22
    2d7c:	80 83       	st	Z, r24
    2d7e:	08 95       	ret

00002d80 <vMotorMoveLeftBackward>:
    2d80:	87 bd       	out	0x27, r24	; 39
    2d82:	2c 98       	cbi	0x05, 4	; 5
    2d84:	2d 9a       	sbi	0x05, 5	; 5
    2d86:	85 e0       	ldi	r24, 0x05	; 5
    2d88:	fb 01       	movw	r30, r22
    2d8a:	80 83       	st	Z, r24
    2d8c:	08 95       	ret

00002d8e <vMotorMoveRightBackward>:
    2d8e:	90 e0       	ldi	r25, 0x00	; 0
    2d90:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    2d94:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    2d98:	e2 e0       	ldi	r30, 0x02	; 2
    2d9a:	f1 e0       	ldi	r31, 0x01	; 1
    2d9c:	80 81       	ld	r24, Z
    2d9e:	8f 7b       	andi	r24, 0xBF	; 191
    2da0:	80 83       	st	Z, r24
    2da2:	80 81       	ld	r24, Z
    2da4:	80 62       	ori	r24, 0x20	; 32
    2da6:	80 83       	st	Z, r24
    2da8:	85 e0       	ldi	r24, 0x05	; 5
    2daa:	fb 01       	movw	r30, r22
    2dac:	80 83       	st	Z, r24
    2dae:	08 95       	ret

00002db0 <vMotorBrakeLeft>:
    2db0:	8f ef       	ldi	r24, 0xFF	; 255
    2db2:	87 bd       	out	0x27, r24	; 39
    2db4:	2c 98       	cbi	0x05, 4	; 5
    2db6:	2d 98       	cbi	0x05, 5	; 5
    2db8:	08 95       	ret

00002dba <vMotorBrakeRight>:
    2dba:	8f ef       	ldi	r24, 0xFF	; 255
    2dbc:	90 e0       	ldi	r25, 0x00	; 0
    2dbe:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    2dc2:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    2dc6:	e2 e0       	ldi	r30, 0x02	; 2
    2dc8:	f1 e0       	ldi	r31, 0x01	; 1
    2dca:	80 81       	ld	r24, Z
    2dcc:	8f 7b       	andi	r24, 0xBF	; 191
    2dce:	80 83       	st	Z, r24
    2dd0:	80 81       	ld	r24, Z
    2dd2:	8f 7d       	andi	r24, 0xDF	; 223
    2dd4:	80 83       	st	Z, r24
    2dd6:	08 95       	ret

00002dd8 <vMotorMovementSwitch>:
}

/* Switch for robot movement to abstract the logic away from main */

void vMotorMovementSwitch(int16_t leftSpeed, int16_t rightSpeed, uint8_t *leftWheelDirection, uint8_t *rightWheelDirection){
    2dd8:	0f 93       	push	r16
    2dda:	1f 93       	push	r17
    2ddc:	cf 93       	push	r28
    2dde:	df 93       	push	r29
    2de0:	eb 01       	movw	r28, r22
    2de2:	89 01       	movw	r16, r18
    if (leftSpeed > 0){
    2de4:	18 16       	cp	r1, r24
    2de6:	19 06       	cpc	r1, r25
    2de8:	1c f4       	brge	.+6      	; 0x2df0 <vMotorMovementSwitch+0x18>
		vMotorMoveLeftForward(leftSpeed, leftWheelDirection);
    2dea:	ba 01       	movw	r22, r20
    2dec:	b1 df       	rcall	.-158    	; 0x2d50 <vMotorMoveLeftForward>
    2dee:	07 c0       	rjmp	.+14     	; 0x2dfe <vMotorMovementSwitch+0x26>
    }else if(leftSpeed < 0){
    2df0:	99 23       	and	r25, r25
    2df2:	24 f4       	brge	.+8      	; 0x2dfc <vMotorMovementSwitch+0x24>
		vMotorMoveLeftBackward(-leftSpeed,leftWheelDirection);
    2df4:	ba 01       	movw	r22, r20
    2df6:	81 95       	neg	r24
    2df8:	c3 df       	rcall	.-122    	; 0x2d80 <vMotorMoveLeftBackward>
    }else{
		vMotorBrakeLeft();
    2dfa:	01 c0       	rjmp	.+2      	; 0x2dfe <vMotorMovementSwitch+0x26>
    2dfc:	d9 df       	rcall	.-78     	; 0x2db0 <vMotorBrakeLeft>
	}
	
	if (rightSpeed > 0) {
    2dfe:	1c 16       	cp	r1, r28
    2e00:	1d 06       	cpc	r1, r29
		vMotorMoveRightForward(rightSpeed,rightWheelDirection);
    2e02:	24 f4       	brge	.+8      	; 0x2e0c <vMotorMovementSwitch+0x34>
    2e04:	b8 01       	movw	r22, r16
    2e06:	8c 2f       	mov	r24, r28
    2e08:	aa df       	rcall	.-172    	; 0x2d5e <vMotorMoveRightForward>
    2e0a:	08 c0       	rjmp	.+16     	; 0x2e1c <vMotorMovementSwitch+0x44>
	}else if (rightSpeed < 0) {
    2e0c:	dd 23       	and	r29, r29
		vMotorMoveRightBackward(-rightSpeed,rightWheelDirection);
    2e0e:	2c f4       	brge	.+10     	; 0x2e1a <vMotorMovementSwitch+0x42>
    2e10:	b8 01       	movw	r22, r16
    2e12:	8c 2f       	mov	r24, r28
    2e14:	81 95       	neg	r24
    2e16:	bb df       	rcall	.-138    	; 0x2d8e <vMotorMoveRightBackward>
	}else {
		vMotorBrakeRight();
    2e18:	01 c0       	rjmp	.+2      	; 0x2e1c <vMotorMovementSwitch+0x44>
    2e1a:	cf df       	rcall	.-98     	; 0x2dba <vMotorBrakeRight>
	}
}
    2e1c:	df 91       	pop	r29
    2e1e:	cf 91       	pop	r28
    2e20:	1f 91       	pop	r17
    2e22:	0f 91       	pop	r16
    2e24:	08 95       	ret

00002e26 <vMotorEncoderLeftTickFromISR>:

/* Handle ISR ticks from encoder, Please note that we are losing accuracy here due to division */
void vMotorEncoderLeftTickFromISR(uint8_t wheelDirection, int16_t *leftWheelTicks, uint8_t leftEncoderTicks){
    switch (wheelDirection){
    2e26:	84 30       	cpi	r24, 0x04	; 4
    2e28:	19 f0       	breq	.+6      	; 0x2e30 <vMotorEncoderLeftTickFromISR+0xa>
    2e2a:	85 30       	cpi	r24, 0x05	; 5
    2e2c:	49 f0       	breq	.+18     	; 0x2e40 <vMotorEncoderLeftTickFromISR+0x1a>
    2e2e:	08 95       	ret
        case motorLeftForward:{
            *leftWheelTicks += leftEncoderTicks;
    2e30:	fb 01       	movw	r30, r22
    2e32:	80 81       	ld	r24, Z
    2e34:	91 81       	ldd	r25, Z+1	; 0x01
    2e36:	84 0f       	add	r24, r20
    2e38:	91 1d       	adc	r25, r1
    2e3a:	91 83       	std	Z+1, r25	; 0x01
    2e3c:	80 83       	st	Z, r24
            break;
    2e3e:	08 95       	ret
        }
        case  motorLeftBackward:{
            *leftWheelTicks -= leftEncoderTicks;
    2e40:	fb 01       	movw	r30, r22
    2e42:	80 81       	ld	r24, Z
    2e44:	91 81       	ldd	r25, Z+1	; 0x01
    2e46:	84 1b       	sub	r24, r20
    2e48:	91 09       	sbc	r25, r1
    2e4a:	91 83       	std	Z+1, r25	; 0x01
    2e4c:	80 83       	st	Z, r24
    2e4e:	08 95       	ret

00002e50 <vMotorEncoderRightTickFromISR>:
        // We have a count when the robot is supposedly not moving.
        break;
    }
}
void vMotorEncoderRightTickFromISR(uint8_t wheelDirection, int16_t *rightWheelTicks, uint8_t rightEncoderTicks){
    switch (wheelDirection){
    2e50:	85 30       	cpi	r24, 0x05	; 5
    2e52:	51 f0       	breq	.+20     	; 0x2e68 <vMotorEncoderRightTickFromISR+0x18>
    2e54:	86 30       	cpi	r24, 0x06	; 6
    2e56:	79 f4       	brne	.+30     	; 0x2e76 <vMotorEncoderRightTickFromISR+0x26>
        case motorRightForward:{
            *rightWheelTicks += rightEncoderTicks;
    2e58:	fb 01       	movw	r30, r22
    2e5a:	80 81       	ld	r24, Z
    2e5c:	91 81       	ldd	r25, Z+1	; 0x01
    2e5e:	84 0f       	add	r24, r20
    2e60:	91 1d       	adc	r25, r1
    2e62:	91 83       	std	Z+1, r25	; 0x01
    2e64:	80 83       	st	Z, r24
            break;
    2e66:	08 95       	ret
        }
        case  motorRightBackward:{
            *rightWheelTicks -= rightEncoderTicks;
    2e68:	fb 01       	movw	r30, r22
    2e6a:	80 81       	ld	r24, Z
    2e6c:	91 81       	ldd	r25, Z+1	; 0x01
    2e6e:	84 1b       	sub	r24, r20
    2e70:	91 09       	sbc	r25, r1
    2e72:	91 83       	std	Z+1, r25	; 0x01
    2e74:	80 83       	st	Z, r24
    2e76:	08 95       	ret

00002e78 <network_receive>:

uint8_t network_get_address(void) {
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
    2e78:	ef 92       	push	r14
    2e7a:	ff 92       	push	r15
    2e7c:	0f 93       	push	r16
    2e7e:	1f 93       	push	r17
    2e80:	cf 93       	push	r28
    2e82:	df 93       	push	r29
    2e84:	7c 01       	movw	r14, r24
    2e86:	8b 01       	movw	r16, r22
   uint8_t *decoded_data = pvPortMalloc(len);
    2e88:	cb 01       	movw	r24, r22
    2e8a:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    2e8e:	ec 01       	movw	r28, r24
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    2e90:	98 01       	movw	r18, r16
    2e92:	21 50       	subi	r18, 0x01	; 1
    2e94:	31 09       	sbc	r19, r1
    2e96:	a7 01       	movw	r20, r14
    2e98:	b8 01       	movw	r22, r16
    2e9a:	0e 94 04 07 	call	0xe08	; 0xe08 <cobs_decode>
   static uint8_t cobs = 0;
   static uint8_t crc = 0;
   if(result.status != COBS_DECODE_OK) {
    2e9e:	88 23       	and	r24, r24
    2ea0:	49 f0       	breq	.+18     	; 0x2eb4 <network_receive+0x3c>
	   ++cobs;
    2ea2:	80 91 e8 19 	lds	r24, 0x19E8	; 0x8019e8 <cobs.2024>
    2ea6:	8f 5f       	subi	r24, 0xFF	; 255
    2ea8:	80 93 e8 19 	sts	0x19E8, r24	; 0x8019e8 <cobs.2024>
	   vPortFree(decoded_data);
    2eac:	ce 01       	movw	r24, r28
    2eae:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
	   return;
    2eb2:	33 c0       	rjmp	.+102    	; 0x2f1a <network_receive+0xa2>
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
   uint8_t *decoded_data = pvPortMalloc(len);
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    2eb4:	86 2f       	mov	r24, r22
    2eb6:	97 2f       	mov	r25, r23
    2eb8:	8c 01       	movw	r16, r24
   if(result.status != COBS_DECODE_OK) {
	   ++cobs;
	   vPortFree(decoded_data);
	   return;
   }
   if(decoded_data[result.out_len-1] != calculate_crc(decoded_data, result.out_len-1) ) {
    2eba:	fe 01       	movw	r30, r28
    2ebc:	e8 0f       	add	r30, r24
    2ebe:	f9 1f       	adc	r31, r25
    2ec0:	31 97       	sbiw	r30, 0x01	; 1
    2ec2:	f0 80       	ld	r15, Z
    2ec4:	6f ef       	ldi	r22, 0xFF	; 255
    2ec6:	68 0f       	add	r22, r24
    2ec8:	ce 01       	movw	r24, r28
    2eca:	0e 94 8e 07 	call	0xf1c	; 0xf1c <calculate_crc>
    2ece:	f8 16       	cp	r15, r24
    2ed0:	49 f0       	breq	.+18     	; 0x2ee4 <network_receive+0x6c>
	   ++crc;
    2ed2:	80 91 e7 19 	lds	r24, 0x19E7	; 0x8019e7 <crc.2025>
    2ed6:	8f 5f       	subi	r24, 0xFF	; 255
    2ed8:	80 93 e7 19 	sts	0x19E7, r24	; 0x8019e7 <crc.2025>
	   vPortFree(decoded_data);
    2edc:	ce 01       	movw	r24, r28
    2ede:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
	   return;
    2ee2:	1b c0       	rjmp	.+54     	; 0x2f1a <network_receive+0xa2>
   }
   uint8_t receiver = decoded_data[0];
   uint8_t sender = decoded_data[1];
   uint8_t protocol = decoded_data[2];
   if(receiver != ADDRESS) {
    2ee4:	88 81       	ld	r24, Y
    2ee6:	83 30       	cpi	r24, 0x03	; 3
    2ee8:	21 f0       	breq	.+8      	; 0x2ef2 <network_receive+0x7a>
	   vPortFree(decoded_data);
    2eea:	ce 01       	movw	r24, r28
    2eec:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
	   return;
    2ef0:	14 c0       	rjmp	.+40     	; 0x2f1a <network_receive+0xa2>
   }
   receive_callbacks[protocol](sender, decoded_data+3, result.out_len-4);
    2ef2:	a8 01       	movw	r20, r16
    2ef4:	44 50       	subi	r20, 0x04	; 4
    2ef6:	51 09       	sbc	r21, r1
    2ef8:	be 01       	movw	r22, r28
    2efa:	6d 5f       	subi	r22, 0xFD	; 253
    2efc:	7f 4f       	sbci	r23, 0xFF	; 255
    2efe:	ea 81       	ldd	r30, Y+2	; 0x02
    2f00:	f0 e0       	ldi	r31, 0x00	; 0
    2f02:	ee 0f       	add	r30, r30
    2f04:	ff 1f       	adc	r31, r31
    2f06:	e5 59       	subi	r30, 0x95	; 149
    2f08:	f4 4e       	sbci	r31, 0xE4	; 228
    2f0a:	01 90       	ld	r0, Z+
    2f0c:	f0 81       	ld	r31, Z
    2f0e:	e0 2d       	mov	r30, r0
    2f10:	89 81       	ldd	r24, Y+1	; 0x01
    2f12:	19 95       	eicall
   vPortFree(decoded_data);
    2f14:	ce 01       	movw	r24, r28
    2f16:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
}
    2f1a:	df 91       	pop	r29
    2f1c:	cf 91       	pop	r28
    2f1e:	1f 91       	pop	r17
    2f20:	0f 91       	pop	r16
    2f22:	ff 90       	pop	r15
    2f24:	ef 90       	pop	r14
    2f26:	08 95       	ret

00002f28 <network_init>:
void network_receive(uint8_t *frame, uint16_t len);

void (*receive_callbacks[10])(uint8_t, uint8_t*, uint16_t);

void network_init(void) {
  vUSART_set_receive_callback(network_receive);
    2f28:	8c e3       	ldi	r24, 0x3C	; 60
    2f2a:	97 e1       	ldi	r25, 0x17	; 23
    2f2c:	0c 94 fa 2f 	jmp	0x5ff4	; 0x5ff4 <vUSART_set_receive_callback>
    2f30:	08 95       	ret

00002f32 <network_set_callback>:
}

void network_set_callback(uint8_t protocol, void (*cb)(uint8_t, uint8_t*, uint16_t)) {
  if(protocol == PROTOCOL_ARQ || protocol == PROTOCOL_SIMPLE) receive_callbacks[protocol] = cb;
    2f32:	82 30       	cpi	r24, 0x02	; 2
    2f34:	40 f4       	brcc	.+16     	; 0x2f46 <network_set_callback+0x14>
    2f36:	e8 2f       	mov	r30, r24
    2f38:	f0 e0       	ldi	r31, 0x00	; 0
    2f3a:	ee 0f       	add	r30, r30
    2f3c:	ff 1f       	adc	r31, r31
    2f3e:	e5 59       	subi	r30, 0x95	; 149
    2f40:	f4 4e       	sbci	r31, 0xE4	; 228
    2f42:	71 83       	std	Z+1, r23	; 0x01
    2f44:	60 83       	st	Z, r22
    2f46:	08 95       	ret

00002f48 <network_send>:
}
    
uint8_t network_send(uint8_t remote_address, uint8_t protocol, uint8_t *data, uint16_t len) {
    2f48:	8f 92       	push	r8
    2f4a:	9f 92       	push	r9
    2f4c:	af 92       	push	r10
    2f4e:	bf 92       	push	r11
    2f50:	cf 92       	push	r12
    2f52:	df 92       	push	r13
    2f54:	ef 92       	push	r14
    2f56:	ff 92       	push	r15
    2f58:	0f 93       	push	r16
    2f5a:	1f 93       	push	r17
    2f5c:	cf 93       	push	r28
    2f5e:	df 93       	push	r29
    2f60:	88 2e       	mov	r8, r24
    2f62:	96 2e       	mov	r9, r22
    2f64:	5a 01       	movw	r10, r20
    2f66:	89 01       	movw	r16, r18
  uint8_t *packet = pvPortMalloc(len+4);
    2f68:	69 01       	movw	r12, r18
    2f6a:	84 e0       	ldi	r24, 0x04	; 4
    2f6c:	c8 0e       	add	r12, r24
    2f6e:	d1 1c       	adc	r13, r1
    2f70:	c6 01       	movw	r24, r12
    2f72:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    2f76:	ec 01       	movw	r28, r24
  uint8_t *encoded_data = pvPortMalloc(len+6);
    2f78:	c8 01       	movw	r24, r16
    2f7a:	06 96       	adiw	r24, 0x06	; 6
    2f7c:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    2f80:	7c 01       	movw	r14, r24
  if(packet == NULL || encoded_data == NULL) {
    2f82:	20 97       	sbiw	r28, 0x00	; 0
    2f84:	11 f0       	breq	.+4      	; 0x2f8a <network_send+0x42>
    2f86:	89 2b       	or	r24, r25
    2f88:	41 f4       	brne	.+16     	; 0x2f9a <network_send+0x52>
    vPortFree(packet);
    2f8a:	ce 01       	movw	r24, r28
    2f8c:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    vPortFree(encoded_data);
    2f90:	c7 01       	movw	r24, r14
    2f92:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    return 0;
    2f96:	80 e0       	ldi	r24, 0x00	; 0
    2f98:	3c c0       	rjmp	.+120    	; 0x3012 <network_send+0xca>
  }
  packet[0] = remote_address;
    2f9a:	88 82       	st	Y, r8
  packet[1] = ADDRESS;
    2f9c:	83 e0       	ldi	r24, 0x03	; 3
    2f9e:	89 83       	std	Y+1, r24	; 0x01
  packet[2] = protocol;
    2fa0:	9a 82       	std	Y+2, r9	; 0x02
  memcpy(packet+3, data, len);
    2fa2:	a8 01       	movw	r20, r16
    2fa4:	b5 01       	movw	r22, r10
    2fa6:	ce 01       	movw	r24, r28
    2fa8:	03 96       	adiw	r24, 0x03	; 3
    2faa:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
  packet[3+len] = calculate_crc(packet, 3+len);
    2fae:	58 01       	movw	r10, r16
    2fb0:	e3 e0       	ldi	r30, 0x03	; 3
    2fb2:	ae 0e       	add	r10, r30
    2fb4:	b1 1c       	adc	r11, r1
    2fb6:	ac 0e       	add	r10, r28
    2fb8:	bd 1e       	adc	r11, r29
    2fba:	63 e0       	ldi	r22, 0x03	; 3
    2fbc:	60 0f       	add	r22, r16
    2fbe:	ce 01       	movw	r24, r28
    2fc0:	0e 94 8e 07 	call	0xf1c	; 0xf1c <calculate_crc>
    2fc4:	f5 01       	movw	r30, r10
    2fc6:	80 83       	st	Z, r24
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    2fc8:	b8 01       	movw	r22, r16
    2fca:	6b 5f       	subi	r22, 0xFB	; 251
    2fcc:	7f 4f       	sbci	r23, 0xFF	; 255
    2fce:	96 01       	movw	r18, r12
    2fd0:	ae 01       	movw	r20, r28
    2fd2:	c7 01       	movw	r24, r14
    2fd4:	0e 94 9e 06 	call	0xd3c	; 0xd3c <cobs_encode>
  if(result.status != COBS_ENCODE_OK) {
    2fd8:	88 23       	and	r24, r24
    2fda:	41 f0       	breq	.+16     	; 0x2fec <network_send+0xa4>
    vPortFree(packet);
    2fdc:	ce 01       	movw	r24, r28
    2fde:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    vPortFree(encoded_data);
    2fe2:	c7 01       	movw	r24, r14
    2fe4:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    return 0;
    2fe8:	80 e0       	ldi	r24, 0x00	; 0
    2fea:	13 c0       	rjmp	.+38     	; 0x3012 <network_send+0xca>
  packet[0] = remote_address;
  packet[1] = ADDRESS;
  packet[2] = protocol;
  memcpy(packet+3, data, len);
  packet[3+len] = calculate_crc(packet, 3+len);
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    2fec:	86 2f       	mov	r24, r22
    2fee:	97 2f       	mov	r25, r23
  if(result.status != COBS_ENCODE_OK) {
    vPortFree(packet);
    vPortFree(encoded_data);
    return 0;
  }
  encoded_data[result.out_len] = 0x00;
    2ff0:	f7 01       	movw	r30, r14
    2ff2:	e8 0f       	add	r30, r24
    2ff4:	f9 1f       	adc	r31, r25
    2ff6:	10 82       	st	Z, r1
  vUSART_send(encoded_data, result.out_len+1);
    2ff8:	bc 01       	movw	r22, r24
    2ffa:	6f 5f       	subi	r22, 0xFF	; 255
    2ffc:	7f 4f       	sbci	r23, 0xFF	; 255
    2ffe:	c7 01       	movw	r24, r14
    3000:	0e 94 d6 2f 	call	0x5fac	; 0x5fac <vUSART_send>
  vPortFree(packet);
    3004:	ce 01       	movw	r24, r28
    3006:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  vPortFree(encoded_data);
    300a:	c7 01       	movw	r24, r14
    300c:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  return 1;
    3010:	81 e0       	ldi	r24, 0x01	; 1
}
    3012:	df 91       	pop	r29
    3014:	cf 91       	pop	r28
    3016:	1f 91       	pop	r17
    3018:	0f 91       	pop	r16
    301a:	ff 90       	pop	r15
    301c:	ef 90       	pop	r14
    301e:	df 90       	pop	r13
    3020:	cf 90       	pop	r12
    3022:	bf 90       	pop	r11
    3024:	af 90       	pop	r10
    3026:	9f 90       	pop	r9
    3028:	8f 90       	pop	r8
    302a:	08 95       	ret

0000302c <pxPortInitialiseStack>:
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    302c:	31 e1       	ldi	r19, 0x11	; 17
    302e:	fc 01       	movw	r30, r24
    3030:	30 83       	st	Z, r19
    3032:	31 97       	sbiw	r30, 0x01	; 1
    3034:	22 e2       	ldi	r18, 0x22	; 34
    3036:	20 83       	st	Z, r18
    3038:	31 97       	sbiw	r30, 0x01	; 1
    303a:	a3 e3       	ldi	r26, 0x33	; 51
    303c:	a0 83       	st	Z, r26
    303e:	31 97       	sbiw	r30, 0x01	; 1
    3040:	60 83       	st	Z, r22
    3042:	31 97       	sbiw	r30, 0x01	; 1
    3044:	70 83       	st	Z, r23
    3046:	31 97       	sbiw	r30, 0x01	; 1
    3048:	10 82       	st	Z, r1
    304a:	31 97       	sbiw	r30, 0x01	; 1
    304c:	10 82       	st	Z, r1
    304e:	31 97       	sbiw	r30, 0x01	; 1
    3050:	60 e8       	ldi	r22, 0x80	; 128
    3052:	60 83       	st	Z, r22
    3054:	31 97       	sbiw	r30, 0x01	; 1
    3056:	10 82       	st	Z, r1
    3058:	31 97       	sbiw	r30, 0x01	; 1
    305a:	10 82       	st	Z, r1
    305c:	31 97       	sbiw	r30, 0x01	; 1
    305e:	10 82       	st	Z, r1
    3060:	31 97       	sbiw	r30, 0x01	; 1
    3062:	62 e0       	ldi	r22, 0x02	; 2
    3064:	60 83       	st	Z, r22
    3066:	31 97       	sbiw	r30, 0x01	; 1
    3068:	63 e0       	ldi	r22, 0x03	; 3
    306a:	60 83       	st	Z, r22
    306c:	31 97       	sbiw	r30, 0x01	; 1
    306e:	64 e0       	ldi	r22, 0x04	; 4
    3070:	60 83       	st	Z, r22
    3072:	31 97       	sbiw	r30, 0x01	; 1
    3074:	65 e0       	ldi	r22, 0x05	; 5
    3076:	60 83       	st	Z, r22
    3078:	31 97       	sbiw	r30, 0x01	; 1
    307a:	66 e0       	ldi	r22, 0x06	; 6
    307c:	60 83       	st	Z, r22
    307e:	31 97       	sbiw	r30, 0x01	; 1
    3080:	67 e0       	ldi	r22, 0x07	; 7
    3082:	60 83       	st	Z, r22
    3084:	31 97       	sbiw	r30, 0x01	; 1
    3086:	68 e0       	ldi	r22, 0x08	; 8
    3088:	60 83       	st	Z, r22
    308a:	31 97       	sbiw	r30, 0x01	; 1
    308c:	69 e0       	ldi	r22, 0x09	; 9
    308e:	60 83       	st	Z, r22
    3090:	31 97       	sbiw	r30, 0x01	; 1
    3092:	60 e1       	ldi	r22, 0x10	; 16
    3094:	60 83       	st	Z, r22
    3096:	31 97       	sbiw	r30, 0x01	; 1
    3098:	30 83       	st	Z, r19
    309a:	31 97       	sbiw	r30, 0x01	; 1
    309c:	32 e1       	ldi	r19, 0x12	; 18
    309e:	30 83       	st	Z, r19
    30a0:	31 97       	sbiw	r30, 0x01	; 1
    30a2:	33 e1       	ldi	r19, 0x13	; 19
    30a4:	30 83       	st	Z, r19
    30a6:	31 97       	sbiw	r30, 0x01	; 1
    30a8:	34 e1       	ldi	r19, 0x14	; 20
    30aa:	30 83       	st	Z, r19
    30ac:	31 97       	sbiw	r30, 0x01	; 1
    30ae:	35 e1       	ldi	r19, 0x15	; 21
    30b0:	30 83       	st	Z, r19
    30b2:	31 97       	sbiw	r30, 0x01	; 1
    30b4:	36 e1       	ldi	r19, 0x16	; 22
    30b6:	30 83       	st	Z, r19
    30b8:	31 97       	sbiw	r30, 0x01	; 1
    30ba:	37 e1       	ldi	r19, 0x17	; 23
    30bc:	30 83       	st	Z, r19
    30be:	31 97       	sbiw	r30, 0x01	; 1
    30c0:	38 e1       	ldi	r19, 0x18	; 24
    30c2:	30 83       	st	Z, r19
    30c4:	31 97       	sbiw	r30, 0x01	; 1
    30c6:	39 e1       	ldi	r19, 0x19	; 25
    30c8:	30 83       	st	Z, r19
    30ca:	31 97       	sbiw	r30, 0x01	; 1
    30cc:	30 e2       	ldi	r19, 0x20	; 32
    30ce:	30 83       	st	Z, r19
    30d0:	31 97       	sbiw	r30, 0x01	; 1
    30d2:	31 e2       	ldi	r19, 0x21	; 33
    30d4:	30 83       	st	Z, r19
    30d6:	31 97       	sbiw	r30, 0x01	; 1
    30d8:	20 83       	st	Z, r18
    30da:	31 97       	sbiw	r30, 0x01	; 1
    30dc:	23 e2       	ldi	r18, 0x23	; 35
    30de:	20 83       	st	Z, r18
    30e0:	31 97       	sbiw	r30, 0x01	; 1
    30e2:	40 83       	st	Z, r20
    30e4:	31 97       	sbiw	r30, 0x01	; 1
    30e6:	50 83       	st	Z, r21
    30e8:	31 97       	sbiw	r30, 0x01	; 1
    30ea:	26 e2       	ldi	r18, 0x26	; 38
    30ec:	20 83       	st	Z, r18
    30ee:	31 97       	sbiw	r30, 0x01	; 1
    30f0:	27 e2       	ldi	r18, 0x27	; 39
    30f2:	20 83       	st	Z, r18
    30f4:	31 97       	sbiw	r30, 0x01	; 1
    30f6:	28 e2       	ldi	r18, 0x28	; 40
    30f8:	20 83       	st	Z, r18
    30fa:	31 97       	sbiw	r30, 0x01	; 1
    30fc:	29 e2       	ldi	r18, 0x29	; 41
    30fe:	20 83       	st	Z, r18
    3100:	31 97       	sbiw	r30, 0x01	; 1
    3102:	20 e3       	ldi	r18, 0x30	; 48
    3104:	20 83       	st	Z, r18
    3106:	31 97       	sbiw	r30, 0x01	; 1
    3108:	21 e3       	ldi	r18, 0x31	; 49
    310a:	20 83       	st	Z, r18
    310c:	89 97       	sbiw	r24, 0x29	; 41
    310e:	08 95       	ret

00003110 <xPortStartScheduler>:
    3110:	88 ee       	ldi	r24, 0xE8	; 232
    3112:	93 e0       	ldi	r25, 0x03	; 3
    3114:	90 93 80 1b 	sts	0x1B80, r25	; 0x801b80 <portTickRateHz+0x1>
    3118:	80 93 7f 1b 	sts	0x1B7F, r24	; 0x801b7f <portTickRateHz>
    311c:	90 93 82 1b 	sts	0x1B82, r25	; 0x801b82 <ticksRemainingInSec+0x1>
    3120:	80 93 81 1b 	sts	0x1B81, r24	; 0x801b81 <ticksRemainingInSec>
    3124:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    3128:	89 ef       	ldi	r24, 0xF9	; 249
    312a:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
    312e:	8b e0       	ldi	r24, 0x0B	; 11
    3130:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    3134:	e1 e7       	ldi	r30, 0x71	; 113
    3136:	f0 e0       	ldi	r31, 0x00	; 0
    3138:	80 81       	ld	r24, Z
    313a:	82 60       	ori	r24, 0x02	; 2
    313c:	80 83       	st	Z, r24
    313e:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    3142:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    3146:	cd 91       	ld	r28, X+
    3148:	cd bf       	out	0x3d, r28	; 61
    314a:	dd 91       	ld	r29, X+
    314c:	de bf       	out	0x3e, r29	; 62
    314e:	ff 91       	pop	r31
    3150:	ef 91       	pop	r30
    3152:	df 91       	pop	r29
    3154:	cf 91       	pop	r28
    3156:	bf 91       	pop	r27
    3158:	af 91       	pop	r26
    315a:	9f 91       	pop	r25
    315c:	8f 91       	pop	r24
    315e:	7f 91       	pop	r23
    3160:	6f 91       	pop	r22
    3162:	5f 91       	pop	r21
    3164:	4f 91       	pop	r20
    3166:	3f 91       	pop	r19
    3168:	2f 91       	pop	r18
    316a:	1f 91       	pop	r17
    316c:	0f 91       	pop	r16
    316e:	ff 90       	pop	r15
    3170:	ef 90       	pop	r14
    3172:	df 90       	pop	r13
    3174:	cf 90       	pop	r12
    3176:	bf 90       	pop	r11
    3178:	af 90       	pop	r10
    317a:	9f 90       	pop	r9
    317c:	8f 90       	pop	r8
    317e:	7f 90       	pop	r7
    3180:	6f 90       	pop	r6
    3182:	5f 90       	pop	r5
    3184:	4f 90       	pop	r4
    3186:	3f 90       	pop	r3
    3188:	2f 90       	pop	r2
    318a:	1f 90       	pop	r1
    318c:	0f 90       	pop	r0
    318e:	0c be       	out	0x3c, r0	; 60
    3190:	0f 90       	pop	r0
    3192:	0b be       	out	0x3b, r0	; 59
    3194:	0f 90       	pop	r0
    3196:	0f be       	out	0x3f, r0	; 63
    3198:	0f 90       	pop	r0
    319a:	08 95       	ret
    319c:	81 e0       	ldi	r24, 0x01	; 1
    319e:	08 95       	ret

000031a0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    31a0:	0f 92       	push	r0
    31a2:	0f b6       	in	r0, 0x3f	; 63
    31a4:	f8 94       	cli
    31a6:	0f 92       	push	r0
    31a8:	0b b6       	in	r0, 0x3b	; 59
    31aa:	0f 92       	push	r0
    31ac:	0c b6       	in	r0, 0x3c	; 60
    31ae:	0f 92       	push	r0
    31b0:	1f 92       	push	r1
    31b2:	11 24       	eor	r1, r1
    31b4:	2f 92       	push	r2
    31b6:	3f 92       	push	r3
    31b8:	4f 92       	push	r4
    31ba:	5f 92       	push	r5
    31bc:	6f 92       	push	r6
    31be:	7f 92       	push	r7
    31c0:	8f 92       	push	r8
    31c2:	9f 92       	push	r9
    31c4:	af 92       	push	r10
    31c6:	bf 92       	push	r11
    31c8:	cf 92       	push	r12
    31ca:	df 92       	push	r13
    31cc:	ef 92       	push	r14
    31ce:	ff 92       	push	r15
    31d0:	0f 93       	push	r16
    31d2:	1f 93       	push	r17
    31d4:	2f 93       	push	r18
    31d6:	3f 93       	push	r19
    31d8:	4f 93       	push	r20
    31da:	5f 93       	push	r21
    31dc:	6f 93       	push	r22
    31de:	7f 93       	push	r23
    31e0:	8f 93       	push	r24
    31e2:	9f 93       	push	r25
    31e4:	af 93       	push	r26
    31e6:	bf 93       	push	r27
    31e8:	cf 93       	push	r28
    31ea:	df 93       	push	r29
    31ec:	ef 93       	push	r30
    31ee:	ff 93       	push	r31
    31f0:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    31f4:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    31f8:	0d b6       	in	r0, 0x3d	; 61
    31fa:	0d 92       	st	X+, r0
    31fc:	0e b6       	in	r0, 0x3e	; 62
    31fe:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3200:	0e 94 56 2a 	call	0x54ac	; 0x54ac <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3204:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    3208:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    320c:	cd 91       	ld	r28, X+
    320e:	cd bf       	out	0x3d, r28	; 61
    3210:	dd 91       	ld	r29, X+
    3212:	de bf       	out	0x3e, r29	; 62
    3214:	ff 91       	pop	r31
    3216:	ef 91       	pop	r30
    3218:	df 91       	pop	r29
    321a:	cf 91       	pop	r28
    321c:	bf 91       	pop	r27
    321e:	af 91       	pop	r26
    3220:	9f 91       	pop	r25
    3222:	8f 91       	pop	r24
    3224:	7f 91       	pop	r23
    3226:	6f 91       	pop	r22
    3228:	5f 91       	pop	r21
    322a:	4f 91       	pop	r20
    322c:	3f 91       	pop	r19
    322e:	2f 91       	pop	r18
    3230:	1f 91       	pop	r17
    3232:	0f 91       	pop	r16
    3234:	ff 90       	pop	r15
    3236:	ef 90       	pop	r14
    3238:	df 90       	pop	r13
    323a:	cf 90       	pop	r12
    323c:	bf 90       	pop	r11
    323e:	af 90       	pop	r10
    3240:	9f 90       	pop	r9
    3242:	8f 90       	pop	r8
    3244:	7f 90       	pop	r7
    3246:	6f 90       	pop	r6
    3248:	5f 90       	pop	r5
    324a:	4f 90       	pop	r4
    324c:	3f 90       	pop	r3
    324e:	2f 90       	pop	r2
    3250:	1f 90       	pop	r1
    3252:	0f 90       	pop	r0
    3254:	0c be       	out	0x3c, r0	; 60
    3256:	0f 90       	pop	r0
    3258:	0b be       	out	0x3b, r0	; 59
    325a:	0f 90       	pop	r0
    325c:	0f be       	out	0x3f, r0	; 63
    325e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3260:	08 95       	ret

00003262 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3262:	0f 92       	push	r0
    3264:	0f b6       	in	r0, 0x3f	; 63
    3266:	f8 94       	cli
    3268:	0f 92       	push	r0
    326a:	0b b6       	in	r0, 0x3b	; 59
    326c:	0f 92       	push	r0
    326e:	0c b6       	in	r0, 0x3c	; 60
    3270:	0f 92       	push	r0
    3272:	1f 92       	push	r1
    3274:	11 24       	eor	r1, r1
    3276:	2f 92       	push	r2
    3278:	3f 92       	push	r3
    327a:	4f 92       	push	r4
    327c:	5f 92       	push	r5
    327e:	6f 92       	push	r6
    3280:	7f 92       	push	r7
    3282:	8f 92       	push	r8
    3284:	9f 92       	push	r9
    3286:	af 92       	push	r10
    3288:	bf 92       	push	r11
    328a:	cf 92       	push	r12
    328c:	df 92       	push	r13
    328e:	ef 92       	push	r14
    3290:	ff 92       	push	r15
    3292:	0f 93       	push	r16
    3294:	1f 93       	push	r17
    3296:	2f 93       	push	r18
    3298:	3f 93       	push	r19
    329a:	4f 93       	push	r20
    329c:	5f 93       	push	r21
    329e:	6f 93       	push	r22
    32a0:	7f 93       	push	r23
    32a2:	8f 93       	push	r24
    32a4:	9f 93       	push	r25
    32a6:	af 93       	push	r26
    32a8:	bf 93       	push	r27
    32aa:	cf 93       	push	r28
    32ac:	df 93       	push	r29
    32ae:	ef 93       	push	r30
    32b0:	ff 93       	push	r31
    32b2:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    32b6:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    32ba:	0d b6       	in	r0, 0x3d	; 61
    32bc:	0d 92       	st	X+, r0
    32be:	0e b6       	in	r0, 0x3e	; 62
    32c0:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    32c2:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    32c4:	80 91 81 1b 	lds	r24, 0x1B81	; 0x801b81 <ticksRemainingInSec>
    32c8:	90 91 82 1b 	lds	r25, 0x1B82	; 0x801b82 <ticksRemainingInSec+0x1>
    32cc:	01 97       	sbiw	r24, 0x01	; 1
    32ce:	90 93 82 1b 	sts	0x1B82, r25	; 0x801b82 <ticksRemainingInSec+0x1>
    32d2:	80 93 81 1b 	sts	0x1B81, r24	; 0x801b81 <ticksRemainingInSec>
    32d6:	89 2b       	or	r24, r25
    32d8:	41 f4       	brne	.+16     	; 0x32ea <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    32da:	80 91 7f 1b 	lds	r24, 0x1B7F	; 0x801b7f <portTickRateHz>
    32de:	90 91 80 1b 	lds	r25, 0x1B80	; 0x801b80 <portTickRateHz+0x1>
    32e2:	90 93 82 1b 	sts	0x1B82, r25	; 0x801b82 <ticksRemainingInSec+0x1>
    32e6:	80 93 81 1b 	sts	0x1B81, r24	; 0x801b81 <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    32ea:	0e 94 95 29 	call	0x532a	; 0x532a <xTaskIncrementTick>
    32ee:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    32f0:	0e 94 56 2a 	call	0x54ac	; 0x54ac <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    32f4:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    32f8:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    32fc:	cd 91       	ld	r28, X+
    32fe:	cd bf       	out	0x3d, r28	; 61
    3300:	dd 91       	ld	r29, X+
    3302:	de bf       	out	0x3e, r29	; 62
    3304:	ff 91       	pop	r31
    3306:	ef 91       	pop	r30
    3308:	df 91       	pop	r29
    330a:	cf 91       	pop	r28
    330c:	bf 91       	pop	r27
    330e:	af 91       	pop	r26
    3310:	9f 91       	pop	r25
    3312:	8f 91       	pop	r24
    3314:	7f 91       	pop	r23
    3316:	6f 91       	pop	r22
    3318:	5f 91       	pop	r21
    331a:	4f 91       	pop	r20
    331c:	3f 91       	pop	r19
    331e:	2f 91       	pop	r18
    3320:	1f 91       	pop	r17
    3322:	0f 91       	pop	r16
    3324:	ff 90       	pop	r15
    3326:	ef 90       	pop	r14
    3328:	df 90       	pop	r13
    332a:	cf 90       	pop	r12
    332c:	bf 90       	pop	r11
    332e:	af 90       	pop	r10
    3330:	9f 90       	pop	r9
    3332:	8f 90       	pop	r8
    3334:	7f 90       	pop	r7
    3336:	6f 90       	pop	r6
    3338:	5f 90       	pop	r5
    333a:	4f 90       	pop	r4
    333c:	3f 90       	pop	r3
    333e:	2f 90       	pop	r2
    3340:	1f 90       	pop	r1
    3342:	0f 90       	pop	r0
    3344:	0c be       	out	0x3c, r0	; 60
    3346:	0f 90       	pop	r0
    3348:	0b be       	out	0x3b, r0	; 59
    334a:	0f 90       	pop	r0
    334c:	0f be       	out	0x3f, r0	; 63
    334e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3350:	08 95       	ret

00003352 <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    3352:	87 df       	rcall	.-242    	; 0x3262 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    3354:	18 95       	reti

00003356 <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3356:	0f 93       	push	r16
    3358:	1f 93       	push	r17
    335a:	cf 93       	push	r28
    335c:	df 93       	push	r29
    335e:	08 2f       	mov	r16, r24
    3360:	16 2f       	mov	r17, r22
    3362:	66 23       	and	r22, r22
    3364:	09 f4       	brne	.+2      	; 0x3368 <xQueueGenericCreate+0x12>
    3366:	3b c0       	rjmp	.+118    	; 0x33de <xQueueGenericCreate+0x88>
    3368:	86 9f       	mul	r24, r22
    336a:	c0 01       	movw	r24, r0
    336c:	11 24       	eor	r1, r1
    336e:	80 96       	adiw	r24, 0x20	; 32
    3370:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3374:	ec 01       	movw	r28, r24
    3376:	00 97       	sbiw	r24, 0x00	; 0
    3378:	21 f4       	brne	.+8      	; 0x3382 <xQueueGenericCreate+0x2c>
    337a:	39 c0       	rjmp	.+114    	; 0x33ee <xQueueGenericCreate+0x98>
    337c:	d9 83       	std	Y+1, r29	; 0x01
    337e:	c8 83       	st	Y, r28
    3380:	03 c0       	rjmp	.+6      	; 0x3388 <xQueueGenericCreate+0x32>
    3382:	4f 96       	adiw	r24, 0x1f	; 31
    3384:	99 83       	std	Y+1, r25	; 0x01
    3386:	88 83       	st	Y, r24
    3388:	0b 8f       	std	Y+27, r16	; 0x1b
    338a:	1c 8f       	std	Y+28, r17	; 0x1c
    338c:	0f b6       	in	r0, 0x3f	; 63
    338e:	f8 94       	cli
    3390:	0f 92       	push	r0
    3392:	48 81       	ld	r20, Y
    3394:	59 81       	ldd	r21, Y+1	; 0x01
    3396:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3398:	30 e0       	ldi	r19, 0x00	; 0
    339a:	6b 8d       	ldd	r22, Y+27	; 0x1b
    339c:	62 9f       	mul	r22, r18
    339e:	c0 01       	movw	r24, r0
    33a0:	63 9f       	mul	r22, r19
    33a2:	90 0d       	add	r25, r0
    33a4:	11 24       	eor	r1, r1
    33a6:	ba 01       	movw	r22, r20
    33a8:	68 0f       	add	r22, r24
    33aa:	79 1f       	adc	r23, r25
    33ac:	7b 83       	std	Y+3, r23	; 0x03
    33ae:	6a 83       	std	Y+2, r22	; 0x02
    33b0:	1a 8e       	std	Y+26, r1	; 0x1a
    33b2:	5d 83       	std	Y+5, r21	; 0x05
    33b4:	4c 83       	std	Y+4, r20	; 0x04
    33b6:	82 1b       	sub	r24, r18
    33b8:	93 0b       	sbc	r25, r19
    33ba:	84 0f       	add	r24, r20
    33bc:	95 1f       	adc	r25, r21
    33be:	9f 83       	std	Y+7, r25	; 0x07
    33c0:	8e 83       	std	Y+6, r24	; 0x06
    33c2:	8f ef       	ldi	r24, 0xFF	; 255
    33c4:	8d 8f       	std	Y+29, r24	; 0x1d
    33c6:	8e 8f       	std	Y+30, r24	; 0x1e
    33c8:	ce 01       	movw	r24, r28
    33ca:	08 96       	adiw	r24, 0x08	; 8
    33cc:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    33d0:	ce 01       	movw	r24, r28
    33d2:	41 96       	adiw	r24, 0x11	; 17
    33d4:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    33d8:	0f 90       	pop	r0
    33da:	0f be       	out	0x3f, r0	; 63
    33dc:	08 c0       	rjmp	.+16     	; 0x33ee <xQueueGenericCreate+0x98>
    33de:	8f e1       	ldi	r24, 0x1F	; 31
    33e0:	90 e0       	ldi	r25, 0x00	; 0
    33e2:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    33e6:	ec 01       	movw	r28, r24
    33e8:	89 2b       	or	r24, r25
    33ea:	09 f0       	breq	.+2      	; 0x33ee <xQueueGenericCreate+0x98>
    33ec:	c7 cf       	rjmp	.-114    	; 0x337c <xQueueGenericCreate+0x26>
    33ee:	ce 01       	movw	r24, r28
    33f0:	df 91       	pop	r29
    33f2:	cf 91       	pop	r28
    33f4:	1f 91       	pop	r17
    33f6:	0f 91       	pop	r16
    33f8:	08 95       	ret

000033fa <xQueueCreateMutex>:
    33fa:	9f 92       	push	r9
    33fc:	af 92       	push	r10
    33fe:	bf 92       	push	r11
    3400:	cf 92       	push	r12
    3402:	df 92       	push	r13
    3404:	ef 92       	push	r14
    3406:	ff 92       	push	r15
    3408:	0f 93       	push	r16
    340a:	1f 93       	push	r17
    340c:	cf 93       	push	r28
    340e:	df 93       	push	r29
    3410:	00 d0       	rcall	.+0      	; 0x3412 <xQueueCreateMutex+0x18>
    3412:	1f 92       	push	r1
    3414:	1f 92       	push	r1
    3416:	cd b7       	in	r28, 0x3d	; 61
    3418:	de b7       	in	r29, 0x3e	; 62
    341a:	8f e1       	ldi	r24, 0x1F	; 31
    341c:	90 e0       	ldi	r25, 0x00	; 0
    341e:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3422:	8c 01       	movw	r16, r24
    3424:	00 97       	sbiw	r24, 0x00	; 0
    3426:	09 f4       	brne	.+2      	; 0x342a <xQueueCreateMutex+0x30>
    3428:	58 c1       	rjmp	.+688    	; 0x36da <xQueueCreateMutex+0x2e0>
    342a:	fc 01       	movw	r30, r24
    342c:	13 82       	std	Z+3, r1	; 0x03
    342e:	12 82       	std	Z+2, r1	; 0x02
    3430:	11 82       	std	Z+1, r1	; 0x01
    3432:	10 82       	st	Z, r1
    3434:	15 82       	std	Z+5, r1	; 0x05
    3436:	14 82       	std	Z+4, r1	; 0x04
    3438:	17 82       	std	Z+7, r1	; 0x07
    343a:	16 82       	std	Z+6, r1	; 0x06
    343c:	12 8e       	std	Z+26, r1	; 0x1a
    343e:	81 e0       	ldi	r24, 0x01	; 1
    3440:	83 8f       	std	Z+27, r24	; 0x1b
    3442:	14 8e       	std	Z+28, r1	; 0x1c
    3444:	8f ef       	ldi	r24, 0xFF	; 255
    3446:	85 8f       	std	Z+29, r24	; 0x1d
    3448:	86 8f       	std	Z+30, r24	; 0x1e
    344a:	78 01       	movw	r14, r16
    344c:	f8 e0       	ldi	r31, 0x08	; 8
    344e:	ef 0e       	add	r14, r31
    3450:	f1 1c       	adc	r15, r1
    3452:	c7 01       	movw	r24, r14
    3454:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    3458:	68 01       	movw	r12, r16
    345a:	81 e1       	ldi	r24, 0x11	; 17
    345c:	c8 0e       	add	r12, r24
    345e:	d1 1c       	adc	r13, r1
    3460:	c6 01       	movw	r24, r12
    3462:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    3466:	1d 82       	std	Y+5, r1	; 0x05
    3468:	1c 82       	std	Y+4, r1	; 0x04
    346a:	a1 2c       	mov	r10, r1
    346c:	99 24       	eor	r9, r9
    346e:	93 94       	inc	r9
    3470:	bb 24       	eor	r11, r11
    3472:	ba 94       	dec	r11
    3474:	0f b6       	in	r0, 0x3f	; 63
    3476:	f8 94       	cli
    3478:	0f 92       	push	r0
    347a:	f8 01       	movw	r30, r16
    347c:	92 8d       	ldd	r25, Z+26	; 0x1a
    347e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3480:	98 17       	cp	r25, r24
    3482:	f0 f4       	brcc	.+60     	; 0x34c0 <xQueueCreateMutex+0xc6>
    3484:	80 81       	ld	r24, Z
    3486:	91 81       	ldd	r25, Z+1	; 0x01
    3488:	89 2b       	or	r24, r25
    348a:	09 f0       	breq	.+2      	; 0x348e <xQueueCreateMutex+0x94>
    348c:	1d c1       	rjmp	.+570    	; 0x36c8 <xQueueCreateMutex+0x2ce>
    348e:	82 81       	ldd	r24, Z+2	; 0x02
    3490:	93 81       	ldd	r25, Z+3	; 0x03
    3492:	0e 94 32 2c 	call	0x5864	; 0x5864 <xTaskPriorityDisinherit>
    3496:	f8 01       	movw	r30, r16
    3498:	13 82       	std	Z+3, r1	; 0x03
    349a:	12 82       	std	Z+2, r1	; 0x02
    349c:	92 8d       	ldd	r25, Z+26	; 0x1a
    349e:	9f 5f       	subi	r25, 0xFF	; 255
    34a0:	92 8f       	std	Z+26, r25	; 0x1a
    34a2:	91 89       	ldd	r25, Z+17	; 0x11
    34a4:	99 23       	and	r25, r25
    34a6:	39 f0       	breq	.+14     	; 0x34b6 <xQueueCreateMutex+0xbc>
    34a8:	c6 01       	movw	r24, r12
    34aa:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    34ae:	81 30       	cpi	r24, 0x01	; 1
    34b0:	21 f4       	brne	.+8      	; 0x34ba <xQueueCreateMutex+0xc0>
    34b2:	76 de       	rcall	.-788    	; 0x31a0 <vPortYield>
    34b4:	02 c0       	rjmp	.+4      	; 0x34ba <xQueueCreateMutex+0xc0>
    34b6:	81 11       	cpse	r24, r1
    34b8:	73 de       	rcall	.-794    	; 0x31a0 <vPortYield>
    34ba:	0f 90       	pop	r0
    34bc:	0f be       	out	0x3f, r0	; 63
    34be:	0d c1       	rjmp	.+538    	; 0x36da <xQueueCreateMutex+0x2e0>
    34c0:	8c 81       	ldd	r24, Y+4	; 0x04
    34c2:	9d 81       	ldd	r25, Y+5	; 0x05
    34c4:	89 2b       	or	r24, r25
    34c6:	19 f4       	brne	.+6      	; 0x34ce <xQueueCreateMutex+0xd4>
    34c8:	0f 90       	pop	r0
    34ca:	0f be       	out	0x3f, r0	; 63
    34cc:	06 c1       	rjmp	.+524    	; 0x36da <xQueueCreateMutex+0x2e0>
    34ce:	a1 10       	cpse	r10, r1
    34d0:	05 c0       	rjmp	.+10     	; 0x34dc <xQueueCreateMutex+0xe2>
    34d2:	ce 01       	movw	r24, r28
    34d4:	01 96       	adiw	r24, 0x01	; 1
    34d6:	0e 94 81 2b 	call	0x5702	; 0x5702 <vTaskSetTimeOutState>
    34da:	a9 2c       	mov	r10, r9
    34dc:	0f 90       	pop	r0
    34de:	0f be       	out	0x3f, r0	; 63
    34e0:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspendAll>
    34e4:	0f b6       	in	r0, 0x3f	; 63
    34e6:	f8 94       	cli
    34e8:	0f 92       	push	r0
    34ea:	f8 01       	movw	r30, r16
    34ec:	85 8d       	ldd	r24, Z+29	; 0x1d
    34ee:	8f 3f       	cpi	r24, 0xFF	; 255
    34f0:	09 f4       	brne	.+2      	; 0x34f4 <xQueueCreateMutex+0xfa>
    34f2:	15 8e       	std	Z+29, r1	; 0x1d
    34f4:	f8 01       	movw	r30, r16
    34f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    34f8:	8f 3f       	cpi	r24, 0xFF	; 255
    34fa:	09 f4       	brne	.+2      	; 0x34fe <xQueueCreateMutex+0x104>
    34fc:	16 8e       	std	Z+30, r1	; 0x1e
    34fe:	0f 90       	pop	r0
    3500:	0f be       	out	0x3f, r0	; 63
    3502:	be 01       	movw	r22, r28
    3504:	6c 5f       	subi	r22, 0xFC	; 252
    3506:	7f 4f       	sbci	r23, 0xFF	; 255
    3508:	ce 01       	movw	r24, r28
    350a:	01 96       	adiw	r24, 0x01	; 1
    350c:	0e 94 8c 2b 	call	0x5718	; 0x5718 <xTaskCheckForTimeOut>
    3510:	81 11       	cpse	r24, r1
    3512:	96 c0       	rjmp	.+300    	; 0x3640 <xQueueCreateMutex+0x246>
    3514:	0f b6       	in	r0, 0x3f	; 63
    3516:	f8 94       	cli
    3518:	0f 92       	push	r0
    351a:	f8 01       	movw	r30, r16
    351c:	92 8d       	ldd	r25, Z+26	; 0x1a
    351e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3520:	0f 90       	pop	r0
    3522:	0f be       	out	0x3f, r0	; 63
    3524:	98 13       	cpse	r25, r24
    3526:	4a c0       	rjmp	.+148    	; 0x35bc <xQueueCreateMutex+0x1c2>
    3528:	6c 81       	ldd	r22, Y+4	; 0x04
    352a:	7d 81       	ldd	r23, Y+5	; 0x05
    352c:	c7 01       	movw	r24, r14
    352e:	0e 94 de 2a 	call	0x55bc	; 0x55bc <vTaskPlaceOnEventList>
    3532:	0f b6       	in	r0, 0x3f	; 63
    3534:	f8 94       	cli
    3536:	0f 92       	push	r0
    3538:	f8 01       	movw	r30, r16
    353a:	86 8d       	ldd	r24, Z+30	; 0x1e
    353c:	18 16       	cp	r1, r24
    353e:	ac f4       	brge	.+42     	; 0x356a <xQueueCreateMutex+0x170>
    3540:	81 89       	ldd	r24, Z+17	; 0x11
    3542:	81 11       	cpse	r24, r1
    3544:	05 c0       	rjmp	.+10     	; 0x3550 <xQueueCreateMutex+0x156>
    3546:	11 c0       	rjmp	.+34     	; 0x356a <xQueueCreateMutex+0x170>
    3548:	f8 01       	movw	r30, r16
    354a:	81 89       	ldd	r24, Z+17	; 0x11
    354c:	88 23       	and	r24, r24
    354e:	69 f0       	breq	.+26     	; 0x356a <xQueueCreateMutex+0x170>
    3550:	c6 01       	movw	r24, r12
    3552:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3556:	81 11       	cpse	r24, r1
    3558:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    355c:	f8 01       	movw	r30, r16
    355e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3560:	81 50       	subi	r24, 0x01	; 1
    3562:	86 8f       	std	Z+30, r24	; 0x1e
    3564:	86 8d       	ldd	r24, Z+30	; 0x1e
    3566:	18 16       	cp	r1, r24
    3568:	7c f3       	brlt	.-34     	; 0x3548 <xQueueCreateMutex+0x14e>
    356a:	f8 01       	movw	r30, r16
    356c:	b6 8e       	std	Z+30, r11	; 0x1e
    356e:	0f 90       	pop	r0
    3570:	0f be       	out	0x3f, r0	; 63
    3572:	0f b6       	in	r0, 0x3f	; 63
    3574:	f8 94       	cli
    3576:	0f 92       	push	r0
    3578:	85 8d       	ldd	r24, Z+29	; 0x1d
    357a:	18 16       	cp	r1, r24
    357c:	ac f4       	brge	.+42     	; 0x35a8 <xQueueCreateMutex+0x1ae>
    357e:	80 85       	ldd	r24, Z+8	; 0x08
    3580:	81 11       	cpse	r24, r1
    3582:	05 c0       	rjmp	.+10     	; 0x358e <xQueueCreateMutex+0x194>
    3584:	11 c0       	rjmp	.+34     	; 0x35a8 <xQueueCreateMutex+0x1ae>
    3586:	f8 01       	movw	r30, r16
    3588:	80 85       	ldd	r24, Z+8	; 0x08
    358a:	88 23       	and	r24, r24
    358c:	69 f0       	breq	.+26     	; 0x35a8 <xQueueCreateMutex+0x1ae>
    358e:	c7 01       	movw	r24, r14
    3590:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3594:	81 11       	cpse	r24, r1
    3596:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    359a:	f8 01       	movw	r30, r16
    359c:	85 8d       	ldd	r24, Z+29	; 0x1d
    359e:	81 50       	subi	r24, 0x01	; 1
    35a0:	85 8f       	std	Z+29, r24	; 0x1d
    35a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    35a4:	18 16       	cp	r1, r24
    35a6:	7c f3       	brlt	.-34     	; 0x3586 <xQueueCreateMutex+0x18c>
    35a8:	f8 01       	movw	r30, r16
    35aa:	b5 8e       	std	Z+29, r11	; 0x1d
    35ac:	0f 90       	pop	r0
    35ae:	0f be       	out	0x3f, r0	; 63
    35b0:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    35b4:	81 11       	cpse	r24, r1
    35b6:	5e cf       	rjmp	.-324    	; 0x3474 <xQueueCreateMutex+0x7a>
    35b8:	f3 dd       	rcall	.-1050   	; 0x31a0 <vPortYield>
    35ba:	5c cf       	rjmp	.-328    	; 0x3474 <xQueueCreateMutex+0x7a>
    35bc:	0f b6       	in	r0, 0x3f	; 63
    35be:	f8 94       	cli
    35c0:	0f 92       	push	r0
    35c2:	f8 01       	movw	r30, r16
    35c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    35c6:	18 16       	cp	r1, r24
    35c8:	ac f4       	brge	.+42     	; 0x35f4 <xQueueCreateMutex+0x1fa>
    35ca:	81 89       	ldd	r24, Z+17	; 0x11
    35cc:	81 11       	cpse	r24, r1
    35ce:	05 c0       	rjmp	.+10     	; 0x35da <xQueueCreateMutex+0x1e0>
    35d0:	11 c0       	rjmp	.+34     	; 0x35f4 <xQueueCreateMutex+0x1fa>
    35d2:	f8 01       	movw	r30, r16
    35d4:	81 89       	ldd	r24, Z+17	; 0x11
    35d6:	88 23       	and	r24, r24
    35d8:	69 f0       	breq	.+26     	; 0x35f4 <xQueueCreateMutex+0x1fa>
    35da:	c6 01       	movw	r24, r12
    35dc:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    35e0:	81 11       	cpse	r24, r1
    35e2:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    35e6:	f8 01       	movw	r30, r16
    35e8:	86 8d       	ldd	r24, Z+30	; 0x1e
    35ea:	81 50       	subi	r24, 0x01	; 1
    35ec:	86 8f       	std	Z+30, r24	; 0x1e
    35ee:	86 8d       	ldd	r24, Z+30	; 0x1e
    35f0:	18 16       	cp	r1, r24
    35f2:	7c f3       	brlt	.-34     	; 0x35d2 <xQueueCreateMutex+0x1d8>
    35f4:	f8 01       	movw	r30, r16
    35f6:	b6 8e       	std	Z+30, r11	; 0x1e
    35f8:	0f 90       	pop	r0
    35fa:	0f be       	out	0x3f, r0	; 63
    35fc:	0f b6       	in	r0, 0x3f	; 63
    35fe:	f8 94       	cli
    3600:	0f 92       	push	r0
    3602:	85 8d       	ldd	r24, Z+29	; 0x1d
    3604:	18 16       	cp	r1, r24
    3606:	ac f4       	brge	.+42     	; 0x3632 <xQueueCreateMutex+0x238>
    3608:	80 85       	ldd	r24, Z+8	; 0x08
    360a:	81 11       	cpse	r24, r1
    360c:	05 c0       	rjmp	.+10     	; 0x3618 <xQueueCreateMutex+0x21e>
    360e:	11 c0       	rjmp	.+34     	; 0x3632 <xQueueCreateMutex+0x238>
    3610:	f8 01       	movw	r30, r16
    3612:	80 85       	ldd	r24, Z+8	; 0x08
    3614:	88 23       	and	r24, r24
    3616:	69 f0       	breq	.+26     	; 0x3632 <xQueueCreateMutex+0x238>
    3618:	c7 01       	movw	r24, r14
    361a:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    361e:	81 11       	cpse	r24, r1
    3620:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3624:	f8 01       	movw	r30, r16
    3626:	85 8d       	ldd	r24, Z+29	; 0x1d
    3628:	81 50       	subi	r24, 0x01	; 1
    362a:	85 8f       	std	Z+29, r24	; 0x1d
    362c:	85 8d       	ldd	r24, Z+29	; 0x1d
    362e:	18 16       	cp	r1, r24
    3630:	7c f3       	brlt	.-34     	; 0x3610 <xQueueCreateMutex+0x216>
    3632:	f8 01       	movw	r30, r16
    3634:	b5 8e       	std	Z+29, r11	; 0x1d
    3636:	0f 90       	pop	r0
    3638:	0f be       	out	0x3f, r0	; 63
    363a:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    363e:	1a cf       	rjmp	.-460    	; 0x3474 <xQueueCreateMutex+0x7a>
    3640:	0f b6       	in	r0, 0x3f	; 63
    3642:	f8 94       	cli
    3644:	0f 92       	push	r0
    3646:	f8 01       	movw	r30, r16
    3648:	86 8d       	ldd	r24, Z+30	; 0x1e
    364a:	18 16       	cp	r1, r24
    364c:	ac f4       	brge	.+42     	; 0x3678 <xQueueCreateMutex+0x27e>
    364e:	81 89       	ldd	r24, Z+17	; 0x11
    3650:	81 11       	cpse	r24, r1
    3652:	05 c0       	rjmp	.+10     	; 0x365e <xQueueCreateMutex+0x264>
    3654:	11 c0       	rjmp	.+34     	; 0x3678 <xQueueCreateMutex+0x27e>
    3656:	f8 01       	movw	r30, r16
    3658:	81 89       	ldd	r24, Z+17	; 0x11
    365a:	88 23       	and	r24, r24
    365c:	69 f0       	breq	.+26     	; 0x3678 <xQueueCreateMutex+0x27e>
    365e:	c6 01       	movw	r24, r12
    3660:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3664:	81 11       	cpse	r24, r1
    3666:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    366a:	f8 01       	movw	r30, r16
    366c:	86 8d       	ldd	r24, Z+30	; 0x1e
    366e:	81 50       	subi	r24, 0x01	; 1
    3670:	86 8f       	std	Z+30, r24	; 0x1e
    3672:	86 8d       	ldd	r24, Z+30	; 0x1e
    3674:	18 16       	cp	r1, r24
    3676:	7c f3       	brlt	.-34     	; 0x3656 <xQueueCreateMutex+0x25c>
    3678:	8f ef       	ldi	r24, 0xFF	; 255
    367a:	f8 01       	movw	r30, r16
    367c:	86 8f       	std	Z+30, r24	; 0x1e
    367e:	0f 90       	pop	r0
    3680:	0f be       	out	0x3f, r0	; 63
    3682:	0f b6       	in	r0, 0x3f	; 63
    3684:	f8 94       	cli
    3686:	0f 92       	push	r0
    3688:	85 8d       	ldd	r24, Z+29	; 0x1d
    368a:	18 16       	cp	r1, r24
    368c:	ac f4       	brge	.+42     	; 0x36b8 <xQueueCreateMutex+0x2be>
    368e:	80 85       	ldd	r24, Z+8	; 0x08
    3690:	81 11       	cpse	r24, r1
    3692:	05 c0       	rjmp	.+10     	; 0x369e <xQueueCreateMutex+0x2a4>
    3694:	11 c0       	rjmp	.+34     	; 0x36b8 <xQueueCreateMutex+0x2be>
    3696:	f8 01       	movw	r30, r16
    3698:	80 85       	ldd	r24, Z+8	; 0x08
    369a:	88 23       	and	r24, r24
    369c:	69 f0       	breq	.+26     	; 0x36b8 <xQueueCreateMutex+0x2be>
    369e:	c7 01       	movw	r24, r14
    36a0:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    36a4:	81 11       	cpse	r24, r1
    36a6:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    36aa:	f8 01       	movw	r30, r16
    36ac:	85 8d       	ldd	r24, Z+29	; 0x1d
    36ae:	81 50       	subi	r24, 0x01	; 1
    36b0:	85 8f       	std	Z+29, r24	; 0x1d
    36b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    36b4:	18 16       	cp	r1, r24
    36b6:	7c f3       	brlt	.-34     	; 0x3696 <xQueueCreateMutex+0x29c>
    36b8:	8f ef       	ldi	r24, 0xFF	; 255
    36ba:	f8 01       	movw	r30, r16
    36bc:	85 8f       	std	Z+29, r24	; 0x1d
    36be:	0f 90       	pop	r0
    36c0:	0f be       	out	0x3f, r0	; 63
    36c2:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    36c6:	09 c0       	rjmp	.+18     	; 0x36da <xQueueCreateMutex+0x2e0>
    36c8:	f8 01       	movw	r30, r16
    36ca:	82 8d       	ldd	r24, Z+26	; 0x1a
    36cc:	8f 5f       	subi	r24, 0xFF	; 255
    36ce:	82 8f       	std	Z+26, r24	; 0x1a
    36d0:	81 89       	ldd	r24, Z+17	; 0x11
    36d2:	88 23       	and	r24, r24
    36d4:	09 f4       	brne	.+2      	; 0x36d8 <xQueueCreateMutex+0x2de>
    36d6:	f1 ce       	rjmp	.-542    	; 0x34ba <xQueueCreateMutex+0xc0>
    36d8:	e7 ce       	rjmp	.-562    	; 0x34a8 <xQueueCreateMutex+0xae>
    36da:	c8 01       	movw	r24, r16
    36dc:	0f 90       	pop	r0
    36de:	0f 90       	pop	r0
    36e0:	0f 90       	pop	r0
    36e2:	0f 90       	pop	r0
    36e4:	0f 90       	pop	r0
    36e6:	df 91       	pop	r29
    36e8:	cf 91       	pop	r28
    36ea:	1f 91       	pop	r17
    36ec:	0f 91       	pop	r16
    36ee:	ff 90       	pop	r15
    36f0:	ef 90       	pop	r14
    36f2:	df 90       	pop	r13
    36f4:	cf 90       	pop	r12
    36f6:	bf 90       	pop	r11
    36f8:	af 90       	pop	r10
    36fa:	9f 90       	pop	r9
    36fc:	08 95       	ret

000036fe <xQueueGenericSend>:
    36fe:	6f 92       	push	r6
    3700:	7f 92       	push	r7
    3702:	8f 92       	push	r8
    3704:	9f 92       	push	r9
    3706:	af 92       	push	r10
    3708:	bf 92       	push	r11
    370a:	cf 92       	push	r12
    370c:	df 92       	push	r13
    370e:	ef 92       	push	r14
    3710:	ff 92       	push	r15
    3712:	0f 93       	push	r16
    3714:	1f 93       	push	r17
    3716:	cf 93       	push	r28
    3718:	df 93       	push	r29
    371a:	00 d0       	rcall	.+0      	; 0x371c <xQueueGenericSend+0x1e>
    371c:	1f 92       	push	r1
    371e:	1f 92       	push	r1
    3720:	cd b7       	in	r28, 0x3d	; 61
    3722:	de b7       	in	r29, 0x3e	; 62
    3724:	8c 01       	movw	r16, r24
    3726:	5b 01       	movw	r10, r22
    3728:	5d 83       	std	Y+5, r21	; 0x05
    372a:	4c 83       	std	Y+4, r20	; 0x04
    372c:	72 2e       	mov	r7, r18
    372e:	81 2c       	mov	r8, r1
    3730:	66 24       	eor	r6, r6
    3732:	63 94       	inc	r6
    3734:	99 24       	eor	r9, r9
    3736:	9a 94       	dec	r9
    3738:	7c 01       	movw	r14, r24
    373a:	88 e0       	ldi	r24, 0x08	; 8
    373c:	e8 0e       	add	r14, r24
    373e:	f1 1c       	adc	r15, r1
    3740:	68 01       	movw	r12, r16
    3742:	e1 e1       	ldi	r30, 0x11	; 17
    3744:	ce 0e       	add	r12, r30
    3746:	d1 1c       	adc	r13, r1
    3748:	0f b6       	in	r0, 0x3f	; 63
    374a:	f8 94       	cli
    374c:	0f 92       	push	r0
    374e:	f8 01       	movw	r30, r16
    3750:	92 8d       	ldd	r25, Z+26	; 0x1a
    3752:	83 8d       	ldd	r24, Z+27	; 0x1b
    3754:	98 17       	cp	r25, r24
    3756:	20 f0       	brcs	.+8      	; 0x3760 <xQueueGenericSend+0x62>
    3758:	f2 e0       	ldi	r31, 0x02	; 2
    375a:	7f 12       	cpse	r7, r31
    375c:	6e c0       	rjmp	.+220    	; 0x383a <xQueueGenericSend+0x13c>
    375e:	7d c1       	rjmp	.+762    	; 0x3a5a <xQueueGenericSend+0x35c>
    3760:	f8 01       	movw	r30, r16
    3762:	44 8d       	ldd	r20, Z+28	; 0x1c
    3764:	41 11       	cpse	r20, r1
    3766:	15 c0       	rjmp	.+42     	; 0x3792 <xQueueGenericSend+0x94>
    3768:	f8 01       	movw	r30, r16
    376a:	80 81       	ld	r24, Z
    376c:	91 81       	ldd	r25, Z+1	; 0x01
    376e:	89 2b       	or	r24, r25
    3770:	09 f0       	breq	.+2      	; 0x3774 <xQueueGenericSend+0x76>
    3772:	79 c1       	rjmp	.+754    	; 0x3a66 <xQueueGenericSend+0x368>
    3774:	82 81       	ldd	r24, Z+2	; 0x02
    3776:	93 81       	ldd	r25, Z+3	; 0x03
    3778:	0e 94 32 2c 	call	0x5864	; 0x5864 <xTaskPriorityDisinherit>
    377c:	f8 01       	movw	r30, r16
    377e:	13 82       	std	Z+3, r1	; 0x03
    3780:	12 82       	std	Z+2, r1	; 0x02
    3782:	92 8d       	ldd	r25, Z+26	; 0x1a
    3784:	9f 5f       	subi	r25, 0xFF	; 255
    3786:	92 8f       	std	Z+26, r25	; 0x1a
    3788:	91 89       	ldd	r25, Z+17	; 0x11
    378a:	99 23       	and	r25, r25
    378c:	09 f4       	brne	.+2      	; 0x3790 <xQueueGenericSend+0x92>
    378e:	4f c0       	rjmp	.+158    	; 0x382e <xQueueGenericSend+0x130>
    3790:	46 c0       	rjmp	.+140    	; 0x381e <xQueueGenericSend+0x120>
    3792:	71 10       	cpse	r7, r1
    3794:	1a c0       	rjmp	.+52     	; 0x37ca <xQueueGenericSend+0xcc>
    3796:	50 e0       	ldi	r21, 0x00	; 0
    3798:	b5 01       	movw	r22, r10
    379a:	f8 01       	movw	r30, r16
    379c:	84 81       	ldd	r24, Z+4	; 0x04
    379e:	95 81       	ldd	r25, Z+5	; 0x05
    37a0:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
    37a4:	f8 01       	movw	r30, r16
    37a6:	24 8d       	ldd	r18, Z+28	; 0x1c
    37a8:	84 81       	ldd	r24, Z+4	; 0x04
    37aa:	95 81       	ldd	r25, Z+5	; 0x05
    37ac:	82 0f       	add	r24, r18
    37ae:	91 1d       	adc	r25, r1
    37b0:	95 83       	std	Z+5, r25	; 0x05
    37b2:	84 83       	std	Z+4, r24	; 0x04
    37b4:	22 81       	ldd	r18, Z+2	; 0x02
    37b6:	33 81       	ldd	r19, Z+3	; 0x03
    37b8:	82 17       	cp	r24, r18
    37ba:	93 07       	cpc	r25, r19
    37bc:	08 f4       	brcc	.+2      	; 0x37c0 <xQueueGenericSend+0xc2>
    37be:	53 c1       	rjmp	.+678    	; 0x3a66 <xQueueGenericSend+0x368>
    37c0:	80 81       	ld	r24, Z
    37c2:	91 81       	ldd	r25, Z+1	; 0x01
    37c4:	95 83       	std	Z+5, r25	; 0x05
    37c6:	84 83       	std	Z+4, r24	; 0x04
    37c8:	4e c1       	rjmp	.+668    	; 0x3a66 <xQueueGenericSend+0x368>
    37ca:	50 e0       	ldi	r21, 0x00	; 0
    37cc:	b5 01       	movw	r22, r10
    37ce:	f8 01       	movw	r30, r16
    37d0:	86 81       	ldd	r24, Z+6	; 0x06
    37d2:	97 81       	ldd	r25, Z+7	; 0x07
    37d4:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
    37d8:	f8 01       	movw	r30, r16
    37da:	84 8d       	ldd	r24, Z+28	; 0x1c
    37dc:	90 e0       	ldi	r25, 0x00	; 0
    37de:	91 95       	neg	r25
    37e0:	81 95       	neg	r24
    37e2:	91 09       	sbc	r25, r1
    37e4:	26 81       	ldd	r18, Z+6	; 0x06
    37e6:	37 81       	ldd	r19, Z+7	; 0x07
    37e8:	28 0f       	add	r18, r24
    37ea:	39 1f       	adc	r19, r25
    37ec:	37 83       	std	Z+7, r19	; 0x07
    37ee:	26 83       	std	Z+6, r18	; 0x06
    37f0:	40 81       	ld	r20, Z
    37f2:	51 81       	ldd	r21, Z+1	; 0x01
    37f4:	24 17       	cp	r18, r20
    37f6:	35 07       	cpc	r19, r21
    37f8:	30 f4       	brcc	.+12     	; 0x3806 <xQueueGenericSend+0x108>
    37fa:	22 81       	ldd	r18, Z+2	; 0x02
    37fc:	33 81       	ldd	r19, Z+3	; 0x03
    37fe:	82 0f       	add	r24, r18
    3800:	93 1f       	adc	r25, r19
    3802:	97 83       	std	Z+7, r25	; 0x07
    3804:	86 83       	std	Z+6, r24	; 0x06
    3806:	f2 e0       	ldi	r31, 0x02	; 2
    3808:	7f 12       	cpse	r7, r31
    380a:	2d c1       	rjmp	.+602    	; 0x3a66 <xQueueGenericSend+0x368>
    380c:	f8 01       	movw	r30, r16
    380e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3810:	88 23       	and	r24, r24
    3812:	09 f4       	brne	.+2      	; 0x3816 <xQueueGenericSend+0x118>
    3814:	28 c1       	rjmp	.+592    	; 0x3a66 <xQueueGenericSend+0x368>
    3816:	82 8d       	ldd	r24, Z+26	; 0x1a
    3818:	81 50       	subi	r24, 0x01	; 1
    381a:	82 8f       	std	Z+26, r24	; 0x1a
    381c:	24 c1       	rjmp	.+584    	; 0x3a66 <xQueueGenericSend+0x368>
    381e:	c8 01       	movw	r24, r16
    3820:	41 96       	adiw	r24, 0x11	; 17
    3822:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3826:	81 30       	cpi	r24, 0x01	; 1
    3828:	21 f4       	brne	.+8      	; 0x3832 <xQueueGenericSend+0x134>
    382a:	ba dc       	rcall	.-1676   	; 0x31a0 <vPortYield>
    382c:	02 c0       	rjmp	.+4      	; 0x3832 <xQueueGenericSend+0x134>
    382e:	81 11       	cpse	r24, r1
    3830:	b7 dc       	rcall	.-1682   	; 0x31a0 <vPortYield>
    3832:	0f 90       	pop	r0
    3834:	0f be       	out	0x3f, r0	; 63
    3836:	81 e0       	ldi	r24, 0x01	; 1
    3838:	1e c1       	rjmp	.+572    	; 0x3a76 <xQueueGenericSend+0x378>
    383a:	8c 81       	ldd	r24, Y+4	; 0x04
    383c:	9d 81       	ldd	r25, Y+5	; 0x05
    383e:	89 2b       	or	r24, r25
    3840:	21 f4       	brne	.+8      	; 0x384a <xQueueGenericSend+0x14c>
    3842:	0f 90       	pop	r0
    3844:	0f be       	out	0x3f, r0	; 63
    3846:	80 e0       	ldi	r24, 0x00	; 0
    3848:	16 c1       	rjmp	.+556    	; 0x3a76 <xQueueGenericSend+0x378>
    384a:	81 10       	cpse	r8, r1
    384c:	05 c0       	rjmp	.+10     	; 0x3858 <xQueueGenericSend+0x15a>
    384e:	ce 01       	movw	r24, r28
    3850:	01 96       	adiw	r24, 0x01	; 1
    3852:	0e 94 81 2b 	call	0x5702	; 0x5702 <vTaskSetTimeOutState>
    3856:	86 2c       	mov	r8, r6
    3858:	0f 90       	pop	r0
    385a:	0f be       	out	0x3f, r0	; 63
    385c:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspendAll>
    3860:	0f b6       	in	r0, 0x3f	; 63
    3862:	f8 94       	cli
    3864:	0f 92       	push	r0
    3866:	f8 01       	movw	r30, r16
    3868:	85 8d       	ldd	r24, Z+29	; 0x1d
    386a:	8f 3f       	cpi	r24, 0xFF	; 255
    386c:	09 f4       	brne	.+2      	; 0x3870 <xQueueGenericSend+0x172>
    386e:	15 8e       	std	Z+29, r1	; 0x1d
    3870:	f8 01       	movw	r30, r16
    3872:	86 8d       	ldd	r24, Z+30	; 0x1e
    3874:	8f 3f       	cpi	r24, 0xFF	; 255
    3876:	09 f4       	brne	.+2      	; 0x387a <xQueueGenericSend+0x17c>
    3878:	16 8e       	std	Z+30, r1	; 0x1e
    387a:	0f 90       	pop	r0
    387c:	0f be       	out	0x3f, r0	; 63
    387e:	be 01       	movw	r22, r28
    3880:	6c 5f       	subi	r22, 0xFC	; 252
    3882:	7f 4f       	sbci	r23, 0xFF	; 255
    3884:	ce 01       	movw	r24, r28
    3886:	01 96       	adiw	r24, 0x01	; 1
    3888:	0e 94 8c 2b 	call	0x5718	; 0x5718 <xTaskCheckForTimeOut>
    388c:	81 11       	cpse	r24, r1
    388e:	96 c0       	rjmp	.+300    	; 0x39bc <xQueueGenericSend+0x2be>
    3890:	0f b6       	in	r0, 0x3f	; 63
    3892:	f8 94       	cli
    3894:	0f 92       	push	r0
    3896:	f8 01       	movw	r30, r16
    3898:	92 8d       	ldd	r25, Z+26	; 0x1a
    389a:	83 8d       	ldd	r24, Z+27	; 0x1b
    389c:	0f 90       	pop	r0
    389e:	0f be       	out	0x3f, r0	; 63
    38a0:	98 13       	cpse	r25, r24
    38a2:	4a c0       	rjmp	.+148    	; 0x3938 <xQueueGenericSend+0x23a>
    38a4:	6c 81       	ldd	r22, Y+4	; 0x04
    38a6:	7d 81       	ldd	r23, Y+5	; 0x05
    38a8:	c7 01       	movw	r24, r14
    38aa:	0e 94 de 2a 	call	0x55bc	; 0x55bc <vTaskPlaceOnEventList>
    38ae:	0f b6       	in	r0, 0x3f	; 63
    38b0:	f8 94       	cli
    38b2:	0f 92       	push	r0
    38b4:	f8 01       	movw	r30, r16
    38b6:	86 8d       	ldd	r24, Z+30	; 0x1e
    38b8:	18 16       	cp	r1, r24
    38ba:	ac f4       	brge	.+42     	; 0x38e6 <xQueueGenericSend+0x1e8>
    38bc:	81 89       	ldd	r24, Z+17	; 0x11
    38be:	81 11       	cpse	r24, r1
    38c0:	05 c0       	rjmp	.+10     	; 0x38cc <xQueueGenericSend+0x1ce>
    38c2:	11 c0       	rjmp	.+34     	; 0x38e6 <xQueueGenericSend+0x1e8>
    38c4:	f8 01       	movw	r30, r16
    38c6:	81 89       	ldd	r24, Z+17	; 0x11
    38c8:	88 23       	and	r24, r24
    38ca:	69 f0       	breq	.+26     	; 0x38e6 <xQueueGenericSend+0x1e8>
    38cc:	c6 01       	movw	r24, r12
    38ce:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    38d2:	81 11       	cpse	r24, r1
    38d4:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    38d8:	f8 01       	movw	r30, r16
    38da:	86 8d       	ldd	r24, Z+30	; 0x1e
    38dc:	81 50       	subi	r24, 0x01	; 1
    38de:	86 8f       	std	Z+30, r24	; 0x1e
    38e0:	86 8d       	ldd	r24, Z+30	; 0x1e
    38e2:	18 16       	cp	r1, r24
    38e4:	7c f3       	brlt	.-34     	; 0x38c4 <xQueueGenericSend+0x1c6>
    38e6:	f8 01       	movw	r30, r16
    38e8:	96 8e       	std	Z+30, r9	; 0x1e
    38ea:	0f 90       	pop	r0
    38ec:	0f be       	out	0x3f, r0	; 63
    38ee:	0f b6       	in	r0, 0x3f	; 63
    38f0:	f8 94       	cli
    38f2:	0f 92       	push	r0
    38f4:	85 8d       	ldd	r24, Z+29	; 0x1d
    38f6:	18 16       	cp	r1, r24
    38f8:	ac f4       	brge	.+42     	; 0x3924 <xQueueGenericSend+0x226>
    38fa:	80 85       	ldd	r24, Z+8	; 0x08
    38fc:	81 11       	cpse	r24, r1
    38fe:	05 c0       	rjmp	.+10     	; 0x390a <xQueueGenericSend+0x20c>
    3900:	11 c0       	rjmp	.+34     	; 0x3924 <xQueueGenericSend+0x226>
    3902:	f8 01       	movw	r30, r16
    3904:	80 85       	ldd	r24, Z+8	; 0x08
    3906:	88 23       	and	r24, r24
    3908:	69 f0       	breq	.+26     	; 0x3924 <xQueueGenericSend+0x226>
    390a:	c7 01       	movw	r24, r14
    390c:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3910:	81 11       	cpse	r24, r1
    3912:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3916:	f8 01       	movw	r30, r16
    3918:	85 8d       	ldd	r24, Z+29	; 0x1d
    391a:	81 50       	subi	r24, 0x01	; 1
    391c:	85 8f       	std	Z+29, r24	; 0x1d
    391e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3920:	18 16       	cp	r1, r24
    3922:	7c f3       	brlt	.-34     	; 0x3902 <xQueueGenericSend+0x204>
    3924:	f8 01       	movw	r30, r16
    3926:	95 8e       	std	Z+29, r9	; 0x1d
    3928:	0f 90       	pop	r0
    392a:	0f be       	out	0x3f, r0	; 63
    392c:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    3930:	81 11       	cpse	r24, r1
    3932:	0a cf       	rjmp	.-492    	; 0x3748 <xQueueGenericSend+0x4a>
    3934:	35 dc       	rcall	.-1942   	; 0x31a0 <vPortYield>
    3936:	08 cf       	rjmp	.-496    	; 0x3748 <xQueueGenericSend+0x4a>
    3938:	0f b6       	in	r0, 0x3f	; 63
    393a:	f8 94       	cli
    393c:	0f 92       	push	r0
    393e:	f8 01       	movw	r30, r16
    3940:	86 8d       	ldd	r24, Z+30	; 0x1e
    3942:	18 16       	cp	r1, r24
    3944:	ac f4       	brge	.+42     	; 0x3970 <xQueueGenericSend+0x272>
    3946:	81 89       	ldd	r24, Z+17	; 0x11
    3948:	81 11       	cpse	r24, r1
    394a:	05 c0       	rjmp	.+10     	; 0x3956 <xQueueGenericSend+0x258>
    394c:	11 c0       	rjmp	.+34     	; 0x3970 <xQueueGenericSend+0x272>
    394e:	f8 01       	movw	r30, r16
    3950:	81 89       	ldd	r24, Z+17	; 0x11
    3952:	88 23       	and	r24, r24
    3954:	69 f0       	breq	.+26     	; 0x3970 <xQueueGenericSend+0x272>
    3956:	c6 01       	movw	r24, r12
    3958:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    395c:	81 11       	cpse	r24, r1
    395e:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3962:	f8 01       	movw	r30, r16
    3964:	86 8d       	ldd	r24, Z+30	; 0x1e
    3966:	81 50       	subi	r24, 0x01	; 1
    3968:	86 8f       	std	Z+30, r24	; 0x1e
    396a:	86 8d       	ldd	r24, Z+30	; 0x1e
    396c:	18 16       	cp	r1, r24
    396e:	7c f3       	brlt	.-34     	; 0x394e <xQueueGenericSend+0x250>
    3970:	f8 01       	movw	r30, r16
    3972:	96 8e       	std	Z+30, r9	; 0x1e
    3974:	0f 90       	pop	r0
    3976:	0f be       	out	0x3f, r0	; 63
    3978:	0f b6       	in	r0, 0x3f	; 63
    397a:	f8 94       	cli
    397c:	0f 92       	push	r0
    397e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3980:	18 16       	cp	r1, r24
    3982:	ac f4       	brge	.+42     	; 0x39ae <xQueueGenericSend+0x2b0>
    3984:	80 85       	ldd	r24, Z+8	; 0x08
    3986:	81 11       	cpse	r24, r1
    3988:	05 c0       	rjmp	.+10     	; 0x3994 <xQueueGenericSend+0x296>
    398a:	11 c0       	rjmp	.+34     	; 0x39ae <xQueueGenericSend+0x2b0>
    398c:	f8 01       	movw	r30, r16
    398e:	80 85       	ldd	r24, Z+8	; 0x08
    3990:	88 23       	and	r24, r24
    3992:	69 f0       	breq	.+26     	; 0x39ae <xQueueGenericSend+0x2b0>
    3994:	c7 01       	movw	r24, r14
    3996:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    399a:	81 11       	cpse	r24, r1
    399c:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    39a0:	f8 01       	movw	r30, r16
    39a2:	85 8d       	ldd	r24, Z+29	; 0x1d
    39a4:	81 50       	subi	r24, 0x01	; 1
    39a6:	85 8f       	std	Z+29, r24	; 0x1d
    39a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    39aa:	18 16       	cp	r1, r24
    39ac:	7c f3       	brlt	.-34     	; 0x398c <xQueueGenericSend+0x28e>
    39ae:	f8 01       	movw	r30, r16
    39b0:	95 8e       	std	Z+29, r9	; 0x1d
    39b2:	0f 90       	pop	r0
    39b4:	0f be       	out	0x3f, r0	; 63
    39b6:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    39ba:	c6 ce       	rjmp	.-628    	; 0x3748 <xQueueGenericSend+0x4a>
    39bc:	0f b6       	in	r0, 0x3f	; 63
    39be:	f8 94       	cli
    39c0:	0f 92       	push	r0
    39c2:	f8 01       	movw	r30, r16
    39c4:	86 8d       	ldd	r24, Z+30	; 0x1e
    39c6:	18 16       	cp	r1, r24
    39c8:	d4 f4       	brge	.+52     	; 0x39fe <xQueueGenericSend+0x300>
    39ca:	81 89       	ldd	r24, Z+17	; 0x11
    39cc:	81 11       	cpse	r24, r1
    39ce:	06 c0       	rjmp	.+12     	; 0x39dc <xQueueGenericSend+0x2de>
    39d0:	16 c0       	rjmp	.+44     	; 0x39fe <xQueueGenericSend+0x300>
    39d2:	f8 01       	movw	r30, r16
    39d4:	81 89       	ldd	r24, Z+17	; 0x11
    39d6:	81 11       	cpse	r24, r1
    39d8:	05 c0       	rjmp	.+10     	; 0x39e4 <xQueueGenericSend+0x2e6>
    39da:	11 c0       	rjmp	.+34     	; 0x39fe <xQueueGenericSend+0x300>
    39dc:	78 01       	movw	r14, r16
    39de:	f1 e1       	ldi	r31, 0x11	; 17
    39e0:	ef 0e       	add	r14, r31
    39e2:	f1 1c       	adc	r15, r1
    39e4:	c7 01       	movw	r24, r14
    39e6:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    39ea:	81 11       	cpse	r24, r1
    39ec:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    39f0:	f8 01       	movw	r30, r16
    39f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    39f4:	81 50       	subi	r24, 0x01	; 1
    39f6:	86 8f       	std	Z+30, r24	; 0x1e
    39f8:	86 8d       	ldd	r24, Z+30	; 0x1e
    39fa:	18 16       	cp	r1, r24
    39fc:	54 f3       	brlt	.-44     	; 0x39d2 <xQueueGenericSend+0x2d4>
    39fe:	8f ef       	ldi	r24, 0xFF	; 255
    3a00:	f8 01       	movw	r30, r16
    3a02:	86 8f       	std	Z+30, r24	; 0x1e
    3a04:	0f 90       	pop	r0
    3a06:	0f be       	out	0x3f, r0	; 63
    3a08:	0f b6       	in	r0, 0x3f	; 63
    3a0a:	f8 94       	cli
    3a0c:	0f 92       	push	r0
    3a0e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a10:	18 16       	cp	r1, r24
    3a12:	d4 f4       	brge	.+52     	; 0x3a48 <xQueueGenericSend+0x34a>
    3a14:	80 85       	ldd	r24, Z+8	; 0x08
    3a16:	81 11       	cpse	r24, r1
    3a18:	06 c0       	rjmp	.+12     	; 0x3a26 <xQueueGenericSend+0x328>
    3a1a:	16 c0       	rjmp	.+44     	; 0x3a48 <xQueueGenericSend+0x34a>
    3a1c:	f8 01       	movw	r30, r16
    3a1e:	80 85       	ldd	r24, Z+8	; 0x08
    3a20:	81 11       	cpse	r24, r1
    3a22:	05 c0       	rjmp	.+10     	; 0x3a2e <xQueueGenericSend+0x330>
    3a24:	11 c0       	rjmp	.+34     	; 0x3a48 <xQueueGenericSend+0x34a>
    3a26:	78 01       	movw	r14, r16
    3a28:	f8 e0       	ldi	r31, 0x08	; 8
    3a2a:	ef 0e       	add	r14, r31
    3a2c:	f1 1c       	adc	r15, r1
    3a2e:	c7 01       	movw	r24, r14
    3a30:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3a34:	81 11       	cpse	r24, r1
    3a36:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3a3a:	f8 01       	movw	r30, r16
    3a3c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a3e:	81 50       	subi	r24, 0x01	; 1
    3a40:	85 8f       	std	Z+29, r24	; 0x1d
    3a42:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a44:	18 16       	cp	r1, r24
    3a46:	54 f3       	brlt	.-44     	; 0x3a1c <xQueueGenericSend+0x31e>
    3a48:	8f ef       	ldi	r24, 0xFF	; 255
    3a4a:	f8 01       	movw	r30, r16
    3a4c:	85 8f       	std	Z+29, r24	; 0x1d
    3a4e:	0f 90       	pop	r0
    3a50:	0f be       	out	0x3f, r0	; 63
    3a52:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    3a56:	80 e0       	ldi	r24, 0x00	; 0
    3a58:	0e c0       	rjmp	.+28     	; 0x3a76 <xQueueGenericSend+0x378>
    3a5a:	f8 01       	movw	r30, r16
    3a5c:	44 8d       	ldd	r20, Z+28	; 0x1c
    3a5e:	44 23       	and	r20, r20
    3a60:	09 f4       	brne	.+2      	; 0x3a64 <xQueueGenericSend+0x366>
    3a62:	82 ce       	rjmp	.-764    	; 0x3768 <xQueueGenericSend+0x6a>
    3a64:	b2 ce       	rjmp	.-668    	; 0x37ca <xQueueGenericSend+0xcc>
    3a66:	f8 01       	movw	r30, r16
    3a68:	82 8d       	ldd	r24, Z+26	; 0x1a
    3a6a:	8f 5f       	subi	r24, 0xFF	; 255
    3a6c:	82 8f       	std	Z+26, r24	; 0x1a
    3a6e:	81 89       	ldd	r24, Z+17	; 0x11
    3a70:	81 11       	cpse	r24, r1
    3a72:	d5 ce       	rjmp	.-598    	; 0x381e <xQueueGenericSend+0x120>
    3a74:	de ce       	rjmp	.-580    	; 0x3832 <xQueueGenericSend+0x134>
    3a76:	0f 90       	pop	r0
    3a78:	0f 90       	pop	r0
    3a7a:	0f 90       	pop	r0
    3a7c:	0f 90       	pop	r0
    3a7e:	0f 90       	pop	r0
    3a80:	df 91       	pop	r29
    3a82:	cf 91       	pop	r28
    3a84:	1f 91       	pop	r17
    3a86:	0f 91       	pop	r16
    3a88:	ff 90       	pop	r15
    3a8a:	ef 90       	pop	r14
    3a8c:	df 90       	pop	r13
    3a8e:	cf 90       	pop	r12
    3a90:	bf 90       	pop	r11
    3a92:	af 90       	pop	r10
    3a94:	9f 90       	pop	r9
    3a96:	8f 90       	pop	r8
    3a98:	7f 90       	pop	r7
    3a9a:	6f 90       	pop	r6
    3a9c:	08 95       	ret

00003a9e <xQueueGive>:
    3a9e:	9f 92       	push	r9
    3aa0:	af 92       	push	r10
    3aa2:	bf 92       	push	r11
    3aa4:	cf 92       	push	r12
    3aa6:	df 92       	push	r13
    3aa8:	ef 92       	push	r14
    3aaa:	ff 92       	push	r15
    3aac:	0f 93       	push	r16
    3aae:	1f 93       	push	r17
    3ab0:	cf 93       	push	r28
    3ab2:	df 93       	push	r29
    3ab4:	00 d0       	rcall	.+0      	; 0x3ab6 <xQueueGive+0x18>
    3ab6:	1f 92       	push	r1
    3ab8:	1f 92       	push	r1
    3aba:	cd b7       	in	r28, 0x3d	; 61
    3abc:	de b7       	in	r29, 0x3e	; 62
    3abe:	8c 01       	movw	r16, r24
    3ac0:	7d 83       	std	Y+5, r23	; 0x05
    3ac2:	6c 83       	std	Y+4, r22	; 0x04
    3ac4:	a1 2c       	mov	r10, r1
    3ac6:	99 24       	eor	r9, r9
    3ac8:	93 94       	inc	r9
    3aca:	bb 24       	eor	r11, r11
    3acc:	ba 94       	dec	r11
    3ace:	7c 01       	movw	r14, r24
    3ad0:	88 e0       	ldi	r24, 0x08	; 8
    3ad2:	e8 0e       	add	r14, r24
    3ad4:	f1 1c       	adc	r15, r1
    3ad6:	68 01       	movw	r12, r16
    3ad8:	e1 e1       	ldi	r30, 0x11	; 17
    3ada:	ce 0e       	add	r12, r30
    3adc:	d1 1c       	adc	r13, r1
    3ade:	0f b6       	in	r0, 0x3f	; 63
    3ae0:	f8 94       	cli
    3ae2:	0f 92       	push	r0
    3ae4:	f8 01       	movw	r30, r16
    3ae6:	92 8d       	ldd	r25, Z+26	; 0x1a
    3ae8:	83 8d       	ldd	r24, Z+27	; 0x1b
    3aea:	98 17       	cp	r25, r24
    3aec:	00 f5       	brcc	.+64     	; 0x3b2e <xQueueGive+0x90>
    3aee:	80 81       	ld	r24, Z
    3af0:	91 81       	ldd	r25, Z+1	; 0x01
    3af2:	89 2b       	or	r24, r25
    3af4:	09 f0       	breq	.+2      	; 0x3af8 <xQueueGive+0x5a>
    3af6:	2b c1       	rjmp	.+598    	; 0x3d4e <xQueueGive+0x2b0>
    3af8:	82 81       	ldd	r24, Z+2	; 0x02
    3afa:	93 81       	ldd	r25, Z+3	; 0x03
    3afc:	0e 94 32 2c 	call	0x5864	; 0x5864 <xTaskPriorityDisinherit>
    3b00:	f8 01       	movw	r30, r16
    3b02:	13 82       	std	Z+3, r1	; 0x03
    3b04:	12 82       	std	Z+2, r1	; 0x02
    3b06:	92 8d       	ldd	r25, Z+26	; 0x1a
    3b08:	9f 5f       	subi	r25, 0xFF	; 255
    3b0a:	92 8f       	std	Z+26, r25	; 0x1a
    3b0c:	91 89       	ldd	r25, Z+17	; 0x11
    3b0e:	99 23       	and	r25, r25
    3b10:	41 f0       	breq	.+16     	; 0x3b22 <xQueueGive+0x84>
    3b12:	c8 01       	movw	r24, r16
    3b14:	41 96       	adiw	r24, 0x11	; 17
    3b16:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3b1a:	81 30       	cpi	r24, 0x01	; 1
    3b1c:	21 f4       	brne	.+8      	; 0x3b26 <xQueueGive+0x88>
    3b1e:	40 db       	rcall	.-2432   	; 0x31a0 <vPortYield>
    3b20:	02 c0       	rjmp	.+4      	; 0x3b26 <xQueueGive+0x88>
    3b22:	81 11       	cpse	r24, r1
    3b24:	3d db       	rcall	.-2438   	; 0x31a0 <vPortYield>
    3b26:	0f 90       	pop	r0
    3b28:	0f be       	out	0x3f, r0	; 63
    3b2a:	81 e0       	ldi	r24, 0x01	; 1
    3b2c:	18 c1       	rjmp	.+560    	; 0x3d5e <xQueueGive+0x2c0>
    3b2e:	8c 81       	ldd	r24, Y+4	; 0x04
    3b30:	9d 81       	ldd	r25, Y+5	; 0x05
    3b32:	89 2b       	or	r24, r25
    3b34:	21 f4       	brne	.+8      	; 0x3b3e <xQueueGive+0xa0>
    3b36:	0f 90       	pop	r0
    3b38:	0f be       	out	0x3f, r0	; 63
    3b3a:	80 e0       	ldi	r24, 0x00	; 0
    3b3c:	10 c1       	rjmp	.+544    	; 0x3d5e <xQueueGive+0x2c0>
    3b3e:	a1 10       	cpse	r10, r1
    3b40:	05 c0       	rjmp	.+10     	; 0x3b4c <xQueueGive+0xae>
    3b42:	ce 01       	movw	r24, r28
    3b44:	01 96       	adiw	r24, 0x01	; 1
    3b46:	0e 94 81 2b 	call	0x5702	; 0x5702 <vTaskSetTimeOutState>
    3b4a:	a9 2c       	mov	r10, r9
    3b4c:	0f 90       	pop	r0
    3b4e:	0f be       	out	0x3f, r0	; 63
    3b50:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspendAll>
    3b54:	0f b6       	in	r0, 0x3f	; 63
    3b56:	f8 94       	cli
    3b58:	0f 92       	push	r0
    3b5a:	f8 01       	movw	r30, r16
    3b5c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b5e:	8f 3f       	cpi	r24, 0xFF	; 255
    3b60:	09 f4       	brne	.+2      	; 0x3b64 <xQueueGive+0xc6>
    3b62:	15 8e       	std	Z+29, r1	; 0x1d
    3b64:	f8 01       	movw	r30, r16
    3b66:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b68:	8f 3f       	cpi	r24, 0xFF	; 255
    3b6a:	09 f4       	brne	.+2      	; 0x3b6e <xQueueGive+0xd0>
    3b6c:	16 8e       	std	Z+30, r1	; 0x1e
    3b6e:	0f 90       	pop	r0
    3b70:	0f be       	out	0x3f, r0	; 63
    3b72:	be 01       	movw	r22, r28
    3b74:	6c 5f       	subi	r22, 0xFC	; 252
    3b76:	7f 4f       	sbci	r23, 0xFF	; 255
    3b78:	ce 01       	movw	r24, r28
    3b7a:	01 96       	adiw	r24, 0x01	; 1
    3b7c:	0e 94 8c 2b 	call	0x5718	; 0x5718 <xTaskCheckForTimeOut>
    3b80:	81 11       	cpse	r24, r1
    3b82:	96 c0       	rjmp	.+300    	; 0x3cb0 <xQueueGive+0x212>
    3b84:	0f b6       	in	r0, 0x3f	; 63
    3b86:	f8 94       	cli
    3b88:	0f 92       	push	r0
    3b8a:	f8 01       	movw	r30, r16
    3b8c:	92 8d       	ldd	r25, Z+26	; 0x1a
    3b8e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3b90:	0f 90       	pop	r0
    3b92:	0f be       	out	0x3f, r0	; 63
    3b94:	98 13       	cpse	r25, r24
    3b96:	4a c0       	rjmp	.+148    	; 0x3c2c <xQueueGive+0x18e>
    3b98:	6c 81       	ldd	r22, Y+4	; 0x04
    3b9a:	7d 81       	ldd	r23, Y+5	; 0x05
    3b9c:	c7 01       	movw	r24, r14
    3b9e:	0e 94 de 2a 	call	0x55bc	; 0x55bc <vTaskPlaceOnEventList>
    3ba2:	0f b6       	in	r0, 0x3f	; 63
    3ba4:	f8 94       	cli
    3ba6:	0f 92       	push	r0
    3ba8:	f8 01       	movw	r30, r16
    3baa:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bac:	18 16       	cp	r1, r24
    3bae:	ac f4       	brge	.+42     	; 0x3bda <xQueueGive+0x13c>
    3bb0:	81 89       	ldd	r24, Z+17	; 0x11
    3bb2:	81 11       	cpse	r24, r1
    3bb4:	05 c0       	rjmp	.+10     	; 0x3bc0 <xQueueGive+0x122>
    3bb6:	11 c0       	rjmp	.+34     	; 0x3bda <xQueueGive+0x13c>
    3bb8:	f8 01       	movw	r30, r16
    3bba:	81 89       	ldd	r24, Z+17	; 0x11
    3bbc:	88 23       	and	r24, r24
    3bbe:	69 f0       	breq	.+26     	; 0x3bda <xQueueGive+0x13c>
    3bc0:	c6 01       	movw	r24, r12
    3bc2:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3bc6:	81 11       	cpse	r24, r1
    3bc8:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3bcc:	f8 01       	movw	r30, r16
    3bce:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bd0:	81 50       	subi	r24, 0x01	; 1
    3bd2:	86 8f       	std	Z+30, r24	; 0x1e
    3bd4:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bd6:	18 16       	cp	r1, r24
    3bd8:	7c f3       	brlt	.-34     	; 0x3bb8 <xQueueGive+0x11a>
    3bda:	f8 01       	movw	r30, r16
    3bdc:	b6 8e       	std	Z+30, r11	; 0x1e
    3bde:	0f 90       	pop	r0
    3be0:	0f be       	out	0x3f, r0	; 63
    3be2:	0f b6       	in	r0, 0x3f	; 63
    3be4:	f8 94       	cli
    3be6:	0f 92       	push	r0
    3be8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3bea:	18 16       	cp	r1, r24
    3bec:	ac f4       	brge	.+42     	; 0x3c18 <xQueueGive+0x17a>
    3bee:	80 85       	ldd	r24, Z+8	; 0x08
    3bf0:	81 11       	cpse	r24, r1
    3bf2:	05 c0       	rjmp	.+10     	; 0x3bfe <xQueueGive+0x160>
    3bf4:	11 c0       	rjmp	.+34     	; 0x3c18 <xQueueGive+0x17a>
    3bf6:	f8 01       	movw	r30, r16
    3bf8:	80 85       	ldd	r24, Z+8	; 0x08
    3bfa:	88 23       	and	r24, r24
    3bfc:	69 f0       	breq	.+26     	; 0x3c18 <xQueueGive+0x17a>
    3bfe:	c7 01       	movw	r24, r14
    3c00:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3c04:	81 11       	cpse	r24, r1
    3c06:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3c0a:	f8 01       	movw	r30, r16
    3c0c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c0e:	81 50       	subi	r24, 0x01	; 1
    3c10:	85 8f       	std	Z+29, r24	; 0x1d
    3c12:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c14:	18 16       	cp	r1, r24
    3c16:	7c f3       	brlt	.-34     	; 0x3bf6 <xQueueGive+0x158>
    3c18:	f8 01       	movw	r30, r16
    3c1a:	b5 8e       	std	Z+29, r11	; 0x1d
    3c1c:	0f 90       	pop	r0
    3c1e:	0f be       	out	0x3f, r0	; 63
    3c20:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    3c24:	81 11       	cpse	r24, r1
    3c26:	5b cf       	rjmp	.-330    	; 0x3ade <xQueueGive+0x40>
    3c28:	bb da       	rcall	.-2698   	; 0x31a0 <vPortYield>
    3c2a:	59 cf       	rjmp	.-334    	; 0x3ade <xQueueGive+0x40>
    3c2c:	0f b6       	in	r0, 0x3f	; 63
    3c2e:	f8 94       	cli
    3c30:	0f 92       	push	r0
    3c32:	f8 01       	movw	r30, r16
    3c34:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c36:	18 16       	cp	r1, r24
    3c38:	ac f4       	brge	.+42     	; 0x3c64 <xQueueGive+0x1c6>
    3c3a:	81 89       	ldd	r24, Z+17	; 0x11
    3c3c:	81 11       	cpse	r24, r1
    3c3e:	05 c0       	rjmp	.+10     	; 0x3c4a <xQueueGive+0x1ac>
    3c40:	11 c0       	rjmp	.+34     	; 0x3c64 <xQueueGive+0x1c6>
    3c42:	f8 01       	movw	r30, r16
    3c44:	81 89       	ldd	r24, Z+17	; 0x11
    3c46:	88 23       	and	r24, r24
    3c48:	69 f0       	breq	.+26     	; 0x3c64 <xQueueGive+0x1c6>
    3c4a:	c6 01       	movw	r24, r12
    3c4c:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3c50:	81 11       	cpse	r24, r1
    3c52:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3c56:	f8 01       	movw	r30, r16
    3c58:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c5a:	81 50       	subi	r24, 0x01	; 1
    3c5c:	86 8f       	std	Z+30, r24	; 0x1e
    3c5e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c60:	18 16       	cp	r1, r24
    3c62:	7c f3       	brlt	.-34     	; 0x3c42 <xQueueGive+0x1a4>
    3c64:	f8 01       	movw	r30, r16
    3c66:	b6 8e       	std	Z+30, r11	; 0x1e
    3c68:	0f 90       	pop	r0
    3c6a:	0f be       	out	0x3f, r0	; 63
    3c6c:	0f b6       	in	r0, 0x3f	; 63
    3c6e:	f8 94       	cli
    3c70:	0f 92       	push	r0
    3c72:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c74:	18 16       	cp	r1, r24
    3c76:	ac f4       	brge	.+42     	; 0x3ca2 <xQueueGive+0x204>
    3c78:	80 85       	ldd	r24, Z+8	; 0x08
    3c7a:	81 11       	cpse	r24, r1
    3c7c:	05 c0       	rjmp	.+10     	; 0x3c88 <xQueueGive+0x1ea>
    3c7e:	11 c0       	rjmp	.+34     	; 0x3ca2 <xQueueGive+0x204>
    3c80:	f8 01       	movw	r30, r16
    3c82:	80 85       	ldd	r24, Z+8	; 0x08
    3c84:	88 23       	and	r24, r24
    3c86:	69 f0       	breq	.+26     	; 0x3ca2 <xQueueGive+0x204>
    3c88:	c7 01       	movw	r24, r14
    3c8a:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3c8e:	81 11       	cpse	r24, r1
    3c90:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3c94:	f8 01       	movw	r30, r16
    3c96:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c98:	81 50       	subi	r24, 0x01	; 1
    3c9a:	85 8f       	std	Z+29, r24	; 0x1d
    3c9c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c9e:	18 16       	cp	r1, r24
    3ca0:	7c f3       	brlt	.-34     	; 0x3c80 <xQueueGive+0x1e2>
    3ca2:	f8 01       	movw	r30, r16
    3ca4:	b5 8e       	std	Z+29, r11	; 0x1d
    3ca6:	0f 90       	pop	r0
    3ca8:	0f be       	out	0x3f, r0	; 63
    3caa:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    3cae:	17 cf       	rjmp	.-466    	; 0x3ade <xQueueGive+0x40>
    3cb0:	0f b6       	in	r0, 0x3f	; 63
    3cb2:	f8 94       	cli
    3cb4:	0f 92       	push	r0
    3cb6:	f8 01       	movw	r30, r16
    3cb8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cba:	18 16       	cp	r1, r24
    3cbc:	d4 f4       	brge	.+52     	; 0x3cf2 <xQueueGive+0x254>
    3cbe:	81 89       	ldd	r24, Z+17	; 0x11
    3cc0:	81 11       	cpse	r24, r1
    3cc2:	06 c0       	rjmp	.+12     	; 0x3cd0 <xQueueGive+0x232>
    3cc4:	16 c0       	rjmp	.+44     	; 0x3cf2 <xQueueGive+0x254>
    3cc6:	f8 01       	movw	r30, r16
    3cc8:	81 89       	ldd	r24, Z+17	; 0x11
    3cca:	81 11       	cpse	r24, r1
    3ccc:	05 c0       	rjmp	.+10     	; 0x3cd8 <xQueueGive+0x23a>
    3cce:	11 c0       	rjmp	.+34     	; 0x3cf2 <xQueueGive+0x254>
    3cd0:	78 01       	movw	r14, r16
    3cd2:	f1 e1       	ldi	r31, 0x11	; 17
    3cd4:	ef 0e       	add	r14, r31
    3cd6:	f1 1c       	adc	r15, r1
    3cd8:	c7 01       	movw	r24, r14
    3cda:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3cde:	81 11       	cpse	r24, r1
    3ce0:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3ce4:	f8 01       	movw	r30, r16
    3ce6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ce8:	81 50       	subi	r24, 0x01	; 1
    3cea:	86 8f       	std	Z+30, r24	; 0x1e
    3cec:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cee:	18 16       	cp	r1, r24
    3cf0:	54 f3       	brlt	.-44     	; 0x3cc6 <xQueueGive+0x228>
    3cf2:	8f ef       	ldi	r24, 0xFF	; 255
    3cf4:	f8 01       	movw	r30, r16
    3cf6:	86 8f       	std	Z+30, r24	; 0x1e
    3cf8:	0f 90       	pop	r0
    3cfa:	0f be       	out	0x3f, r0	; 63
    3cfc:	0f b6       	in	r0, 0x3f	; 63
    3cfe:	f8 94       	cli
    3d00:	0f 92       	push	r0
    3d02:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d04:	18 16       	cp	r1, r24
    3d06:	d4 f4       	brge	.+52     	; 0x3d3c <xQueueGive+0x29e>
    3d08:	80 85       	ldd	r24, Z+8	; 0x08
    3d0a:	81 11       	cpse	r24, r1
    3d0c:	06 c0       	rjmp	.+12     	; 0x3d1a <xQueueGive+0x27c>
    3d0e:	16 c0       	rjmp	.+44     	; 0x3d3c <xQueueGive+0x29e>
    3d10:	f8 01       	movw	r30, r16
    3d12:	80 85       	ldd	r24, Z+8	; 0x08
    3d14:	81 11       	cpse	r24, r1
    3d16:	05 c0       	rjmp	.+10     	; 0x3d22 <xQueueGive+0x284>
    3d18:	11 c0       	rjmp	.+34     	; 0x3d3c <xQueueGive+0x29e>
    3d1a:	78 01       	movw	r14, r16
    3d1c:	f8 e0       	ldi	r31, 0x08	; 8
    3d1e:	ef 0e       	add	r14, r31
    3d20:	f1 1c       	adc	r15, r1
    3d22:	c7 01       	movw	r24, r14
    3d24:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3d28:	81 11       	cpse	r24, r1
    3d2a:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
    3d2e:	f8 01       	movw	r30, r16
    3d30:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d32:	81 50       	subi	r24, 0x01	; 1
    3d34:	85 8f       	std	Z+29, r24	; 0x1d
    3d36:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d38:	18 16       	cp	r1, r24
    3d3a:	54 f3       	brlt	.-44     	; 0x3d10 <xQueueGive+0x272>
    3d3c:	8f ef       	ldi	r24, 0xFF	; 255
    3d3e:	f8 01       	movw	r30, r16
    3d40:	85 8f       	std	Z+29, r24	; 0x1d
    3d42:	0f 90       	pop	r0
    3d44:	0f be       	out	0x3f, r0	; 63
    3d46:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    3d4a:	80 e0       	ldi	r24, 0x00	; 0
    3d4c:	08 c0       	rjmp	.+16     	; 0x3d5e <xQueueGive+0x2c0>
    3d4e:	f8 01       	movw	r30, r16
    3d50:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d52:	8f 5f       	subi	r24, 0xFF	; 255
    3d54:	82 8f       	std	Z+26, r24	; 0x1a
    3d56:	81 89       	ldd	r24, Z+17	; 0x11
    3d58:	81 11       	cpse	r24, r1
    3d5a:	db ce       	rjmp	.-586    	; 0x3b12 <xQueueGive+0x74>
    3d5c:	e4 ce       	rjmp	.-568    	; 0x3b26 <xQueueGive+0x88>
    3d5e:	0f 90       	pop	r0
    3d60:	0f 90       	pop	r0
    3d62:	0f 90       	pop	r0
    3d64:	0f 90       	pop	r0
    3d66:	0f 90       	pop	r0
    3d68:	df 91       	pop	r29
    3d6a:	cf 91       	pop	r28
    3d6c:	1f 91       	pop	r17
    3d6e:	0f 91       	pop	r16
    3d70:	ff 90       	pop	r15
    3d72:	ef 90       	pop	r14
    3d74:	df 90       	pop	r13
    3d76:	cf 90       	pop	r12
    3d78:	bf 90       	pop	r11
    3d7a:	af 90       	pop	r10
    3d7c:	9f 90       	pop	r9
    3d7e:	08 95       	ret

00003d80 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3d80:	cf 93       	push	r28
    3d82:	df 93       	push	r29
    3d84:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3d86:	92 8d       	ldd	r25, Z+26	; 0x1a
    3d88:	83 8d       	ldd	r24, Z+27	; 0x1b
    3d8a:	98 17       	cp	r25, r24
    3d8c:	d0 f4       	brcc	.+52     	; 0x3dc2 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    3d8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d90:	8f 5f       	subi	r24, 0xFF	; 255
    3d92:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3d94:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d96:	8f 3f       	cpi	r24, 0xFF	; 255
    3d98:	79 f4       	brne	.+30     	; 0x3db8 <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3d9a:	81 89       	ldd	r24, Z+17	; 0x11
    3d9c:	88 23       	and	r24, r24
    3d9e:	99 f0       	breq	.+38     	; 0x3dc6 <xQueueGiveFromISR+0x46>
    3da0:	eb 01       	movw	r28, r22
    3da2:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3da4:	41 96       	adiw	r24, 0x11	; 17
    3da6:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3daa:	88 23       	and	r24, r24
    3dac:	71 f0       	breq	.+28     	; 0x3dca <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3dae:	20 97       	sbiw	r28, 0x00	; 0
    3db0:	71 f0       	breq	.+28     	; 0x3dce <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3db2:	81 e0       	ldi	r24, 0x01	; 1
    3db4:	88 83       	st	Y, r24
    3db6:	0c c0       	rjmp	.+24     	; 0x3dd0 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3db8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3dba:	8f 5f       	subi	r24, 0xFF	; 255
    3dbc:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3dbe:	81 e0       	ldi	r24, 0x01	; 1
    3dc0:	07 c0       	rjmp	.+14     	; 0x3dd0 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3dc2:	80 e0       	ldi	r24, 0x00	; 0
    3dc4:	05 c0       	rjmp	.+10     	; 0x3dd0 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    3dc6:	81 e0       	ldi	r24, 0x01	; 1
    3dc8:	03 c0       	rjmp	.+6      	; 0x3dd0 <xQueueGiveFromISR+0x50>
    3dca:	81 e0       	ldi	r24, 0x01	; 1
    3dcc:	01 c0       	rjmp	.+2      	; 0x3dd0 <xQueueGiveFromISR+0x50>
    3dce:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3dd0:	df 91       	pop	r29
    3dd2:	cf 91       	pop	r28
    3dd4:	08 95       	ret

00003dd6 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    3dd6:	6f 92       	push	r6
    3dd8:	7f 92       	push	r7
    3dda:	8f 92       	push	r8
    3ddc:	9f 92       	push	r9
    3dde:	af 92       	push	r10
    3de0:	bf 92       	push	r11
    3de2:	cf 92       	push	r12
    3de4:	df 92       	push	r13
    3de6:	ef 92       	push	r14
    3de8:	ff 92       	push	r15
    3dea:	0f 93       	push	r16
    3dec:	1f 93       	push	r17
    3dee:	cf 93       	push	r28
    3df0:	df 93       	push	r29
    3df2:	00 d0       	rcall	.+0      	; 0x3df4 <xQueueGenericReceive+0x1e>
    3df4:	1f 92       	push	r1
    3df6:	1f 92       	push	r1
    3df8:	cd b7       	in	r28, 0x3d	; 61
    3dfa:	de b7       	in	r29, 0x3e	; 62
    3dfc:	8c 01       	movw	r16, r24
    3dfe:	5b 01       	movw	r10, r22
    3e00:	5d 83       	std	Y+5, r21	; 0x05
    3e02:	4c 83       	std	Y+4, r20	; 0x04
    3e04:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    3e06:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3e08:	77 24       	eor	r7, r7
    3e0a:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3e0c:	99 24       	eor	r9, r9
    3e0e:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3e10:	6c 01       	movw	r12, r24
    3e12:	88 e0       	ldi	r24, 0x08	; 8
    3e14:	c8 0e       	add	r12, r24
    3e16:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3e18:	78 01       	movw	r14, r16
    3e1a:	e1 e1       	ldi	r30, 0x11	; 17
    3e1c:	ee 0e       	add	r14, r30
    3e1e:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3e20:	0f b6       	in	r0, 0x3f	; 63
    3e22:	f8 94       	cli
    3e24:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3e26:	f8 01       	movw	r30, r16
    3e28:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e2a:	88 23       	and	r24, r24
    3e2c:	09 f4       	brne	.+2      	; 0x3e30 <xQueueGenericReceive+0x5a>
    3e2e:	45 c0       	rjmp	.+138    	; 0x3eba <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    3e30:	e6 80       	ldd	r14, Z+6	; 0x06
    3e32:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3e34:	44 8d       	ldd	r20, Z+28	; 0x1c
    3e36:	44 23       	and	r20, r20
    3e38:	a9 f0       	breq	.+42     	; 0x3e64 <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3e3a:	50 e0       	ldi	r21, 0x00	; 0
    3e3c:	c7 01       	movw	r24, r14
    3e3e:	84 0f       	add	r24, r20
    3e40:	95 1f       	adc	r25, r21
    3e42:	97 83       	std	Z+7, r25	; 0x07
    3e44:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3e46:	22 81       	ldd	r18, Z+2	; 0x02
    3e48:	33 81       	ldd	r19, Z+3	; 0x03
    3e4a:	82 17       	cp	r24, r18
    3e4c:	93 07       	cpc	r25, r19
    3e4e:	20 f0       	brcs	.+8      	; 0x3e58 <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3e50:	80 81       	ld	r24, Z
    3e52:	91 81       	ldd	r25, Z+1	; 0x01
    3e54:	97 83       	std	Z+7, r25	; 0x07
    3e56:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    3e58:	f8 01       	movw	r30, r16
    3e5a:	66 81       	ldd	r22, Z+6	; 0x06
    3e5c:	77 81       	ldd	r23, Z+7	; 0x07
    3e5e:	c5 01       	movw	r24, r10
    3e60:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    3e64:	61 10       	cpse	r6, r1
    3e66:	19 c0       	rjmp	.+50     	; 0x3e9a <xQueueGenericReceive+0xc4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    3e68:	f8 01       	movw	r30, r16
    3e6a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e6c:	81 50       	subi	r24, 0x01	; 1
    3e6e:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3e70:	80 81       	ld	r24, Z
    3e72:	91 81       	ldd	r25, Z+1	; 0x01
    3e74:	89 2b       	or	r24, r25
    3e76:	29 f4       	brne	.+10     	; 0x3e82 <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    3e78:	0e 94 72 2c 	call	0x58e4	; 0x58e4 <pvTaskIncrementMutexHeldCount>
    3e7c:	f8 01       	movw	r30, r16
    3e7e:	93 83       	std	Z+3, r25	; 0x03
    3e80:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3e82:	f8 01       	movw	r30, r16
    3e84:	80 85       	ldd	r24, Z+8	; 0x08
    3e86:	88 23       	and	r24, r24
    3e88:	a1 f0       	breq	.+40     	; 0x3eb2 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3e8a:	c8 01       	movw	r24, r16
    3e8c:	08 96       	adiw	r24, 0x08	; 8
    3e8e:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3e92:	81 30       	cpi	r24, 0x01	; 1
    3e94:	71 f4       	brne	.+28     	; 0x3eb2 <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
    3e96:	84 d9       	rcall	.-3320   	; 0x31a0 <vPortYield>
    3e98:	0c c0       	rjmp	.+24     	; 0x3eb2 <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3e9a:	f8 01       	movw	r30, r16
    3e9c:	f7 82       	std	Z+7, r15	; 0x07
    3e9e:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ea0:	81 89       	ldd	r24, Z+17	; 0x11
    3ea2:	88 23       	and	r24, r24
    3ea4:	31 f0       	breq	.+12     	; 0x3eb2 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ea6:	c8 01       	movw	r24, r16
    3ea8:	41 96       	adiw	r24, 0x11	; 17
    3eaa:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3eae:	81 11       	cpse	r24, r1
    3eb0:	77 d9       	rcall	.-3346   	; 0x31a0 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    3eb2:	0f 90       	pop	r0
    3eb4:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3eb6:	81 e0       	ldi	r24, 0x01	; 1
    3eb8:	1a c1       	rjmp	.+564    	; 0x40ee <xQueueGenericReceive+0x318>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3eba:	8c 81       	ldd	r24, Y+4	; 0x04
    3ebc:	9d 81       	ldd	r25, Y+5	; 0x05
    3ebe:	89 2b       	or	r24, r25
    3ec0:	21 f4       	brne	.+8      	; 0x3eca <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3ec2:	0f 90       	pop	r0
    3ec4:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3ec6:	80 e0       	ldi	r24, 0x00	; 0
    3ec8:	12 c1       	rjmp	.+548    	; 0x40ee <xQueueGenericReceive+0x318>
				}
				else if( xEntryTimeSet == pdFALSE )
    3eca:	81 10       	cpse	r8, r1
    3ecc:	05 c0       	rjmp	.+10     	; 0x3ed8 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3ece:	ce 01       	movw	r24, r28
    3ed0:	01 96       	adiw	r24, 0x01	; 1
    3ed2:	0e 94 81 2b 	call	0x5702	; 0x5702 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3ed6:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3ed8:	0f 90       	pop	r0
    3eda:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3edc:	0e 94 4a 28 	call	0x5094	; 0x5094 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3ee0:	0f b6       	in	r0, 0x3f	; 63
    3ee2:	f8 94       	cli
    3ee4:	0f 92       	push	r0
    3ee6:	f8 01       	movw	r30, r16
    3ee8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3eea:	8f 3f       	cpi	r24, 0xFF	; 255
    3eec:	09 f4       	brne	.+2      	; 0x3ef0 <xQueueGenericReceive+0x11a>
    3eee:	15 8e       	std	Z+29, r1	; 0x1d
    3ef0:	f8 01       	movw	r30, r16
    3ef2:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ef4:	8f 3f       	cpi	r24, 0xFF	; 255
    3ef6:	09 f4       	brne	.+2      	; 0x3efa <xQueueGenericReceive+0x124>
    3ef8:	16 8e       	std	Z+30, r1	; 0x1e
    3efa:	0f 90       	pop	r0
    3efc:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3efe:	be 01       	movw	r22, r28
    3f00:	6c 5f       	subi	r22, 0xFC	; 252
    3f02:	7f 4f       	sbci	r23, 0xFF	; 255
    3f04:	ce 01       	movw	r24, r28
    3f06:	01 96       	adiw	r24, 0x01	; 1
    3f08:	0e 94 8c 2b 	call	0x5718	; 0x5718 <xTaskCheckForTimeOut>
    3f0c:	81 11       	cpse	r24, r1
    3f0e:	a2 c0       	rjmp	.+324    	; 0x4054 <xQueueGenericReceive+0x27e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3f10:	0f b6       	in	r0, 0x3f	; 63
    3f12:	f8 94       	cli
    3f14:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3f16:	f8 01       	movw	r30, r16
    3f18:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    3f1a:	0f 90       	pop	r0
    3f1c:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3f1e:	81 11       	cpse	r24, r1
    3f20:	57 c0       	rjmp	.+174    	; 0x3fd0 <xQueueGenericReceive+0x1fa>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3f22:	80 81       	ld	r24, Z
    3f24:	91 81       	ldd	r25, Z+1	; 0x01
    3f26:	89 2b       	or	r24, r25
    3f28:	49 f4       	brne	.+18     	; 0x3f3c <xQueueGenericReceive+0x166>
					{
						taskENTER_CRITICAL();
    3f2a:	0f b6       	in	r0, 0x3f	; 63
    3f2c:	f8 94       	cli
    3f2e:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    3f30:	82 81       	ldd	r24, Z+2	; 0x02
    3f32:	93 81       	ldd	r25, Z+3	; 0x03
    3f34:	0e 94 d0 2b 	call	0x57a0	; 0x57a0 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    3f38:	0f 90       	pop	r0
    3f3a:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3f3c:	6c 81       	ldd	r22, Y+4	; 0x04
    3f3e:	7d 81       	ldd	r23, Y+5	; 0x05
    3f40:	c7 01       	movw	r24, r14
    3f42:	0e 94 de 2a 	call	0x55bc	; 0x55bc <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3f46:	0f b6       	in	r0, 0x3f	; 63
    3f48:	f8 94       	cli
    3f4a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3f4c:	f8 01       	movw	r30, r16
    3f4e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f50:	18 16       	cp	r1, r24
    3f52:	ac f4       	brge	.+42     	; 0x3f7e <xQueueGenericReceive+0x1a8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3f54:	81 89       	ldd	r24, Z+17	; 0x11
    3f56:	81 11       	cpse	r24, r1
    3f58:	05 c0       	rjmp	.+10     	; 0x3f64 <xQueueGenericReceive+0x18e>
    3f5a:	11 c0       	rjmp	.+34     	; 0x3f7e <xQueueGenericReceive+0x1a8>
    3f5c:	f8 01       	movw	r30, r16
    3f5e:	81 89       	ldd	r24, Z+17	; 0x11
    3f60:	88 23       	and	r24, r24
    3f62:	69 f0       	breq	.+26     	; 0x3f7e <xQueueGenericReceive+0x1a8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f64:	c7 01       	movw	r24, r14
    3f66:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3f6a:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3f6c:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3f70:	f8 01       	movw	r30, r16
    3f72:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f74:	81 50       	subi	r24, 0x01	; 1
    3f76:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3f78:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f7a:	18 16       	cp	r1, r24
    3f7c:	7c f3       	brlt	.-34     	; 0x3f5c <xQueueGenericReceive+0x186>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3f7e:	f8 01       	movw	r30, r16
    3f80:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    3f82:	0f 90       	pop	r0
    3f84:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3f86:	0f b6       	in	r0, 0x3f	; 63
    3f88:	f8 94       	cli
    3f8a:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3f8c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f8e:	18 16       	cp	r1, r24
    3f90:	ac f4       	brge	.+42     	; 0x3fbc <xQueueGenericReceive+0x1e6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3f92:	80 85       	ldd	r24, Z+8	; 0x08
    3f94:	81 11       	cpse	r24, r1
    3f96:	05 c0       	rjmp	.+10     	; 0x3fa2 <xQueueGenericReceive+0x1cc>
    3f98:	11 c0       	rjmp	.+34     	; 0x3fbc <xQueueGenericReceive+0x1e6>
    3f9a:	f8 01       	movw	r30, r16
    3f9c:	80 85       	ldd	r24, Z+8	; 0x08
    3f9e:	88 23       	and	r24, r24
    3fa0:	69 f0       	breq	.+26     	; 0x3fbc <xQueueGenericReceive+0x1e6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3fa2:	c6 01       	movw	r24, r12
    3fa4:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3fa8:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    3faa:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3fae:	f8 01       	movw	r30, r16
    3fb0:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fb2:	81 50       	subi	r24, 0x01	; 1
    3fb4:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3fb6:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fb8:	18 16       	cp	r1, r24
    3fba:	7c f3       	brlt	.-34     	; 0x3f9a <xQueueGenericReceive+0x1c4>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3fbc:	f8 01       	movw	r30, r16
    3fbe:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    3fc0:	0f 90       	pop	r0
    3fc2:	0f be       	out	0x3f, r0	; 63
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    3fc4:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    3fc8:	81 11       	cpse	r24, r1
				{
					portYIELD_WITHIN_API();
    3fca:	2a cf       	rjmp	.-428    	; 0x3e20 <xQueueGenericReceive+0x4a>
    3fcc:	e9 d8       	rcall	.-3630   	; 0x31a0 <vPortYield>
    3fce:	28 cf       	rjmp	.-432    	; 0x3e20 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3fd0:	0f b6       	in	r0, 0x3f	; 63
    3fd2:	f8 94       	cli
    3fd4:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3fd6:	f8 01       	movw	r30, r16
    3fd8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fda:	18 16       	cp	r1, r24
    3fdc:	ac f4       	brge	.+42     	; 0x4008 <xQueueGenericReceive+0x232>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3fde:	81 89       	ldd	r24, Z+17	; 0x11
    3fe0:	81 11       	cpse	r24, r1
    3fe2:	05 c0       	rjmp	.+10     	; 0x3fee <xQueueGenericReceive+0x218>
    3fe4:	11 c0       	rjmp	.+34     	; 0x4008 <xQueueGenericReceive+0x232>
    3fe6:	f8 01       	movw	r30, r16
    3fe8:	81 89       	ldd	r24, Z+17	; 0x11
    3fea:	88 23       	and	r24, r24
    3fec:	69 f0       	breq	.+26     	; 0x4008 <xQueueGenericReceive+0x232>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3fee:	c7 01       	movw	r24, r14
    3ff0:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    3ff4:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3ff6:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3ffa:	f8 01       	movw	r30, r16
    3ffc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ffe:	81 50       	subi	r24, 0x01	; 1
    4000:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4002:	86 8d       	ldd	r24, Z+30	; 0x1e
    4004:	18 16       	cp	r1, r24
    4006:	7c f3       	brlt	.-34     	; 0x3fe6 <xQueueGenericReceive+0x210>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4008:	f8 01       	movw	r30, r16
    400a:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    400c:	0f 90       	pop	r0
    400e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4010:	0f b6       	in	r0, 0x3f	; 63
    4012:	f8 94       	cli
    4014:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4016:	85 8d       	ldd	r24, Z+29	; 0x1d
    4018:	18 16       	cp	r1, r24
    401a:	ac f4       	brge	.+42     	; 0x4046 <xQueueGenericReceive+0x270>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    401c:	80 85       	ldd	r24, Z+8	; 0x08
    401e:	81 11       	cpse	r24, r1
    4020:	05 c0       	rjmp	.+10     	; 0x402c <xQueueGenericReceive+0x256>
    4022:	11 c0       	rjmp	.+34     	; 0x4046 <xQueueGenericReceive+0x270>
    4024:	f8 01       	movw	r30, r16
    4026:	80 85       	ldd	r24, Z+8	; 0x08
    4028:	88 23       	and	r24, r24
    402a:	69 f0       	breq	.+26     	; 0x4046 <xQueueGenericReceive+0x270>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    402c:	c6 01       	movw	r24, r12
    402e:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    4032:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    4034:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    4038:	f8 01       	movw	r30, r16
    403a:	85 8d       	ldd	r24, Z+29	; 0x1d
    403c:	81 50       	subi	r24, 0x01	; 1
    403e:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4040:	85 8d       	ldd	r24, Z+29	; 0x1d
    4042:	18 16       	cp	r1, r24
    4044:	7c f3       	brlt	.-34     	; 0x4024 <xQueueGenericReceive+0x24e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4046:	f8 01       	movw	r30, r16
    4048:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    404a:	0f 90       	pop	r0
    404c:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    404e:	0e 94 50 28 	call	0x50a0	; 0x50a0 <xTaskResumeAll>
    4052:	e6 ce       	rjmp	.-564    	; 0x3e20 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4054:	0f b6       	in	r0, 0x3f	; 63
    4056:	f8 94       	cli
    4058:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    405a:	f8 01       	movw	r30, r16
    405c:	86 8d       	ldd	r24, Z+30	; 0x1e
    405e:	18 16       	cp	r1, r24
    4060:	d4 f4       	brge	.+52     	; 0x4096 <xQueueGenericReceive+0x2c0>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4062:	81 89       	ldd	r24, Z+17	; 0x11
    4064:	81 11       	cpse	r24, r1
    4066:	06 c0       	rjmp	.+12     	; 0x4074 <xQueueGenericReceive+0x29e>
    4068:	16 c0       	rjmp	.+44     	; 0x4096 <xQueueGenericReceive+0x2c0>
    406a:	f8 01       	movw	r30, r16
    406c:	81 89       	ldd	r24, Z+17	; 0x11
    406e:	81 11       	cpse	r24, r1
    4070:	05 c0       	rjmp	.+10     	; 0x407c <xQueueGenericReceive+0x2a6>
    4072:	11 c0       	rjmp	.+34     	; 0x4096 <xQueueGenericReceive+0x2c0>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4074:	78 01       	movw	r14, r16
    4076:	f1 e1       	ldi	r31, 0x11	; 17
    4078:	ef 0e       	add	r14, r31
    407a:	f1 1c       	adc	r15, r1
    407c:	c7 01       	movw	r24, r14
    407e:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    4082:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    4084:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    4088:	f8 01       	movw	r30, r16
    408a:	86 8d       	ldd	r24, Z+30	; 0x1e
    408c:	81 50       	subi	r24, 0x01	; 1
    408e:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4090:	86 8d       	ldd	r24, Z+30	; 0x1e
    4092:	18 16       	cp	r1, r24
    4094:	54 f3       	brlt	.-44     	; 0x406a <xQueueGenericReceive+0x294>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4096:	8f ef       	ldi	r24, 0xFF	; 255
    4098:	f8 01       	movw	r30, r16
    409a:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    409c:	0f 90       	pop	r0
    409e:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    40a0:	0f b6       	in	r0, 0x3f	; 63
    40a2:	f8 94       	cli
    40a4:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    40a6:	85 8d       	ldd	r24, Z+29	; 0x1d
    40a8:	18 16       	cp	r1, r24
    40aa:	d4 f4       	brge	.+52     	; 0x40e0 <xQueueGenericReceive+0x30a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    40ac:	80 85       	ldd	r24, Z+8	; 0x08
    40ae:	81 11       	cpse	r24, r1
    40b0:	06 c0       	rjmp	.+12     	; 0x40be <xQueueGenericReceive+0x2e8>
    40b2:	16 c0       	rjmp	.+44     	; 0x40e0 <xQueueGenericReceive+0x30a>
    40b4:	f8 01       	movw	r30, r16
    40b6:	80 85       	ldd	r24, Z+8	; 0x08
    40b8:	81 11       	cpse	r24, r1
    40ba:	05 c0       	rjmp	.+10     	; 0x40c6 <xQueueGenericReceive+0x2f0>
    40bc:	11 c0       	rjmp	.+34     	; 0x40e0 <xQueueGenericReceive+0x30a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    40be:	78 01       	movw	r14, r16
    40c0:	f8 e0       	ldi	r31, 0x08	; 8
    40c2:	ef 0e       	add	r14, r31
    40c4:	f1 1c       	adc	r15, r1
    40c6:	c7 01       	movw	r24, r14
    40c8:	0e 94 39 2b 	call	0x5672	; 0x5672 <xTaskRemoveFromEventList>
    40cc:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    40ce:	0e 94 c7 2b 	call	0x578e	; 0x578e <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    40d2:	f8 01       	movw	r30, r16
    40d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    40d6:	81 50       	subi	r24, 0x01	; 1
    40d8:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    40da:	85 8d       	ldd	r24, Z+29	; 0x1d
    40dc:	18 16       	cp	r1, r24
    40de:	54 f3       	brlt	.-44     	; 0x40b4 <xQueueGenericReceive+0x2de>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    40e0:	8f ef       	ldi	r24, 0xFF	; 255
    40e2:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    40e4:	85 8f       	std	Z+29, r24	; 0x1d
    40e6:	0f 90       	pop	r0
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    40e8:	0f be       	out	0x3f, r0	; 63
    40ea:	da d7       	rcall	.+4020   	; 0x50a0 <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    40ec:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    40ee:	0f 90       	pop	r0
    40f0:	0f 90       	pop	r0
    40f2:	0f 90       	pop	r0
    40f4:	0f 90       	pop	r0
    40f6:	0f 90       	pop	r0
    40f8:	df 91       	pop	r29
    40fa:	cf 91       	pop	r28
    40fc:	1f 91       	pop	r17
    40fe:	0f 91       	pop	r16
    4100:	ff 90       	pop	r15
    4102:	ef 90       	pop	r14
    4104:	df 90       	pop	r13
    4106:	cf 90       	pop	r12
    4108:	bf 90       	pop	r11
    410a:	af 90       	pop	r10
    410c:	9f 90       	pop	r9
    410e:	8f 90       	pop	r8
    4110:	7f 90       	pop	r7
    4112:	6f 90       	pop	r6
    4114:	08 95       	ret

00004116 <server_receiver>:
  uint8_t status = TYPE_PING_RESPONSE;
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
  else simple_p_send(SERVER_ADDRESS, &status, 1);
}

void server_receiver(uint8_t *data, uint16_t len) {
    4116:	ab 01       	movw	r20, r22
  if(data == NULL) { // ARQ passes NULL to the callback when connection is lost
    4118:	00 97       	sbiw	r24, 0x00	; 0
    411a:	11 f4       	brne	.+4      	; 0x4120 <server_receiver+0xa>
      gHandshook = 0;
    411c:	10 92 de 19 	sts	0x19DE, r1	; 0x8019de <gHandshook>
  }
  memcpy(&message_in, data, len);
    4120:	bc 01       	movw	r22, r24
    4122:	81 e5       	ldi	r24, 0x51	; 81
    4124:	9b e1       	ldi	r25, 0x1B	; 27
    4126:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
  xSemaphoreGive(xCommandReadyBSem);
    412a:	60 e0       	ldi	r22, 0x00	; 0
    412c:	70 e0       	ldi	r23, 0x00	; 0
    412e:	80 91 4d 1b 	lds	r24, 0x1B4D	; 0x801b4d <xCommandReadyBSem>
    4132:	90 91 4e 1b 	lds	r25, 0x1B4E	; 0x801b4e <xCommandReadyBSem+0x1>
    4136:	b3 cc       	rjmp	.-1690   	; 0x3a9e <xQueueGive>
    4138:	08 95       	ret

0000413a <server_communication_init>:
#define TYPE_PING           8
#define TYPE_PING_RESPONSE  9
#define TYPE_DEBUG          10

void server_communication_init(void) {
  if(connected) return;
    413a:	80 91 e9 19 	lds	r24, 0x19E9	; 0x8019e9 <connected>
    413e:	81 11       	cpse	r24, r1
    4140:	04 c0       	rjmp	.+8      	; 0x414a <server_communication_init+0x10>
  server_connection = arq_new_connection();
    4142:	0e 94 60 01 	call	0x2c0	; 0x2c0 <arq_new_connection>
    4146:	80 93 83 1b 	sts	0x1B83, r24	; 0x801b83 <server_connection>
    414a:	08 95       	ret

0000414c <server_connect>:
}

uint8_t server_connect(void) {
  connected = arq_connect(server_connection, SERVER_ADDRESS, server_receiver, 1000);
    414c:	28 ee       	ldi	r18, 0xE8	; 232
    414e:	33 e0       	ldi	r19, 0x03	; 3
    4150:	4b e8       	ldi	r20, 0x8B	; 139
    4152:	50 e2       	ldi	r21, 0x20	; 32
    4154:	60 e0       	ldi	r22, 0x00	; 0
    4156:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <server_connection>
    415a:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <arq_connect>
    415e:	80 93 e9 19 	sts	0x19E9, r24	; 0x8019e9 <connected>
  return connected;
}
    4162:	08 95       	ret

00004164 <send_handshake>:

uint8_t send_handshake(void) {
    4164:	cf 93       	push	r28
    4166:	df 93       	push	r29
    4168:	cd b7       	in	r28, 0x3d	; 61
    416a:	de b7       	in	r29, 0x3e	; 62
    416c:	e4 97       	sbiw	r28, 0x34	; 52
    416e:	0f b6       	in	r0, 0x3f	; 63
    4170:	f8 94       	cli
    4172:	de bf       	out	0x3e, r29	; 62
    4174:	0f be       	out	0x3f, r0	; 63
    4176:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return 0;
    4178:	80 91 e9 19 	lds	r24, 0x19E9	; 0x8019e9 <connected>
    417c:	88 23       	and	r24, r24
    417e:	09 f4       	brne	.+2      	; 0x4182 <send_handshake+0x1e>
    4180:	4d c0       	rjmp	.+154    	; 0x421c <send_handshake+0xb8>
  message_t msg;
  msg.type = TYPE_HANDSHAKE;
    4182:	19 82       	std	Y+1, r1	; 0x01
  msg.message.handshake.name_length = ROBOT_NAME_LENGTH;
    4184:	83 e0       	ldi	r24, 0x03	; 3
    4186:	8a 83       	std	Y+2, r24	; 0x02
  strcpy((char*)msg.message.handshake.name, ROBOT_NAME);
    4188:	81 e4       	ldi	r24, 0x41	; 65
    418a:	92 e5       	ldi	r25, 0x52	; 82
    418c:	9c 83       	std	Y+4, r25	; 0x04
    418e:	8b 83       	std	Y+3, r24	; 0x03
    4190:	84 e4       	ldi	r24, 0x44	; 68
    4192:	90 e0       	ldi	r25, 0x00	; 0
    4194:	9e 83       	std	Y+6, r25	; 0x06
    4196:	8d 83       	std	Y+5, r24	; 0x05
  msg.message.handshake.width = ROBOT_TOTAL_WIDTH_MM;
    4198:	24 eb       	ldi	r18, 0xB4	; 180
    419a:	30 e0       	ldi	r19, 0x00	; 0
    419c:	3f 83       	std	Y+7, r19	; 0x07
    419e:	2e 83       	std	Y+6, r18	; 0x06
  msg.message.handshake.length = ROBOT_TOTAL_LENGTH_MM;
    41a0:	85 ef       	ldi	r24, 0xF5	; 245
    41a2:	90 e0       	ldi	r25, 0x00	; 0
    41a4:	99 87       	std	Y+9, r25	; 0x09
    41a6:	88 87       	std	Y+8, r24	; 0x08
  msg.message.handshake.axel_offset = ROBOT_AXEL_OFFSET_MM;
    41a8:	88 e3       	ldi	r24, 0x38	; 56
    41aa:	8c 87       	std	Y+12, r24	; 0x0c
  msg.message.handshake.tower_offset_x = SENSOR_TOWER_OFFSET_X_MM;
    41ac:	8a 87       	std	Y+10, r24	; 0x0a
  msg.message.handshake.tower_offset_y = SENSOR_TOWER_OFFSET_Y_MM;
    41ae:	1b 86       	std	Y+11, r1	; 0x0b
  msg.message.handshake.sensor_offset1 = SENSOR_OFFSET_RADIUS_MM;
    41b0:	85 e1       	ldi	r24, 0x15	; 21
    41b2:	8d 87       	std	Y+13, r24	; 0x0d
  msg.message.handshake.sensor_offset2 = SENSOR_OFFSET_RADIUS_MM;
    41b4:	8e 87       	std	Y+14, r24	; 0x0e
  msg.message.handshake.sensor_offset3 = SENSOR_OFFSET_RADIUS_MM;
    41b6:	8f 87       	std	Y+15, r24	; 0x0f
  msg.message.handshake.sensor_offset4 = SENSOR_OFFSET_RADIUS_MM;
    41b8:	88 8b       	std	Y+16, r24	; 0x10
  msg.message.handshake.sensor_heading1 = SENSOR1_HEADING_DEG;
    41ba:	1a 8a       	std	Y+18, r1	; 0x12
    41bc:	19 8a       	std	Y+17, r1	; 0x11
  msg.message.handshake.sensor_heading2 = SENSOR2_HEADING_DEG;
    41be:	8a e5       	ldi	r24, 0x5A	; 90
    41c0:	90 e0       	ldi	r25, 0x00	; 0
    41c2:	9c 8b       	std	Y+20, r25	; 0x14
    41c4:	8b 8b       	std	Y+19, r24	; 0x13
  msg.message.handshake.sensor_heading3 = SENSOR3_HEADING_DEG;
    41c6:	3e 8b       	std	Y+22, r19	; 0x16
    41c8:	2d 8b       	std	Y+21, r18	; 0x15
  msg.message.handshake.sensor_heading4 = SENSOR4_HEADING_DEG;
    41ca:	8e e0       	ldi	r24, 0x0E	; 14
    41cc:	91 e0       	ldi	r25, 0x01	; 1
    41ce:	98 8f       	std	Y+24, r25	; 0x18
    41d0:	8f 8b       	std	Y+23, r24	; 0x17
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
    41d2:	88 ec       	ldi	r24, 0xC8	; 200
    41d4:	90 e0       	ldi	r25, 0x00	; 0
    41d6:	9a 8f       	std	Y+26, r25	; 0x1a
    41d8:	89 8f       	std	Y+25, r24	; 0x19
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    41da:	8a e1       	ldi	r24, 0x1A	; 26
    41dc:	fe 01       	movw	r30, r28
    41de:	31 96       	adiw	r30, 0x01	; 1
    41e0:	de 01       	movw	r26, r28
    41e2:	5b 96       	adiw	r26, 0x1b	; 27
    41e4:	01 90       	ld	r0, Z+
    41e6:	0d 92       	st	X+, r0
    41e8:	8a 95       	dec	r24
    41ea:	e1 f7       	brne	.-8      	; 0x41e4 <send_handshake+0x80>
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
    41ec:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <use_arq>
    41f0:	88 23       	and	r24, r24
    41f2:	59 f0       	breq	.+22     	; 0x420a <send_handshake+0xa6>
    41f4:	4a e1       	ldi	r20, 0x1A	; 26
    41f6:	50 e0       	ldi	r21, 0x00	; 0
    41f8:	be 01       	movw	r22, r28
    41fa:	65 5e       	subi	r22, 0xE5	; 229
    41fc:	7f 4f       	sbci	r23, 0xFF	; 255
    41fe:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <server_connection>
    4202:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
  else simple_p_send(server_connection, data, sizeof(data));
  return 1;
    4206:	81 e0       	ldi	r24, 0x01	; 1
    4208:	09 c0       	rjmp	.+18     	; 0x421c <send_handshake+0xb8>
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
  else simple_p_send(server_connection, data, sizeof(data));
    420a:	4a e1       	ldi	r20, 0x1A	; 26
    420c:	50 e0       	ldi	r21, 0x00	; 0
    420e:	be 01       	movw	r22, r28
    4210:	65 5e       	subi	r22, 0xE5	; 229
    4212:	7f 4f       	sbci	r23, 0xFF	; 255
    4214:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <server_connection>
    4218:	89 d1       	rcall	.+786    	; 0x452c <simple_p_send>
  return 1;
    421a:	81 e0       	ldi	r24, 0x01	; 1
}
    421c:	e4 96       	adiw	r28, 0x34	; 52
    421e:	0f b6       	in	r0, 0x3f	; 63
    4220:	f8 94       	cli
    4222:	de bf       	out	0x3e, r29	; 62
    4224:	0f be       	out	0x3f, r0	; 63
    4226:	cd bf       	out	0x3d, r28	; 61
    4228:	df 91       	pop	r29
    422a:	cf 91       	pop	r28
    422c:	08 95       	ret

0000422e <send_update>:

void send_update(int16_t x_cm, int16_t y_cm, int16_t heading_deg, int16_t towerAngle_deg, uint8_t S1_cm, uint8_t S2_cm, uint8_t S3_cm, uint8_t S4_cm){
    422e:	af 92       	push	r10
    4230:	cf 92       	push	r12
    4232:	ef 92       	push	r14
    4234:	0f 93       	push	r16
    4236:	cf 93       	push	r28
    4238:	df 93       	push	r29
    423a:	cd b7       	in	r28, 0x3d	; 61
    423c:	de b7       	in	r29, 0x3e	; 62
    423e:	2d 97       	sbiw	r28, 0x0d	; 13
    4240:	0f b6       	in	r0, 0x3f	; 63
    4242:	f8 94       	cli
    4244:	de bf       	out	0x3e, r29	; 62
    4246:	0f be       	out	0x3f, r0	; 63
    4248:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return;
    424a:	e0 91 e9 19 	lds	r30, 0x19E9	; 0x8019e9 <connected>
    424e:	ee 23       	and	r30, r30
    4250:	19 f1       	breq	.+70     	; 0x4298 <send_update+0x6a>
  msg.message.update.sensor1 = S1_cm;
  msg.message.update.sensor2 = S2_cm;
  msg.message.update.sensor3 = S3_cm;
  msg.message.update.sensor4 = S4_cm;
  uint8_t data[sizeof(update_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    4252:	e1 e0       	ldi	r30, 0x01	; 1
    4254:	e9 83       	std	Y+1, r30	; 0x01
    4256:	9b 83       	std	Y+3, r25	; 0x03
    4258:	8a 83       	std	Y+2, r24	; 0x02
    425a:	7d 83       	std	Y+5, r23	; 0x05
    425c:	6c 83       	std	Y+4, r22	; 0x04
    425e:	5f 83       	std	Y+7, r21	; 0x07
    4260:	4e 83       	std	Y+6, r20	; 0x06
    4262:	39 87       	std	Y+9, r19	; 0x09
    4264:	28 87       	std	Y+8, r18	; 0x08
    4266:	0a 87       	std	Y+10, r16	; 0x0a
    4268:	eb 86       	std	Y+11, r14	; 0x0b
    426a:	cc 86       	std	Y+12, r12	; 0x0c
    426c:	ad 86       	std	Y+13, r10	; 0x0d
  if(use_arq[TYPE_UPDATE]) arq_send(server_connection, data, sizeof(data));
    426e:	80 91 01 06 	lds	r24, 0x0601	; 0x800601 <use_arq+0x1>
    4272:	88 23       	and	r24, r24
    4274:	51 f0       	breq	.+20     	; 0x428a <send_update+0x5c>
    4276:	4d e0       	ldi	r20, 0x0D	; 13
    4278:	50 e0       	ldi	r21, 0x00	; 0
    427a:	be 01       	movw	r22, r28
    427c:	6f 5f       	subi	r22, 0xFF	; 255
    427e:	7f 4f       	sbci	r23, 0xFF	; 255
    4280:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <server_connection>
    4284:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4288:	07 c0       	rjmp	.+14     	; 0x4298 <send_update+0x6a>
  else simple_p_send(SERVER_ADDRESS, data, sizeof(data));
    428a:	4d e0       	ldi	r20, 0x0D	; 13
    428c:	50 e0       	ldi	r21, 0x00	; 0
    428e:	be 01       	movw	r22, r28
    4290:	6f 5f       	subi	r22, 0xFF	; 255
    4292:	7f 4f       	sbci	r23, 0xFF	; 255
    4294:	80 e0       	ldi	r24, 0x00	; 0
    4296:	4a d1       	rcall	.+660    	; 0x452c <simple_p_send>
}
    4298:	2d 96       	adiw	r28, 0x0d	; 13
    429a:	0f b6       	in	r0, 0x3f	; 63
    429c:	f8 94       	cli
    429e:	de bf       	out	0x3e, r29	; 62
    42a0:	0f be       	out	0x3f, r0	; 63
    42a2:	cd bf       	out	0x3d, r28	; 61
    42a4:	df 91       	pop	r29
    42a6:	cf 91       	pop	r28
    42a8:	0f 91       	pop	r16
    42aa:	ef 90       	pop	r14
    42ac:	cf 90       	pop	r12
    42ae:	af 90       	pop	r10
    42b0:	08 95       	ret

000042b2 <send_idle>:

void send_idle(void) {
    42b2:	cf 93       	push	r28
    42b4:	df 93       	push	r29
    42b6:	1f 92       	push	r1
    42b8:	cd b7       	in	r28, 0x3d	; 61
    42ba:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    42bc:	80 91 e9 19 	lds	r24, 0x19E9	; 0x8019e9 <connected>
    42c0:	88 23       	and	r24, r24
    42c2:	b9 f0       	breq	.+46     	; 0x42f2 <send_idle+0x40>
  uint8_t status = TYPE_IDLE;
    42c4:	83 e0       	ldi	r24, 0x03	; 3
    42c6:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_IDLE]) arq_send(server_connection, &status, 1);
    42c8:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <use_arq+0x3>
    42cc:	88 23       	and	r24, r24
    42ce:	51 f0       	breq	.+20     	; 0x42e4 <send_idle+0x32>
    42d0:	41 e0       	ldi	r20, 0x01	; 1
    42d2:	50 e0       	ldi	r21, 0x00	; 0
    42d4:	be 01       	movw	r22, r28
    42d6:	6f 5f       	subi	r22, 0xFF	; 255
    42d8:	7f 4f       	sbci	r23, 0xFF	; 255
    42da:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <server_connection>
    42de:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    42e2:	07 c0       	rjmp	.+14     	; 0x42f2 <send_idle+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    42e4:	41 e0       	ldi	r20, 0x01	; 1
    42e6:	50 e0       	ldi	r21, 0x00	; 0
    42e8:	be 01       	movw	r22, r28
    42ea:	6f 5f       	subi	r22, 0xFF	; 255
    42ec:	7f 4f       	sbci	r23, 0xFF	; 255
    42ee:	80 e0       	ldi	r24, 0x00	; 0
    42f0:	1d d1       	rcall	.+570    	; 0x452c <simple_p_send>
}
    42f2:	0f 90       	pop	r0
    42f4:	df 91       	pop	r29
    42f6:	cf 91       	pop	r28
    42f8:	08 95       	ret

000042fa <debug>:
void debug(const char *fmt, ...) {
    42fa:	cf 93       	push	r28
    42fc:	df 93       	push	r29
    42fe:	cd b7       	in	r28, 0x3d	; 61
    4300:	de b7       	in	r29, 0x3e	; 62
    4302:	c4 56       	subi	r28, 0x64	; 100
    4304:	d1 09       	sbc	r29, r1
    4306:	0f b6       	in	r0, 0x3f	; 63
    4308:	f8 94       	cli
    430a:	de bf       	out	0x3e, r29	; 62
    430c:	0f be       	out	0x3f, r0	; 63
    430e:	cd bf       	out	0x3d, r28	; 61
    4310:	ae 01       	movw	r20, r28
    4312:	46 59       	subi	r20, 0x96	; 150
    4314:	5f 4f       	sbci	r21, 0xFF	; 255
    4316:	fa 01       	movw	r30, r20
    4318:	61 91       	ld	r22, Z+
    431a:	71 91       	ld	r23, Z+
    431c:	af 01       	movw	r20, r30
	uint8_t buf[100];
	va_list ap;
	buf[0] = TYPE_DEBUG;
    431e:	8a e0       	ldi	r24, 0x0A	; 10
    4320:	89 83       	std	Y+1, r24	; 0x01
	va_start(ap, fmt);
	uint8_t ret = vsprintf((char*)buf+1, fmt, ap);
    4322:	ce 01       	movw	r24, r28
    4324:	02 96       	adiw	r24, 0x02	; 2
    4326:	0e 94 b3 38 	call	0x7166	; 0x7166 <vsprintf>
	va_end(ap);
	if (ret > 0) {
    432a:	88 23       	and	r24, r24
    432c:	c9 f0       	breq	.+50     	; 0x4360 <debug+0x66>
		if(use_arq[TYPE_DEBUG]) arq_send(server_connection, buf, ret+1);
    432e:	20 91 0a 06 	lds	r18, 0x060A	; 0x80060a <use_arq+0xa>
    4332:	22 23       	and	r18, r18
    4334:	61 f0       	breq	.+24     	; 0x434e <debug+0x54>
    4336:	99 27       	eor	r25, r25
    4338:	ac 01       	movw	r20, r24
    433a:	4f 5f       	subi	r20, 0xFF	; 255
    433c:	5f 4f       	sbci	r21, 0xFF	; 255
    433e:	be 01       	movw	r22, r28
    4340:	6f 5f       	subi	r22, 0xFF	; 255
    4342:	7f 4f       	sbci	r23, 0xFF	; 255
    4344:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <server_connection>
    4348:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    434c:	09 c0       	rjmp	.+18     	; 0x4360 <debug+0x66>
		else simple_p_send(SERVER_ADDRESS, buf, ret+1);
    434e:	99 27       	eor	r25, r25
    4350:	ac 01       	movw	r20, r24
    4352:	4f 5f       	subi	r20, 0xFF	; 255
    4354:	5f 4f       	sbci	r21, 0xFF	; 255
    4356:	be 01       	movw	r22, r28
    4358:	6f 5f       	subi	r22, 0xFF	; 255
    435a:	7f 4f       	sbci	r23, 0xFF	; 255
    435c:	80 e0       	ldi	r24, 0x00	; 0
    435e:	e6 d0       	rcall	.+460    	; 0x452c <simple_p_send>
	}
}
    4360:	cc 59       	subi	r28, 0x9C	; 156
    4362:	df 4f       	sbci	r29, 0xFF	; 255
    4364:	0f b6       	in	r0, 0x3f	; 63
    4366:	f8 94       	cli
    4368:	de bf       	out	0x3e, r29	; 62
    436a:	0f be       	out	0x3f, r0	; 63
    436c:	cd bf       	out	0x3d, r28	; 61
    436e:	df 91       	pop	r29
    4370:	cf 91       	pop	r28
    4372:	08 95       	ret

00004374 <send_ping_response>:

void send_ping_response(void) {
    4374:	cf 93       	push	r28
    4376:	df 93       	push	r29
    4378:	1f 92       	push	r1
    437a:	cd b7       	in	r28, 0x3d	; 61
    437c:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    437e:	80 91 e9 19 	lds	r24, 0x19E9	; 0x8019e9 <connected>
    4382:	88 23       	and	r24, r24
    4384:	b9 f0       	breq	.+46     	; 0x43b4 <send_ping_response+0x40>
  uint8_t status = TYPE_PING_RESPONSE;
    4386:	89 e0       	ldi	r24, 0x09	; 9
    4388:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
    438a:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <use_arq+0x9>
    438e:	88 23       	and	r24, r24
    4390:	51 f0       	breq	.+20     	; 0x43a6 <send_ping_response+0x32>
    4392:	41 e0       	ldi	r20, 0x01	; 1
    4394:	50 e0       	ldi	r21, 0x00	; 0
    4396:	be 01       	movw	r22, r28
    4398:	6f 5f       	subi	r22, 0xFF	; 255
    439a:	7f 4f       	sbci	r23, 0xFF	; 255
    439c:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <server_connection>
    43a0:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    43a4:	07 c0       	rjmp	.+14     	; 0x43b4 <send_ping_response+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    43a6:	41 e0       	ldi	r20, 0x01	; 1
    43a8:	50 e0       	ldi	r21, 0x00	; 0
    43aa:	be 01       	movw	r22, r28
    43ac:	6f 5f       	subi	r22, 0xFF	; 255
    43ae:	7f 4f       	sbci	r23, 0xFF	; 255
    43b0:	80 e0       	ldi	r24, 0x00	; 0
    43b2:	bc d0       	rcall	.+376    	; 0x452c <simple_p_send>
}
    43b4:	0f 90       	pop	r0
    43b6:	df 91       	pop	r29
    43b8:	cf 91       	pop	r28
    43ba:	08 95       	ret

000043bc <vServo_setAngle>:

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
	//debug("vServo_setAngle: %i", ServoAngleDeg);
	/* Ensure feasible values */
	if (ServoAngleDeg >= 90){
    43bc:	8a 35       	cpi	r24, 0x5A	; 90
    43be:	38 f0       	brcs	.+14     	; 0x43ce <vServo_setAngle+0x12>
		ServoAngleDeg = 90;
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    43c0:	80 e9       	ldi	r24, 0x90	; 144
    43c2:	9b e0       	ldi	r25, 0x0B	; 11
    43c4:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    43c8:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    43cc:	08 95       	ret
	}
	else if(ServoAngleDeg <= 0){
    43ce:	81 11       	cpse	r24, r1
    43d0:	07 c0       	rjmp	.+14     	; 0x43e0 <vServo_setAngle+0x24>
		ServoAngleDeg = 0;
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    43d2:	8d e2       	ldi	r24, 0x2D	; 45
    43d4:	95 e0       	ldi	r25, 0x05	; 5
    43d6:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    43da:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    43de:	08 95       	ret
	}
	else if (ServoAngleDeg>0 && ServoAngleDeg<90)
    43e0:	9f ef       	ldi	r25, 0xFF	; 255
    43e2:	98 0f       	add	r25, r24
    43e4:	99 35       	cpi	r25, 0x59	; 89
    43e6:	60 f4       	brcc	.+24     	; 0x4400 <vServo_setAngle+0x44>
	{
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    43e8:	e8 2f       	mov	r30, r24
    43ea:	f0 e0       	ldi	r31, 0x00	; 0
    43ec:	ee 0f       	add	r30, r30
    43ee:	ff 1f       	adc	r31, r31
    43f0:	ef 59       	subi	r30, 0x9F	; 159
    43f2:	f9 4f       	sbci	r31, 0xF9	; 249
    43f4:	80 81       	ld	r24, Z
    43f6:	91 81       	ldd	r25, Z+1	; 0x01
    43f8:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    43fc:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    4400:	08 95       	ret

00004402 <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
	/* Clear OCnA/OCnB on Compare Match, set */
	/* OCnA/OCnB at BOTTOM (non-inverting mode) */
	/* Datasheet p.155 Table 17-4 */
	TCCR4A |= (1<<COM4B1) | (0<<COM4B0);
    4402:	a0 ea       	ldi	r26, 0xA0	; 160
    4404:	b0 e0       	ldi	r27, 0x00	; 0
    4406:	9c 91       	ld	r25, X
    4408:	90 62       	ori	r25, 0x20	; 32
    440a:	9c 93       	st	X, r25
	
	/* Waveform generation mode 14: Fast PWM */
	/* top: ICRn, Update bottom, flag set on top */
	/* Datasheet p.145 Table 17-2 */
	
	TCCR4B |= (1<<WGM43) | (1<<WGM42);
    440c:	e1 ea       	ldi	r30, 0xA1	; 161
    440e:	f0 e0       	ldi	r31, 0x00	; 0
    4410:	90 81       	ld	r25, Z
    4412:	98 61       	ori	r25, 0x18	; 24
    4414:	90 83       	st	Z, r25
	TCCR4A |= (1<<WGM41) | (0<<WGM40);
    4416:	9c 91       	ld	r25, X
    4418:	92 60       	ori	r25, 0x02	; 2
    441a:	9c 93       	st	X, r25

	/* Clock select bit description: */
	/* clkI/O/8 (From prescaler) - Datasheet p.157 Table 17-6*/

	TCCR4B |= (0<<CS42) | (1<<CS41) | (0<<CS40);
    441c:	90 81       	ld	r25, Z
    441e:	92 60       	ori	r25, 0x02	; 2
    4420:	90 83       	st	Z, r25
	
	/* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
	/* Datasheet p.125 */
	ICR4 = 39999; // 49999 for 20mhz, 39 999 for 16Mhz
    4422:	2f e3       	ldi	r18, 0x3F	; 63
    4424:	3c e9       	ldi	r19, 0x9C	; 156
    4426:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>
    442a:	20 93 a6 00 	sts	0x00A6, r18	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
	
	/*Port H Pin 7 as servo PWM Output (OC4B)*/
	servoReg |= (1<<servoPin);
    442e:	e1 e0       	ldi	r30, 0x01	; 1
    4430:	f1 e0       	ldi	r31, 0x01	; 1
    4432:	90 81       	ld	r25, Z
    4434:	90 61       	ori	r25, 0x10	; 16
    4436:	90 83       	st	Z, r25
	
	/*  Set angle to desired start angle (usually 0)*/
	vServo_setAngle(servoAngleDeg);
    4438:	c1 cf       	rjmp	.-126    	; 0x43bc <vServo_setAngle>
    443a:	08 95       	ret

0000443c <simple_p_reassembly>:
  vPortFree(part);
  return 1;
}


void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length) {
    443c:	ef 92       	push	r14
    443e:	ff 92       	push	r15
    4440:	0f 93       	push	r16
    4442:	1f 93       	push	r17
    4444:	cf 93       	push	r28
    4446:	df 93       	push	r29
  uint8_t i;
  uint8_t id = 0xFF;
  uint8_t free = 0xFF;
  for(i=0;i<MAX_MESSAGES;i++) {
    if(messages[i].address == 0xFF && free == 0xFF) free = i;
    4448:	90 91 eb 19 	lds	r25, 0x19EB	; 0x8019eb <messages+0x1>
    444c:	9f 3f       	cpi	r25, 0xFF	; 255
    444e:	11 f0       	breq	.+4      	; 0x4454 <simple_p_reassembly+0x18>
    else if(messages[i].address == sender) {
    4450:	98 13       	cpse	r25, r24
    4452:	58 c0       	rjmp	.+176    	; 0x4504 <simple_p_reassembly+0xc8>
  if(id == 0xFF && free == 0xFF) return; // Not room for any more messages, and none is stored for this address
  else if(id == 0xFF && free != 0xFF) { // Did not find any part messages from this sender, but there is room to store a new one
    id = free; 
  }
    
  if(data[0] == 0) { // First part of a new message
    4454:	fb 01       	movw	r30, r22
    4456:	80 81       	ld	r24, Z
    4458:	81 11       	cpse	r24, r1
    445a:	05 c0       	rjmp	.+10     	; 0x4466 <simple_p_reassembly+0x2a>
    messages[id].num_received_bytes = 0;
    445c:	10 92 ed 19 	sts	0x19ED, r1	; 0x8019ed <messages+0x3>
    4460:	10 92 ec 19 	sts	0x19EC, r1	; 0x8019ec <messages+0x2>
    4464:	0c c0       	rjmp	.+24     	; 0x447e <simple_p_reassembly+0x42>
  } else if(data[0] != messages[id].next_part) {
    4466:	90 91 ee 19 	lds	r25, 0x19EE	; 0x8019ee <messages+0x4>
    446a:	89 17       	cp	r24, r25
    446c:	41 f0       	breq	.+16     	; 0x447e <simple_p_reassembly+0x42>
    messages[id].next_part = 0;
    446e:	ea ee       	ldi	r30, 0xEA	; 234
    4470:	f9 e1       	ldi	r31, 0x19	; 25
    4472:	14 82       	std	Z+4, r1	; 0x04
    messages[id].num_received_bytes = 0;
    4474:	13 82       	std	Z+3, r1	; 0x03
    4476:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    4478:	8f ef       	ldi	r24, 0xFF	; 255
    447a:	81 83       	std	Z+1, r24	; 0x01
    return;
    447c:	43 c0       	rjmp	.+134    	; 0x4504 <simple_p_reassembly+0xc8>
  }

  if(messages[id].num_received_bytes + (length-2) > MAX_MESSAGE_SIZE) { // Message is larger than what can be handled, discard it
    447e:	80 91 ec 19 	lds	r24, 0x19EC	; 0x8019ec <messages+0x2>
    4482:	90 91 ed 19 	lds	r25, 0x19ED	; 0x8019ed <messages+0x3>
    4486:	9c 01       	movw	r18, r24
    4488:	22 50       	subi	r18, 0x02	; 2
    448a:	31 09       	sbc	r19, r1
    448c:	24 0f       	add	r18, r20
    448e:	35 1f       	adc	r19, r21
    4490:	25 36       	cpi	r18, 0x65	; 101
    4492:	31 05       	cpc	r19, r1
    4494:	40 f0       	brcs	.+16     	; 0x44a6 <simple_p_reassembly+0x6a>
    messages[id].num_received_bytes = 0;
    4496:	ea ee       	ldi	r30, 0xEA	; 234
    4498:	f9 e1       	ldi	r31, 0x19	; 25
    449a:	13 82       	std	Z+3, r1	; 0x03
    449c:	12 82       	std	Z+2, r1	; 0x02
    messages[id].next_part = 0;
    449e:	14 82       	std	Z+4, r1	; 0x04
    messages[id].address = 0xFF;
    44a0:	8f ef       	ldi	r24, 0xFF	; 255
    44a2:	81 83       	std	Z+1, r24	; 0x01
    return;
    44a4:	2f c0       	rjmp	.+94     	; 0x4504 <simple_p_reassembly+0xc8>
    44a6:	8a 01       	movw	r16, r20
    44a8:	eb 01       	movw	r28, r22
  }
  
  messages[id].next_part++;
    44aa:	0f 2e       	mov	r0, r31
    44ac:	fa ee       	ldi	r31, 0xEA	; 234
    44ae:	ef 2e       	mov	r14, r31
    44b0:	f9 e1       	ldi	r31, 0x19	; 25
    44b2:	ff 2e       	mov	r15, r31
    44b4:	f0 2d       	mov	r31, r0
    44b6:	f7 01       	movw	r30, r14
    44b8:	24 81       	ldd	r18, Z+4	; 0x04
    44ba:	2f 5f       	subi	r18, 0xFF	; 255
    44bc:	24 83       	std	Z+4, r18	; 0x04
  memcpy(messages[id].message+messages[id].num_received_bytes, data+2, length-2);
    44be:	42 50       	subi	r20, 0x02	; 2
    44c0:	51 09       	sbc	r21, r1
    44c2:	6e 5f       	subi	r22, 0xFE	; 254
    44c4:	7f 4f       	sbci	r23, 0xFF	; 255
    44c6:	81 51       	subi	r24, 0x11	; 17
    44c8:	96 4e       	sbci	r25, 0xE6	; 230
    44ca:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
  messages[id].num_received_bytes += (length-2);
    44ce:	f7 01       	movw	r30, r14
    44d0:	42 81       	ldd	r20, Z+2	; 0x02
    44d2:	53 81       	ldd	r21, Z+3	; 0x03
    44d4:	42 50       	subi	r20, 0x02	; 2
    44d6:	51 09       	sbc	r21, r1
    44d8:	ba 01       	movw	r22, r20
    44da:	60 0f       	add	r22, r16
    44dc:	71 1f       	adc	r23, r17
    44de:	73 83       	std	Z+3, r23	; 0x03
    44e0:	62 83       	std	Z+2, r22	; 0x02
  
  if(data[0] == data[1]) {
    44e2:	98 81       	ld	r25, Y
    44e4:	89 81       	ldd	r24, Y+1	; 0x01
    44e6:	98 13       	cpse	r25, r24
    44e8:	0d c0       	rjmp	.+26     	; 0x4504 <simple_p_reassembly+0xc8>
    callback_data_received(messages[id].message, messages[id].num_received_bytes);
    44ea:	e0 91 84 1b 	lds	r30, 0x1B84	; 0x801b84 <callback_data_received>
    44ee:	f0 91 85 1b 	lds	r31, 0x1B85	; 0x801b85 <callback_data_received+0x1>
    44f2:	8f ee       	ldi	r24, 0xEF	; 239
    44f4:	99 e1       	ldi	r25, 0x19	; 25
    44f6:	19 95       	eicall
    messages[id].num_received_bytes = messages[id].next_part = 0;
    44f8:	f7 01       	movw	r30, r14
    44fa:	14 82       	std	Z+4, r1	; 0x04
    44fc:	13 82       	std	Z+3, r1	; 0x03
    44fe:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    4500:	8f ef       	ldi	r24, 0xFF	; 255
    4502:	81 83       	std	Z+1, r24	; 0x01
  }
    4504:	df 91       	pop	r29
    4506:	cf 91       	pop	r28
    4508:	1f 91       	pop	r17
    450a:	0f 91       	pop	r16
    450c:	ff 90       	pop	r15
    450e:	ef 90       	pop	r14
    4510:	08 95       	ret

00004512 <simple_p_init>:
void (*callback_data_received)(uint8_t*, uint16_t); 

void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length);

void simple_p_init(void (*cb)(uint8_t*, uint16_t)) {
  callback_data_received = cb;
    4512:	90 93 85 1b 	sts	0x1B85, r25	; 0x801b85 <callback_data_received+0x1>
    4516:	80 93 84 1b 	sts	0x1B84, r24	; 0x801b84 <callback_data_received>
  uint8_t i;
  network_set_callback(PROTOCOL_SIMPLE, simple_p_reassembly);
    451a:	6e e1       	ldi	r22, 0x1E	; 30
    451c:	72 e2       	ldi	r23, 0x22	; 34
    451e:	80 e0       	ldi	r24, 0x00	; 0
    4520:	0e 94 99 17 	call	0x2f32	; 0x2f32 <network_set_callback>
  for(i=0;i<MAX_MESSAGES;i++) {
    messages[i].address = 0xFF;
    4524:	8f ef       	ldi	r24, 0xFF	; 255
    4526:	80 93 eb 19 	sts	0x19EB, r24	; 0x8019eb <messages+0x1>
    452a:	08 95       	ret

0000452c <simple_p_send>:
  }
}

uint8_t simple_p_send(uint8_t address, uint8_t *data, uint16_t length) {  
    452c:	5f 92       	push	r5
    452e:	6f 92       	push	r6
    4530:	7f 92       	push	r7
    4532:	8f 92       	push	r8
    4534:	9f 92       	push	r9
    4536:	af 92       	push	r10
    4538:	bf 92       	push	r11
    453a:	cf 92       	push	r12
    453c:	df 92       	push	r13
    453e:	ef 92       	push	r14
    4540:	ff 92       	push	r15
    4542:	0f 93       	push	r16
    4544:	1f 93       	push	r17
    4546:	cf 93       	push	r28
    4548:	df 93       	push	r29
    454a:	58 2e       	mov	r5, r24
    454c:	5b 01       	movw	r10, r22
    454e:	8a 01       	movw	r16, r20
  uint16_t tmp;
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
    4550:	8c e2       	ldi	r24, 0x2C	; 44
    4552:	90 e0       	ldi	r25, 0x00	; 0
    4554:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4558:	7c 01       	movw	r14, r24
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
    455a:	98 01       	movw	r18, r16
    455c:	36 95       	lsr	r19
    455e:	27 95       	ror	r18
    4560:	ad e0       	ldi	r26, 0x0D	; 13
    4562:	b3 ec       	ldi	r27, 0xC3	; 195
    4564:	0e 94 5d 37 	call	0x6eba	; 0x6eba <__umulhisi3>
    4568:	92 95       	swap	r25
    456a:	82 95       	swap	r24
    456c:	8f 70       	andi	r24, 0x0F	; 15
    456e:	89 27       	eor	r24, r25
    4570:	9f 70       	andi	r25, 0x0F	; 15
    4572:	89 27       	eor	r24, r25
    4574:	4a e2       	ldi	r20, 0x2A	; 42
    4576:	48 9f       	mul	r20, r24
    4578:	90 01       	movw	r18, r0
    457a:	49 9f       	mul	r20, r25
    457c:	30 0d       	add	r19, r0
    457e:	11 24       	eor	r1, r1
    4580:	41 e0       	ldi	r20, 0x01	; 1
    4582:	02 17       	cp	r16, r18
    4584:	13 07       	cpc	r17, r19
    4586:	09 f4       	brne	.+2      	; 0x458a <simple_p_send+0x5e>
    4588:	40 e0       	ldi	r20, 0x00	; 0
    458a:	98 01       	movw	r18, r16
    458c:	36 95       	lsr	r19
    458e:	27 95       	ror	r18
    4590:	ad e0       	ldi	r26, 0x0D	; 13
    4592:	b3 ec       	ldi	r27, 0xC3	; 195
    4594:	0e 94 5d 37 	call	0x6eba	; 0x6eba <__umulhisi3>
    4598:	92 95       	swap	r25
    459a:	82 95       	swap	r24
    459c:	8f 70       	andi	r24, 0x0F	; 15
    459e:	89 27       	eor	r24, r25
    45a0:	9f 70       	andi	r25, 0x0F	; 15
    45a2:	89 27       	eor	r24, r25
    45a4:	84 0f       	add	r24, r20
  while(remaining > 0) {
    45a6:	01 15       	cp	r16, r1
    45a8:	11 05       	cpc	r17, r1
    45aa:	59 f1       	breq	.+86     	; 0x4602 <simple_p_send+0xd6>
    45ac:	90 e0       	ldi	r25, 0x00	; 0
    45ae:	c1 2c       	mov	r12, r1
    45b0:	d1 2c       	mov	r13, r1
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    part[1] = number_of_parts-1;
    45b2:	66 24       	eor	r6, r6
    45b4:	6a 94       	dec	r6
    45b6:	68 0e       	add	r6, r24
    memcpy(part+2, data+offset, tmp);
    45b8:	47 01       	movw	r8, r14
    45ba:	82 e0       	ldi	r24, 0x02	; 2
    45bc:	88 0e       	add	r8, r24
    45be:	91 1c       	adc	r9, r1
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    45c0:	e8 01       	movw	r28, r16
    45c2:	0b 32       	cpi	r16, 0x2B	; 43
    45c4:	11 05       	cpc	r17, r1
    45c6:	10 f0       	brcs	.+4      	; 0x45cc <simple_p_send+0xa0>
    45c8:	ca e2       	ldi	r28, 0x2A	; 42
    45ca:	d0 e0       	ldi	r29, 0x00	; 0
    part[0] = part_number++;
    45cc:	77 24       	eor	r7, r7
    45ce:	73 94       	inc	r7
    45d0:	79 0e       	add	r7, r25
    45d2:	f7 01       	movw	r30, r14
    45d4:	90 83       	st	Z, r25
    part[1] = number_of_parts-1;
    45d6:	61 82       	std	Z+1, r6	; 0x01
    memcpy(part+2, data+offset, tmp);
    45d8:	b5 01       	movw	r22, r10
    45da:	6c 0d       	add	r22, r12
    45dc:	7d 1d       	adc	r23, r13
    45de:	ae 01       	movw	r20, r28
    45e0:	c4 01       	movw	r24, r8
    45e2:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    45e6:	9e 01       	movw	r18, r28
    45e8:	2e 5f       	subi	r18, 0xFE	; 254
    45ea:	3f 4f       	sbci	r19, 0xFF	; 255
    45ec:	a7 01       	movw	r20, r14
    45ee:	60 e0       	ldi	r22, 0x00	; 0
    45f0:	85 2d       	mov	r24, r5
    45f2:	0e 94 a4 17 	call	0x2f48	; 0x2f48 <network_send>
    offset += tmp;
    45f6:	cc 0e       	add	r12, r28
    45f8:	dd 1e       	adc	r13, r29
    remaining -= tmp;
    45fa:	0c 1b       	sub	r16, r28
    45fc:	1d 0b       	sbc	r17, r29
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    45fe:	97 2d       	mov	r25, r7
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    4600:	f9 f6       	brne	.-66     	; 0x45c0 <simple_p_send+0x94>
    memcpy(part+2, data+offset, tmp);
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    offset += tmp;
    remaining -= tmp;
  }
  vPortFree(part);
    4602:	c7 01       	movw	r24, r14
    4604:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  return 1;
}
    4608:	81 e0       	ldi	r24, 0x01	; 1
    460a:	df 91       	pop	r29
    460c:	cf 91       	pop	r28
    460e:	1f 91       	pop	r17
    4610:	0f 91       	pop	r16
    4612:	ff 90       	pop	r15
    4614:	ef 90       	pop	r14
    4616:	df 90       	pop	r13
    4618:	cf 90       	pop	r12
    461a:	bf 90       	pop	r11
    461c:	af 90       	pop	r10
    461e:	9f 90       	pop	r9
    4620:	8f 90       	pop	r8
    4622:	7f 90       	pop	r7
    4624:	6f 90       	pop	r6
    4626:	5f 90       	pop	r5
    4628:	08 95       	ret

0000462a <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    462a:	84 b1       	in	r24, 0x04	; 4
    462c:	87 60       	ori	r24, 0x07	; 7
    462e:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    4630:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    4632:	8c b5       	in	r24, 0x2c	; 44
    4634:	81 60       	ori	r24, 0x01	; 1
    4636:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    4638:	8c b5       	in	r24, 0x2c	; 44
    463a:	8c 65       	ori	r24, 0x5C	; 92
    463c:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    463e:	8c b5       	in	r24, 0x2c	; 44
    4640:	8f 7d       	andi	r24, 0xDF	; 223
    4642:	8c bd       	out	0x2c, r24	; 44
    4644:	08 95       	ret

00004646 <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    4646:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    4648:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    464a:	0d b4       	in	r0, 0x2d	; 45
    464c:	07 fe       	sbrs	r0, 7
    464e:	fd cf       	rjmp	.-6      	; 0x464a <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    4650:	8e b5       	in	r24, 0x2e	; 46
}
    4652:	08 95       	ret

00004654 <xTaskGenericCreate>:
    4654:	4f 92       	push	r4
    4656:	5f 92       	push	r5
    4658:	6f 92       	push	r6
    465a:	7f 92       	push	r7
    465c:	8f 92       	push	r8
    465e:	9f 92       	push	r9
    4660:	af 92       	push	r10
    4662:	bf 92       	push	r11
    4664:	cf 92       	push	r12
    4666:	df 92       	push	r13
    4668:	ef 92       	push	r14
    466a:	ff 92       	push	r15
    466c:	0f 93       	push	r16
    466e:	1f 93       	push	r17
    4670:	cf 93       	push	r28
    4672:	df 93       	push	r29
    4674:	3c 01       	movw	r6, r24
    4676:	5b 01       	movw	r10, r22
    4678:	4a 01       	movw	r8, r20
    467a:	29 01       	movw	r4, r18
    467c:	c1 14       	cp	r12, r1
    467e:	d1 04       	cpc	r13, r1
    4680:	39 f4       	brne	.+14     	; 0x4690 <xTaskGenericCreate+0x3c>
    4682:	ca 01       	movw	r24, r20
    4684:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4688:	6c 01       	movw	r12, r24
    468a:	89 2b       	or	r24, r25
    468c:	09 f4       	brne	.+2      	; 0x4690 <xTaskGenericCreate+0x3c>
    468e:	e4 c0       	rjmp	.+456    	; 0x4858 <xTaskGenericCreate+0x204>
    4690:	88 e2       	ldi	r24, 0x28	; 40
    4692:	90 e0       	ldi	r25, 0x00	; 0
    4694:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4698:	ec 01       	movw	r28, r24
    469a:	89 2b       	or	r24, r25
    469c:	71 f0       	breq	.+28     	; 0x46ba <xTaskGenericCreate+0x66>
    469e:	d8 8e       	std	Y+24, r13	; 0x18
    46a0:	cf 8a       	std	Y+23, r12	; 0x17
    46a2:	81 e0       	ldi	r24, 0x01	; 1
    46a4:	88 1a       	sub	r8, r24
    46a6:	91 08       	sbc	r9, r1
    46a8:	c8 0c       	add	r12, r8
    46aa:	d9 1c       	adc	r13, r9
    46ac:	d5 01       	movw	r26, r10
    46ae:	8c 91       	ld	r24, X
    46b0:	89 8f       	std	Y+25, r24	; 0x19
    46b2:	8c 91       	ld	r24, X
    46b4:	81 11       	cpse	r24, r1
    46b6:	05 c0       	rjmp	.+10     	; 0x46c2 <xTaskGenericCreate+0x6e>
    46b8:	18 c0       	rjmp	.+48     	; 0x46ea <xTaskGenericCreate+0x96>
    46ba:	c6 01       	movw	r24, r12
    46bc:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    46c0:	cb c0       	rjmp	.+406    	; 0x4858 <xTaskGenericCreate+0x204>
    46c2:	ae 01       	movw	r20, r28
    46c4:	46 5e       	subi	r20, 0xE6	; 230
    46c6:	5f 4f       	sbci	r21, 0xFF	; 255
    46c8:	f5 01       	movw	r30, r10
    46ca:	31 96       	adiw	r30, 0x01	; 1
    46cc:	b8 e0       	ldi	r27, 0x08	; 8
    46ce:	ab 0e       	add	r10, r27
    46d0:	b1 1c       	adc	r11, r1
    46d2:	cf 01       	movw	r24, r30
    46d4:	21 91       	ld	r18, Z+
    46d6:	da 01       	movw	r26, r20
    46d8:	2d 93       	st	X+, r18
    46da:	ad 01       	movw	r20, r26
    46dc:	dc 01       	movw	r26, r24
    46de:	8c 91       	ld	r24, X
    46e0:	88 23       	and	r24, r24
    46e2:	19 f0       	breq	.+6      	; 0x46ea <xTaskGenericCreate+0x96>
    46e4:	ae 16       	cp	r10, r30
    46e6:	bf 06       	cpc	r11, r31
    46e8:	a1 f7       	brne	.-24     	; 0x46d2 <xTaskGenericCreate+0x7e>
    46ea:	18 a2       	std	Y+32, r1	; 0x20
    46ec:	10 2f       	mov	r17, r16
    46ee:	06 30       	cpi	r16, 0x06	; 6
    46f0:	08 f0       	brcs	.+2      	; 0x46f4 <xTaskGenericCreate+0xa0>
    46f2:	15 e0       	ldi	r17, 0x05	; 5
    46f4:	1e 8b       	std	Y+22, r17	; 0x16
    46f6:	19 a3       	std	Y+33, r17	; 0x21
    46f8:	1a a2       	std	Y+34, r1	; 0x22
    46fa:	5e 01       	movw	r10, r28
    46fc:	b2 e0       	ldi	r27, 0x02	; 2
    46fe:	ab 0e       	add	r10, r27
    4700:	b1 1c       	adc	r11, r1
    4702:	c5 01       	movw	r24, r10
    4704:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <vListInitialiseItem>
    4708:	ce 01       	movw	r24, r28
    470a:	0c 96       	adiw	r24, 0x0c	; 12
    470c:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <vListInitialiseItem>
    4710:	d9 87       	std	Y+9, r29	; 0x09
    4712:	c8 87       	std	Y+8, r28	; 0x08
    4714:	86 e0       	ldi	r24, 0x06	; 6
    4716:	90 e0       	ldi	r25, 0x00	; 0
    4718:	81 1b       	sub	r24, r17
    471a:	91 09       	sbc	r25, r1
    471c:	9d 87       	std	Y+13, r25	; 0x0d
    471e:	8c 87       	std	Y+12, r24	; 0x0c
    4720:	db 8b       	std	Y+19, r29	; 0x13
    4722:	ca 8b       	std	Y+18, r28	; 0x12
    4724:	1b a2       	std	Y+35, r1	; 0x23
    4726:	1c a2       	std	Y+36, r1	; 0x24
    4728:	1d a2       	std	Y+37, r1	; 0x25
    472a:	1e a2       	std	Y+38, r1	; 0x26
    472c:	1f a2       	std	Y+39, r1	; 0x27
    472e:	a2 01       	movw	r20, r4
    4730:	b3 01       	movw	r22, r6
    4732:	c6 01       	movw	r24, r12
    4734:	0e 94 16 18 	call	0x302c	; 0x302c <pxPortInitialiseStack>
    4738:	99 83       	std	Y+1, r25	; 0x01
    473a:	88 83       	st	Y, r24
    473c:	e1 14       	cp	r14, r1
    473e:	f1 04       	cpc	r15, r1
    4740:	19 f0       	breq	.+6      	; 0x4748 <xTaskGenericCreate+0xf4>
    4742:	f7 01       	movw	r30, r14
    4744:	d1 83       	std	Z+1, r29	; 0x01
    4746:	c0 83       	st	Z, r28
    4748:	0f b6       	in	r0, 0x3f	; 63
    474a:	f8 94       	cli
    474c:	0f 92       	push	r0
    474e:	80 91 5e 1a 	lds	r24, 0x1A5E	; 0x801a5e <uxCurrentNumberOfTasks>
    4752:	8f 5f       	subi	r24, 0xFF	; 255
    4754:	80 93 5e 1a 	sts	0x1A5E, r24	; 0x801a5e <uxCurrentNumberOfTasks>
    4758:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    475c:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4760:	89 2b       	or	r24, r25
    4762:	d9 f5       	brne	.+118    	; 0x47da <xTaskGenericCreate+0x186>
    4764:	d0 93 be 1a 	sts	0x1ABE, r29	; 0x801abe <pxCurrentTCB+0x1>
    4768:	c0 93 bd 1a 	sts	0x1ABD, r28	; 0x801abd <pxCurrentTCB>
    476c:	80 91 5e 1a 	lds	r24, 0x1A5E	; 0x801a5e <uxCurrentNumberOfTasks>
    4770:	81 30       	cpi	r24, 0x01	; 1
    4772:	09 f0       	breq	.+2      	; 0x4776 <xTaskGenericCreate+0x122>
    4774:	41 c0       	rjmp	.+130    	; 0x47f8 <xTaskGenericCreate+0x1a4>
    4776:	0f 2e       	mov	r0, r31
    4778:	f7 e8       	ldi	r31, 0x87	; 135
    477a:	ef 2e       	mov	r14, r31
    477c:	fa e1       	ldi	r31, 0x1A	; 26
    477e:	ff 2e       	mov	r15, r31
    4780:	f0 2d       	mov	r31, r0
    4782:	0f 2e       	mov	r0, r31
    4784:	fd eb       	ldi	r31, 0xBD	; 189
    4786:	cf 2e       	mov	r12, r31
    4788:	fa e1       	ldi	r31, 0x1A	; 26
    478a:	df 2e       	mov	r13, r31
    478c:	f0 2d       	mov	r31, r0
    478e:	c7 01       	movw	r24, r14
    4790:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    4794:	f9 e0       	ldi	r31, 0x09	; 9
    4796:	ef 0e       	add	r14, r31
    4798:	f1 1c       	adc	r15, r1
    479a:	ec 14       	cp	r14, r12
    479c:	fd 04       	cpc	r15, r13
    479e:	b9 f7       	brne	.-18     	; 0x478e <xTaskGenericCreate+0x13a>
    47a0:	8e e7       	ldi	r24, 0x7E	; 126
    47a2:	9a e1       	ldi	r25, 0x1A	; 26
    47a4:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    47a8:	85 e7       	ldi	r24, 0x75	; 117
    47aa:	9a e1       	ldi	r25, 0x1A	; 26
    47ac:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    47b0:	88 e6       	ldi	r24, 0x68	; 104
    47b2:	9a e1       	ldi	r25, 0x1A	; 26
    47b4:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    47b8:	8f e5       	ldi	r24, 0x5F	; 95
    47ba:	9a e1       	ldi	r25, 0x1A	; 26
    47bc:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    47c0:	8e e7       	ldi	r24, 0x7E	; 126
    47c2:	9a e1       	ldi	r25, 0x1A	; 26
    47c4:	90 93 74 1a 	sts	0x1A74, r25	; 0x801a74 <pxDelayedTaskList+0x1>
    47c8:	80 93 73 1a 	sts	0x1A73, r24	; 0x801a73 <pxDelayedTaskList>
    47cc:	85 e7       	ldi	r24, 0x75	; 117
    47ce:	9a e1       	ldi	r25, 0x1A	; 26
    47d0:	90 93 72 1a 	sts	0x1A72, r25	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    47d4:	80 93 71 1a 	sts	0x1A71, r24	; 0x801a71 <pxOverflowDelayedTaskList>
    47d8:	0f c0       	rjmp	.+30     	; 0x47f8 <xTaskGenericCreate+0x1a4>
    47da:	80 91 5a 1a 	lds	r24, 0x1A5A	; 0x801a5a <xSchedulerRunning>
    47de:	81 11       	cpse	r24, r1
    47e0:	0b c0       	rjmp	.+22     	; 0x47f8 <xTaskGenericCreate+0x1a4>
    47e2:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    47e6:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    47ea:	86 89       	ldd	r24, Z+22	; 0x16
    47ec:	08 17       	cp	r16, r24
    47ee:	20 f0       	brcs	.+8      	; 0x47f8 <xTaskGenericCreate+0x1a4>
    47f0:	d0 93 be 1a 	sts	0x1ABE, r29	; 0x801abe <pxCurrentTCB+0x1>
    47f4:	c0 93 bd 1a 	sts	0x1ABD, r28	; 0x801abd <pxCurrentTCB>
    47f8:	80 91 56 1a 	lds	r24, 0x1A56	; 0x801a56 <uxTaskNumber>
    47fc:	8f 5f       	subi	r24, 0xFF	; 255
    47fe:	80 93 56 1a 	sts	0x1A56, r24	; 0x801a56 <uxTaskNumber>
    4802:	8e 89       	ldd	r24, Y+22	; 0x16
    4804:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    4808:	98 17       	cp	r25, r24
    480a:	10 f4       	brcc	.+4      	; 0x4810 <xTaskGenericCreate+0x1bc>
    480c:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    4810:	90 e0       	ldi	r25, 0x00	; 0
    4812:	9c 01       	movw	r18, r24
    4814:	22 0f       	add	r18, r18
    4816:	33 1f       	adc	r19, r19
    4818:	22 0f       	add	r18, r18
    481a:	33 1f       	adc	r19, r19
    481c:	22 0f       	add	r18, r18
    481e:	33 1f       	adc	r19, r19
    4820:	82 0f       	add	r24, r18
    4822:	93 1f       	adc	r25, r19
    4824:	b5 01       	movw	r22, r10
    4826:	89 57       	subi	r24, 0x79	; 121
    4828:	95 4e       	sbci	r25, 0xE5	; 229
    482a:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    482e:	0f 90       	pop	r0
    4830:	0f be       	out	0x3f, r0	; 63
    4832:	80 91 5a 1a 	lds	r24, 0x1A5A	; 0x801a5a <xSchedulerRunning>
    4836:	88 23       	and	r24, r24
    4838:	59 f0       	breq	.+22     	; 0x4850 <xTaskGenericCreate+0x1fc>
    483a:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    483e:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4842:	86 89       	ldd	r24, Z+22	; 0x16
    4844:	80 17       	cp	r24, r16
    4846:	30 f4       	brcc	.+12     	; 0x4854 <xTaskGenericCreate+0x200>
    4848:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    484c:	81 e0       	ldi	r24, 0x01	; 1
    484e:	05 c0       	rjmp	.+10     	; 0x485a <xTaskGenericCreate+0x206>
    4850:	81 e0       	ldi	r24, 0x01	; 1
    4852:	03 c0       	rjmp	.+6      	; 0x485a <xTaskGenericCreate+0x206>
    4854:	81 e0       	ldi	r24, 0x01	; 1
    4856:	01 c0       	rjmp	.+2      	; 0x485a <xTaskGenericCreate+0x206>
    4858:	8f ef       	ldi	r24, 0xFF	; 255
    485a:	df 91       	pop	r29
    485c:	cf 91       	pop	r28
    485e:	1f 91       	pop	r17
    4860:	0f 91       	pop	r16
    4862:	ff 90       	pop	r15
    4864:	ef 90       	pop	r14
    4866:	df 90       	pop	r13
    4868:	cf 90       	pop	r12
    486a:	bf 90       	pop	r11
    486c:	af 90       	pop	r10
    486e:	9f 90       	pop	r9
    4870:	8f 90       	pop	r8
    4872:	7f 90       	pop	r7
    4874:	6f 90       	pop	r6
    4876:	5f 90       	pop	r5
    4878:	4f 90       	pop	r4
    487a:	08 95       	ret

0000487c <vTaskDelayUntil>:
    487c:	9f 92       	push	r9
    487e:	af 92       	push	r10
    4880:	bf 92       	push	r11
    4882:	cf 92       	push	r12
    4884:	df 92       	push	r13
    4886:	ef 92       	push	r14
    4888:	ff 92       	push	r15
    488a:	0f 93       	push	r16
    488c:	1f 93       	push	r17
    488e:	cf 93       	push	r28
    4890:	df 93       	push	r29
    4892:	fc 01       	movw	r30, r24
    4894:	90 91 53 1a 	lds	r25, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    4898:	9f 5f       	subi	r25, 0xFF	; 255
    489a:	90 93 53 1a 	sts	0x1A53, r25	; 0x801a53 <uxSchedulerSuspended>
    489e:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    48a2:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    48a6:	20 81       	ld	r18, Z
    48a8:	31 81       	ldd	r19, Z+1	; 0x01
    48aa:	e9 01       	movw	r28, r18
    48ac:	c6 0f       	add	r28, r22
    48ae:	d7 1f       	adc	r29, r23
    48b0:	82 17       	cp	r24, r18
    48b2:	93 07       	cpc	r25, r19
    48b4:	58 f4       	brcc	.+22     	; 0x48cc <vTaskDelayUntil+0x50>
    48b6:	c2 17       	cp	r28, r18
    48b8:	d3 07       	cpc	r29, r19
    48ba:	08 f0       	brcs	.+2      	; 0x48be <vTaskDelayUntil+0x42>
    48bc:	6e c1       	rjmp	.+732    	; 0x4b9a <vTaskDelayUntil+0x31e>
    48be:	d1 83       	std	Z+1, r29	; 0x01
    48c0:	c0 83       	st	Z, r28
    48c2:	8c 17       	cp	r24, r28
    48c4:	9d 07       	cpc	r25, r29
    48c6:	08 f0       	brcs	.+2      	; 0x48ca <vTaskDelayUntil+0x4e>
    48c8:	42 c0       	rjmp	.+132    	; 0x494e <vTaskDelayUntil+0xd2>
    48ca:	09 c0       	rjmp	.+18     	; 0x48de <vTaskDelayUntil+0x62>
    48cc:	c2 17       	cp	r28, r18
    48ce:	d3 07       	cpc	r29, r19
    48d0:	08 f4       	brcc	.+2      	; 0x48d4 <vTaskDelayUntil+0x58>
    48d2:	60 c1       	rjmp	.+704    	; 0x4b94 <vTaskDelayUntil+0x318>
    48d4:	8c 17       	cp	r24, r28
    48d6:	9d 07       	cpc	r25, r29
    48d8:	08 f4       	brcc	.+2      	; 0x48dc <vTaskDelayUntil+0x60>
    48da:	5c c1       	rjmp	.+696    	; 0x4b94 <vTaskDelayUntil+0x318>
    48dc:	5e c1       	rjmp	.+700    	; 0x4b9a <vTaskDelayUntil+0x31e>
    48de:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    48e2:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    48e6:	02 96       	adiw	r24, 0x02	; 2
    48e8:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    48ec:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    48f0:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    48f4:	d3 83       	std	Z+3, r29	; 0x03
    48f6:	c2 83       	std	Z+2, r28	; 0x02
    48f8:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    48fc:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    4900:	c8 17       	cp	r28, r24
    4902:	d9 07       	cpc	r29, r25
    4904:	68 f4       	brcc	.+26     	; 0x4920 <vTaskDelayUntil+0xa4>
    4906:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    490a:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    490e:	80 91 71 1a 	lds	r24, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    4912:	90 91 72 1a 	lds	r25, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    4916:	6e 5f       	subi	r22, 0xFE	; 254
    4918:	7f 4f       	sbci	r23, 0xFF	; 255
    491a:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    491e:	17 c0       	rjmp	.+46     	; 0x494e <vTaskDelayUntil+0xd2>
    4920:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4924:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4928:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    492c:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4930:	6e 5f       	subi	r22, 0xFE	; 254
    4932:	7f 4f       	sbci	r23, 0xFF	; 255
    4934:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    4938:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    493c:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4940:	c8 17       	cp	r28, r24
    4942:	d9 07       	cpc	r29, r25
    4944:	20 f4       	brcc	.+8      	; 0x494e <vTaskDelayUntil+0xd2>
    4946:	d0 93 55 1a 	sts	0x1A55, r29	; 0x801a55 <xNextTaskUnblockTime+0x1>
    494a:	c0 93 54 1a 	sts	0x1A54, r28	; 0x801a54 <xNextTaskUnblockTime>
    494e:	0f b6       	in	r0, 0x3f	; 63
    4950:	f8 94       	cli
    4952:	0f 92       	push	r0
    4954:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    4958:	81 50       	subi	r24, 0x01	; 1
    495a:	80 93 53 1a 	sts	0x1A53, r24	; 0x801a53 <uxSchedulerSuspended>
    495e:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    4962:	81 11       	cpse	r24, r1
    4964:	0d c1       	rjmp	.+538    	; 0x4b80 <vTaskDelayUntil+0x304>
    4966:	80 91 5e 1a 	lds	r24, 0x1A5E	; 0x801a5e <uxCurrentNumberOfTasks>
    496a:	81 11       	cpse	r24, r1
    496c:	33 c0       	rjmp	.+102    	; 0x49d4 <vTaskDelayUntil+0x158>
    496e:	0b c1       	rjmp	.+534    	; 0x4b86 <vTaskDelayUntil+0x30a>
    4970:	d7 01       	movw	r26, r14
    4972:	15 96       	adiw	r26, 0x05	; 5
    4974:	ed 91       	ld	r30, X+
    4976:	fc 91       	ld	r31, X
    4978:	16 97       	sbiw	r26, 0x06	; 6
    497a:	c6 81       	ldd	r28, Z+6	; 0x06
    497c:	d7 81       	ldd	r29, Z+7	; 0x07
    497e:	ce 01       	movw	r24, r28
    4980:	0c 96       	adiw	r24, 0x0c	; 12
    4982:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4986:	8e 01       	movw	r16, r28
    4988:	0e 5f       	subi	r16, 0xFE	; 254
    498a:	1f 4f       	sbci	r17, 0xFF	; 255
    498c:	c8 01       	movw	r24, r16
    498e:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4992:	8e 89       	ldd	r24, Y+22	; 0x16
    4994:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    4998:	98 17       	cp	r25, r24
    499a:	10 f4       	brcc	.+4      	; 0x49a0 <vTaskDelayUntil+0x124>
    499c:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    49a0:	90 e0       	ldi	r25, 0x00	; 0
    49a2:	9c 01       	movw	r18, r24
    49a4:	22 0f       	add	r18, r18
    49a6:	33 1f       	adc	r19, r19
    49a8:	22 0f       	add	r18, r18
    49aa:	33 1f       	adc	r19, r19
    49ac:	22 0f       	add	r18, r18
    49ae:	33 1f       	adc	r19, r19
    49b0:	82 0f       	add	r24, r18
    49b2:	93 1f       	adc	r25, r19
    49b4:	b8 01       	movw	r22, r16
    49b6:	89 57       	subi	r24, 0x79	; 121
    49b8:	95 4e       	sbci	r25, 0xE5	; 229
    49ba:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    49be:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    49c2:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    49c6:	9e 89       	ldd	r25, Y+22	; 0x16
    49c8:	86 89       	ldd	r24, Z+22	; 0x16
    49ca:	98 17       	cp	r25, r24
    49cc:	58 f0       	brcs	.+22     	; 0x49e4 <vTaskDelayUntil+0x168>
    49ce:	d0 92 58 1a 	sts	0x1A58, r13	; 0x801a58 <xYieldPending>
    49d2:	08 c0       	rjmp	.+16     	; 0x49e4 <vTaskDelayUntil+0x168>
    49d4:	0f 2e       	mov	r0, r31
    49d6:	f8 e6       	ldi	r31, 0x68	; 104
    49d8:	ef 2e       	mov	r14, r31
    49da:	fa e1       	ldi	r31, 0x1A	; 26
    49dc:	ff 2e       	mov	r15, r31
    49de:	f0 2d       	mov	r31, r0
    49e0:	dd 24       	eor	r13, r13
    49e2:	d3 94       	inc	r13
    49e4:	f7 01       	movw	r30, r14
    49e6:	80 81       	ld	r24, Z
    49e8:	81 11       	cpse	r24, r1
    49ea:	c2 cf       	rjmp	.-124    	; 0x4970 <vTaskDelayUntil+0xf4>
    49ec:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    49f0:	88 23       	and	r24, r24
    49f2:	09 f4       	brne	.+2      	; 0x49f6 <vTaskDelayUntil+0x17a>
    49f4:	bd c0       	rjmp	.+378    	; 0x4b70 <vTaskDelayUntil+0x2f4>
    49f6:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    49fa:	88 23       	and	r24, r24
    49fc:	09 f4       	brne	.+2      	; 0x4a00 <vTaskDelayUntil+0x184>
    49fe:	b8 c0       	rjmp	.+368    	; 0x4b70 <vTaskDelayUntil+0x2f4>
    4a00:	91 2c       	mov	r9, r1
    4a02:	bb 24       	eor	r11, r11
    4a04:	b3 94       	inc	r11
    4a06:	cc 24       	eor	r12, r12
    4a08:	ca 94       	dec	r12
    4a0a:	dc 2c       	mov	r13, r12
    4a0c:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    4a10:	81 11       	cpse	r24, r1
    4a12:	98 c0       	rjmp	.+304    	; 0x4b44 <vTaskDelayUntil+0x2c8>
    4a14:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    4a18:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    4a1c:	01 96       	adiw	r24, 0x01	; 1
    4a1e:	90 93 5d 1a 	sts	0x1A5D, r25	; 0x801a5d <xTickCount+0x1>
    4a22:	80 93 5c 1a 	sts	0x1A5C, r24	; 0x801a5c <xTickCount>
    4a26:	e0 90 5c 1a 	lds	r14, 0x1A5C	; 0x801a5c <xTickCount>
    4a2a:	f0 90 5d 1a 	lds	r15, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    4a2e:	e1 14       	cp	r14, r1
    4a30:	f1 04       	cpc	r15, r1
    4a32:	89 f5       	brne	.+98     	; 0x4a96 <vTaskDelayUntil+0x21a>
    4a34:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4a38:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4a3c:	20 91 71 1a 	lds	r18, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    4a40:	30 91 72 1a 	lds	r19, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    4a44:	30 93 74 1a 	sts	0x1A74, r19	; 0x801a74 <pxDelayedTaskList+0x1>
    4a48:	20 93 73 1a 	sts	0x1A73, r18	; 0x801a73 <pxDelayedTaskList>
    4a4c:	90 93 72 1a 	sts	0x1A72, r25	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    4a50:	80 93 71 1a 	sts	0x1A71, r24	; 0x801a71 <pxOverflowDelayedTaskList>
    4a54:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <xNumOfOverflows>
    4a58:	8f 5f       	subi	r24, 0xFF	; 255
    4a5a:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <xNumOfOverflows>
    4a5e:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4a62:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4a66:	80 81       	ld	r24, Z
    4a68:	81 11       	cpse	r24, r1
    4a6a:	05 c0       	rjmp	.+10     	; 0x4a76 <vTaskDelayUntil+0x1fa>
    4a6c:	d0 92 55 1a 	sts	0x1A55, r13	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4a70:	c0 92 54 1a 	sts	0x1A54, r12	; 0x801a54 <xNextTaskUnblockTime>
    4a74:	10 c0       	rjmp	.+32     	; 0x4a96 <vTaskDelayUntil+0x21a>
    4a76:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4a7a:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4a7e:	05 80       	ldd	r0, Z+5	; 0x05
    4a80:	f6 81       	ldd	r31, Z+6	; 0x06
    4a82:	e0 2d       	mov	r30, r0
    4a84:	06 80       	ldd	r0, Z+6	; 0x06
    4a86:	f7 81       	ldd	r31, Z+7	; 0x07
    4a88:	e0 2d       	mov	r30, r0
    4a8a:	82 81       	ldd	r24, Z+2	; 0x02
    4a8c:	93 81       	ldd	r25, Z+3	; 0x03
    4a8e:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4a92:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    4a96:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    4a9a:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4a9e:	e8 16       	cp	r14, r24
    4aa0:	f9 06       	cpc	r15, r25
    4aa2:	08 f4       	brcc	.+2      	; 0x4aa6 <vTaskDelayUntil+0x22a>
    4aa4:	7d c0       	rjmp	.+250    	; 0x4ba0 <vTaskDelayUntil+0x324>
    4aa6:	a9 2c       	mov	r10, r9
    4aa8:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4aac:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4ab0:	80 81       	ld	r24, Z
    4ab2:	81 11       	cpse	r24, r1
    4ab4:	05 c0       	rjmp	.+10     	; 0x4ac0 <vTaskDelayUntil+0x244>
    4ab6:	d0 92 55 1a 	sts	0x1A55, r13	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4aba:	c0 92 54 1a 	sts	0x1A54, r12	; 0x801a54 <xNextTaskUnblockTime>
    4abe:	48 c0       	rjmp	.+144    	; 0x4b50 <vTaskDelayUntil+0x2d4>
    4ac0:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4ac4:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4ac8:	05 80       	ldd	r0, Z+5	; 0x05
    4aca:	f6 81       	ldd	r31, Z+6	; 0x06
    4acc:	e0 2d       	mov	r30, r0
    4ace:	c6 81       	ldd	r28, Z+6	; 0x06
    4ad0:	d7 81       	ldd	r29, Z+7	; 0x07
    4ad2:	8a 81       	ldd	r24, Y+2	; 0x02
    4ad4:	9b 81       	ldd	r25, Y+3	; 0x03
    4ad6:	e8 16       	cp	r14, r24
    4ad8:	f9 06       	cpc	r15, r25
    4ada:	28 f4       	brcc	.+10     	; 0x4ae6 <vTaskDelayUntil+0x26a>
    4adc:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4ae0:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    4ae4:	35 c0       	rjmp	.+106    	; 0x4b50 <vTaskDelayUntil+0x2d4>
    4ae6:	8e 01       	movw	r16, r28
    4ae8:	0e 5f       	subi	r16, 0xFE	; 254
    4aea:	1f 4f       	sbci	r17, 0xFF	; 255
    4aec:	c8 01       	movw	r24, r16
    4aee:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4af2:	8c 89       	ldd	r24, Y+20	; 0x14
    4af4:	9d 89       	ldd	r25, Y+21	; 0x15
    4af6:	89 2b       	or	r24, r25
    4af8:	21 f0       	breq	.+8      	; 0x4b02 <vTaskDelayUntil+0x286>
    4afa:	ce 01       	movw	r24, r28
    4afc:	0c 96       	adiw	r24, 0x0c	; 12
    4afe:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4b02:	8e 89       	ldd	r24, Y+22	; 0x16
    4b04:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    4b08:	98 17       	cp	r25, r24
    4b0a:	10 f4       	brcc	.+4      	; 0x4b10 <vTaskDelayUntil+0x294>
    4b0c:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    4b10:	90 e0       	ldi	r25, 0x00	; 0
    4b12:	9c 01       	movw	r18, r24
    4b14:	22 0f       	add	r18, r18
    4b16:	33 1f       	adc	r19, r19
    4b18:	22 0f       	add	r18, r18
    4b1a:	33 1f       	adc	r19, r19
    4b1c:	22 0f       	add	r18, r18
    4b1e:	33 1f       	adc	r19, r19
    4b20:	82 0f       	add	r24, r18
    4b22:	93 1f       	adc	r25, r19
    4b24:	b8 01       	movw	r22, r16
    4b26:	89 57       	subi	r24, 0x79	; 121
    4b28:	95 4e       	sbci	r25, 0xE5	; 229
    4b2a:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    4b2e:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4b32:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4b36:	9e 89       	ldd	r25, Y+22	; 0x16
    4b38:	86 89       	ldd	r24, Z+22	; 0x16
    4b3a:	98 17       	cp	r25, r24
    4b3c:	08 f4       	brcc	.+2      	; 0x4b40 <vTaskDelayUntil+0x2c4>
    4b3e:	b4 cf       	rjmp	.-152    	; 0x4aa8 <vTaskDelayUntil+0x22c>
    4b40:	ab 2c       	mov	r10, r11
    4b42:	b2 cf       	rjmp	.-156    	; 0x4aa8 <vTaskDelayUntil+0x22c>
    4b44:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    4b48:	8f 5f       	subi	r24, 0xFF	; 255
    4b4a:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <uxPendedTicks>
    4b4e:	28 c0       	rjmp	.+80     	; 0x4ba0 <vTaskDelayUntil+0x324>
    4b50:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    4b54:	81 11       	cpse	r24, r1
    4b56:	01 c0       	rjmp	.+2      	; 0x4b5a <vTaskDelayUntil+0x2de>
    4b58:	a1 10       	cpse	r10, r1
    4b5a:	b0 92 58 1a 	sts	0x1A58, r11	; 0x801a58 <xYieldPending>
    4b5e:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    4b62:	81 50       	subi	r24, 0x01	; 1
    4b64:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <uxPendedTicks>
    4b68:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    4b6c:	81 11       	cpse	r24, r1
    4b6e:	4e cf       	rjmp	.-356    	; 0x4a0c <vTaskDelayUntil+0x190>
    4b70:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    4b74:	81 30       	cpi	r24, 0x01	; 1
    4b76:	31 f4       	brne	.+12     	; 0x4b84 <vTaskDelayUntil+0x308>
    4b78:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    4b7c:	81 e0       	ldi	r24, 0x01	; 1
    4b7e:	03 c0       	rjmp	.+6      	; 0x4b86 <vTaskDelayUntil+0x30a>
    4b80:	80 e0       	ldi	r24, 0x00	; 0
    4b82:	01 c0       	rjmp	.+2      	; 0x4b86 <vTaskDelayUntil+0x30a>
    4b84:	80 e0       	ldi	r24, 0x00	; 0
    4b86:	0f 90       	pop	r0
    4b88:	0f be       	out	0x3f, r0	; 63
    4b8a:	81 11       	cpse	r24, r1
    4b8c:	0e c0       	rjmp	.+28     	; 0x4baa <vTaskDelayUntil+0x32e>
    4b8e:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    4b92:	0b c0       	rjmp	.+22     	; 0x4baa <vTaskDelayUntil+0x32e>
    4b94:	d1 83       	std	Z+1, r29	; 0x01
    4b96:	c0 83       	st	Z, r28
    4b98:	a2 ce       	rjmp	.-700    	; 0x48de <vTaskDelayUntil+0x62>
    4b9a:	d1 83       	std	Z+1, r29	; 0x01
    4b9c:	c0 83       	st	Z, r28
    4b9e:	d7 ce       	rjmp	.-594    	; 0x494e <vTaskDelayUntil+0xd2>
    4ba0:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    4ba4:	81 11       	cpse	r24, r1
    4ba6:	d9 cf       	rjmp	.-78     	; 0x4b5a <vTaskDelayUntil+0x2de>
    4ba8:	da cf       	rjmp	.-76     	; 0x4b5e <vTaskDelayUntil+0x2e2>
    4baa:	df 91       	pop	r29
    4bac:	cf 91       	pop	r28
    4bae:	1f 91       	pop	r17
    4bb0:	0f 91       	pop	r16
    4bb2:	ff 90       	pop	r15
    4bb4:	ef 90       	pop	r14
    4bb6:	df 90       	pop	r13
    4bb8:	cf 90       	pop	r12
    4bba:	bf 90       	pop	r11
    4bbc:	af 90       	pop	r10
    4bbe:	9f 90       	pop	r9
    4bc0:	08 95       	ret

00004bc2 <vTaskDelay>:
    4bc2:	9f 92       	push	r9
    4bc4:	af 92       	push	r10
    4bc6:	bf 92       	push	r11
    4bc8:	cf 92       	push	r12
    4bca:	df 92       	push	r13
    4bcc:	ef 92       	push	r14
    4bce:	ff 92       	push	r15
    4bd0:	0f 93       	push	r16
    4bd2:	1f 93       	push	r17
    4bd4:	cf 93       	push	r28
    4bd6:	df 93       	push	r29
    4bd8:	00 97       	sbiw	r24, 0x00	; 0
    4bda:	09 f4       	brne	.+2      	; 0x4bde <vTaskDelay+0x1c>
    4bdc:	63 c1       	rjmp	.+710    	; 0x4ea4 <vTaskDelay+0x2e2>
    4bde:	20 91 53 1a 	lds	r18, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    4be2:	2f 5f       	subi	r18, 0xFF	; 255
    4be4:	20 93 53 1a 	sts	0x1A53, r18	; 0x801a53 <uxSchedulerSuspended>
    4be8:	c0 91 5c 1a 	lds	r28, 0x1A5C	; 0x801a5c <xTickCount>
    4bec:	d0 91 5d 1a 	lds	r29, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    4bf0:	c8 0f       	add	r28, r24
    4bf2:	d9 1f       	adc	r29, r25
    4bf4:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4bf8:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4bfc:	02 96       	adiw	r24, 0x02	; 2
    4bfe:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4c02:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4c06:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4c0a:	d3 83       	std	Z+3, r29	; 0x03
    4c0c:	c2 83       	std	Z+2, r28	; 0x02
    4c0e:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    4c12:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    4c16:	c8 17       	cp	r28, r24
    4c18:	d9 07       	cpc	r29, r25
    4c1a:	68 f4       	brcc	.+26     	; 0x4c36 <vTaskDelay+0x74>
    4c1c:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4c20:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4c24:	80 91 71 1a 	lds	r24, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    4c28:	90 91 72 1a 	lds	r25, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    4c2c:	6e 5f       	subi	r22, 0xFE	; 254
    4c2e:	7f 4f       	sbci	r23, 0xFF	; 255
    4c30:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    4c34:	17 c0       	rjmp	.+46     	; 0x4c64 <vTaskDelay+0xa2>
    4c36:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4c3a:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4c3e:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4c42:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4c46:	6e 5f       	subi	r22, 0xFE	; 254
    4c48:	7f 4f       	sbci	r23, 0xFF	; 255
    4c4a:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    4c4e:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    4c52:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4c56:	c8 17       	cp	r28, r24
    4c58:	d9 07       	cpc	r29, r25
    4c5a:	20 f4       	brcc	.+8      	; 0x4c64 <vTaskDelay+0xa2>
    4c5c:	d0 93 55 1a 	sts	0x1A55, r29	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4c60:	c0 93 54 1a 	sts	0x1A54, r28	; 0x801a54 <xNextTaskUnblockTime>
    4c64:	0f b6       	in	r0, 0x3f	; 63
    4c66:	f8 94       	cli
    4c68:	0f 92       	push	r0
    4c6a:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    4c6e:	81 50       	subi	r24, 0x01	; 1
    4c70:	80 93 53 1a 	sts	0x1A53, r24	; 0x801a53 <uxSchedulerSuspended>
    4c74:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    4c78:	81 11       	cpse	r24, r1
    4c7a:	0d c1       	rjmp	.+538    	; 0x4e96 <vTaskDelay+0x2d4>
    4c7c:	80 91 5e 1a 	lds	r24, 0x1A5E	; 0x801a5e <uxCurrentNumberOfTasks>
    4c80:	81 11       	cpse	r24, r1
    4c82:	33 c0       	rjmp	.+102    	; 0x4cea <vTaskDelay+0x128>
    4c84:	0b c1       	rjmp	.+534    	; 0x4e9c <vTaskDelay+0x2da>
    4c86:	d7 01       	movw	r26, r14
    4c88:	15 96       	adiw	r26, 0x05	; 5
    4c8a:	ed 91       	ld	r30, X+
    4c8c:	fc 91       	ld	r31, X
    4c8e:	16 97       	sbiw	r26, 0x06	; 6
    4c90:	c6 81       	ldd	r28, Z+6	; 0x06
    4c92:	d7 81       	ldd	r29, Z+7	; 0x07
    4c94:	ce 01       	movw	r24, r28
    4c96:	0c 96       	adiw	r24, 0x0c	; 12
    4c98:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4c9c:	8e 01       	movw	r16, r28
    4c9e:	0e 5f       	subi	r16, 0xFE	; 254
    4ca0:	1f 4f       	sbci	r17, 0xFF	; 255
    4ca2:	c8 01       	movw	r24, r16
    4ca4:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4ca8:	8e 89       	ldd	r24, Y+22	; 0x16
    4caa:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    4cae:	98 17       	cp	r25, r24
    4cb0:	10 f4       	brcc	.+4      	; 0x4cb6 <vTaskDelay+0xf4>
    4cb2:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    4cb6:	90 e0       	ldi	r25, 0x00	; 0
    4cb8:	9c 01       	movw	r18, r24
    4cba:	22 0f       	add	r18, r18
    4cbc:	33 1f       	adc	r19, r19
    4cbe:	22 0f       	add	r18, r18
    4cc0:	33 1f       	adc	r19, r19
    4cc2:	22 0f       	add	r18, r18
    4cc4:	33 1f       	adc	r19, r19
    4cc6:	82 0f       	add	r24, r18
    4cc8:	93 1f       	adc	r25, r19
    4cca:	b8 01       	movw	r22, r16
    4ccc:	89 57       	subi	r24, 0x79	; 121
    4cce:	95 4e       	sbci	r25, 0xE5	; 229
    4cd0:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    4cd4:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4cd8:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4cdc:	9e 89       	ldd	r25, Y+22	; 0x16
    4cde:	86 89       	ldd	r24, Z+22	; 0x16
    4ce0:	98 17       	cp	r25, r24
    4ce2:	58 f0       	brcs	.+22     	; 0x4cfa <vTaskDelay+0x138>
    4ce4:	d0 92 58 1a 	sts	0x1A58, r13	; 0x801a58 <xYieldPending>
    4ce8:	08 c0       	rjmp	.+16     	; 0x4cfa <vTaskDelay+0x138>
    4cea:	0f 2e       	mov	r0, r31
    4cec:	f8 e6       	ldi	r31, 0x68	; 104
    4cee:	ef 2e       	mov	r14, r31
    4cf0:	fa e1       	ldi	r31, 0x1A	; 26
    4cf2:	ff 2e       	mov	r15, r31
    4cf4:	f0 2d       	mov	r31, r0
    4cf6:	dd 24       	eor	r13, r13
    4cf8:	d3 94       	inc	r13
    4cfa:	f7 01       	movw	r30, r14
    4cfc:	80 81       	ld	r24, Z
    4cfe:	81 11       	cpse	r24, r1
    4d00:	c2 cf       	rjmp	.-124    	; 0x4c86 <vTaskDelay+0xc4>
    4d02:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    4d06:	88 23       	and	r24, r24
    4d08:	09 f4       	brne	.+2      	; 0x4d0c <vTaskDelay+0x14a>
    4d0a:	bd c0       	rjmp	.+378    	; 0x4e86 <vTaskDelay+0x2c4>
    4d0c:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    4d10:	88 23       	and	r24, r24
    4d12:	09 f4       	brne	.+2      	; 0x4d16 <vTaskDelay+0x154>
    4d14:	b8 c0       	rjmp	.+368    	; 0x4e86 <vTaskDelay+0x2c4>
    4d16:	91 2c       	mov	r9, r1
    4d18:	bb 24       	eor	r11, r11
    4d1a:	b3 94       	inc	r11
    4d1c:	cc 24       	eor	r12, r12
    4d1e:	ca 94       	dec	r12
    4d20:	dc 2c       	mov	r13, r12
    4d22:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    4d26:	81 11       	cpse	r24, r1
    4d28:	98 c0       	rjmp	.+304    	; 0x4e5a <vTaskDelay+0x298>
    4d2a:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    4d2e:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    4d32:	01 96       	adiw	r24, 0x01	; 1
    4d34:	90 93 5d 1a 	sts	0x1A5D, r25	; 0x801a5d <xTickCount+0x1>
    4d38:	80 93 5c 1a 	sts	0x1A5C, r24	; 0x801a5c <xTickCount>
    4d3c:	e0 90 5c 1a 	lds	r14, 0x1A5C	; 0x801a5c <xTickCount>
    4d40:	f0 90 5d 1a 	lds	r15, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    4d44:	e1 14       	cp	r14, r1
    4d46:	f1 04       	cpc	r15, r1
    4d48:	89 f5       	brne	.+98     	; 0x4dac <vTaskDelay+0x1ea>
    4d4a:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4d4e:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4d52:	20 91 71 1a 	lds	r18, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    4d56:	30 91 72 1a 	lds	r19, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    4d5a:	30 93 74 1a 	sts	0x1A74, r19	; 0x801a74 <pxDelayedTaskList+0x1>
    4d5e:	20 93 73 1a 	sts	0x1A73, r18	; 0x801a73 <pxDelayedTaskList>
    4d62:	90 93 72 1a 	sts	0x1A72, r25	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    4d66:	80 93 71 1a 	sts	0x1A71, r24	; 0x801a71 <pxOverflowDelayedTaskList>
    4d6a:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <xNumOfOverflows>
    4d6e:	8f 5f       	subi	r24, 0xFF	; 255
    4d70:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <xNumOfOverflows>
    4d74:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4d78:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4d7c:	80 81       	ld	r24, Z
    4d7e:	81 11       	cpse	r24, r1
    4d80:	05 c0       	rjmp	.+10     	; 0x4d8c <vTaskDelay+0x1ca>
    4d82:	d0 92 55 1a 	sts	0x1A55, r13	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4d86:	c0 92 54 1a 	sts	0x1A54, r12	; 0x801a54 <xNextTaskUnblockTime>
    4d8a:	10 c0       	rjmp	.+32     	; 0x4dac <vTaskDelay+0x1ea>
    4d8c:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4d90:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4d94:	05 80       	ldd	r0, Z+5	; 0x05
    4d96:	f6 81       	ldd	r31, Z+6	; 0x06
    4d98:	e0 2d       	mov	r30, r0
    4d9a:	06 80       	ldd	r0, Z+6	; 0x06
    4d9c:	f7 81       	ldd	r31, Z+7	; 0x07
    4d9e:	e0 2d       	mov	r30, r0
    4da0:	82 81       	ldd	r24, Z+2	; 0x02
    4da2:	93 81       	ldd	r25, Z+3	; 0x03
    4da4:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4da8:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    4dac:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    4db0:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4db4:	e8 16       	cp	r14, r24
    4db6:	f9 06       	cpc	r15, r25
    4db8:	08 f4       	brcc	.+2      	; 0x4dbc <vTaskDelay+0x1fa>
    4dba:	77 c0       	rjmp	.+238    	; 0x4eaa <vTaskDelay+0x2e8>
    4dbc:	a9 2c       	mov	r10, r9
    4dbe:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4dc2:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4dc6:	80 81       	ld	r24, Z
    4dc8:	81 11       	cpse	r24, r1
    4dca:	05 c0       	rjmp	.+10     	; 0x4dd6 <vTaskDelay+0x214>
    4dcc:	d0 92 55 1a 	sts	0x1A55, r13	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4dd0:	c0 92 54 1a 	sts	0x1A54, r12	; 0x801a54 <xNextTaskUnblockTime>
    4dd4:	48 c0       	rjmp	.+144    	; 0x4e66 <vTaskDelay+0x2a4>
    4dd6:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    4dda:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    4dde:	05 80       	ldd	r0, Z+5	; 0x05
    4de0:	f6 81       	ldd	r31, Z+6	; 0x06
    4de2:	e0 2d       	mov	r30, r0
    4de4:	c6 81       	ldd	r28, Z+6	; 0x06
    4de6:	d7 81       	ldd	r29, Z+7	; 0x07
    4de8:	8a 81       	ldd	r24, Y+2	; 0x02
    4dea:	9b 81       	ldd	r25, Y+3	; 0x03
    4dec:	e8 16       	cp	r14, r24
    4dee:	f9 06       	cpc	r15, r25
    4df0:	28 f4       	brcc	.+10     	; 0x4dfc <vTaskDelay+0x23a>
    4df2:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    4df6:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    4dfa:	35 c0       	rjmp	.+106    	; 0x4e66 <vTaskDelay+0x2a4>
    4dfc:	8e 01       	movw	r16, r28
    4dfe:	0e 5f       	subi	r16, 0xFE	; 254
    4e00:	1f 4f       	sbci	r17, 0xFF	; 255
    4e02:	c8 01       	movw	r24, r16
    4e04:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4e08:	8c 89       	ldd	r24, Y+20	; 0x14
    4e0a:	9d 89       	ldd	r25, Y+21	; 0x15
    4e0c:	89 2b       	or	r24, r25
    4e0e:	21 f0       	breq	.+8      	; 0x4e18 <vTaskDelay+0x256>
    4e10:	ce 01       	movw	r24, r28
    4e12:	0c 96       	adiw	r24, 0x0c	; 12
    4e14:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    4e18:	8e 89       	ldd	r24, Y+22	; 0x16
    4e1a:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    4e1e:	98 17       	cp	r25, r24
    4e20:	10 f4       	brcc	.+4      	; 0x4e26 <vTaskDelay+0x264>
    4e22:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    4e26:	90 e0       	ldi	r25, 0x00	; 0
    4e28:	9c 01       	movw	r18, r24
    4e2a:	22 0f       	add	r18, r18
    4e2c:	33 1f       	adc	r19, r19
    4e2e:	22 0f       	add	r18, r18
    4e30:	33 1f       	adc	r19, r19
    4e32:	22 0f       	add	r18, r18
    4e34:	33 1f       	adc	r19, r19
    4e36:	82 0f       	add	r24, r18
    4e38:	93 1f       	adc	r25, r19
    4e3a:	b8 01       	movw	r22, r16
    4e3c:	89 57       	subi	r24, 0x79	; 121
    4e3e:	95 4e       	sbci	r25, 0xE5	; 229
    4e40:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    4e44:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4e48:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4e4c:	9e 89       	ldd	r25, Y+22	; 0x16
    4e4e:	86 89       	ldd	r24, Z+22	; 0x16
    4e50:	98 17       	cp	r25, r24
    4e52:	08 f4       	brcc	.+2      	; 0x4e56 <vTaskDelay+0x294>
    4e54:	b4 cf       	rjmp	.-152    	; 0x4dbe <vTaskDelay+0x1fc>
    4e56:	ab 2c       	mov	r10, r11
    4e58:	b2 cf       	rjmp	.-156    	; 0x4dbe <vTaskDelay+0x1fc>
    4e5a:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    4e5e:	8f 5f       	subi	r24, 0xFF	; 255
    4e60:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <uxPendedTicks>
    4e64:	22 c0       	rjmp	.+68     	; 0x4eaa <vTaskDelay+0x2e8>
    4e66:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    4e6a:	81 11       	cpse	r24, r1
    4e6c:	01 c0       	rjmp	.+2      	; 0x4e70 <vTaskDelay+0x2ae>
    4e6e:	a1 10       	cpse	r10, r1
    4e70:	b0 92 58 1a 	sts	0x1A58, r11	; 0x801a58 <xYieldPending>
    4e74:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    4e78:	81 50       	subi	r24, 0x01	; 1
    4e7a:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <uxPendedTicks>
    4e7e:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    4e82:	81 11       	cpse	r24, r1
    4e84:	4e cf       	rjmp	.-356    	; 0x4d22 <vTaskDelay+0x160>
    4e86:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    4e8a:	81 30       	cpi	r24, 0x01	; 1
    4e8c:	31 f4       	brne	.+12     	; 0x4e9a <vTaskDelay+0x2d8>
    4e8e:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    4e92:	81 e0       	ldi	r24, 0x01	; 1
    4e94:	03 c0       	rjmp	.+6      	; 0x4e9c <vTaskDelay+0x2da>
    4e96:	80 e0       	ldi	r24, 0x00	; 0
    4e98:	01 c0       	rjmp	.+2      	; 0x4e9c <vTaskDelay+0x2da>
    4e9a:	80 e0       	ldi	r24, 0x00	; 0
    4e9c:	0f 90       	pop	r0
    4e9e:	0f be       	out	0x3f, r0	; 63
    4ea0:	81 11       	cpse	r24, r1
    4ea2:	08 c0       	rjmp	.+16     	; 0x4eb4 <vTaskDelay+0x2f2>
    4ea4:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    4ea8:	05 c0       	rjmp	.+10     	; 0x4eb4 <vTaskDelay+0x2f2>
    4eaa:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    4eae:	81 11       	cpse	r24, r1
    4eb0:	df cf       	rjmp	.-66     	; 0x4e70 <vTaskDelay+0x2ae>
    4eb2:	e0 cf       	rjmp	.-64     	; 0x4e74 <vTaskDelay+0x2b2>
    4eb4:	df 91       	pop	r29
    4eb6:	cf 91       	pop	r28
    4eb8:	1f 91       	pop	r17
    4eba:	0f 91       	pop	r16
    4ebc:	ff 90       	pop	r15
    4ebe:	ef 90       	pop	r14
    4ec0:	df 90       	pop	r13
    4ec2:	cf 90       	pop	r12
    4ec4:	bf 90       	pop	r11
    4ec6:	af 90       	pop	r10
    4ec8:	9f 90       	pop	r9
    4eca:	08 95       	ret

00004ecc <vTaskStartScheduler>:
    4ecc:	cf 92       	push	r12
    4ece:	df 92       	push	r13
    4ed0:	ef 92       	push	r14
    4ed2:	ff 92       	push	r15
    4ed4:	0f 93       	push	r16
    4ed6:	1f 93       	push	r17
    4ed8:	cf 93       	push	r28
    4eda:	df 93       	push	r29
    4edc:	85 e5       	ldi	r24, 0x55	; 85
    4ede:	90 e0       	ldi	r25, 0x00	; 0
    4ee0:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4ee4:	8c 01       	movw	r16, r24
    4ee6:	89 2b       	or	r24, r25
    4ee8:	09 f4       	brne	.+2      	; 0x4eec <vTaskStartScheduler+0x20>
    4eea:	cb c0       	rjmp	.+406    	; 0x5082 <vTaskStartScheduler+0x1b6>
    4eec:	88 e2       	ldi	r24, 0x28	; 40
    4eee:	90 e0       	ldi	r25, 0x00	; 0
    4ef0:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4ef4:	ec 01       	movw	r28, r24
    4ef6:	89 2b       	or	r24, r25
    4ef8:	69 f0       	breq	.+26     	; 0x4f14 <vTaskStartScheduler+0x48>
    4efa:	18 8f       	std	Y+24, r17	; 0x18
    4efc:	0f 8b       	std	Y+23, r16	; 0x17
    4efe:	0c 5a       	subi	r16, 0xAC	; 172
    4f00:	1f 4f       	sbci	r17, 0xFF	; 255
    4f02:	89 e4       	ldi	r24, 0x49	; 73
    4f04:	89 8f       	std	Y+25, r24	; 0x19
    4f06:	e8 e1       	ldi	r30, 0x18	; 24
    4f08:	f7 e0       	ldi	r31, 0x07	; 7
    4f0a:	de 01       	movw	r26, r28
    4f0c:	5a 96       	adiw	r26, 0x1a	; 26
    4f0e:	2f e1       	ldi	r18, 0x1F	; 31
    4f10:	37 e0       	ldi	r19, 0x07	; 7
    4f12:	04 c0       	rjmp	.+8      	; 0x4f1c <vTaskStartScheduler+0x50>
    4f14:	c8 01       	movw	r24, r16
    4f16:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    4f1a:	b3 c0       	rjmp	.+358    	; 0x5082 <vTaskStartScheduler+0x1b6>
    4f1c:	91 91       	ld	r25, Z+
    4f1e:	9d 93       	st	X+, r25
    4f20:	99 23       	and	r25, r25
    4f22:	19 f0       	breq	.+6      	; 0x4f2a <vTaskStartScheduler+0x5e>
    4f24:	2e 17       	cp	r18, r30
    4f26:	3f 07       	cpc	r19, r31
    4f28:	c9 f7       	brne	.-14     	; 0x4f1c <vTaskStartScheduler+0x50>
    4f2a:	18 a2       	std	Y+32, r1	; 0x20
    4f2c:	1e 8a       	std	Y+22, r1	; 0x16
    4f2e:	19 a2       	std	Y+33, r1	; 0x21
    4f30:	1a a2       	std	Y+34, r1	; 0x22
    4f32:	7e 01       	movw	r14, r28
    4f34:	82 e0       	ldi	r24, 0x02	; 2
    4f36:	e8 0e       	add	r14, r24
    4f38:	f1 1c       	adc	r15, r1
    4f3a:	c7 01       	movw	r24, r14
    4f3c:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <vListInitialiseItem>
    4f40:	ce 01       	movw	r24, r28
    4f42:	0c 96       	adiw	r24, 0x0c	; 12
    4f44:	0e 94 54 0c 	call	0x18a8	; 0x18a8 <vListInitialiseItem>
    4f48:	d9 87       	std	Y+9, r29	; 0x09
    4f4a:	c8 87       	std	Y+8, r28	; 0x08
    4f4c:	86 e0       	ldi	r24, 0x06	; 6
    4f4e:	90 e0       	ldi	r25, 0x00	; 0
    4f50:	9d 87       	std	Y+13, r25	; 0x0d
    4f52:	8c 87       	std	Y+12, r24	; 0x0c
    4f54:	db 8b       	std	Y+19, r29	; 0x13
    4f56:	ca 8b       	std	Y+18, r28	; 0x12
    4f58:	1b a2       	std	Y+35, r1	; 0x23
    4f5a:	1c a2       	std	Y+36, r1	; 0x24
    4f5c:	1d a2       	std	Y+37, r1	; 0x25
    4f5e:	1e a2       	std	Y+38, r1	; 0x26
    4f60:	1f a2       	std	Y+39, r1	; 0x27
    4f62:	40 e0       	ldi	r20, 0x00	; 0
    4f64:	50 e0       	ldi	r21, 0x00	; 0
    4f66:	69 e1       	ldi	r22, 0x19	; 25
    4f68:	71 e0       	ldi	r23, 0x01	; 1
    4f6a:	c8 01       	movw	r24, r16
    4f6c:	0e 94 16 18 	call	0x302c	; 0x302c <pxPortInitialiseStack>
    4f70:	99 83       	std	Y+1, r25	; 0x01
    4f72:	88 83       	st	Y, r24
    4f74:	0f b6       	in	r0, 0x3f	; 63
    4f76:	f8 94       	cli
    4f78:	0f 92       	push	r0
    4f7a:	80 91 5e 1a 	lds	r24, 0x1A5E	; 0x801a5e <uxCurrentNumberOfTasks>
    4f7e:	8f 5f       	subi	r24, 0xFF	; 255
    4f80:	80 93 5e 1a 	sts	0x1A5E, r24	; 0x801a5e <uxCurrentNumberOfTasks>
    4f84:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    4f88:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    4f8c:	89 2b       	or	r24, r25
    4f8e:	a9 f5       	brne	.+106    	; 0x4ffa <vTaskStartScheduler+0x12e>
    4f90:	d0 93 be 1a 	sts	0x1ABE, r29	; 0x801abe <pxCurrentTCB+0x1>
    4f94:	c0 93 bd 1a 	sts	0x1ABD, r28	; 0x801abd <pxCurrentTCB>
    4f98:	80 91 5e 1a 	lds	r24, 0x1A5E	; 0x801a5e <uxCurrentNumberOfTasks>
    4f9c:	81 30       	cpi	r24, 0x01	; 1
    4f9e:	e1 f5       	brne	.+120    	; 0x5018 <vTaskStartScheduler+0x14c>
    4fa0:	07 e8       	ldi	r16, 0x87	; 135
    4fa2:	1a e1       	ldi	r17, 0x1A	; 26
    4fa4:	0f 2e       	mov	r0, r31
    4fa6:	fd eb       	ldi	r31, 0xBD	; 189
    4fa8:	cf 2e       	mov	r12, r31
    4faa:	fa e1       	ldi	r31, 0x1A	; 26
    4fac:	df 2e       	mov	r13, r31
    4fae:	f0 2d       	mov	r31, r0
    4fb0:	c8 01       	movw	r24, r16
    4fb2:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    4fb6:	07 5f       	subi	r16, 0xF7	; 247
    4fb8:	1f 4f       	sbci	r17, 0xFF	; 255
    4fba:	0c 15       	cp	r16, r12
    4fbc:	1d 05       	cpc	r17, r13
    4fbe:	c1 f7       	brne	.-16     	; 0x4fb0 <vTaskStartScheduler+0xe4>
    4fc0:	8e e7       	ldi	r24, 0x7E	; 126
    4fc2:	9a e1       	ldi	r25, 0x1A	; 26
    4fc4:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    4fc8:	85 e7       	ldi	r24, 0x75	; 117
    4fca:	9a e1       	ldi	r25, 0x1A	; 26
    4fcc:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    4fd0:	88 e6       	ldi	r24, 0x68	; 104
    4fd2:	9a e1       	ldi	r25, 0x1A	; 26
    4fd4:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    4fd8:	8f e5       	ldi	r24, 0x5F	; 95
    4fda:	9a e1       	ldi	r25, 0x1A	; 26
    4fdc:	0e 94 46 0c 	call	0x188c	; 0x188c <vListInitialise>
    4fe0:	8e e7       	ldi	r24, 0x7E	; 126
    4fe2:	9a e1       	ldi	r25, 0x1A	; 26
    4fe4:	90 93 74 1a 	sts	0x1A74, r25	; 0x801a74 <pxDelayedTaskList+0x1>
    4fe8:	80 93 73 1a 	sts	0x1A73, r24	; 0x801a73 <pxDelayedTaskList>
    4fec:	85 e7       	ldi	r24, 0x75	; 117
    4fee:	9a e1       	ldi	r25, 0x1A	; 26
    4ff0:	90 93 72 1a 	sts	0x1A72, r25	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    4ff4:	80 93 71 1a 	sts	0x1A71, r24	; 0x801a71 <pxOverflowDelayedTaskList>
    4ff8:	0f c0       	rjmp	.+30     	; 0x5018 <vTaskStartScheduler+0x14c>
    4ffa:	80 91 5a 1a 	lds	r24, 0x1A5A	; 0x801a5a <xSchedulerRunning>
    4ffe:	81 11       	cpse	r24, r1
    5000:	0b c0       	rjmp	.+22     	; 0x5018 <vTaskStartScheduler+0x14c>
    5002:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5006:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    500a:	86 89       	ldd	r24, Z+22	; 0x16
    500c:	81 11       	cpse	r24, r1
    500e:	04 c0       	rjmp	.+8      	; 0x5018 <vTaskStartScheduler+0x14c>
    5010:	d0 93 be 1a 	sts	0x1ABE, r29	; 0x801abe <pxCurrentTCB+0x1>
    5014:	c0 93 bd 1a 	sts	0x1ABD, r28	; 0x801abd <pxCurrentTCB>
    5018:	80 91 56 1a 	lds	r24, 0x1A56	; 0x801a56 <uxTaskNumber>
    501c:	8f 5f       	subi	r24, 0xFF	; 255
    501e:	80 93 56 1a 	sts	0x1A56, r24	; 0x801a56 <uxTaskNumber>
    5022:	8e 89       	ldd	r24, Y+22	; 0x16
    5024:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    5028:	98 17       	cp	r25, r24
    502a:	10 f4       	brcc	.+4      	; 0x5030 <vTaskStartScheduler+0x164>
    502c:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    5030:	90 e0       	ldi	r25, 0x00	; 0
    5032:	9c 01       	movw	r18, r24
    5034:	22 0f       	add	r18, r18
    5036:	33 1f       	adc	r19, r19
    5038:	22 0f       	add	r18, r18
    503a:	33 1f       	adc	r19, r19
    503c:	22 0f       	add	r18, r18
    503e:	33 1f       	adc	r19, r19
    5040:	82 0f       	add	r24, r18
    5042:	93 1f       	adc	r25, r19
    5044:	b7 01       	movw	r22, r14
    5046:	89 57       	subi	r24, 0x79	; 121
    5048:	95 4e       	sbci	r25, 0xE5	; 229
    504a:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    504e:	0f 90       	pop	r0
    5050:	0f be       	out	0x3f, r0	; 63
    5052:	80 91 5a 1a 	lds	r24, 0x1A5A	; 0x801a5a <xSchedulerRunning>
    5056:	88 23       	and	r24, r24
    5058:	21 f0       	breq	.+8      	; 0x5062 <vTaskStartScheduler+0x196>
    505a:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    505e:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5062:	f8 94       	cli
    5064:	8f ef       	ldi	r24, 0xFF	; 255
    5066:	9f ef       	ldi	r25, 0xFF	; 255
    5068:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    506c:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    5070:	81 e0       	ldi	r24, 0x01	; 1
    5072:	80 93 5a 1a 	sts	0x1A5A, r24	; 0x801a5a <xSchedulerRunning>
    5076:	10 92 5d 1a 	sts	0x1A5D, r1	; 0x801a5d <xTickCount+0x1>
    507a:	10 92 5c 1a 	sts	0x1A5C, r1	; 0x801a5c <xTickCount>
    507e:	0e 94 88 18 	call	0x3110	; 0x3110 <xPortStartScheduler>
    5082:	df 91       	pop	r29
    5084:	cf 91       	pop	r28
    5086:	1f 91       	pop	r17
    5088:	0f 91       	pop	r16
    508a:	ff 90       	pop	r15
    508c:	ef 90       	pop	r14
    508e:	df 90       	pop	r13
    5090:	cf 90       	pop	r12
    5092:	08 95       	ret

00005094 <vTaskSuspendAll>:
    5094:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    5098:	8f 5f       	subi	r24, 0xFF	; 255
    509a:	80 93 53 1a 	sts	0x1A53, r24	; 0x801a53 <uxSchedulerSuspended>
    509e:	08 95       	ret

000050a0 <xTaskResumeAll>:
    50a0:	9f 92       	push	r9
    50a2:	af 92       	push	r10
    50a4:	bf 92       	push	r11
    50a6:	cf 92       	push	r12
    50a8:	df 92       	push	r13
    50aa:	ef 92       	push	r14
    50ac:	ff 92       	push	r15
    50ae:	0f 93       	push	r16
    50b0:	1f 93       	push	r17
    50b2:	cf 93       	push	r28
    50b4:	df 93       	push	r29
    50b6:	0f b6       	in	r0, 0x3f	; 63
    50b8:	f8 94       	cli
    50ba:	0f 92       	push	r0
    50bc:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    50c0:	81 50       	subi	r24, 0x01	; 1
    50c2:	80 93 53 1a 	sts	0x1A53, r24	; 0x801a53 <uxSchedulerSuspended>
    50c6:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    50ca:	81 11       	cpse	r24, r1
    50cc:	0d c1       	rjmp	.+538    	; 0x52e8 <xTaskResumeAll+0x248>
    50ce:	80 91 5e 1a 	lds	r24, 0x1A5E	; 0x801a5e <uxCurrentNumberOfTasks>
    50d2:	81 11       	cpse	r24, r1
    50d4:	33 c0       	rjmp	.+102    	; 0x513c <xTaskResumeAll+0x9c>
    50d6:	0b c1       	rjmp	.+534    	; 0x52ee <xTaskResumeAll+0x24e>
    50d8:	d7 01       	movw	r26, r14
    50da:	15 96       	adiw	r26, 0x05	; 5
    50dc:	ed 91       	ld	r30, X+
    50de:	fc 91       	ld	r31, X
    50e0:	16 97       	sbiw	r26, 0x06	; 6
    50e2:	c6 81       	ldd	r28, Z+6	; 0x06
    50e4:	d7 81       	ldd	r29, Z+7	; 0x07
    50e6:	ce 01       	movw	r24, r28
    50e8:	0c 96       	adiw	r24, 0x0c	; 12
    50ea:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    50ee:	8e 01       	movw	r16, r28
    50f0:	0e 5f       	subi	r16, 0xFE	; 254
    50f2:	1f 4f       	sbci	r17, 0xFF	; 255
    50f4:	c8 01       	movw	r24, r16
    50f6:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    50fa:	8e 89       	ldd	r24, Y+22	; 0x16
    50fc:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    5100:	98 17       	cp	r25, r24
    5102:	10 f4       	brcc	.+4      	; 0x5108 <xTaskResumeAll+0x68>
    5104:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    5108:	90 e0       	ldi	r25, 0x00	; 0
    510a:	9c 01       	movw	r18, r24
    510c:	22 0f       	add	r18, r18
    510e:	33 1f       	adc	r19, r19
    5110:	22 0f       	add	r18, r18
    5112:	33 1f       	adc	r19, r19
    5114:	22 0f       	add	r18, r18
    5116:	33 1f       	adc	r19, r19
    5118:	82 0f       	add	r24, r18
    511a:	93 1f       	adc	r25, r19
    511c:	b8 01       	movw	r22, r16
    511e:	89 57       	subi	r24, 0x79	; 121
    5120:	95 4e       	sbci	r25, 0xE5	; 229
    5122:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    5126:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    512a:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    512e:	9e 89       	ldd	r25, Y+22	; 0x16
    5130:	86 89       	ldd	r24, Z+22	; 0x16
    5132:	98 17       	cp	r25, r24
    5134:	58 f0       	brcs	.+22     	; 0x514c <xTaskResumeAll+0xac>
    5136:	d0 92 58 1a 	sts	0x1A58, r13	; 0x801a58 <xYieldPending>
    513a:	08 c0       	rjmp	.+16     	; 0x514c <xTaskResumeAll+0xac>
    513c:	0f 2e       	mov	r0, r31
    513e:	f8 e6       	ldi	r31, 0x68	; 104
    5140:	ef 2e       	mov	r14, r31
    5142:	fa e1       	ldi	r31, 0x1A	; 26
    5144:	ff 2e       	mov	r15, r31
    5146:	f0 2d       	mov	r31, r0
    5148:	dd 24       	eor	r13, r13
    514a:	d3 94       	inc	r13
    514c:	f7 01       	movw	r30, r14
    514e:	80 81       	ld	r24, Z
    5150:	81 11       	cpse	r24, r1
    5152:	c2 cf       	rjmp	.-124    	; 0x50d8 <xTaskResumeAll+0x38>
    5154:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    5158:	88 23       	and	r24, r24
    515a:	09 f4       	brne	.+2      	; 0x515e <xTaskResumeAll+0xbe>
    515c:	bd c0       	rjmp	.+378    	; 0x52d8 <xTaskResumeAll+0x238>
    515e:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    5162:	88 23       	and	r24, r24
    5164:	09 f4       	brne	.+2      	; 0x5168 <xTaskResumeAll+0xc8>
    5166:	b8 c0       	rjmp	.+368    	; 0x52d8 <xTaskResumeAll+0x238>
    5168:	91 2c       	mov	r9, r1
    516a:	bb 24       	eor	r11, r11
    516c:	b3 94       	inc	r11
    516e:	cc 24       	eor	r12, r12
    5170:	ca 94       	dec	r12
    5172:	dc 2c       	mov	r13, r12
    5174:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    5178:	81 11       	cpse	r24, r1
    517a:	98 c0       	rjmp	.+304    	; 0x52ac <xTaskResumeAll+0x20c>
    517c:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    5180:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5184:	01 96       	adiw	r24, 0x01	; 1
    5186:	90 93 5d 1a 	sts	0x1A5D, r25	; 0x801a5d <xTickCount+0x1>
    518a:	80 93 5c 1a 	sts	0x1A5C, r24	; 0x801a5c <xTickCount>
    518e:	e0 90 5c 1a 	lds	r14, 0x1A5C	; 0x801a5c <xTickCount>
    5192:	f0 90 5d 1a 	lds	r15, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5196:	e1 14       	cp	r14, r1
    5198:	f1 04       	cpc	r15, r1
    519a:	89 f5       	brne	.+98     	; 0x51fe <xTaskResumeAll+0x15e>
    519c:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    51a0:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    51a4:	20 91 71 1a 	lds	r18, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    51a8:	30 91 72 1a 	lds	r19, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    51ac:	30 93 74 1a 	sts	0x1A74, r19	; 0x801a74 <pxDelayedTaskList+0x1>
    51b0:	20 93 73 1a 	sts	0x1A73, r18	; 0x801a73 <pxDelayedTaskList>
    51b4:	90 93 72 1a 	sts	0x1A72, r25	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    51b8:	80 93 71 1a 	sts	0x1A71, r24	; 0x801a71 <pxOverflowDelayedTaskList>
    51bc:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <xNumOfOverflows>
    51c0:	8f 5f       	subi	r24, 0xFF	; 255
    51c2:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <xNumOfOverflows>
    51c6:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    51ca:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    51ce:	80 81       	ld	r24, Z
    51d0:	81 11       	cpse	r24, r1
    51d2:	05 c0       	rjmp	.+10     	; 0x51de <xTaskResumeAll+0x13e>
    51d4:	d0 92 55 1a 	sts	0x1A55, r13	; 0x801a55 <xNextTaskUnblockTime+0x1>
    51d8:	c0 92 54 1a 	sts	0x1A54, r12	; 0x801a54 <xNextTaskUnblockTime>
    51dc:	10 c0       	rjmp	.+32     	; 0x51fe <xTaskResumeAll+0x15e>
    51de:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    51e2:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    51e6:	05 80       	ldd	r0, Z+5	; 0x05
    51e8:	f6 81       	ldd	r31, Z+6	; 0x06
    51ea:	e0 2d       	mov	r30, r0
    51ec:	06 80       	ldd	r0, Z+6	; 0x06
    51ee:	f7 81       	ldd	r31, Z+7	; 0x07
    51f0:	e0 2d       	mov	r30, r0
    51f2:	82 81       	ldd	r24, Z+2	; 0x02
    51f4:	93 81       	ldd	r25, Z+3	; 0x03
    51f6:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    51fa:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    51fe:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    5202:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    5206:	e8 16       	cp	r14, r24
    5208:	f9 06       	cpc	r15, r25
    520a:	08 f4       	brcc	.+2      	; 0x520e <xTaskResumeAll+0x16e>
    520c:	73 c0       	rjmp	.+230    	; 0x52f4 <xTaskResumeAll+0x254>
    520e:	a9 2c       	mov	r10, r9
    5210:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    5214:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    5218:	80 81       	ld	r24, Z
    521a:	81 11       	cpse	r24, r1
    521c:	05 c0       	rjmp	.+10     	; 0x5228 <xTaskResumeAll+0x188>
    521e:	d0 92 55 1a 	sts	0x1A55, r13	; 0x801a55 <xNextTaskUnblockTime+0x1>
    5222:	c0 92 54 1a 	sts	0x1A54, r12	; 0x801a54 <xNextTaskUnblockTime>
    5226:	48 c0       	rjmp	.+144    	; 0x52b8 <xTaskResumeAll+0x218>
    5228:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    522c:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    5230:	05 80       	ldd	r0, Z+5	; 0x05
    5232:	f6 81       	ldd	r31, Z+6	; 0x06
    5234:	e0 2d       	mov	r30, r0
    5236:	c6 81       	ldd	r28, Z+6	; 0x06
    5238:	d7 81       	ldd	r29, Z+7	; 0x07
    523a:	8a 81       	ldd	r24, Y+2	; 0x02
    523c:	9b 81       	ldd	r25, Y+3	; 0x03
    523e:	e8 16       	cp	r14, r24
    5240:	f9 06       	cpc	r15, r25
    5242:	28 f4       	brcc	.+10     	; 0x524e <xTaskResumeAll+0x1ae>
    5244:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    5248:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    524c:	35 c0       	rjmp	.+106    	; 0x52b8 <xTaskResumeAll+0x218>
    524e:	8e 01       	movw	r16, r28
    5250:	0e 5f       	subi	r16, 0xFE	; 254
    5252:	1f 4f       	sbci	r17, 0xFF	; 255
    5254:	c8 01       	movw	r24, r16
    5256:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    525a:	8c 89       	ldd	r24, Y+20	; 0x14
    525c:	9d 89       	ldd	r25, Y+21	; 0x15
    525e:	89 2b       	or	r24, r25
    5260:	21 f0       	breq	.+8      	; 0x526a <xTaskResumeAll+0x1ca>
    5262:	ce 01       	movw	r24, r28
    5264:	0c 96       	adiw	r24, 0x0c	; 12
    5266:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    526a:	8e 89       	ldd	r24, Y+22	; 0x16
    526c:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    5270:	98 17       	cp	r25, r24
    5272:	10 f4       	brcc	.+4      	; 0x5278 <xTaskResumeAll+0x1d8>
    5274:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    5278:	90 e0       	ldi	r25, 0x00	; 0
    527a:	9c 01       	movw	r18, r24
    527c:	22 0f       	add	r18, r18
    527e:	33 1f       	adc	r19, r19
    5280:	22 0f       	add	r18, r18
    5282:	33 1f       	adc	r19, r19
    5284:	22 0f       	add	r18, r18
    5286:	33 1f       	adc	r19, r19
    5288:	82 0f       	add	r24, r18
    528a:	93 1f       	adc	r25, r19
    528c:	b8 01       	movw	r22, r16
    528e:	89 57       	subi	r24, 0x79	; 121
    5290:	95 4e       	sbci	r25, 0xE5	; 229
    5292:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    5296:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    529a:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    529e:	9e 89       	ldd	r25, Y+22	; 0x16
    52a0:	86 89       	ldd	r24, Z+22	; 0x16
    52a2:	98 17       	cp	r25, r24
    52a4:	08 f4       	brcc	.+2      	; 0x52a8 <xTaskResumeAll+0x208>
    52a6:	b4 cf       	rjmp	.-152    	; 0x5210 <xTaskResumeAll+0x170>
    52a8:	ab 2c       	mov	r10, r11
    52aa:	b2 cf       	rjmp	.-156    	; 0x5210 <xTaskResumeAll+0x170>
    52ac:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    52b0:	8f 5f       	subi	r24, 0xFF	; 255
    52b2:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <uxPendedTicks>
    52b6:	1e c0       	rjmp	.+60     	; 0x52f4 <xTaskResumeAll+0x254>
    52b8:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    52bc:	81 11       	cpse	r24, r1
    52be:	01 c0       	rjmp	.+2      	; 0x52c2 <xTaskResumeAll+0x222>
    52c0:	a1 10       	cpse	r10, r1
    52c2:	b0 92 58 1a 	sts	0x1A58, r11	; 0x801a58 <xYieldPending>
    52c6:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    52ca:	81 50       	subi	r24, 0x01	; 1
    52cc:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <uxPendedTicks>
    52d0:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    52d4:	81 11       	cpse	r24, r1
    52d6:	4e cf       	rjmp	.-356    	; 0x5174 <xTaskResumeAll+0xd4>
    52d8:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    52dc:	81 30       	cpi	r24, 0x01	; 1
    52de:	31 f4       	brne	.+12     	; 0x52ec <xTaskResumeAll+0x24c>
    52e0:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    52e4:	81 e0       	ldi	r24, 0x01	; 1
    52e6:	03 c0       	rjmp	.+6      	; 0x52ee <xTaskResumeAll+0x24e>
    52e8:	80 e0       	ldi	r24, 0x00	; 0
    52ea:	01 c0       	rjmp	.+2      	; 0x52ee <xTaskResumeAll+0x24e>
    52ec:	80 e0       	ldi	r24, 0x00	; 0
    52ee:	0f 90       	pop	r0
    52f0:	0f be       	out	0x3f, r0	; 63
    52f2:	05 c0       	rjmp	.+10     	; 0x52fe <xTaskResumeAll+0x25e>
    52f4:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    52f8:	81 11       	cpse	r24, r1
    52fa:	e3 cf       	rjmp	.-58     	; 0x52c2 <xTaskResumeAll+0x222>
    52fc:	e4 cf       	rjmp	.-56     	; 0x52c6 <xTaskResumeAll+0x226>
    52fe:	df 91       	pop	r29
    5300:	cf 91       	pop	r28
    5302:	1f 91       	pop	r17
    5304:	0f 91       	pop	r16
    5306:	ff 90       	pop	r15
    5308:	ef 90       	pop	r14
    530a:	df 90       	pop	r13
    530c:	cf 90       	pop	r12
    530e:	bf 90       	pop	r11
    5310:	af 90       	pop	r10
    5312:	9f 90       	pop	r9
    5314:	08 95       	ret

00005316 <xTaskGetTickCount>:
    5316:	0f b6       	in	r0, 0x3f	; 63
    5318:	f8 94       	cli
    531a:	0f 92       	push	r0
    531c:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    5320:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5324:	0f 90       	pop	r0
    5326:	0f be       	out	0x3f, r0	; 63
    5328:	08 95       	ret

0000532a <xTaskIncrementTick>:
    532a:	cf 92       	push	r12
    532c:	df 92       	push	r13
    532e:	ef 92       	push	r14
    5330:	ff 92       	push	r15
    5332:	0f 93       	push	r16
    5334:	1f 93       	push	r17
    5336:	cf 93       	push	r28
    5338:	df 93       	push	r29
    533a:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    533e:	81 11       	cpse	r24, r1
    5340:	9f c0       	rjmp	.+318    	; 0x5480 <xTaskIncrementTick+0x156>
    5342:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    5346:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    534a:	01 96       	adiw	r24, 0x01	; 1
    534c:	90 93 5d 1a 	sts	0x1A5D, r25	; 0x801a5d <xTickCount+0x1>
    5350:	80 93 5c 1a 	sts	0x1A5C, r24	; 0x801a5c <xTickCount>
    5354:	e0 90 5c 1a 	lds	r14, 0x1A5C	; 0x801a5c <xTickCount>
    5358:	f0 90 5d 1a 	lds	r15, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    535c:	e1 14       	cp	r14, r1
    535e:	f1 04       	cpc	r15, r1
    5360:	99 f5       	brne	.+102    	; 0x53c8 <xTaskIncrementTick+0x9e>
    5362:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    5366:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    536a:	20 91 71 1a 	lds	r18, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    536e:	30 91 72 1a 	lds	r19, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    5372:	30 93 74 1a 	sts	0x1A74, r19	; 0x801a74 <pxDelayedTaskList+0x1>
    5376:	20 93 73 1a 	sts	0x1A73, r18	; 0x801a73 <pxDelayedTaskList>
    537a:	90 93 72 1a 	sts	0x1A72, r25	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    537e:	80 93 71 1a 	sts	0x1A71, r24	; 0x801a71 <pxOverflowDelayedTaskList>
    5382:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <xNumOfOverflows>
    5386:	8f 5f       	subi	r24, 0xFF	; 255
    5388:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <xNumOfOverflows>
    538c:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    5390:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    5394:	80 81       	ld	r24, Z
    5396:	81 11       	cpse	r24, r1
    5398:	07 c0       	rjmp	.+14     	; 0x53a8 <xTaskIncrementTick+0x7e>
    539a:	8f ef       	ldi	r24, 0xFF	; 255
    539c:	9f ef       	ldi	r25, 0xFF	; 255
    539e:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    53a2:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    53a6:	10 c0       	rjmp	.+32     	; 0x53c8 <xTaskIncrementTick+0x9e>
    53a8:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    53ac:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    53b0:	05 80       	ldd	r0, Z+5	; 0x05
    53b2:	f6 81       	ldd	r31, Z+6	; 0x06
    53b4:	e0 2d       	mov	r30, r0
    53b6:	06 80       	ldd	r0, Z+6	; 0x06
    53b8:	f7 81       	ldd	r31, Z+7	; 0x07
    53ba:	e0 2d       	mov	r30, r0
    53bc:	82 81       	ldd	r24, Z+2	; 0x02
    53be:	93 81       	ldd	r25, Z+3	; 0x03
    53c0:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    53c4:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    53c8:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    53cc:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    53d0:	e8 16       	cp	r14, r24
    53d2:	f9 06       	cpc	r15, r25
    53d4:	10 f4       	brcc	.+4      	; 0x53da <xTaskIncrementTick+0xb0>
    53d6:	d1 2c       	mov	r13, r1
    53d8:	59 c0       	rjmp	.+178    	; 0x548c <xTaskIncrementTick+0x162>
    53da:	d1 2c       	mov	r13, r1
    53dc:	cc 24       	eor	r12, r12
    53de:	c3 94       	inc	r12
    53e0:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    53e4:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    53e8:	80 81       	ld	r24, Z
    53ea:	81 11       	cpse	r24, r1
    53ec:	07 c0       	rjmp	.+14     	; 0x53fc <xTaskIncrementTick+0xd2>
    53ee:	8f ef       	ldi	r24, 0xFF	; 255
    53f0:	9f ef       	ldi	r25, 0xFF	; 255
    53f2:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    53f6:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    53fa:	48 c0       	rjmp	.+144    	; 0x548c <xTaskIncrementTick+0x162>
    53fc:	e0 91 73 1a 	lds	r30, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    5400:	f0 91 74 1a 	lds	r31, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    5404:	05 80       	ldd	r0, Z+5	; 0x05
    5406:	f6 81       	ldd	r31, Z+6	; 0x06
    5408:	e0 2d       	mov	r30, r0
    540a:	c6 81       	ldd	r28, Z+6	; 0x06
    540c:	d7 81       	ldd	r29, Z+7	; 0x07
    540e:	8a 81       	ldd	r24, Y+2	; 0x02
    5410:	9b 81       	ldd	r25, Y+3	; 0x03
    5412:	e8 16       	cp	r14, r24
    5414:	f9 06       	cpc	r15, r25
    5416:	28 f4       	brcc	.+10     	; 0x5422 <xTaskIncrementTick+0xf8>
    5418:	90 93 55 1a 	sts	0x1A55, r25	; 0x801a55 <xNextTaskUnblockTime+0x1>
    541c:	80 93 54 1a 	sts	0x1A54, r24	; 0x801a54 <xNextTaskUnblockTime>
    5420:	35 c0       	rjmp	.+106    	; 0x548c <xTaskIncrementTick+0x162>
    5422:	8e 01       	movw	r16, r28
    5424:	0e 5f       	subi	r16, 0xFE	; 254
    5426:	1f 4f       	sbci	r17, 0xFF	; 255
    5428:	c8 01       	movw	r24, r16
    542a:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    542e:	8c 89       	ldd	r24, Y+20	; 0x14
    5430:	9d 89       	ldd	r25, Y+21	; 0x15
    5432:	89 2b       	or	r24, r25
    5434:	21 f0       	breq	.+8      	; 0x543e <xTaskIncrementTick+0x114>
    5436:	ce 01       	movw	r24, r28
    5438:	0c 96       	adiw	r24, 0x0c	; 12
    543a:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    543e:	8e 89       	ldd	r24, Y+22	; 0x16
    5440:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    5444:	98 17       	cp	r25, r24
    5446:	10 f4       	brcc	.+4      	; 0x544c <xTaskIncrementTick+0x122>
    5448:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    544c:	90 e0       	ldi	r25, 0x00	; 0
    544e:	9c 01       	movw	r18, r24
    5450:	22 0f       	add	r18, r18
    5452:	33 1f       	adc	r19, r19
    5454:	22 0f       	add	r18, r18
    5456:	33 1f       	adc	r19, r19
    5458:	22 0f       	add	r18, r18
    545a:	33 1f       	adc	r19, r19
    545c:	82 0f       	add	r24, r18
    545e:	93 1f       	adc	r25, r19
    5460:	b8 01       	movw	r22, r16
    5462:	89 57       	subi	r24, 0x79	; 121
    5464:	95 4e       	sbci	r25, 0xE5	; 229
    5466:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    546a:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    546e:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5472:	9e 89       	ldd	r25, Y+22	; 0x16
    5474:	86 89       	ldd	r24, Z+22	; 0x16
    5476:	98 17       	cp	r25, r24
    5478:	08 f4       	brcc	.+2      	; 0x547c <xTaskIncrementTick+0x152>
    547a:	b2 cf       	rjmp	.-156    	; 0x53e0 <xTaskIncrementTick+0xb6>
    547c:	dc 2c       	mov	r13, r12
    547e:	b0 cf       	rjmp	.-160    	; 0x53e0 <xTaskIncrementTick+0xb6>
    5480:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <uxPendedTicks>
    5484:	8f 5f       	subi	r24, 0xFF	; 255
    5486:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <uxPendedTicks>
    548a:	d1 2c       	mov	r13, r1
    548c:	80 91 58 1a 	lds	r24, 0x1A58	; 0x801a58 <xYieldPending>
    5490:	88 23       	and	r24, r24
    5492:	11 f0       	breq	.+4      	; 0x5498 <xTaskIncrementTick+0x16e>
    5494:	dd 24       	eor	r13, r13
    5496:	d3 94       	inc	r13
    5498:	8d 2d       	mov	r24, r13
    549a:	df 91       	pop	r29
    549c:	cf 91       	pop	r28
    549e:	1f 91       	pop	r17
    54a0:	0f 91       	pop	r16
    54a2:	ff 90       	pop	r15
    54a4:	ef 90       	pop	r14
    54a6:	df 90       	pop	r13
    54a8:	cf 90       	pop	r12
    54aa:	08 95       	ret

000054ac <vTaskSwitchContext>:
    54ac:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    54b0:	88 23       	and	r24, r24
    54b2:	21 f0       	breq	.+8      	; 0x54bc <vTaskSwitchContext+0x10>
    54b4:	81 e0       	ldi	r24, 0x01	; 1
    54b6:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <xYieldPending>
    54ba:	08 95       	ret
    54bc:	10 92 58 1a 	sts	0x1A58, r1	; 0x801a58 <xYieldPending>
    54c0:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    54c4:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    54c8:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    54cc:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    54d0:	2d 91       	ld	r18, X+
    54d2:	3c 91       	ld	r19, X
    54d4:	87 89       	ldd	r24, Z+23	; 0x17
    54d6:	90 8d       	ldd	r25, Z+24	; 0x18
    54d8:	82 17       	cp	r24, r18
    54da:	93 07       	cpc	r25, r19
    54dc:	60 f0       	brcs	.+24     	; 0x54f6 <vTaskSwitchContext+0x4a>
    54de:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    54e2:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    54e6:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    54ea:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    54ee:	67 5e       	subi	r22, 0xE7	; 231
    54f0:	7f 4f       	sbci	r23, 0xFF	; 255
    54f2:	0e 94 4c 15 	call	0x2a98	; 0x2a98 <vApplicationStackOverflowHook>
    54f6:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    54fa:	90 e0       	ldi	r25, 0x00	; 0
    54fc:	fc 01       	movw	r30, r24
    54fe:	ee 0f       	add	r30, r30
    5500:	ff 1f       	adc	r31, r31
    5502:	ee 0f       	add	r30, r30
    5504:	ff 1f       	adc	r31, r31
    5506:	ee 0f       	add	r30, r30
    5508:	ff 1f       	adc	r31, r31
    550a:	8e 0f       	add	r24, r30
    550c:	9f 1f       	adc	r25, r31
    550e:	fc 01       	movw	r30, r24
    5510:	e9 57       	subi	r30, 0x79	; 121
    5512:	f5 4e       	sbci	r31, 0xE5	; 229
    5514:	80 81       	ld	r24, Z
    5516:	81 11       	cpse	r24, r1
    5518:	17 c0       	rjmp	.+46     	; 0x5548 <vTaskSwitchContext+0x9c>
    551a:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    551e:	81 50       	subi	r24, 0x01	; 1
    5520:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    5524:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    5528:	90 e0       	ldi	r25, 0x00	; 0
    552a:	fc 01       	movw	r30, r24
    552c:	ee 0f       	add	r30, r30
    552e:	ff 1f       	adc	r31, r31
    5530:	ee 0f       	add	r30, r30
    5532:	ff 1f       	adc	r31, r31
    5534:	ee 0f       	add	r30, r30
    5536:	ff 1f       	adc	r31, r31
    5538:	8e 0f       	add	r24, r30
    553a:	9f 1f       	adc	r25, r31
    553c:	fc 01       	movw	r30, r24
    553e:	e9 57       	subi	r30, 0x79	; 121
    5540:	f5 4e       	sbci	r31, 0xE5	; 229
    5542:	80 81       	ld	r24, Z
    5544:	88 23       	and	r24, r24
    5546:	49 f3       	breq	.-46     	; 0x551a <vTaskSwitchContext+0x6e>
    5548:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    554c:	90 e0       	ldi	r25, 0x00	; 0
    554e:	9c 01       	movw	r18, r24
    5550:	22 0f       	add	r18, r18
    5552:	33 1f       	adc	r19, r19
    5554:	22 0f       	add	r18, r18
    5556:	33 1f       	adc	r19, r19
    5558:	22 0f       	add	r18, r18
    555a:	33 1f       	adc	r19, r19
    555c:	28 0f       	add	r18, r24
    555e:	39 1f       	adc	r19, r25
    5560:	d9 01       	movw	r26, r18
    5562:	a9 57       	subi	r26, 0x79	; 121
    5564:	b5 4e       	sbci	r27, 0xE5	; 229
    5566:	11 96       	adiw	r26, 0x01	; 1
    5568:	ed 91       	ld	r30, X+
    556a:	fc 91       	ld	r31, X
    556c:	12 97       	sbiw	r26, 0x02	; 2
    556e:	02 80       	ldd	r0, Z+2	; 0x02
    5570:	f3 81       	ldd	r31, Z+3	; 0x03
    5572:	e0 2d       	mov	r30, r0
    5574:	12 96       	adiw	r26, 0x02	; 2
    5576:	fc 93       	st	X, r31
    5578:	ee 93       	st	-X, r30
    557a:	11 97       	sbiw	r26, 0x01	; 1
    557c:	26 57       	subi	r18, 0x76	; 118
    557e:	35 4e       	sbci	r19, 0xE5	; 229
    5580:	e2 17       	cp	r30, r18
    5582:	f3 07       	cpc	r31, r19
    5584:	29 f4       	brne	.+10     	; 0x5590 <vTaskSwitchContext+0xe4>
    5586:	22 81       	ldd	r18, Z+2	; 0x02
    5588:	33 81       	ldd	r19, Z+3	; 0x03
    558a:	fd 01       	movw	r30, r26
    558c:	32 83       	std	Z+2, r19	; 0x02
    558e:	21 83       	std	Z+1, r18	; 0x01
    5590:	fc 01       	movw	r30, r24
    5592:	ee 0f       	add	r30, r30
    5594:	ff 1f       	adc	r31, r31
    5596:	ee 0f       	add	r30, r30
    5598:	ff 1f       	adc	r31, r31
    559a:	ee 0f       	add	r30, r30
    559c:	ff 1f       	adc	r31, r31
    559e:	8e 0f       	add	r24, r30
    55a0:	9f 1f       	adc	r25, r31
    55a2:	fc 01       	movw	r30, r24
    55a4:	e9 57       	subi	r30, 0x79	; 121
    55a6:	f5 4e       	sbci	r31, 0xE5	; 229
    55a8:	01 80       	ldd	r0, Z+1	; 0x01
    55aa:	f2 81       	ldd	r31, Z+2	; 0x02
    55ac:	e0 2d       	mov	r30, r0
    55ae:	86 81       	ldd	r24, Z+6	; 0x06
    55b0:	97 81       	ldd	r25, Z+7	; 0x07
    55b2:	90 93 be 1a 	sts	0x1ABE, r25	; 0x801abe <pxCurrentTCB+0x1>
    55b6:	80 93 bd 1a 	sts	0x1ABD, r24	; 0x801abd <pxCurrentTCB>
    55ba:	08 95       	ret

000055bc <vTaskPlaceOnEventList>:
    55bc:	cf 93       	push	r28
    55be:	df 93       	push	r29
    55c0:	eb 01       	movw	r28, r22
    55c2:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    55c6:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    55ca:	64 5f       	subi	r22, 0xF4	; 244
    55cc:	7f 4f       	sbci	r23, 0xFF	; 255
    55ce:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    55d2:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    55d6:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    55da:	02 96       	adiw	r24, 0x02	; 2
    55dc:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    55e0:	cf 3f       	cpi	r28, 0xFF	; 255
    55e2:	8f ef       	ldi	r24, 0xFF	; 255
    55e4:	d8 07       	cpc	r29, r24
    55e6:	59 f4       	brne	.+22     	; 0x55fe <vTaskPlaceOnEventList+0x42>
    55e8:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    55ec:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    55f0:	6e 5f       	subi	r22, 0xFE	; 254
    55f2:	7f 4f       	sbci	r23, 0xFF	; 255
    55f4:	8f e5       	ldi	r24, 0x5F	; 95
    55f6:	9a e1       	ldi	r25, 0x1A	; 26
    55f8:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    55fc:	37 c0       	rjmp	.+110    	; 0x566c <vTaskPlaceOnEventList+0xb0>
    55fe:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    5602:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5606:	c8 0f       	add	r28, r24
    5608:	d9 1f       	adc	r29, r25
    560a:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    560e:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5612:	d3 83       	std	Z+3, r29	; 0x03
    5614:	c2 83       	std	Z+2, r28	; 0x02
    5616:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    561a:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    561e:	c8 17       	cp	r28, r24
    5620:	d9 07       	cpc	r29, r25
    5622:	68 f4       	brcc	.+26     	; 0x563e <vTaskPlaceOnEventList+0x82>
    5624:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5628:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    562c:	80 91 71 1a 	lds	r24, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    5630:	90 91 72 1a 	lds	r25, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    5634:	6e 5f       	subi	r22, 0xFE	; 254
    5636:	7f 4f       	sbci	r23, 0xFF	; 255
    5638:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    563c:	17 c0       	rjmp	.+46     	; 0x566c <vTaskPlaceOnEventList+0xb0>
    563e:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5642:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5646:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    564a:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    564e:	6e 5f       	subi	r22, 0xFE	; 254
    5650:	7f 4f       	sbci	r23, 0xFF	; 255
    5652:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    5656:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    565a:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    565e:	c8 17       	cp	r28, r24
    5660:	d9 07       	cpc	r29, r25
    5662:	20 f4       	brcc	.+8      	; 0x566c <vTaskPlaceOnEventList+0xb0>
    5664:	d0 93 55 1a 	sts	0x1A55, r29	; 0x801a55 <xNextTaskUnblockTime+0x1>
    5668:	c0 93 54 1a 	sts	0x1A54, r28	; 0x801a54 <xNextTaskUnblockTime>
    566c:	df 91       	pop	r29
    566e:	cf 91       	pop	r28
    5670:	08 95       	ret

00005672 <xTaskRemoveFromEventList>:
    5672:	0f 93       	push	r16
    5674:	1f 93       	push	r17
    5676:	cf 93       	push	r28
    5678:	df 93       	push	r29
    567a:	dc 01       	movw	r26, r24
    567c:	15 96       	adiw	r26, 0x05	; 5
    567e:	ed 91       	ld	r30, X+
    5680:	fc 91       	ld	r31, X
    5682:	16 97       	sbiw	r26, 0x06	; 6
    5684:	c6 81       	ldd	r28, Z+6	; 0x06
    5686:	d7 81       	ldd	r29, Z+7	; 0x07
    5688:	8e 01       	movw	r16, r28
    568a:	04 5f       	subi	r16, 0xF4	; 244
    568c:	1f 4f       	sbci	r17, 0xFF	; 255
    568e:	c8 01       	movw	r24, r16
    5690:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    5694:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    5698:	81 11       	cpse	r24, r1
    569a:	1c c0       	rjmp	.+56     	; 0x56d4 <xTaskRemoveFromEventList+0x62>
    569c:	0a 50       	subi	r16, 0x0A	; 10
    569e:	11 09       	sbc	r17, r1
    56a0:	c8 01       	movw	r24, r16
    56a2:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    56a6:	8e 89       	ldd	r24, Y+22	; 0x16
    56a8:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    56ac:	98 17       	cp	r25, r24
    56ae:	10 f4       	brcc	.+4      	; 0x56b4 <xTaskRemoveFromEventList+0x42>
    56b0:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    56b4:	90 e0       	ldi	r25, 0x00	; 0
    56b6:	9c 01       	movw	r18, r24
    56b8:	22 0f       	add	r18, r18
    56ba:	33 1f       	adc	r19, r19
    56bc:	22 0f       	add	r18, r18
    56be:	33 1f       	adc	r19, r19
    56c0:	22 0f       	add	r18, r18
    56c2:	33 1f       	adc	r19, r19
    56c4:	82 0f       	add	r24, r18
    56c6:	93 1f       	adc	r25, r19
    56c8:	b8 01       	movw	r22, r16
    56ca:	89 57       	subi	r24, 0x79	; 121
    56cc:	95 4e       	sbci	r25, 0xE5	; 229
    56ce:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    56d2:	05 c0       	rjmp	.+10     	; 0x56de <xTaskRemoveFromEventList+0x6c>
    56d4:	b8 01       	movw	r22, r16
    56d6:	88 e6       	ldi	r24, 0x68	; 104
    56d8:	9a e1       	ldi	r25, 0x1A	; 26
    56da:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    56de:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    56e2:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    56e6:	9e 89       	ldd	r25, Y+22	; 0x16
    56e8:	86 89       	ldd	r24, Z+22	; 0x16
    56ea:	89 17       	cp	r24, r25
    56ec:	20 f4       	brcc	.+8      	; 0x56f6 <xTaskRemoveFromEventList+0x84>
    56ee:	81 e0       	ldi	r24, 0x01	; 1
    56f0:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <xYieldPending>
    56f4:	01 c0       	rjmp	.+2      	; 0x56f8 <xTaskRemoveFromEventList+0x86>
    56f6:	80 e0       	ldi	r24, 0x00	; 0
    56f8:	df 91       	pop	r29
    56fa:	cf 91       	pop	r28
    56fc:	1f 91       	pop	r17
    56fe:	0f 91       	pop	r16
    5700:	08 95       	ret

00005702 <vTaskSetTimeOutState>:
    5702:	20 91 57 1a 	lds	r18, 0x1A57	; 0x801a57 <xNumOfOverflows>
    5706:	fc 01       	movw	r30, r24
    5708:	20 83       	st	Z, r18
    570a:	20 91 5c 1a 	lds	r18, 0x1A5C	; 0x801a5c <xTickCount>
    570e:	30 91 5d 1a 	lds	r19, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5712:	32 83       	std	Z+2, r19	; 0x02
    5714:	21 83       	std	Z+1, r18	; 0x01
    5716:	08 95       	ret

00005718 <xTaskCheckForTimeOut>:
    5718:	fc 01       	movw	r30, r24
    571a:	0f b6       	in	r0, 0x3f	; 63
    571c:	f8 94       	cli
    571e:	0f 92       	push	r0
    5720:	20 91 5c 1a 	lds	r18, 0x1A5C	; 0x801a5c <xTickCount>
    5724:	30 91 5d 1a 	lds	r19, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5728:	db 01       	movw	r26, r22
    572a:	8d 91       	ld	r24, X+
    572c:	9c 91       	ld	r25, X
    572e:	8f 3f       	cpi	r24, 0xFF	; 255
    5730:	bf ef       	ldi	r27, 0xFF	; 255
    5732:	9b 07       	cpc	r25, r27
    5734:	21 f1       	breq	.+72     	; 0x577e <xTaskCheckForTimeOut+0x66>
    5736:	40 91 57 1a 	lds	r20, 0x1A57	; 0x801a57 <xNumOfOverflows>
    573a:	50 81       	ld	r21, Z
    573c:	54 17       	cp	r21, r20
    573e:	29 f0       	breq	.+10     	; 0x574a <xTaskCheckForTimeOut+0x32>
    5740:	41 81       	ldd	r20, Z+1	; 0x01
    5742:	52 81       	ldd	r21, Z+2	; 0x02
    5744:	24 17       	cp	r18, r20
    5746:	35 07       	cpc	r19, r21
    5748:	e0 f4       	brcc	.+56     	; 0x5782 <xTaskCheckForTimeOut+0x6a>
    574a:	41 81       	ldd	r20, Z+1	; 0x01
    574c:	52 81       	ldd	r21, Z+2	; 0x02
    574e:	d9 01       	movw	r26, r18
    5750:	a4 1b       	sub	r26, r20
    5752:	b5 0b       	sbc	r27, r21
    5754:	a8 17       	cp	r26, r24
    5756:	b9 07       	cpc	r27, r25
    5758:	b0 f4       	brcc	.+44     	; 0x5786 <xTaskCheckForTimeOut+0x6e>
    575a:	42 1b       	sub	r20, r18
    575c:	53 0b       	sbc	r21, r19
    575e:	84 0f       	add	r24, r20
    5760:	95 1f       	adc	r25, r21
    5762:	db 01       	movw	r26, r22
    5764:	8d 93       	st	X+, r24
    5766:	9c 93       	st	X, r25
    5768:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <xNumOfOverflows>
    576c:	80 83       	st	Z, r24
    576e:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    5772:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5776:	92 83       	std	Z+2, r25	; 0x02
    5778:	81 83       	std	Z+1, r24	; 0x01
    577a:	80 e0       	ldi	r24, 0x00	; 0
    577c:	05 c0       	rjmp	.+10     	; 0x5788 <xTaskCheckForTimeOut+0x70>
    577e:	80 e0       	ldi	r24, 0x00	; 0
    5780:	03 c0       	rjmp	.+6      	; 0x5788 <xTaskCheckForTimeOut+0x70>
    5782:	81 e0       	ldi	r24, 0x01	; 1
    5784:	01 c0       	rjmp	.+2      	; 0x5788 <xTaskCheckForTimeOut+0x70>
    5786:	81 e0       	ldi	r24, 0x01	; 1
    5788:	0f 90       	pop	r0
    578a:	0f be       	out	0x3f, r0	; 63
    578c:	08 95       	ret

0000578e <vTaskMissedYield>:
    578e:	81 e0       	ldi	r24, 0x01	; 1
    5790:	80 93 58 1a 	sts	0x1A58, r24	; 0x801a58 <xYieldPending>
    5794:	08 95       	ret

00005796 <xTaskGetCurrentTaskHandle>:
    5796:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    579a:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    579e:	08 95       	ret

000057a0 <vTaskPriorityInherit>:
    57a0:	0f 93       	push	r16
    57a2:	1f 93       	push	r17
    57a4:	cf 93       	push	r28
    57a6:	df 93       	push	r29
    57a8:	fc 01       	movw	r30, r24
    57aa:	89 2b       	or	r24, r25
    57ac:	09 f4       	brne	.+2      	; 0x57b0 <vTaskPriorityInherit+0x10>
    57ae:	55 c0       	rjmp	.+170    	; 0x585a <vTaskPriorityInherit+0xba>
    57b0:	26 89       	ldd	r18, Z+22	; 0x16
    57b2:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    57b6:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    57ba:	56 96       	adiw	r26, 0x16	; 22
    57bc:	8c 91       	ld	r24, X
    57be:	28 17       	cp	r18, r24
    57c0:	08 f0       	brcs	.+2      	; 0x57c4 <vTaskPriorityInherit+0x24>
    57c2:	4b c0       	rjmp	.+150    	; 0x585a <vTaskPriorityInherit+0xba>
    57c4:	84 85       	ldd	r24, Z+12	; 0x0c
    57c6:	95 85       	ldd	r25, Z+13	; 0x0d
    57c8:	99 23       	and	r25, r25
    57ca:	64 f0       	brlt	.+24     	; 0x57e4 <vTaskPriorityInherit+0x44>
    57cc:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    57d0:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    57d4:	56 96       	adiw	r26, 0x16	; 22
    57d6:	3c 91       	ld	r19, X
    57d8:	86 e0       	ldi	r24, 0x06	; 6
    57da:	90 e0       	ldi	r25, 0x00	; 0
    57dc:	83 1b       	sub	r24, r19
    57de:	91 09       	sbc	r25, r1
    57e0:	95 87       	std	Z+13, r25	; 0x0d
    57e2:	84 87       	std	Z+12, r24	; 0x0c
    57e4:	30 e0       	ldi	r19, 0x00	; 0
    57e6:	c9 01       	movw	r24, r18
    57e8:	88 0f       	add	r24, r24
    57ea:	99 1f       	adc	r25, r25
    57ec:	88 0f       	add	r24, r24
    57ee:	99 1f       	adc	r25, r25
    57f0:	88 0f       	add	r24, r24
    57f2:	99 1f       	adc	r25, r25
    57f4:	28 0f       	add	r18, r24
    57f6:	39 1f       	adc	r19, r25
    57f8:	29 57       	subi	r18, 0x79	; 121
    57fa:	35 4e       	sbci	r19, 0xE5	; 229
    57fc:	82 85       	ldd	r24, Z+10	; 0x0a
    57fe:	93 85       	ldd	r25, Z+11	; 0x0b
    5800:	82 17       	cp	r24, r18
    5802:	93 07       	cpc	r25, r19
    5804:	19 f5       	brne	.+70     	; 0x584c <vTaskPriorityInherit+0xac>
    5806:	8f 01       	movw	r16, r30
    5808:	ef 01       	movw	r28, r30
    580a:	22 96       	adiw	r28, 0x02	; 2
    580c:	ce 01       	movw	r24, r28
    580e:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    5812:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5816:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    581a:	86 89       	ldd	r24, Z+22	; 0x16
    581c:	f8 01       	movw	r30, r16
    581e:	86 8b       	std	Z+22, r24	; 0x16
    5820:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    5824:	98 17       	cp	r25, r24
    5826:	10 f4       	brcc	.+4      	; 0x582c <vTaskPriorityInherit+0x8c>
    5828:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    582c:	90 e0       	ldi	r25, 0x00	; 0
    582e:	9c 01       	movw	r18, r24
    5830:	22 0f       	add	r18, r18
    5832:	33 1f       	adc	r19, r19
    5834:	22 0f       	add	r18, r18
    5836:	33 1f       	adc	r19, r19
    5838:	22 0f       	add	r18, r18
    583a:	33 1f       	adc	r19, r19
    583c:	82 0f       	add	r24, r18
    583e:	93 1f       	adc	r25, r19
    5840:	be 01       	movw	r22, r28
    5842:	89 57       	subi	r24, 0x79	; 121
    5844:	95 4e       	sbci	r25, 0xE5	; 229
    5846:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    584a:	07 c0       	rjmp	.+14     	; 0x585a <vTaskPriorityInherit+0xba>
    584c:	a0 91 bd 1a 	lds	r26, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5850:	b0 91 be 1a 	lds	r27, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5854:	56 96       	adiw	r26, 0x16	; 22
    5856:	8c 91       	ld	r24, X
    5858:	86 8b       	std	Z+22, r24	; 0x16
    585a:	df 91       	pop	r29
    585c:	cf 91       	pop	r28
    585e:	1f 91       	pop	r17
    5860:	0f 91       	pop	r16
    5862:	08 95       	ret

00005864 <xTaskPriorityDisinherit>:
    5864:	0f 93       	push	r16
    5866:	1f 93       	push	r17
    5868:	cf 93       	push	r28
    586a:	df 93       	push	r29
    586c:	fc 01       	movw	r30, r24
    586e:	89 2b       	or	r24, r25
    5870:	79 f1       	breq	.+94     	; 0x58d0 <xTaskPriorityDisinherit+0x6c>
    5872:	82 a1       	ldd	r24, Z+34	; 0x22
    5874:	81 50       	subi	r24, 0x01	; 1
    5876:	82 a3       	std	Z+34, r24	; 0x22
    5878:	26 89       	ldd	r18, Z+22	; 0x16
    587a:	91 a1       	ldd	r25, Z+33	; 0x21
    587c:	29 17       	cp	r18, r25
    587e:	51 f1       	breq	.+84     	; 0x58d4 <xTaskPriorityDisinherit+0x70>
    5880:	81 11       	cpse	r24, r1
    5882:	2a c0       	rjmp	.+84     	; 0x58d8 <xTaskPriorityDisinherit+0x74>
    5884:	ef 01       	movw	r28, r30
    5886:	8f 01       	movw	r16, r30
    5888:	0e 5f       	subi	r16, 0xFE	; 254
    588a:	1f 4f       	sbci	r17, 0xFF	; 255
    588c:	c8 01       	movw	r24, r16
    588e:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    5892:	89 a1       	ldd	r24, Y+33	; 0x21
    5894:	8e 8b       	std	Y+22, r24	; 0x16
    5896:	26 e0       	ldi	r18, 0x06	; 6
    5898:	30 e0       	ldi	r19, 0x00	; 0
    589a:	28 1b       	sub	r18, r24
    589c:	31 09       	sbc	r19, r1
    589e:	3d 87       	std	Y+13, r19	; 0x0d
    58a0:	2c 87       	std	Y+12, r18	; 0x0c
    58a2:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    58a6:	98 17       	cp	r25, r24
    58a8:	10 f4       	brcc	.+4      	; 0x58ae <xTaskPriorityDisinherit+0x4a>
    58aa:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    58ae:	90 e0       	ldi	r25, 0x00	; 0
    58b0:	9c 01       	movw	r18, r24
    58b2:	22 0f       	add	r18, r18
    58b4:	33 1f       	adc	r19, r19
    58b6:	22 0f       	add	r18, r18
    58b8:	33 1f       	adc	r19, r19
    58ba:	22 0f       	add	r18, r18
    58bc:	33 1f       	adc	r19, r19
    58be:	82 0f       	add	r24, r18
    58c0:	93 1f       	adc	r25, r19
    58c2:	b8 01       	movw	r22, r16
    58c4:	89 57       	subi	r24, 0x79	; 121
    58c6:	95 4e       	sbci	r25, 0xE5	; 229
    58c8:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    58cc:	81 e0       	ldi	r24, 0x01	; 1
    58ce:	05 c0       	rjmp	.+10     	; 0x58da <xTaskPriorityDisinherit+0x76>
    58d0:	80 e0       	ldi	r24, 0x00	; 0
    58d2:	03 c0       	rjmp	.+6      	; 0x58da <xTaskPriorityDisinherit+0x76>
    58d4:	80 e0       	ldi	r24, 0x00	; 0
    58d6:	01 c0       	rjmp	.+2      	; 0x58da <xTaskPriorityDisinherit+0x76>
    58d8:	80 e0       	ldi	r24, 0x00	; 0
    58da:	df 91       	pop	r29
    58dc:	cf 91       	pop	r28
    58de:	1f 91       	pop	r17
    58e0:	0f 91       	pop	r16
    58e2:	08 95       	ret

000058e4 <pvTaskIncrementMutexHeldCount>:
    58e4:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    58e8:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    58ec:	89 2b       	or	r24, r25
    58ee:	39 f0       	breq	.+14     	; 0x58fe <pvTaskIncrementMutexHeldCount+0x1a>
    58f0:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    58f4:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    58f8:	82 a1       	ldd	r24, Z+34	; 0x22
    58fa:	8f 5f       	subi	r24, 0xFF	; 255
    58fc:	82 a3       	std	Z+34, r24	; 0x22
    58fe:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5902:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5906:	08 95       	ret

00005908 <ulTaskNotifyTake>:
    5908:	0f 93       	push	r16
    590a:	1f 93       	push	r17
    590c:	cf 93       	push	r28
    590e:	df 93       	push	r29
    5910:	18 2f       	mov	r17, r24
    5912:	eb 01       	movw	r28, r22
    5914:	0f b6       	in	r0, 0x3f	; 63
    5916:	f8 94       	cli
    5918:	0f 92       	push	r0
    591a:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    591e:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5922:	83 a1       	ldd	r24, Z+35	; 0x23
    5924:	94 a1       	ldd	r25, Z+36	; 0x24
    5926:	a5 a1       	ldd	r26, Z+37	; 0x25
    5928:	b6 a1       	ldd	r27, Z+38	; 0x26
    592a:	89 2b       	or	r24, r25
    592c:	8a 2b       	or	r24, r26
    592e:	8b 2b       	or	r24, r27
    5930:	09 f0       	breq	.+2      	; 0x5934 <ulTaskNotifyTake+0x2c>
    5932:	58 c0       	rjmp	.+176    	; 0x59e4 <ulTaskNotifyTake+0xdc>
    5934:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5938:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    593c:	81 e0       	ldi	r24, 0x01	; 1
    593e:	87 a3       	std	Z+39, r24	; 0x27
    5940:	20 97       	sbiw	r28, 0x00	; 0
    5942:	09 f4       	brne	.+2      	; 0x5946 <ulTaskNotifyTake+0x3e>
    5944:	4f c0       	rjmp	.+158    	; 0x59e4 <ulTaskNotifyTake+0xdc>
    5946:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    594a:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    594e:	02 96       	adiw	r24, 0x02	; 2
    5950:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    5954:	cf 3f       	cpi	r28, 0xFF	; 255
    5956:	8f ef       	ldi	r24, 0xFF	; 255
    5958:	d8 07       	cpc	r29, r24
    595a:	59 f4       	brne	.+22     	; 0x5972 <ulTaskNotifyTake+0x6a>
    595c:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5960:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5964:	6e 5f       	subi	r22, 0xFE	; 254
    5966:	7f 4f       	sbci	r23, 0xFF	; 255
    5968:	8f e5       	ldi	r24, 0x5F	; 95
    596a:	9a e1       	ldi	r25, 0x1A	; 26
    596c:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    5970:	37 c0       	rjmp	.+110    	; 0x59e0 <ulTaskNotifyTake+0xd8>
    5972:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    5976:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    597a:	c8 0f       	add	r28, r24
    597c:	d9 1f       	adc	r29, r25
    597e:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5982:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5986:	d3 83       	std	Z+3, r29	; 0x03
    5988:	c2 83       	std	Z+2, r28	; 0x02
    598a:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    598e:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5992:	c8 17       	cp	r28, r24
    5994:	d9 07       	cpc	r29, r25
    5996:	68 f4       	brcc	.+26     	; 0x59b2 <ulTaskNotifyTake+0xaa>
    5998:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    599c:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    59a0:	80 91 71 1a 	lds	r24, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    59a4:	90 91 72 1a 	lds	r25, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    59a8:	6e 5f       	subi	r22, 0xFE	; 254
    59aa:	7f 4f       	sbci	r23, 0xFF	; 255
    59ac:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    59b0:	17 c0       	rjmp	.+46     	; 0x59e0 <ulTaskNotifyTake+0xd8>
    59b2:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    59b6:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    59ba:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    59be:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    59c2:	6e 5f       	subi	r22, 0xFE	; 254
    59c4:	7f 4f       	sbci	r23, 0xFF	; 255
    59c6:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    59ca:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    59ce:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    59d2:	c8 17       	cp	r28, r24
    59d4:	d9 07       	cpc	r29, r25
    59d6:	20 f4       	brcc	.+8      	; 0x59e0 <ulTaskNotifyTake+0xd8>
    59d8:	d0 93 55 1a 	sts	0x1A55, r29	; 0x801a55 <xNextTaskUnblockTime+0x1>
    59dc:	c0 93 54 1a 	sts	0x1A54, r28	; 0x801a54 <xNextTaskUnblockTime>
    59e0:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    59e4:	0f 90       	pop	r0
    59e6:	0f be       	out	0x3f, r0	; 63
    59e8:	0f b6       	in	r0, 0x3f	; 63
    59ea:	f8 94       	cli
    59ec:	0f 92       	push	r0
    59ee:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    59f2:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    59f6:	63 a1       	ldd	r22, Z+35	; 0x23
    59f8:	74 a1       	ldd	r23, Z+36	; 0x24
    59fa:	85 a1       	ldd	r24, Z+37	; 0x25
    59fc:	96 a1       	ldd	r25, Z+38	; 0x26
    59fe:	61 15       	cp	r22, r1
    5a00:	71 05       	cpc	r23, r1
    5a02:	81 05       	cpc	r24, r1
    5a04:	91 05       	cpc	r25, r1
    5a06:	d9 f0       	breq	.+54     	; 0x5a3e <ulTaskNotifyTake+0x136>
    5a08:	11 23       	and	r17, r17
    5a0a:	49 f0       	breq	.+18     	; 0x5a1e <ulTaskNotifyTake+0x116>
    5a0c:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5a10:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5a14:	13 a2       	std	Z+35, r1	; 0x23
    5a16:	14 a2       	std	Z+36, r1	; 0x24
    5a18:	15 a2       	std	Z+37, r1	; 0x25
    5a1a:	16 a2       	std	Z+38, r1	; 0x26
    5a1c:	10 c0       	rjmp	.+32     	; 0x5a3e <ulTaskNotifyTake+0x136>
    5a1e:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5a22:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5a26:	03 a1       	ldd	r16, Z+35	; 0x23
    5a28:	14 a1       	ldd	r17, Z+36	; 0x24
    5a2a:	25 a1       	ldd	r18, Z+37	; 0x25
    5a2c:	36 a1       	ldd	r19, Z+38	; 0x26
    5a2e:	01 50       	subi	r16, 0x01	; 1
    5a30:	11 09       	sbc	r17, r1
    5a32:	21 09       	sbc	r18, r1
    5a34:	31 09       	sbc	r19, r1
    5a36:	03 a3       	std	Z+35, r16	; 0x23
    5a38:	14 a3       	std	Z+36, r17	; 0x24
    5a3a:	25 a3       	std	Z+37, r18	; 0x25
    5a3c:	36 a3       	std	Z+38, r19	; 0x26
    5a3e:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5a42:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5a46:	17 a2       	std	Z+39, r1	; 0x27
    5a48:	0f 90       	pop	r0
    5a4a:	0f be       	out	0x3f, r0	; 63
    5a4c:	df 91       	pop	r29
    5a4e:	cf 91       	pop	r28
    5a50:	1f 91       	pop	r17
    5a52:	0f 91       	pop	r16
    5a54:	08 95       	ret

00005a56 <xTaskNotifyWait>:
    5a56:	4f 92       	push	r4
    5a58:	5f 92       	push	r5
    5a5a:	6f 92       	push	r6
    5a5c:	7f 92       	push	r7
    5a5e:	8f 92       	push	r8
    5a60:	9f 92       	push	r9
    5a62:	af 92       	push	r10
    5a64:	bf 92       	push	r11
    5a66:	ef 92       	push	r14
    5a68:	ff 92       	push	r15
    5a6a:	0f 93       	push	r16
    5a6c:	1f 93       	push	r17
    5a6e:	49 01       	movw	r8, r18
    5a70:	5a 01       	movw	r10, r20
    5a72:	0f b6       	in	r0, 0x3f	; 63
    5a74:	f8 94       	cli
    5a76:	0f 92       	push	r0
    5a78:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5a7c:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5a80:	27 a1       	ldd	r18, Z+39	; 0x27
    5a82:	22 30       	cpi	r18, 0x02	; 2
    5a84:	09 f4       	brne	.+2      	; 0x5a88 <xTaskNotifyWait+0x32>
    5a86:	6f c0       	rjmp	.+222    	; 0x5b66 <xTaskNotifyWait+0x110>
    5a88:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5a8c:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5a90:	43 a0       	ldd	r4, Z+35	; 0x23
    5a92:	54 a0       	ldd	r5, Z+36	; 0x24
    5a94:	65 a0       	ldd	r6, Z+37	; 0x25
    5a96:	76 a0       	ldd	r7, Z+38	; 0x26
    5a98:	dc 01       	movw	r26, r24
    5a9a:	cb 01       	movw	r24, r22
    5a9c:	80 95       	com	r24
    5a9e:	90 95       	com	r25
    5aa0:	a0 95       	com	r26
    5aa2:	b0 95       	com	r27
    5aa4:	84 21       	and	r24, r4
    5aa6:	95 21       	and	r25, r5
    5aa8:	a6 21       	and	r26, r6
    5aaa:	b7 21       	and	r27, r7
    5aac:	83 a3       	std	Z+35, r24	; 0x23
    5aae:	94 a3       	std	Z+36, r25	; 0x24
    5ab0:	a5 a3       	std	Z+37, r26	; 0x25
    5ab2:	b6 a3       	std	Z+38, r27	; 0x26
    5ab4:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5ab8:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5abc:	81 e0       	ldi	r24, 0x01	; 1
    5abe:	87 a3       	std	Z+39, r24	; 0x27
    5ac0:	e1 14       	cp	r14, r1
    5ac2:	f1 04       	cpc	r15, r1
    5ac4:	09 f4       	brne	.+2      	; 0x5ac8 <xTaskNotifyWait+0x72>
    5ac6:	4f c0       	rjmp	.+158    	; 0x5b66 <xTaskNotifyWait+0x110>
    5ac8:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5acc:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5ad0:	02 96       	adiw	r24, 0x02	; 2
    5ad2:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    5ad6:	8f ef       	ldi	r24, 0xFF	; 255
    5ad8:	e8 16       	cp	r14, r24
    5ada:	f8 06       	cpc	r15, r24
    5adc:	59 f4       	brne	.+22     	; 0x5af4 <xTaskNotifyWait+0x9e>
    5ade:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5ae2:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5ae6:	6e 5f       	subi	r22, 0xFE	; 254
    5ae8:	7f 4f       	sbci	r23, 0xFF	; 255
    5aea:	8f e5       	ldi	r24, 0x5F	; 95
    5aec:	9a e1       	ldi	r25, 0x1A	; 26
    5aee:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    5af2:	37 c0       	rjmp	.+110    	; 0x5b62 <xTaskNotifyWait+0x10c>
    5af4:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    5af8:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5afc:	e8 0e       	add	r14, r24
    5afe:	f9 1e       	adc	r15, r25
    5b00:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5b04:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5b08:	f3 82       	std	Z+3, r15	; 0x03
    5b0a:	e2 82       	std	Z+2, r14	; 0x02
    5b0c:	80 91 5c 1a 	lds	r24, 0x1A5C	; 0x801a5c <xTickCount>
    5b10:	90 91 5d 1a 	lds	r25, 0x1A5D	; 0x801a5d <xTickCount+0x1>
    5b14:	e8 16       	cp	r14, r24
    5b16:	f9 06       	cpc	r15, r25
    5b18:	68 f4       	brcc	.+26     	; 0x5b34 <xTaskNotifyWait+0xde>
    5b1a:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5b1e:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5b22:	80 91 71 1a 	lds	r24, 0x1A71	; 0x801a71 <pxOverflowDelayedTaskList>
    5b26:	90 91 72 1a 	lds	r25, 0x1A72	; 0x801a72 <pxOverflowDelayedTaskList+0x1>
    5b2a:	6e 5f       	subi	r22, 0xFE	; 254
    5b2c:	7f 4f       	sbci	r23, 0xFF	; 255
    5b2e:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    5b32:	17 c0       	rjmp	.+46     	; 0x5b62 <xTaskNotifyWait+0x10c>
    5b34:	60 91 bd 1a 	lds	r22, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5b38:	70 91 be 1a 	lds	r23, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5b3c:	80 91 73 1a 	lds	r24, 0x1A73	; 0x801a73 <pxDelayedTaskList>
    5b40:	90 91 74 1a 	lds	r25, 0x1A74	; 0x801a74 <pxDelayedTaskList+0x1>
    5b44:	6e 5f       	subi	r22, 0xFE	; 254
    5b46:	7f 4f       	sbci	r23, 0xFF	; 255
    5b48:	0e 94 79 0c 	call	0x18f2	; 0x18f2 <vListInsert>
    5b4c:	80 91 54 1a 	lds	r24, 0x1A54	; 0x801a54 <xNextTaskUnblockTime>
    5b50:	90 91 55 1a 	lds	r25, 0x1A55	; 0x801a55 <xNextTaskUnblockTime+0x1>
    5b54:	e8 16       	cp	r14, r24
    5b56:	f9 06       	cpc	r15, r25
    5b58:	20 f4       	brcc	.+8      	; 0x5b62 <xTaskNotifyWait+0x10c>
    5b5a:	f0 92 55 1a 	sts	0x1A55, r15	; 0x801a55 <xNextTaskUnblockTime+0x1>
    5b5e:	e0 92 54 1a 	sts	0x1A54, r14	; 0x801a54 <xNextTaskUnblockTime>
    5b62:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    5b66:	0f 90       	pop	r0
    5b68:	0f be       	out	0x3f, r0	; 63
    5b6a:	0f b6       	in	r0, 0x3f	; 63
    5b6c:	f8 94       	cli
    5b6e:	0f 92       	push	r0
    5b70:	01 15       	cp	r16, r1
    5b72:	11 05       	cpc	r17, r1
    5b74:	69 f0       	breq	.+26     	; 0x5b90 <xTaskNotifyWait+0x13a>
    5b76:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5b7a:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5b7e:	83 a1       	ldd	r24, Z+35	; 0x23
    5b80:	94 a1       	ldd	r25, Z+36	; 0x24
    5b82:	a5 a1       	ldd	r26, Z+37	; 0x25
    5b84:	b6 a1       	ldd	r27, Z+38	; 0x26
    5b86:	f8 01       	movw	r30, r16
    5b88:	80 83       	st	Z, r24
    5b8a:	91 83       	std	Z+1, r25	; 0x01
    5b8c:	a2 83       	std	Z+2, r26	; 0x02
    5b8e:	b3 83       	std	Z+3, r27	; 0x03
    5b90:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5b94:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5b98:	87 a1       	ldd	r24, Z+39	; 0x27
    5b9a:	81 30       	cpi	r24, 0x01	; 1
    5b9c:	b1 f0       	breq	.+44     	; 0x5bca <xTaskNotifyWait+0x174>
    5b9e:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5ba2:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5ba6:	83 a1       	ldd	r24, Z+35	; 0x23
    5ba8:	94 a1       	ldd	r25, Z+36	; 0x24
    5baa:	a5 a1       	ldd	r26, Z+37	; 0x25
    5bac:	b6 a1       	ldd	r27, Z+38	; 0x26
    5bae:	80 94       	com	r8
    5bb0:	90 94       	com	r9
    5bb2:	a0 94       	com	r10
    5bb4:	b0 94       	com	r11
    5bb6:	88 22       	and	r8, r24
    5bb8:	99 22       	and	r9, r25
    5bba:	aa 22       	and	r10, r26
    5bbc:	bb 22       	and	r11, r27
    5bbe:	83 a2       	std	Z+35, r8	; 0x23
    5bc0:	94 a2       	std	Z+36, r9	; 0x24
    5bc2:	a5 a2       	std	Z+37, r10	; 0x25
    5bc4:	b6 a2       	std	Z+38, r11	; 0x26
    5bc6:	81 e0       	ldi	r24, 0x01	; 1
    5bc8:	01 c0       	rjmp	.+2      	; 0x5bcc <xTaskNotifyWait+0x176>
    5bca:	80 e0       	ldi	r24, 0x00	; 0
    5bcc:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5bd0:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5bd4:	17 a2       	std	Z+39, r1	; 0x27
    5bd6:	0f 90       	pop	r0
    5bd8:	0f be       	out	0x3f, r0	; 63
    5bda:	1f 91       	pop	r17
    5bdc:	0f 91       	pop	r16
    5bde:	ff 90       	pop	r15
    5be0:	ef 90       	pop	r14
    5be2:	bf 90       	pop	r11
    5be4:	af 90       	pop	r10
    5be6:	9f 90       	pop	r9
    5be8:	8f 90       	pop	r8
    5bea:	7f 90       	pop	r7
    5bec:	6f 90       	pop	r6
    5bee:	5f 90       	pop	r5
    5bf0:	4f 90       	pop	r4
    5bf2:	08 95       	ret

00005bf4 <xTaskGenericNotify>:
    5bf4:	0f 93       	push	r16
    5bf6:	1f 93       	push	r17
    5bf8:	cf 93       	push	r28
    5bfa:	df 93       	push	r29
    5bfc:	fc 01       	movw	r30, r24
    5bfe:	0f b6       	in	r0, 0x3f	; 63
    5c00:	f8 94       	cli
    5c02:	0f 92       	push	r0
    5c04:	01 15       	cp	r16, r1
    5c06:	11 05       	cpc	r17, r1
    5c08:	49 f0       	breq	.+18     	; 0x5c1c <xTaskGenericNotify+0x28>
    5c0a:	83 a1       	ldd	r24, Z+35	; 0x23
    5c0c:	94 a1       	ldd	r25, Z+36	; 0x24
    5c0e:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c10:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c12:	e8 01       	movw	r28, r16
    5c14:	88 83       	st	Y, r24
    5c16:	99 83       	std	Y+1, r25	; 0x01
    5c18:	aa 83       	std	Y+2, r26	; 0x02
    5c1a:	bb 83       	std	Y+3, r27	; 0x03
    5c1c:	87 a1       	ldd	r24, Z+39	; 0x27
    5c1e:	92 e0       	ldi	r25, 0x02	; 2
    5c20:	97 a3       	std	Z+39, r25	; 0x27
    5c22:	22 30       	cpi	r18, 0x02	; 2
    5c24:	b1 f0       	breq	.+44     	; 0x5c52 <xTaskGenericNotify+0x5e>
    5c26:	18 f4       	brcc	.+6      	; 0x5c2e <xTaskGenericNotify+0x3a>
    5c28:	21 30       	cpi	r18, 0x01	; 1
    5c2a:	31 f0       	breq	.+12     	; 0x5c38 <xTaskGenericNotify+0x44>
    5c2c:	2a c0       	rjmp	.+84     	; 0x5c82 <xTaskGenericNotify+0x8e>
    5c2e:	23 30       	cpi	r18, 0x03	; 3
    5c30:	e9 f0       	breq	.+58     	; 0x5c6c <xTaskGenericNotify+0x78>
    5c32:	24 30       	cpi	r18, 0x04	; 4
    5c34:	01 f1       	breq	.+64     	; 0x5c76 <xTaskGenericNotify+0x82>
    5c36:	25 c0       	rjmp	.+74     	; 0x5c82 <xTaskGenericNotify+0x8e>
    5c38:	03 a1       	ldd	r16, Z+35	; 0x23
    5c3a:	14 a1       	ldd	r17, Z+36	; 0x24
    5c3c:	25 a1       	ldd	r18, Z+37	; 0x25
    5c3e:	36 a1       	ldd	r19, Z+38	; 0x26
    5c40:	40 2b       	or	r20, r16
    5c42:	51 2b       	or	r21, r17
    5c44:	62 2b       	or	r22, r18
    5c46:	73 2b       	or	r23, r19
    5c48:	43 a3       	std	Z+35, r20	; 0x23
    5c4a:	54 a3       	std	Z+36, r21	; 0x24
    5c4c:	65 a3       	std	Z+37, r22	; 0x25
    5c4e:	76 a3       	std	Z+38, r23	; 0x26
    5c50:	18 c0       	rjmp	.+48     	; 0x5c82 <xTaskGenericNotify+0x8e>
    5c52:	43 a1       	ldd	r20, Z+35	; 0x23
    5c54:	54 a1       	ldd	r21, Z+36	; 0x24
    5c56:	65 a1       	ldd	r22, Z+37	; 0x25
    5c58:	76 a1       	ldd	r23, Z+38	; 0x26
    5c5a:	4f 5f       	subi	r20, 0xFF	; 255
    5c5c:	5f 4f       	sbci	r21, 0xFF	; 255
    5c5e:	6f 4f       	sbci	r22, 0xFF	; 255
    5c60:	7f 4f       	sbci	r23, 0xFF	; 255
    5c62:	43 a3       	std	Z+35, r20	; 0x23
    5c64:	54 a3       	std	Z+36, r21	; 0x24
    5c66:	65 a3       	std	Z+37, r22	; 0x25
    5c68:	76 a3       	std	Z+38, r23	; 0x26
    5c6a:	0b c0       	rjmp	.+22     	; 0x5c82 <xTaskGenericNotify+0x8e>
    5c6c:	43 a3       	std	Z+35, r20	; 0x23
    5c6e:	54 a3       	std	Z+36, r21	; 0x24
    5c70:	65 a3       	std	Z+37, r22	; 0x25
    5c72:	76 a3       	std	Z+38, r23	; 0x26
    5c74:	06 c0       	rjmp	.+12     	; 0x5c82 <xTaskGenericNotify+0x8e>
    5c76:	82 30       	cpi	r24, 0x02	; 2
    5c78:	79 f1       	breq	.+94     	; 0x5cd8 <xTaskGenericNotify+0xe4>
    5c7a:	43 a3       	std	Z+35, r20	; 0x23
    5c7c:	54 a3       	std	Z+36, r21	; 0x24
    5c7e:	65 a3       	std	Z+37, r22	; 0x25
    5c80:	76 a3       	std	Z+38, r23	; 0x26
    5c82:	81 30       	cpi	r24, 0x01	; 1
    5c84:	59 f5       	brne	.+86     	; 0x5cdc <xTaskGenericNotify+0xe8>
    5c86:	ef 01       	movw	r28, r30
    5c88:	8f 01       	movw	r16, r30
    5c8a:	0e 5f       	subi	r16, 0xFE	; 254
    5c8c:	1f 4f       	sbci	r17, 0xFF	; 255
    5c8e:	c8 01       	movw	r24, r16
    5c90:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    5c94:	8e 89       	ldd	r24, Y+22	; 0x16
    5c96:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    5c9a:	98 17       	cp	r25, r24
    5c9c:	10 f4       	brcc	.+4      	; 0x5ca2 <xTaskGenericNotify+0xae>
    5c9e:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    5ca2:	90 e0       	ldi	r25, 0x00	; 0
    5ca4:	9c 01       	movw	r18, r24
    5ca6:	22 0f       	add	r18, r18
    5ca8:	33 1f       	adc	r19, r19
    5caa:	22 0f       	add	r18, r18
    5cac:	33 1f       	adc	r19, r19
    5cae:	22 0f       	add	r18, r18
    5cb0:	33 1f       	adc	r19, r19
    5cb2:	82 0f       	add	r24, r18
    5cb4:	93 1f       	adc	r25, r19
    5cb6:	b8 01       	movw	r22, r16
    5cb8:	89 57       	subi	r24, 0x79	; 121
    5cba:	95 4e       	sbci	r25, 0xE5	; 229
    5cbc:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    5cc0:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5cc4:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5cc8:	9e 89       	ldd	r25, Y+22	; 0x16
    5cca:	86 89       	ldd	r24, Z+22	; 0x16
    5ccc:	89 17       	cp	r24, r25
    5cce:	40 f4       	brcc	.+16     	; 0x5ce0 <xTaskGenericNotify+0xec>
    5cd0:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vPortYield>
    5cd4:	81 e0       	ldi	r24, 0x01	; 1
    5cd6:	05 c0       	rjmp	.+10     	; 0x5ce2 <xTaskGenericNotify+0xee>
    5cd8:	80 e0       	ldi	r24, 0x00	; 0
    5cda:	03 c0       	rjmp	.+6      	; 0x5ce2 <xTaskGenericNotify+0xee>
    5cdc:	81 e0       	ldi	r24, 0x01	; 1
    5cde:	01 c0       	rjmp	.+2      	; 0x5ce2 <xTaskGenericNotify+0xee>
    5ce0:	81 e0       	ldi	r24, 0x01	; 1
    5ce2:	0f 90       	pop	r0
    5ce4:	0f be       	out	0x3f, r0	; 63
    5ce6:	df 91       	pop	r29
    5ce8:	cf 91       	pop	r28
    5cea:	1f 91       	pop	r17
    5cec:	0f 91       	pop	r16
    5cee:	08 95       	ret

00005cf0 <xTaskGenericNotifyFromISR>:
    5cf0:	ef 92       	push	r14
    5cf2:	ff 92       	push	r15
    5cf4:	0f 93       	push	r16
    5cf6:	1f 93       	push	r17
    5cf8:	cf 93       	push	r28
    5cfa:	df 93       	push	r29
    5cfc:	fc 01       	movw	r30, r24
    5cfe:	01 15       	cp	r16, r1
    5d00:	11 05       	cpc	r17, r1
    5d02:	49 f0       	breq	.+18     	; 0x5d16 <xTaskGenericNotifyFromISR+0x26>
    5d04:	83 a1       	ldd	r24, Z+35	; 0x23
    5d06:	94 a1       	ldd	r25, Z+36	; 0x24
    5d08:	a5 a1       	ldd	r26, Z+37	; 0x25
    5d0a:	b6 a1       	ldd	r27, Z+38	; 0x26
    5d0c:	e8 01       	movw	r28, r16
    5d0e:	88 83       	st	Y, r24
    5d10:	99 83       	std	Y+1, r25	; 0x01
    5d12:	aa 83       	std	Y+2, r26	; 0x02
    5d14:	bb 83       	std	Y+3, r27	; 0x03
    5d16:	87 a1       	ldd	r24, Z+39	; 0x27
    5d18:	92 e0       	ldi	r25, 0x02	; 2
    5d1a:	97 a3       	std	Z+39, r25	; 0x27
    5d1c:	22 30       	cpi	r18, 0x02	; 2
    5d1e:	b1 f0       	breq	.+44     	; 0x5d4c <xTaskGenericNotifyFromISR+0x5c>
    5d20:	18 f4       	brcc	.+6      	; 0x5d28 <xTaskGenericNotifyFromISR+0x38>
    5d22:	21 30       	cpi	r18, 0x01	; 1
    5d24:	31 f0       	breq	.+12     	; 0x5d32 <xTaskGenericNotifyFromISR+0x42>
    5d26:	2a c0       	rjmp	.+84     	; 0x5d7c <xTaskGenericNotifyFromISR+0x8c>
    5d28:	23 30       	cpi	r18, 0x03	; 3
    5d2a:	e9 f0       	breq	.+58     	; 0x5d66 <xTaskGenericNotifyFromISR+0x76>
    5d2c:	24 30       	cpi	r18, 0x04	; 4
    5d2e:	01 f1       	breq	.+64     	; 0x5d70 <xTaskGenericNotifyFromISR+0x80>
    5d30:	25 c0       	rjmp	.+74     	; 0x5d7c <xTaskGenericNotifyFromISR+0x8c>
    5d32:	03 a1       	ldd	r16, Z+35	; 0x23
    5d34:	14 a1       	ldd	r17, Z+36	; 0x24
    5d36:	25 a1       	ldd	r18, Z+37	; 0x25
    5d38:	36 a1       	ldd	r19, Z+38	; 0x26
    5d3a:	40 2b       	or	r20, r16
    5d3c:	51 2b       	or	r21, r17
    5d3e:	62 2b       	or	r22, r18
    5d40:	73 2b       	or	r23, r19
    5d42:	43 a3       	std	Z+35, r20	; 0x23
    5d44:	54 a3       	std	Z+36, r21	; 0x24
    5d46:	65 a3       	std	Z+37, r22	; 0x25
    5d48:	76 a3       	std	Z+38, r23	; 0x26
    5d4a:	18 c0       	rjmp	.+48     	; 0x5d7c <xTaskGenericNotifyFromISR+0x8c>
    5d4c:	43 a1       	ldd	r20, Z+35	; 0x23
    5d4e:	54 a1       	ldd	r21, Z+36	; 0x24
    5d50:	65 a1       	ldd	r22, Z+37	; 0x25
    5d52:	76 a1       	ldd	r23, Z+38	; 0x26
    5d54:	4f 5f       	subi	r20, 0xFF	; 255
    5d56:	5f 4f       	sbci	r21, 0xFF	; 255
    5d58:	6f 4f       	sbci	r22, 0xFF	; 255
    5d5a:	7f 4f       	sbci	r23, 0xFF	; 255
    5d5c:	43 a3       	std	Z+35, r20	; 0x23
    5d5e:	54 a3       	std	Z+36, r21	; 0x24
    5d60:	65 a3       	std	Z+37, r22	; 0x25
    5d62:	76 a3       	std	Z+38, r23	; 0x26
    5d64:	0b c0       	rjmp	.+22     	; 0x5d7c <xTaskGenericNotifyFromISR+0x8c>
    5d66:	43 a3       	std	Z+35, r20	; 0x23
    5d68:	54 a3       	std	Z+36, r21	; 0x24
    5d6a:	65 a3       	std	Z+37, r22	; 0x25
    5d6c:	76 a3       	std	Z+38, r23	; 0x26
    5d6e:	06 c0       	rjmp	.+12     	; 0x5d7c <xTaskGenericNotifyFromISR+0x8c>
    5d70:	82 30       	cpi	r24, 0x02	; 2
    5d72:	f1 f1       	breq	.+124    	; 0x5df0 <xTaskGenericNotifyFromISR+0x100>
    5d74:	43 a3       	std	Z+35, r20	; 0x23
    5d76:	54 a3       	std	Z+36, r21	; 0x24
    5d78:	65 a3       	std	Z+37, r22	; 0x25
    5d7a:	76 a3       	std	Z+38, r23	; 0x26
    5d7c:	81 30       	cpi	r24, 0x01	; 1
    5d7e:	d1 f5       	brne	.+116    	; 0x5df4 <xTaskGenericNotifyFromISR+0x104>
    5d80:	ef 01       	movw	r28, r30
    5d82:	80 91 53 1a 	lds	r24, 0x1A53	; 0x801a53 <uxSchedulerSuspended>
    5d86:	81 11       	cpse	r24, r1
    5d88:	1d c0       	rjmp	.+58     	; 0x5dc4 <xTaskGenericNotifyFromISR+0xd4>
    5d8a:	8f 01       	movw	r16, r30
    5d8c:	0e 5f       	subi	r16, 0xFE	; 254
    5d8e:	1f 4f       	sbci	r17, 0xFF	; 255
    5d90:	c8 01       	movw	r24, r16
    5d92:	0e 94 aa 0c 	call	0x1954	; 0x1954 <uxListRemove>
    5d96:	8e 89       	ldd	r24, Y+22	; 0x16
    5d98:	90 91 5b 1a 	lds	r25, 0x1A5B	; 0x801a5b <uxTopReadyPriority>
    5d9c:	98 17       	cp	r25, r24
    5d9e:	10 f4       	brcc	.+4      	; 0x5da4 <xTaskGenericNotifyFromISR+0xb4>
    5da0:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <uxTopReadyPriority>
    5da4:	90 e0       	ldi	r25, 0x00	; 0
    5da6:	9c 01       	movw	r18, r24
    5da8:	22 0f       	add	r18, r18
    5daa:	33 1f       	adc	r19, r19
    5dac:	22 0f       	add	r18, r18
    5dae:	33 1f       	adc	r19, r19
    5db0:	22 0f       	add	r18, r18
    5db2:	33 1f       	adc	r19, r19
    5db4:	82 0f       	add	r24, r18
    5db6:	93 1f       	adc	r25, r19
    5db8:	b8 01       	movw	r22, r16
    5dba:	89 57       	subi	r24, 0x79	; 121
    5dbc:	95 4e       	sbci	r25, 0xE5	; 229
    5dbe:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    5dc2:	07 c0       	rjmp	.+14     	; 0x5dd2 <xTaskGenericNotifyFromISR+0xe2>
    5dc4:	bf 01       	movw	r22, r30
    5dc6:	64 5f       	subi	r22, 0xF4	; 244
    5dc8:	7f 4f       	sbci	r23, 0xFF	; 255
    5dca:	88 e6       	ldi	r24, 0x68	; 104
    5dcc:	9a e1       	ldi	r25, 0x1A	; 26
    5dce:	0e 94 58 0c 	call	0x18b0	; 0x18b0 <vListInsertEnd>
    5dd2:	e0 91 bd 1a 	lds	r30, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5dd6:	f0 91 be 1a 	lds	r31, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>
    5dda:	9e 89       	ldd	r25, Y+22	; 0x16
    5ddc:	86 89       	ldd	r24, Z+22	; 0x16
    5dde:	89 17       	cp	r24, r25
    5de0:	58 f4       	brcc	.+22     	; 0x5df8 <xTaskGenericNotifyFromISR+0x108>
    5de2:	e1 14       	cp	r14, r1
    5de4:	f1 04       	cpc	r15, r1
    5de6:	51 f0       	breq	.+20     	; 0x5dfc <xTaskGenericNotifyFromISR+0x10c>
    5de8:	81 e0       	ldi	r24, 0x01	; 1
    5dea:	f7 01       	movw	r30, r14
    5dec:	80 83       	st	Z, r24
    5dee:	07 c0       	rjmp	.+14     	; 0x5dfe <xTaskGenericNotifyFromISR+0x10e>
    5df0:	80 e0       	ldi	r24, 0x00	; 0
    5df2:	05 c0       	rjmp	.+10     	; 0x5dfe <xTaskGenericNotifyFromISR+0x10e>
    5df4:	81 e0       	ldi	r24, 0x01	; 1
    5df6:	03 c0       	rjmp	.+6      	; 0x5dfe <xTaskGenericNotifyFromISR+0x10e>
    5df8:	81 e0       	ldi	r24, 0x01	; 1
    5dfa:	01 c0       	rjmp	.+2      	; 0x5dfe <xTaskGenericNotifyFromISR+0x10e>
    5dfc:	81 e0       	ldi	r24, 0x01	; 1
    5dfe:	df 91       	pop	r29
    5e00:	cf 91       	pop	r28
    5e02:	1f 91       	pop	r17
    5e04:	0f 91       	pop	r16
    5e06:	ff 90       	pop	r15
    5e08:	ef 90       	pop	r14
    5e0a:	08 95       	ret

00005e0c <xTaskNotifyStateClear>:

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    5e0c:	00 97       	sbiw	r24, 0x00	; 0
    5e0e:	21 f4       	brne	.+8      	; 0x5e18 <xTaskNotifyStateClear+0xc>
    5e10:	80 91 bd 1a 	lds	r24, 0x1ABD	; 0x801abd <pxCurrentTCB>
    5e14:	90 91 be 1a 	lds	r25, 0x1ABE	; 0x801abe <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    5e18:	0f b6       	in	r0, 0x3f	; 63
    5e1a:	f8 94       	cli
    5e1c:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    5e1e:	fc 01       	movw	r30, r24
    5e20:	27 a1       	ldd	r18, Z+39	; 0x27
    5e22:	22 30       	cpi	r18, 0x02	; 2
    5e24:	19 f4       	brne	.+6      	; 0x5e2c <xTaskNotifyStateClear+0x20>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    5e26:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5e28:	81 e0       	ldi	r24, 0x01	; 1
    5e2a:	01 c0       	rjmp	.+2      	; 0x5e2e <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    5e2c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    5e2e:	0f 90       	pop	r0
    5e30:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    5e32:	08 95       	ret

00005e34 <vFrameReaderTask>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
}

void vFrameReaderTask( void *pvParameters ){
    5e34:	cf 93       	push	r28
    5e36:	df 93       	push	r29
    5e38:	00 d0       	rcall	.+0      	; 0x5e3a <vFrameReaderTask+0x6>
    5e3a:	1f 92       	push	r1
    5e3c:	cd b7       	in	r28, 0x3d	; 61
    5e3e:	de b7       	in	r29, 0x3e	; 62
	frame_receiver = xTaskGetCurrentTaskHandle();
    5e40:	aa dc       	rcall	.-1708   	; 0x5796 <xTaskGetCurrentTaskHandle>
    5e42:	90 93 26 1b 	sts	0x1B26, r25	; 0x801b26 <frame_receiver+0x1>
    5e46:	80 93 25 1b 	sts	0x1B25, r24	; 0x801b25 <frame_receiver>
	uint32_t notification_value = 0;
    5e4a:	19 82       	std	Y+1, r1	; 0x01
    5e4c:	1a 82       	std	Y+2, r1	; 0x02
    5e4e:	1b 82       	std	Y+3, r1	; 0x03
    5e50:	1c 82       	std	Y+4, r1	; 0x04
	while(1){
		xTaskNotifyWait(0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);
    5e52:	ee 24       	eor	r14, r14
    5e54:	ea 94       	dec	r14
    5e56:	fe 2c       	mov	r15, r14
    5e58:	8e 01       	movw	r16, r28
    5e5a:	0f 5f       	subi	r16, 0xFF	; 255
    5e5c:	1f 4f       	sbci	r17, 0xFF	; 255
    5e5e:	2f ef       	ldi	r18, 0xFF	; 255
    5e60:	3f ef       	ldi	r19, 0xFF	; 255
    5e62:	a9 01       	movw	r20, r18
    5e64:	6f ef       	ldi	r22, 0xFF	; 255
    5e66:	7f ef       	ldi	r23, 0xFF	; 255
    5e68:	cb 01       	movw	r24, r22
    5e6a:	f5 dd       	rcall	.-1046   	; 0x5a56 <xTaskNotifyWait>
		if(receive_callback != NULL) receive_callback(receive_buffer, (uint16_t)notification_value);
    5e6c:	e0 91 86 1b 	lds	r30, 0x1B86	; 0x801b86 <receive_callback>
    5e70:	f0 91 87 1b 	lds	r31, 0x1B87	; 0x801b87 <receive_callback+0x1>
    5e74:	30 97       	sbiw	r30, 0x00	; 0
    5e76:	69 f3       	breq	.-38     	; 0x5e52 <vFrameReaderTask+0x1e>
    5e78:	69 81       	ldd	r22, Y+1	; 0x01
    5e7a:	7a 81       	ldd	r23, Y+2	; 0x02
    5e7c:	88 e8       	ldi	r24, 0x88	; 136
    5e7e:	9b e1       	ldi	r25, 0x1B	; 27
    5e80:	19 95       	eicall
    5e82:	e7 cf       	rjmp	.-50     	; 0x5e52 <vFrameReaderTask+0x1e>

00005e84 <vUartSendTask>:
	}
}

void vUartSendTask(void *pvParamters) {
    5e84:	cf 93       	push	r28
    5e86:	df 93       	push	r29
    5e88:	cd b7       	in	r28, 0x3d	; 61
    5e8a:	de b7       	in	r29, 0x3e	; 62
    5e8c:	c4 56       	subi	r28, 0x64	; 100
    5e8e:	d1 09       	sbc	r29, r1
    5e90:	0f b6       	in	r0, 0x3f	; 63
    5e92:	f8 94       	cli
    5e94:	de bf       	out	0x3e, r29	; 62
    5e96:	0f be       	out	0x3f, r0	; 63
    5e98:	cd bf       	out	0x3d, r28	; 61
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    5e9a:	00 ed       	ldi	r16, 0xD0	; 208
    5e9c:	10 e0       	ldi	r17, 0x00	; 0
				UDR2 = data[i];
    5e9e:	0f 2e       	mov	r0, r31
    5ea0:	f6 ed       	ldi	r31, 0xD6	; 214
    5ea2:	ef 2e       	mov	r14, r31
    5ea4:	f1 2c       	mov	r15, r1
    5ea6:	f0 2d       	mov	r31, r0
void vUartSendTask(void *pvParamters) {
	uint8_t data[100];
	uint16_t num;
	uint16_t i;
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
    5ea8:	20 e0       	ldi	r18, 0x00	; 0
    5eaa:	4f ef       	ldi	r20, 0xFF	; 255
    5eac:	5f ef       	ldi	r21, 0xFF	; 255
    5eae:	60 e0       	ldi	r22, 0x00	; 0
    5eb0:	70 e0       	ldi	r23, 0x00	; 0
    5eb2:	80 91 4b 1b 	lds	r24, 0x1B4B	; 0x801b4b <xUartMutex>
    5eb6:	90 91 4c 1b 	lds	r25, 0x1B4C	; 0x801b4c <xUartMutex+0x1>
    5eba:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
    5ebe:	24 e6       	ldi	r18, 0x64	; 100
    5ec0:	30 e0       	ldi	r19, 0x00	; 0
    5ec2:	40 e0       	ldi	r20, 0x00	; 0
    5ec4:	be 01       	movw	r22, r28
    5ec6:	6f 5f       	subi	r22, 0xFF	; 255
    5ec8:	7f 4f       	sbci	r23, 0xFF	; 255
    5eca:	8c ee       	ldi	r24, 0xEC	; 236
    5ecc:	9b e1       	ldi	r25, 0x1B	; 27
    5ece:	0e 94 a2 05 	call	0xb44	; 0xb44 <buffer_remove_token>
    5ed2:	6c 01       	movw	r12, r24
		xSemaphoreGive(xUartMutex);
    5ed4:	60 e0       	ldi	r22, 0x00	; 0
    5ed6:	70 e0       	ldi	r23, 0x00	; 0
    5ed8:	80 91 4b 1b 	lds	r24, 0x1B4B	; 0x801b4b <xUartMutex>
    5edc:	90 91 4c 1b 	lds	r25, 0x1B4C	; 0x801b4c <xUartMutex+0x1>
    5ee0:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
		if(num>0) {
    5ee4:	c1 14       	cp	r12, r1
    5ee6:	d1 04       	cpc	r13, r1
    5ee8:	79 f0       	breq	.+30     	; 0x5f08 <vUartSendTask+0x84>
    5eea:	fe 01       	movw	r30, r28
    5eec:	31 96       	adiw	r30, 0x01	; 1
    5eee:	9f 01       	movw	r18, r30
    5ef0:	2c 0d       	add	r18, r12
    5ef2:	3d 1d       	adc	r19, r13
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    5ef4:	d8 01       	movw	r26, r16
    5ef6:	8c 91       	ld	r24, X
    5ef8:	85 ff       	sbrs	r24, 5
    5efa:	fc cf       	rjmp	.-8      	; 0x5ef4 <vUartSendTask+0x70>
				UDR2 = data[i];
    5efc:	81 91       	ld	r24, Z+
    5efe:	d7 01       	movw	r26, r14
    5f00:	8c 93       	st	X, r24
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
    5f02:	2e 17       	cp	r18, r30
    5f04:	3f 07       	cpc	r19, r31
    5f06:	b1 f7       	brne	.-20     	; 0x5ef4 <vUartSendTask+0x70>
				while ( !( UCSR2A & (1<<UDRE2)) );
				UDR2 = data[i];
			}
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
    5f08:	8a e0       	ldi	r24, 0x0A	; 10
    5f0a:	90 e0       	ldi	r25, 0x00	; 0
    5f0c:	0e 94 e1 25 	call	0x4bc2	; 0x4bc2 <vTaskDelay>
	}
    5f10:	cb cf       	rjmp	.-106    	; 0x5ea8 <vUartSendTask+0x24>

00005f12 <vUSART_init>:
/************************************************************************/
//Initialize USART driver, note that RXD0/TXD0 (PD0/PD1) is used
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    5f12:	af 92       	push	r10
    5f14:	bf 92       	push	r11
    5f16:	cf 92       	push	r12
    5f18:	df 92       	push	r13
    5f1a:	ef 92       	push	r14
    5f1c:	ff 92       	push	r15
    5f1e:	0f 93       	push	r16
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    5f20:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    5f24:	89 e1       	ldi	r24, 0x19	; 25
    5f26:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    5f2a:	80 ee       	ldi	r24, 0xE0	; 224
    5f2c:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    5f30:	88 e9       	ldi	r24, 0x98	; 152
    5f32:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    5f36:	e2 ed       	ldi	r30, 0xD2	; 210
    5f38:	f0 e0       	ldi	r31, 0x00	; 0
    5f3a:	86 e0       	ldi	r24, 0x06	; 6
    5f3c:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    5f3e:	80 81       	ld	r24, Z
    5f40:	80 83       	st	Z, r24

	uint8_t *buf = pvPortMalloc(100);
    5f42:	84 e6       	ldi	r24, 0x64	; 100
    5f44:	90 e0       	ldi	r25, 0x00	; 0
    5f46:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
	buffer_init(&send_buffer, buf, 100);
    5f4a:	44 e6       	ldi	r20, 0x64	; 100
    5f4c:	50 e0       	ldi	r21, 0x00	; 0
    5f4e:	bc 01       	movw	r22, r24
    5f50:	8c ee       	ldi	r24, 0xEC	; 236
    5f52:	9b e1       	ldi	r25, 0x1B	; 27
    5f54:	0e 94 2c 05 	call	0xa58	; 0xa58 <buffer_init>
	xTaskCreate(vFrameReaderTask, "FrameReader", 300, NULL, 4, NULL);
    5f58:	a1 2c       	mov	r10, r1
    5f5a:	b1 2c       	mov	r11, r1
    5f5c:	c1 2c       	mov	r12, r1
    5f5e:	d1 2c       	mov	r13, r1
    5f60:	e1 2c       	mov	r14, r1
    5f62:	f1 2c       	mov	r15, r1
    5f64:	04 e0       	ldi	r16, 0x04	; 4
    5f66:	20 e0       	ldi	r18, 0x00	; 0
    5f68:	30 e0       	ldi	r19, 0x00	; 0
    5f6a:	4c e2       	ldi	r20, 0x2C	; 44
    5f6c:	51 e0       	ldi	r21, 0x01	; 1
    5f6e:	6c e1       	ldi	r22, 0x1C	; 28
    5f70:	77 e0       	ldi	r23, 0x07	; 7
    5f72:	8a e1       	ldi	r24, 0x1A	; 26
    5f74:	9f e2       	ldi	r25, 0x2F	; 47
    5f76:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskGenericCreate>
	xTaskCreate(vUartSendTask, "UartSendTask", 300, NULL, 4, NULL);
    5f7a:	20 e0       	ldi	r18, 0x00	; 0
    5f7c:	30 e0       	ldi	r19, 0x00	; 0
    5f7e:	4c e2       	ldi	r20, 0x2C	; 44
    5f80:	51 e0       	ldi	r21, 0x01	; 1
    5f82:	68 e2       	ldi	r22, 0x28	; 40
    5f84:	77 e0       	ldi	r23, 0x07	; 7
    5f86:	82 e4       	ldi	r24, 0x42	; 66
    5f88:	9f e2       	ldi	r25, 0x2F	; 47
    5f8a:	0e 94 2a 23 	call	0x4654	; 0x4654 <xTaskGenericCreate>
	
	xUartMutex = xSemaphoreCreateMutex();
    5f8e:	81 e0       	ldi	r24, 0x01	; 1
    5f90:	0e 94 fd 19 	call	0x33fa	; 0x33fa <xQueueCreateMutex>
    5f94:	90 93 4c 1b 	sts	0x1B4C, r25	; 0x801b4c <xUartMutex+0x1>
    5f98:	80 93 4b 1b 	sts	0x1B4B, r24	; 0x801b4b <xUartMutex>
}
    5f9c:	0f 91       	pop	r16
    5f9e:	ff 90       	pop	r15
    5fa0:	ef 90       	pop	r14
    5fa2:	df 90       	pop	r13
    5fa4:	cf 90       	pop	r12
    5fa6:	bf 90       	pop	r11
    5fa8:	af 90       	pop	r10
    5faa:	08 95       	ret

00005fac <vUSART_send>:




void vUSART_send(uint8_t *data, uint16_t len) {
    5fac:	0f 93       	push	r16
    5fae:	1f 93       	push	r17
    5fb0:	cf 93       	push	r28
    5fb2:	df 93       	push	r29
    5fb4:	ec 01       	movw	r28, r24
    5fb6:	8b 01       	movw	r16, r22
	xSemaphoreTake(xUartMutex, portMAX_DELAY);
    5fb8:	20 e0       	ldi	r18, 0x00	; 0
    5fba:	4f ef       	ldi	r20, 0xFF	; 255
    5fbc:	5f ef       	ldi	r21, 0xFF	; 255
    5fbe:	60 e0       	ldi	r22, 0x00	; 0
    5fc0:	70 e0       	ldi	r23, 0x00	; 0
    5fc2:	80 91 4b 1b 	lds	r24, 0x1B4B	; 0x801b4b <xUartMutex>
    5fc6:	90 91 4c 1b 	lds	r25, 0x1B4C	; 0x801b4c <xUartMutex+0x1>
    5fca:	0e 94 eb 1e 	call	0x3dd6	; 0x3dd6 <xQueueGenericReceive>
	buffer_append(&send_buffer, data, len);
    5fce:	a8 01       	movw	r20, r16
    5fd0:	be 01       	movw	r22, r28
    5fd2:	8c ee       	ldi	r24, 0xEC	; 236
    5fd4:	9b e1       	ldi	r25, 0x1B	; 27
    5fd6:	0e 94 3e 05 	call	0xa7c	; 0xa7c <buffer_append>
	xSemaphoreGive(xUartMutex);
    5fda:	60 e0       	ldi	r22, 0x00	; 0
    5fdc:	70 e0       	ldi	r23, 0x00	; 0
    5fde:	80 91 4b 1b 	lds	r24, 0x1B4B	; 0x801b4b <xUartMutex>
    5fe2:	90 91 4c 1b 	lds	r25, 0x1B4C	; 0x801b4c <xUartMutex+0x1>
    5fe6:	0e 94 4f 1d 	call	0x3a9e	; 0x3a9e <xQueueGive>
}
    5fea:	df 91       	pop	r29
    5fec:	cf 91       	pop	r28
    5fee:	1f 91       	pop	r17
    5ff0:	0f 91       	pop	r16
    5ff2:	08 95       	ret

00005ff4 <vUSART_set_receive_callback>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
    5ff4:	90 93 87 1b 	sts	0x1B87, r25	; 0x801b87 <receive_callback+0x1>
    5ff8:	80 93 86 1b 	sts	0x1B86, r24	; 0x801b86 <receive_callback>
    5ffc:	08 95       	ret

00005ffe <__vector_51>:
		vTaskDelay(10*portTICK_PERIOD_MS);
	}
}


ISR(USART2_RX_vect){
    5ffe:	1f 92       	push	r1
    6000:	0f 92       	push	r0
    6002:	0f b6       	in	r0, 0x3f	; 63
    6004:	0f 92       	push	r0
    6006:	11 24       	eor	r1, r1
    6008:	0b b6       	in	r0, 0x3b	; 59
    600a:	0f 92       	push	r0
    600c:	cf 92       	push	r12
    600e:	df 92       	push	r13
    6010:	ef 92       	push	r14
    6012:	ff 92       	push	r15
    6014:	0f 93       	push	r16
    6016:	1f 93       	push	r17
    6018:	2f 93       	push	r18
    601a:	3f 93       	push	r19
    601c:	4f 93       	push	r20
    601e:	5f 93       	push	r21
    6020:	6f 93       	push	r22
    6022:	7f 93       	push	r23
    6024:	8f 93       	push	r24
    6026:	9f 93       	push	r25
    6028:	af 93       	push	r26
    602a:	bf 93       	push	r27
    602c:	cf 93       	push	r28
    602e:	df 93       	push	r29
    6030:	ef 93       	push	r30
    6032:	ff 93       	push	r31
	static uint8_t input_buffer[100];
	static uint16_t input_index = 0;
	input_buffer[input_index++] = UDR2;
    6034:	80 91 23 1b 	lds	r24, 0x1B23	; 0x801b23 <input_index.2398>
    6038:	90 91 24 1b 	lds	r25, 0x1B24	; 0x801b24 <input_index.2398+0x1>
    603c:	ec 01       	movw	r28, r24
    603e:	21 96       	adiw	r28, 0x01	; 1
    6040:	d0 93 24 1b 	sts	0x1B24, r29	; 0x801b24 <input_index.2398+0x1>
    6044:	c0 93 23 1b 	sts	0x1B23, r28	; 0x801b23 <input_index.2398>
    6048:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    604c:	fc 01       	movw	r30, r24
    604e:	e1 54       	subi	r30, 0x41	; 65
    6050:	f5 4e       	sbci	r31, 0xE5	; 229
    6052:	20 83       	st	Z, r18
	if(input_buffer[input_index-1] == 0x00) {
    6054:	21 11       	cpse	r18, r1
    6056:	1d c0       	rjmp	.+58     	; 0x6092 <__vector_51+0x94>
		if(frame_receiver != NULL) {
    6058:	c0 90 25 1b 	lds	r12, 0x1B25	; 0x801b25 <frame_receiver>
    605c:	d0 90 26 1b 	lds	r13, 0x1B26	; 0x801b26 <frame_receiver+0x1>
    6060:	c1 14       	cp	r12, r1
    6062:	d1 04       	cpc	r13, r1
    6064:	89 f0       	breq	.+34     	; 0x6088 <__vector_51+0x8a>
			memcpy(receive_buffer, input_buffer, input_index);
    6066:	ae 01       	movw	r20, r28
    6068:	6f eb       	ldi	r22, 0xBF	; 191
    606a:	7a e1       	ldi	r23, 0x1A	; 26
    606c:	88 e8       	ldi	r24, 0x88	; 136
    606e:	9b e1       	ldi	r25, 0x1B	; 27
    6070:	0e 94 63 38 	call	0x70c6	; 0x70c6 <memcpy>
			xTaskNotifyFromISR(frame_receiver, input_index, eSetValueWithoutOverwrite, NULL);
    6074:	ae 01       	movw	r20, r28
    6076:	60 e0       	ldi	r22, 0x00	; 0
    6078:	70 e0       	ldi	r23, 0x00	; 0
    607a:	e1 2c       	mov	r14, r1
    607c:	f1 2c       	mov	r15, r1
    607e:	00 e0       	ldi	r16, 0x00	; 0
    6080:	10 e0       	ldi	r17, 0x00	; 0
    6082:	24 e0       	ldi	r18, 0x04	; 4
    6084:	c6 01       	movw	r24, r12
    6086:	34 de       	rcall	.-920    	; 0x5cf0 <xTaskGenericNotifyFromISR>
		}
		input_index = 0;
    6088:	10 92 24 1b 	sts	0x1B24, r1	; 0x801b24 <input_index.2398+0x1>
    608c:	10 92 23 1b 	sts	0x1B23, r1	; 0x801b23 <input_index.2398>
    6090:	07 c0       	rjmp	.+14     	; 0x60a0 <__vector_51+0xa2>
	}
	if(input_index > 100) input_index = 0; // Something went wrong, received too many bytes
    6092:	c5 36       	cpi	r28, 0x65	; 101
    6094:	d1 05       	cpc	r29, r1
    6096:	20 f0       	brcs	.+8      	; 0x60a0 <__vector_51+0xa2>
    6098:	10 92 24 1b 	sts	0x1B24, r1	; 0x801b24 <input_index.2398+0x1>
    609c:	10 92 23 1b 	sts	0x1B23, r1	; 0x801b23 <input_index.2398>
    60a0:	ff 91       	pop	r31
    60a2:	ef 91       	pop	r30
    60a4:	df 91       	pop	r29
    60a6:	cf 91       	pop	r28
    60a8:	bf 91       	pop	r27
    60aa:	af 91       	pop	r26
    60ac:	9f 91       	pop	r25
    60ae:	8f 91       	pop	r24
    60b0:	7f 91       	pop	r23
    60b2:	6f 91       	pop	r22
    60b4:	5f 91       	pop	r21
    60b6:	4f 91       	pop	r20
    60b8:	3f 91       	pop	r19
    60ba:	2f 91       	pop	r18
    60bc:	1f 91       	pop	r17
    60be:	0f 91       	pop	r16
    60c0:	ff 90       	pop	r15
    60c2:	ef 90       	pop	r14
    60c4:	df 90       	pop	r13
    60c6:	cf 90       	pop	r12
    60c8:	0f 90       	pop	r0
    60ca:	0b be       	out	0x3b, r0	; 59
    60cc:	0f 90       	pop	r0
    60ce:	0f be       	out	0x3f, r0	; 63
    60d0:	0f 90       	pop	r0
    60d2:	1f 90       	pop	r1
    60d4:	18 95       	reti

000060d6 <__subsf3>:
    60d6:	50 58       	subi	r21, 0x80	; 128

000060d8 <__addsf3>:
    60d8:	bb 27       	eor	r27, r27
    60da:	aa 27       	eor	r26, r26
    60dc:	0e d0       	rcall	.+28     	; 0x60fa <__addsf3x>
    60de:	27 c2       	rjmp	.+1102   	; 0x652e <__fp_round>
    60e0:	f0 d1       	rcall	.+992    	; 0x64c2 <__fp_pscA>
    60e2:	30 f0       	brcs	.+12     	; 0x60f0 <__addsf3+0x18>
    60e4:	f5 d1       	rcall	.+1002   	; 0x64d0 <__fp_pscB>
    60e6:	20 f0       	brcs	.+8      	; 0x60f0 <__addsf3+0x18>
    60e8:	31 f4       	brne	.+12     	; 0x60f6 <__addsf3+0x1e>
    60ea:	9f 3f       	cpi	r25, 0xFF	; 255
    60ec:	11 f4       	brne	.+4      	; 0x60f2 <__addsf3+0x1a>
    60ee:	1e f4       	brtc	.+6      	; 0x60f6 <__addsf3+0x1e>
    60f0:	c0 c1       	rjmp	.+896    	; 0x6472 <__fp_nan>
    60f2:	0e f4       	brtc	.+2      	; 0x60f6 <__addsf3+0x1e>
    60f4:	e0 95       	com	r30
    60f6:	e7 fb       	bst	r30, 7
    60f8:	b6 c1       	rjmp	.+876    	; 0x6466 <__fp_inf>

000060fa <__addsf3x>:
    60fa:	e9 2f       	mov	r30, r25
    60fc:	3a d2       	rcall	.+1140   	; 0x6572 <__fp_split3>
    60fe:	80 f3       	brcs	.-32     	; 0x60e0 <__addsf3+0x8>
    6100:	ba 17       	cp	r27, r26
    6102:	62 07       	cpc	r22, r18
    6104:	73 07       	cpc	r23, r19
    6106:	84 07       	cpc	r24, r20
    6108:	95 07       	cpc	r25, r21
    610a:	18 f0       	brcs	.+6      	; 0x6112 <__addsf3x+0x18>
    610c:	71 f4       	brne	.+28     	; 0x612a <__addsf3x+0x30>
    610e:	9e f5       	brtc	.+102    	; 0x6176 <__addsf3x+0x7c>
    6110:	52 c2       	rjmp	.+1188   	; 0x65b6 <__fp_zero>
    6112:	0e f4       	brtc	.+2      	; 0x6116 <__addsf3x+0x1c>
    6114:	e0 95       	com	r30
    6116:	0b 2e       	mov	r0, r27
    6118:	ba 2f       	mov	r27, r26
    611a:	a0 2d       	mov	r26, r0
    611c:	0b 01       	movw	r0, r22
    611e:	b9 01       	movw	r22, r18
    6120:	90 01       	movw	r18, r0
    6122:	0c 01       	movw	r0, r24
    6124:	ca 01       	movw	r24, r20
    6126:	a0 01       	movw	r20, r0
    6128:	11 24       	eor	r1, r1
    612a:	ff 27       	eor	r31, r31
    612c:	59 1b       	sub	r21, r25
    612e:	99 f0       	breq	.+38     	; 0x6156 <__addsf3x+0x5c>
    6130:	59 3f       	cpi	r21, 0xF9	; 249
    6132:	50 f4       	brcc	.+20     	; 0x6148 <__addsf3x+0x4e>
    6134:	50 3e       	cpi	r21, 0xE0	; 224
    6136:	68 f1       	brcs	.+90     	; 0x6192 <__addsf3x+0x98>
    6138:	1a 16       	cp	r1, r26
    613a:	f0 40       	sbci	r31, 0x00	; 0
    613c:	a2 2f       	mov	r26, r18
    613e:	23 2f       	mov	r18, r19
    6140:	34 2f       	mov	r19, r20
    6142:	44 27       	eor	r20, r20
    6144:	58 5f       	subi	r21, 0xF8	; 248
    6146:	f3 cf       	rjmp	.-26     	; 0x612e <__addsf3x+0x34>
    6148:	46 95       	lsr	r20
    614a:	37 95       	ror	r19
    614c:	27 95       	ror	r18
    614e:	a7 95       	ror	r26
    6150:	f0 40       	sbci	r31, 0x00	; 0
    6152:	53 95       	inc	r21
    6154:	c9 f7       	brne	.-14     	; 0x6148 <__addsf3x+0x4e>
    6156:	7e f4       	brtc	.+30     	; 0x6176 <__addsf3x+0x7c>
    6158:	1f 16       	cp	r1, r31
    615a:	ba 0b       	sbc	r27, r26
    615c:	62 0b       	sbc	r22, r18
    615e:	73 0b       	sbc	r23, r19
    6160:	84 0b       	sbc	r24, r20
    6162:	ba f0       	brmi	.+46     	; 0x6192 <__addsf3x+0x98>
    6164:	91 50       	subi	r25, 0x01	; 1
    6166:	a1 f0       	breq	.+40     	; 0x6190 <__addsf3x+0x96>
    6168:	ff 0f       	add	r31, r31
    616a:	bb 1f       	adc	r27, r27
    616c:	66 1f       	adc	r22, r22
    616e:	77 1f       	adc	r23, r23
    6170:	88 1f       	adc	r24, r24
    6172:	c2 f7       	brpl	.-16     	; 0x6164 <__addsf3x+0x6a>
    6174:	0e c0       	rjmp	.+28     	; 0x6192 <__addsf3x+0x98>
    6176:	ba 0f       	add	r27, r26
    6178:	62 1f       	adc	r22, r18
    617a:	73 1f       	adc	r23, r19
    617c:	84 1f       	adc	r24, r20
    617e:	48 f4       	brcc	.+18     	; 0x6192 <__addsf3x+0x98>
    6180:	87 95       	ror	r24
    6182:	77 95       	ror	r23
    6184:	67 95       	ror	r22
    6186:	b7 95       	ror	r27
    6188:	f7 95       	ror	r31
    618a:	9e 3f       	cpi	r25, 0xFE	; 254
    618c:	08 f0       	brcs	.+2      	; 0x6190 <__addsf3x+0x96>
    618e:	b3 cf       	rjmp	.-154    	; 0x60f6 <__addsf3+0x1e>
    6190:	93 95       	inc	r25
    6192:	88 0f       	add	r24, r24
    6194:	08 f0       	brcs	.+2      	; 0x6198 <__addsf3x+0x9e>
    6196:	99 27       	eor	r25, r25
    6198:	ee 0f       	add	r30, r30
    619a:	97 95       	ror	r25
    619c:	87 95       	ror	r24
    619e:	08 95       	ret
    61a0:	90 d1       	rcall	.+800    	; 0x64c2 <__fp_pscA>
    61a2:	58 f0       	brcs	.+22     	; 0x61ba <__addsf3x+0xc0>
    61a4:	80 e8       	ldi	r24, 0x80	; 128
    61a6:	91 e0       	ldi	r25, 0x01	; 1
    61a8:	09 f4       	brne	.+2      	; 0x61ac <__addsf3x+0xb2>
    61aa:	9e ef       	ldi	r25, 0xFE	; 254
    61ac:	91 d1       	rcall	.+802    	; 0x64d0 <__fp_pscB>
    61ae:	28 f0       	brcs	.+10     	; 0x61ba <__addsf3x+0xc0>
    61b0:	40 e8       	ldi	r20, 0x80	; 128
    61b2:	51 e0       	ldi	r21, 0x01	; 1
    61b4:	59 f4       	brne	.+22     	; 0x61cc <atan2+0xe>
    61b6:	5e ef       	ldi	r21, 0xFE	; 254
    61b8:	09 c0       	rjmp	.+18     	; 0x61cc <atan2+0xe>
    61ba:	5b c1       	rjmp	.+694    	; 0x6472 <__fp_nan>
    61bc:	fc c1       	rjmp	.+1016   	; 0x65b6 <__fp_zero>

000061be <atan2>:
    61be:	e9 2f       	mov	r30, r25
    61c0:	e0 78       	andi	r30, 0x80	; 128
    61c2:	d7 d1       	rcall	.+942    	; 0x6572 <__fp_split3>
    61c4:	68 f3       	brcs	.-38     	; 0x61a0 <__addsf3x+0xa6>
    61c6:	09 2e       	mov	r0, r25
    61c8:	05 2a       	or	r0, r21
    61ca:	c1 f3       	breq	.-16     	; 0x61bc <__addsf3x+0xc2>
    61cc:	26 17       	cp	r18, r22
    61ce:	37 07       	cpc	r19, r23
    61d0:	48 07       	cpc	r20, r24
    61d2:	59 07       	cpc	r21, r25
    61d4:	38 f0       	brcs	.+14     	; 0x61e4 <atan2+0x26>
    61d6:	0e 2e       	mov	r0, r30
    61d8:	07 f8       	bld	r0, 7
    61da:	e0 25       	eor	r30, r0
    61dc:	69 f0       	breq	.+26     	; 0x61f8 <atan2+0x3a>
    61de:	e0 25       	eor	r30, r0
    61e0:	e0 64       	ori	r30, 0x40	; 64
    61e2:	0a c0       	rjmp	.+20     	; 0x61f8 <atan2+0x3a>
    61e4:	ef 63       	ori	r30, 0x3F	; 63
    61e6:	07 f8       	bld	r0, 7
    61e8:	00 94       	com	r0
    61ea:	07 fa       	bst	r0, 7
    61ec:	db 01       	movw	r26, r22
    61ee:	b9 01       	movw	r22, r18
    61f0:	9d 01       	movw	r18, r26
    61f2:	dc 01       	movw	r26, r24
    61f4:	ca 01       	movw	r24, r20
    61f6:	ad 01       	movw	r20, r26
    61f8:	ef 93       	push	r30
    61fa:	4a d0       	rcall	.+148    	; 0x6290 <__divsf3_pse>
    61fc:	98 d1       	rcall	.+816    	; 0x652e <__fp_round>
    61fe:	0a d0       	rcall	.+20     	; 0x6214 <atan>
    6200:	5f 91       	pop	r21
    6202:	55 23       	and	r21, r21
    6204:	31 f0       	breq	.+12     	; 0x6212 <atan2+0x54>
    6206:	2b ed       	ldi	r18, 0xDB	; 219
    6208:	3f e0       	ldi	r19, 0x0F	; 15
    620a:	49 e4       	ldi	r20, 0x49	; 73
    620c:	50 fd       	sbrc	r21, 0
    620e:	49 ec       	ldi	r20, 0xC9	; 201
    6210:	63 cf       	rjmp	.-314    	; 0x60d8 <__addsf3>
    6212:	08 95       	ret

00006214 <atan>:
    6214:	df 93       	push	r29
    6216:	dd 27       	eor	r29, r29
    6218:	b9 2f       	mov	r27, r25
    621a:	bf 77       	andi	r27, 0x7F	; 127
    621c:	40 e8       	ldi	r20, 0x80	; 128
    621e:	5f e3       	ldi	r21, 0x3F	; 63
    6220:	16 16       	cp	r1, r22
    6222:	17 06       	cpc	r1, r23
    6224:	48 07       	cpc	r20, r24
    6226:	5b 07       	cpc	r21, r27
    6228:	10 f4       	brcc	.+4      	; 0x622e <atan+0x1a>
    622a:	d9 2f       	mov	r29, r25
    622c:	cf d1       	rcall	.+926    	; 0x65cc <inverse>
    622e:	9f 93       	push	r25
    6230:	8f 93       	push	r24
    6232:	7f 93       	push	r23
    6234:	6f 93       	push	r22
    6236:	7c d2       	rcall	.+1272   	; 0x6730 <square>
    6238:	e4 ee       	ldi	r30, 0xE4	; 228
    623a:	f0 e0       	ldi	r31, 0x00	; 0
    623c:	1d d1       	rcall	.+570    	; 0x6478 <__fp_powser>
    623e:	77 d1       	rcall	.+750    	; 0x652e <__fp_round>
    6240:	2f 91       	pop	r18
    6242:	3f 91       	pop	r19
    6244:	4f 91       	pop	r20
    6246:	5f 91       	pop	r21
    6248:	d4 d1       	rcall	.+936    	; 0x65f2 <__mulsf3x>
    624a:	dd 23       	and	r29, r29
    624c:	49 f0       	breq	.+18     	; 0x6260 <atan+0x4c>
    624e:	90 58       	subi	r25, 0x80	; 128
    6250:	a2 ea       	ldi	r26, 0xA2	; 162
    6252:	2a ed       	ldi	r18, 0xDA	; 218
    6254:	3f e0       	ldi	r19, 0x0F	; 15
    6256:	49 ec       	ldi	r20, 0xC9	; 201
    6258:	5f e3       	ldi	r21, 0x3F	; 63
    625a:	d0 78       	andi	r29, 0x80	; 128
    625c:	5d 27       	eor	r21, r29
    625e:	4d df       	rcall	.-358    	; 0x60fa <__addsf3x>
    6260:	df 91       	pop	r29
    6262:	65 c1       	rjmp	.+714    	; 0x652e <__fp_round>

00006264 <__cmpsf2>:
    6264:	dc d0       	rcall	.+440    	; 0x641e <__fp_cmp>
    6266:	08 f4       	brcc	.+2      	; 0x626a <__cmpsf2+0x6>
    6268:	81 e0       	ldi	r24, 0x01	; 1
    626a:	08 95       	ret

0000626c <cos>:
    626c:	39 d1       	rcall	.+626    	; 0x64e0 <__fp_rempio2>
    626e:	e3 95       	inc	r30
    6270:	6f c1       	rjmp	.+734    	; 0x6550 <__fp_sinus>

00006272 <__divsf3>:
    6272:	0c d0       	rcall	.+24     	; 0x628c <__divsf3x>
    6274:	5c c1       	rjmp	.+696    	; 0x652e <__fp_round>
    6276:	2c d1       	rcall	.+600    	; 0x64d0 <__fp_pscB>
    6278:	40 f0       	brcs	.+16     	; 0x628a <__divsf3+0x18>
    627a:	23 d1       	rcall	.+582    	; 0x64c2 <__fp_pscA>
    627c:	30 f0       	brcs	.+12     	; 0x628a <__divsf3+0x18>
    627e:	21 f4       	brne	.+8      	; 0x6288 <__divsf3+0x16>
    6280:	5f 3f       	cpi	r21, 0xFF	; 255
    6282:	19 f0       	breq	.+6      	; 0x628a <__divsf3+0x18>
    6284:	f0 c0       	rjmp	.+480    	; 0x6466 <__fp_inf>
    6286:	51 11       	cpse	r21, r1
    6288:	97 c1       	rjmp	.+814    	; 0x65b8 <__fp_szero>
    628a:	f3 c0       	rjmp	.+486    	; 0x6472 <__fp_nan>

0000628c <__divsf3x>:
    628c:	72 d1       	rcall	.+740    	; 0x6572 <__fp_split3>
    628e:	98 f3       	brcs	.-26     	; 0x6276 <__divsf3+0x4>

00006290 <__divsf3_pse>:
    6290:	99 23       	and	r25, r25
    6292:	c9 f3       	breq	.-14     	; 0x6286 <__divsf3+0x14>
    6294:	55 23       	and	r21, r21
    6296:	b1 f3       	breq	.-20     	; 0x6284 <__divsf3+0x12>
    6298:	95 1b       	sub	r25, r21
    629a:	55 0b       	sbc	r21, r21
    629c:	bb 27       	eor	r27, r27
    629e:	aa 27       	eor	r26, r26
    62a0:	62 17       	cp	r22, r18
    62a2:	73 07       	cpc	r23, r19
    62a4:	84 07       	cpc	r24, r20
    62a6:	38 f0       	brcs	.+14     	; 0x62b6 <__divsf3_pse+0x26>
    62a8:	9f 5f       	subi	r25, 0xFF	; 255
    62aa:	5f 4f       	sbci	r21, 0xFF	; 255
    62ac:	22 0f       	add	r18, r18
    62ae:	33 1f       	adc	r19, r19
    62b0:	44 1f       	adc	r20, r20
    62b2:	aa 1f       	adc	r26, r26
    62b4:	a9 f3       	breq	.-22     	; 0x62a0 <__divsf3_pse+0x10>
    62b6:	33 d0       	rcall	.+102    	; 0x631e <__divsf3_pse+0x8e>
    62b8:	0e 2e       	mov	r0, r30
    62ba:	3a f0       	brmi	.+14     	; 0x62ca <__divsf3_pse+0x3a>
    62bc:	e0 e8       	ldi	r30, 0x80	; 128
    62be:	30 d0       	rcall	.+96     	; 0x6320 <__divsf3_pse+0x90>
    62c0:	91 50       	subi	r25, 0x01	; 1
    62c2:	50 40       	sbci	r21, 0x00	; 0
    62c4:	e6 95       	lsr	r30
    62c6:	00 1c       	adc	r0, r0
    62c8:	ca f7       	brpl	.-14     	; 0x62bc <__divsf3_pse+0x2c>
    62ca:	29 d0       	rcall	.+82     	; 0x631e <__divsf3_pse+0x8e>
    62cc:	fe 2f       	mov	r31, r30
    62ce:	27 d0       	rcall	.+78     	; 0x631e <__divsf3_pse+0x8e>
    62d0:	66 0f       	add	r22, r22
    62d2:	77 1f       	adc	r23, r23
    62d4:	88 1f       	adc	r24, r24
    62d6:	bb 1f       	adc	r27, r27
    62d8:	26 17       	cp	r18, r22
    62da:	37 07       	cpc	r19, r23
    62dc:	48 07       	cpc	r20, r24
    62de:	ab 07       	cpc	r26, r27
    62e0:	b0 e8       	ldi	r27, 0x80	; 128
    62e2:	09 f0       	breq	.+2      	; 0x62e6 <__divsf3_pse+0x56>
    62e4:	bb 0b       	sbc	r27, r27
    62e6:	80 2d       	mov	r24, r0
    62e8:	bf 01       	movw	r22, r30
    62ea:	ff 27       	eor	r31, r31
    62ec:	93 58       	subi	r25, 0x83	; 131
    62ee:	5f 4f       	sbci	r21, 0xFF	; 255
    62f0:	2a f0       	brmi	.+10     	; 0x62fc <__divsf3_pse+0x6c>
    62f2:	9e 3f       	cpi	r25, 0xFE	; 254
    62f4:	51 05       	cpc	r21, r1
    62f6:	68 f0       	brcs	.+26     	; 0x6312 <__divsf3_pse+0x82>
    62f8:	b6 c0       	rjmp	.+364    	; 0x6466 <__fp_inf>
    62fa:	5e c1       	rjmp	.+700    	; 0x65b8 <__fp_szero>
    62fc:	5f 3f       	cpi	r21, 0xFF	; 255
    62fe:	ec f3       	brlt	.-6      	; 0x62fa <__divsf3_pse+0x6a>
    6300:	98 3e       	cpi	r25, 0xE8	; 232
    6302:	dc f3       	brlt	.-10     	; 0x62fa <__divsf3_pse+0x6a>
    6304:	86 95       	lsr	r24
    6306:	77 95       	ror	r23
    6308:	67 95       	ror	r22
    630a:	b7 95       	ror	r27
    630c:	f7 95       	ror	r31
    630e:	9f 5f       	subi	r25, 0xFF	; 255
    6310:	c9 f7       	brne	.-14     	; 0x6304 <__divsf3_pse+0x74>
    6312:	88 0f       	add	r24, r24
    6314:	91 1d       	adc	r25, r1
    6316:	96 95       	lsr	r25
    6318:	87 95       	ror	r24
    631a:	97 f9       	bld	r25, 7
    631c:	08 95       	ret
    631e:	e1 e0       	ldi	r30, 0x01	; 1
    6320:	66 0f       	add	r22, r22
    6322:	77 1f       	adc	r23, r23
    6324:	88 1f       	adc	r24, r24
    6326:	bb 1f       	adc	r27, r27
    6328:	62 17       	cp	r22, r18
    632a:	73 07       	cpc	r23, r19
    632c:	84 07       	cpc	r24, r20
    632e:	ba 07       	cpc	r27, r26
    6330:	20 f0       	brcs	.+8      	; 0x633a <__divsf3_pse+0xaa>
    6332:	62 1b       	sub	r22, r18
    6334:	73 0b       	sbc	r23, r19
    6336:	84 0b       	sbc	r24, r20
    6338:	ba 0b       	sbc	r27, r26
    633a:	ee 1f       	adc	r30, r30
    633c:	88 f7       	brcc	.-30     	; 0x6320 <__divsf3_pse+0x90>
    633e:	e0 95       	com	r30
    6340:	08 95       	ret

00006342 <__fixsfsi>:
    6342:	04 d0       	rcall	.+8      	; 0x634c <__fixunssfsi>
    6344:	68 94       	set
    6346:	b1 11       	cpse	r27, r1
    6348:	37 c1       	rjmp	.+622    	; 0x65b8 <__fp_szero>
    634a:	08 95       	ret

0000634c <__fixunssfsi>:
    634c:	1a d1       	rcall	.+564    	; 0x6582 <__fp_splitA>
    634e:	88 f0       	brcs	.+34     	; 0x6372 <__fixunssfsi+0x26>
    6350:	9f 57       	subi	r25, 0x7F	; 127
    6352:	90 f0       	brcs	.+36     	; 0x6378 <__fixunssfsi+0x2c>
    6354:	b9 2f       	mov	r27, r25
    6356:	99 27       	eor	r25, r25
    6358:	b7 51       	subi	r27, 0x17	; 23
    635a:	a0 f0       	brcs	.+40     	; 0x6384 <__fixunssfsi+0x38>
    635c:	d1 f0       	breq	.+52     	; 0x6392 <__fixunssfsi+0x46>
    635e:	66 0f       	add	r22, r22
    6360:	77 1f       	adc	r23, r23
    6362:	88 1f       	adc	r24, r24
    6364:	99 1f       	adc	r25, r25
    6366:	1a f0       	brmi	.+6      	; 0x636e <__fixunssfsi+0x22>
    6368:	ba 95       	dec	r27
    636a:	c9 f7       	brne	.-14     	; 0x635e <__fixunssfsi+0x12>
    636c:	12 c0       	rjmp	.+36     	; 0x6392 <__fixunssfsi+0x46>
    636e:	b1 30       	cpi	r27, 0x01	; 1
    6370:	81 f0       	breq	.+32     	; 0x6392 <__fixunssfsi+0x46>
    6372:	21 d1       	rcall	.+578    	; 0x65b6 <__fp_zero>
    6374:	b1 e0       	ldi	r27, 0x01	; 1
    6376:	08 95       	ret
    6378:	1e c1       	rjmp	.+572    	; 0x65b6 <__fp_zero>
    637a:	67 2f       	mov	r22, r23
    637c:	78 2f       	mov	r23, r24
    637e:	88 27       	eor	r24, r24
    6380:	b8 5f       	subi	r27, 0xF8	; 248
    6382:	39 f0       	breq	.+14     	; 0x6392 <__fixunssfsi+0x46>
    6384:	b9 3f       	cpi	r27, 0xF9	; 249
    6386:	cc f3       	brlt	.-14     	; 0x637a <__fixunssfsi+0x2e>
    6388:	86 95       	lsr	r24
    638a:	77 95       	ror	r23
    638c:	67 95       	ror	r22
    638e:	b3 95       	inc	r27
    6390:	d9 f7       	brne	.-10     	; 0x6388 <__fixunssfsi+0x3c>
    6392:	3e f4       	brtc	.+14     	; 0x63a2 <__fixunssfsi+0x56>
    6394:	90 95       	com	r25
    6396:	80 95       	com	r24
    6398:	70 95       	com	r23
    639a:	61 95       	neg	r22
    639c:	7f 4f       	sbci	r23, 0xFF	; 255
    639e:	8f 4f       	sbci	r24, 0xFF	; 255
    63a0:	9f 4f       	sbci	r25, 0xFF	; 255
    63a2:	08 95       	ret

000063a4 <__floatunsisf>:
    63a4:	e8 94       	clt
    63a6:	09 c0       	rjmp	.+18     	; 0x63ba <__floatsisf+0x12>

000063a8 <__floatsisf>:
    63a8:	97 fb       	bst	r25, 7
    63aa:	3e f4       	brtc	.+14     	; 0x63ba <__floatsisf+0x12>
    63ac:	90 95       	com	r25
    63ae:	80 95       	com	r24
    63b0:	70 95       	com	r23
    63b2:	61 95       	neg	r22
    63b4:	7f 4f       	sbci	r23, 0xFF	; 255
    63b6:	8f 4f       	sbci	r24, 0xFF	; 255
    63b8:	9f 4f       	sbci	r25, 0xFF	; 255
    63ba:	99 23       	and	r25, r25
    63bc:	a9 f0       	breq	.+42     	; 0x63e8 <__floatsisf+0x40>
    63be:	f9 2f       	mov	r31, r25
    63c0:	96 e9       	ldi	r25, 0x96	; 150
    63c2:	bb 27       	eor	r27, r27
    63c4:	93 95       	inc	r25
    63c6:	f6 95       	lsr	r31
    63c8:	87 95       	ror	r24
    63ca:	77 95       	ror	r23
    63cc:	67 95       	ror	r22
    63ce:	b7 95       	ror	r27
    63d0:	f1 11       	cpse	r31, r1
    63d2:	f8 cf       	rjmp	.-16     	; 0x63c4 <__floatsisf+0x1c>
    63d4:	fa f4       	brpl	.+62     	; 0x6414 <__floatsisf+0x6c>
    63d6:	bb 0f       	add	r27, r27
    63d8:	11 f4       	brne	.+4      	; 0x63de <__floatsisf+0x36>
    63da:	60 ff       	sbrs	r22, 0
    63dc:	1b c0       	rjmp	.+54     	; 0x6414 <__floatsisf+0x6c>
    63de:	6f 5f       	subi	r22, 0xFF	; 255
    63e0:	7f 4f       	sbci	r23, 0xFF	; 255
    63e2:	8f 4f       	sbci	r24, 0xFF	; 255
    63e4:	9f 4f       	sbci	r25, 0xFF	; 255
    63e6:	16 c0       	rjmp	.+44     	; 0x6414 <__floatsisf+0x6c>
    63e8:	88 23       	and	r24, r24
    63ea:	11 f0       	breq	.+4      	; 0x63f0 <__floatsisf+0x48>
    63ec:	96 e9       	ldi	r25, 0x96	; 150
    63ee:	11 c0       	rjmp	.+34     	; 0x6412 <__floatsisf+0x6a>
    63f0:	77 23       	and	r23, r23
    63f2:	21 f0       	breq	.+8      	; 0x63fc <__floatsisf+0x54>
    63f4:	9e e8       	ldi	r25, 0x8E	; 142
    63f6:	87 2f       	mov	r24, r23
    63f8:	76 2f       	mov	r23, r22
    63fa:	05 c0       	rjmp	.+10     	; 0x6406 <__floatsisf+0x5e>
    63fc:	66 23       	and	r22, r22
    63fe:	71 f0       	breq	.+28     	; 0x641c <__floatsisf+0x74>
    6400:	96 e8       	ldi	r25, 0x86	; 134
    6402:	86 2f       	mov	r24, r22
    6404:	70 e0       	ldi	r23, 0x00	; 0
    6406:	60 e0       	ldi	r22, 0x00	; 0
    6408:	2a f0       	brmi	.+10     	; 0x6414 <__floatsisf+0x6c>
    640a:	9a 95       	dec	r25
    640c:	66 0f       	add	r22, r22
    640e:	77 1f       	adc	r23, r23
    6410:	88 1f       	adc	r24, r24
    6412:	da f7       	brpl	.-10     	; 0x640a <__floatsisf+0x62>
    6414:	88 0f       	add	r24, r24
    6416:	96 95       	lsr	r25
    6418:	87 95       	ror	r24
    641a:	97 f9       	bld	r25, 7
    641c:	08 95       	ret

0000641e <__fp_cmp>:
    641e:	99 0f       	add	r25, r25
    6420:	00 08       	sbc	r0, r0
    6422:	55 0f       	add	r21, r21
    6424:	aa 0b       	sbc	r26, r26
    6426:	e0 e8       	ldi	r30, 0x80	; 128
    6428:	fe ef       	ldi	r31, 0xFE	; 254
    642a:	16 16       	cp	r1, r22
    642c:	17 06       	cpc	r1, r23
    642e:	e8 07       	cpc	r30, r24
    6430:	f9 07       	cpc	r31, r25
    6432:	c0 f0       	brcs	.+48     	; 0x6464 <__fp_cmp+0x46>
    6434:	12 16       	cp	r1, r18
    6436:	13 06       	cpc	r1, r19
    6438:	e4 07       	cpc	r30, r20
    643a:	f5 07       	cpc	r31, r21
    643c:	98 f0       	brcs	.+38     	; 0x6464 <__fp_cmp+0x46>
    643e:	62 1b       	sub	r22, r18
    6440:	73 0b       	sbc	r23, r19
    6442:	84 0b       	sbc	r24, r20
    6444:	95 0b       	sbc	r25, r21
    6446:	39 f4       	brne	.+14     	; 0x6456 <__fp_cmp+0x38>
    6448:	0a 26       	eor	r0, r26
    644a:	61 f0       	breq	.+24     	; 0x6464 <__fp_cmp+0x46>
    644c:	23 2b       	or	r18, r19
    644e:	24 2b       	or	r18, r20
    6450:	25 2b       	or	r18, r21
    6452:	21 f4       	brne	.+8      	; 0x645c <__fp_cmp+0x3e>
    6454:	08 95       	ret
    6456:	0a 26       	eor	r0, r26
    6458:	09 f4       	brne	.+2      	; 0x645c <__fp_cmp+0x3e>
    645a:	a1 40       	sbci	r26, 0x01	; 1
    645c:	a6 95       	lsr	r26
    645e:	8f ef       	ldi	r24, 0xFF	; 255
    6460:	81 1d       	adc	r24, r1
    6462:	81 1d       	adc	r24, r1
    6464:	08 95       	ret

00006466 <__fp_inf>:
    6466:	97 f9       	bld	r25, 7
    6468:	9f 67       	ori	r25, 0x7F	; 127
    646a:	80 e8       	ldi	r24, 0x80	; 128
    646c:	70 e0       	ldi	r23, 0x00	; 0
    646e:	60 e0       	ldi	r22, 0x00	; 0
    6470:	08 95       	ret

00006472 <__fp_nan>:
    6472:	9f ef       	ldi	r25, 0xFF	; 255
    6474:	80 ec       	ldi	r24, 0xC0	; 192
    6476:	08 95       	ret

00006478 <__fp_powser>:
    6478:	df 93       	push	r29
    647a:	cf 93       	push	r28
    647c:	1f 93       	push	r17
    647e:	0f 93       	push	r16
    6480:	ff 92       	push	r15
    6482:	ef 92       	push	r14
    6484:	df 92       	push	r13
    6486:	7b 01       	movw	r14, r22
    6488:	8c 01       	movw	r16, r24
    648a:	68 94       	set
    648c:	05 c0       	rjmp	.+10     	; 0x6498 <__fp_powser+0x20>
    648e:	da 2e       	mov	r13, r26
    6490:	ef 01       	movw	r28, r30
    6492:	af d0       	rcall	.+350    	; 0x65f2 <__mulsf3x>
    6494:	fe 01       	movw	r30, r28
    6496:	e8 94       	clt
    6498:	a5 91       	lpm	r26, Z+
    649a:	25 91       	lpm	r18, Z+
    649c:	35 91       	lpm	r19, Z+
    649e:	45 91       	lpm	r20, Z+
    64a0:	55 91       	lpm	r21, Z+
    64a2:	ae f3       	brts	.-22     	; 0x648e <__fp_powser+0x16>
    64a4:	ef 01       	movw	r28, r30
    64a6:	29 de       	rcall	.-942    	; 0x60fa <__addsf3x>
    64a8:	fe 01       	movw	r30, r28
    64aa:	97 01       	movw	r18, r14
    64ac:	a8 01       	movw	r20, r16
    64ae:	da 94       	dec	r13
    64b0:	79 f7       	brne	.-34     	; 0x6490 <__fp_powser+0x18>
    64b2:	df 90       	pop	r13
    64b4:	ef 90       	pop	r14
    64b6:	ff 90       	pop	r15
    64b8:	0f 91       	pop	r16
    64ba:	1f 91       	pop	r17
    64bc:	cf 91       	pop	r28
    64be:	df 91       	pop	r29
    64c0:	08 95       	ret

000064c2 <__fp_pscA>:
    64c2:	00 24       	eor	r0, r0
    64c4:	0a 94       	dec	r0
    64c6:	16 16       	cp	r1, r22
    64c8:	17 06       	cpc	r1, r23
    64ca:	18 06       	cpc	r1, r24
    64cc:	09 06       	cpc	r0, r25
    64ce:	08 95       	ret

000064d0 <__fp_pscB>:
    64d0:	00 24       	eor	r0, r0
    64d2:	0a 94       	dec	r0
    64d4:	12 16       	cp	r1, r18
    64d6:	13 06       	cpc	r1, r19
    64d8:	14 06       	cpc	r1, r20
    64da:	05 06       	cpc	r0, r21
    64dc:	08 95       	ret
    64de:	c9 cf       	rjmp	.-110    	; 0x6472 <__fp_nan>

000064e0 <__fp_rempio2>:
    64e0:	50 d0       	rcall	.+160    	; 0x6582 <__fp_splitA>
    64e2:	e8 f3       	brcs	.-6      	; 0x64de <__fp_pscB+0xe>
    64e4:	e8 94       	clt
    64e6:	e0 e0       	ldi	r30, 0x00	; 0
    64e8:	bb 27       	eor	r27, r27
    64ea:	9f 57       	subi	r25, 0x7F	; 127
    64ec:	f0 f0       	brcs	.+60     	; 0x652a <__fp_rempio2+0x4a>
    64ee:	2a ed       	ldi	r18, 0xDA	; 218
    64f0:	3f e0       	ldi	r19, 0x0F	; 15
    64f2:	49 ec       	ldi	r20, 0xC9	; 201
    64f4:	06 c0       	rjmp	.+12     	; 0x6502 <__fp_rempio2+0x22>
    64f6:	ee 0f       	add	r30, r30
    64f8:	bb 0f       	add	r27, r27
    64fa:	66 1f       	adc	r22, r22
    64fc:	77 1f       	adc	r23, r23
    64fe:	88 1f       	adc	r24, r24
    6500:	28 f0       	brcs	.+10     	; 0x650c <__fp_rempio2+0x2c>
    6502:	b2 3a       	cpi	r27, 0xA2	; 162
    6504:	62 07       	cpc	r22, r18
    6506:	73 07       	cpc	r23, r19
    6508:	84 07       	cpc	r24, r20
    650a:	28 f0       	brcs	.+10     	; 0x6516 <__fp_rempio2+0x36>
    650c:	b2 5a       	subi	r27, 0xA2	; 162
    650e:	62 0b       	sbc	r22, r18
    6510:	73 0b       	sbc	r23, r19
    6512:	84 0b       	sbc	r24, r20
    6514:	e3 95       	inc	r30
    6516:	9a 95       	dec	r25
    6518:	72 f7       	brpl	.-36     	; 0x64f6 <__fp_rempio2+0x16>
    651a:	80 38       	cpi	r24, 0x80	; 128
    651c:	30 f4       	brcc	.+12     	; 0x652a <__fp_rempio2+0x4a>
    651e:	9a 95       	dec	r25
    6520:	bb 0f       	add	r27, r27
    6522:	66 1f       	adc	r22, r22
    6524:	77 1f       	adc	r23, r23
    6526:	88 1f       	adc	r24, r24
    6528:	d2 f7       	brpl	.-12     	; 0x651e <__fp_rempio2+0x3e>
    652a:	90 48       	sbci	r25, 0x80	; 128
    652c:	06 c1       	rjmp	.+524    	; 0x673a <__fp_mpack_finite>

0000652e <__fp_round>:
    652e:	09 2e       	mov	r0, r25
    6530:	03 94       	inc	r0
    6532:	00 0c       	add	r0, r0
    6534:	11 f4       	brne	.+4      	; 0x653a <__fp_round+0xc>
    6536:	88 23       	and	r24, r24
    6538:	52 f0       	brmi	.+20     	; 0x654e <__fp_round+0x20>
    653a:	bb 0f       	add	r27, r27
    653c:	40 f4       	brcc	.+16     	; 0x654e <__fp_round+0x20>
    653e:	bf 2b       	or	r27, r31
    6540:	11 f4       	brne	.+4      	; 0x6546 <__fp_round+0x18>
    6542:	60 ff       	sbrs	r22, 0
    6544:	04 c0       	rjmp	.+8      	; 0x654e <__fp_round+0x20>
    6546:	6f 5f       	subi	r22, 0xFF	; 255
    6548:	7f 4f       	sbci	r23, 0xFF	; 255
    654a:	8f 4f       	sbci	r24, 0xFF	; 255
    654c:	9f 4f       	sbci	r25, 0xFF	; 255
    654e:	08 95       	ret

00006550 <__fp_sinus>:
    6550:	ef 93       	push	r30
    6552:	e0 ff       	sbrs	r30, 0
    6554:	06 c0       	rjmp	.+12     	; 0x6562 <__fp_sinus+0x12>
    6556:	a2 ea       	ldi	r26, 0xA2	; 162
    6558:	2a ed       	ldi	r18, 0xDA	; 218
    655a:	3f e0       	ldi	r19, 0x0F	; 15
    655c:	49 ec       	ldi	r20, 0xC9	; 201
    655e:	5f eb       	ldi	r21, 0xBF	; 191
    6560:	cc dd       	rcall	.-1128   	; 0x60fa <__addsf3x>
    6562:	e5 df       	rcall	.-54     	; 0x652e <__fp_round>
    6564:	0f 90       	pop	r0
    6566:	03 94       	inc	r0
    6568:	01 fc       	sbrc	r0, 1
    656a:	90 58       	subi	r25, 0x80	; 128
    656c:	e1 e1       	ldi	r30, 0x11	; 17
    656e:	f1 e0       	ldi	r31, 0x01	; 1
    6570:	f7 c0       	rjmp	.+494    	; 0x6760 <__fp_powsodd>

00006572 <__fp_split3>:
    6572:	57 fd       	sbrc	r21, 7
    6574:	90 58       	subi	r25, 0x80	; 128
    6576:	44 0f       	add	r20, r20
    6578:	55 1f       	adc	r21, r21
    657a:	59 f0       	breq	.+22     	; 0x6592 <__fp_splitA+0x10>
    657c:	5f 3f       	cpi	r21, 0xFF	; 255
    657e:	71 f0       	breq	.+28     	; 0x659c <__fp_splitA+0x1a>
    6580:	47 95       	ror	r20

00006582 <__fp_splitA>:
    6582:	88 0f       	add	r24, r24
    6584:	97 fb       	bst	r25, 7
    6586:	99 1f       	adc	r25, r25
    6588:	61 f0       	breq	.+24     	; 0x65a2 <__fp_splitA+0x20>
    658a:	9f 3f       	cpi	r25, 0xFF	; 255
    658c:	79 f0       	breq	.+30     	; 0x65ac <__fp_splitA+0x2a>
    658e:	87 95       	ror	r24
    6590:	08 95       	ret
    6592:	12 16       	cp	r1, r18
    6594:	13 06       	cpc	r1, r19
    6596:	14 06       	cpc	r1, r20
    6598:	55 1f       	adc	r21, r21
    659a:	f2 cf       	rjmp	.-28     	; 0x6580 <__fp_split3+0xe>
    659c:	46 95       	lsr	r20
    659e:	f1 df       	rcall	.-30     	; 0x6582 <__fp_splitA>
    65a0:	08 c0       	rjmp	.+16     	; 0x65b2 <__fp_splitA+0x30>
    65a2:	16 16       	cp	r1, r22
    65a4:	17 06       	cpc	r1, r23
    65a6:	18 06       	cpc	r1, r24
    65a8:	99 1f       	adc	r25, r25
    65aa:	f1 cf       	rjmp	.-30     	; 0x658e <__fp_splitA+0xc>
    65ac:	86 95       	lsr	r24
    65ae:	71 05       	cpc	r23, r1
    65b0:	61 05       	cpc	r22, r1
    65b2:	08 94       	sec
    65b4:	08 95       	ret

000065b6 <__fp_zero>:
    65b6:	e8 94       	clt

000065b8 <__fp_szero>:
    65b8:	bb 27       	eor	r27, r27
    65ba:	66 27       	eor	r22, r22
    65bc:	77 27       	eor	r23, r23
    65be:	cb 01       	movw	r24, r22
    65c0:	97 f9       	bld	r25, 7
    65c2:	08 95       	ret

000065c4 <__gesf2>:
    65c4:	2c df       	rcall	.-424    	; 0x641e <__fp_cmp>
    65c6:	08 f4       	brcc	.+2      	; 0x65ca <__gesf2+0x6>
    65c8:	8f ef       	ldi	r24, 0xFF	; 255
    65ca:	08 95       	ret

000065cc <inverse>:
    65cc:	9b 01       	movw	r18, r22
    65ce:	ac 01       	movw	r20, r24
    65d0:	60 e0       	ldi	r22, 0x00	; 0
    65d2:	70 e0       	ldi	r23, 0x00	; 0
    65d4:	80 e8       	ldi	r24, 0x80	; 128
    65d6:	9f e3       	ldi	r25, 0x3F	; 63
    65d8:	4c ce       	rjmp	.-872    	; 0x6272 <__divsf3>

000065da <__mulsf3>:
    65da:	0b d0       	rcall	.+22     	; 0x65f2 <__mulsf3x>
    65dc:	a8 cf       	rjmp	.-176    	; 0x652e <__fp_round>
    65de:	71 df       	rcall	.-286    	; 0x64c2 <__fp_pscA>
    65e0:	28 f0       	brcs	.+10     	; 0x65ec <__mulsf3+0x12>
    65e2:	76 df       	rcall	.-276    	; 0x64d0 <__fp_pscB>
    65e4:	18 f0       	brcs	.+6      	; 0x65ec <__mulsf3+0x12>
    65e6:	95 23       	and	r25, r21
    65e8:	09 f0       	breq	.+2      	; 0x65ec <__mulsf3+0x12>
    65ea:	3d cf       	rjmp	.-390    	; 0x6466 <__fp_inf>
    65ec:	42 cf       	rjmp	.-380    	; 0x6472 <__fp_nan>
    65ee:	11 24       	eor	r1, r1
    65f0:	e3 cf       	rjmp	.-58     	; 0x65b8 <__fp_szero>

000065f2 <__mulsf3x>:
    65f2:	bf df       	rcall	.-130    	; 0x6572 <__fp_split3>
    65f4:	a0 f3       	brcs	.-24     	; 0x65de <__mulsf3+0x4>

000065f6 <__mulsf3_pse>:
    65f6:	95 9f       	mul	r25, r21
    65f8:	d1 f3       	breq	.-12     	; 0x65ee <__mulsf3+0x14>
    65fa:	95 0f       	add	r25, r21
    65fc:	50 e0       	ldi	r21, 0x00	; 0
    65fe:	55 1f       	adc	r21, r21
    6600:	62 9f       	mul	r22, r18
    6602:	f0 01       	movw	r30, r0
    6604:	72 9f       	mul	r23, r18
    6606:	bb 27       	eor	r27, r27
    6608:	f0 0d       	add	r31, r0
    660a:	b1 1d       	adc	r27, r1
    660c:	63 9f       	mul	r22, r19
    660e:	aa 27       	eor	r26, r26
    6610:	f0 0d       	add	r31, r0
    6612:	b1 1d       	adc	r27, r1
    6614:	aa 1f       	adc	r26, r26
    6616:	64 9f       	mul	r22, r20
    6618:	66 27       	eor	r22, r22
    661a:	b0 0d       	add	r27, r0
    661c:	a1 1d       	adc	r26, r1
    661e:	66 1f       	adc	r22, r22
    6620:	82 9f       	mul	r24, r18
    6622:	22 27       	eor	r18, r18
    6624:	b0 0d       	add	r27, r0
    6626:	a1 1d       	adc	r26, r1
    6628:	62 1f       	adc	r22, r18
    662a:	73 9f       	mul	r23, r19
    662c:	b0 0d       	add	r27, r0
    662e:	a1 1d       	adc	r26, r1
    6630:	62 1f       	adc	r22, r18
    6632:	83 9f       	mul	r24, r19
    6634:	a0 0d       	add	r26, r0
    6636:	61 1d       	adc	r22, r1
    6638:	22 1f       	adc	r18, r18
    663a:	74 9f       	mul	r23, r20
    663c:	33 27       	eor	r19, r19
    663e:	a0 0d       	add	r26, r0
    6640:	61 1d       	adc	r22, r1
    6642:	23 1f       	adc	r18, r19
    6644:	84 9f       	mul	r24, r20
    6646:	60 0d       	add	r22, r0
    6648:	21 1d       	adc	r18, r1
    664a:	82 2f       	mov	r24, r18
    664c:	76 2f       	mov	r23, r22
    664e:	6a 2f       	mov	r22, r26
    6650:	11 24       	eor	r1, r1
    6652:	9f 57       	subi	r25, 0x7F	; 127
    6654:	50 40       	sbci	r21, 0x00	; 0
    6656:	8a f0       	brmi	.+34     	; 0x667a <__mulsf3_pse+0x84>
    6658:	e1 f0       	breq	.+56     	; 0x6692 <__mulsf3_pse+0x9c>
    665a:	88 23       	and	r24, r24
    665c:	4a f0       	brmi	.+18     	; 0x6670 <__mulsf3_pse+0x7a>
    665e:	ee 0f       	add	r30, r30
    6660:	ff 1f       	adc	r31, r31
    6662:	bb 1f       	adc	r27, r27
    6664:	66 1f       	adc	r22, r22
    6666:	77 1f       	adc	r23, r23
    6668:	88 1f       	adc	r24, r24
    666a:	91 50       	subi	r25, 0x01	; 1
    666c:	50 40       	sbci	r21, 0x00	; 0
    666e:	a9 f7       	brne	.-22     	; 0x665a <__mulsf3_pse+0x64>
    6670:	9e 3f       	cpi	r25, 0xFE	; 254
    6672:	51 05       	cpc	r21, r1
    6674:	70 f0       	brcs	.+28     	; 0x6692 <__mulsf3_pse+0x9c>
    6676:	f7 ce       	rjmp	.-530    	; 0x6466 <__fp_inf>
    6678:	9f cf       	rjmp	.-194    	; 0x65b8 <__fp_szero>
    667a:	5f 3f       	cpi	r21, 0xFF	; 255
    667c:	ec f3       	brlt	.-6      	; 0x6678 <__mulsf3_pse+0x82>
    667e:	98 3e       	cpi	r25, 0xE8	; 232
    6680:	dc f3       	brlt	.-10     	; 0x6678 <__mulsf3_pse+0x82>
    6682:	86 95       	lsr	r24
    6684:	77 95       	ror	r23
    6686:	67 95       	ror	r22
    6688:	b7 95       	ror	r27
    668a:	f7 95       	ror	r31
    668c:	e7 95       	ror	r30
    668e:	9f 5f       	subi	r25, 0xFF	; 255
    6690:	c1 f7       	brne	.-16     	; 0x6682 <__mulsf3_pse+0x8c>
    6692:	fe 2b       	or	r31, r30
    6694:	88 0f       	add	r24, r24
    6696:	91 1d       	adc	r25, r1
    6698:	96 95       	lsr	r25
    669a:	87 95       	ror	r24
    669c:	97 f9       	bld	r25, 7
    669e:	08 95       	ret

000066a0 <sin>:
    66a0:	9f 93       	push	r25
    66a2:	1e df       	rcall	.-452    	; 0x64e0 <__fp_rempio2>
    66a4:	0f 90       	pop	r0
    66a6:	07 fc       	sbrc	r0, 7
    66a8:	ee 5f       	subi	r30, 0xFE	; 254
    66aa:	52 cf       	rjmp	.-348    	; 0x6550 <__fp_sinus>
    66ac:	11 f4       	brne	.+4      	; 0x66b2 <sin+0x12>
    66ae:	0e f4       	brtc	.+2      	; 0x66b2 <sin+0x12>
    66b0:	e0 ce       	rjmp	.-576    	; 0x6472 <__fp_nan>
    66b2:	41 c0       	rjmp	.+130    	; 0x6736 <__fp_mpack>

000066b4 <sqrt>:
    66b4:	66 df       	rcall	.-308    	; 0x6582 <__fp_splitA>
    66b6:	d0 f3       	brcs	.-12     	; 0x66ac <sin+0xc>
    66b8:	99 23       	and	r25, r25
    66ba:	d9 f3       	breq	.-10     	; 0x66b2 <sin+0x12>
    66bc:	ce f3       	brts	.-14     	; 0x66b0 <sin+0x10>
    66be:	9f 57       	subi	r25, 0x7F	; 127
    66c0:	55 0b       	sbc	r21, r21
    66c2:	87 ff       	sbrs	r24, 7
    66c4:	46 d0       	rcall	.+140    	; 0x6752 <__fp_norm2>
    66c6:	00 24       	eor	r0, r0
    66c8:	a0 e6       	ldi	r26, 0x60	; 96
    66ca:	40 ea       	ldi	r20, 0xA0	; 160
    66cc:	90 01       	movw	r18, r0
    66ce:	80 58       	subi	r24, 0x80	; 128
    66d0:	56 95       	lsr	r21
    66d2:	97 95       	ror	r25
    66d4:	28 f4       	brcc	.+10     	; 0x66e0 <sqrt+0x2c>
    66d6:	80 5c       	subi	r24, 0xC0	; 192
    66d8:	66 0f       	add	r22, r22
    66da:	77 1f       	adc	r23, r23
    66dc:	88 1f       	adc	r24, r24
    66de:	20 f0       	brcs	.+8      	; 0x66e8 <sqrt+0x34>
    66e0:	26 17       	cp	r18, r22
    66e2:	37 07       	cpc	r19, r23
    66e4:	48 07       	cpc	r20, r24
    66e6:	30 f4       	brcc	.+12     	; 0x66f4 <sqrt+0x40>
    66e8:	62 1b       	sub	r22, r18
    66ea:	73 0b       	sbc	r23, r19
    66ec:	84 0b       	sbc	r24, r20
    66ee:	20 29       	or	r18, r0
    66f0:	31 29       	or	r19, r1
    66f2:	4a 2b       	or	r20, r26
    66f4:	a6 95       	lsr	r26
    66f6:	17 94       	ror	r1
    66f8:	07 94       	ror	r0
    66fa:	20 25       	eor	r18, r0
    66fc:	31 25       	eor	r19, r1
    66fe:	4a 27       	eor	r20, r26
    6700:	58 f7       	brcc	.-42     	; 0x66d8 <sqrt+0x24>
    6702:	66 0f       	add	r22, r22
    6704:	77 1f       	adc	r23, r23
    6706:	88 1f       	adc	r24, r24
    6708:	20 f0       	brcs	.+8      	; 0x6712 <sqrt+0x5e>
    670a:	26 17       	cp	r18, r22
    670c:	37 07       	cpc	r19, r23
    670e:	48 07       	cpc	r20, r24
    6710:	30 f4       	brcc	.+12     	; 0x671e <sqrt+0x6a>
    6712:	62 0b       	sbc	r22, r18
    6714:	73 0b       	sbc	r23, r19
    6716:	84 0b       	sbc	r24, r20
    6718:	20 0d       	add	r18, r0
    671a:	31 1d       	adc	r19, r1
    671c:	41 1d       	adc	r20, r1
    671e:	a0 95       	com	r26
    6720:	81 f7       	brne	.-32     	; 0x6702 <sqrt+0x4e>
    6722:	b9 01       	movw	r22, r18
    6724:	84 2f       	mov	r24, r20
    6726:	91 58       	subi	r25, 0x81	; 129
    6728:	88 0f       	add	r24, r24
    672a:	96 95       	lsr	r25
    672c:	87 95       	ror	r24
    672e:	08 95       	ret

00006730 <square>:
    6730:	9b 01       	movw	r18, r22
    6732:	ac 01       	movw	r20, r24
    6734:	52 cf       	rjmp	.-348    	; 0x65da <__mulsf3>

00006736 <__fp_mpack>:
    6736:	9f 3f       	cpi	r25, 0xFF	; 255
    6738:	31 f0       	breq	.+12     	; 0x6746 <__fp_mpack_finite+0xc>

0000673a <__fp_mpack_finite>:
    673a:	91 50       	subi	r25, 0x01	; 1
    673c:	20 f4       	brcc	.+8      	; 0x6746 <__fp_mpack_finite+0xc>
    673e:	87 95       	ror	r24
    6740:	77 95       	ror	r23
    6742:	67 95       	ror	r22
    6744:	b7 95       	ror	r27
    6746:	88 0f       	add	r24, r24
    6748:	91 1d       	adc	r25, r1
    674a:	96 95       	lsr	r25
    674c:	87 95       	ror	r24
    674e:	97 f9       	bld	r25, 7
    6750:	08 95       	ret

00006752 <__fp_norm2>:
    6752:	91 50       	subi	r25, 0x01	; 1
    6754:	50 40       	sbci	r21, 0x00	; 0
    6756:	66 0f       	add	r22, r22
    6758:	77 1f       	adc	r23, r23
    675a:	88 1f       	adc	r24, r24
    675c:	d2 f7       	brpl	.-12     	; 0x6752 <__fp_norm2>
    675e:	08 95       	ret

00006760 <__fp_powsodd>:
    6760:	9f 93       	push	r25
    6762:	8f 93       	push	r24
    6764:	7f 93       	push	r23
    6766:	6f 93       	push	r22
    6768:	ff 93       	push	r31
    676a:	ef 93       	push	r30
    676c:	9b 01       	movw	r18, r22
    676e:	ac 01       	movw	r20, r24
    6770:	34 df       	rcall	.-408    	; 0x65da <__mulsf3>
    6772:	ef 91       	pop	r30
    6774:	ff 91       	pop	r31
    6776:	80 de       	rcall	.-768    	; 0x6478 <__fp_powser>
    6778:	2f 91       	pop	r18
    677a:	3f 91       	pop	r19
    677c:	4f 91       	pop	r20
    677e:	5f 91       	pop	r21
    6780:	2c cf       	rjmp	.-424    	; 0x65da <__mulsf3>

00006782 <vfprintf>:
    6782:	2f 92       	push	r2
    6784:	3f 92       	push	r3
    6786:	4f 92       	push	r4
    6788:	5f 92       	push	r5
    678a:	6f 92       	push	r6
    678c:	7f 92       	push	r7
    678e:	8f 92       	push	r8
    6790:	9f 92       	push	r9
    6792:	af 92       	push	r10
    6794:	bf 92       	push	r11
    6796:	cf 92       	push	r12
    6798:	df 92       	push	r13
    679a:	ef 92       	push	r14
    679c:	ff 92       	push	r15
    679e:	0f 93       	push	r16
    67a0:	1f 93       	push	r17
    67a2:	cf 93       	push	r28
    67a4:	df 93       	push	r29
    67a6:	cd b7       	in	r28, 0x3d	; 61
    67a8:	de b7       	in	r29, 0x3e	; 62
    67aa:	60 97       	sbiw	r28, 0x10	; 16
    67ac:	0f b6       	in	r0, 0x3f	; 63
    67ae:	f8 94       	cli
    67b0:	de bf       	out	0x3e, r29	; 62
    67b2:	0f be       	out	0x3f, r0	; 63
    67b4:	cd bf       	out	0x3d, r28	; 61
    67b6:	7c 01       	movw	r14, r24
    67b8:	1b 01       	movw	r2, r22
    67ba:	6a 01       	movw	r12, r20
    67bc:	fc 01       	movw	r30, r24
    67be:	17 82       	std	Z+7, r1	; 0x07
    67c0:	16 82       	std	Z+6, r1	; 0x06
    67c2:	83 81       	ldd	r24, Z+3	; 0x03
    67c4:	81 ff       	sbrs	r24, 1
    67c6:	2a c3       	rjmp	.+1620   	; 0x6e1c <vfprintf+0x69a>
    67c8:	9e 01       	movw	r18, r28
    67ca:	2f 5f       	subi	r18, 0xFF	; 255
    67cc:	3f 4f       	sbci	r19, 0xFF	; 255
    67ce:	39 01       	movw	r6, r18
    67d0:	f7 01       	movw	r30, r14
    67d2:	93 81       	ldd	r25, Z+3	; 0x03
    67d4:	f1 01       	movw	r30, r2
    67d6:	93 fd       	sbrc	r25, 3
    67d8:	85 91       	lpm	r24, Z+
    67da:	93 ff       	sbrs	r25, 3
    67dc:	81 91       	ld	r24, Z+
    67de:	1f 01       	movw	r2, r30
    67e0:	88 23       	and	r24, r24
    67e2:	09 f4       	brne	.+2      	; 0x67e6 <vfprintf+0x64>
    67e4:	17 c3       	rjmp	.+1582   	; 0x6e14 <vfprintf+0x692>
    67e6:	85 32       	cpi	r24, 0x25	; 37
    67e8:	39 f4       	brne	.+14     	; 0x67f8 <vfprintf+0x76>
    67ea:	93 fd       	sbrc	r25, 3
    67ec:	85 91       	lpm	r24, Z+
    67ee:	93 ff       	sbrs	r25, 3
    67f0:	81 91       	ld	r24, Z+
    67f2:	1f 01       	movw	r2, r30
    67f4:	85 32       	cpi	r24, 0x25	; 37
    67f6:	31 f4       	brne	.+12     	; 0x6804 <vfprintf+0x82>
    67f8:	b7 01       	movw	r22, r14
    67fa:	90 e0       	ldi	r25, 0x00	; 0
    67fc:	78 d4       	rcall	.+2288   	; 0x70ee <fputc>
    67fe:	56 01       	movw	r10, r12
    6800:	65 01       	movw	r12, r10
    6802:	e6 cf       	rjmp	.-52     	; 0x67d0 <vfprintf+0x4e>
    6804:	10 e0       	ldi	r17, 0x00	; 0
    6806:	51 2c       	mov	r5, r1
    6808:	91 2c       	mov	r9, r1
    680a:	ff e1       	ldi	r31, 0x1F	; 31
    680c:	f9 15       	cp	r31, r9
    680e:	d8 f0       	brcs	.+54     	; 0x6846 <vfprintf+0xc4>
    6810:	8b 32       	cpi	r24, 0x2B	; 43
    6812:	79 f0       	breq	.+30     	; 0x6832 <vfprintf+0xb0>
    6814:	38 f4       	brcc	.+14     	; 0x6824 <vfprintf+0xa2>
    6816:	80 32       	cpi	r24, 0x20	; 32
    6818:	79 f0       	breq	.+30     	; 0x6838 <vfprintf+0xb6>
    681a:	83 32       	cpi	r24, 0x23	; 35
    681c:	a1 f4       	brne	.+40     	; 0x6846 <vfprintf+0xc4>
    681e:	f9 2d       	mov	r31, r9
    6820:	f0 61       	ori	r31, 0x10	; 16
    6822:	2e c0       	rjmp	.+92     	; 0x6880 <vfprintf+0xfe>
    6824:	8d 32       	cpi	r24, 0x2D	; 45
    6826:	61 f0       	breq	.+24     	; 0x6840 <vfprintf+0xbe>
    6828:	80 33       	cpi	r24, 0x30	; 48
    682a:	69 f4       	brne	.+26     	; 0x6846 <vfprintf+0xc4>
    682c:	29 2d       	mov	r18, r9
    682e:	21 60       	ori	r18, 0x01	; 1
    6830:	2d c0       	rjmp	.+90     	; 0x688c <vfprintf+0x10a>
    6832:	39 2d       	mov	r19, r9
    6834:	32 60       	ori	r19, 0x02	; 2
    6836:	93 2e       	mov	r9, r19
    6838:	89 2d       	mov	r24, r9
    683a:	84 60       	ori	r24, 0x04	; 4
    683c:	98 2e       	mov	r9, r24
    683e:	2a c0       	rjmp	.+84     	; 0x6894 <vfprintf+0x112>
    6840:	e9 2d       	mov	r30, r9
    6842:	e8 60       	ori	r30, 0x08	; 8
    6844:	15 c0       	rjmp	.+42     	; 0x6870 <vfprintf+0xee>
    6846:	97 fc       	sbrc	r9, 7
    6848:	2d c0       	rjmp	.+90     	; 0x68a4 <vfprintf+0x122>
    684a:	20 ed       	ldi	r18, 0xD0	; 208
    684c:	28 0f       	add	r18, r24
    684e:	2a 30       	cpi	r18, 0x0A	; 10
    6850:	88 f4       	brcc	.+34     	; 0x6874 <vfprintf+0xf2>
    6852:	96 fe       	sbrs	r9, 6
    6854:	06 c0       	rjmp	.+12     	; 0x6862 <vfprintf+0xe0>
    6856:	3a e0       	ldi	r19, 0x0A	; 10
    6858:	13 9f       	mul	r17, r19
    685a:	20 0d       	add	r18, r0
    685c:	11 24       	eor	r1, r1
    685e:	12 2f       	mov	r17, r18
    6860:	19 c0       	rjmp	.+50     	; 0x6894 <vfprintf+0x112>
    6862:	8a e0       	ldi	r24, 0x0A	; 10
    6864:	58 9e       	mul	r5, r24
    6866:	20 0d       	add	r18, r0
    6868:	11 24       	eor	r1, r1
    686a:	52 2e       	mov	r5, r18
    686c:	e9 2d       	mov	r30, r9
    686e:	e0 62       	ori	r30, 0x20	; 32
    6870:	9e 2e       	mov	r9, r30
    6872:	10 c0       	rjmp	.+32     	; 0x6894 <vfprintf+0x112>
    6874:	8e 32       	cpi	r24, 0x2E	; 46
    6876:	31 f4       	brne	.+12     	; 0x6884 <vfprintf+0x102>
    6878:	96 fc       	sbrc	r9, 6
    687a:	cc c2       	rjmp	.+1432   	; 0x6e14 <vfprintf+0x692>
    687c:	f9 2d       	mov	r31, r9
    687e:	f0 64       	ori	r31, 0x40	; 64
    6880:	9f 2e       	mov	r9, r31
    6882:	08 c0       	rjmp	.+16     	; 0x6894 <vfprintf+0x112>
    6884:	8c 36       	cpi	r24, 0x6C	; 108
    6886:	21 f4       	brne	.+8      	; 0x6890 <vfprintf+0x10e>
    6888:	29 2d       	mov	r18, r9
    688a:	20 68       	ori	r18, 0x80	; 128
    688c:	92 2e       	mov	r9, r18
    688e:	02 c0       	rjmp	.+4      	; 0x6894 <vfprintf+0x112>
    6890:	88 36       	cpi	r24, 0x68	; 104
    6892:	41 f4       	brne	.+16     	; 0x68a4 <vfprintf+0x122>
    6894:	f1 01       	movw	r30, r2
    6896:	93 fd       	sbrc	r25, 3
    6898:	85 91       	lpm	r24, Z+
    689a:	93 ff       	sbrs	r25, 3
    689c:	81 91       	ld	r24, Z+
    689e:	1f 01       	movw	r2, r30
    68a0:	81 11       	cpse	r24, r1
    68a2:	b3 cf       	rjmp	.-154    	; 0x680a <vfprintf+0x88>
    68a4:	9b eb       	ldi	r25, 0xBB	; 187
    68a6:	98 0f       	add	r25, r24
    68a8:	93 30       	cpi	r25, 0x03	; 3
    68aa:	20 f4       	brcc	.+8      	; 0x68b4 <vfprintf+0x132>
    68ac:	99 2d       	mov	r25, r9
    68ae:	90 61       	ori	r25, 0x10	; 16
    68b0:	80 5e       	subi	r24, 0xE0	; 224
    68b2:	07 c0       	rjmp	.+14     	; 0x68c2 <vfprintf+0x140>
    68b4:	9b e9       	ldi	r25, 0x9B	; 155
    68b6:	98 0f       	add	r25, r24
    68b8:	93 30       	cpi	r25, 0x03	; 3
    68ba:	08 f0       	brcs	.+2      	; 0x68be <vfprintf+0x13c>
    68bc:	59 c1       	rjmp	.+690    	; 0x6b70 <vfprintf+0x3ee>
    68be:	99 2d       	mov	r25, r9
    68c0:	9f 7e       	andi	r25, 0xEF	; 239
    68c2:	96 ff       	sbrs	r25, 6
    68c4:	16 e0       	ldi	r17, 0x06	; 6
    68c6:	9f 73       	andi	r25, 0x3F	; 63
    68c8:	99 2e       	mov	r9, r25
    68ca:	85 36       	cpi	r24, 0x65	; 101
    68cc:	19 f4       	brne	.+6      	; 0x68d4 <vfprintf+0x152>
    68ce:	90 64       	ori	r25, 0x40	; 64
    68d0:	99 2e       	mov	r9, r25
    68d2:	08 c0       	rjmp	.+16     	; 0x68e4 <vfprintf+0x162>
    68d4:	86 36       	cpi	r24, 0x66	; 102
    68d6:	21 f4       	brne	.+8      	; 0x68e0 <vfprintf+0x15e>
    68d8:	39 2f       	mov	r19, r25
    68da:	30 68       	ori	r19, 0x80	; 128
    68dc:	93 2e       	mov	r9, r19
    68de:	02 c0       	rjmp	.+4      	; 0x68e4 <vfprintf+0x162>
    68e0:	11 11       	cpse	r17, r1
    68e2:	11 50       	subi	r17, 0x01	; 1
    68e4:	97 fe       	sbrs	r9, 7
    68e6:	07 c0       	rjmp	.+14     	; 0x68f6 <vfprintf+0x174>
    68e8:	1c 33       	cpi	r17, 0x3C	; 60
    68ea:	50 f4       	brcc	.+20     	; 0x6900 <vfprintf+0x17e>
    68ec:	44 24       	eor	r4, r4
    68ee:	43 94       	inc	r4
    68f0:	41 0e       	add	r4, r17
    68f2:	27 e0       	ldi	r18, 0x07	; 7
    68f4:	0b c0       	rjmp	.+22     	; 0x690c <vfprintf+0x18a>
    68f6:	18 30       	cpi	r17, 0x08	; 8
    68f8:	38 f0       	brcs	.+14     	; 0x6908 <vfprintf+0x186>
    68fa:	27 e0       	ldi	r18, 0x07	; 7
    68fc:	17 e0       	ldi	r17, 0x07	; 7
    68fe:	05 c0       	rjmp	.+10     	; 0x690a <vfprintf+0x188>
    6900:	27 e0       	ldi	r18, 0x07	; 7
    6902:	9c e3       	ldi	r25, 0x3C	; 60
    6904:	49 2e       	mov	r4, r25
    6906:	02 c0       	rjmp	.+4      	; 0x690c <vfprintf+0x18a>
    6908:	21 2f       	mov	r18, r17
    690a:	41 2c       	mov	r4, r1
    690c:	56 01       	movw	r10, r12
    690e:	84 e0       	ldi	r24, 0x04	; 4
    6910:	a8 0e       	add	r10, r24
    6912:	b1 1c       	adc	r11, r1
    6914:	f6 01       	movw	r30, r12
    6916:	60 81       	ld	r22, Z
    6918:	71 81       	ldd	r23, Z+1	; 0x01
    691a:	82 81       	ldd	r24, Z+2	; 0x02
    691c:	93 81       	ldd	r25, Z+3	; 0x03
    691e:	04 2d       	mov	r16, r4
    6920:	a3 01       	movw	r20, r6
    6922:	ee d2       	rcall	.+1500   	; 0x6f00 <__ftoa_engine>
    6924:	6c 01       	movw	r12, r24
    6926:	f9 81       	ldd	r31, Y+1	; 0x01
    6928:	fc 87       	std	Y+12, r31	; 0x0c
    692a:	f0 ff       	sbrs	r31, 0
    692c:	02 c0       	rjmp	.+4      	; 0x6932 <vfprintf+0x1b0>
    692e:	f3 ff       	sbrs	r31, 3
    6930:	06 c0       	rjmp	.+12     	; 0x693e <vfprintf+0x1bc>
    6932:	91 fc       	sbrc	r9, 1
    6934:	06 c0       	rjmp	.+12     	; 0x6942 <vfprintf+0x1c0>
    6936:	92 fe       	sbrs	r9, 2
    6938:	06 c0       	rjmp	.+12     	; 0x6946 <vfprintf+0x1c4>
    693a:	00 e2       	ldi	r16, 0x20	; 32
    693c:	05 c0       	rjmp	.+10     	; 0x6948 <vfprintf+0x1c6>
    693e:	0d e2       	ldi	r16, 0x2D	; 45
    6940:	03 c0       	rjmp	.+6      	; 0x6948 <vfprintf+0x1c6>
    6942:	0b e2       	ldi	r16, 0x2B	; 43
    6944:	01 c0       	rjmp	.+2      	; 0x6948 <vfprintf+0x1c6>
    6946:	00 e0       	ldi	r16, 0x00	; 0
    6948:	8c 85       	ldd	r24, Y+12	; 0x0c
    694a:	8c 70       	andi	r24, 0x0C	; 12
    694c:	19 f0       	breq	.+6      	; 0x6954 <vfprintf+0x1d2>
    694e:	01 11       	cpse	r16, r1
    6950:	43 c2       	rjmp	.+1158   	; 0x6dd8 <vfprintf+0x656>
    6952:	80 c2       	rjmp	.+1280   	; 0x6e54 <vfprintf+0x6d2>
    6954:	97 fe       	sbrs	r9, 7
    6956:	10 c0       	rjmp	.+32     	; 0x6978 <vfprintf+0x1f6>
    6958:	4c 0c       	add	r4, r12
    695a:	fc 85       	ldd	r31, Y+12	; 0x0c
    695c:	f4 ff       	sbrs	r31, 4
    695e:	04 c0       	rjmp	.+8      	; 0x6968 <vfprintf+0x1e6>
    6960:	8a 81       	ldd	r24, Y+2	; 0x02
    6962:	81 33       	cpi	r24, 0x31	; 49
    6964:	09 f4       	brne	.+2      	; 0x6968 <vfprintf+0x1e6>
    6966:	4a 94       	dec	r4
    6968:	14 14       	cp	r1, r4
    696a:	74 f5       	brge	.+92     	; 0x69c8 <vfprintf+0x246>
    696c:	28 e0       	ldi	r18, 0x08	; 8
    696e:	24 15       	cp	r18, r4
    6970:	78 f5       	brcc	.+94     	; 0x69d0 <vfprintf+0x24e>
    6972:	88 e0       	ldi	r24, 0x08	; 8
    6974:	48 2e       	mov	r4, r24
    6976:	2c c0       	rjmp	.+88     	; 0x69d0 <vfprintf+0x24e>
    6978:	96 fc       	sbrc	r9, 6
    697a:	2a c0       	rjmp	.+84     	; 0x69d0 <vfprintf+0x24e>
    697c:	81 2f       	mov	r24, r17
    697e:	90 e0       	ldi	r25, 0x00	; 0
    6980:	8c 15       	cp	r24, r12
    6982:	9d 05       	cpc	r25, r13
    6984:	9c f0       	brlt	.+38     	; 0x69ac <vfprintf+0x22a>
    6986:	3c ef       	ldi	r19, 0xFC	; 252
    6988:	c3 16       	cp	r12, r19
    698a:	3f ef       	ldi	r19, 0xFF	; 255
    698c:	d3 06       	cpc	r13, r19
    698e:	74 f0       	brlt	.+28     	; 0x69ac <vfprintf+0x22a>
    6990:	89 2d       	mov	r24, r9
    6992:	80 68       	ori	r24, 0x80	; 128
    6994:	98 2e       	mov	r9, r24
    6996:	0a c0       	rjmp	.+20     	; 0x69ac <vfprintf+0x22a>
    6998:	e2 e0       	ldi	r30, 0x02	; 2
    699a:	f0 e0       	ldi	r31, 0x00	; 0
    699c:	ec 0f       	add	r30, r28
    699e:	fd 1f       	adc	r31, r29
    69a0:	e1 0f       	add	r30, r17
    69a2:	f1 1d       	adc	r31, r1
    69a4:	80 81       	ld	r24, Z
    69a6:	80 33       	cpi	r24, 0x30	; 48
    69a8:	19 f4       	brne	.+6      	; 0x69b0 <vfprintf+0x22e>
    69aa:	11 50       	subi	r17, 0x01	; 1
    69ac:	11 11       	cpse	r17, r1
    69ae:	f4 cf       	rjmp	.-24     	; 0x6998 <vfprintf+0x216>
    69b0:	97 fe       	sbrs	r9, 7
    69b2:	0e c0       	rjmp	.+28     	; 0x69d0 <vfprintf+0x24e>
    69b4:	44 24       	eor	r4, r4
    69b6:	43 94       	inc	r4
    69b8:	41 0e       	add	r4, r17
    69ba:	81 2f       	mov	r24, r17
    69bc:	90 e0       	ldi	r25, 0x00	; 0
    69be:	c8 16       	cp	r12, r24
    69c0:	d9 06       	cpc	r13, r25
    69c2:	2c f4       	brge	.+10     	; 0x69ce <vfprintf+0x24c>
    69c4:	1c 19       	sub	r17, r12
    69c6:	04 c0       	rjmp	.+8      	; 0x69d0 <vfprintf+0x24e>
    69c8:	44 24       	eor	r4, r4
    69ca:	43 94       	inc	r4
    69cc:	01 c0       	rjmp	.+2      	; 0x69d0 <vfprintf+0x24e>
    69ce:	10 e0       	ldi	r17, 0x00	; 0
    69d0:	97 fe       	sbrs	r9, 7
    69d2:	06 c0       	rjmp	.+12     	; 0x69e0 <vfprintf+0x25e>
    69d4:	1c 14       	cp	r1, r12
    69d6:	1d 04       	cpc	r1, r13
    69d8:	34 f4       	brge	.+12     	; 0x69e6 <vfprintf+0x264>
    69da:	c6 01       	movw	r24, r12
    69dc:	01 96       	adiw	r24, 0x01	; 1
    69de:	05 c0       	rjmp	.+10     	; 0x69ea <vfprintf+0x268>
    69e0:	85 e0       	ldi	r24, 0x05	; 5
    69e2:	90 e0       	ldi	r25, 0x00	; 0
    69e4:	02 c0       	rjmp	.+4      	; 0x69ea <vfprintf+0x268>
    69e6:	81 e0       	ldi	r24, 0x01	; 1
    69e8:	90 e0       	ldi	r25, 0x00	; 0
    69ea:	01 11       	cpse	r16, r1
    69ec:	01 96       	adiw	r24, 0x01	; 1
    69ee:	11 23       	and	r17, r17
    69f0:	31 f0       	breq	.+12     	; 0x69fe <vfprintf+0x27c>
    69f2:	21 2f       	mov	r18, r17
    69f4:	30 e0       	ldi	r19, 0x00	; 0
    69f6:	2f 5f       	subi	r18, 0xFF	; 255
    69f8:	3f 4f       	sbci	r19, 0xFF	; 255
    69fa:	82 0f       	add	r24, r18
    69fc:	93 1f       	adc	r25, r19
    69fe:	25 2d       	mov	r18, r5
    6a00:	30 e0       	ldi	r19, 0x00	; 0
    6a02:	82 17       	cp	r24, r18
    6a04:	93 07       	cpc	r25, r19
    6a06:	14 f4       	brge	.+4      	; 0x6a0c <vfprintf+0x28a>
    6a08:	58 1a       	sub	r5, r24
    6a0a:	01 c0       	rjmp	.+2      	; 0x6a0e <vfprintf+0x28c>
    6a0c:	51 2c       	mov	r5, r1
    6a0e:	89 2d       	mov	r24, r9
    6a10:	89 70       	andi	r24, 0x09	; 9
    6a12:	41 f4       	brne	.+16     	; 0x6a24 <vfprintf+0x2a2>
    6a14:	55 20       	and	r5, r5
    6a16:	31 f0       	breq	.+12     	; 0x6a24 <vfprintf+0x2a2>
    6a18:	b7 01       	movw	r22, r14
    6a1a:	80 e2       	ldi	r24, 0x20	; 32
    6a1c:	90 e0       	ldi	r25, 0x00	; 0
    6a1e:	67 d3       	rcall	.+1742   	; 0x70ee <fputc>
    6a20:	5a 94       	dec	r5
    6a22:	f8 cf       	rjmp	.-16     	; 0x6a14 <vfprintf+0x292>
    6a24:	00 23       	and	r16, r16
    6a26:	21 f0       	breq	.+8      	; 0x6a30 <vfprintf+0x2ae>
    6a28:	b7 01       	movw	r22, r14
    6a2a:	80 2f       	mov	r24, r16
    6a2c:	90 e0       	ldi	r25, 0x00	; 0
    6a2e:	5f d3       	rcall	.+1726   	; 0x70ee <fputc>
    6a30:	93 fc       	sbrc	r9, 3
    6a32:	08 c0       	rjmp	.+16     	; 0x6a44 <vfprintf+0x2c2>
    6a34:	55 20       	and	r5, r5
    6a36:	31 f0       	breq	.+12     	; 0x6a44 <vfprintf+0x2c2>
    6a38:	b7 01       	movw	r22, r14
    6a3a:	80 e3       	ldi	r24, 0x30	; 48
    6a3c:	90 e0       	ldi	r25, 0x00	; 0
    6a3e:	57 d3       	rcall	.+1710   	; 0x70ee <fputc>
    6a40:	5a 94       	dec	r5
    6a42:	f8 cf       	rjmp	.-16     	; 0x6a34 <vfprintf+0x2b2>
    6a44:	97 fe       	sbrs	r9, 7
    6a46:	4a c0       	rjmp	.+148    	; 0x6adc <vfprintf+0x35a>
    6a48:	46 01       	movw	r8, r12
    6a4a:	d7 fe       	sbrs	r13, 7
    6a4c:	02 c0       	rjmp	.+4      	; 0x6a52 <vfprintf+0x2d0>
    6a4e:	81 2c       	mov	r8, r1
    6a50:	91 2c       	mov	r9, r1
    6a52:	c6 01       	movw	r24, r12
    6a54:	88 19       	sub	r24, r8
    6a56:	99 09       	sbc	r25, r9
    6a58:	f3 01       	movw	r30, r6
    6a5a:	e8 0f       	add	r30, r24
    6a5c:	f9 1f       	adc	r31, r25
    6a5e:	fe 87       	std	Y+14, r31	; 0x0e
    6a60:	ed 87       	std	Y+13, r30	; 0x0d
    6a62:	96 01       	movw	r18, r12
    6a64:	24 19       	sub	r18, r4
    6a66:	31 09       	sbc	r19, r1
    6a68:	38 8b       	std	Y+16, r19	; 0x10
    6a6a:	2f 87       	std	Y+15, r18	; 0x0f
    6a6c:	01 2f       	mov	r16, r17
    6a6e:	10 e0       	ldi	r17, 0x00	; 0
    6a70:	11 95       	neg	r17
    6a72:	01 95       	neg	r16
    6a74:	11 09       	sbc	r17, r1
    6a76:	3f ef       	ldi	r19, 0xFF	; 255
    6a78:	83 16       	cp	r8, r19
    6a7a:	93 06       	cpc	r9, r19
    6a7c:	21 f4       	brne	.+8      	; 0x6a86 <vfprintf+0x304>
    6a7e:	b7 01       	movw	r22, r14
    6a80:	8e e2       	ldi	r24, 0x2E	; 46
    6a82:	90 e0       	ldi	r25, 0x00	; 0
    6a84:	34 d3       	rcall	.+1640   	; 0x70ee <fputc>
    6a86:	c8 14       	cp	r12, r8
    6a88:	d9 04       	cpc	r13, r9
    6a8a:	4c f0       	brlt	.+18     	; 0x6a9e <vfprintf+0x31c>
    6a8c:	8f 85       	ldd	r24, Y+15	; 0x0f
    6a8e:	98 89       	ldd	r25, Y+16	; 0x10
    6a90:	88 15       	cp	r24, r8
    6a92:	99 05       	cpc	r25, r9
    6a94:	24 f4       	brge	.+8      	; 0x6a9e <vfprintf+0x31c>
    6a96:	ed 85       	ldd	r30, Y+13	; 0x0d
    6a98:	fe 85       	ldd	r31, Y+14	; 0x0e
    6a9a:	81 81       	ldd	r24, Z+1	; 0x01
    6a9c:	01 c0       	rjmp	.+2      	; 0x6aa0 <vfprintf+0x31e>
    6a9e:	80 e3       	ldi	r24, 0x30	; 48
    6aa0:	f1 e0       	ldi	r31, 0x01	; 1
    6aa2:	8f 1a       	sub	r8, r31
    6aa4:	91 08       	sbc	r9, r1
    6aa6:	2d 85       	ldd	r18, Y+13	; 0x0d
    6aa8:	3e 85       	ldd	r19, Y+14	; 0x0e
    6aaa:	2f 5f       	subi	r18, 0xFF	; 255
    6aac:	3f 4f       	sbci	r19, 0xFF	; 255
    6aae:	3e 87       	std	Y+14, r19	; 0x0e
    6ab0:	2d 87       	std	Y+13, r18	; 0x0d
    6ab2:	80 16       	cp	r8, r16
    6ab4:	91 06       	cpc	r9, r17
    6ab6:	24 f0       	brlt	.+8      	; 0x6ac0 <vfprintf+0x33e>
    6ab8:	b7 01       	movw	r22, r14
    6aba:	90 e0       	ldi	r25, 0x00	; 0
    6abc:	18 d3       	rcall	.+1584   	; 0x70ee <fputc>
    6abe:	db cf       	rjmp	.-74     	; 0x6a76 <vfprintf+0x2f4>
    6ac0:	c8 14       	cp	r12, r8
    6ac2:	d9 04       	cpc	r13, r9
    6ac4:	41 f4       	brne	.+16     	; 0x6ad6 <vfprintf+0x354>
    6ac6:	9a 81       	ldd	r25, Y+2	; 0x02
    6ac8:	96 33       	cpi	r25, 0x36	; 54
    6aca:	20 f4       	brcc	.+8      	; 0x6ad4 <vfprintf+0x352>
    6acc:	95 33       	cpi	r25, 0x35	; 53
    6ace:	19 f4       	brne	.+6      	; 0x6ad6 <vfprintf+0x354>
    6ad0:	3c 85       	ldd	r19, Y+12	; 0x0c
    6ad2:	34 ff       	sbrs	r19, 4
    6ad4:	81 e3       	ldi	r24, 0x31	; 49
    6ad6:	b7 01       	movw	r22, r14
    6ad8:	90 e0       	ldi	r25, 0x00	; 0
    6ada:	48 c0       	rjmp	.+144    	; 0x6b6c <vfprintf+0x3ea>
    6adc:	8a 81       	ldd	r24, Y+2	; 0x02
    6ade:	81 33       	cpi	r24, 0x31	; 49
    6ae0:	19 f0       	breq	.+6      	; 0x6ae8 <vfprintf+0x366>
    6ae2:	9c 85       	ldd	r25, Y+12	; 0x0c
    6ae4:	9f 7e       	andi	r25, 0xEF	; 239
    6ae6:	9c 87       	std	Y+12, r25	; 0x0c
    6ae8:	b7 01       	movw	r22, r14
    6aea:	90 e0       	ldi	r25, 0x00	; 0
    6aec:	00 d3       	rcall	.+1536   	; 0x70ee <fputc>
    6aee:	11 11       	cpse	r17, r1
    6af0:	05 c0       	rjmp	.+10     	; 0x6afc <vfprintf+0x37a>
    6af2:	94 fc       	sbrc	r9, 4
    6af4:	16 c0       	rjmp	.+44     	; 0x6b22 <vfprintf+0x3a0>
    6af6:	85 e6       	ldi	r24, 0x65	; 101
    6af8:	90 e0       	ldi	r25, 0x00	; 0
    6afa:	15 c0       	rjmp	.+42     	; 0x6b26 <vfprintf+0x3a4>
    6afc:	b7 01       	movw	r22, r14
    6afe:	8e e2       	ldi	r24, 0x2E	; 46
    6b00:	90 e0       	ldi	r25, 0x00	; 0
    6b02:	f5 d2       	rcall	.+1514   	; 0x70ee <fputc>
    6b04:	1e 5f       	subi	r17, 0xFE	; 254
    6b06:	82 e0       	ldi	r24, 0x02	; 2
    6b08:	01 e0       	ldi	r16, 0x01	; 1
    6b0a:	08 0f       	add	r16, r24
    6b0c:	f3 01       	movw	r30, r6
    6b0e:	e8 0f       	add	r30, r24
    6b10:	f1 1d       	adc	r31, r1
    6b12:	80 81       	ld	r24, Z
    6b14:	b7 01       	movw	r22, r14
    6b16:	90 e0       	ldi	r25, 0x00	; 0
    6b18:	ea d2       	rcall	.+1492   	; 0x70ee <fputc>
    6b1a:	80 2f       	mov	r24, r16
    6b1c:	01 13       	cpse	r16, r17
    6b1e:	f4 cf       	rjmp	.-24     	; 0x6b08 <vfprintf+0x386>
    6b20:	e8 cf       	rjmp	.-48     	; 0x6af2 <vfprintf+0x370>
    6b22:	85 e4       	ldi	r24, 0x45	; 69
    6b24:	90 e0       	ldi	r25, 0x00	; 0
    6b26:	b7 01       	movw	r22, r14
    6b28:	e2 d2       	rcall	.+1476   	; 0x70ee <fputc>
    6b2a:	d7 fc       	sbrc	r13, 7
    6b2c:	06 c0       	rjmp	.+12     	; 0x6b3a <vfprintf+0x3b8>
    6b2e:	c1 14       	cp	r12, r1
    6b30:	d1 04       	cpc	r13, r1
    6b32:	41 f4       	brne	.+16     	; 0x6b44 <vfprintf+0x3c2>
    6b34:	ec 85       	ldd	r30, Y+12	; 0x0c
    6b36:	e4 ff       	sbrs	r30, 4
    6b38:	05 c0       	rjmp	.+10     	; 0x6b44 <vfprintf+0x3c2>
    6b3a:	d1 94       	neg	r13
    6b3c:	c1 94       	neg	r12
    6b3e:	d1 08       	sbc	r13, r1
    6b40:	8d e2       	ldi	r24, 0x2D	; 45
    6b42:	01 c0       	rjmp	.+2      	; 0x6b46 <vfprintf+0x3c4>
    6b44:	8b e2       	ldi	r24, 0x2B	; 43
    6b46:	b7 01       	movw	r22, r14
    6b48:	90 e0       	ldi	r25, 0x00	; 0
    6b4a:	d1 d2       	rcall	.+1442   	; 0x70ee <fputc>
    6b4c:	80 e3       	ldi	r24, 0x30	; 48
    6b4e:	2a e0       	ldi	r18, 0x0A	; 10
    6b50:	c2 16       	cp	r12, r18
    6b52:	d1 04       	cpc	r13, r1
    6b54:	2c f0       	brlt	.+10     	; 0x6b60 <vfprintf+0x3de>
    6b56:	8f 5f       	subi	r24, 0xFF	; 255
    6b58:	fa e0       	ldi	r31, 0x0A	; 10
    6b5a:	cf 1a       	sub	r12, r31
    6b5c:	d1 08       	sbc	r13, r1
    6b5e:	f7 cf       	rjmp	.-18     	; 0x6b4e <vfprintf+0x3cc>
    6b60:	b7 01       	movw	r22, r14
    6b62:	90 e0       	ldi	r25, 0x00	; 0
    6b64:	c4 d2       	rcall	.+1416   	; 0x70ee <fputc>
    6b66:	b7 01       	movw	r22, r14
    6b68:	c6 01       	movw	r24, r12
    6b6a:	c0 96       	adiw	r24, 0x30	; 48
    6b6c:	c0 d2       	rcall	.+1408   	; 0x70ee <fputc>
    6b6e:	49 c1       	rjmp	.+658    	; 0x6e02 <vfprintf+0x680>
    6b70:	83 36       	cpi	r24, 0x63	; 99
    6b72:	31 f0       	breq	.+12     	; 0x6b80 <vfprintf+0x3fe>
    6b74:	83 37       	cpi	r24, 0x73	; 115
    6b76:	79 f0       	breq	.+30     	; 0x6b96 <vfprintf+0x414>
    6b78:	83 35       	cpi	r24, 0x53	; 83
    6b7a:	09 f0       	breq	.+2      	; 0x6b7e <vfprintf+0x3fc>
    6b7c:	52 c0       	rjmp	.+164    	; 0x6c22 <vfprintf+0x4a0>
    6b7e:	1f c0       	rjmp	.+62     	; 0x6bbe <vfprintf+0x43c>
    6b80:	56 01       	movw	r10, r12
    6b82:	32 e0       	ldi	r19, 0x02	; 2
    6b84:	a3 0e       	add	r10, r19
    6b86:	b1 1c       	adc	r11, r1
    6b88:	f6 01       	movw	r30, r12
    6b8a:	80 81       	ld	r24, Z
    6b8c:	89 83       	std	Y+1, r24	; 0x01
    6b8e:	01 e0       	ldi	r16, 0x01	; 1
    6b90:	10 e0       	ldi	r17, 0x00	; 0
    6b92:	63 01       	movw	r12, r6
    6b94:	11 c0       	rjmp	.+34     	; 0x6bb8 <vfprintf+0x436>
    6b96:	56 01       	movw	r10, r12
    6b98:	f2 e0       	ldi	r31, 0x02	; 2
    6b9a:	af 0e       	add	r10, r31
    6b9c:	b1 1c       	adc	r11, r1
    6b9e:	f6 01       	movw	r30, r12
    6ba0:	c0 80       	ld	r12, Z
    6ba2:	d1 80       	ldd	r13, Z+1	; 0x01
    6ba4:	96 fe       	sbrs	r9, 6
    6ba6:	03 c0       	rjmp	.+6      	; 0x6bae <vfprintf+0x42c>
    6ba8:	61 2f       	mov	r22, r17
    6baa:	70 e0       	ldi	r23, 0x00	; 0
    6bac:	02 c0       	rjmp	.+4      	; 0x6bb2 <vfprintf+0x430>
    6bae:	6f ef       	ldi	r22, 0xFF	; 255
    6bb0:	7f ef       	ldi	r23, 0xFF	; 255
    6bb2:	c6 01       	movw	r24, r12
    6bb4:	91 d2       	rcall	.+1314   	; 0x70d8 <strnlen>
    6bb6:	8c 01       	movw	r16, r24
    6bb8:	f9 2d       	mov	r31, r9
    6bba:	ff 77       	andi	r31, 0x7F	; 127
    6bbc:	13 c0       	rjmp	.+38     	; 0x6be4 <vfprintf+0x462>
    6bbe:	56 01       	movw	r10, r12
    6bc0:	22 e0       	ldi	r18, 0x02	; 2
    6bc2:	a2 0e       	add	r10, r18
    6bc4:	b1 1c       	adc	r11, r1
    6bc6:	f6 01       	movw	r30, r12
    6bc8:	c0 80       	ld	r12, Z
    6bca:	d1 80       	ldd	r13, Z+1	; 0x01
    6bcc:	96 fe       	sbrs	r9, 6
    6bce:	03 c0       	rjmp	.+6      	; 0x6bd6 <vfprintf+0x454>
    6bd0:	61 2f       	mov	r22, r17
    6bd2:	70 e0       	ldi	r23, 0x00	; 0
    6bd4:	02 c0       	rjmp	.+4      	; 0x6bda <vfprintf+0x458>
    6bd6:	6f ef       	ldi	r22, 0xFF	; 255
    6bd8:	7f ef       	ldi	r23, 0xFF	; 255
    6bda:	c6 01       	movw	r24, r12
    6bdc:	69 d2       	rcall	.+1234   	; 0x70b0 <strnlen_P>
    6bde:	8c 01       	movw	r16, r24
    6be0:	f9 2d       	mov	r31, r9
    6be2:	f0 68       	ori	r31, 0x80	; 128
    6be4:	9f 2e       	mov	r9, r31
    6be6:	f3 fd       	sbrc	r31, 3
    6be8:	18 c0       	rjmp	.+48     	; 0x6c1a <vfprintf+0x498>
    6bea:	85 2d       	mov	r24, r5
    6bec:	90 e0       	ldi	r25, 0x00	; 0
    6bee:	08 17       	cp	r16, r24
    6bf0:	19 07       	cpc	r17, r25
    6bf2:	98 f4       	brcc	.+38     	; 0x6c1a <vfprintf+0x498>
    6bf4:	b7 01       	movw	r22, r14
    6bf6:	80 e2       	ldi	r24, 0x20	; 32
    6bf8:	90 e0       	ldi	r25, 0x00	; 0
    6bfa:	79 d2       	rcall	.+1266   	; 0x70ee <fputc>
    6bfc:	5a 94       	dec	r5
    6bfe:	f5 cf       	rjmp	.-22     	; 0x6bea <vfprintf+0x468>
    6c00:	f6 01       	movw	r30, r12
    6c02:	97 fc       	sbrc	r9, 7
    6c04:	85 91       	lpm	r24, Z+
    6c06:	97 fe       	sbrs	r9, 7
    6c08:	81 91       	ld	r24, Z+
    6c0a:	6f 01       	movw	r12, r30
    6c0c:	b7 01       	movw	r22, r14
    6c0e:	90 e0       	ldi	r25, 0x00	; 0
    6c10:	6e d2       	rcall	.+1244   	; 0x70ee <fputc>
    6c12:	51 10       	cpse	r5, r1
    6c14:	5a 94       	dec	r5
    6c16:	01 50       	subi	r16, 0x01	; 1
    6c18:	11 09       	sbc	r17, r1
    6c1a:	01 15       	cp	r16, r1
    6c1c:	11 05       	cpc	r17, r1
    6c1e:	81 f7       	brne	.-32     	; 0x6c00 <vfprintf+0x47e>
    6c20:	f0 c0       	rjmp	.+480    	; 0x6e02 <vfprintf+0x680>
    6c22:	84 36       	cpi	r24, 0x64	; 100
    6c24:	11 f0       	breq	.+4      	; 0x6c2a <vfprintf+0x4a8>
    6c26:	89 36       	cpi	r24, 0x69	; 105
    6c28:	59 f5       	brne	.+86     	; 0x6c80 <vfprintf+0x4fe>
    6c2a:	56 01       	movw	r10, r12
    6c2c:	97 fe       	sbrs	r9, 7
    6c2e:	09 c0       	rjmp	.+18     	; 0x6c42 <vfprintf+0x4c0>
    6c30:	24 e0       	ldi	r18, 0x04	; 4
    6c32:	a2 0e       	add	r10, r18
    6c34:	b1 1c       	adc	r11, r1
    6c36:	f6 01       	movw	r30, r12
    6c38:	60 81       	ld	r22, Z
    6c3a:	71 81       	ldd	r23, Z+1	; 0x01
    6c3c:	82 81       	ldd	r24, Z+2	; 0x02
    6c3e:	93 81       	ldd	r25, Z+3	; 0x03
    6c40:	0a c0       	rjmp	.+20     	; 0x6c56 <vfprintf+0x4d4>
    6c42:	f2 e0       	ldi	r31, 0x02	; 2
    6c44:	af 0e       	add	r10, r31
    6c46:	b1 1c       	adc	r11, r1
    6c48:	f6 01       	movw	r30, r12
    6c4a:	60 81       	ld	r22, Z
    6c4c:	71 81       	ldd	r23, Z+1	; 0x01
    6c4e:	07 2e       	mov	r0, r23
    6c50:	00 0c       	add	r0, r0
    6c52:	88 0b       	sbc	r24, r24
    6c54:	99 0b       	sbc	r25, r25
    6c56:	f9 2d       	mov	r31, r9
    6c58:	ff 76       	andi	r31, 0x6F	; 111
    6c5a:	9f 2e       	mov	r9, r31
    6c5c:	97 ff       	sbrs	r25, 7
    6c5e:	09 c0       	rjmp	.+18     	; 0x6c72 <vfprintf+0x4f0>
    6c60:	90 95       	com	r25
    6c62:	80 95       	com	r24
    6c64:	70 95       	com	r23
    6c66:	61 95       	neg	r22
    6c68:	7f 4f       	sbci	r23, 0xFF	; 255
    6c6a:	8f 4f       	sbci	r24, 0xFF	; 255
    6c6c:	9f 4f       	sbci	r25, 0xFF	; 255
    6c6e:	f0 68       	ori	r31, 0x80	; 128
    6c70:	9f 2e       	mov	r9, r31
    6c72:	2a e0       	ldi	r18, 0x0A	; 10
    6c74:	30 e0       	ldi	r19, 0x00	; 0
    6c76:	a3 01       	movw	r20, r6
    6c78:	9e d2       	rcall	.+1340   	; 0x71b6 <__ultoa_invert>
    6c7a:	c8 2e       	mov	r12, r24
    6c7c:	c6 18       	sub	r12, r6
    6c7e:	3e c0       	rjmp	.+124    	; 0x6cfc <vfprintf+0x57a>
    6c80:	09 2d       	mov	r16, r9
    6c82:	85 37       	cpi	r24, 0x75	; 117
    6c84:	21 f4       	brne	.+8      	; 0x6c8e <vfprintf+0x50c>
    6c86:	0f 7e       	andi	r16, 0xEF	; 239
    6c88:	2a e0       	ldi	r18, 0x0A	; 10
    6c8a:	30 e0       	ldi	r19, 0x00	; 0
    6c8c:	1d c0       	rjmp	.+58     	; 0x6cc8 <vfprintf+0x546>
    6c8e:	09 7f       	andi	r16, 0xF9	; 249
    6c90:	8f 36       	cpi	r24, 0x6F	; 111
    6c92:	91 f0       	breq	.+36     	; 0x6cb8 <vfprintf+0x536>
    6c94:	18 f4       	brcc	.+6      	; 0x6c9c <vfprintf+0x51a>
    6c96:	88 35       	cpi	r24, 0x58	; 88
    6c98:	59 f0       	breq	.+22     	; 0x6cb0 <vfprintf+0x52e>
    6c9a:	bc c0       	rjmp	.+376    	; 0x6e14 <vfprintf+0x692>
    6c9c:	80 37       	cpi	r24, 0x70	; 112
    6c9e:	19 f0       	breq	.+6      	; 0x6ca6 <vfprintf+0x524>
    6ca0:	88 37       	cpi	r24, 0x78	; 120
    6ca2:	11 f0       	breq	.+4      	; 0x6ca8 <vfprintf+0x526>
    6ca4:	b7 c0       	rjmp	.+366    	; 0x6e14 <vfprintf+0x692>
    6ca6:	00 61       	ori	r16, 0x10	; 16
    6ca8:	04 ff       	sbrs	r16, 4
    6caa:	09 c0       	rjmp	.+18     	; 0x6cbe <vfprintf+0x53c>
    6cac:	04 60       	ori	r16, 0x04	; 4
    6cae:	07 c0       	rjmp	.+14     	; 0x6cbe <vfprintf+0x53c>
    6cb0:	94 fe       	sbrs	r9, 4
    6cb2:	08 c0       	rjmp	.+16     	; 0x6cc4 <vfprintf+0x542>
    6cb4:	06 60       	ori	r16, 0x06	; 6
    6cb6:	06 c0       	rjmp	.+12     	; 0x6cc4 <vfprintf+0x542>
    6cb8:	28 e0       	ldi	r18, 0x08	; 8
    6cba:	30 e0       	ldi	r19, 0x00	; 0
    6cbc:	05 c0       	rjmp	.+10     	; 0x6cc8 <vfprintf+0x546>
    6cbe:	20 e1       	ldi	r18, 0x10	; 16
    6cc0:	30 e0       	ldi	r19, 0x00	; 0
    6cc2:	02 c0       	rjmp	.+4      	; 0x6cc8 <vfprintf+0x546>
    6cc4:	20 e1       	ldi	r18, 0x10	; 16
    6cc6:	32 e0       	ldi	r19, 0x02	; 2
    6cc8:	56 01       	movw	r10, r12
    6cca:	07 ff       	sbrs	r16, 7
    6ccc:	09 c0       	rjmp	.+18     	; 0x6ce0 <vfprintf+0x55e>
    6cce:	84 e0       	ldi	r24, 0x04	; 4
    6cd0:	a8 0e       	add	r10, r24
    6cd2:	b1 1c       	adc	r11, r1
    6cd4:	f6 01       	movw	r30, r12
    6cd6:	60 81       	ld	r22, Z
    6cd8:	71 81       	ldd	r23, Z+1	; 0x01
    6cda:	82 81       	ldd	r24, Z+2	; 0x02
    6cdc:	93 81       	ldd	r25, Z+3	; 0x03
    6cde:	08 c0       	rjmp	.+16     	; 0x6cf0 <vfprintf+0x56e>
    6ce0:	f2 e0       	ldi	r31, 0x02	; 2
    6ce2:	af 0e       	add	r10, r31
    6ce4:	b1 1c       	adc	r11, r1
    6ce6:	f6 01       	movw	r30, r12
    6ce8:	60 81       	ld	r22, Z
    6cea:	71 81       	ldd	r23, Z+1	; 0x01
    6cec:	80 e0       	ldi	r24, 0x00	; 0
    6cee:	90 e0       	ldi	r25, 0x00	; 0
    6cf0:	a3 01       	movw	r20, r6
    6cf2:	61 d2       	rcall	.+1218   	; 0x71b6 <__ultoa_invert>
    6cf4:	c8 2e       	mov	r12, r24
    6cf6:	c6 18       	sub	r12, r6
    6cf8:	0f 77       	andi	r16, 0x7F	; 127
    6cfa:	90 2e       	mov	r9, r16
    6cfc:	96 fe       	sbrs	r9, 6
    6cfe:	0b c0       	rjmp	.+22     	; 0x6d16 <vfprintf+0x594>
    6d00:	09 2d       	mov	r16, r9
    6d02:	0e 7f       	andi	r16, 0xFE	; 254
    6d04:	c1 16       	cp	r12, r17
    6d06:	50 f4       	brcc	.+20     	; 0x6d1c <vfprintf+0x59a>
    6d08:	94 fe       	sbrs	r9, 4
    6d0a:	0a c0       	rjmp	.+20     	; 0x6d20 <vfprintf+0x59e>
    6d0c:	92 fc       	sbrc	r9, 2
    6d0e:	08 c0       	rjmp	.+16     	; 0x6d20 <vfprintf+0x59e>
    6d10:	09 2d       	mov	r16, r9
    6d12:	0e 7e       	andi	r16, 0xEE	; 238
    6d14:	05 c0       	rjmp	.+10     	; 0x6d20 <vfprintf+0x59e>
    6d16:	dc 2c       	mov	r13, r12
    6d18:	09 2d       	mov	r16, r9
    6d1a:	03 c0       	rjmp	.+6      	; 0x6d22 <vfprintf+0x5a0>
    6d1c:	dc 2c       	mov	r13, r12
    6d1e:	01 c0       	rjmp	.+2      	; 0x6d22 <vfprintf+0x5a0>
    6d20:	d1 2e       	mov	r13, r17
    6d22:	04 ff       	sbrs	r16, 4
    6d24:	0d c0       	rjmp	.+26     	; 0x6d40 <vfprintf+0x5be>
    6d26:	fe 01       	movw	r30, r28
    6d28:	ec 0d       	add	r30, r12
    6d2a:	f1 1d       	adc	r31, r1
    6d2c:	80 81       	ld	r24, Z
    6d2e:	80 33       	cpi	r24, 0x30	; 48
    6d30:	11 f4       	brne	.+4      	; 0x6d36 <vfprintf+0x5b4>
    6d32:	09 7e       	andi	r16, 0xE9	; 233
    6d34:	09 c0       	rjmp	.+18     	; 0x6d48 <vfprintf+0x5c6>
    6d36:	02 ff       	sbrs	r16, 2
    6d38:	06 c0       	rjmp	.+12     	; 0x6d46 <vfprintf+0x5c4>
    6d3a:	d3 94       	inc	r13
    6d3c:	d3 94       	inc	r13
    6d3e:	04 c0       	rjmp	.+8      	; 0x6d48 <vfprintf+0x5c6>
    6d40:	80 2f       	mov	r24, r16
    6d42:	86 78       	andi	r24, 0x86	; 134
    6d44:	09 f0       	breq	.+2      	; 0x6d48 <vfprintf+0x5c6>
    6d46:	d3 94       	inc	r13
    6d48:	03 fd       	sbrc	r16, 3
    6d4a:	10 c0       	rjmp	.+32     	; 0x6d6c <vfprintf+0x5ea>
    6d4c:	00 ff       	sbrs	r16, 0
    6d4e:	06 c0       	rjmp	.+12     	; 0x6d5c <vfprintf+0x5da>
    6d50:	1c 2d       	mov	r17, r12
    6d52:	d5 14       	cp	r13, r5
    6d54:	78 f4       	brcc	.+30     	; 0x6d74 <vfprintf+0x5f2>
    6d56:	15 0d       	add	r17, r5
    6d58:	1d 19       	sub	r17, r13
    6d5a:	0c c0       	rjmp	.+24     	; 0x6d74 <vfprintf+0x5f2>
    6d5c:	d5 14       	cp	r13, r5
    6d5e:	50 f4       	brcc	.+20     	; 0x6d74 <vfprintf+0x5f2>
    6d60:	b7 01       	movw	r22, r14
    6d62:	80 e2       	ldi	r24, 0x20	; 32
    6d64:	90 e0       	ldi	r25, 0x00	; 0
    6d66:	c3 d1       	rcall	.+902    	; 0x70ee <fputc>
    6d68:	d3 94       	inc	r13
    6d6a:	f8 cf       	rjmp	.-16     	; 0x6d5c <vfprintf+0x5da>
    6d6c:	d5 14       	cp	r13, r5
    6d6e:	10 f4       	brcc	.+4      	; 0x6d74 <vfprintf+0x5f2>
    6d70:	5d 18       	sub	r5, r13
    6d72:	01 c0       	rjmp	.+2      	; 0x6d76 <vfprintf+0x5f4>
    6d74:	51 2c       	mov	r5, r1
    6d76:	04 ff       	sbrs	r16, 4
    6d78:	0f c0       	rjmp	.+30     	; 0x6d98 <vfprintf+0x616>
    6d7a:	b7 01       	movw	r22, r14
    6d7c:	80 e3       	ldi	r24, 0x30	; 48
    6d7e:	90 e0       	ldi	r25, 0x00	; 0
    6d80:	b6 d1       	rcall	.+876    	; 0x70ee <fputc>
    6d82:	02 ff       	sbrs	r16, 2
    6d84:	16 c0       	rjmp	.+44     	; 0x6db2 <vfprintf+0x630>
    6d86:	01 fd       	sbrc	r16, 1
    6d88:	03 c0       	rjmp	.+6      	; 0x6d90 <vfprintf+0x60e>
    6d8a:	88 e7       	ldi	r24, 0x78	; 120
    6d8c:	90 e0       	ldi	r25, 0x00	; 0
    6d8e:	02 c0       	rjmp	.+4      	; 0x6d94 <vfprintf+0x612>
    6d90:	88 e5       	ldi	r24, 0x58	; 88
    6d92:	90 e0       	ldi	r25, 0x00	; 0
    6d94:	b7 01       	movw	r22, r14
    6d96:	0c c0       	rjmp	.+24     	; 0x6db0 <vfprintf+0x62e>
    6d98:	80 2f       	mov	r24, r16
    6d9a:	86 78       	andi	r24, 0x86	; 134
    6d9c:	51 f0       	breq	.+20     	; 0x6db2 <vfprintf+0x630>
    6d9e:	01 ff       	sbrs	r16, 1
    6da0:	02 c0       	rjmp	.+4      	; 0x6da6 <vfprintf+0x624>
    6da2:	8b e2       	ldi	r24, 0x2B	; 43
    6da4:	01 c0       	rjmp	.+2      	; 0x6da8 <vfprintf+0x626>
    6da6:	80 e2       	ldi	r24, 0x20	; 32
    6da8:	07 fd       	sbrc	r16, 7
    6daa:	8d e2       	ldi	r24, 0x2D	; 45
    6dac:	b7 01       	movw	r22, r14
    6dae:	90 e0       	ldi	r25, 0x00	; 0
    6db0:	9e d1       	rcall	.+828    	; 0x70ee <fputc>
    6db2:	c1 16       	cp	r12, r17
    6db4:	30 f4       	brcc	.+12     	; 0x6dc2 <vfprintf+0x640>
    6db6:	b7 01       	movw	r22, r14
    6db8:	80 e3       	ldi	r24, 0x30	; 48
    6dba:	90 e0       	ldi	r25, 0x00	; 0
    6dbc:	98 d1       	rcall	.+816    	; 0x70ee <fputc>
    6dbe:	11 50       	subi	r17, 0x01	; 1
    6dc0:	f8 cf       	rjmp	.-16     	; 0x6db2 <vfprintf+0x630>
    6dc2:	ca 94       	dec	r12
    6dc4:	f3 01       	movw	r30, r6
    6dc6:	ec 0d       	add	r30, r12
    6dc8:	f1 1d       	adc	r31, r1
    6dca:	80 81       	ld	r24, Z
    6dcc:	b7 01       	movw	r22, r14
    6dce:	90 e0       	ldi	r25, 0x00	; 0
    6dd0:	8e d1       	rcall	.+796    	; 0x70ee <fputc>
    6dd2:	c1 10       	cpse	r12, r1
    6dd4:	f6 cf       	rjmp	.-20     	; 0x6dc2 <vfprintf+0x640>
    6dd6:	15 c0       	rjmp	.+42     	; 0x6e02 <vfprintf+0x680>
    6dd8:	f4 e0       	ldi	r31, 0x04	; 4
    6dda:	f5 15       	cp	r31, r5
    6ddc:	50 f5       	brcc	.+84     	; 0x6e32 <vfprintf+0x6b0>
    6dde:	84 e0       	ldi	r24, 0x04	; 4
    6de0:	58 1a       	sub	r5, r24
    6de2:	93 fe       	sbrs	r9, 3
    6de4:	1e c0       	rjmp	.+60     	; 0x6e22 <vfprintf+0x6a0>
    6de6:	01 11       	cpse	r16, r1
    6de8:	25 c0       	rjmp	.+74     	; 0x6e34 <vfprintf+0x6b2>
    6dea:	2c 85       	ldd	r18, Y+12	; 0x0c
    6dec:	23 ff       	sbrs	r18, 3
    6dee:	27 c0       	rjmp	.+78     	; 0x6e3e <vfprintf+0x6bc>
    6df0:	00 e3       	ldi	r16, 0x30	; 48
    6df2:	11 e0       	ldi	r17, 0x01	; 1
    6df4:	39 2d       	mov	r19, r9
    6df6:	30 71       	andi	r19, 0x10	; 16
    6df8:	93 2e       	mov	r9, r19
    6dfa:	f8 01       	movw	r30, r16
    6dfc:	84 91       	lpm	r24, Z
    6dfe:	81 11       	cpse	r24, r1
    6e00:	21 c0       	rjmp	.+66     	; 0x6e44 <vfprintf+0x6c2>
    6e02:	55 20       	and	r5, r5
    6e04:	09 f4       	brne	.+2      	; 0x6e08 <vfprintf+0x686>
    6e06:	fc cc       	rjmp	.-1544   	; 0x6800 <vfprintf+0x7e>
    6e08:	b7 01       	movw	r22, r14
    6e0a:	80 e2       	ldi	r24, 0x20	; 32
    6e0c:	90 e0       	ldi	r25, 0x00	; 0
    6e0e:	6f d1       	rcall	.+734    	; 0x70ee <fputc>
    6e10:	5a 94       	dec	r5
    6e12:	f7 cf       	rjmp	.-18     	; 0x6e02 <vfprintf+0x680>
    6e14:	f7 01       	movw	r30, r14
    6e16:	86 81       	ldd	r24, Z+6	; 0x06
    6e18:	97 81       	ldd	r25, Z+7	; 0x07
    6e1a:	23 c0       	rjmp	.+70     	; 0x6e62 <vfprintf+0x6e0>
    6e1c:	8f ef       	ldi	r24, 0xFF	; 255
    6e1e:	9f ef       	ldi	r25, 0xFF	; 255
    6e20:	20 c0       	rjmp	.+64     	; 0x6e62 <vfprintf+0x6e0>
    6e22:	b7 01       	movw	r22, r14
    6e24:	80 e2       	ldi	r24, 0x20	; 32
    6e26:	90 e0       	ldi	r25, 0x00	; 0
    6e28:	62 d1       	rcall	.+708    	; 0x70ee <fputc>
    6e2a:	5a 94       	dec	r5
    6e2c:	51 10       	cpse	r5, r1
    6e2e:	f9 cf       	rjmp	.-14     	; 0x6e22 <vfprintf+0x6a0>
    6e30:	da cf       	rjmp	.-76     	; 0x6de6 <vfprintf+0x664>
    6e32:	51 2c       	mov	r5, r1
    6e34:	b7 01       	movw	r22, r14
    6e36:	80 2f       	mov	r24, r16
    6e38:	90 e0       	ldi	r25, 0x00	; 0
    6e3a:	59 d1       	rcall	.+690    	; 0x70ee <fputc>
    6e3c:	d6 cf       	rjmp	.-84     	; 0x6dea <vfprintf+0x668>
    6e3e:	04 e3       	ldi	r16, 0x34	; 52
    6e40:	11 e0       	ldi	r17, 0x01	; 1
    6e42:	d8 cf       	rjmp	.-80     	; 0x6df4 <vfprintf+0x672>
    6e44:	91 10       	cpse	r9, r1
    6e46:	80 52       	subi	r24, 0x20	; 32
    6e48:	b7 01       	movw	r22, r14
    6e4a:	90 e0       	ldi	r25, 0x00	; 0
    6e4c:	50 d1       	rcall	.+672    	; 0x70ee <fputc>
    6e4e:	0f 5f       	subi	r16, 0xFF	; 255
    6e50:	1f 4f       	sbci	r17, 0xFF	; 255
    6e52:	d3 cf       	rjmp	.-90     	; 0x6dfa <vfprintf+0x678>
    6e54:	23 e0       	ldi	r18, 0x03	; 3
    6e56:	25 15       	cp	r18, r5
    6e58:	10 f4       	brcc	.+4      	; 0x6e5e <vfprintf+0x6dc>
    6e5a:	83 e0       	ldi	r24, 0x03	; 3
    6e5c:	c1 cf       	rjmp	.-126    	; 0x6de0 <vfprintf+0x65e>
    6e5e:	51 2c       	mov	r5, r1
    6e60:	c4 cf       	rjmp	.-120    	; 0x6dea <vfprintf+0x668>
    6e62:	60 96       	adiw	r28, 0x10	; 16
    6e64:	0f b6       	in	r0, 0x3f	; 63
    6e66:	f8 94       	cli
    6e68:	de bf       	out	0x3e, r29	; 62
    6e6a:	0f be       	out	0x3f, r0	; 63
    6e6c:	cd bf       	out	0x3d, r28	; 61
    6e6e:	df 91       	pop	r29
    6e70:	cf 91       	pop	r28
    6e72:	1f 91       	pop	r17
    6e74:	0f 91       	pop	r16
    6e76:	ff 90       	pop	r15
    6e78:	ef 90       	pop	r14
    6e7a:	df 90       	pop	r13
    6e7c:	cf 90       	pop	r12
    6e7e:	bf 90       	pop	r11
    6e80:	af 90       	pop	r10
    6e82:	9f 90       	pop	r9
    6e84:	8f 90       	pop	r8
    6e86:	7f 90       	pop	r7
    6e88:	6f 90       	pop	r6
    6e8a:	5f 90       	pop	r5
    6e8c:	4f 90       	pop	r4
    6e8e:	3f 90       	pop	r3
    6e90:	2f 90       	pop	r2
    6e92:	08 95       	ret

00006e94 <__divmodhi4>:
    6e94:	97 fb       	bst	r25, 7
    6e96:	07 2e       	mov	r0, r23
    6e98:	16 f4       	brtc	.+4      	; 0x6e9e <__divmodhi4+0xa>
    6e9a:	00 94       	com	r0
    6e9c:	06 d0       	rcall	.+12     	; 0x6eaa <__divmodhi4_neg1>
    6e9e:	77 fd       	sbrc	r23, 7
    6ea0:	08 d0       	rcall	.+16     	; 0x6eb2 <__divmodhi4_neg2>
    6ea2:	1a d0       	rcall	.+52     	; 0x6ed8 <__udivmodhi4>
    6ea4:	07 fc       	sbrc	r0, 7
    6ea6:	05 d0       	rcall	.+10     	; 0x6eb2 <__divmodhi4_neg2>
    6ea8:	3e f4       	brtc	.+14     	; 0x6eb8 <__divmodhi4_exit>

00006eaa <__divmodhi4_neg1>:
    6eaa:	90 95       	com	r25
    6eac:	81 95       	neg	r24
    6eae:	9f 4f       	sbci	r25, 0xFF	; 255
    6eb0:	08 95       	ret

00006eb2 <__divmodhi4_neg2>:
    6eb2:	70 95       	com	r23
    6eb4:	61 95       	neg	r22
    6eb6:	7f 4f       	sbci	r23, 0xFF	; 255

00006eb8 <__divmodhi4_exit>:
    6eb8:	08 95       	ret

00006eba <__umulhisi3>:
    6eba:	a2 9f       	mul	r26, r18
    6ebc:	b0 01       	movw	r22, r0
    6ebe:	b3 9f       	mul	r27, r19
    6ec0:	c0 01       	movw	r24, r0
    6ec2:	a3 9f       	mul	r26, r19
    6ec4:	70 0d       	add	r23, r0
    6ec6:	81 1d       	adc	r24, r1
    6ec8:	11 24       	eor	r1, r1
    6eca:	91 1d       	adc	r25, r1
    6ecc:	b2 9f       	mul	r27, r18
    6ece:	70 0d       	add	r23, r0
    6ed0:	81 1d       	adc	r24, r1
    6ed2:	11 24       	eor	r1, r1
    6ed4:	91 1d       	adc	r25, r1
    6ed6:	08 95       	ret

00006ed8 <__udivmodhi4>:
    6ed8:	aa 1b       	sub	r26, r26
    6eda:	bb 1b       	sub	r27, r27
    6edc:	51 e1       	ldi	r21, 0x11	; 17
    6ede:	07 c0       	rjmp	.+14     	; 0x6eee <__udivmodhi4_ep>

00006ee0 <__udivmodhi4_loop>:
    6ee0:	aa 1f       	adc	r26, r26
    6ee2:	bb 1f       	adc	r27, r27
    6ee4:	a6 17       	cp	r26, r22
    6ee6:	b7 07       	cpc	r27, r23
    6ee8:	10 f0       	brcs	.+4      	; 0x6eee <__udivmodhi4_ep>
    6eea:	a6 1b       	sub	r26, r22
    6eec:	b7 0b       	sbc	r27, r23

00006eee <__udivmodhi4_ep>:
    6eee:	88 1f       	adc	r24, r24
    6ef0:	99 1f       	adc	r25, r25
    6ef2:	5a 95       	dec	r21
    6ef4:	a9 f7       	brne	.-22     	; 0x6ee0 <__udivmodhi4_loop>
    6ef6:	80 95       	com	r24
    6ef8:	90 95       	com	r25
    6efa:	bc 01       	movw	r22, r24
    6efc:	cd 01       	movw	r24, r26
    6efe:	08 95       	ret

00006f00 <__ftoa_engine>:
    6f00:	28 30       	cpi	r18, 0x08	; 8
    6f02:	08 f0       	brcs	.+2      	; 0x6f06 <__ftoa_engine+0x6>
    6f04:	27 e0       	ldi	r18, 0x07	; 7
    6f06:	33 27       	eor	r19, r19
    6f08:	da 01       	movw	r26, r20
    6f0a:	99 0f       	add	r25, r25
    6f0c:	31 1d       	adc	r19, r1
    6f0e:	87 fd       	sbrc	r24, 7
    6f10:	91 60       	ori	r25, 0x01	; 1
    6f12:	00 96       	adiw	r24, 0x00	; 0
    6f14:	61 05       	cpc	r22, r1
    6f16:	71 05       	cpc	r23, r1
    6f18:	39 f4       	brne	.+14     	; 0x6f28 <__ftoa_engine+0x28>
    6f1a:	32 60       	ori	r19, 0x02	; 2
    6f1c:	2e 5f       	subi	r18, 0xFE	; 254
    6f1e:	3d 93       	st	X+, r19
    6f20:	30 e3       	ldi	r19, 0x30	; 48
    6f22:	2a 95       	dec	r18
    6f24:	e1 f7       	brne	.-8      	; 0x6f1e <__ftoa_engine+0x1e>
    6f26:	08 95       	ret
    6f28:	9f 3f       	cpi	r25, 0xFF	; 255
    6f2a:	30 f0       	brcs	.+12     	; 0x6f38 <__ftoa_engine+0x38>
    6f2c:	80 38       	cpi	r24, 0x80	; 128
    6f2e:	71 05       	cpc	r23, r1
    6f30:	61 05       	cpc	r22, r1
    6f32:	09 f0       	breq	.+2      	; 0x6f36 <__ftoa_engine+0x36>
    6f34:	3c 5f       	subi	r19, 0xFC	; 252
    6f36:	3c 5f       	subi	r19, 0xFC	; 252
    6f38:	3d 93       	st	X+, r19
    6f3a:	91 30       	cpi	r25, 0x01	; 1
    6f3c:	08 f0       	brcs	.+2      	; 0x6f40 <__ftoa_engine+0x40>
    6f3e:	80 68       	ori	r24, 0x80	; 128
    6f40:	91 1d       	adc	r25, r1
    6f42:	df 93       	push	r29
    6f44:	cf 93       	push	r28
    6f46:	1f 93       	push	r17
    6f48:	0f 93       	push	r16
    6f4a:	ff 92       	push	r15
    6f4c:	ef 92       	push	r14
    6f4e:	19 2f       	mov	r17, r25
    6f50:	98 7f       	andi	r25, 0xF8	; 248
    6f52:	96 95       	lsr	r25
    6f54:	e9 2f       	mov	r30, r25
    6f56:	96 95       	lsr	r25
    6f58:	96 95       	lsr	r25
    6f5a:	e9 0f       	add	r30, r25
    6f5c:	ff 27       	eor	r31, r31
    6f5e:	ee 56       	subi	r30, 0x6E	; 110
    6f60:	fe 4f       	sbci	r31, 0xFE	; 254
    6f62:	99 27       	eor	r25, r25
    6f64:	33 27       	eor	r19, r19
    6f66:	ee 24       	eor	r14, r14
    6f68:	ff 24       	eor	r15, r15
    6f6a:	a7 01       	movw	r20, r14
    6f6c:	e7 01       	movw	r28, r14
    6f6e:	05 90       	lpm	r0, Z+
    6f70:	08 94       	sec
    6f72:	07 94       	ror	r0
    6f74:	28 f4       	brcc	.+10     	; 0x6f80 <__ftoa_engine+0x80>
    6f76:	36 0f       	add	r19, r22
    6f78:	e7 1e       	adc	r14, r23
    6f7a:	f8 1e       	adc	r15, r24
    6f7c:	49 1f       	adc	r20, r25
    6f7e:	51 1d       	adc	r21, r1
    6f80:	66 0f       	add	r22, r22
    6f82:	77 1f       	adc	r23, r23
    6f84:	88 1f       	adc	r24, r24
    6f86:	99 1f       	adc	r25, r25
    6f88:	06 94       	lsr	r0
    6f8a:	a1 f7       	brne	.-24     	; 0x6f74 <__ftoa_engine+0x74>
    6f8c:	05 90       	lpm	r0, Z+
    6f8e:	07 94       	ror	r0
    6f90:	28 f4       	brcc	.+10     	; 0x6f9c <__ftoa_engine+0x9c>
    6f92:	e7 0e       	add	r14, r23
    6f94:	f8 1e       	adc	r15, r24
    6f96:	49 1f       	adc	r20, r25
    6f98:	56 1f       	adc	r21, r22
    6f9a:	c1 1d       	adc	r28, r1
    6f9c:	77 0f       	add	r23, r23
    6f9e:	88 1f       	adc	r24, r24
    6fa0:	99 1f       	adc	r25, r25
    6fa2:	66 1f       	adc	r22, r22
    6fa4:	06 94       	lsr	r0
    6fa6:	a1 f7       	brne	.-24     	; 0x6f90 <__ftoa_engine+0x90>
    6fa8:	05 90       	lpm	r0, Z+
    6faa:	07 94       	ror	r0
    6fac:	28 f4       	brcc	.+10     	; 0x6fb8 <__ftoa_engine+0xb8>
    6fae:	f8 0e       	add	r15, r24
    6fb0:	49 1f       	adc	r20, r25
    6fb2:	56 1f       	adc	r21, r22
    6fb4:	c7 1f       	adc	r28, r23
    6fb6:	d1 1d       	adc	r29, r1
    6fb8:	88 0f       	add	r24, r24
    6fba:	99 1f       	adc	r25, r25
    6fbc:	66 1f       	adc	r22, r22
    6fbe:	77 1f       	adc	r23, r23
    6fc0:	06 94       	lsr	r0
    6fc2:	a1 f7       	brne	.-24     	; 0x6fac <__ftoa_engine+0xac>
    6fc4:	05 90       	lpm	r0, Z+
    6fc6:	07 94       	ror	r0
    6fc8:	20 f4       	brcc	.+8      	; 0x6fd2 <__ftoa_engine+0xd2>
    6fca:	49 0f       	add	r20, r25
    6fcc:	56 1f       	adc	r21, r22
    6fce:	c7 1f       	adc	r28, r23
    6fd0:	d8 1f       	adc	r29, r24
    6fd2:	99 0f       	add	r25, r25
    6fd4:	66 1f       	adc	r22, r22
    6fd6:	77 1f       	adc	r23, r23
    6fd8:	88 1f       	adc	r24, r24
    6fda:	06 94       	lsr	r0
    6fdc:	a9 f7       	brne	.-22     	; 0x6fc8 <__ftoa_engine+0xc8>
    6fde:	84 91       	lpm	r24, Z
    6fe0:	10 95       	com	r17
    6fe2:	17 70       	andi	r17, 0x07	; 7
    6fe4:	41 f0       	breq	.+16     	; 0x6ff6 <__ftoa_engine+0xf6>
    6fe6:	d6 95       	lsr	r29
    6fe8:	c7 95       	ror	r28
    6fea:	57 95       	ror	r21
    6fec:	47 95       	ror	r20
    6fee:	f7 94       	ror	r15
    6ff0:	e7 94       	ror	r14
    6ff2:	1a 95       	dec	r17
    6ff4:	c1 f7       	brne	.-16     	; 0x6fe6 <__ftoa_engine+0xe6>
    6ff6:	e8 e3       	ldi	r30, 0x38	; 56
    6ff8:	f1 e0       	ldi	r31, 0x01	; 1
    6ffa:	68 94       	set
    6ffc:	15 90       	lpm	r1, Z+
    6ffe:	15 91       	lpm	r17, Z+
    7000:	35 91       	lpm	r19, Z+
    7002:	65 91       	lpm	r22, Z+
    7004:	95 91       	lpm	r25, Z+
    7006:	05 90       	lpm	r0, Z+
    7008:	7f e2       	ldi	r23, 0x2F	; 47
    700a:	73 95       	inc	r23
    700c:	e1 18       	sub	r14, r1
    700e:	f1 0a       	sbc	r15, r17
    7010:	43 0b       	sbc	r20, r19
    7012:	56 0b       	sbc	r21, r22
    7014:	c9 0b       	sbc	r28, r25
    7016:	d0 09       	sbc	r29, r0
    7018:	c0 f7       	brcc	.-16     	; 0x700a <__ftoa_engine+0x10a>
    701a:	e1 0c       	add	r14, r1
    701c:	f1 1e       	adc	r15, r17
    701e:	43 1f       	adc	r20, r19
    7020:	56 1f       	adc	r21, r22
    7022:	c9 1f       	adc	r28, r25
    7024:	d0 1d       	adc	r29, r0
    7026:	7e f4       	brtc	.+30     	; 0x7046 <__ftoa_engine+0x146>
    7028:	70 33       	cpi	r23, 0x30	; 48
    702a:	11 f4       	brne	.+4      	; 0x7030 <__ftoa_engine+0x130>
    702c:	8a 95       	dec	r24
    702e:	e6 cf       	rjmp	.-52     	; 0x6ffc <__ftoa_engine+0xfc>
    7030:	e8 94       	clt
    7032:	01 50       	subi	r16, 0x01	; 1
    7034:	30 f0       	brcs	.+12     	; 0x7042 <__ftoa_engine+0x142>
    7036:	08 0f       	add	r16, r24
    7038:	0a f4       	brpl	.+2      	; 0x703c <__ftoa_engine+0x13c>
    703a:	00 27       	eor	r16, r16
    703c:	02 17       	cp	r16, r18
    703e:	08 f4       	brcc	.+2      	; 0x7042 <__ftoa_engine+0x142>
    7040:	20 2f       	mov	r18, r16
    7042:	23 95       	inc	r18
    7044:	02 2f       	mov	r16, r18
    7046:	7a 33       	cpi	r23, 0x3A	; 58
    7048:	28 f0       	brcs	.+10     	; 0x7054 <__ftoa_engine+0x154>
    704a:	79 e3       	ldi	r23, 0x39	; 57
    704c:	7d 93       	st	X+, r23
    704e:	2a 95       	dec	r18
    7050:	e9 f7       	brne	.-6      	; 0x704c <__ftoa_engine+0x14c>
    7052:	10 c0       	rjmp	.+32     	; 0x7074 <__ftoa_engine+0x174>
    7054:	7d 93       	st	X+, r23
    7056:	2a 95       	dec	r18
    7058:	89 f6       	brne	.-94     	; 0x6ffc <__ftoa_engine+0xfc>
    705a:	06 94       	lsr	r0
    705c:	97 95       	ror	r25
    705e:	67 95       	ror	r22
    7060:	37 95       	ror	r19
    7062:	17 95       	ror	r17
    7064:	17 94       	ror	r1
    7066:	e1 18       	sub	r14, r1
    7068:	f1 0a       	sbc	r15, r17
    706a:	43 0b       	sbc	r20, r19
    706c:	56 0b       	sbc	r21, r22
    706e:	c9 0b       	sbc	r28, r25
    7070:	d0 09       	sbc	r29, r0
    7072:	98 f0       	brcs	.+38     	; 0x709a <__ftoa_engine+0x19a>
    7074:	23 95       	inc	r18
    7076:	7e 91       	ld	r23, -X
    7078:	73 95       	inc	r23
    707a:	7a 33       	cpi	r23, 0x3A	; 58
    707c:	08 f0       	brcs	.+2      	; 0x7080 <__ftoa_engine+0x180>
    707e:	70 e3       	ldi	r23, 0x30	; 48
    7080:	7c 93       	st	X, r23
    7082:	20 13       	cpse	r18, r16
    7084:	b8 f7       	brcc	.-18     	; 0x7074 <__ftoa_engine+0x174>
    7086:	7e 91       	ld	r23, -X
    7088:	70 61       	ori	r23, 0x10	; 16
    708a:	7d 93       	st	X+, r23
    708c:	30 f0       	brcs	.+12     	; 0x709a <__ftoa_engine+0x19a>
    708e:	83 95       	inc	r24
    7090:	71 e3       	ldi	r23, 0x31	; 49
    7092:	7d 93       	st	X+, r23
    7094:	70 e3       	ldi	r23, 0x30	; 48
    7096:	2a 95       	dec	r18
    7098:	e1 f7       	brne	.-8      	; 0x7092 <__ftoa_engine+0x192>
    709a:	11 24       	eor	r1, r1
    709c:	ef 90       	pop	r14
    709e:	ff 90       	pop	r15
    70a0:	0f 91       	pop	r16
    70a2:	1f 91       	pop	r17
    70a4:	cf 91       	pop	r28
    70a6:	df 91       	pop	r29
    70a8:	99 27       	eor	r25, r25
    70aa:	87 fd       	sbrc	r24, 7
    70ac:	90 95       	com	r25
    70ae:	08 95       	ret

000070b0 <strnlen_P>:
    70b0:	fc 01       	movw	r30, r24
    70b2:	05 90       	lpm	r0, Z+
    70b4:	61 50       	subi	r22, 0x01	; 1
    70b6:	70 40       	sbci	r23, 0x00	; 0
    70b8:	01 10       	cpse	r0, r1
    70ba:	d8 f7       	brcc	.-10     	; 0x70b2 <strnlen_P+0x2>
    70bc:	80 95       	com	r24
    70be:	90 95       	com	r25
    70c0:	8e 0f       	add	r24, r30
    70c2:	9f 1f       	adc	r25, r31
    70c4:	08 95       	ret

000070c6 <memcpy>:
    70c6:	fb 01       	movw	r30, r22
    70c8:	dc 01       	movw	r26, r24
    70ca:	02 c0       	rjmp	.+4      	; 0x70d0 <memcpy+0xa>
    70cc:	01 90       	ld	r0, Z+
    70ce:	0d 92       	st	X+, r0
    70d0:	41 50       	subi	r20, 0x01	; 1
    70d2:	50 40       	sbci	r21, 0x00	; 0
    70d4:	d8 f7       	brcc	.-10     	; 0x70cc <memcpy+0x6>
    70d6:	08 95       	ret

000070d8 <strnlen>:
    70d8:	fc 01       	movw	r30, r24
    70da:	61 50       	subi	r22, 0x01	; 1
    70dc:	70 40       	sbci	r23, 0x00	; 0
    70de:	01 90       	ld	r0, Z+
    70e0:	01 10       	cpse	r0, r1
    70e2:	d8 f7       	brcc	.-10     	; 0x70da <strnlen+0x2>
    70e4:	80 95       	com	r24
    70e6:	90 95       	com	r25
    70e8:	8e 0f       	add	r24, r30
    70ea:	9f 1f       	adc	r25, r31
    70ec:	08 95       	ret

000070ee <fputc>:
    70ee:	0f 93       	push	r16
    70f0:	1f 93       	push	r17
    70f2:	cf 93       	push	r28
    70f4:	df 93       	push	r29
    70f6:	fb 01       	movw	r30, r22
    70f8:	23 81       	ldd	r18, Z+3	; 0x03
    70fa:	21 fd       	sbrc	r18, 1
    70fc:	03 c0       	rjmp	.+6      	; 0x7104 <fputc+0x16>
    70fe:	8f ef       	ldi	r24, 0xFF	; 255
    7100:	9f ef       	ldi	r25, 0xFF	; 255
    7102:	2c c0       	rjmp	.+88     	; 0x715c <fputc+0x6e>
    7104:	22 ff       	sbrs	r18, 2
    7106:	16 c0       	rjmp	.+44     	; 0x7134 <fputc+0x46>
    7108:	46 81       	ldd	r20, Z+6	; 0x06
    710a:	57 81       	ldd	r21, Z+7	; 0x07
    710c:	24 81       	ldd	r18, Z+4	; 0x04
    710e:	35 81       	ldd	r19, Z+5	; 0x05
    7110:	42 17       	cp	r20, r18
    7112:	53 07       	cpc	r21, r19
    7114:	44 f4       	brge	.+16     	; 0x7126 <fputc+0x38>
    7116:	a0 81       	ld	r26, Z
    7118:	b1 81       	ldd	r27, Z+1	; 0x01
    711a:	9d 01       	movw	r18, r26
    711c:	2f 5f       	subi	r18, 0xFF	; 255
    711e:	3f 4f       	sbci	r19, 0xFF	; 255
    7120:	31 83       	std	Z+1, r19	; 0x01
    7122:	20 83       	st	Z, r18
    7124:	8c 93       	st	X, r24
    7126:	26 81       	ldd	r18, Z+6	; 0x06
    7128:	37 81       	ldd	r19, Z+7	; 0x07
    712a:	2f 5f       	subi	r18, 0xFF	; 255
    712c:	3f 4f       	sbci	r19, 0xFF	; 255
    712e:	37 83       	std	Z+7, r19	; 0x07
    7130:	26 83       	std	Z+6, r18	; 0x06
    7132:	14 c0       	rjmp	.+40     	; 0x715c <fputc+0x6e>
    7134:	8b 01       	movw	r16, r22
    7136:	ec 01       	movw	r28, r24
    7138:	fb 01       	movw	r30, r22
    713a:	00 84       	ldd	r0, Z+8	; 0x08
    713c:	f1 85       	ldd	r31, Z+9	; 0x09
    713e:	e0 2d       	mov	r30, r0
    7140:	19 95       	eicall
    7142:	89 2b       	or	r24, r25
    7144:	e1 f6       	brne	.-72     	; 0x70fe <fputc+0x10>
    7146:	d8 01       	movw	r26, r16
    7148:	16 96       	adiw	r26, 0x06	; 6
    714a:	8d 91       	ld	r24, X+
    714c:	9c 91       	ld	r25, X
    714e:	17 97       	sbiw	r26, 0x07	; 7
    7150:	01 96       	adiw	r24, 0x01	; 1
    7152:	17 96       	adiw	r26, 0x07	; 7
    7154:	9c 93       	st	X, r25
    7156:	8e 93       	st	-X, r24
    7158:	16 97       	sbiw	r26, 0x06	; 6
    715a:	ce 01       	movw	r24, r28
    715c:	df 91       	pop	r29
    715e:	cf 91       	pop	r28
    7160:	1f 91       	pop	r17
    7162:	0f 91       	pop	r16
    7164:	08 95       	ret

00007166 <vsprintf>:
    7166:	0f 93       	push	r16
    7168:	1f 93       	push	r17
    716a:	cf 93       	push	r28
    716c:	df 93       	push	r29
    716e:	cd b7       	in	r28, 0x3d	; 61
    7170:	de b7       	in	r29, 0x3e	; 62
    7172:	2e 97       	sbiw	r28, 0x0e	; 14
    7174:	0f b6       	in	r0, 0x3f	; 63
    7176:	f8 94       	cli
    7178:	de bf       	out	0x3e, r29	; 62
    717a:	0f be       	out	0x3f, r0	; 63
    717c:	cd bf       	out	0x3d, r28	; 61
    717e:	8c 01       	movw	r16, r24
    7180:	86 e0       	ldi	r24, 0x06	; 6
    7182:	8c 83       	std	Y+4, r24	; 0x04
    7184:	1a 83       	std	Y+2, r17	; 0x02
    7186:	09 83       	std	Y+1, r16	; 0x01
    7188:	8f ef       	ldi	r24, 0xFF	; 255
    718a:	9f e7       	ldi	r25, 0x7F	; 127
    718c:	9e 83       	std	Y+6, r25	; 0x06
    718e:	8d 83       	std	Y+5, r24	; 0x05
    7190:	ce 01       	movw	r24, r28
    7192:	01 96       	adiw	r24, 0x01	; 1
    7194:	f6 da       	rcall	.-2580   	; 0x6782 <vfprintf>
    7196:	ef 81       	ldd	r30, Y+7	; 0x07
    7198:	f8 85       	ldd	r31, Y+8	; 0x08
    719a:	e0 0f       	add	r30, r16
    719c:	f1 1f       	adc	r31, r17
    719e:	10 82       	st	Z, r1
    71a0:	2e 96       	adiw	r28, 0x0e	; 14
    71a2:	0f b6       	in	r0, 0x3f	; 63
    71a4:	f8 94       	cli
    71a6:	de bf       	out	0x3e, r29	; 62
    71a8:	0f be       	out	0x3f, r0	; 63
    71aa:	cd bf       	out	0x3d, r28	; 61
    71ac:	df 91       	pop	r29
    71ae:	cf 91       	pop	r28
    71b0:	1f 91       	pop	r17
    71b2:	0f 91       	pop	r16
    71b4:	08 95       	ret

000071b6 <__ultoa_invert>:
    71b6:	fa 01       	movw	r30, r20
    71b8:	aa 27       	eor	r26, r26
    71ba:	28 30       	cpi	r18, 0x08	; 8
    71bc:	51 f1       	breq	.+84     	; 0x7212 <__ultoa_invert+0x5c>
    71be:	20 31       	cpi	r18, 0x10	; 16
    71c0:	81 f1       	breq	.+96     	; 0x7222 <__ultoa_invert+0x6c>
    71c2:	e8 94       	clt
    71c4:	6f 93       	push	r22
    71c6:	6e 7f       	andi	r22, 0xFE	; 254
    71c8:	6e 5f       	subi	r22, 0xFE	; 254
    71ca:	7f 4f       	sbci	r23, 0xFF	; 255
    71cc:	8f 4f       	sbci	r24, 0xFF	; 255
    71ce:	9f 4f       	sbci	r25, 0xFF	; 255
    71d0:	af 4f       	sbci	r26, 0xFF	; 255
    71d2:	b1 e0       	ldi	r27, 0x01	; 1
    71d4:	3e d0       	rcall	.+124    	; 0x7252 <__ultoa_invert+0x9c>
    71d6:	b4 e0       	ldi	r27, 0x04	; 4
    71d8:	3c d0       	rcall	.+120    	; 0x7252 <__ultoa_invert+0x9c>
    71da:	67 0f       	add	r22, r23
    71dc:	78 1f       	adc	r23, r24
    71de:	89 1f       	adc	r24, r25
    71e0:	9a 1f       	adc	r25, r26
    71e2:	a1 1d       	adc	r26, r1
    71e4:	68 0f       	add	r22, r24
    71e6:	79 1f       	adc	r23, r25
    71e8:	8a 1f       	adc	r24, r26
    71ea:	91 1d       	adc	r25, r1
    71ec:	a1 1d       	adc	r26, r1
    71ee:	6a 0f       	add	r22, r26
    71f0:	71 1d       	adc	r23, r1
    71f2:	81 1d       	adc	r24, r1
    71f4:	91 1d       	adc	r25, r1
    71f6:	a1 1d       	adc	r26, r1
    71f8:	20 d0       	rcall	.+64     	; 0x723a <__ultoa_invert+0x84>
    71fa:	09 f4       	brne	.+2      	; 0x71fe <__ultoa_invert+0x48>
    71fc:	68 94       	set
    71fe:	3f 91       	pop	r19
    7200:	2a e0       	ldi	r18, 0x0A	; 10
    7202:	26 9f       	mul	r18, r22
    7204:	11 24       	eor	r1, r1
    7206:	30 19       	sub	r19, r0
    7208:	30 5d       	subi	r19, 0xD0	; 208
    720a:	31 93       	st	Z+, r19
    720c:	de f6       	brtc	.-74     	; 0x71c4 <__ultoa_invert+0xe>
    720e:	cf 01       	movw	r24, r30
    7210:	08 95       	ret
    7212:	46 2f       	mov	r20, r22
    7214:	47 70       	andi	r20, 0x07	; 7
    7216:	40 5d       	subi	r20, 0xD0	; 208
    7218:	41 93       	st	Z+, r20
    721a:	b3 e0       	ldi	r27, 0x03	; 3
    721c:	0f d0       	rcall	.+30     	; 0x723c <__ultoa_invert+0x86>
    721e:	c9 f7       	brne	.-14     	; 0x7212 <__ultoa_invert+0x5c>
    7220:	f6 cf       	rjmp	.-20     	; 0x720e <__ultoa_invert+0x58>
    7222:	46 2f       	mov	r20, r22
    7224:	4f 70       	andi	r20, 0x0F	; 15
    7226:	40 5d       	subi	r20, 0xD0	; 208
    7228:	4a 33       	cpi	r20, 0x3A	; 58
    722a:	18 f0       	brcs	.+6      	; 0x7232 <__ultoa_invert+0x7c>
    722c:	49 5d       	subi	r20, 0xD9	; 217
    722e:	31 fd       	sbrc	r19, 1
    7230:	40 52       	subi	r20, 0x20	; 32
    7232:	41 93       	st	Z+, r20
    7234:	02 d0       	rcall	.+4      	; 0x723a <__ultoa_invert+0x84>
    7236:	a9 f7       	brne	.-22     	; 0x7222 <__ultoa_invert+0x6c>
    7238:	ea cf       	rjmp	.-44     	; 0x720e <__ultoa_invert+0x58>
    723a:	b4 e0       	ldi	r27, 0x04	; 4
    723c:	a6 95       	lsr	r26
    723e:	97 95       	ror	r25
    7240:	87 95       	ror	r24
    7242:	77 95       	ror	r23
    7244:	67 95       	ror	r22
    7246:	ba 95       	dec	r27
    7248:	c9 f7       	brne	.-14     	; 0x723c <__ultoa_invert+0x86>
    724a:	00 97       	sbiw	r24, 0x00	; 0
    724c:	61 05       	cpc	r22, r1
    724e:	71 05       	cpc	r23, r1
    7250:	08 95       	ret
    7252:	9b 01       	movw	r18, r22
    7254:	ac 01       	movw	r20, r24
    7256:	0a 2e       	mov	r0, r26
    7258:	06 94       	lsr	r0
    725a:	57 95       	ror	r21
    725c:	47 95       	ror	r20
    725e:	37 95       	ror	r19
    7260:	27 95       	ror	r18
    7262:	ba 95       	dec	r27
    7264:	c9 f7       	brne	.-14     	; 0x7258 <__ultoa_invert+0xa2>
    7266:	62 0f       	add	r22, r18
    7268:	73 1f       	adc	r23, r19
    726a:	84 1f       	adc	r24, r20
    726c:	95 1f       	adc	r25, r21
    726e:	a0 1d       	adc	r26, r0
    7270:	08 95       	ret

00007272 <_exit>:
    7272:	f8 94       	cli

00007274 <__stop_program>:
    7274:	ff cf       	rjmp	.-2      	; 0x7274 <__stop_program>
