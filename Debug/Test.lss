
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000051a  00800200  00007206  0000729a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007206  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000014c6  0080071a  0080071a  000077b4  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  000077b4  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00007840  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000810  00000000  00000000  00007880  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000af5a  00000000  00000000  00008090  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002400  00000000  00000000  00012fea  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000064ea  00000000  00000000  000153ea  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001adc  00000000  00000000  0001b8d4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000030ad  00000000  00000000  0001d3b0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b534  00000000  00000000  0002045d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008f0  00000000  00000000  0002b991  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	20 c1       	rjmp	.+576    	; 0x242 <__ctors_end>
       2:	00 00       	nop
       4:	3f c1       	rjmp	.+638    	; 0x284 <__bad_interrupt>
       6:	00 00       	nop
       8:	3d c1       	rjmp	.+634    	; 0x284 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 78 15 	jmp	0x2af0	; 0x2af0 <__vector_3>
      10:	0c 94 67 15 	jmp	0x2ace	; 0x2ace <__vector_4>
      14:	0c 94 89 15 	jmp	0x2b12	; 0x2b12 <__vector_5>
      18:	35 c1       	rjmp	.+618    	; 0x284 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	33 c1       	rjmp	.+614    	; 0x284 <__bad_interrupt>
      1e:	00 00       	nop
      20:	31 c1       	rjmp	.+610    	; 0x284 <__bad_interrupt>
      22:	00 00       	nop
      24:	2f c1       	rjmp	.+606    	; 0x284 <__bad_interrupt>
      26:	00 00       	nop
      28:	2d c1       	rjmp	.+602    	; 0x284 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	2b c1       	rjmp	.+598    	; 0x284 <__bad_interrupt>
      2e:	00 00       	nop
      30:	29 c1       	rjmp	.+594    	; 0x284 <__bad_interrupt>
      32:	00 00       	nop
      34:	27 c1       	rjmp	.+590    	; 0x284 <__bad_interrupt>
      36:	00 00       	nop
      38:	25 c1       	rjmp	.+586    	; 0x284 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	23 c1       	rjmp	.+582    	; 0x284 <__bad_interrupt>
      3e:	00 00       	nop
      40:	21 c1       	rjmp	.+578    	; 0x284 <__bad_interrupt>
      42:	00 00       	nop
      44:	1f c1       	rjmp	.+574    	; 0x284 <__bad_interrupt>
      46:	00 00       	nop
      48:	1d c1       	rjmp	.+570    	; 0x284 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1b c1       	rjmp	.+566    	; 0x284 <__bad_interrupt>
      4e:	00 00       	nop
      50:	19 c1       	rjmp	.+562    	; 0x284 <__bad_interrupt>
      52:	00 00       	nop
      54:	17 c1       	rjmp	.+558    	; 0x284 <__bad_interrupt>
      56:	00 00       	nop
      58:	15 c1       	rjmp	.+554    	; 0x284 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	13 c1       	rjmp	.+550    	; 0x284 <__bad_interrupt>
      5e:	00 00       	nop
      60:	11 c1       	rjmp	.+546    	; 0x284 <__bad_interrupt>
      62:	00 00       	nop
      64:	0f c1       	rjmp	.+542    	; 0x284 <__bad_interrupt>
      66:	00 00       	nop
      68:	0d c1       	rjmp	.+538    	; 0x284 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	0b c1       	rjmp	.+534    	; 0x284 <__bad_interrupt>
      6e:	00 00       	nop
      70:	09 c1       	rjmp	.+530    	; 0x284 <__bad_interrupt>
      72:	00 00       	nop
      74:	07 c1       	rjmp	.+526    	; 0x284 <__bad_interrupt>
      76:	00 00       	nop
      78:	05 c1       	rjmp	.+522    	; 0x284 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	03 c1       	rjmp	.+518    	; 0x284 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 32 19 	jmp	0x3264	; 0x3264 <__vector_32>
      84:	ff c0       	rjmp	.+510    	; 0x284 <__bad_interrupt>
      86:	00 00       	nop
      88:	fd c0       	rjmp	.+506    	; 0x284 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fb c0       	rjmp	.+502    	; 0x284 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f9 c0       	rjmp	.+498    	; 0x284 <__bad_interrupt>
      92:	00 00       	nop
      94:	f7 c0       	rjmp	.+494    	; 0x284 <__bad_interrupt>
      96:	00 00       	nop
      98:	f5 c0       	rjmp	.+490    	; 0x284 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	f3 c0       	rjmp	.+486    	; 0x284 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	f1 c0       	rjmp	.+482    	; 0x284 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	ef c0       	rjmp	.+478    	; 0x284 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	ed c0       	rjmp	.+474    	; 0x284 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	eb c0       	rjmp	.+470    	; 0x284 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	e9 c0       	rjmp	.+466    	; 0x284 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	e7 c0       	rjmp	.+462    	; 0x284 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	e5 c0       	rjmp	.+458    	; 0x284 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	e3 c0       	rjmp	.+454    	; 0x284 <__bad_interrupt>
      be:	00 00       	nop
      c0:	e1 c0       	rjmp	.+450    	; 0x284 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	df c0       	rjmp	.+446    	; 0x284 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	dd c0       	rjmp	.+442    	; 0x284 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 c7 2f 	jmp	0x5f8e	; 0x5f8e <__vector_51>
      d0:	d9 c0       	rjmp	.+434    	; 0x284 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	d7 c0       	rjmp	.+430    	; 0x284 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	d5 c0       	rjmp	.+426    	; 0x284 <__bad_interrupt>
      da:	00 00       	nop
      dc:	d3 c0       	rjmp	.+422    	; 0x284 <__bad_interrupt>
      de:	00 00       	nop
      e0:	d1 c0       	rjmp	.+418    	; 0x284 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 05       	cpc	r19, r15
     112:	a8 4c       	sbci	r26, 0xC8	; 200
     114:	cd b2       	in	r12, 0x1d	; 29
     116:	d4 4e       	sbci	r29, 0xE4	; 228
     118:	b9 38       	cpi	r27, 0x89	; 137
     11a:	36 a9       	ldd	r19, Z+54	; 0x36
     11c:	02 0c       	add	r0, r2
     11e:	50 b9       	out	0x00, r21	; 0
     120:	91 86       	std	Z+9, r9	; 0x09
     122:	88 08       	sbc	r8, r8
     124:	3c a6       	std	Y+44, r3	; 0x2c
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	2a be       	out	0x3a, r2	; 58
     12a:	00 00       	nop
     12c:	00 80       	ld	r0, Z
     12e:	3f 00       	.word	0x003f	; ????

00000130 <__trampolines_end>:
     130:	6e 61       	ori	r22, 0x1E	; 30
     132:	6e 00       	.word	0x006e	; ????

00000134 <__c.2332>:
     134:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     144:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     154:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     164:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     174:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     184:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     194:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     1a4:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     1b4:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     1c4:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     1d4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     1e4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1f4:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     204:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     214:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     224:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000232 <prvIdleTask>:
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     232:	cd e6       	ldi	r28, 0x6D	; 109
     234:	da e1       	ldi	r29, 0x1A	; 26
     236:	88 81       	ld	r24, Y
     238:	82 30       	cpi	r24, 0x02	; 2
     23a:	f0 f3       	brcs	.-4      	; 0x238 <prvIdleTask+0x6>
     23c:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
     240:	fa cf       	rjmp	.-12     	; 0x236 <prvIdleTask+0x4>

00000242 <__ctors_end>:
     242:	11 24       	eor	r1, r1
     244:	1f be       	out	0x3f, r1	; 63
     246:	cf ef       	ldi	r28, 0xFF	; 255
     248:	d1 e2       	ldi	r29, 0x21	; 33
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	cd bf       	out	0x3d, r28	; 61
     24e:	00 e0       	ldi	r16, 0x00	; 0
     250:	0c bf       	out	0x3c, r16	; 60

00000252 <__do_copy_data>:
     252:	17 e0       	ldi	r17, 0x07	; 7
     254:	a0 e0       	ldi	r26, 0x00	; 0
     256:	b2 e0       	ldi	r27, 0x02	; 2
     258:	e6 e0       	ldi	r30, 0x06	; 6
     25a:	f2 e7       	ldi	r31, 0x72	; 114
     25c:	00 e0       	ldi	r16, 0x00	; 0
     25e:	0b bf       	out	0x3b, r16	; 59
     260:	02 c0       	rjmp	.+4      	; 0x266 <__do_copy_data+0x14>
     262:	07 90       	elpm	r0, Z+
     264:	0d 92       	st	X+, r0
     266:	aa 31       	cpi	r26, 0x1A	; 26
     268:	b1 07       	cpc	r27, r17
     26a:	d9 f7       	brne	.-10     	; 0x262 <__do_copy_data+0x10>

0000026c <__do_clear_bss>:
     26c:	2b e1       	ldi	r18, 0x1B	; 27
     26e:	aa e1       	ldi	r26, 0x1A	; 26
     270:	b7 e0       	ldi	r27, 0x07	; 7
     272:	01 c0       	rjmp	.+2      	; 0x276 <.do_clear_bss_start>

00000274 <.do_clear_bss_loop>:
     274:	1d 92       	st	X+, r1

00000276 <.do_clear_bss_start>:
     276:	a0 3e       	cpi	r26, 0xE0	; 224
     278:	b2 07       	cpc	r27, r18
     27a:	e1 f7       	brne	.-8      	; 0x274 <.do_clear_bss_loop>
     27c:	0e 94 c0 14 	call	0x2980	; 0x2980 <main>
     280:	0c 94 01 39 	jmp	0x7202	; 0x7202 <_exit>

00000284 <__bad_interrupt>:
     284:	bd ce       	rjmp	.-646    	; 0x0 <__vectors>

00000286 <arq_init>:
  return len;
}

uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}
     286:	cf 93       	push	r28
     288:	df 93       	push	r29
     28a:	6b e3       	ldi	r22, 0x3B	; 59
     28c:	74 e0       	ldi	r23, 0x04	; 4
     28e:	81 e0       	ldi	r24, 0x01	; 1
     290:	0e 94 22 17 	call	0x2e44	; 0x2e44 <network_set_callback>
     294:	10 92 1b 07 	sts	0x071B, r1	; 0x80071b <__data_end+0x1>
     298:	10 92 1a 07 	sts	0x071A, r1	; 0x80071a <__data_end>
     29c:	cc e1       	ldi	r28, 0x1C	; 28
     29e:	d7 e0       	ldi	r29, 0x07	; 7
     2a0:	8d e8       	ldi	r24, 0x8D	; 141
     2a2:	fe 01       	movw	r30, r28
     2a4:	11 92       	st	Z+, r1
     2a6:	8a 95       	dec	r24
     2a8:	e9 f7       	brne	.-6      	; 0x2a4 <arq_init+0x1e>
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	0e 94 86 19 	call	0x330c	; 0x330c <xQueueCreateMutex>
     2b0:	90 93 a6 07 	sts	0x07A6, r25	; 0x8007a6 <connections+0x8a>
     2b4:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <connections+0x89>
     2b8:	18 82       	st	Y, r1
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	08 95       	ret

000002c0 <arq_new_connection>:
     2c0:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     2c4:	81 11       	cpse	r24, r1
     2c6:	16 c0       	rjmp	.+44     	; 0x2f4 <arq_new_connection+0x34>
     2c8:	ec e1       	ldi	r30, 0x1C	; 28
     2ca:	f7 e0       	ldi	r31, 0x07	; 7
     2cc:	16 8e       	std	Z+30, r1	; 0x1e
     2ce:	15 8e       	std	Z+29, r1	; 0x1d
     2d0:	16 8a       	std	Z+22, r1	; 0x16
     2d2:	15 8a       	std	Z+21, r1	; 0x15
     2d4:	14 a2       	std	Z+36, r1	; 0x24
     2d6:	13 a2       	std	Z+35, r1	; 0x23
     2d8:	12 a2       	std	Z+34, r1	; 0x22
     2da:	11 a2       	std	Z+33, r1	; 0x21
     2dc:	17 8e       	std	Z+31, r1	; 0x1f
     2de:	14 8e       	std	Z+28, r1	; 0x1c
     2e0:	12 8e       	std	Z+26, r1	; 0x1a
     2e2:	11 8e       	std	Z+25, r1	; 0x19
     2e4:	13 8e       	std	Z+27, r1	; 0x1b
     2e6:	10 92 a8 07 	sts	0x07A8, r1	; 0x8007a8 <connections+0x8c>
     2ea:	10 92 a7 07 	sts	0x07A7, r1	; 0x8007a7 <connections+0x8b>
     2ee:	91 e0       	ldi	r25, 0x01	; 1
     2f0:	90 83       	st	Z, r25
     2f2:	08 95       	ret
     2f4:	8f ef       	ldi	r24, 0xFF	; 255
     2f6:	08 95       	ret

000002f8 <arq_connect>:
     2f8:	cf 92       	push	r12
     2fa:	df 92       	push	r13
     2fc:	ef 92       	push	r14
     2fe:	ff 92       	push	r15
     300:	0f 93       	push	r16
     302:	1f 93       	push	r17
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	1f 92       	push	r1
     30a:	cd b7       	in	r28, 0x3d	; 61
     30c:	de b7       	in	r29, 0x3e	; 62
     30e:	69 01       	movw	r12, r18
     310:	e8 2e       	mov	r14, r24
     312:	f1 2c       	mov	r15, r1
     314:	9d e8       	ldi	r25, 0x8D	; 141
     316:	89 9f       	mul	r24, r25
     318:	80 01       	movw	r16, r0
     31a:	11 24       	eor	r1, r1
     31c:	04 5e       	subi	r16, 0xE4	; 228
     31e:	18 4f       	sbci	r17, 0xF8	; 248
     320:	83 e0       	ldi	r24, 0x03	; 3
     322:	f8 01       	movw	r30, r16
     324:	80 83       	st	Z, r24
     326:	50 8f       	std	Z+24, r21	; 0x18
     328:	47 8b       	std	Z+23, r20	; 0x17
     32a:	60 a3       	std	Z+32, r22	; 0x20
     32c:	82 e0       	ldi	r24, 0x02	; 2
     32e:	89 83       	std	Y+1, r24	; 0x01
     330:	0e 94 42 2b 	call	0x5684	; 0x5684 <xTaskGetCurrentTaskHandle>
     334:	f8 01       	movw	r30, r16
     336:	e5 57       	subi	r30, 0x75	; 117
     338:	ff 4f       	sbci	r31, 0xFF	; 255
     33a:	91 83       	std	Z+1, r25	; 0x01
     33c:	80 83       	st	Z, r24
     33e:	0e 94 7d 2e 	call	0x5cfa	; 0x5cfa <xTaskNotifyStateClear>
     342:	21 e0       	ldi	r18, 0x01	; 1
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	ae 01       	movw	r20, r28
     348:	4f 5f       	subi	r20, 0xFF	; 255
     34a:	5f 4f       	sbci	r21, 0xFF	; 255
     34c:	61 e0       	ldi	r22, 0x01	; 1
     34e:	f8 01       	movw	r30, r16
     350:	80 a1       	ldd	r24, Z+32	; 0x20
     352:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <network_send>
     356:	b6 01       	movw	r22, r12
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	0e 94 fb 2b 	call	0x57f6	; 0x57f6 <ulTaskNotifyTake>
     35e:	67 2b       	or	r22, r23
     360:	68 2b       	or	r22, r24
     362:	69 2b       	or	r22, r25
     364:	61 f4       	brne	.+24     	; 0x37e <arq_connect+0x86>
     366:	8d e8       	ldi	r24, 0x8D	; 141
     368:	8e 9d       	mul	r24, r14
     36a:	f0 01       	movw	r30, r0
     36c:	8f 9d       	mul	r24, r15
     36e:	f0 0d       	add	r31, r0
     370:	11 24       	eor	r1, r1
     372:	e4 5e       	subi	r30, 0xE4	; 228
     374:	f8 4f       	sbci	r31, 0xF8	; 248
     376:	81 e0       	ldi	r24, 0x01	; 1
     378:	80 83       	st	Z, r24
     37a:	80 e0       	ldi	r24, 0x00	; 0
     37c:	2e c0       	rjmp	.+92     	; 0x3da <arq_connect+0xe2>
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	91 e0       	ldi	r25, 0x01	; 1
     382:	a7 d6       	rcall	.+3406   	; 0x10d2 <pvPortMalloc>
     384:	00 97       	sbiw	r24, 0x00	; 0
     386:	31 f1       	breq	.+76     	; 0x3d4 <arq_connect+0xdc>
     388:	4d e8       	ldi	r20, 0x8D	; 141
     38a:	4e 9d       	mul	r20, r14
     38c:	90 01       	movw	r18, r0
     38e:	4f 9d       	mul	r20, r15
     390:	30 0d       	add	r19, r0
     392:	11 24       	eor	r1, r1
     394:	40 e0       	ldi	r20, 0x00	; 0
     396:	51 e0       	ldi	r21, 0x01	; 1
     398:	bc 01       	movw	r22, r24
     39a:	c9 01       	movw	r24, r18
     39c:	83 5e       	subi	r24, 0xE3	; 227
     39e:	98 4f       	sbci	r25, 0xF8	; 248
     3a0:	5b d3       	rcall	.+1718   	; 0xa58 <buffer_init>
     3a2:	84 e1       	ldi	r24, 0x14	; 20
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	95 d6       	rcall	.+3370   	; 0x10d2 <pvPortMalloc>
     3a8:	00 97       	sbiw	r24, 0x00	; 0
     3aa:	b1 f0       	breq	.+44     	; 0x3d8 <arq_connect+0xe0>
     3ac:	2d e8       	ldi	r18, 0x8D	; 141
     3ae:	2e 9d       	mul	r18, r14
     3b0:	80 01       	movw	r16, r0
     3b2:	2f 9d       	mul	r18, r15
     3b4:	10 0d       	add	r17, r0
     3b6:	11 24       	eor	r1, r1
     3b8:	44 e1       	ldi	r20, 0x14	; 20
     3ba:	50 e0       	ldi	r21, 0x00	; 0
     3bc:	bc 01       	movw	r22, r24
     3be:	c8 01       	movw	r24, r16
     3c0:	89 5d       	subi	r24, 0xD9	; 217
     3c2:	98 4f       	sbci	r25, 0xF8	; 248
     3c4:	49 d3       	rcall	.+1682   	; 0xa58 <buffer_init>
     3c6:	f8 01       	movw	r30, r16
     3c8:	e4 5e       	subi	r30, 0xE4	; 228
     3ca:	f8 4f       	sbci	r31, 0xF8	; 248
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	80 83       	st	Z, r24
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	03 c0       	rjmp	.+6      	; 0x3da <arq_connect+0xe2>
     3d4:	8f ef       	ldi	r24, 0xFF	; 255
     3d6:	01 c0       	rjmp	.+2      	; 0x3da <arq_connect+0xe2>
     3d8:	8f ef       	ldi	r24, 0xFF	; 255
     3da:	0f 90       	pop	r0
     3dc:	df 91       	pop	r29
     3de:	cf 91       	pop	r28
     3e0:	1f 91       	pop	r17
     3e2:	0f 91       	pop	r16
     3e4:	ff 90       	pop	r15
     3e6:	ef 90       	pop	r14
     3e8:	df 90       	pop	r13
     3ea:	cf 90       	pop	r12
     3ec:	08 95       	ret

000003ee <arq_close_connection>:
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
     3f2:	81 11       	cpse	r24, r1
     3f4:	34 c0       	rjmp	.+104    	; 0x45e <__FUSE_REGION_LENGTH__+0x5e>
     3f6:	20 e0       	ldi	r18, 0x00	; 0
     3f8:	4f ef       	ldi	r20, 0xFF	; 255
     3fa:	5f ef       	ldi	r21, 0xFF	; 255
     3fc:	60 e0       	ldi	r22, 0x00	; 0
     3fe:	70 e0       	ldi	r23, 0x00	; 0
     400:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     404:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     408:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
     40c:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     410:	82 30       	cpi	r24, 0x02	; 2
     412:	51 f0       	breq	.+20     	; 0x428 <__FUSE_REGION_LENGTH__+0x28>
     414:	60 e0       	ldi	r22, 0x00	; 0
     416:	70 e0       	ldi	r23, 0x00	; 0
     418:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     41c:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     420:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	1c c0       	rjmp	.+56     	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     428:	cc e1       	ldi	r28, 0x1C	; 28
     42a:	d7 e0       	ldi	r29, 0x07	; 7
     42c:	89 81       	ldd	r24, Y+1	; 0x01
     42e:	9a 81       	ldd	r25, Y+2	; 0x02
     430:	5a d7       	rcall	.+3764   	; 0x12e6 <vPortFree>
     432:	8b 85       	ldd	r24, Y+11	; 0x0b
     434:	9c 85       	ldd	r25, Y+12	; 0x0c
     436:	57 d7       	rcall	.+3758   	; 0x12e6 <vPortFree>
     438:	81 e0       	ldi	r24, 0x01	; 1
     43a:	88 83       	st	Y, r24
     43c:	ef 89       	ldd	r30, Y+23	; 0x17
     43e:	f8 8d       	ldd	r31, Y+24	; 0x18
     440:	60 e0       	ldi	r22, 0x00	; 0
     442:	70 e0       	ldi	r23, 0x00	; 0
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	19 95       	eicall
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     452:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     456:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
     45a:	81 e0       	ldi	r24, 0x01	; 1
     45c:	01 c0       	rjmp	.+2      	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	08 95       	ret

00000466 <arq_send>:
     466:	ef 92       	push	r14
     468:	ff 92       	push	r15
     46a:	0f 93       	push	r16
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	df 93       	push	r29
     472:	00 d0       	rcall	.+0      	; 0x474 <arq_send+0xe>
     474:	1f 92       	push	r1
     476:	cd b7       	in	r28, 0x3d	; 61
     478:	de b7       	in	r29, 0x3e	; 62
     47a:	5c 83       	std	Y+4, r21	; 0x04
     47c:	4b 83       	std	Y+3, r20	; 0x03
     47e:	81 11       	cpse	r24, r1
     480:	7b c0       	rjmp	.+246    	; 0x578 <arq_send+0x112>
     482:	7b 01       	movw	r14, r22
     484:	20 e0       	ldi	r18, 0x00	; 0
     486:	4f ef       	ldi	r20, 0xFF	; 255
     488:	5f ef       	ldi	r21, 0xFF	; 255
     48a:	60 e0       	ldi	r22, 0x00	; 0
     48c:	70 e0       	ldi	r23, 0x00	; 0
     48e:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     492:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     496:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
     49a:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     49e:	82 30       	cpi	r24, 0x02	; 2
     4a0:	51 f4       	brne	.+20     	; 0x4b6 <arq_send+0x50>
     4a2:	e1 14       	cp	r14, r1
     4a4:	f1 04       	cpc	r15, r1
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <arq_send+0x50>
     4a8:	0b 81       	ldd	r16, Y+3	; 0x03
     4aa:	1c 81       	ldd	r17, Y+4	; 0x04
     4ac:	c8 01       	movw	r24, r16
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	84 36       	cpi	r24, 0x64	; 100
     4b2:	91 05       	cpc	r25, r1
     4b4:	50 f0       	brcs	.+20     	; 0x4ca <arq_send+0x64>
     4b6:	60 e0       	ldi	r22, 0x00	; 0
     4b8:	70 e0       	ldi	r23, 0x00	; 0
     4ba:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     4be:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     4c2:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	58 c0       	rjmp	.+176    	; 0x57a <arq_send+0x114>
     4ca:	0e 5f       	subi	r16, 0xFE	; 254
     4cc:	1f 4f       	sbci	r17, 0xFF	; 255
     4ce:	20 91 25 07 	lds	r18, 0x0725	; 0x800725 <connections+0x9>
     4d2:	30 91 26 07 	lds	r19, 0x0726	; 0x800726 <connections+0xa>
     4d6:	80 e0       	ldi	r24, 0x00	; 0
     4d8:	91 e0       	ldi	r25, 0x01	; 1
     4da:	82 1b       	sub	r24, r18
     4dc:	93 0b       	sbc	r25, r19
     4de:	08 17       	cp	r16, r24
     4e0:	19 07       	cpc	r17, r25
     4e2:	08 f0       	brcs	.+2      	; 0x4e6 <arq_send+0x80>
     4e4:	3f c0       	rjmp	.+126    	; 0x564 <arq_send+0xfe>
     4e6:	20 91 2f 07 	lds	r18, 0x072F	; 0x80072f <connections+0x13>
     4ea:	30 91 30 07 	lds	r19, 0x0730	; 0x800730 <connections+0x14>
     4ee:	84 e1       	ldi	r24, 0x14	; 20
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	82 1b       	sub	r24, r18
     4f4:	93 0b       	sbc	r25, r19
     4f6:	02 97       	sbiw	r24, 0x02	; 2
     4f8:	a8 f1       	brcs	.+106    	; 0x564 <arq_send+0xfe>
     4fa:	8a e2       	ldi	r24, 0x2A	; 42
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	9a 83       	std	Y+2, r25	; 0x02
     500:	89 83       	std	Y+1, r24	; 0x01
     502:	42 e0       	ldi	r20, 0x02	; 2
     504:	50 e0       	ldi	r21, 0x00	; 0
     506:	be 01       	movw	r22, r28
     508:	6d 5f       	subi	r22, 0xFD	; 253
     50a:	7f 4f       	sbci	r23, 0xFF	; 255
     50c:	8d e1       	ldi	r24, 0x1D	; 29
     50e:	97 e0       	ldi	r25, 0x07	; 7
     510:	b5 d2       	rcall	.+1386   	; 0xa7c <buffer_append>
     512:	4b 81       	ldd	r20, Y+3	; 0x03
     514:	5c 81       	ldd	r21, Y+4	; 0x04
     516:	b7 01       	movw	r22, r14
     518:	8d e1       	ldi	r24, 0x1D	; 29
     51a:	97 e0       	ldi	r25, 0x07	; 7
     51c:	af d2       	rcall	.+1374   	; 0xa7c <buffer_append>
     51e:	01 15       	cp	r16, r1
     520:	11 05       	cpc	r17, r1
     522:	b1 f0       	breq	.+44     	; 0x550 <arq_send+0xea>
     524:	90 2f       	mov	r25, r16
     526:	81 2f       	mov	r24, r17
     528:	0b 32       	cpi	r16, 0x2B	; 43
     52a:	11 05       	cpc	r17, r1
     52c:	10 f0       	brcs	.+4      	; 0x532 <arq_send+0xcc>
     52e:	9a e2       	ldi	r25, 0x2A	; 42
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	99 83       	std	Y+1, r25	; 0x01
     534:	8a 83       	std	Y+2, r24	; 0x02
     536:	42 e0       	ldi	r20, 0x02	; 2
     538:	50 e0       	ldi	r21, 0x00	; 0
     53a:	be 01       	movw	r22, r28
     53c:	6f 5f       	subi	r22, 0xFF	; 255
     53e:	7f 4f       	sbci	r23, 0xFF	; 255
     540:	87 e2       	ldi	r24, 0x27	; 39
     542:	97 e0       	ldi	r25, 0x07	; 7
     544:	9b d2       	rcall	.+1334   	; 0xa7c <buffer_append>
     546:	89 81       	ldd	r24, Y+1	; 0x01
     548:	9a 81       	ldd	r25, Y+2	; 0x02
     54a:	08 1b       	sub	r16, r24
     54c:	19 0b       	sbc	r17, r25
     54e:	51 f7       	brne	.-44     	; 0x524 <arq_send+0xbe>
     550:	60 e0       	ldi	r22, 0x00	; 0
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     558:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     55c:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	0b c0       	rjmp	.+22     	; 0x57a <arq_send+0x114>
     564:	60 e0       	ldi	r22, 0x00	; 0
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     56c:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     570:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	01 c0       	rjmp	.+2      	; 0x57a <arq_send+0x114>
     578:	80 e0       	ldi	r24, 0x00	; 0
     57a:	0f 90       	pop	r0
     57c:	0f 90       	pop	r0
     57e:	0f 90       	pop	r0
     580:	0f 90       	pop	r0
     582:	df 91       	pop	r29
     584:	cf 91       	pop	r28
     586:	1f 91       	pop	r17
     588:	0f 91       	pop	r16
     58a:	ff 90       	pop	r15
     58c:	ef 90       	pop	r14
     58e:	08 95       	ret

00000590 <arq_send_ack>:

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	1f 92       	push	r1
     596:	1f 92       	push	r1
     598:	cd b7       	in	r28, 0x3d	; 61
     59a:	de b7       	in	r29, 0x3e	; 62
  if(id >= MAX_CONNECTIONS) return 0;
     59c:	81 11       	cpse	r24, r1
     59e:	14 c0       	rjmp	.+40     	; 0x5c8 <arq_send_ack+0x38>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
     5a0:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     5a4:	82 30       	cpi	r24, 0x02	; 2
     5a6:	91 f4       	brne	.+36     	; 0x5cc <arq_send_ack+0x3c>
     5a8:	66 23       	and	r22, r22
     5aa:	94 f0       	brlt	.+36     	; 0x5d0 <arq_send_ack+0x40>
    return 0;
  }
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	89 83       	std	Y+1, r24	; 0x01
  data[1] = sequence_number;
     5b0:	6a 83       	std	Y+2, r22	; 0x02
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
     5b2:	22 e0       	ldi	r18, 0x02	; 2
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	ae 01       	movw	r20, r28
     5b8:	4f 5f       	subi	r20, 0xFF	; 255
     5ba:	5f 4f       	sbci	r21, 0xFF	; 255
     5bc:	61 e0       	ldi	r22, 0x01	; 1
     5be:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <connections+0x20>
     5c2:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <network_send>
     5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <arq_send_ack+0x42>
uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
  if(id >= MAX_CONNECTIONS) return 0;
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	03 c0       	rjmp	.+6      	; 0x5d2 <arq_send_ack+0x42>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
    return 0;
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <arq_send_ack+0x42>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}
     5d2:	0f 90       	pop	r0
     5d4:	0f 90       	pop	r0
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	08 95       	ret

000005dc <sender>:
/  When the transmit window has available space, it removes segments from the send buffer 
/  and sends them. It also increments a retransmit timer and timeout timer. When the retransmit timer
/  expires the function resends all the segments in the transmit window. On timeout the connection is
/  closed. 
*/
void sender(arq_connection id) { 
     5dc:	af 92       	push	r10
     5de:	bf 92       	push	r11
     5e0:	cf 92       	push	r12
     5e2:	df 92       	push	r13
     5e4:	ef 92       	push	r14
     5e6:	ff 92       	push	r15
     5e8:	0f 93       	push	r16
     5ea:	1f 93       	push	r17
     5ec:	cf 93       	push	r28
     5ee:	df 93       	push	r29
     5f0:	cd b7       	in	r28, 0x3d	; 61
     5f2:	de b7       	in	r29, 0x3e	; 62
     5f4:	ae 97       	sbiw	r28, 0x2e	; 46
     5f6:	0f b6       	in	r0, 0x3f	; 63
     5f8:	f8 94       	cli
     5fa:	de bf       	out	0x3e, r29	; 62
     5fc:	0f be       	out	0x3f, r0	; 63
     5fe:	cd bf       	out	0x3d, r28	; 61
  if(id >= MAX_CONNECTIONS) return;
     600:	81 11       	cpse	r24, r1
     602:	db c0       	rjmp	.+438    	; 0x7ba <sender+0x1de>
  arq_connection_t *con = &connections[id];
  if(con->status == STATUS_NONE) return;
     604:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     608:	88 23       	and	r24, r24
     60a:	09 f4       	brne	.+2      	; 0x60e <sender+0x32>
     60c:	d6 c0       	rjmp	.+428    	; 0x7ba <sender+0x1de>
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     60e:	20 e0       	ldi	r18, 0x00	; 0
     610:	4f ef       	ldi	r20, 0xFF	; 255
     612:	5f ef       	ldi	r21, 0xFF	; 255
     614:	60 e0       	ldi	r22, 0x00	; 0
     616:	70 e0       	ldi	r23, 0x00	; 0
     618:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     61c:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     620:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
  
  if(con->status != STATUS_CONNECTED) {
     624:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     628:	82 30       	cpi	r24, 0x02	; 2
     62a:	49 f0       	breq	.+18     	; 0x63e <sender+0x62>
    xSemaphoreGive(con->mutex);
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     634:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     638:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
    return;
     63c:	be c0       	rjmp	.+380    	; 0x7ba <sender+0x1de>
  }

  if(con->timer_started) {
     63e:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <connections+0x1f>
     642:	88 23       	and	r24, r24
     644:	09 f4       	brne	.+2      	; 0x648 <sender+0x6c>
     646:	62 c0       	rjmp	.+196    	; 0x70c <sender+0x130>
    con->timeout += 10;
     648:	ec e1       	ldi	r30, 0x1C	; 28
     64a:	f7 e0       	ldi	r31, 0x07	; 7
     64c:	85 8d       	ldd	r24, Z+29	; 0x1d
     64e:	96 8d       	ldd	r25, Z+30	; 0x1e
     650:	0a 96       	adiw	r24, 0x0a	; 10
     652:	96 8f       	std	Z+30, r25	; 0x1e
     654:	85 8f       	std	Z+29, r24	; 0x1d
    con->timer += 10;
     656:	24 8d       	ldd	r18, Z+28	; 0x1c
     658:	26 5f       	subi	r18, 0xF6	; 246
     65a:	24 8f       	std	Z+28, r18	; 0x1c
    if(con->timeout > LOST_CONNECTION_TIMEOUT_MS) { 
     65c:	89 3e       	cpi	r24, 0xE9	; 233
     65e:	93 40       	sbci	r25, 0x03	; 3
     660:	58 f0       	brcs	.+22     	; 0x678 <sender+0x9c>
      xSemaphoreGive(con->mutex);
     662:	60 e0       	ldi	r22, 0x00	; 0
     664:	70 e0       	ldi	r23, 0x00	; 0
     666:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     66a:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     66e:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
      arq_close_connection(id);
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	bc de       	rcall	.-648    	; 0x3ee <arq_close_connection>
      return;
     676:	a1 c0       	rjmp	.+322    	; 0x7ba <sender+0x1de>
    }
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
     678:	29 3c       	cpi	r18, 0xC9	; 201
     67a:	08 f4       	brcc	.+2      	; 0x67e <sender+0xa2>
     67c:	47 c0       	rjmp	.+142    	; 0x70c <sender+0x130>
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
     67e:	ec e1       	ldi	r30, 0x1C	; 28
     680:	f7 e0       	ldi	r31, 0x07	; 7
     682:	07 81       	ldd	r16, Z+7	; 0x07
     684:	10 85       	ldd	r17, Z+8	; 0x08
      uint16_t len = 0;
     686:	1e a6       	std	Y+46, r1	; 0x2e
     688:	1d a6       	std	Y+45, r1	; 0x2d
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
     68a:	a1 8c       	ldd	r10, Z+25	; 0x19
     68c:	83 8d       	ldd	r24, Z+27	; 0x1b
     68e:	a8 1a       	sub	r10, r24
     690:	8a 2d       	mov	r24, r10
     692:	8f 77       	andi	r24, 0x7F	; 127
     694:	a8 2e       	mov	r10, r24
      while(i < resend_count) {
     696:	c1 f1       	breq	.+112    	; 0x708 <sender+0x12c>
     698:	c1 2c       	mov	r12, r1
     69a:	d1 2c       	mov	r13, r1
     69c:	b1 2c       	mov	r11, r1
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
        data[1] = (con->sequence_base+i) & 127; 
     69e:	7f 01       	movw	r14, r30
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
     6a0:	19 82       	std	Y+1, r1	; 0x01
        data[1] = (con->sequence_base+i) & 127; 
     6a2:	f7 01       	movw	r30, r14
     6a4:	83 8d       	ldd	r24, Z+27	; 0x1b
     6a6:	8b 0d       	add	r24, r11
     6a8:	8f 77       	andi	r24, 0x7F	; 127
     6aa:	8a 83       	std	Y+2, r24	; 0x02
        buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*i, 2);
     6ac:	41 89       	ldd	r20, Z+17	; 0x11
     6ae:	52 89       	ldd	r21, Z+18	; 0x12
     6b0:	4c 0d       	add	r20, r12
     6b2:	5d 1d       	adc	r21, r13
     6b4:	22 e0       	ldi	r18, 0x02	; 2
     6b6:	30 e0       	ldi	r19, 0x00	; 0
     6b8:	be 01       	movw	r22, r28
     6ba:	63 5d       	subi	r22, 0xD3	; 211
     6bc:	7f 4f       	sbci	r23, 0xFF	; 255
     6be:	87 e2       	ldi	r24, 0x27	; 39
     6c0:	97 e0       	ldi	r25, 0x07	; 7
     6c2:	8b d2       	rcall	.+1302   	; 0xbda <buffer_read>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
     6c4:	2d a5       	ldd	r18, Y+45	; 0x2d
     6c6:	3e a5       	ldd	r19, Y+46	; 0x2e
     6c8:	a8 01       	movw	r20, r16
     6ca:	be 01       	movw	r22, r28
     6cc:	6d 5f       	subi	r22, 0xFD	; 253
     6ce:	7f 4f       	sbci	r23, 0xFF	; 255
     6d0:	8d e1       	ldi	r24, 0x1D	; 29
     6d2:	97 e0       	ldi	r25, 0x07	; 7
     6d4:	82 d2       	rcall	.+1284   	; 0xbda <buffer_read>
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
     6d6:	2d a5       	ldd	r18, Y+45	; 0x2d
     6d8:	3e a5       	ldd	r19, Y+46	; 0x2e
     6da:	02 0f       	add	r16, r18
     6dc:	13 1f       	adc	r17, r19
     6de:	f7 01       	movw	r30, r14
     6e0:	83 81       	ldd	r24, Z+3	; 0x03
     6e2:	94 81       	ldd	r25, Z+4	; 0x04
     6e4:	01 97       	sbiw	r24, 0x01	; 1
     6e6:	08 23       	and	r16, r24
     6e8:	19 23       	and	r17, r25
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     6ea:	2e 5f       	subi	r18, 0xFE	; 254
     6ec:	3f 4f       	sbci	r19, 0xFF	; 255
     6ee:	ae 01       	movw	r20, r28
     6f0:	4f 5f       	subi	r20, 0xFF	; 255
     6f2:	5f 4f       	sbci	r21, 0xFF	; 255
     6f4:	61 e0       	ldi	r22, 0x01	; 1
     6f6:	80 a1       	ldd	r24, Z+32	; 0x20
     6f8:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <network_send>
        ++i;
     6fc:	b3 94       	inc	r11
     6fe:	f2 e0       	ldi	r31, 0x02	; 2
     700:	cf 0e       	add	r12, r31
     702:	d1 1c       	adc	r13, r1
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
     704:	ab 10       	cpse	r10, r11
     706:	cc cf       	rjmp	.-104    	; 0x6a0 <sender+0xc4>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
        ++i;
      }
      con->timer = 0;
     708:	10 92 38 07 	sts	0x0738, r1	; 0x800738 <connections+0x1c>
    }
  }
  if( ((con->sequence_number-con->sequence_base) & 127) < WINDOW_SIZE && con->send_buffer.head != con->send_buffer_window_end) {
     70c:	ec e1       	ldi	r30, 0x1C	; 28
     70e:	f7 e0       	ldi	r31, 0x07	; 7
     710:	81 8d       	ldd	r24, Z+25	; 0x19
     712:	48 2f       	mov	r20, r24
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	93 8d       	ldd	r25, Z+27	; 0x1b
     718:	49 1b       	sub	r20, r25
     71a:	51 09       	sbc	r21, r1
     71c:	4f 77       	andi	r20, 0x7F	; 127
     71e:	55 27       	eor	r21, r21
     720:	44 30       	cpi	r20, 0x04	; 4
     722:	51 05       	cpc	r21, r1
     724:	0c f0       	brlt	.+2      	; 0x728 <sender+0x14c>
     726:	41 c0       	rjmp	.+130    	; 0x7aa <sender+0x1ce>
     728:	65 81       	ldd	r22, Z+5	; 0x05
     72a:	76 81       	ldd	r23, Z+6	; 0x06
     72c:	25 89       	ldd	r18, Z+21	; 0x15
     72e:	36 89       	ldd	r19, Z+22	; 0x16
     730:	62 17       	cp	r22, r18
     732:	73 07       	cpc	r23, r19
     734:	d1 f1       	breq	.+116    	; 0x7aa <sender+0x1ce>
    uint8_t data[MAX_PAYLOAD_SIZE];
    uint16_t len;
    data[0] = TYPE_DATA;
     736:	19 82       	std	Y+1, r1	; 0x01
    data[1] = con->sequence_number;
     738:	8a 83       	std	Y+2, r24	; 0x02
    buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*((con->sequence_number-con->sequence_base) & 127), 2);
     73a:	8f 01       	movw	r16, r30
     73c:	44 0f       	add	r20, r20
     73e:	55 1f       	adc	r21, r21
     740:	81 89       	ldd	r24, Z+17	; 0x11
     742:	92 89       	ldd	r25, Z+18	; 0x12
     744:	48 0f       	add	r20, r24
     746:	59 1f       	adc	r21, r25
     748:	22 e0       	ldi	r18, 0x02	; 2
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	be 01       	movw	r22, r28
     74e:	63 5d       	subi	r22, 0xD3	; 211
     750:	7f 4f       	sbci	r23, 0xFF	; 255
     752:	87 e2       	ldi	r24, 0x27	; 39
     754:	97 e0       	ldi	r25, 0x07	; 7
     756:	41 d2       	rcall	.+1154   	; 0xbda <buffer_read>
    buffer_read(&con->send_buffer, &data[2], con->send_buffer_window_end, len);
     758:	2d a5       	ldd	r18, Y+45	; 0x2d
     75a:	3e a5       	ldd	r19, Y+46	; 0x2e
     75c:	f8 01       	movw	r30, r16
     75e:	45 89       	ldd	r20, Z+21	; 0x15
     760:	56 89       	ldd	r21, Z+22	; 0x16
     762:	be 01       	movw	r22, r28
     764:	6d 5f       	subi	r22, 0xFD	; 253
     766:	7f 4f       	sbci	r23, 0xFF	; 255
     768:	8d e1       	ldi	r24, 0x1D	; 29
     76a:	97 e0       	ldi	r25, 0x07	; 7
     76c:	36 d2       	rcall	.+1132   	; 0xbda <buffer_read>
    con->send_buffer_window_end = (con->send_buffer_window_end+len) & (con->send_buffer.capacity-1);
     76e:	2d a5       	ldd	r18, Y+45	; 0x2d
     770:	3e a5       	ldd	r19, Y+46	; 0x2e
     772:	f8 01       	movw	r30, r16
     774:	85 89       	ldd	r24, Z+21	; 0x15
     776:	96 89       	ldd	r25, Z+22	; 0x16
     778:	a9 01       	movw	r20, r18
     77a:	48 0f       	add	r20, r24
     77c:	59 1f       	adc	r21, r25
     77e:	83 81       	ldd	r24, Z+3	; 0x03
     780:	94 81       	ldd	r25, Z+4	; 0x04
     782:	01 97       	sbiw	r24, 0x01	; 1
     784:	84 23       	and	r24, r20
     786:	95 23       	and	r25, r21
     788:	96 8b       	std	Z+22, r25	; 0x16
     78a:	85 8b       	std	Z+21, r24	; 0x15
    con->timer_started = 1;
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	87 8f       	std	Z+31, r24	; 0x1f
    con->sequence_number = (con->sequence_number+1) & 127;
     790:	81 8d       	ldd	r24, Z+25	; 0x19
     792:	8f 5f       	subi	r24, 0xFF	; 255
     794:	8f 77       	andi	r24, 0x7F	; 127
     796:	81 8f       	std	Z+25, r24	; 0x19
    network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     798:	2e 5f       	subi	r18, 0xFE	; 254
     79a:	3f 4f       	sbci	r19, 0xFF	; 255
     79c:	ae 01       	movw	r20, r28
     79e:	4f 5f       	subi	r20, 0xFF	; 255
     7a0:	5f 4f       	sbci	r21, 0xFF	; 255
     7a2:	61 e0       	ldi	r22, 0x01	; 1
     7a4:	80 a1       	ldd	r24, Z+32	; 0x20
     7a6:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <network_send>
  } 
  
  xSemaphoreGive(con->mutex);
     7aa:	60 e0       	ldi	r22, 0x00	; 0
     7ac:	70 e0       	ldi	r23, 0x00	; 0
     7ae:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     7b2:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     7b6:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
}
     7ba:	ae 96       	adiw	r28, 0x2e	; 46
     7bc:	0f b6       	in	r0, 0x3f	; 63
     7be:	f8 94       	cli
     7c0:	de bf       	out	0x3e, r29	; 62
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	cd bf       	out	0x3d, r28	; 61
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	df 90       	pop	r13
     7d4:	cf 90       	pop	r12
     7d6:	bf 90       	pop	r11
     7d8:	af 90       	pop	r10
     7da:	08 95       	ret

000007dc <arq_reassembly>:

void arq_reassembly(arq_connection id, uint8_t *data, uint16_t len) { 
     7dc:	0f 93       	push	r16
     7de:	1f 93       	push	r17
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	ea 01       	movw	r28, r20
  if(id >= MAX_CONNECTIONS) return;
     7e6:	81 11       	cpse	r24, r1
     7e8:	41 c0       	rjmp	.+130    	; 0x86c <arq_reassembly+0x90>
  
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
     7ea:	80 91 3f 07 	lds	r24, 0x073F	; 0x80073f <connections+0x23>
     7ee:	90 91 40 07 	lds	r25, 0x0740	; 0x800740 <connections+0x24>
     7f2:	89 2b       	or	r24, r25
     7f4:	99 f4       	brne	.+38     	; 0x81c <arq_reassembly+0x40>
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
     7f6:	db 01       	movw	r26, r22
     7f8:	11 96       	adiw	r26, 0x01	; 1
     7fa:	8c 91       	ld	r24, X
     7fc:	11 97       	sbiw	r26, 0x01	; 1
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	98 2f       	mov	r25, r24
     802:	88 27       	eor	r24, r24
     804:	2c 91       	ld	r18, X
     806:	82 2b       	or	r24, r18
     808:	90 93 40 07 	sts	0x0740, r25	; 0x800740 <connections+0x24>
     80c:	80 93 3f 07 	sts	0x073F, r24	; 0x80073f <connections+0x23>
    len-=2; // Remove the header from the length, left with the length of the payload
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
     810:	85 36       	cpi	r24, 0x65	; 101
     812:	91 05       	cpc	r25, r1
     814:	58 f5       	brcc	.+86     	; 0x86c <arq_reassembly+0x90>
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
    len-=2; // Remove the header from the length, left with the length of the payload
     816:	22 97       	sbiw	r28, 0x02	; 2
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
     818:	6e 5f       	subi	r22, 0xFE	; 254
     81a:	7f 4f       	sbci	r23, 0xFF	; 255
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
      return;
    }
  } 
  memcpy(con->message+con->num_received_bytes, data, len);
     81c:	0c e1       	ldi	r16, 0x1C	; 28
     81e:	17 e0       	ldi	r17, 0x07	; 7
     820:	f8 01       	movw	r30, r16
     822:	81 a1       	ldd	r24, Z+33	; 0x21
     824:	92 a1       	ldd	r25, Z+34	; 0x22
     826:	ae 01       	movw	r20, r28
     828:	8f 5b       	subi	r24, 0xBF	; 191
     82a:	98 4f       	sbci	r25, 0xF8	; 248
     82c:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
  con->num_received_bytes += len;
     830:	d8 01       	movw	r26, r16
     832:	91 96       	adiw	r26, 0x21	; 33
     834:	6d 91       	ld	r22, X+
     836:	7c 91       	ld	r23, X
     838:	92 97       	sbiw	r26, 0x22	; 34
     83a:	6c 0f       	add	r22, r28
     83c:	7d 1f       	adc	r23, r29
     83e:	92 96       	adiw	r26, 0x22	; 34
     840:	7c 93       	st	X, r23
     842:	6e 93       	st	-X, r22
     844:	91 97       	sbiw	r26, 0x21	; 33
  
  if(con->num_received_bytes == con->receive_message_length) {
     846:	93 96       	adiw	r26, 0x23	; 35
     848:	8d 91       	ld	r24, X+
     84a:	9c 91       	ld	r25, X
     84c:	94 97       	sbiw	r26, 0x24	; 36
     84e:	68 17       	cp	r22, r24
     850:	79 07       	cpc	r23, r25
     852:	61 f4       	brne	.+24     	; 0x86c <arq_reassembly+0x90>
    con->callback_data_received(con->message, con->num_received_bytes);
     854:	57 96       	adiw	r26, 0x17	; 23
     856:	ed 91       	ld	r30, X+
     858:	fc 91       	ld	r31, X
     85a:	58 97       	sbiw	r26, 0x18	; 24
     85c:	81 e4       	ldi	r24, 0x41	; 65
     85e:	97 e0       	ldi	r25, 0x07	; 7
     860:	19 95       	eicall
    con->num_received_bytes = con->receive_message_length = 0;
     862:	f8 01       	movw	r30, r16
     864:	14 a2       	std	Z+36, r1	; 0x24
     866:	13 a2       	std	Z+35, r1	; 0x23
     868:	12 a2       	std	Z+34, r1	; 0x22
     86a:	11 a2       	std	Z+33, r1	; 0x21
  }
}
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	1f 91       	pop	r17
     872:	0f 91       	pop	r16
     874:	08 95       	ret

00000876 <receiver>:
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
     876:	9f 92       	push	r9
     878:	af 92       	push	r10
     87a:	bf 92       	push	r11
     87c:	cf 92       	push	r12
     87e:	df 92       	push	r13
     880:	ef 92       	push	r14
     882:	ff 92       	push	r15
     884:	0f 93       	push	r16
     886:	1f 93       	push	r17
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	1f 92       	push	r1
     88e:	cd b7       	in	r28, 0x3d	; 61
     890:	de b7       	in	r29, 0x3e	; 62
     892:	8b 01       	movw	r16, r22
     894:	5a 01       	movw	r10, r20
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
     896:	90 91 3c 07 	lds	r25, 0x073C	; 0x80073c <connections+0x20>
     89a:	98 13       	cpse	r25, r24
     89c:	b8 c0       	rjmp	.+368    	; 0xa0e <receiver+0x198>
     89e:	90 91 1c 07 	lds	r25, 0x071C	; 0x80071c <connections>
     8a2:	99 23       	and	r25, r25
     8a4:	09 f4       	brne	.+2      	; 0x8a8 <receiver+0x32>
     8a6:	b3 c0       	rjmp	.+358    	; 0xa0e <receiver+0x198>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     8a8:	fb 01       	movw	r30, r22
     8aa:	d0 80       	ld	r13, Z
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
      con = &connections[i];
     8ac:	0f 2e       	mov	r0, r31
     8ae:	fc e1       	ldi	r31, 0x1C	; 28
     8b0:	ef 2e       	mov	r14, r31
     8b2:	f7 e0       	ldi	r31, 0x07	; 7
     8b4:	ff 2e       	mov	r15, r31
     8b6:	f0 2d       	mov	r31, r0
     8b8:	13 c0       	rjmp	.+38     	; 0x8e0 <receiver+0x6a>
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
  if(con == NULL && type == TYPE_SYN && listening_task != NULL) {
     8ba:	e0 91 1a 07 	lds	r30, 0x071A	; 0x80071a <__data_end>
     8be:	f0 91 1b 07 	lds	r31, 0x071B	; 0x80071b <__data_end+0x1>
     8c2:	30 97       	sbiw	r30, 0x00	; 0
     8c4:	59 f0       	breq	.+22     	; 0x8dc <receiver+0x66>
    xTaskNotify(listening_task, address, eSetValueWithOverwrite);
     8c6:	48 2f       	mov	r20, r24
     8c8:	50 e0       	ldi	r21, 0x00	; 0
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	70 e0       	ldi	r23, 0x00	; 0
     8ce:	00 e0       	ldi	r16, 0x00	; 0
     8d0:	10 e0       	ldi	r17, 0x00	; 0
     8d2:	23 e0       	ldi	r18, 0x03	; 3
     8d4:	cf 01       	movw	r24, r30
     8d6:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <xTaskGenericNotify>
    return;
     8da:	aa c0       	rjmp	.+340    	; 0xa30 <receiver+0x1ba>
     8dc:	e1 2c       	mov	r14, r1
     8de:	f1 2c       	mov	r15, r1
  }
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     8e0:	20 e0       	ldi	r18, 0x00	; 0
     8e2:	4f ef       	ldi	r20, 0xFF	; 255
     8e4:	5f ef       	ldi	r21, 0xFF	; 255
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	70 e0       	ldi	r23, 0x00	; 0
     8ea:	f7 01       	movw	r30, r14
     8ec:	e7 57       	subi	r30, 0x77	; 119
     8ee:	ff 4f       	sbci	r31, 0xFF	; 255
     8f0:	80 81       	ld	r24, Z
     8f2:	91 81       	ldd	r25, Z+1	; 0x01
     8f4:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
  
  if(con->status == STATUS_CLOSED || con->status == STATUS_NONE || len == 0 || data == NULL) {
     8f8:	f7 01       	movw	r30, r14
     8fa:	80 81       	ld	r24, Z
     8fc:	82 30       	cpi	r24, 0x02	; 2
     8fe:	30 f0       	brcs	.+12     	; 0x90c <receiver+0x96>
     900:	a1 14       	cp	r10, r1
     902:	b1 04       	cpc	r11, r1
     904:	19 f0       	breq	.+6      	; 0x90c <receiver+0x96>
     906:	01 15       	cp	r16, r1
     908:	11 05       	cpc	r17, r1
     90a:	51 f4       	brne	.+20     	; 0x920 <receiver+0xaa>
    xSemaphoreGive(con->mutex);
     90c:	f7 01       	movw	r30, r14
     90e:	e7 57       	subi	r30, 0x77	; 119
     910:	ff 4f       	sbci	r31, 0xFF	; 255
     912:	60 e0       	ldi	r22, 0x00	; 0
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	80 81       	ld	r24, Z
     918:	91 81       	ldd	r25, Z+1	; 0x01
     91a:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
    return;
     91e:	88 c0       	rjmp	.+272    	; 0xa30 <receiver+0x1ba>
  }
  
  if(con->status == STATUS_CONNECTING && type == TYPE_SYNACK) {
     920:	83 30       	cpi	r24, 0x03	; 3
     922:	21 f5       	brne	.+72     	; 0x96c <receiver+0xf6>
     924:	f3 e0       	ldi	r31, 0x03	; 3
     926:	df 12       	cpse	r13, r31
     928:	21 c0       	rjmp	.+66     	; 0x96c <receiver+0xf6>
    if(con->blocked_task != NULL) {
     92a:	f7 01       	movw	r30, r14
     92c:	e5 57       	subi	r30, 0x75	; 117
     92e:	ff 4f       	sbci	r31, 0xFF	; 255
     930:	80 81       	ld	r24, Z
     932:	91 81       	ldd	r25, Z+1	; 0x01
     934:	00 97       	sbiw	r24, 0x00	; 0
     936:	81 f0       	breq	.+32     	; 0x958 <receiver+0xe2>
      xTaskNotifyGive(con->blocked_task);
     938:	00 e0       	ldi	r16, 0x00	; 0
     93a:	10 e0       	ldi	r17, 0x00	; 0
     93c:	22 e0       	ldi	r18, 0x02	; 2
     93e:	40 e0       	ldi	r20, 0x00	; 0
     940:	50 e0       	ldi	r21, 0x00	; 0
     942:	ba 01       	movw	r22, r20
     944:	0e 94 71 2d 	call	0x5ae2	; 0x5ae2 <xTaskGenericNotify>
      con->blocked_task = NULL;
     948:	f7 01       	movw	r30, r14
     94a:	e5 57       	subi	r30, 0x75	; 117
     94c:	ff 4f       	sbci	r31, 0xFF	; 255
     94e:	11 82       	std	Z+1, r1	; 0x01
     950:	10 82       	st	Z, r1
      arq_send_ack(id, 0x00);
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	1c de       	rcall	.-968    	; 0x590 <arq_send_ack>
    }
    
    xSemaphoreGive(con->mutex);
     958:	f7 01       	movw	r30, r14
     95a:	e7 57       	subi	r30, 0x77	; 119
     95c:	ff 4f       	sbci	r31, 0xFF	; 255
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	70 e0       	ldi	r23, 0x00	; 0
     962:	80 81       	ld	r24, Z
     964:	91 81       	ldd	r25, Z+1	; 0x01
     966:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
    return;
     96a:	62 c0       	rjmp	.+196    	; 0xa30 <receiver+0x1ba>
  }
  
  uint8_t sequence = data[1];
     96c:	f8 01       	movw	r30, r16
     96e:	c1 80       	ldd	r12, Z+1	; 0x01
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
     970:	dd 20       	and	r13, r13
     972:	09 f4       	brne	.+2      	; 0x976 <receiver+0x100>
     974:	52 c0       	rjmp	.+164    	; 0xa1a <receiver+0x1a4>
     976:	f4 e0       	ldi	r31, 0x04	; 4
     978:	df 12       	cpse	r13, r31
     97a:	13 c0       	rjmp	.+38     	; 0x9a2 <receiver+0x12c>
     97c:	53 c0       	rjmp	.+166    	; 0xa24 <receiver+0x1ae>
    if(sequence == con->request_number) {
      if(type == TYPE_DATA) arq_reassembly(id, &data[2], len-2);
     97e:	a5 01       	movw	r20, r10
     980:	42 50       	subi	r20, 0x02	; 2
     982:	51 09       	sbc	r21, r1
     984:	b8 01       	movw	r22, r16
     986:	6e 5f       	subi	r22, 0xFE	; 254
     988:	7f 4f       	sbci	r23, 0xFF	; 255
     98a:	80 e0       	ldi	r24, 0x00	; 0
     98c:	27 df       	rcall	.-434    	; 0x7dc <arq_reassembly>
      con->request_number = (con->request_number+1) & 127;
     98e:	f7 01       	movw	r30, r14
     990:	82 8d       	ldd	r24, Z+26	; 0x1a
     992:	8f 5f       	subi	r24, 0xFF	; 255
     994:	8f 77       	andi	r24, 0x7F	; 127
     996:	82 8f       	std	Z+26, r24	; 0x1a
    }
    arq_send_ack(id, con->request_number);
     998:	f7 01       	movw	r30, r14
     99a:	62 8d       	ldd	r22, Z+26	; 0x1a
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	f8 dd       	rcall	.-1040   	; 0x590 <arq_send_ack>
     9a0:	2c c0       	rjmp	.+88     	; 0x9fa <receiver+0x184>
  } else if(type == TYPE_ACK) {
     9a2:	f1 e0       	ldi	r31, 0x01	; 1
     9a4:	df 12       	cpse	r13, r31
     9a6:	29 c0       	rjmp	.+82     	; 0x9fa <receiver+0x184>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
     9a8:	f7 01       	movw	r30, r14
     9aa:	83 8d       	ldd	r24, Z+27	; 0x1b
     9ac:	fc 2d       	mov	r31, r12
     9ae:	f8 1b       	sub	r31, r24
     9b0:	8f 2f       	mov	r24, r31
     9b2:	8f 77       	andi	r24, 0x7F	; 127
     9b4:	98 2e       	mov	r9, r24
    if(count != 0) {
     9b6:	09 f1       	breq	.+66     	; 0x9fa <receiver+0x184>
     9b8:	d1 2c       	mov	r13, r1
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9ba:	57 01       	movw	r10, r14
     9bc:	8b e0       	ldi	r24, 0x0B	; 11
     9be:	a8 0e       	add	r10, r24
     9c0:	b1 1c       	adc	r11, r1
        buffer_remove(&con->send_buffer, NULL, len);
     9c2:	87 01       	movw	r16, r14
     9c4:	0f 5f       	subi	r16, 0xFF	; 255
     9c6:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9c8:	42 e0       	ldi	r20, 0x02	; 2
     9ca:	50 e0       	ldi	r21, 0x00	; 0
     9cc:	be 01       	movw	r22, r28
     9ce:	6f 5f       	subi	r22, 0xFF	; 255
     9d0:	7f 4f       	sbci	r23, 0xFF	; 255
     9d2:	c5 01       	movw	r24, r10
     9d4:	50 d1       	rcall	.+672    	; 0xc76 <buffer_remove>
        buffer_remove(&con->send_buffer, NULL, len);
     9d6:	49 81       	ldd	r20, Y+1	; 0x01
     9d8:	50 e0       	ldi	r21, 0x00	; 0
     9da:	60 e0       	ldi	r22, 0x00	; 0
     9dc:	70 e0       	ldi	r23, 0x00	; 0
     9de:	c8 01       	movw	r24, r16
     9e0:	4a d1       	rcall	.+660    	; 0xc76 <buffer_remove>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
     9e2:	d3 94       	inc	r13
     9e4:	9d 10       	cpse	r9, r13
     9e6:	f0 cf       	rjmp	.-32     	; 0x9c8 <receiver+0x152>
        buffer_remove(&con->segment_lengths, &len, 2);
        buffer_remove(&con->send_buffer, NULL, len);
      }
      con->sequence_base = sequence;
     9e8:	f7 01       	movw	r30, r14
     9ea:	c3 8e       	std	Z+27, r12	; 0x1b

      con->timer = 0;
     9ec:	14 8e       	std	Z+28, r1	; 0x1c
      con->timeout = 0;
     9ee:	16 8e       	std	Z+30, r1	; 0x1e
     9f0:	15 8e       	std	Z+29, r1	; 0x1d
      if(con->sequence_base == con->sequence_number) con->timer_started = 0; // No more un-acked packets
     9f2:	81 8d       	ldd	r24, Z+25	; 0x19
     9f4:	c8 12       	cpse	r12, r24
     9f6:	01 c0       	rjmp	.+2      	; 0x9fa <receiver+0x184>
     9f8:	17 8e       	std	Z+31, r1	; 0x1f
    }
  }
  
  xSemaphoreGive(con->mutex);
     9fa:	f7 01       	movw	r30, r14
     9fc:	e7 57       	subi	r30, 0x77	; 119
     9fe:	ff 4f       	sbci	r31, 0xFF	; 255
     a00:	60 e0       	ldi	r22, 0x00	; 0
     a02:	70 e0       	ldi	r23, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	91 81       	ldd	r25, Z+1	; 0x01
     a08:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
     a0c:	11 c0       	rjmp	.+34     	; 0xa30 <receiver+0x1ba>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     a0e:	f8 01       	movw	r30, r16
     a10:	d0 80       	ld	r13, Z
  
  if(con == NULL && type != TYPE_SYN) return;
     a12:	f2 e0       	ldi	r31, 0x02	; 2
     a14:	df 12       	cpse	r13, r31
     a16:	0c c0       	rjmp	.+24     	; 0xa30 <receiver+0x1ba>
     a18:	50 cf       	rjmp	.-352    	; 0x8ba <receiver+0x44>
    return;
  }
  
  uint8_t sequence = data[1];
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
    if(sequence == con->request_number) {
     a1a:	f7 01       	movw	r30, r14
     a1c:	82 8d       	ldd	r24, Z+26	; 0x1a
     a1e:	c8 12       	cpse	r12, r24
     a20:	bb cf       	rjmp	.-138    	; 0x998 <receiver+0x122>
     a22:	ad cf       	rjmp	.-166    	; 0x97e <receiver+0x108>
     a24:	f7 01       	movw	r30, r14
     a26:	82 8d       	ldd	r24, Z+26	; 0x1a
     a28:	c8 16       	cp	r12, r24
     a2a:	09 f4       	brne	.+2      	; 0xa2e <receiver+0x1b8>
     a2c:	b0 cf       	rjmp	.-160    	; 0x98e <receiver+0x118>
     a2e:	b4 cf       	rjmp	.-152    	; 0x998 <receiver+0x122>
    }
  }
  
  xSemaphoreGive(con->mutex);
  
}
     a30:	0f 90       	pop	r0
     a32:	df 91       	pop	r29
     a34:	cf 91       	pop	r28
     a36:	1f 91       	pop	r17
     a38:	0f 91       	pop	r16
     a3a:	ff 90       	pop	r15
     a3c:	ef 90       	pop	r14
     a3e:	df 90       	pop	r13
     a40:	cf 90       	pop	r12
     a42:	bf 90       	pop	r11
     a44:	af 90       	pop	r10
     a46:	9f 90       	pop	r9
     a48:	08 95       	ret

00000a4a <vARQTask>:
void vARQTask(void *pvParamters) {
  uint8_t i;
  
  while(1) {
    for(i=0;i<MAX_CONNECTIONS;i++) {
		sender(i);
     a4a:	80 e0       	ldi	r24, 0x00	; 0
     a4c:	c7 dd       	rcall	.-1138   	; 0x5dc <sender>
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
     a4e:	8a e0       	ldi	r24, 0x0A	; 10
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vTaskDelay>
     a56:	f9 cf       	rjmp	.-14     	; 0xa4a <vARQTask>

00000a58 <buffer_init>:
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
     a58:	fc 01       	movw	r30, r24
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a5a:	61 15       	cp	r22, r1
     a5c:	71 05       	cpc	r23, r1
     a5e:	61 f0       	breq	.+24     	; 0xa78 <buffer_init+0x20>
  b->buf = buf;
     a60:	71 83       	std	Z+1, r23	; 0x01
     a62:	60 83       	st	Z, r22
  b->capacity = size;
     a64:	53 83       	std	Z+3, r21	; 0x03
     a66:	42 83       	std	Z+2, r20	; 0x02
  b->head = b->tail = b->len = 0;
     a68:	11 86       	std	Z+9, r1	; 0x09
     a6a:	10 86       	std	Z+8, r1	; 0x08
     a6c:	17 82       	std	Z+7, r1	; 0x07
     a6e:	16 82       	std	Z+6, r1	; 0x06
     a70:	15 82       	std	Z+5, r1	; 0x05
     a72:	14 82       	std	Z+4, r1	; 0x04
  return 1;
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	08 95       	ret
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a78:	80 e0       	ldi	r24, 0x00	; 0
  b->buf = buf;
  b->capacity = size;
  b->head = b->tail = b->len = 0;
  return 1;
}
     a7a:	08 95       	ret

00000a7c <buffer_append>:

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	ec 01       	movw	r28, r24
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     a8a:	2a 81       	ldd	r18, Y+2	; 0x02
     a8c:	3b 81       	ldd	r19, Y+3	; 0x03
     a8e:	88 85       	ldd	r24, Y+8	; 0x08
     a90:	99 85       	ldd	r25, Y+9	; 0x09
     a92:	f9 01       	movw	r30, r18
     a94:	e8 1b       	sub	r30, r24
     a96:	f9 0b       	sbc	r31, r25
     a98:	e4 17       	cp	r30, r20
     a9a:	f5 07       	cpc	r31, r21
     a9c:	08 f4       	brcc	.+2      	; 0xaa0 <buffer_append+0x24>
     a9e:	49 c0       	rjmp	.+146    	; 0xb32 <buffer_append+0xb6>
     aa0:	8a 01       	movw	r16, r20
     aa2:	7b 01       	movw	r14, r22
  if(len < b->capacity - b->head) {
     aa4:	8c 81       	ldd	r24, Y+4	; 0x04
     aa6:	9d 81       	ldd	r25, Y+5	; 0x05
     aa8:	a9 01       	movw	r20, r18
     aaa:	48 1b       	sub	r20, r24
     aac:	59 0b       	sbc	r21, r25
     aae:	04 17       	cp	r16, r20
     ab0:	15 07       	cpc	r17, r21
     ab2:	a8 f4       	brcc	.+42     	; 0xade <buffer_append+0x62>
    memcpy(b->buf+b->head, data, len);
     ab4:	28 81       	ld	r18, Y
     ab6:	39 81       	ldd	r19, Y+1	; 0x01
     ab8:	a8 01       	movw	r20, r16
     aba:	82 0f       	add	r24, r18
     abc:	93 1f       	adc	r25, r19
     abe:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    b->head += len;
     ac2:	8c 81       	ldd	r24, Y+4	; 0x04
     ac4:	9d 81       	ldd	r25, Y+5	; 0x05
     ac6:	80 0f       	add	r24, r16
     ac8:	91 1f       	adc	r25, r17
     aca:	9d 83       	std	Y+5, r25	; 0x05
     acc:	8c 83       	std	Y+4, r24	; 0x04
    if(b->head == b->capacity) b->head = 0;
     ace:	2a 81       	ldd	r18, Y+2	; 0x02
     ad0:	3b 81       	ldd	r19, Y+3	; 0x03
     ad2:	82 17       	cp	r24, r18
     ad4:	93 07       	cpc	r25, r19
     ad6:	21 f5       	brne	.+72     	; 0xb20 <buffer_append+0xa4>
     ad8:	1d 82       	std	Y+5, r1	; 0x05
     ada:	1c 82       	std	Y+4, r1	; 0x04
     adc:	21 c0       	rjmp	.+66     	; 0xb20 <buffer_append+0xa4>
  } else {
    memcpy(b->buf+b->head, data, (b->capacity - b->head) );
     ade:	28 81       	ld	r18, Y
     ae0:	39 81       	ldd	r19, Y+1	; 0x01
     ae2:	82 0f       	add	r24, r18
     ae4:	93 1f       	adc	r25, r19
     ae6:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
     aea:	8c 81       	ldd	r24, Y+4	; 0x04
     aec:	9d 81       	ldd	r25, Y+5	; 0x05
     aee:	6a 81       	ldd	r22, Y+2	; 0x02
     af0:	7b 81       	ldd	r23, Y+3	; 0x03
     af2:	ac 01       	movw	r20, r24
     af4:	46 1b       	sub	r20, r22
     af6:	57 0b       	sbc	r21, r23
     af8:	40 0f       	add	r20, r16
     afa:	51 1f       	adc	r21, r17
     afc:	68 1b       	sub	r22, r24
     afe:	79 0b       	sbc	r23, r25
     b00:	6e 0d       	add	r22, r14
     b02:	7f 1d       	adc	r23, r15
     b04:	88 81       	ld	r24, Y
     b06:	99 81       	ldd	r25, Y+1	; 0x01
     b08:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    b->head = len-(b->capacity - b->head);
     b0c:	8c 81       	ldd	r24, Y+4	; 0x04
     b0e:	9d 81       	ldd	r25, Y+5	; 0x05
     b10:	2a 81       	ldd	r18, Y+2	; 0x02
     b12:	3b 81       	ldd	r19, Y+3	; 0x03
     b14:	82 1b       	sub	r24, r18
     b16:	93 0b       	sbc	r25, r19
     b18:	80 0f       	add	r24, r16
     b1a:	91 1f       	adc	r25, r17
     b1c:	9d 83       	std	Y+5, r25	; 0x05
     b1e:	8c 83       	std	Y+4, r24	; 0x04
  }
  b->len += len;
     b20:	48 85       	ldd	r20, Y+8	; 0x08
     b22:	59 85       	ldd	r21, Y+9	; 0x09
     b24:	04 0f       	add	r16, r20
     b26:	15 1f       	adc	r17, r21
     b28:	19 87       	std	Y+9, r17	; 0x09
     b2a:	08 87       	std	Y+8, r16	; 0x08
  return 1;
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	02 c0       	rjmp	.+4      	; 0xb36 <buffer_append+0xba>
  b->head = b->tail = b->len = 0;
  return 1;
}

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	90 e0       	ldi	r25, 0x00	; 0
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
    b->head = len-(b->capacity - b->head);
  }
  b->len += len;
  return 1;
}
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	08 95       	ret

00000b44 <buffer_remove_token>:

//This reads bytes from the buffer until token is found, or nbytes is reached
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
     b44:	0f 93       	push	r16
     b46:	1f 93       	push	r17
     b48:	cf 93       	push	r28
     b4a:	df 93       	push	r29
     b4c:	fc 01       	movw	r30, r24
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     b4e:	21 15       	cp	r18, r1
     b50:	31 05       	cpc	r19, r1
     b52:	c9 f1       	breq	.+114    	; 0xbc6 <buffer_remove_token+0x82>
    if( b->tail != b->head ){ //see if any data is available
     b54:	a6 81       	ldd	r26, Z+6	; 0x06
     b56:	b7 81       	ldd	r27, Z+7	; 0x07
     b58:	84 81       	ldd	r24, Z+4	; 0x04
     b5a:	95 81       	ldd	r25, Z+5	; 0x05
     b5c:	a8 17       	cp	r26, r24
     b5e:	b9 07       	cpc	r27, r25
     b60:	a9 f1       	breq	.+106    	; 0xbcc <buffer_remove_token+0x88>
     b62:	c6 2f       	mov	r28, r22
     b64:	d7 2f       	mov	r29, r23
     b66:	80 e0       	ldi	r24, 0x00	; 0
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	07 c0       	rjmp	.+14     	; 0xb7a <buffer_remove_token+0x36>
     b6c:	a6 81       	ldd	r26, Z+6	; 0x06
     b6e:	b7 81       	ldd	r27, Z+7	; 0x07
     b70:	64 81       	ldd	r22, Z+4	; 0x04
     b72:	75 81       	ldd	r23, Z+5	; 0x05
     b74:	a6 17       	cp	r26, r22
     b76:	b7 07       	cpc	r27, r23
     b78:	59 f1       	breq	.+86     	; 0xbd0 <buffer_remove_token+0x8c>
      *p++ = b->buf[b->tail];  //grab a byte from the buffer
     b7a:	60 81       	ld	r22, Z
     b7c:	71 81       	ldd	r23, Z+1	; 0x01
     b7e:	a6 0f       	add	r26, r22
     b80:	b7 1f       	adc	r27, r23
     b82:	5c 91       	ld	r21, X
     b84:	8e 01       	movw	r16, r28
     b86:	58 83       	st	Y, r21
      b->tail++;  //increment the tail
     b88:	66 81       	ldd	r22, Z+6	; 0x06
     b8a:	77 81       	ldd	r23, Z+7	; 0x07
     b8c:	6f 5f       	subi	r22, 0xFF	; 255
     b8e:	7f 4f       	sbci	r23, 0xFF	; 255
     b90:	77 83       	std	Z+7, r23	; 0x07
     b92:	66 83       	std	Z+6, r22	; 0x06
      b->len--;
     b94:	a0 85       	ldd	r26, Z+8	; 0x08
     b96:	b1 85       	ldd	r27, Z+9	; 0x09
     b98:	11 97       	sbiw	r26, 0x01	; 1
     b9a:	b1 87       	std	Z+9, r27	; 0x09
     b9c:	a0 87       	std	Z+8, r26	; 0x08
      if( b->tail == b->capacity ){  //check for wrap-around
     b9e:	a2 81       	ldd	r26, Z+2	; 0x02
     ba0:	b3 81       	ldd	r27, Z+3	; 0x03
     ba2:	6a 17       	cp	r22, r26
     ba4:	7b 07       	cpc	r23, r27
     ba6:	11 f4       	brne	.+4      	; 0xbac <buffer_remove_token+0x68>
        b->tail = 0;
     ba8:	17 82       	std	Z+7, r1	; 0x07
     baa:	16 82       	std	Z+6, r1	; 0x06
     bac:	21 96       	adiw	r28, 0x01	; 1
      }
      if(*(p-1) == token) return i+1;
     bae:	d8 01       	movw	r26, r16
     bb0:	5c 91       	ld	r21, X
     bb2:	54 13       	cpse	r21, r20
     bb4:	02 c0       	rjmp	.+4      	; 0xbba <buffer_remove_token+0x76>
     bb6:	01 96       	adiw	r24, 0x01	; 1
     bb8:	0b c0       	rjmp	.+22     	; 0xbd0 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     bba:	01 96       	adiw	r24, 0x01	; 1
     bbc:	28 17       	cp	r18, r24
     bbe:	39 07       	cpc	r19, r25
     bc0:	a9 f6       	brne	.-86     	; 0xb6c <buffer_remove_token+0x28>
      if(*(p-1) == token) return i+1;
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
     bc2:	c9 01       	movw	r24, r18
     bc4:	05 c0       	rjmp	.+10     	; 0xbd0 <buffer_remove_token+0x8c>
     bc6:	80 e0       	ldi	r24, 0x00	; 0
     bc8:	90 e0       	ldi	r25, 0x00	; 0
     bca:	02 c0       	rjmp	.+4      	; 0xbd0 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     bcc:	80 e0       	ldi	r24, 0x00	; 0
     bce:	90 e0       	ldi	r25, 0x00	; 0
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
}
     bd0:	df 91       	pop	r29
     bd2:	cf 91       	pop	r28
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	08 95       	ret

00000bda <buffer_read>:
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
     bda:	cf 92       	push	r12
     bdc:	df 92       	push	r13
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	7c 01       	movw	r14, r24
     bec:	6b 01       	movw	r12, r22
     bee:	ea 01       	movw	r28, r20
     bf0:	89 01       	movw	r16, r18
  if(data == NULL) return 0;
     bf2:	67 2b       	or	r22, r23
     bf4:	a9 f1       	breq	.+106    	; 0xc60 <buffer_read+0x86>
  if(idx >= b->capacity) idx -= b->capacity;
     bf6:	fc 01       	movw	r30, r24
     bf8:	42 81       	ldd	r20, Z+2	; 0x02
     bfa:	53 81       	ldd	r21, Z+3	; 0x03
     bfc:	c4 17       	cp	r28, r20
     bfe:	d5 07       	cpc	r29, r21
     c00:	10 f0       	brcs	.+4      	; 0xc06 <buffer_read+0x2c>
     c02:	c4 1b       	sub	r28, r20
     c04:	d5 0b       	sbc	r29, r21
  if(b->capacity - idx >= len) {
     c06:	4c 1b       	sub	r20, r28
     c08:	5d 0b       	sbc	r21, r29
     c0a:	40 17       	cp	r20, r16
     c0c:	51 07       	cpc	r21, r17
     c0e:	60 f0       	brcs	.+24     	; 0xc28 <buffer_read+0x4e>
    memcpy(data, b->buf+idx, len);
     c10:	f7 01       	movw	r30, r14
     c12:	60 81       	ld	r22, Z
     c14:	71 81       	ldd	r23, Z+1	; 0x01
     c16:	6c 0f       	add	r22, r28
     c18:	7d 1f       	adc	r23, r29
     c1a:	a8 01       	movw	r20, r16
     c1c:	c6 01       	movw	r24, r12
     c1e:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
     c22:	80 2f       	mov	r24, r16
     c24:	91 2f       	mov	r25, r17
     c26:	1e c0       	rjmp	.+60     	; 0xc64 <buffer_read+0x8a>
  if(data == NULL) return 0;
  if(idx >= b->capacity) idx -= b->capacity;
  if(b->capacity - idx >= len) {
    memcpy(data, b->buf+idx, len);
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
     c28:	f7 01       	movw	r30, r14
     c2a:	60 81       	ld	r22, Z
     c2c:	71 81       	ldd	r23, Z+1	; 0x01
     c2e:	6c 0f       	add	r22, r28
     c30:	7d 1f       	adc	r23, r29
     c32:	c6 01       	movw	r24, r12
     c34:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
     c38:	f7 01       	movw	r30, r14
     c3a:	22 81       	ldd	r18, Z+2	; 0x02
     c3c:	33 81       	ldd	r19, Z+3	; 0x03
     c3e:	c9 01       	movw	r24, r18
     c40:	8c 1b       	sub	r24, r28
     c42:	9d 0b       	sbc	r25, r29
     c44:	a8 01       	movw	r20, r16
     c46:	42 1b       	sub	r20, r18
     c48:	53 0b       	sbc	r21, r19
     c4a:	4c 0f       	add	r20, r28
     c4c:	5d 1f       	adc	r21, r29
     c4e:	60 81       	ld	r22, Z
     c50:	71 81       	ldd	r23, Z+1	; 0x01
     c52:	8c 0d       	add	r24, r12
     c54:	9d 1d       	adc	r25, r13
     c56:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
  }
  return len;
     c5a:	80 2f       	mov	r24, r16
     c5c:	91 2f       	mov	r25, r17
     c5e:	02 c0       	rjmp	.+4      	; 0xc64 <buffer_read+0x8a>
  }
  return nbytes;
}
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
  if(data == NULL) return 0;
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	90 e0       	ldi	r25, 0x00	; 0
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
}
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	08 95       	ret

00000c76 <buffer_remove>:

//Remove 'len' bytes from the buffer and add them to 'data'
uint16_t buffer_remove(buffer_t *b, uint8_t *data, uint16_t len) {
     c76:	ef 92       	push	r14
     c78:	ff 92       	push	r15
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	ec 01       	movw	r28, r24
     c84:	7b 01       	movw	r14, r22
  if(len > b->len) len = b->len;
     c86:	08 85       	ldd	r16, Y+8	; 0x08
     c88:	19 85       	ldd	r17, Y+9	; 0x09
     c8a:	40 17       	cp	r20, r16
     c8c:	51 07       	cpc	r21, r17
     c8e:	08 f4       	brcc	.+2      	; 0xc92 <buffer_remove+0x1c>
     c90:	8a 01       	movw	r16, r20
  if(b->capacity - b->tail >= len) {
     c92:	8e 81       	ldd	r24, Y+6	; 0x06
     c94:	9f 81       	ldd	r25, Y+7	; 0x07
     c96:	4a 81       	ldd	r20, Y+2	; 0x02
     c98:	5b 81       	ldd	r21, Y+3	; 0x03
     c9a:	48 1b       	sub	r20, r24
     c9c:	59 0b       	sbc	r21, r25
     c9e:	40 17       	cp	r20, r16
     ca0:	51 07       	cpc	r21, r17
     ca2:	c8 f0       	brcs	.+50     	; 0xcd6 <buffer_remove+0x60>
    if(data != NULL) memcpy(data, b->buf+b->tail, len);
     ca4:	e1 14       	cp	r14, r1
     ca6:	f1 04       	cpc	r15, r1
     ca8:	41 f0       	breq	.+16     	; 0xcba <buffer_remove+0x44>
     caa:	68 81       	ld	r22, Y
     cac:	79 81       	ldd	r23, Y+1	; 0x01
     cae:	68 0f       	add	r22, r24
     cb0:	79 1f       	adc	r23, r25
     cb2:	a8 01       	movw	r20, r16
     cb4:	c7 01       	movw	r24, r14
     cb6:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    b->tail = b->tail + len;
     cba:	8e 81       	ldd	r24, Y+6	; 0x06
     cbc:	9f 81       	ldd	r25, Y+7	; 0x07
     cbe:	80 0f       	add	r24, r16
     cc0:	91 1f       	adc	r25, r17
     cc2:	9f 83       	std	Y+7, r25	; 0x07
     cc4:	8e 83       	std	Y+6, r24	; 0x06
    if(b->tail == b->capacity) b->tail = 0;
     cc6:	2a 81       	ldd	r18, Y+2	; 0x02
     cc8:	3b 81       	ldd	r19, Y+3	; 0x03
     cca:	82 17       	cp	r24, r18
     ccc:	93 07       	cpc	r25, r19
     cce:	41 f5       	brne	.+80     	; 0xd20 <buffer_remove+0xaa>
     cd0:	1f 82       	std	Y+7, r1	; 0x07
     cd2:	1e 82       	std	Y+6, r1	; 0x06
     cd4:	25 c0       	rjmp	.+74     	; 0xd20 <buffer_remove+0xaa>
  } else {
    if(data != NULL) {
     cd6:	e1 14       	cp	r14, r1
     cd8:	f1 04       	cpc	r15, r1
     cda:	c1 f0       	breq	.+48     	; 0xd0c <buffer_remove+0x96>
      memcpy(data, b->buf+b->tail, b->capacity - b->tail);
     cdc:	68 81       	ld	r22, Y
     cde:	79 81       	ldd	r23, Y+1	; 0x01
     ce0:	68 0f       	add	r22, r24
     ce2:	79 1f       	adc	r23, r25
     ce4:	c7 01       	movw	r24, r14
     ce6:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
      memcpy(data + (b->capacity - b->tail), b->buf, len - (b->capacity - b->tail) );
     cea:	4e 81       	ldd	r20, Y+6	; 0x06
     cec:	5f 81       	ldd	r21, Y+7	; 0x07
     cee:	2a 81       	ldd	r18, Y+2	; 0x02
     cf0:	3b 81       	ldd	r19, Y+3	; 0x03
     cf2:	c9 01       	movw	r24, r18
     cf4:	84 1b       	sub	r24, r20
     cf6:	95 0b       	sbc	r25, r21
     cf8:	42 1b       	sub	r20, r18
     cfa:	53 0b       	sbc	r21, r19
     cfc:	40 0f       	add	r20, r16
     cfe:	51 1f       	adc	r21, r17
     d00:	68 81       	ld	r22, Y
     d02:	79 81       	ldd	r23, Y+1	; 0x01
     d04:	8e 0d       	add	r24, r14
     d06:	9f 1d       	adc	r25, r15
     d08:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    }
    b->tail = len - (b->capacity - b->tail);
     d0c:	8e 81       	ldd	r24, Y+6	; 0x06
     d0e:	9f 81       	ldd	r25, Y+7	; 0x07
     d10:	2a 81       	ldd	r18, Y+2	; 0x02
     d12:	3b 81       	ldd	r19, Y+3	; 0x03
     d14:	82 1b       	sub	r24, r18
     d16:	93 0b       	sbc	r25, r19
     d18:	80 0f       	add	r24, r16
     d1a:	91 1f       	adc	r25, r17
     d1c:	9f 83       	std	Y+7, r25	; 0x07
     d1e:	8e 83       	std	Y+6, r24	; 0x06
  }
  b->len -= len;
     d20:	88 85       	ldd	r24, Y+8	; 0x08
     d22:	99 85       	ldd	r25, Y+9	; 0x09
     d24:	80 1b       	sub	r24, r16
     d26:	91 0b       	sbc	r25, r17
     d28:	99 87       	std	Y+9, r25	; 0x09
     d2a:	88 87       	std	Y+8, r24	; 0x08
  return len;
     d2c:	c8 01       	movw	r24, r16
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	08 95       	ret

00000d3c <cobs_encode>:
/*****************************************************************************
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     d3c:	ef 92       	push	r14
     d3e:	ff 92       	push	r15
     d40:	0f 93       	push	r16
     d42:	1f 93       	push	r17
     d44:	cf 93       	push	r28
     d46:	df 93       	push	r29
     d48:	7c 01       	movw	r14, r24
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     d4a:	68 0f       	add	r22, r24
     d4c:	79 1f       	adc	r23, r25
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
     d4e:	fc 01       	movw	r30, r24
     d50:	31 96       	adiw	r30, 0x01	; 1
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     d52:	00 97       	sbiw	r24, 0x00	; 0
     d54:	19 f0       	breq	.+6      	; 0xd5c <cobs_encode+0x20>
     d56:	41 15       	cp	r20, r1
     d58:	51 05       	cpc	r21, r1
     d5a:	21 f4       	brne	.+8      	; 0xd64 <cobs_encode+0x28>
    {
        result.status = COBS_ENCODE_NULL_POINTER;
        return result;
     d5c:	60 e0       	ldi	r22, 0x00	; 0
     d5e:	70 e0       	ldi	r23, 0x00	; 0
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	4b c0       	rjmp	.+150    	; 0xdfa <cobs_encode+0xbe>
    }

    if (src_len != 0)
     d64:	21 15       	cp	r18, r1
     d66:	31 05       	cpc	r19, r1
     d68:	59 f1       	breq	.+86     	; 0xdc0 <cobs_encode+0x84>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d6a:	e6 17       	cp	r30, r22
     d6c:	f7 07       	cpc	r31, r23
     d6e:	60 f5       	brcc	.+88     	; 0xdc8 <cobs_encode+0x8c>
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     d70:	8a 01       	movw	r16, r20
     d72:	02 0f       	add	r16, r18
     d74:	13 1f       	adc	r17, r19
     d76:	da 01       	movw	r26, r20
     d78:	ec 01       	movw	r28, r24
     d7a:	91 e0       	ldi	r25, 0x01	; 1
                }
                if (search_len == 0xFF)
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     d7c:	2f ef       	ldi	r18, 0xFF	; 255
     d7e:	04 c0       	rjmp	.+8      	; 0xd88 <cobs_encode+0x4c>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     d80:	fa 01       	movw	r30, r20
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d82:	e6 17       	cp	r30, r22
     d84:	f7 07       	cpc	r31, r23
     d86:	20 f5       	brcc	.+72     	; 0xdd0 <cobs_encode+0x94>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
                break;
            }

            src_byte = *src_ptr++;
     d88:	3d 91       	ld	r19, X+
            if (src_byte == 0)
     d8a:	31 11       	cpse	r19, r1
     d8c:	0a c0       	rjmp	.+20     	; 0xda2 <cobs_encode+0x66>
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
     d8e:	98 83       	st	Y, r25
                dst_code_write_ptr = dst_write_ptr++;
     d90:	cf 01       	movw	r24, r30
     d92:	01 96       	adiw	r24, 0x01	; 1
                search_len = 1;
                if (src_ptr >= src_end_ptr)
     d94:	a0 17       	cp	r26, r16
     d96:	b1 07       	cpc	r27, r17
     d98:	e8 f4       	brcc	.+58     	; 0xdd4 <cobs_encode+0x98>
     d9a:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     d9c:	fc 01       	movw	r30, r24
                search_len = 1;
     d9e:	91 e0       	ldi	r25, 0x01	; 1
     da0:	f0 cf       	rjmp	.-32     	; 0xd82 <cobs_encode+0x46>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     da2:	af 01       	movw	r20, r30
     da4:	4f 5f       	subi	r20, 0xFF	; 255
     da6:	5f 4f       	sbci	r21, 0xFF	; 255
     da8:	30 83       	st	Z, r19
                search_len++;
     daa:	9f 5f       	subi	r25, 0xFF	; 255
                if (src_ptr >= src_end_ptr)
     dac:	a0 17       	cp	r26, r16
     dae:	b1 07       	cpc	r27, r17
     db0:	b0 f4       	brcc	.+44     	; 0xdde <cobs_encode+0xa2>
                {
                    break;
                }
                if (search_len == 0xFF)
     db2:	9f 3f       	cpi	r25, 0xFF	; 255
     db4:	29 f7       	brne	.-54     	; 0xd80 <cobs_encode+0x44>
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     db6:	28 83       	st	Y, r18
                    dst_code_write_ptr = dst_write_ptr++;
     db8:	32 96       	adiw	r30, 0x02	; 2
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     dba:	ea 01       	movw	r28, r20
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
                    dst_code_write_ptr = dst_write_ptr++;
                    search_len = 1;
     dbc:	91 e0       	ldi	r25, 0x01	; 1
     dbe:	e1 cf       	rjmp	.-62     	; 0xd82 <cobs_encode+0x46>
cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
     dc0:	ec 01       	movw	r28, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     dc2:	80 e0       	ldi	r24, 0x00	; 0
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;
     dc4:	91 e0       	ldi	r25, 0x01	; 1
     dc6:	0d c0       	rjmp	.+26     	; 0xde2 <cobs_encode+0xa6>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     dc8:	ec 01       	movw	r28, r24
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dca:	82 e0       	ldi	r24, 0x02	; 2
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     dcc:	91 e0       	ldi	r25, 0x01	; 1
     dce:	09 c0       	rjmp	.+18     	; 0xde2 <cobs_encode+0xa6>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dd0:	82 e0       	ldi	r24, 0x02	; 2
     dd2:	07 c0       	rjmp	.+14     	; 0xde2 <cobs_encode+0xa6>
     dd4:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     dd6:	fc 01       	movw	r30, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     dd8:	80 e0       	ldi	r24, 0x00	; 0
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
                search_len = 1;
     dda:	91 e0       	ldi	r25, 0x01	; 1
     ddc:	02 c0       	rjmp	.+4      	; 0xde2 <cobs_encode+0xa6>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     dde:	fa 01       	movw	r30, r20
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     de0:	80 e0       	ldi	r24, 0x00	; 0

    /* We've reached the end of the source data (or possibly run out of output buffer)
     * Finalise the remaining output. In particular, write the code (length) byte.
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
     de2:	c6 17       	cp	r28, r22
     de4:	d7 07       	cpc	r29, r23
     de6:	18 f4       	brcc	.+6      	; 0xdee <cobs_encode+0xb2>
        dst_write_ptr = dst_buf_end_ptr;
    }
    else
    {
        /* Write the last code (length) byte. */
        *dst_code_write_ptr = search_len;
     de8:	98 83       	st	Y, r25
     dea:	bf 01       	movw	r22, r30
     dec:	01 c0       	rjmp	.+2      	; 0xdf0 <cobs_encode+0xb4>
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
    {
        /* We've run out of output buffer to write the code byte. */
        result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dee:	82 e0       	ldi	r24, 0x02	; 2
    }

    /* Calculate the output length, from the value of dst_code_write_ptr */
    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     df0:	9b 01       	movw	r18, r22
     df2:	2e 19       	sub	r18, r14
     df4:	3f 09       	sbc	r19, r15
     df6:	62 2f       	mov	r22, r18
     df8:	73 2f       	mov	r23, r19
}
     dfa:	df 91       	pop	r29
     dfc:	cf 91       	pop	r28
     dfe:	1f 91       	pop	r17
     e00:	0f 91       	pop	r16
     e02:	ff 90       	pop	r15
     e04:	ef 90       	pop	r14
     e06:	08 95       	ret

00000e08 <cobs_decode>:


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     e08:	af 92       	push	r10
     e0a:	bf 92       	push	r11
     e0c:	cf 92       	push	r12
     e0e:	df 92       	push	r13
     e10:	ef 92       	push	r14
     e12:	ff 92       	push	r15
     e14:	0f 93       	push	r16
     e16:	1f 93       	push	r17
     e18:	cf 93       	push	r28
     e1a:	df 93       	push	r29
     e1c:	7c 01       	movw	r14, r24
     e1e:	da 01       	movw	r26, r20
    uint8_t             i;
    uint8_t             len_code;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     e20:	00 97       	sbiw	r24, 0x00	; 0
     e22:	11 f0       	breq	.+4      	; 0xe28 <cobs_decode+0x20>
     e24:	10 97       	sbiw	r26, 0x00	; 0
     e26:	21 f4       	brne	.+8      	; 0xe30 <cobs_decode+0x28>
    {
        result.status = COBS_DECODE_NULL_POINTER;
        return result;
     e28:	60 e0       	ldi	r22, 0x00	; 0
     e2a:	70 e0       	ldi	r23, 0x00	; 0
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	5f c0       	rjmp	.+190    	; 0xeee <cobs_decode+0xe6>
    }

    if (src_len != 0)
     e30:	21 15       	cp	r18, r1
     e32:	31 05       	cpc	r19, r1
     e34:	09 f4       	brne	.+2      	; 0xe38 <cobs_decode+0x30>
     e36:	4b c0       	rjmp	.+150    	; 0xece <cobs_decode+0xc6>


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     e38:	6a 01       	movw	r12, r20
     e3a:	c2 0e       	add	r12, r18
     e3c:	d3 1e       	adc	r13, r19
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     e3e:	5c 01       	movw	r10, r24
     e40:	a6 0e       	add	r10, r22
     e42:	b7 1e       	adc	r11, r23
     e44:	8c 01       	movw	r16, r24
     e46:	50 e0       	ldi	r21, 0x00	; 0
     e48:	01 c0       	rjmp	.+2      	; 0xe4c <cobs_decode+0x44>
                src_byte = *src_ptr++;
                if (src_byte == 0)
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
     e4a:	8f 01       	movw	r16, r30

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     e4c:	ed 01       	movw	r28, r26
     e4e:	21 96       	adiw	r28, 0x01	; 1
     e50:	7c 91       	ld	r23, X
            if (len_code == 0)
     e52:	71 11       	cpse	r23, r1
     e54:	03 c0       	rjmp	.+6      	; 0xe5c <cobs_decode+0x54>
            {
                result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e56:	54 60       	ori	r21, 0x04	; 4
                break;
     e58:	f8 01       	movw	r30, r16
     e5a:	3d c0       	rjmp	.+122    	; 0xed6 <cobs_decode+0xce>
            }
            len_code--;
     e5c:	71 50       	subi	r23, 0x01	; 1

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
     e5e:	c6 01       	movw	r24, r12
     e60:	8c 1b       	sub	r24, r28
     e62:	9d 0b       	sbc	r25, r29
            if (len_code > remaining_bytes)
     e64:	27 2f       	mov	r18, r23
     e66:	30 e0       	ldi	r19, 0x00	; 0
     e68:	82 17       	cp	r24, r18
     e6a:	93 07       	cpc	r25, r19
     e6c:	10 f4       	brcc	.+4      	; 0xe72 <cobs_decode+0x6a>
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
                len_code = remaining_bytes;
     e6e:	78 2f       	mov	r23, r24

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
     e70:	58 60       	ori	r21, 0x08	; 8
                len_code = remaining_bytes;
            }

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
     e72:	c5 01       	movw	r24, r10
     e74:	80 1b       	sub	r24, r16
     e76:	91 0b       	sbc	r25, r17
            if (len_code > remaining_bytes)
     e78:	27 2f       	mov	r18, r23
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	82 17       	cp	r24, r18
     e7e:	93 07       	cpc	r25, r19
     e80:	10 f4       	brcc	.+4      	; 0xe86 <cobs_decode+0x7e>
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
     e82:	78 2f       	mov	r23, r24

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     e84:	52 60       	ori	r21, 0x02	; 2
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e86:	77 23       	and	r23, r23
     e88:	61 f1       	breq	.+88     	; 0xee2 <cobs_decode+0xda>
     e8a:	de 01       	movw	r26, r28
     e8c:	f8 01       	movw	r30, r16
     e8e:	97 2f       	mov	r25, r23
            {
                src_byte = *src_ptr++;
     e90:	3d 91       	ld	r19, X+
                if (src_byte == 0)
     e92:	31 11       	cpse	r19, r1
     e94:	01 c0       	rjmp	.+2      	; 0xe98 <cobs_decode+0x90>
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e96:	54 60       	ori	r21, 0x04	; 4
                }
                *dst_write_ptr++ = src_byte;
     e98:	31 93       	st	Z+, r19
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e9a:	91 50       	subi	r25, 0x01	; 1
     e9c:	c9 f7       	brne	.-14     	; 0xe90 <cobs_decode+0x88>
     e9e:	ef ef       	ldi	r30, 0xFF	; 255
     ea0:	e7 0f       	add	r30, r23
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	31 96       	adiw	r30, 0x01	; 1
     ea6:	de 01       	movw	r26, r28
     ea8:	ae 0f       	add	r26, r30
     eaa:	bf 1f       	adc	r27, r31
     eac:	e0 0f       	add	r30, r16
     eae:	f1 1f       	adc	r31, r17
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     eb0:	ac 15       	cp	r26, r12
     eb2:	bd 05       	cpc	r27, r13
     eb4:	80 f4       	brcc	.+32     	; 0xed6 <cobs_decode+0xce>
            {
                break;
            }

            /* Add a zero to the end */
            if (len_code != 0xFE)
     eb6:	7e 3f       	cpi	r23, 0xFE	; 254
     eb8:	41 f2       	breq	.-112    	; 0xe4a <cobs_decode+0x42>
            {
                if (dst_write_ptr >= dst_buf_end_ptr)
     eba:	ea 15       	cp	r30, r10
     ebc:	fb 05       	cpc	r31, r11
     ebe:	10 f0       	brcs	.+4      	; 0xec4 <cobs_decode+0xbc>
                {
                    result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     ec0:	52 60       	ori	r21, 0x02	; 2
                    break;
     ec2:	09 c0       	rjmp	.+18     	; 0xed6 <cobs_decode+0xce>
                }
                *dst_write_ptr++ = 0;
     ec4:	8f 01       	movw	r16, r30
     ec6:	0f 5f       	subi	r16, 0xFF	; 255
     ec8:	1f 4f       	sbci	r17, 0xFF	; 255
     eca:	10 82       	st	Z, r1
     ecc:	bf cf       	rjmp	.-130    	; 0xe4c <cobs_decode+0x44>
cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_write_ptr       = dst_buf_ptr;
     ece:	fc 01       	movw	r30, r24
}


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
     ed0:	50 e0       	ldi	r21, 0x00	; 0
     ed2:	01 c0       	rjmp	.+2      	; 0xed6 <cobs_decode+0xce>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ed4:	f8 01       	movw	r30, r16
        }
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     ed6:	ee 19       	sub	r30, r14
     ed8:	ff 09       	sbc	r31, r15
     eda:	6e 2f       	mov	r22, r30
     edc:	7f 2f       	mov	r23, r31
     ede:	85 2f       	mov	r24, r21
     ee0:	06 c0       	rjmp	.+12     	; 0xeee <cobs_decode+0xe6>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ee2:	cc 15       	cp	r28, r12
     ee4:	dd 05       	cpc	r29, r13
     ee6:	b0 f7       	brcc	.-20     	; 0xed4 <cobs_decode+0xcc>
     ee8:	f8 01       	movw	r30, r16

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     eea:	de 01       	movw	r26, r28
     eec:	e6 cf       	rjmp	.-52     	; 0xeba <cobs_decode+0xb2>
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
}
     eee:	df 91       	pop	r29
     ef0:	cf 91       	pop	r28
     ef2:	1f 91       	pop	r17
     ef4:	0f 91       	pop	r16
     ef6:	ff 90       	pop	r15
     ef8:	ef 90       	pop	r14
     efa:	df 90       	pop	r13
     efc:	cf 90       	pop	r12
     efe:	bf 90       	pop	r11
     f00:	af 90       	pop	r10
     f02:	08 95       	ret

00000f04 <vCOM_getData>:
    ui8TWI_write(0x02); // set pointer to measurement mode
    ui8TWI_write(0x00); // continous measurement
    vTWI_stop();
}

void vCOM_getData(int16_t *xCom, int16_t *yCom, int16_t *zCom){
     f04:	ef 92       	push	r14
     f06:	ff 92       	push	r15
     f08:	0f 93       	push	r16
     f0a:	1f 93       	push	r17
     f0c:	cf 93       	push	r28
     f0e:	df 93       	push	r29
     f10:	7c 01       	movw	r14, r24
     f12:	eb 01       	movw	r28, r22
     f14:	8a 01       	movw	r16, r20
    ui8TWI_start(HMC5883L_WRITE);
     f16:	8c e3       	ldi	r24, 0x3C	; 60
     f18:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <ui8TWI_start>
    ui8TWI_write(0x03); // set pointer to X axis MSB
     f1c:	83 e0       	ldi	r24, 0x03	; 3
     f1e:	0e 94 b6 2e 	call	0x5d6c	; 0x5d6c <ui8TWI_write>
    vTWI_stop();
     f22:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <vTWI_stop>
    ui8TWI_start(HMC5883L_READ);
     f26:	8d e3       	ldi	r24, 0x3D	; 61
     f28:	0e 94 91 2e 	call	0x5d22	; 0x5d22 <ui8TWI_start>
    *xCom = ((uint8_t)ui8TWI_read_ack())<<8;
     f2c:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <ui8TWI_read_ack>
     f30:	f7 01       	movw	r30, r14
     f32:	10 82       	st	Z, r1
     f34:	81 83       	std	Z+1, r24	; 0x01
    *xCom |= ui8TWI_read_ack();
     f36:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <ui8TWI_read_ack>
     f3a:	f7 01       	movw	r30, r14
     f3c:	20 81       	ld	r18, Z
     f3e:	31 81       	ldd	r19, Z+1	; 0x01
     f40:	28 2b       	or	r18, r24
     f42:	31 83       	std	Z+1, r19	; 0x01
     f44:	20 83       	st	Z, r18
    *zCom = ((uint8_t)ui8TWI_read_ack())<<8;
     f46:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <ui8TWI_read_ack>
     f4a:	f8 01       	movw	r30, r16
     f4c:	10 82       	st	Z, r1
     f4e:	81 83       	std	Z+1, r24	; 0x01
    *zCom |= ui8TWI_read_ack();
     f50:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <ui8TWI_read_ack>
     f54:	f8 01       	movw	r30, r16
     f56:	20 81       	ld	r18, Z
     f58:	31 81       	ldd	r19, Z+1	; 0x01
     f5a:	28 2b       	or	r18, r24
     f5c:	31 83       	std	Z+1, r19	; 0x01
     f5e:	20 83       	st	Z, r18
    *yCom = ((uint8_t)ui8TWI_read_ack())<<8;
     f60:	0e 94 c8 2e 	call	0x5d90	; 0x5d90 <ui8TWI_read_ack>
     f64:	18 82       	st	Y, r1
     f66:	89 83       	std	Y+1, r24	; 0x01
    *yCom |= ui8TWI_read_nack();
     f68:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <ui8TWI_read_nack>
     f6c:	28 81       	ld	r18, Y
     f6e:	39 81       	ldd	r19, Y+1	; 0x01
     f70:	28 2b       	or	r18, r24
     f72:	39 83       	std	Y+1, r19	; 0x01
     f74:	28 83       	st	Y, r18
    vTWI_stop();
     f76:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <vTWI_stop>
}
     f7a:	df 91       	pop	r29
     f7c:	cf 91       	pop	r28
     f7e:	1f 91       	pop	r17
     f80:	0f 91       	pop	r16
     f82:	ff 90       	pop	r15
     f84:	ef 90       	pop	r14
     f86:	08 95       	ret

00000f88 <crc_ibutton_update>:
     f88:	86 27       	eor	r24, r22
     f8a:	98 e0       	ldi	r25, 0x08	; 8
     f8c:	2c e8       	ldi	r18, 0x8C	; 140
     f8e:	80 ff       	sbrs	r24, 0
     f90:	03 c0       	rjmp	.+6      	; 0xf98 <crc_ibutton_update+0x10>
     f92:	86 95       	lsr	r24
     f94:	82 27       	eor	r24, r18
     f96:	01 c0       	rjmp	.+2      	; 0xf9a <crc_ibutton_update+0x12>
     f98:	86 95       	lsr	r24
     f9a:	91 50       	subi	r25, 0x01	; 1
     f9c:	c1 f7       	brne	.-16     	; 0xf8e <crc_ibutton_update+0x6>
     f9e:	08 95       	ret

00000fa0 <calculate_crc>:
     fa0:	0f 93       	push	r16
     fa2:	1f 93       	push	r17
     fa4:	cf 93       	push	r28
     fa6:	df 93       	push	r29
     fa8:	66 23       	and	r22, r22
     faa:	59 f0       	breq	.+22     	; 0xfc2 <calculate_crc+0x22>
     fac:	8c 01       	movw	r16, r24
     fae:	ec 01       	movw	r28, r24
     fb0:	06 0f       	add	r16, r22
     fb2:	11 1d       	adc	r17, r1
     fb4:	80 e0       	ldi	r24, 0x00	; 0
     fb6:	69 91       	ld	r22, Y+
     fb8:	e7 df       	rcall	.-50     	; 0xf88 <crc_ibutton_update>
     fba:	c0 17       	cp	r28, r16
     fbc:	d1 07       	cpc	r29, r17
     fbe:	d9 f7       	brne	.-10     	; 0xfb6 <calculate_crc+0x16>
     fc0:	01 c0       	rjmp	.+2      	; 0xfc4 <calculate_crc+0x24>
     fc2:	80 e0       	ldi	r24, 0x00	; 0
     fc4:	df 91       	pop	r29
     fc6:	cf 91       	pop	r28
     fc8:	1f 91       	pop	r17
     fca:	0f 91       	pop	r16
     fcc:	08 95       	ret

00000fce <vDistSens_init>:
};

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
     fce:	80 b3       	in	r24, 0x10	; 16
     fd0:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     fd2:	ec e7       	ldi	r30, 0x7C	; 124
     fd4:	f0 e0       	ldi	r31, 0x00	; 0
     fd6:	80 81       	ld	r24, Z
     fd8:	80 6c       	ori	r24, 0xC0	; 192
     fda:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
     fdc:	ea e7       	ldi	r30, 0x7A	; 122
     fde:	f0 e0       	ldi	r31, 0x00	; 0
     fe0:	80 81       	ld	r24, Z
     fe2:	80 68       	ori	r24, 0x80	; 128
     fe4:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
     fe6:	80 81       	ld	r24, Z
     fe8:	84 60       	ori	r24, 0x04	; 4
     fea:	80 83       	st	Z, r24
     fec:	08 95       	ret

00000fee <ui8DistSens_readCM>:
uint8_t ui8DistSens_readCM(uint8_t sensorDirection){
    
    uint8_t ui8_analogValue;
    
    /* Choose channel */
    ADMUX = sensorDirection;
     fee:	ec e7       	ldi	r30, 0x7C	; 124
     ff0:	f0 e0       	ldi	r31, 0x00	; 0
     ff2:	80 83       	st	Z, r24
    
    /* Enable internal 2,54V AREF */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     ff4:	90 81       	ld	r25, Z
     ff6:	90 6c       	ori	r25, 0xC0	; 192
     ff8:	90 83       	st	Z, r25
    
    /* Start conversion */
    ADCSRA |= (1<<ADSC);
     ffa:	ea e7       	ldi	r30, 0x7A	; 122
     ffc:	f0 e0       	ldi	r31, 0x00	; 0
     ffe:	90 81       	ld	r25, Z
    1000:	90 64       	ori	r25, 0x40	; 64
    1002:	90 83       	st	Z, r25
    loop_until_bit_is_clear(ADCSRA, ADSC); // Macro from <avr/io.h>, wait until bit bit in IO register is set.
    1004:	90 81       	ld	r25, Z
    1006:	96 fd       	sbrc	r25, 6
    1008:	fd cf       	rjmp	.-6      	; 0x1004 <ui8DistSens_readCM+0x16>

    /* Return the 8 most significant bits from the 10 bit register */
    ui8_analogValue = (ADCL >> 2) | (ADCH << 6);
    100a:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    100e:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    
    // Returns corresponding distance in CM
    return ui8_analogToCM[sensorDirection-1][ui8_analogValue];
    1012:	e8 2f       	mov	r30, r24
    1014:	f0 e0       	ldi	r31, 0x00	; 0
    1016:	26 95       	lsr	r18
    1018:	26 95       	lsr	r18
    101a:	30 e4       	ldi	r19, 0x40	; 64
    101c:	93 9f       	mul	r25, r19
    101e:	c0 01       	movw	r24, r0
    1020:	11 24       	eor	r1, r1
    1022:	82 2b       	or	r24, r18
    1024:	fe 2f       	mov	r31, r30
    1026:	ee 27       	eor	r30, r30
    1028:	e0 50       	subi	r30, 0x00	; 0
    102a:	ff 4f       	sbci	r31, 0xFF	; 255
    102c:	e8 0f       	add	r30, r24
    102e:	f1 1d       	adc	r31, r1
}
    1030:	80 81       	ld	r24, Z
    1032:	08 95       	ret

00001034 <vFunc_Inf2pi>:
#include <string.h>
#include <math.h>
#include <stdlib.h>

/* Take any angle and put it inside -pi,pi */
void vFunc_Inf2pi(float *angle_in_radians){
    1034:	cf 92       	push	r12
    1036:	df 92       	push	r13
    1038:	ef 92       	push	r14
    103a:	ff 92       	push	r15
    103c:	cf 93       	push	r28
    103e:	df 93       	push	r29
    1040:	ec 01       	movw	r28, r24
    do{
        if (*angle_in_radians > M_PI) *angle_in_radians -= 2*M_PI;
    1042:	c8 80       	ld	r12, Y
    1044:	d9 80       	ldd	r13, Y+1	; 0x01
    1046:	ea 80       	ldd	r14, Y+2	; 0x02
    1048:	fb 80       	ldd	r15, Y+3	; 0x03
    104a:	2b ed       	ldi	r18, 0xDB	; 219
    104c:	3f e0       	ldi	r19, 0x0F	; 15
    104e:	49 e4       	ldi	r20, 0x49	; 73
    1050:	50 e4       	ldi	r21, 0x40	; 64
    1052:	c7 01       	movw	r24, r14
    1054:	b6 01       	movw	r22, r12
    1056:	0e 94 aa 32 	call	0x6554	; 0x6554 <__gesf2>
    105a:	18 16       	cp	r1, r24
    105c:	6c f4       	brge	.+26     	; 0x1078 <vFunc_Inf2pi+0x44>
    105e:	2b ed       	ldi	r18, 0xDB	; 219
    1060:	3f e0       	ldi	r19, 0x0F	; 15
    1062:	49 ec       	ldi	r20, 0xC9	; 201
    1064:	50 e4       	ldi	r21, 0x40	; 64
    1066:	c7 01       	movw	r24, r14
    1068:	b6 01       	movw	r22, r12
    106a:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    106e:	68 83       	st	Y, r22
    1070:	79 83       	std	Y+1, r23	; 0x01
    1072:	8a 83       	std	Y+2, r24	; 0x02
    1074:	9b 83       	std	Y+3, r25	; 0x03
    1076:	16 c0       	rjmp	.+44     	; 0x10a4 <vFunc_Inf2pi+0x70>
        else if (*angle_in_radians < -M_PI) *angle_in_radians += 2*M_PI;
    1078:	2b ed       	ldi	r18, 0xDB	; 219
    107a:	3f e0       	ldi	r19, 0x0F	; 15
    107c:	49 e4       	ldi	r20, 0x49	; 73
    107e:	50 ec       	ldi	r21, 0xC0	; 192
    1080:	c7 01       	movw	r24, r14
    1082:	b6 01       	movw	r22, r12
    1084:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__cmpsf2>
    1088:	88 23       	and	r24, r24
    108a:	64 f4       	brge	.+24     	; 0x10a4 <vFunc_Inf2pi+0x70>
    108c:	2b ed       	ldi	r18, 0xDB	; 219
    108e:	3f e0       	ldi	r19, 0x0F	; 15
    1090:	49 ec       	ldi	r20, 0xC9	; 201
    1092:	50 e4       	ldi	r21, 0x40	; 64
    1094:	c7 01       	movw	r24, r14
    1096:	b6 01       	movw	r22, r12
    1098:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    109c:	68 83       	st	Y, r22
    109e:	79 83       	std	Y+1, r23	; 0x01
    10a0:	8a 83       	std	Y+2, r24	; 0x02
    10a2:	9b 83       	std	Y+3, r25	; 0x03
    } while (fabs(*angle_in_radians) > M_PI);
    10a4:	88 81       	ld	r24, Y
    10a6:	99 81       	ldd	r25, Y+1	; 0x01
    10a8:	aa 81       	ldd	r26, Y+2	; 0x02
    10aa:	bb 81       	ldd	r27, Y+3	; 0x03
    10ac:	bc 01       	movw	r22, r24
    10ae:	cd 01       	movw	r24, r26
    10b0:	9f 77       	andi	r25, 0x7F	; 127
    10b2:	2b ed       	ldi	r18, 0xDB	; 219
    10b4:	3f e0       	ldi	r19, 0x0F	; 15
    10b6:	49 e4       	ldi	r20, 0x49	; 73
    10b8:	50 e4       	ldi	r21, 0x40	; 64
    10ba:	0e 94 aa 32 	call	0x6554	; 0x6554 <__gesf2>
    10be:	18 16       	cp	r1, r24
    10c0:	0c f4       	brge	.+2      	; 0x10c4 <vFunc_Inf2pi+0x90>
    10c2:	bf cf       	rjmp	.-130    	; 0x1042 <vFunc_Inf2pi+0xe>
}
    10c4:	df 91       	pop	r29
    10c6:	cf 91       	pop	r28
    10c8:	ff 90       	pop	r15
    10ca:	ef 90       	pop	r14
    10cc:	df 90       	pop	r13
    10ce:	cf 90       	pop	r12
    10d0:	08 95       	ret

000010d2 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    10d2:	ef 92       	push	r14
    10d4:	ff 92       	push	r15
    10d6:	0f 93       	push	r16
    10d8:	1f 93       	push	r17
    10da:	cf 93       	push	r28
    10dc:	df 93       	push	r29
    10de:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    10e0:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    10e4:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <pxEnd>
    10e8:	90 91 b0 07 	lds	r25, 0x07B0	; 0x8007b0 <pxEnd+0x1>
    10ec:	89 2b       	or	r24, r25
    10ee:	41 f5       	brne	.+80     	; 0x1140 <pvPortMalloc+0x6e>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    10f0:	e1 eb       	ldi	r30, 0xB1	; 177
    10f2:	f7 e0       	ldi	r31, 0x07	; 7
    10f4:	a5 eb       	ldi	r26, 0xB5	; 181
    10f6:	b7 e0       	ldi	r27, 0x07	; 7
    10f8:	b1 83       	std	Z+1, r27	; 0x01
    10fa:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    10fc:	13 82       	std	Z+3, r1	; 0x03
    10fe:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    1100:	e1 eb       	ldi	r30, 0xB1	; 177
    1102:	f9 e1       	ldi	r31, 0x19	; 25
    1104:	f0 93 b0 07 	sts	0x07B0, r31	; 0x8007b0 <pxEnd+0x1>
    1108:	e0 93 af 07 	sts	0x07AF, r30	; 0x8007af <pxEnd>
	pxEnd->xBlockSize = 0;
    110c:	13 82       	std	Z+3, r1	; 0x03
    110e:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    1110:	11 82       	std	Z+1, r1	; 0x01
    1112:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    1114:	8c ef       	ldi	r24, 0xFC	; 252
    1116:	91 e1       	ldi	r25, 0x11	; 17
    1118:	13 96       	adiw	r26, 0x03	; 3
    111a:	9c 93       	st	X, r25
    111c:	8e 93       	st	-X, r24
    111e:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    1120:	ed 93       	st	X+, r30
    1122:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1124:	90 93 ac 07 	sts	0x07AC, r25	; 0x8007ac <xMinimumEverFreeBytesRemaining+0x1>
    1128:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    112c:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <xFreeBytesRemaining+0x1>
    1130:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    1134:	80 e0       	ldi	r24, 0x00	; 0
    1136:	90 e8       	ldi	r25, 0x80	; 128
    1138:	90 93 aa 07 	sts	0x07AA, r25	; 0x8007aa <xBlockAllocatedBit+0x1>
    113c:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    1140:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <xBlockAllocatedBit>
    1144:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <xBlockAllocatedBit+0x1>
    1148:	8c 23       	and	r24, r28
    114a:	9d 23       	and	r25, r29
    114c:	89 2b       	or	r24, r25
    114e:	09 f0       	breq	.+2      	; 0x1152 <pvPortMalloc+0x80>
    1150:	b2 c0       	rjmp	.+356    	; 0x12b6 <pvPortMalloc+0x1e4>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    1152:	20 97       	sbiw	r28, 0x00	; 0
    1154:	09 f4       	brne	.+2      	; 0x1158 <pvPortMalloc+0x86>
    1156:	b2 c0       	rjmp	.+356    	; 0x12bc <pvPortMalloc+0x1ea>
			{
				xWantedSize += xHeapStructSize;
    1158:	ae 01       	movw	r20, r28
    115a:	4c 5f       	subi	r20, 0xFC	; 252
    115c:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    115e:	09 f4       	brne	.+2      	; 0x1162 <pvPortMalloc+0x90>
    1160:	b0 c0       	rjmp	.+352    	; 0x12c2 <pvPortMalloc+0x1f0>
    1162:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <xFreeBytesRemaining>
    1166:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <xFreeBytesRemaining+0x1>
    116a:	84 17       	cp	r24, r20
    116c:	95 07       	cpc	r25, r21
    116e:	08 f4       	brcc	.+2      	; 0x1172 <pvPortMalloc+0xa0>
    1170:	ab c0       	rjmp	.+342    	; 0x12c8 <pvPortMalloc+0x1f6>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    1172:	e0 91 b1 07 	lds	r30, 0x07B1	; 0x8007b1 <xStart>
    1176:	f0 91 b2 07 	lds	r31, 0x07B2	; 0x8007b2 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    117a:	a1 eb       	ldi	r26, 0xB1	; 177
    117c:	b7 e0       	ldi	r27, 0x07	; 7
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    117e:	02 c0       	rjmp	.+4      	; 0x1184 <pvPortMalloc+0xb2>
    1180:	df 01       	movw	r26, r30
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    1182:	f9 01       	movw	r30, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1184:	22 81       	ldd	r18, Z+2	; 0x02
    1186:	33 81       	ldd	r19, Z+3	; 0x03
    1188:	24 17       	cp	r18, r20
    118a:	35 07       	cpc	r19, r21
    118c:	28 f4       	brcc	.+10     	; 0x1198 <pvPortMalloc+0xc6>
    118e:	20 81       	ld	r18, Z
    1190:	31 81       	ldd	r19, Z+1	; 0x01
    1192:	21 15       	cp	r18, r1
    1194:	31 05       	cpc	r19, r1
    1196:	a1 f7       	brne	.-24     	; 0x1180 <pvPortMalloc+0xae>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    1198:	60 91 af 07 	lds	r22, 0x07AF	; 0x8007af <pxEnd>
    119c:	70 91 b0 07 	lds	r23, 0x07B0	; 0x8007b0 <pxEnd+0x1>
    11a0:	e6 17       	cp	r30, r22
    11a2:	f7 07       	cpc	r31, r23
    11a4:	09 f4       	brne	.+2      	; 0x11a8 <pvPortMalloc+0xd6>
    11a6:	93 c0       	rjmp	.+294    	; 0x12ce <pvPortMalloc+0x1fc>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    11a8:	cd 91       	ld	r28, X+
    11aa:	dc 91       	ld	r29, X
    11ac:	11 97       	sbiw	r26, 0x01	; 1
    11ae:	7e 01       	movw	r14, r28
    11b0:	84 e0       	ldi	r24, 0x04	; 4
    11b2:	e8 0e       	add	r14, r24
    11b4:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    11b6:	80 81       	ld	r24, Z
    11b8:	91 81       	ldd	r25, Z+1	; 0x01
    11ba:	8d 93       	st	X+, r24
    11bc:	9c 93       	st	X, r25

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    11be:	82 81       	ldd	r24, Z+2	; 0x02
    11c0:	93 81       	ldd	r25, Z+3	; 0x03
    11c2:	84 1b       	sub	r24, r20
    11c4:	95 0b       	sbc	r25, r21
    11c6:	89 30       	cpi	r24, 0x09	; 9
    11c8:	91 05       	cpc	r25, r1
    11ca:	08 f4       	brcc	.+2      	; 0x11ce <pvPortMalloc+0xfc>
    11cc:	52 c0       	rjmp	.+164    	; 0x1272 <pvPortMalloc+0x1a0>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    11ce:	9f 01       	movw	r18, r30
    11d0:	24 0f       	add	r18, r20
    11d2:	35 1f       	adc	r19, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    11d4:	d9 01       	movw	r26, r18
    11d6:	13 96       	adiw	r26, 0x03	; 3
    11d8:	9c 93       	st	X, r25
    11da:	8e 93       	st	-X, r24
    11dc:	12 97       	sbiw	r26, 0x02	; 2
						pxBlock->xBlockSize = xWantedSize;
    11de:	53 83       	std	Z+3, r21	; 0x03
    11e0:	42 83       	std	Z+2, r20	; 0x02
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    11e2:	a1 eb       	ldi	r26, 0xB1	; 177
    11e4:	b7 e0       	ldi	r27, 0x07	; 7
    11e6:	01 c0       	rjmp	.+2      	; 0x11ea <pvPortMalloc+0x118>
    11e8:	dc 01       	movw	r26, r24
    11ea:	8d 91       	ld	r24, X+
    11ec:	9c 91       	ld	r25, X
    11ee:	11 97       	sbiw	r26, 0x01	; 1
    11f0:	82 17       	cp	r24, r18
    11f2:	93 07       	cpc	r25, r19
    11f4:	c8 f3       	brcs	.-14     	; 0x11e8 <pvPortMalloc+0x116>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    11f6:	12 96       	adiw	r26, 0x02	; 2
    11f8:	4d 91       	ld	r20, X+
    11fa:	5c 91       	ld	r21, X
    11fc:	13 97       	sbiw	r26, 0x03	; 3
    11fe:	8d 01       	movw	r16, r26
    1200:	04 0f       	add	r16, r20
    1202:	15 1f       	adc	r17, r21
    1204:	20 17       	cp	r18, r16
    1206:	31 07       	cpc	r19, r17
    1208:	51 f4       	brne	.+20     	; 0x121e <pvPortMalloc+0x14c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    120a:	e9 01       	movw	r28, r18
    120c:	2a 81       	ldd	r18, Y+2	; 0x02
    120e:	3b 81       	ldd	r19, Y+3	; 0x03
    1210:	42 0f       	add	r20, r18
    1212:	53 1f       	adc	r21, r19
    1214:	13 96       	adiw	r26, 0x03	; 3
    1216:	5c 93       	st	X, r21
    1218:	4e 93       	st	-X, r20
    121a:	12 97       	sbiw	r26, 0x02	; 2
    121c:	9d 01       	movw	r18, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    121e:	e9 01       	movw	r28, r18
    1220:	4a 81       	ldd	r20, Y+2	; 0x02
    1222:	5b 81       	ldd	r21, Y+3	; 0x03
    1224:	89 01       	movw	r16, r18
    1226:	04 0f       	add	r16, r20
    1228:	15 1f       	adc	r17, r21
    122a:	80 17       	cp	r24, r16
    122c:	91 07       	cpc	r25, r17
    122e:	c9 f4       	brne	.+50     	; 0x1262 <pvPortMalloc+0x190>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    1230:	60 17       	cp	r22, r16
    1232:	71 07       	cpc	r23, r17
    1234:	91 f0       	breq	.+36     	; 0x125a <pvPortMalloc+0x188>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    1236:	e8 01       	movw	r28, r16
    1238:	8a 81       	ldd	r24, Y+2	; 0x02
    123a:	9b 81       	ldd	r25, Y+3	; 0x03
    123c:	48 0f       	add	r20, r24
    123e:	59 1f       	adc	r21, r25
    1240:	e9 01       	movw	r28, r18
    1242:	5b 83       	std	Y+3, r21	; 0x03
    1244:	4a 83       	std	Y+2, r20	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1246:	8d 91       	ld	r24, X+
    1248:	9c 91       	ld	r25, X
    124a:	11 97       	sbiw	r26, 0x01	; 1
    124c:	ec 01       	movw	r28, r24
    124e:	88 81       	ld	r24, Y
    1250:	99 81       	ldd	r25, Y+1	; 0x01
    1252:	e9 01       	movw	r28, r18
    1254:	99 83       	std	Y+1, r25	; 0x01
    1256:	88 83       	st	Y, r24
    1258:	07 c0       	rjmp	.+14     	; 0x1268 <pvPortMalloc+0x196>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    125a:	e9 01       	movw	r28, r18
    125c:	79 83       	std	Y+1, r23	; 0x01
    125e:	68 83       	st	Y, r22
    1260:	03 c0       	rjmp	.+6      	; 0x1268 <pvPortMalloc+0x196>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    1262:	e9 01       	movw	r28, r18
    1264:	99 83       	std	Y+1, r25	; 0x01
    1266:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    1268:	a2 17       	cp	r26, r18
    126a:	b3 07       	cpc	r27, r19
    126c:	11 f0       	breq	.+4      	; 0x1272 <pvPortMalloc+0x1a0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    126e:	2d 93       	st	X+, r18
    1270:	3c 93       	st	X, r19
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    1272:	22 81       	ldd	r18, Z+2	; 0x02
    1274:	33 81       	ldd	r19, Z+3	; 0x03
    1276:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <xFreeBytesRemaining>
    127a:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <xFreeBytesRemaining+0x1>
    127e:	82 1b       	sub	r24, r18
    1280:	93 0b       	sbc	r25, r19
    1282:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <xFreeBytesRemaining+0x1>
    1286:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    128a:	40 91 ab 07 	lds	r20, 0x07AB	; 0x8007ab <xMinimumEverFreeBytesRemaining>
    128e:	50 91 ac 07 	lds	r21, 0x07AC	; 0x8007ac <xMinimumEverFreeBytesRemaining+0x1>
    1292:	84 17       	cp	r24, r20
    1294:	95 07       	cpc	r25, r21
    1296:	20 f4       	brcc	.+8      	; 0x12a0 <pvPortMalloc+0x1ce>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1298:	90 93 ac 07 	sts	0x07AC, r25	; 0x8007ac <xMinimumEverFreeBytesRemaining+0x1>
    129c:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    12a0:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <xBlockAllocatedBit>
    12a4:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <xBlockAllocatedBit+0x1>
    12a8:	28 2b       	or	r18, r24
    12aa:	39 2b       	or	r19, r25
    12ac:	33 83       	std	Z+3, r19	; 0x03
    12ae:	22 83       	std	Z+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    12b0:	11 82       	std	Z+1, r1	; 0x01
    12b2:	10 82       	st	Z, r1
    12b4:	0e c0       	rjmp	.+28     	; 0x12d2 <pvPortMalloc+0x200>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    12b6:	e1 2c       	mov	r14, r1
    12b8:	f1 2c       	mov	r15, r1
    12ba:	0b c0       	rjmp	.+22     	; 0x12d2 <pvPortMalloc+0x200>
    12bc:	e1 2c       	mov	r14, r1
    12be:	f1 2c       	mov	r15, r1
    12c0:	08 c0       	rjmp	.+16     	; 0x12d2 <pvPortMalloc+0x200>
    12c2:	e1 2c       	mov	r14, r1
    12c4:	f1 2c       	mov	r15, r1
    12c6:	05 c0       	rjmp	.+10     	; 0x12d2 <pvPortMalloc+0x200>
    12c8:	e1 2c       	mov	r14, r1
    12ca:	f1 2c       	mov	r15, r1
    12cc:	02 c0       	rjmp	.+4      	; 0x12d2 <pvPortMalloc+0x200>
    12ce:	e1 2c       	mov	r14, r1
    12d0:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    12d2:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    12d6:	c7 01       	movw	r24, r14
    12d8:	df 91       	pop	r29
    12da:	cf 91       	pop	r28
    12dc:	1f 91       	pop	r17
    12de:	0f 91       	pop	r16
    12e0:	ff 90       	pop	r15
    12e2:	ef 90       	pop	r14
    12e4:	08 95       	ret

000012e6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    12e6:	cf 93       	push	r28
    12e8:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    12ea:	00 97       	sbiw	r24, 0x00	; 0
    12ec:	09 f4       	brne	.+2      	; 0x12f0 <vPortFree+0xa>
    12ee:	68 c0       	rjmp	.+208    	; 0x13c0 <vPortFree+0xda>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    12f0:	fc 01       	movw	r30, r24
    12f2:	34 97       	sbiw	r30, 0x04	; 4
    12f4:	22 81       	ldd	r18, Z+2	; 0x02
    12f6:	33 81       	ldd	r19, Z+3	; 0x03
    12f8:	40 91 a9 07 	lds	r20, 0x07A9	; 0x8007a9 <xBlockAllocatedBit>
    12fc:	50 91 aa 07 	lds	r21, 0x07AA	; 0x8007aa <xBlockAllocatedBit+0x1>
    1300:	b9 01       	movw	r22, r18
    1302:	64 23       	and	r22, r20
    1304:	75 23       	and	r23, r21
    1306:	67 2b       	or	r22, r23
    1308:	09 f4       	brne	.+2      	; 0x130c <vPortFree+0x26>
    130a:	5a c0       	rjmp	.+180    	; 0x13c0 <vPortFree+0xda>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    130c:	60 81       	ld	r22, Z
    130e:	71 81       	ldd	r23, Z+1	; 0x01
    1310:	67 2b       	or	r22, r23
    1312:	09 f0       	breq	.+2      	; 0x1316 <vPortFree+0x30>
    1314:	55 c0       	rjmp	.+170    	; 0x13c0 <vPortFree+0xda>

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    1316:	ef 01       	movw	r28, r30
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    1318:	40 95       	com	r20
    131a:	50 95       	com	r21
    131c:	24 23       	and	r18, r20
    131e:	35 23       	and	r19, r21
    1320:	33 83       	std	Z+3, r19	; 0x03
    1322:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    1324:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    1328:	4a 81       	ldd	r20, Y+2	; 0x02
    132a:	5b 81       	ldd	r21, Y+3	; 0x03
    132c:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <xFreeBytesRemaining>
    1330:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <xFreeBytesRemaining+0x1>
    1334:	84 0f       	add	r24, r20
    1336:	95 1f       	adc	r25, r21
    1338:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <xFreeBytesRemaining+0x1>
    133c:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <xFreeBytesRemaining>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    1340:	e1 eb       	ldi	r30, 0xB1	; 177
    1342:	f7 e0       	ldi	r31, 0x07	; 7
    1344:	01 c0       	rjmp	.+2      	; 0x1348 <vPortFree+0x62>
    1346:	fc 01       	movw	r30, r24
    1348:	80 81       	ld	r24, Z
    134a:	91 81       	ldd	r25, Z+1	; 0x01
    134c:	8c 17       	cp	r24, r28
    134e:	9d 07       	cpc	r25, r29
    1350:	d0 f3       	brcs	.-12     	; 0x1346 <vPortFree+0x60>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1352:	22 81       	ldd	r18, Z+2	; 0x02
    1354:	33 81       	ldd	r19, Z+3	; 0x03
    1356:	bf 01       	movw	r22, r30
    1358:	62 0f       	add	r22, r18
    135a:	73 1f       	adc	r23, r19
    135c:	c6 17       	cp	r28, r22
    135e:	d7 07       	cpc	r29, r23
    1360:	29 f4       	brne	.+10     	; 0x136c <vPortFree+0x86>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    1362:	24 0f       	add	r18, r20
    1364:	35 1f       	adc	r19, r21
    1366:	33 83       	std	Z+3, r19	; 0x03
    1368:	22 83       	std	Z+2, r18	; 0x02
    136a:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    136c:	2a 81       	ldd	r18, Y+2	; 0x02
    136e:	3b 81       	ldd	r19, Y+3	; 0x03
    1370:	de 01       	movw	r26, r28
    1372:	a2 0f       	add	r26, r18
    1374:	b3 1f       	adc	r27, r19
    1376:	8a 17       	cp	r24, r26
    1378:	9b 07       	cpc	r25, r27
    137a:	c9 f4       	brne	.+50     	; 0x13ae <vPortFree+0xc8>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    137c:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <pxEnd>
    1380:	90 91 b0 07 	lds	r25, 0x07B0	; 0x8007b0 <pxEnd+0x1>
    1384:	a8 17       	cp	r26, r24
    1386:	b9 07       	cpc	r27, r25
    1388:	79 f0       	breq	.+30     	; 0x13a8 <vPortFree+0xc2>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    138a:	12 96       	adiw	r26, 0x02	; 2
    138c:	8d 91       	ld	r24, X+
    138e:	9c 91       	ld	r25, X
    1390:	13 97       	sbiw	r26, 0x03	; 3
    1392:	28 0f       	add	r18, r24
    1394:	39 1f       	adc	r19, r25
    1396:	3b 83       	std	Y+3, r19	; 0x03
    1398:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    139a:	a0 81       	ld	r26, Z
    139c:	b1 81       	ldd	r27, Z+1	; 0x01
    139e:	8d 91       	ld	r24, X+
    13a0:	9c 91       	ld	r25, X
    13a2:	99 83       	std	Y+1, r25	; 0x01
    13a4:	88 83       	st	Y, r24
    13a6:	05 c0       	rjmp	.+10     	; 0x13b2 <vPortFree+0xcc>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    13a8:	b9 83       	std	Y+1, r27	; 0x01
    13aa:	a8 83       	st	Y, r26
    13ac:	02 c0       	rjmp	.+4      	; 0x13b2 <vPortFree+0xcc>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    13ae:	99 83       	std	Y+1, r25	; 0x01
    13b0:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    13b2:	ec 17       	cp	r30, r28
    13b4:	fd 07       	cpc	r31, r29
    13b6:	11 f0       	breq	.+4      	; 0x13bc <vPortFree+0xd6>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    13b8:	d1 83       	std	Z+1, r29	; 0x01
    13ba:	c0 83       	st	Z, r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
    13bc:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    13c0:	df 91       	pop	r29
    13c2:	cf 91       	pop	r28
    13c4:	08 95       	ret

000013c6 <sIMU_readRegisterRegion>:
}
float fIMU_readFloatGyroY( void ){
    
    float output = fIMU_calcGyro(i16IMU_readRawGyroY());
    return output;
}
    13c6:	ef 92       	push	r14
    13c8:	ff 92       	push	r15
    13ca:	0f 93       	push	r16
    13cc:	1f 93       	push	r17
    13ce:	cf 93       	push	r28
    13d0:	df 93       	push	r29
    13d2:	ec 01       	movw	r28, r24
    13d4:	e4 2e       	mov	r14, r20
    13d6:	28 98       	cbi	0x05, 0	; 5
    13d8:	86 2f       	mov	r24, r22
    13da:	80 68       	ori	r24, 0x80	; 128
    13dc:	0e 94 9a 22 	call	0x4534	; 0x4534 <ui8SPI_MasterTransmit>
    13e0:	ee 20       	and	r14, r14
    13e2:	b1 f0       	breq	.+44     	; 0x1410 <sIMU_readRegisterRegion+0x4a>
    13e4:	0f ef       	ldi	r16, 0xFF	; 255
    13e6:	0e 0d       	add	r16, r14
    13e8:	10 e0       	ldi	r17, 0x00	; 0
    13ea:	0f 5f       	subi	r16, 0xFF	; 255
    13ec:	1f 4f       	sbci	r17, 0xFF	; 255
    13ee:	0c 0f       	add	r16, r28
    13f0:	1d 1f       	adc	r17, r29
    13f2:	f1 2c       	mov	r15, r1
    13f4:	80 e0       	ldi	r24, 0x00	; 0
    13f6:	0e 94 9a 22 	call	0x4534	; 0x4534 <ui8SPI_MasterTransmit>
    13fa:	8f 3f       	cpi	r24, 0xFF	; 255
    13fc:	09 f4       	brne	.+2      	; 0x1400 <sIMU_readRegisterRegion+0x3a>
    13fe:	f3 94       	inc	r15
    1400:	89 93       	st	Y+, r24
    1402:	0c 17       	cp	r16, r28
    1404:	1d 07       	cpc	r17, r29
    1406:	b1 f7       	brne	.-20     	; 0x13f4 <sIMU_readRegisterRegion+0x2e>
    1408:	fe 10       	cpse	r15, r14
    140a:	04 c0       	rjmp	.+8      	; 0x1414 <sIMU_readRegisterRegion+0x4e>
    140c:	85 e0       	ldi	r24, 0x05	; 5
    140e:	03 c0       	rjmp	.+6      	; 0x1416 <sIMU_readRegisterRegion+0x50>
    1410:	85 e0       	ldi	r24, 0x05	; 5
    1412:	01 c0       	rjmp	.+2      	; 0x1416 <sIMU_readRegisterRegion+0x50>
    1414:	80 e0       	ldi	r24, 0x00	; 0
    1416:	28 9a       	sbi	0x05, 0	; 5
    1418:	df 91       	pop	r29
    141a:	cf 91       	pop	r28
    141c:	1f 91       	pop	r17
    141e:	0f 91       	pop	r16
    1420:	ff 90       	pop	r15
    1422:	ef 90       	pop	r14
    1424:	08 95       	ret

00001426 <sIMU_readRegister>:
    1426:	cf 93       	push	r28
    1428:	df 93       	push	r29
    142a:	ec 01       	movw	r28, r24
    142c:	28 98       	cbi	0x05, 0	; 5
    142e:	86 2f       	mov	r24, r22
    1430:	80 68       	ori	r24, 0x80	; 128
    1432:	0e 94 9a 22 	call	0x4534	; 0x4534 <ui8SPI_MasterTransmit>
    1436:	80 e0       	ldi	r24, 0x00	; 0
    1438:	0e 94 9a 22 	call	0x4534	; 0x4534 <ui8SPI_MasterTransmit>
    143c:	28 9a       	sbi	0x05, 0	; 5
    143e:	8f 3f       	cpi	r24, 0xFF	; 255
    1440:	11 f4       	brne	.+4      	; 0x1446 <sIMU_readRegister+0x20>
    1442:	95 e0       	ldi	r25, 0x05	; 5
    1444:	01 c0       	rjmp	.+2      	; 0x1448 <sIMU_readRegister+0x22>
    1446:	90 e0       	ldi	r25, 0x00	; 0
    1448:	88 83       	st	Y, r24
    144a:	89 2f       	mov	r24, r25
    144c:	df 91       	pop	r29
    144e:	cf 91       	pop	r28
    1450:	08 95       	ret

00001452 <sIMU_Init>:
    1452:	cf 93       	push	r28
    1454:	df 93       	push	r29
    1456:	1f 92       	push	r1
    1458:	1f 92       	push	r1
    145a:	cd b7       	in	r28, 0x3d	; 61
    145c:	de b7       	in	r29, 0x3e	; 62
    145e:	ed e0       	ldi	r30, 0x0D	; 13
    1460:	fb e1       	ldi	r31, 0x1B	; 27
    1462:	81 e0       	ldi	r24, 0x01	; 1
    1464:	80 83       	st	Z, r24
    1466:	24 ef       	ldi	r18, 0xF4	; 244
    1468:	31 e0       	ldi	r19, 0x01	; 1
    146a:	32 83       	std	Z+2, r19	; 0x02
    146c:	21 83       	std	Z+1, r18	; 0x01
    146e:	22 e8       	ldi	r18, 0x82	; 130
    1470:	36 e0       	ldi	r19, 0x06	; 6
    1472:	34 83       	std	Z+4, r19	; 0x04
    1474:	23 83       	std	Z+3, r18	; 0x03
    1476:	20 e9       	ldi	r18, 0x90	; 144
    1478:	31 e0       	ldi	r19, 0x01	; 1
    147a:	36 83       	std	Z+6, r19	; 0x06
    147c:	25 83       	std	Z+5, r18	; 0x05
    147e:	17 82       	std	Z+7, r1	; 0x07
    1480:	10 86       	std	Z+8, r1	; 0x08
    1482:	81 87       	std	Z+9, r24	; 0x09
    1484:	82 87       	std	Z+10, r24	; 0x0a
    1486:	20 e1       	ldi	r18, 0x10	; 16
    1488:	30 e0       	ldi	r19, 0x00	; 0
    148a:	34 87       	std	Z+12, r19	; 0x0c
    148c:	23 87       	std	Z+11, r18	; 0x0b
    148e:	2d e0       	ldi	r18, 0x0D	; 13
    1490:	30 e0       	ldi	r19, 0x00	; 0
    1492:	36 87       	std	Z+14, r19	; 0x0e
    1494:	25 87       	std	Z+13, r18	; 0x0d
    1496:	22 e3       	ldi	r18, 0x32	; 50
    1498:	30 e0       	ldi	r19, 0x00	; 0
    149a:	30 8b       	std	Z+16, r19	; 0x10
    149c:	27 87       	std	Z+15, r18	; 0x0f
    149e:	11 8a       	std	Z+17, r1	; 0x11
    14a0:	12 8a       	std	Z+18, r1	; 0x12
    14a2:	83 8b       	std	Z+19, r24	; 0x13
    14a4:	84 8b       	std	Z+20, r24	; 0x14
    14a6:	88 eb       	ldi	r24, 0xB8	; 184
    14a8:	9b e0       	ldi	r25, 0x0B	; 11
    14aa:	96 8b       	std	Z+22, r25	; 0x16
    14ac:	85 8b       	std	Z+21, r24	; 0x15
    14ae:	8a e0       	ldi	r24, 0x0A	; 10
    14b0:	90 e0       	ldi	r25, 0x00	; 0
    14b2:	90 8f       	std	Z+24, r25	; 0x18
    14b4:	87 8b       	std	Z+23, r24	; 0x17
    14b6:	11 8e       	std	Z+25, r1	; 0x19
    14b8:	10 92 28 1b 	sts	0x1B28, r1	; 0x801b28 <allOnesCounter+0x1>
    14bc:	10 92 27 1b 	sts	0x1B27, r1	; 0x801b27 <allOnesCounter>
    14c0:	10 92 2a 1b 	sts	0x1B2A, r1	; 0x801b2a <nonSuccessCounter+0x1>
    14c4:	10 92 29 1b 	sts	0x1B29, r1	; 0x801b29 <nonSuccessCounter>
    14c8:	0e 94 8c 22 	call	0x4518	; 0x4518 <vSPI_MasterInit>
    14cc:	20 9a       	sbi	0x04, 0	; 4
    14ce:	28 9a       	sbi	0x05, 0	; 5
    14d0:	19 82       	std	Y+1, r1	; 0x01
    14d2:	20 e1       	ldi	r18, 0x10	; 16
    14d4:	37 e2       	ldi	r19, 0x27	; 39
    14d6:	89 81       	ldd	r24, Y+1	; 0x01
    14d8:	8f 5f       	subi	r24, 0xFF	; 255
    14da:	89 83       	std	Y+1, r24	; 0x01
    14dc:	21 50       	subi	r18, 0x01	; 1
    14de:	31 09       	sbc	r19, r1
    14e0:	d1 f7       	brne	.-12     	; 0x14d6 <sIMU_Init+0x84>
    14e2:	6f e0       	ldi	r22, 0x0F	; 15
    14e4:	ce 01       	movw	r24, r28
    14e6:	02 96       	adiw	r24, 0x02	; 2
    14e8:	9e df       	rcall	.-196    	; 0x1426 <sIMU_readRegister>
    14ea:	8a 81       	ldd	r24, Y+2	; 0x02
    14ec:	89 36       	cpi	r24, 0x69	; 105
    14ee:	c9 f7       	brne	.-14     	; 0x14e2 <sIMU_Init+0x90>
    14f0:	80 e0       	ldi	r24, 0x00	; 0
    14f2:	0f 90       	pop	r0
    14f4:	0f 90       	pop	r0
    14f6:	df 91       	pop	r29
    14f8:	cf 91       	pop	r28
    14fa:	08 95       	ret

000014fc <sIMU_readRegisterInt16>:
    14fc:	0f 93       	push	r16
    14fe:	1f 93       	push	r17
    1500:	cf 93       	push	r28
    1502:	df 93       	push	r29
    1504:	1f 92       	push	r1
    1506:	1f 92       	push	r1
    1508:	cd b7       	in	r28, 0x3d	; 61
    150a:	de b7       	in	r29, 0x3e	; 62
    150c:	8c 01       	movw	r16, r24
    150e:	42 e0       	ldi	r20, 0x02	; 2
    1510:	ce 01       	movw	r24, r28
    1512:	01 96       	adiw	r24, 0x01	; 1
    1514:	58 df       	rcall	.-336    	; 0x13c6 <sIMU_readRegisterRegion>
    1516:	2a 81       	ldd	r18, Y+2	; 0x02
    1518:	30 e0       	ldi	r19, 0x00	; 0
    151a:	32 2f       	mov	r19, r18
    151c:	22 27       	eor	r18, r18
    151e:	99 81       	ldd	r25, Y+1	; 0x01
    1520:	29 2b       	or	r18, r25
    1522:	f8 01       	movw	r30, r16
    1524:	31 83       	std	Z+1, r19	; 0x01
    1526:	20 83       	st	Z, r18
    1528:	0f 90       	pop	r0
    152a:	0f 90       	pop	r0
    152c:	df 91       	pop	r29
    152e:	cf 91       	pop	r28
    1530:	1f 91       	pop	r17
    1532:	0f 91       	pop	r16
    1534:	08 95       	ret

00001536 <sIMU_writeRegister>:
    1536:	cf 93       	push	r28
    1538:	c6 2f       	mov	r28, r22
    153a:	28 98       	cbi	0x05, 0	; 5
    153c:	0e 94 9a 22 	call	0x4534	; 0x4534 <ui8SPI_MasterTransmit>
    1540:	8c 2f       	mov	r24, r28
    1542:	0e 94 9a 22 	call	0x4534	; 0x4534 <ui8SPI_MasterTransmit>
    1546:	28 9a       	sbi	0x05, 0	; 5
    1548:	80 e0       	ldi	r24, 0x00	; 0
    154a:	cf 91       	pop	r28
    154c:	08 95       	ret

0000154e <sIMU_begin>:
    154e:	1f 93       	push	r17
    1550:	cf 93       	push	r28
    1552:	df 93       	push	r29
    1554:	1f 92       	push	r1
    1556:	1f 92       	push	r1
    1558:	cd b7       	in	r28, 0x3d	; 61
    155a:	de b7       	in	r29, 0x3e	; 62
    155c:	19 82       	std	Y+1, r1	; 0x01
    155e:	79 df       	rcall	.-270    	; 0x1452 <sIMU_Init>
    1560:	18 2f       	mov	r17, r24
    1562:	19 82       	std	Y+1, r1	; 0x01
    1564:	80 91 16 1b 	lds	r24, 0x1B16	; 0x801b16 <settings+0x9>
    1568:	81 30       	cpi	r24, 0x01	; 1
    156a:	09 f0       	breq	.+2      	; 0x156e <sIMU_begin+0x20>
    156c:	83 c0       	rjmp	.+262    	; 0x1674 <sIMU_begin+0x126>
    156e:	80 91 1c 1b 	lds	r24, 0x1B1C	; 0x801b1c <settings+0xf>
    1572:	90 91 1d 1b 	lds	r25, 0x1B1D	; 0x801b1d <settings+0x10>
    1576:	84 36       	cpi	r24, 0x64	; 100
    1578:	91 05       	cpc	r25, r1
    157a:	41 f0       	breq	.+16     	; 0x158c <sIMU_begin+0x3e>
    157c:	88 3c       	cpi	r24, 0xC8	; 200
    157e:	91 05       	cpc	r25, r1
    1580:	41 f0       	breq	.+16     	; 0x1592 <sIMU_begin+0x44>
    1582:	c2 97       	sbiw	r24, 0x32	; 50
    1584:	41 f4       	brne	.+16     	; 0x1596 <sIMU_begin+0x48>
    1586:	83 e0       	ldi	r24, 0x03	; 3
    1588:	89 83       	std	Y+1, r24	; 0x01
    158a:	05 c0       	rjmp	.+10     	; 0x1596 <sIMU_begin+0x48>
    158c:	82 e0       	ldi	r24, 0x02	; 2
    158e:	89 83       	std	Y+1, r24	; 0x01
    1590:	02 c0       	rjmp	.+4      	; 0x1596 <sIMU_begin+0x48>
    1592:	81 e0       	ldi	r24, 0x01	; 1
    1594:	89 83       	std	Y+1, r24	; 0x01
    1596:	80 91 18 1b 	lds	r24, 0x1B18	; 0x801b18 <settings+0xb>
    159a:	90 91 19 1b 	lds	r25, 0x1B19	; 0x801b19 <settings+0xc>
    159e:	84 30       	cpi	r24, 0x04	; 4
    15a0:	91 05       	cpc	r25, r1
    15a2:	31 f0       	breq	.+12     	; 0x15b0 <sIMU_begin+0x62>
    15a4:	88 30       	cpi	r24, 0x08	; 8
    15a6:	91 05       	cpc	r25, r1
    15a8:	39 f0       	breq	.+14     	; 0x15b8 <sIMU_begin+0x6a>
    15aa:	02 97       	sbiw	r24, 0x02	; 2
    15ac:	49 f4       	brne	.+18     	; 0x15c0 <sIMU_begin+0x72>
    15ae:	0b c0       	rjmp	.+22     	; 0x15c6 <sIMU_begin+0x78>
    15b0:	89 81       	ldd	r24, Y+1	; 0x01
    15b2:	88 60       	ori	r24, 0x08	; 8
    15b4:	89 83       	std	Y+1, r24	; 0x01
    15b6:	07 c0       	rjmp	.+14     	; 0x15c6 <sIMU_begin+0x78>
    15b8:	89 81       	ldd	r24, Y+1	; 0x01
    15ba:	8c 60       	ori	r24, 0x0C	; 12
    15bc:	89 83       	std	Y+1, r24	; 0x01
    15be:	03 c0       	rjmp	.+6      	; 0x15c6 <sIMU_begin+0x78>
    15c0:	89 81       	ldd	r24, Y+1	; 0x01
    15c2:	84 60       	ori	r24, 0x04	; 4
    15c4:	89 83       	std	Y+1, r24	; 0x01
    15c6:	80 91 1a 1b 	lds	r24, 0x1B1A	; 0x801b1a <settings+0xd>
    15ca:	90 91 1b 1b 	lds	r25, 0x1B1B	; 0x801b1b <settings+0xe>
    15ce:	80 3a       	cpi	r24, 0xA0	; 160
    15d0:	21 e0       	ldi	r18, 0x01	; 1
    15d2:	92 07       	cpc	r25, r18
    15d4:	c1 f1       	breq	.+112    	; 0x1646 <sIMU_begin+0xf8>
    15d6:	70 f4       	brcc	.+28     	; 0x15f4 <sIMU_begin+0xa6>
    15d8:	8a 31       	cpi	r24, 0x1A	; 26
    15da:	91 05       	cpc	r25, r1
    15dc:	21 f1       	breq	.+72     	; 0x1626 <sIMU_begin+0xd8>
    15de:	18 f4       	brcc	.+6      	; 0x15e6 <sIMU_begin+0x98>
    15e0:	0d 97       	sbiw	r24, 0x0d	; 13
    15e2:	e9 f0       	breq	.+58     	; 0x161e <sIMU_begin+0xd0>
    15e4:	28 c0       	rjmp	.+80     	; 0x1636 <sIMU_begin+0xe8>
    15e6:	84 33       	cpi	r24, 0x34	; 52
    15e8:	91 05       	cpc	r25, r1
    15ea:	09 f1       	breq	.+66     	; 0x162e <sIMU_begin+0xe0>
    15ec:	80 3d       	cpi	r24, 0xD0	; 208
    15ee:	91 05       	cpc	r25, r1
    15f0:	31 f1       	breq	.+76     	; 0x163e <sIMU_begin+0xf0>
    15f2:	21 c0       	rjmp	.+66     	; 0x1636 <sIMU_begin+0xe8>
    15f4:	82 30       	cpi	r24, 0x02	; 2
    15f6:	2d e0       	ldi	r18, 0x0D	; 13
    15f8:	92 07       	cpc	r25, r18
    15fa:	89 f1       	breq	.+98     	; 0x165e <sIMU_begin+0x110>
    15fc:	40 f4       	brcc	.+16     	; 0x160e <sIMU_begin+0xc0>
    15fe:	81 34       	cpi	r24, 0x41	; 65
    1600:	23 e0       	ldi	r18, 0x03	; 3
    1602:	92 07       	cpc	r25, r18
    1604:	21 f1       	breq	.+72     	; 0x164e <sIMU_begin+0x100>
    1606:	8c 37       	cpi	r24, 0x7C	; 124
    1608:	96 40       	sbci	r25, 0x06	; 6
    160a:	29 f1       	breq	.+74     	; 0x1656 <sIMU_begin+0x108>
    160c:	14 c0       	rjmp	.+40     	; 0x1636 <sIMU_begin+0xe8>
    160e:	84 30       	cpi	r24, 0x04	; 4
    1610:	2a e1       	ldi	r18, 0x1A	; 26
    1612:	92 07       	cpc	r25, r18
    1614:	41 f1       	breq	.+80     	; 0x1666 <sIMU_begin+0x118>
    1616:	82 31       	cpi	r24, 0x12	; 18
    1618:	94 43       	sbci	r25, 0x34	; 52
    161a:	49 f1       	breq	.+82     	; 0x166e <sIMU_begin+0x120>
    161c:	0c c0       	rjmp	.+24     	; 0x1636 <sIMU_begin+0xe8>
    161e:	89 81       	ldd	r24, Y+1	; 0x01
    1620:	80 61       	ori	r24, 0x10	; 16
    1622:	89 83       	std	Y+1, r24	; 0x01
    1624:	27 c0       	rjmp	.+78     	; 0x1674 <sIMU_begin+0x126>
    1626:	89 81       	ldd	r24, Y+1	; 0x01
    1628:	80 62       	ori	r24, 0x20	; 32
    162a:	89 83       	std	Y+1, r24	; 0x01
    162c:	23 c0       	rjmp	.+70     	; 0x1674 <sIMU_begin+0x126>
    162e:	89 81       	ldd	r24, Y+1	; 0x01
    1630:	80 63       	ori	r24, 0x30	; 48
    1632:	89 83       	std	Y+1, r24	; 0x01
    1634:	1f c0       	rjmp	.+62     	; 0x1674 <sIMU_begin+0x126>
    1636:	89 81       	ldd	r24, Y+1	; 0x01
    1638:	80 64       	ori	r24, 0x40	; 64
    163a:	89 83       	std	Y+1, r24	; 0x01
    163c:	1b c0       	rjmp	.+54     	; 0x1674 <sIMU_begin+0x126>
    163e:	89 81       	ldd	r24, Y+1	; 0x01
    1640:	80 65       	ori	r24, 0x50	; 80
    1642:	89 83       	std	Y+1, r24	; 0x01
    1644:	17 c0       	rjmp	.+46     	; 0x1674 <sIMU_begin+0x126>
    1646:	89 81       	ldd	r24, Y+1	; 0x01
    1648:	80 66       	ori	r24, 0x60	; 96
    164a:	89 83       	std	Y+1, r24	; 0x01
    164c:	13 c0       	rjmp	.+38     	; 0x1674 <sIMU_begin+0x126>
    164e:	89 81       	ldd	r24, Y+1	; 0x01
    1650:	80 67       	ori	r24, 0x70	; 112
    1652:	89 83       	std	Y+1, r24	; 0x01
    1654:	0f c0       	rjmp	.+30     	; 0x1674 <sIMU_begin+0x126>
    1656:	89 81       	ldd	r24, Y+1	; 0x01
    1658:	80 68       	ori	r24, 0x80	; 128
    165a:	89 83       	std	Y+1, r24	; 0x01
    165c:	0b c0       	rjmp	.+22     	; 0x1674 <sIMU_begin+0x126>
    165e:	89 81       	ldd	r24, Y+1	; 0x01
    1660:	80 69       	ori	r24, 0x90	; 144
    1662:	89 83       	std	Y+1, r24	; 0x01
    1664:	07 c0       	rjmp	.+14     	; 0x1674 <sIMU_begin+0x126>
    1666:	89 81       	ldd	r24, Y+1	; 0x01
    1668:	80 6a       	ori	r24, 0xA0	; 160
    166a:	89 83       	std	Y+1, r24	; 0x01
    166c:	03 c0       	rjmp	.+6      	; 0x1674 <sIMU_begin+0x126>
    166e:	89 81       	ldd	r24, Y+1	; 0x01
    1670:	80 6b       	ori	r24, 0xB0	; 176
    1672:	89 83       	std	Y+1, r24	; 0x01
    1674:	69 81       	ldd	r22, Y+1	; 0x01
    1676:	80 e1       	ldi	r24, 0x10	; 16
    1678:	5e df       	rcall	.-324    	; 0x1536 <sIMU_writeRegister>
    167a:	63 e1       	ldi	r22, 0x13	; 19
    167c:	ce 01       	movw	r24, r28
    167e:	01 96       	adiw	r24, 0x01	; 1
    1680:	d2 de       	rcall	.-604    	; 0x1426 <sIMU_readRegister>
    1682:	89 81       	ldd	r24, Y+1	; 0x01
    1684:	8f 77       	andi	r24, 0x7F	; 127
    1686:	89 83       	std	Y+1, r24	; 0x01
    1688:	90 91 17 1b 	lds	r25, 0x1B17	; 0x801b17 <settings+0xa>
    168c:	91 30       	cpi	r25, 0x01	; 1
    168e:	11 f4       	brne	.+4      	; 0x1694 <sIMU_begin+0x146>
    1690:	80 68       	ori	r24, 0x80	; 128
    1692:	89 83       	std	Y+1, r24	; 0x01
    1694:	69 81       	ldd	r22, Y+1	; 0x01
    1696:	83 e1       	ldi	r24, 0x13	; 19
    1698:	4e df       	rcall	.-356    	; 0x1536 <sIMU_writeRegister>
    169a:	19 82       	std	Y+1, r1	; 0x01
    169c:	80 91 0d 1b 	lds	r24, 0x1B0D	; 0x801b0d <settings>
    16a0:	81 30       	cpi	r24, 0x01	; 1
    16a2:	09 f0       	breq	.+2      	; 0x16a6 <sIMU_begin+0x158>
    16a4:	5b c0       	rjmp	.+182    	; 0x175c <sIMU_begin+0x20e>
    16a6:	80 91 0e 1b 	lds	r24, 0x1B0E	; 0x801b0e <settings+0x1>
    16aa:	90 91 0f 1b 	lds	r25, 0x1B0F	; 0x801b0f <settings+0x2>
    16ae:	85 3f       	cpi	r24, 0xF5	; 245
    16b0:	91 05       	cpc	r25, r1
    16b2:	c1 f0       	breq	.+48     	; 0x16e4 <sIMU_begin+0x196>
    16b4:	20 f4       	brcc	.+8      	; 0x16be <sIMU_begin+0x170>
    16b6:	8d 37       	cpi	r24, 0x7D	; 125
    16b8:	91 05       	cpc	r25, r1
    16ba:	49 f0       	breq	.+18     	; 0x16ce <sIMU_begin+0x180>
    16bc:	11 c0       	rjmp	.+34     	; 0x16e0 <sIMU_begin+0x192>
    16be:	84 3f       	cpi	r24, 0xF4	; 244
    16c0:	21 e0       	ldi	r18, 0x01	; 1
    16c2:	92 07       	cpc	r25, r18
    16c4:	39 f0       	breq	.+14     	; 0x16d4 <sIMU_begin+0x186>
    16c6:	88 3e       	cpi	r24, 0xE8	; 232
    16c8:	93 40       	sbci	r25, 0x03	; 3
    16ca:	39 f0       	breq	.+14     	; 0x16da <sIMU_begin+0x18c>
    16cc:	09 c0       	rjmp	.+18     	; 0x16e0 <sIMU_begin+0x192>
    16ce:	82 e0       	ldi	r24, 0x02	; 2
    16d0:	89 83       	std	Y+1, r24	; 0x01
    16d2:	08 c0       	rjmp	.+16     	; 0x16e4 <sIMU_begin+0x196>
    16d4:	84 e0       	ldi	r24, 0x04	; 4
    16d6:	89 83       	std	Y+1, r24	; 0x01
    16d8:	05 c0       	rjmp	.+10     	; 0x16e4 <sIMU_begin+0x196>
    16da:	88 e0       	ldi	r24, 0x08	; 8
    16dc:	89 83       	std	Y+1, r24	; 0x01
    16de:	02 c0       	rjmp	.+4      	; 0x16e4 <sIMU_begin+0x196>
    16e0:	8c e0       	ldi	r24, 0x0C	; 12
    16e2:	89 83       	std	Y+1, r24	; 0x01
    16e4:	80 91 10 1b 	lds	r24, 0x1B10	; 0x801b10 <settings+0x3>
    16e8:	90 91 11 1b 	lds	r25, 0x1B11	; 0x801b11 <settings+0x4>
    16ec:	80 3d       	cpi	r24, 0xD0	; 208
    16ee:	91 05       	cpc	r25, r1
    16f0:	31 f1       	breq	.+76     	; 0x173e <sIMU_begin+0x1f0>
    16f2:	48 f4       	brcc	.+18     	; 0x1706 <sIMU_begin+0x1b8>
    16f4:	8a 31       	cpi	r24, 0x1A	; 26
    16f6:	91 05       	cpc	r25, r1
    16f8:	b1 f0       	breq	.+44     	; 0x1726 <sIMU_begin+0x1d8>
    16fa:	84 33       	cpi	r24, 0x34	; 52
    16fc:	91 05       	cpc	r25, r1
    16fe:	b9 f0       	breq	.+46     	; 0x172e <sIMU_begin+0x1e0>
    1700:	0d 97       	sbiw	r24, 0x0d	; 13
    1702:	c9 f4       	brne	.+50     	; 0x1736 <sIMU_begin+0x1e8>
    1704:	0c c0       	rjmp	.+24     	; 0x171e <sIMU_begin+0x1d0>
    1706:	81 34       	cpi	r24, 0x41	; 65
    1708:	23 e0       	ldi	r18, 0x03	; 3
    170a:	92 07       	cpc	r25, r18
    170c:	01 f1       	breq	.+64     	; 0x174e <sIMU_begin+0x200>
    170e:	8c 37       	cpi	r24, 0x7C	; 124
    1710:	26 e0       	ldi	r18, 0x06	; 6
    1712:	92 07       	cpc	r25, r18
    1714:	01 f1       	breq	.+64     	; 0x1756 <sIMU_begin+0x208>
    1716:	80 3a       	cpi	r24, 0xA0	; 160
    1718:	91 40       	sbci	r25, 0x01	; 1
    171a:	69 f4       	brne	.+26     	; 0x1736 <sIMU_begin+0x1e8>
    171c:	14 c0       	rjmp	.+40     	; 0x1746 <sIMU_begin+0x1f8>
    171e:	89 81       	ldd	r24, Y+1	; 0x01
    1720:	80 61       	ori	r24, 0x10	; 16
    1722:	89 83       	std	Y+1, r24	; 0x01
    1724:	1b c0       	rjmp	.+54     	; 0x175c <sIMU_begin+0x20e>
    1726:	89 81       	ldd	r24, Y+1	; 0x01
    1728:	80 62       	ori	r24, 0x20	; 32
    172a:	89 83       	std	Y+1, r24	; 0x01
    172c:	17 c0       	rjmp	.+46     	; 0x175c <sIMU_begin+0x20e>
    172e:	89 81       	ldd	r24, Y+1	; 0x01
    1730:	80 63       	ori	r24, 0x30	; 48
    1732:	89 83       	std	Y+1, r24	; 0x01
    1734:	13 c0       	rjmp	.+38     	; 0x175c <sIMU_begin+0x20e>
    1736:	89 81       	ldd	r24, Y+1	; 0x01
    1738:	80 64       	ori	r24, 0x40	; 64
    173a:	89 83       	std	Y+1, r24	; 0x01
    173c:	0f c0       	rjmp	.+30     	; 0x175c <sIMU_begin+0x20e>
    173e:	89 81       	ldd	r24, Y+1	; 0x01
    1740:	80 65       	ori	r24, 0x50	; 80
    1742:	89 83       	std	Y+1, r24	; 0x01
    1744:	0b c0       	rjmp	.+22     	; 0x175c <sIMU_begin+0x20e>
    1746:	89 81       	ldd	r24, Y+1	; 0x01
    1748:	80 66       	ori	r24, 0x60	; 96
    174a:	89 83       	std	Y+1, r24	; 0x01
    174c:	07 c0       	rjmp	.+14     	; 0x175c <sIMU_begin+0x20e>
    174e:	89 81       	ldd	r24, Y+1	; 0x01
    1750:	80 67       	ori	r24, 0x70	; 112
    1752:	89 83       	std	Y+1, r24	; 0x01
    1754:	03 c0       	rjmp	.+6      	; 0x175c <sIMU_begin+0x20e>
    1756:	89 81       	ldd	r24, Y+1	; 0x01
    1758:	80 68       	ori	r24, 0x80	; 128
    175a:	89 83       	std	Y+1, r24	; 0x01
    175c:	69 81       	ldd	r22, Y+1	; 0x01
    175e:	81 e1       	ldi	r24, 0x11	; 17
    1760:	ea de       	rcall	.-556    	; 0x1536 <sIMU_writeRegister>
    1762:	6f e0       	ldi	r22, 0x0F	; 15
    1764:	ce 01       	movw	r24, r28
    1766:	02 96       	adiw	r24, 0x02	; 2
    1768:	5e de       	rcall	.-836    	; 0x1426 <sIMU_readRegister>
    176a:	81 2f       	mov	r24, r17
    176c:	0f 90       	pop	r0
    176e:	0f 90       	pop	r0
    1770:	df 91       	pop	r29
    1772:	cf 91       	pop	r28
    1774:	1f 91       	pop	r17
    1776:	08 95       	ret

00001778 <i16IMU_readRawGyroZ>:
    1778:	cf 93       	push	r28
    177a:	df 93       	push	r29
    177c:	1f 92       	push	r1
    177e:	1f 92       	push	r1
    1780:	cd b7       	in	r28, 0x3d	; 61
    1782:	de b7       	in	r29, 0x3e	; 62
    1784:	66 e2       	ldi	r22, 0x26	; 38
    1786:	ce 01       	movw	r24, r28
    1788:	01 96       	adiw	r24, 0x01	; 1
    178a:	b8 de       	rcall	.-656    	; 0x14fc <sIMU_readRegisterInt16>
    178c:	88 23       	and	r24, r24
    178e:	a9 f0       	breq	.+42     	; 0x17ba <i16IMU_readRawGyroZ+0x42>
    1790:	85 30       	cpi	r24, 0x05	; 5
    1792:	51 f4       	brne	.+20     	; 0x17a8 <i16IMU_readRawGyroZ+0x30>
    1794:	80 91 27 1b 	lds	r24, 0x1B27	; 0x801b27 <allOnesCounter>
    1798:	90 91 28 1b 	lds	r25, 0x1B28	; 0x801b28 <allOnesCounter+0x1>
    179c:	01 96       	adiw	r24, 0x01	; 1
    179e:	90 93 28 1b 	sts	0x1B28, r25	; 0x801b28 <allOnesCounter+0x1>
    17a2:	80 93 27 1b 	sts	0x1B27, r24	; 0x801b27 <allOnesCounter>
    17a6:	09 c0       	rjmp	.+18     	; 0x17ba <i16IMU_readRawGyroZ+0x42>
    17a8:	80 91 29 1b 	lds	r24, 0x1B29	; 0x801b29 <nonSuccessCounter>
    17ac:	90 91 2a 1b 	lds	r25, 0x1B2A	; 0x801b2a <nonSuccessCounter+0x1>
    17b0:	01 96       	adiw	r24, 0x01	; 1
    17b2:	90 93 2a 1b 	sts	0x1B2A, r25	; 0x801b2a <nonSuccessCounter+0x1>
    17b6:	80 93 29 1b 	sts	0x1B29, r24	; 0x801b29 <nonSuccessCounter>
    17ba:	89 81       	ldd	r24, Y+1	; 0x01
    17bc:	9a 81       	ldd	r25, Y+2	; 0x02
    17be:	0f 90       	pop	r0
    17c0:	0f 90       	pop	r0
    17c2:	df 91       	pop	r29
    17c4:	cf 91       	pop	r28
    17c6:	08 95       	ret

000017c8 <fIMU_calcGyro>:
    17c8:	cf 92       	push	r12
    17ca:	df 92       	push	r13
    17cc:	ef 92       	push	r14
    17ce:	ff 92       	push	r15
    17d0:	cf 93       	push	r28
    17d2:	fc 01       	movw	r30, r24
    17d4:	40 91 0e 1b 	lds	r20, 0x1B0E	; 0x801b0e <settings+0x1>
    17d8:	50 91 0f 1b 	lds	r21, 0x1B0F	; 0x801b0f <settings+0x2>
    17dc:	45 3f       	cpi	r20, 0xF5	; 245
    17de:	51 05       	cpc	r21, r1
    17e0:	b1 f0       	breq	.+44     	; 0x180e <fIMU_calcGyro+0x46>
    17e2:	9a 01       	movw	r18, r20
    17e4:	a5 e2       	ldi	r26, 0x25	; 37
    17e6:	b6 e0       	ldi	r27, 0x06	; 6
    17e8:	0e 94 25 37 	call	0x6e4a	; 0x6e4a <__umulhisi3>
    17ec:	48 1b       	sub	r20, r24
    17ee:	59 0b       	sbc	r21, r25
    17f0:	56 95       	lsr	r21
    17f2:	47 95       	ror	r20
    17f4:	84 0f       	add	r24, r20
    17f6:	95 1f       	adc	r25, r21
    17f8:	00 24       	eor	r0, r0
    17fa:	88 0f       	add	r24, r24
    17fc:	99 1f       	adc	r25, r25
    17fe:	00 1c       	adc	r0, r0
    1800:	88 0f       	add	r24, r24
    1802:	99 1f       	adc	r25, r25
    1804:	00 1c       	adc	r0, r0
    1806:	89 2f       	mov	r24, r25
    1808:	90 2d       	mov	r25, r0
    180a:	c8 2f       	mov	r28, r24
    180c:	01 c0       	rjmp	.+2      	; 0x1810 <fIMU_calcGyro+0x48>
    180e:	c2 e0       	ldi	r28, 0x02	; 2
    1810:	bf 01       	movw	r22, r30
    1812:	ff 0f       	add	r31, r31
    1814:	88 0b       	sbc	r24, r24
    1816:	99 0b       	sbc	r25, r25
    1818:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    181c:	20 e0       	ldi	r18, 0x00	; 0
    181e:	30 e0       	ldi	r19, 0x00	; 0
    1820:	4c e8       	ldi	r20, 0x8C	; 140
    1822:	50 e4       	ldi	r21, 0x40	; 64
    1824:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    1828:	6b 01       	movw	r12, r22
    182a:	7c 01       	movw	r14, r24
    182c:	6c 2f       	mov	r22, r28
    182e:	70 e0       	ldi	r23, 0x00	; 0
    1830:	80 e0       	ldi	r24, 0x00	; 0
    1832:	90 e0       	ldi	r25, 0x00	; 0
    1834:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    1838:	9b 01       	movw	r18, r22
    183a:	ac 01       	movw	r20, r24
    183c:	c7 01       	movw	r24, r14
    183e:	b6 01       	movw	r22, r12
    1840:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    1844:	20 e0       	ldi	r18, 0x00	; 0
    1846:	30 e0       	ldi	r19, 0x00	; 0
    1848:	4a e7       	ldi	r20, 0x7A	; 122
    184a:	54 e4       	ldi	r21, 0x44	; 68
    184c:	0e 94 01 31 	call	0x6202	; 0x6202 <__divsf3>
    1850:	cf 91       	pop	r28
    1852:	ff 90       	pop	r15
    1854:	ef 90       	pop	r14
    1856:	df 90       	pop	r13
    1858:	cf 90       	pop	r12
    185a:	08 95       	ret

0000185c <fIMU_readFloatGyroZ>:
    }
    
    return output;
}
float fIMU_readFloatGyroZ(){
    float output = fIMU_calcGyro(i16IMU_readRawGyroZ());
    185c:	8d df       	rcall	.-230    	; 0x1778 <i16IMU_readRawGyroZ>
    185e:	b4 cf       	rjmp	.-152    	; 0x17c8 <fIMU_calcGyro>
    
    return output;
}
    1860:	08 95       	ret

00001862 <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    1862:	ea e0       	ldi	r30, 0x0A	; 10
    1864:	f1 e0       	ldi	r31, 0x01	; 1
    1866:	80 81       	ld	r24, Z
    1868:	87 60       	ori	r24, 0x07	; 7
    186a:	80 83       	st	Z, r24
    186c:	08 95       	ret

0000186e <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
    186e:	82 30       	cpi	r24, 0x02	; 2
    1870:	91 05       	cpc	r25, r1
    1872:	31 f4       	brne	.+12     	; 0x1880 <vLED_singleHigh+0x12>
    1874:	eb e0       	ldi	r30, 0x0B	; 11
    1876:	f1 e0       	ldi	r31, 0x01	; 1
    1878:	80 81       	ld	r24, Z
    187a:	84 60       	ori	r24, 0x04	; 4
    187c:	80 83       	st	Z, r24
    187e:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
    1880:	81 30       	cpi	r24, 0x01	; 1
    1882:	91 05       	cpc	r25, r1
    1884:	31 f4       	brne	.+12     	; 0x1892 <vLED_singleHigh+0x24>
    1886:	eb e0       	ldi	r30, 0x0B	; 11
    1888:	f1 e0       	ldi	r31, 0x01	; 1
    188a:	80 81       	ld	r24, Z
    188c:	82 60       	ori	r24, 0x02	; 2
    188e:	80 83       	st	Z, r24
    1890:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
    1892:	89 2b       	or	r24, r25
    1894:	29 f4       	brne	.+10     	; 0x18a0 <vLED_singleHigh+0x32>
    1896:	eb e0       	ldi	r30, 0x0B	; 11
    1898:	f1 e0       	ldi	r31, 0x01	; 1
    189a:	80 81       	ld	r24, Z
    189c:	81 60       	ori	r24, 0x01	; 1
    189e:	80 83       	st	Z, r24
    18a0:	08 95       	ret

000018a2 <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
    18a2:	82 30       	cpi	r24, 0x02	; 2
    18a4:	91 05       	cpc	r25, r1
    18a6:	31 f4       	brne	.+12     	; 0x18b4 <vLED_singleLow+0x12>
    18a8:	eb e0       	ldi	r30, 0x0B	; 11
    18aa:	f1 e0       	ldi	r31, 0x01	; 1
    18ac:	80 81       	ld	r24, Z
    18ae:	8b 7f       	andi	r24, 0xFB	; 251
    18b0:	80 83       	st	Z, r24
    18b2:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
    18b4:	81 30       	cpi	r24, 0x01	; 1
    18b6:	91 05       	cpc	r25, r1
    18b8:	31 f4       	brne	.+12     	; 0x18c6 <vLED_singleLow+0x24>
    18ba:	eb e0       	ldi	r30, 0x0B	; 11
    18bc:	f1 e0       	ldi	r31, 0x01	; 1
    18be:	80 81       	ld	r24, Z
    18c0:	8d 7f       	andi	r24, 0xFD	; 253
    18c2:	80 83       	st	Z, r24
    18c4:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
    18c6:	89 2b       	or	r24, r25
    18c8:	29 f4       	brne	.+10     	; 0x18d4 <vLED_singleLow+0x32>
    18ca:	eb e0       	ldi	r30, 0x0B	; 11
    18cc:	f1 e0       	ldi	r31, 0x01	; 1
    18ce:	80 81       	ld	r24, Z
    18d0:	8e 7f       	andi	r24, 0xFE	; 254
    18d2:	80 83       	st	Z, r24
    18d4:	08 95       	ret

000018d6 <vLED_toggle>:
}

/* Toggle a single LED */
void vLED_toggle(int ledCOLOR){
	if (ledCOLOR == ledGREEN)		ledPORT ^= (1<<ledGREEN);
    18d6:	82 30       	cpi	r24, 0x02	; 2
    18d8:	91 05       	cpc	r25, r1
    18da:	39 f4       	brne	.+14     	; 0x18ea <vLED_toggle+0x14>
    18dc:	eb e0       	ldi	r30, 0x0B	; 11
    18de:	f1 e0       	ldi	r31, 0x01	; 1
    18e0:	90 81       	ld	r25, Z
    18e2:	84 e0       	ldi	r24, 0x04	; 4
    18e4:	89 27       	eor	r24, r25
    18e6:	80 83       	st	Z, r24
    18e8:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)	ledPORT ^= (1<<ledYELLOW);
    18ea:	81 30       	cpi	r24, 0x01	; 1
    18ec:	91 05       	cpc	r25, r1
    18ee:	39 f4       	brne	.+14     	; 0x18fe <vLED_toggle+0x28>
    18f0:	eb e0       	ldi	r30, 0x0B	; 11
    18f2:	f1 e0       	ldi	r31, 0x01	; 1
    18f4:	90 81       	ld	r25, Z
    18f6:	82 e0       	ldi	r24, 0x02	; 2
    18f8:	89 27       	eor	r24, r25
    18fa:	80 83       	st	Z, r24
    18fc:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT ^= (1<<ledRED);
    18fe:	89 2b       	or	r24, r25
    1900:	31 f4       	brne	.+12     	; 0x190e <vLED_toggle+0x38>
    1902:	eb e0       	ldi	r30, 0x0B	; 11
    1904:	f1 e0       	ldi	r31, 0x01	; 1
    1906:	90 81       	ld	r25, Z
    1908:	81 e0       	ldi	r24, 0x01	; 1
    190a:	89 27       	eor	r24, r25
    190c:	80 83       	st	Z, r24
    190e:	08 95       	ret

00001910 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1910:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1912:	03 96       	adiw	r24, 0x03	; 3
    1914:	92 83       	std	Z+2, r25	; 0x02
    1916:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1918:	2f ef       	ldi	r18, 0xFF	; 255
    191a:	3f ef       	ldi	r19, 0xFF	; 255
    191c:	34 83       	std	Z+4, r19	; 0x04
    191e:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1920:	96 83       	std	Z+6, r25	; 0x06
    1922:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1924:	90 87       	std	Z+8, r25	; 0x08
    1926:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1928:	10 82       	st	Z, r1
    192a:	08 95       	ret

0000192c <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    192c:	fc 01       	movw	r30, r24
    192e:	11 86       	std	Z+9, r1	; 0x09
    1930:	10 86       	std	Z+8, r1	; 0x08
    1932:	08 95       	ret

00001934 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1934:	cf 93       	push	r28
    1936:	df 93       	push	r29
    1938:	9c 01       	movw	r18, r24
    193a:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    193c:	dc 01       	movw	r26, r24
    193e:	11 96       	adiw	r26, 0x01	; 1
    1940:	cd 91       	ld	r28, X+
    1942:	dc 91       	ld	r29, X
    1944:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1946:	d3 83       	std	Z+3, r29	; 0x03
    1948:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    194a:	8c 81       	ldd	r24, Y+4	; 0x04
    194c:	9d 81       	ldd	r25, Y+5	; 0x05
    194e:	95 83       	std	Z+5, r25	; 0x05
    1950:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    1952:	8c 81       	ldd	r24, Y+4	; 0x04
    1954:	9d 81       	ldd	r25, Y+5	; 0x05
    1956:	dc 01       	movw	r26, r24
    1958:	13 96       	adiw	r26, 0x03	; 3
    195a:	7c 93       	st	X, r23
    195c:	6e 93       	st	-X, r22
    195e:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    1960:	7d 83       	std	Y+5, r23	; 0x05
    1962:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1964:	31 87       	std	Z+9, r19	; 0x09
    1966:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    1968:	f9 01       	movw	r30, r18
    196a:	80 81       	ld	r24, Z
    196c:	8f 5f       	subi	r24, 0xFF	; 255
    196e:	80 83       	st	Z, r24
}
    1970:	df 91       	pop	r29
    1972:	cf 91       	pop	r28
    1974:	08 95       	ret

00001976 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1976:	cf 93       	push	r28
    1978:	df 93       	push	r29
    197a:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    197c:	48 81       	ld	r20, Y
    197e:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1980:	4f 3f       	cpi	r20, 0xFF	; 255
    1982:	2f ef       	ldi	r18, 0xFF	; 255
    1984:	52 07       	cpc	r21, r18
    1986:	21 f4       	brne	.+8      	; 0x1990 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1988:	fc 01       	movw	r30, r24
    198a:	a7 81       	ldd	r26, Z+7	; 0x07
    198c:	b0 85       	ldd	r27, Z+8	; 0x08
    198e:	0d c0       	rjmp	.+26     	; 0x19aa <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1990:	dc 01       	movw	r26, r24
    1992:	13 96       	adiw	r26, 0x03	; 3
    1994:	01 c0       	rjmp	.+2      	; 0x1998 <vListInsert+0x22>
    1996:	df 01       	movw	r26, r30
    1998:	12 96       	adiw	r26, 0x02	; 2
    199a:	ed 91       	ld	r30, X+
    199c:	fc 91       	ld	r31, X
    199e:	13 97       	sbiw	r26, 0x03	; 3
    19a0:	20 81       	ld	r18, Z
    19a2:	31 81       	ldd	r19, Z+1	; 0x01
    19a4:	42 17       	cp	r20, r18
    19a6:	53 07       	cpc	r21, r19
    19a8:	b0 f7       	brcc	.-20     	; 0x1996 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    19aa:	12 96       	adiw	r26, 0x02	; 2
    19ac:	ed 91       	ld	r30, X+
    19ae:	fc 91       	ld	r31, X
    19b0:	13 97       	sbiw	r26, 0x03	; 3
    19b2:	fb 83       	std	Y+3, r31	; 0x03
    19b4:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    19b6:	d5 83       	std	Z+5, r29	; 0x05
    19b8:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    19ba:	bd 83       	std	Y+5, r27	; 0x05
    19bc:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    19be:	13 96       	adiw	r26, 0x03	; 3
    19c0:	dc 93       	st	X, r29
    19c2:	ce 93       	st	-X, r28
    19c4:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19c6:	99 87       	std	Y+9, r25	; 0x09
    19c8:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    19ca:	fc 01       	movw	r30, r24
    19cc:	20 81       	ld	r18, Z
    19ce:	2f 5f       	subi	r18, 0xFF	; 255
    19d0:	20 83       	st	Z, r18
}
    19d2:	df 91       	pop	r29
    19d4:	cf 91       	pop	r28
    19d6:	08 95       	ret

000019d8 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    19d8:	cf 93       	push	r28
    19da:	df 93       	push	r29
    19dc:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    19de:	a0 85       	ldd	r26, Z+8	; 0x08
    19e0:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    19e2:	c2 81       	ldd	r28, Z+2	; 0x02
    19e4:	d3 81       	ldd	r29, Z+3	; 0x03
    19e6:	84 81       	ldd	r24, Z+4	; 0x04
    19e8:	95 81       	ldd	r25, Z+5	; 0x05
    19ea:	9d 83       	std	Y+5, r25	; 0x05
    19ec:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    19ee:	c4 81       	ldd	r28, Z+4	; 0x04
    19f0:	d5 81       	ldd	r29, Z+5	; 0x05
    19f2:	82 81       	ldd	r24, Z+2	; 0x02
    19f4:	93 81       	ldd	r25, Z+3	; 0x03
    19f6:	9b 83       	std	Y+3, r25	; 0x03
    19f8:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    19fa:	11 96       	adiw	r26, 0x01	; 1
    19fc:	8d 91       	ld	r24, X+
    19fe:	9c 91       	ld	r25, X
    1a00:	12 97       	sbiw	r26, 0x02	; 2
    1a02:	e8 17       	cp	r30, r24
    1a04:	f9 07       	cpc	r31, r25
    1a06:	31 f4       	brne	.+12     	; 0x1a14 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a08:	84 81       	ldd	r24, Z+4	; 0x04
    1a0a:	95 81       	ldd	r25, Z+5	; 0x05
    1a0c:	12 96       	adiw	r26, 0x02	; 2
    1a0e:	9c 93       	st	X, r25
    1a10:	8e 93       	st	-X, r24
    1a12:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1a14:	11 86       	std	Z+9, r1	; 0x09
    1a16:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1a18:	8c 91       	ld	r24, X
    1a1a:	81 50       	subi	r24, 0x01	; 1
    1a1c:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1a1e:	df 91       	pop	r29
    1a20:	cf 91       	pop	r28
    1a22:	08 95       	ret

00001a24 <vMainCommunicationTask>:
    #define toc PORTH &= ~(1<<PINH5)
#endif

/*  Communication task */
/*  Communication task */
void vMainCommunicationTask( void *pvParameters ){
    1a24:	cf 93       	push	r28
    1a26:	df 93       	push	r29
    1a28:	00 d0       	rcall	.+0      	; 0x1a2a <vMainCommunicationTask+0x6>
    1a2a:	00 d0       	rcall	.+0      	; 0x1a2c <vMainCommunicationTask+0x8>
    1a2c:	cd b7       	in	r28, 0x3d	; 61
    1a2e:	de b7       	in	r29, 0x3e	; 62
	// Setup for the communication task
	struct sPolar Setpoint = {0}; // Struct for setpoints from server
    1a30:	fe 01       	movw	r30, r28
    1a32:	31 96       	adiw	r30, 0x01	; 1
    1a34:	86 e0       	ldi	r24, 0x06	; 6
    1a36:	df 01       	movw	r26, r30
    1a38:	1d 92       	st	X+, r1
    1a3a:	8a 95       	dec	r24
    1a3c:	e9 f7       	brne	.-6      	; 0x1a38 <vMainCommunicationTask+0x14>

	message_t command_in; // Buffer for recieved messages

	server_communication_init();
    1a3e:	0e 94 26 20 	call	0x404c	; 0x404c <server_communication_init>
	if(xTaskCreate(vARQTask, "ARQ", 200, NULL, 3, NULL) != pdPASS) {
    1a42:	a1 2c       	mov	r10, r1
    1a44:	b1 2c       	mov	r11, r1
    1a46:	c1 2c       	mov	r12, r1
    1a48:	d1 2c       	mov	r13, r1
    1a4a:	e1 2c       	mov	r14, r1
    1a4c:	f1 2c       	mov	r15, r1
    1a4e:	03 e0       	ldi	r16, 0x03	; 3
    1a50:	20 e0       	ldi	r18, 0x00	; 0
    1a52:	30 e0       	ldi	r19, 0x00	; 0
    1a54:	48 ec       	ldi	r20, 0xC8	; 200
    1a56:	50 e0       	ldi	r21, 0x00	; 0
    1a58:	6b e0       	ldi	r22, 0x0B	; 11
    1a5a:	76 e0       	ldi	r23, 0x06	; 6
    1a5c:	85 e2       	ldi	r24, 0x25	; 37
    1a5e:	95 e0       	ldi	r25, 0x05	; 5
    1a60:	0e 94 a1 22 	call	0x4542	; 0x4542 <xTaskGenericCreate>
    1a64:	81 30       	cpi	r24, 0x01	; 1
    1a66:	19 f0       	breq	.+6      	; 0x1a6e <vMainCommunicationTask+0x4a>
		vLED_singleHigh(ledRED);
    1a68:	80 e0       	ldi	r24, 0x00	; 0
    1a6a:	90 e0       	ldi	r25, 0x00	; 0
    1a6c:	00 df       	rcall	.-512    	; 0x186e <vLED_singleHigh>
	}
	uint8_t success = 0;
	
	while(!success) {
		success = server_connect();
    1a6e:	0e 94 2f 20 	call	0x405e	; 0x405e <server_connect>
    1a72:	18 2f       	mov	r17, r24
		vTaskDelay(1000 / portTICK_PERIOD_MS);
    1a74:	88 ee       	ldi	r24, 0xE8	; 232
    1a76:	93 e0       	ldi	r25, 0x03	; 3
    1a78:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vTaskDelay>
		vLED_toggle(ledGREEN);
    1a7c:	82 e0       	ldi	r24, 0x02	; 2
    1a7e:	90 e0       	ldi	r25, 0x00	; 0
    1a80:	2a df       	rcall	.-428    	; 0x18d6 <vLED_toggle>
	if(xTaskCreate(vARQTask, "ARQ", 200, NULL, 3, NULL) != pdPASS) {
		vLED_singleHigh(ledRED);
	}
	uint8_t success = 0;
	
	while(!success) {
    1a82:	11 23       	and	r17, r17
    1a84:	a1 f3       	breq	.-24     	; 0x1a6e <vMainCommunicationTask+0x4a>
		success = server_connect();
		vTaskDelay(1000 / portTICK_PERIOD_MS);
		vLED_toggle(ledGREEN);
	}
	
	send_handshake();
    1a86:	0e 94 3b 20 	call	0x4076	; 0x4076 <send_handshake>
	while(1){
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
			taskENTER_CRITICAL();
			command_in = message_in;
    1a8a:	0f 2e       	mov	r0, r31
    1a8c:	f7 e3       	ldi	r31, 0x37	; 55
    1a8e:	ef 2e       	mov	r14, r31
    1a90:	fb e1       	ldi	r31, 0x1B	; 27
    1a92:	ff 2e       	mov	r15, r31
    1a94:	f0 2d       	mov	r31, r0
			taskEXIT_CRITICAL();
			xTaskResumeAll ();      // Enable context switching
			switch(command_in.type){
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
					gHandshook = TRUE; // Set start flag true
    1a96:	01 e0       	ldi	r16, 0x01	; 1
					// Ensure max values are not exceeded
					if (Setpoint.distance > 320){
						Setpoint.distance = 320;
					}
					else if (Setpoint.distance < -320){
						Setpoint.distance = -320;
    1a98:	0f 2e       	mov	r0, r31
    1a9a:	f0 ec       	ldi	r31, 0xC0	; 192
    1a9c:	6f 2e       	mov	r6, r31
    1a9e:	fe ef       	ldi	r31, 0xFE	; 254
    1aa0:	7f 2e       	mov	r7, r31
    1aa2:	f0 2d       	mov	r31, r0
				case TYPE_ORDER:
					Setpoint.heading = command_in.message.order.orientation;
					Setpoint.distance = command_in.message.order.distance;
					// Ensure max values are not exceeded
					if (Setpoint.distance > 320){
						Setpoint.distance = 320;
    1aa4:	68 94       	set
    1aa6:	88 24       	eor	r8, r8
    1aa8:	86 f8       	bld	r8, 6
    1aaa:	99 24       	eor	r9, r9
    1aac:	93 94       	inc	r9
	}
	
	send_handshake();
	
	while(1){
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	4f ef       	ldi	r20, 0xFF	; 255
    1ab2:	5f ef       	ldi	r21, 0xFF	; 255
    1ab4:	60 e0       	ldi	r22, 0x00	; 0
    1ab6:	70 e0       	ldi	r23, 0x00	; 0
    1ab8:	80 91 33 1b 	lds	r24, 0x1B33	; 0x801b33 <xCommandReadyBSem>
    1abc:	90 91 34 1b 	lds	r25, 0x1B34	; 0x801b34 <xCommandReadyBSem+0x1>
    1ac0:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
    1ac4:	81 30       	cpi	r24, 0x01	; 1
    1ac6:	99 f7       	brne	.-26     	; 0x1aae <vMainCommunicationTask+0x8a>
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
    1ac8:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <vTaskSuspendAll>
			taskENTER_CRITICAL();
    1acc:	0f b6       	in	r0, 0x3f	; 63
    1ace:	f8 94       	cli
    1ad0:	0f 92       	push	r0
			command_in = message_in;
    1ad2:	f7 01       	movw	r30, r14
    1ad4:	10 81       	ld	r17, Z
    1ad6:	c1 80       	ldd	r12, Z+1	; 0x01
    1ad8:	d2 80       	ldd	r13, Z+2	; 0x02
    1ada:	a3 80       	ldd	r10, Z+3	; 0x03
    1adc:	b4 80       	ldd	r11, Z+4	; 0x04
			taskEXIT_CRITICAL();
    1ade:	0f 90       	pop	r0
    1ae0:	0f be       	out	0x3f, r0	; 63
			xTaskResumeAll ();      // Enable context switching
    1ae2:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
			switch(command_in.type){
    1ae6:	15 30       	cpi	r17, 0x05	; 5
    1ae8:	09 f4       	brne	.+2      	; 0x1aec <vMainCommunicationTask+0xc8>
    1aea:	65 c0       	rjmp	.+202    	; 0x1bb6 <vMainCommunicationTask+0x192>
    1aec:	30 f4       	brcc	.+12     	; 0x1afa <vMainCommunicationTask+0xd6>
    1aee:	12 30       	cpi	r17, 0x02	; 2
    1af0:	b1 f0       	breq	.+44     	; 0x1b1e <vMainCommunicationTask+0xfa>
    1af2:	14 30       	cpi	r17, 0x04	; 4
    1af4:	09 f4       	brne	.+2      	; 0x1af8 <vMainCommunicationTask+0xd4>
    1af6:	45 c0       	rjmp	.+138    	; 0x1b82 <vMainCommunicationTask+0x15e>
    1af8:	da cf       	rjmp	.-76     	; 0x1aae <vMainCommunicationTask+0x8a>
    1afa:	17 30       	cpi	r17, 0x07	; 7
    1afc:	09 f4       	brne	.+2      	; 0x1b00 <vMainCommunicationTask+0xdc>
    1afe:	63 c0       	rjmp	.+198    	; 0x1bc6 <vMainCommunicationTask+0x1a2>
    1b00:	18 f0       	brcs	.+6      	; 0x1b08 <vMainCommunicationTask+0xe4>
    1b02:	18 30       	cpi	r17, 0x08	; 8
    1b04:	49 f0       	breq	.+18     	; 0x1b18 <vMainCommunicationTask+0xf4>
    1b06:	d3 cf       	rjmp	.-90     	; 0x1aae <vMainCommunicationTask+0x8a>
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
    1b08:	0f b6       	in	r0, 0x3f	; 63
    1b0a:	f8 94       	cli
    1b0c:	0f 92       	push	r0
					gHandshook = TRUE; // Set start flag true
    1b0e:	00 93 c2 19 	sts	0x19C2, r16	; 0x8019c2 <gHandshook>
					taskEXIT_CRITICAL();
    1b12:	0f 90       	pop	r0
    1b14:	0f be       	out	0x3f, r0	; 63

					break;
    1b16:	cb cf       	rjmp	.-106    	; 0x1aae <vMainCommunicationTask+0x8a>
					case TYPE_PING:
					send_ping_response();
    1b18:	0e 94 44 21 	call	0x4288	; 0x4288 <send_ping_response>
					break;
    1b1c:	c8 cf       	rjmp	.-112    	; 0x1aae <vMainCommunicationTask+0x8a>
				case TYPE_ORDER:
					Setpoint.heading = command_in.message.order.orientation;
    1b1e:	b6 01       	movw	r22, r12
    1b20:	dd 0c       	add	r13, r13
    1b22:	88 0b       	sbc	r24, r24
    1b24:	99 0b       	sbc	r25, r25
    1b26:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
					Setpoint.distance = command_in.message.order.distance;
					// Ensure max values are not exceeded
					if (Setpoint.distance > 320){
    1b2a:	f1 e4       	ldi	r31, 0x41	; 65
    1b2c:	af 16       	cp	r10, r31
    1b2e:	f1 e0       	ldi	r31, 0x01	; 1
    1b30:	bf 06       	cpc	r11, r31
    1b32:	1c f0       	brlt	.+6      	; 0x1b3a <vMainCommunicationTask+0x116>
						Setpoint.distance = 320;
    1b34:	9e 82       	std	Y+6, r9	; 0x06
    1b36:	8d 82       	std	Y+5, r8	; 0x05
    1b38:	0a c0       	rjmp	.+20     	; 0x1b4e <vMainCommunicationTask+0x12a>
					}
					else if (Setpoint.distance < -320){
    1b3a:	20 ec       	ldi	r18, 0xC0	; 192
    1b3c:	a2 16       	cp	r10, r18
    1b3e:	2e ef       	ldi	r18, 0xFE	; 254
    1b40:	b2 06       	cpc	r11, r18
    1b42:	1c f0       	brlt	.+6      	; 0x1b4a <vMainCommunicationTask+0x126>
					case TYPE_PING:
					send_ping_response();
					break;
				case TYPE_ORDER:
					Setpoint.heading = command_in.message.order.orientation;
					Setpoint.distance = command_in.message.order.distance;
    1b44:	be 82       	std	Y+6, r11	; 0x06
    1b46:	ad 82       	std	Y+5, r10	; 0x05
    1b48:	02 c0       	rjmp	.+4      	; 0x1b4e <vMainCommunicationTask+0x12a>
					// Ensure max values are not exceeded
					if (Setpoint.distance > 320){
						Setpoint.distance = 320;
					}
					else if (Setpoint.distance < -320){
						Setpoint.distance = -320;
    1b4a:	7e 82       	std	Y+6, r7	; 0x06
    1b4c:	6d 82       	std	Y+5, r6	; 0x05
					}
					Setpoint.heading *= DEG2RAD; // Convert received set point to radians
    1b4e:	25 e3       	ldi	r18, 0x35	; 53
    1b50:	3a ef       	ldi	r19, 0xFA	; 250
    1b52:	4e e8       	ldi	r20, 0x8E	; 142
    1b54:	5c e3       	ldi	r21, 0x3C	; 60
    1b56:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    1b5a:	69 83       	std	Y+1, r22	; 0x01
    1b5c:	7a 83       	std	Y+2, r23	; 0x02
    1b5e:	8b 83       	std	Y+3, r24	; 0x03
    1b60:	9c 83       	std	Y+4, r25	; 0x04
					vFunc_Inf2pi(&Setpoint.heading);
    1b62:	ce 01       	movw	r24, r28
    1b64:	01 96       	adiw	r24, 0x01	; 1
    1b66:	66 da       	rcall	.-2868   	; 0x1034 <vFunc_Inf2pi>
				
					/* Relay new coordinates to position controller */
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1b68:	20 e0       	ldi	r18, 0x00	; 0
    1b6a:	44 e6       	ldi	r20, 0x64	; 100
    1b6c:	50 e0       	ldi	r21, 0x00	; 0
    1b6e:	be 01       	movw	r22, r28
    1b70:	6f 5f       	subi	r22, 0xFF	; 255
    1b72:	7f 4f       	sbci	r23, 0xFF	; 255
    1b74:	80 91 c9 19 	lds	r24, 0x19C9	; 0x8019c9 <poseControllerQ>
    1b78:	90 91 ca 19 	lds	r25, 0x19CA	; 0x8019ca <poseControllerQ+0x1>
    1b7c:	0e 94 08 1b 	call	0x3610	; 0x3610 <xQueueGenericSend>
					break;
    1b80:	96 cf       	rjmp	.-212    	; 0x1aae <vMainCommunicationTask+0x8a>
				case TYPE_PAUSE:
					// Stop sending update messages
					taskENTER_CRITICAL();
    1b82:	0f b6       	in	r0, 0x3f	; 63
    1b84:	f8 94       	cli
    1b86:	0f 92       	push	r0
					gPaused = TRUE;
    1b88:	00 93 c1 19 	sts	0x19C1, r16	; 0x8019c1 <gPaused>
					taskEXIT_CRITICAL();
    1b8c:	0f 90       	pop	r0
    1b8e:	0f be       	out	0x3f, r0	; 63
					// Stop controller
					Setpoint.distance = 0;
    1b90:	1e 82       	std	Y+6, r1	; 0x06
    1b92:	1d 82       	std	Y+5, r1	; 0x05
					Setpoint.heading = 0;
    1b94:	19 82       	std	Y+1, r1	; 0x01
    1b96:	1a 82       	std	Y+2, r1	; 0x02
    1b98:	1b 82       	std	Y+3, r1	; 0x03
    1b9a:	1c 82       	std	Y+4, r1	; 0x04
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1b9c:	20 e0       	ldi	r18, 0x00	; 0
    1b9e:	44 e6       	ldi	r20, 0x64	; 100
    1ba0:	50 e0       	ldi	r21, 0x00	; 0
    1ba2:	be 01       	movw	r22, r28
    1ba4:	6f 5f       	subi	r22, 0xFF	; 255
    1ba6:	7f 4f       	sbci	r23, 0xFF	; 255
    1ba8:	80 91 c9 19 	lds	r24, 0x19C9	; 0x8019c9 <poseControllerQ>
    1bac:	90 91 ca 19 	lds	r25, 0x19CA	; 0x8019ca <poseControllerQ+0x1>
    1bb0:	0e 94 08 1b 	call	0x3610	; 0x3610 <xQueueGenericSend>
					break;
    1bb4:	7c cf       	rjmp	.-264    	; 0x1aae <vMainCommunicationTask+0x8a>
				case TYPE_UNPAUSE:
					taskENTER_CRITICAL();
    1bb6:	0f b6       	in	r0, 0x3f	; 63
    1bb8:	f8 94       	cli
    1bba:	0f 92       	push	r0
					gPaused = FALSE;
    1bbc:	10 92 c1 19 	sts	0x19C1, r1	; 0x8019c1 <gPaused>
					taskEXIT_CRITICAL();
    1bc0:	0f 90       	pop	r0
    1bc2:	0f be       	out	0x3f, r0	; 63
					break;
    1bc4:	74 cf       	rjmp	.-280    	; 0x1aae <vMainCommunicationTask+0x8a>
				case TYPE_FINISH:
					taskENTER_CRITICAL();
    1bc6:	0f b6       	in	r0, 0x3f	; 63
    1bc8:	f8 94       	cli
    1bca:	0f 92       	push	r0
					gHandshook = FALSE;
    1bcc:	10 92 c2 19 	sts	0x19C2, r1	; 0x8019c2 <gHandshook>
					taskEXIT_CRITICAL();
    1bd0:	0f 90       	pop	r0
    1bd2:	0f be       	out	0x3f, r0	; 63
					break;
    1bd4:	6c cf       	rjmp	.-296    	; 0x1aae <vMainCommunicationTask+0x8a>

00001bd6 <vMainMovementTask>:
    } // While(1) end
}

/* Handles request from position controller and sets motor pins. */
/* Frequency set by PERIOD_MOTOR_MS in defines.h */
void vMainMovementTask( void *pvParameters ){
    1bd6:	cf 93       	push	r28
    1bd8:	df 93       	push	r29
    1bda:	1f 92       	push	r1
    1bdc:	1f 92       	push	r1
    1bde:	cd b7       	in	r28, 0x3d	; 61
    1be0:	de b7       	in	r29, 0x3e	; 62
    
    
    
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    1be2:	0e 94 02 29 	call	0x5204	; 0x5204 <xTaskGetTickCount>
    1be6:	9a 83       	std	Y+2, r25	; 0x02
    1be8:	89 83       	std	Y+1, r24	; 0x01
    const TickType_t xDelay = PERIOD_MOTOR_MS;
    
    while(1){
		
		
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    1bea:	64 e1       	ldi	r22, 0x14	; 20
    1bec:	70 e0       	ldi	r23, 0x00	; 0
    1bee:	ce 01       	movw	r24, r28
    1bf0:	01 96       	adiw	r24, 0x01	; 1
    1bf2:	0e 94 b5 23 	call	0x476a	; 0x476a <vTaskDelayUntil>
    1bf6:	f9 cf       	rjmp	.-14     	; 0x1bea <vMainMovementTask+0x14>

00001bf8 <vMainSensorTowerTask>:
		} // if (xCommandReady) end
	}// While(1) end
}// vMainComtask end

/*  Sensor tower task */
void vMainSensorTowerTask( void *pvParameters){
    1bf8:	cf 93       	push	r28
    1bfa:	df 93       	push	r29
    1bfc:	cd b7       	in	r28, 0x3d	; 61
    1bfe:	de b7       	in	r29, 0x3e	; 62
    1c00:	2f 97       	sbiw	r28, 0x0f	; 15
    1c02:	0f b6       	in	r0, 0x3f	; 63
    1c04:	f8 94       	cli
    1c06:	de bf       	out	0x3e, r29	; 62
    1c08:	0f be       	out	0x3f, r0	; 63
    1c0a:	cd bf       	out	0x3d, r28	; 61
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    uint8_t robotMovement = moveStop;
    1c0c:	19 82       	std	Y+1, r1	; 0x01
    
    uint8_t idleCounter = 0;
    1c0e:	f1 2c       	mov	r15, r1
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    1c10:	33 24       	eor	r3, r3
    1c12:	33 94       	inc	r3
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    1c14:	10 e0       	ldi	r17, 0x00	; 0
        
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    1c16:	68 94       	set
    1c18:	dd 24       	eor	r13, r13
    1c1a:	d2 f8       	bld	r13, 2
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1c1c:	68 94       	set
    1c1e:	22 24       	eor	r2, r2
    1c20:	22 f8       	bld	r2, 2
    1c22:	0e c0       	rjmp	.+28     	; 0x1c40 <vMainSensorTowerTask+0x48>
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
                rotationDirection = moveClockwise;
    1c24:	0f 2e       	mov	r0, r31
    1c26:	f3 e0       	ldi	r31, 0x03	; 3
    1c28:	df 2e       	mov	r13, r31
    1c2a:	f0 2d       	mov	r31, r0
    1c2c:	09 c0       	rjmp	.+18     	; 0x1c40 <vMainSensorTowerTask+0x48>
    1c2e:	0f 2e       	mov	r0, r31
    1c30:	f3 e0       	ldi	r31, 0x03	; 3
    1c32:	df 2e       	mov	r13, r31
    1c34:	f0 2d       	mov	r31, r0
    1c36:	04 c0       	rjmp	.+8      	; 0x1c40 <vMainSensorTowerTask+0x48>
    1c38:	0f 2e       	mov	r0, r31
    1c3a:	f3 e0       	ldi	r31, 0x03	; 3
    1c3c:	df 2e       	mov	r13, r31
    1c3e:	f0 2d       	mov	r31, r0
    // Initialize the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    
    while(1){
        // Loop
        if ((gHandshook == TRUE) && (gPaused == FALSE)){
    1c40:	80 91 c2 19 	lds	r24, 0x19C2	; 0x8019c2 <gHandshook>
    1c44:	81 30       	cpi	r24, 0x01	; 1
    1c46:	09 f0       	breq	.+2      	; 0x1c4a <vMainSensorTowerTask+0x52>
    1c48:	06 c1       	rjmp	.+524    	; 0x1e56 <vMainSensorTowerTask+0x25e>
    1c4a:	80 91 c1 19 	lds	r24, 0x19C1	; 0x8019c1 <gPaused>
    1c4e:	81 11       	cpse	r24, r1
    1c50:	02 c1       	rjmp	.+516    	; 0x1e56 <vMainSensorTowerTask+0x25e>
            // xLastWakeTime variable with the current time.
            xLastWakeTime = xTaskGetTickCount();
    1c52:	0e 94 02 29 	call	0x5204	; 0x5204 <xTaskGetTickCount>
    1c56:	9b 83       	std	Y+3, r25	; 0x03
    1c58:	8a 83       	std	Y+2, r24	; 0x02
            // Set scanning resolution depending on which movement the robot is executing.
            if (xQueueReceive(scanStatusQ, &robotMovement,150 / portTICK_PERIOD_MS) == pdTRUE){
    1c5a:	20 e0       	ldi	r18, 0x00	; 0
    1c5c:	46 e9       	ldi	r20, 0x96	; 150
    1c5e:	50 e0       	ldi	r21, 0x00	; 0
    1c60:	be 01       	movw	r22, r28
    1c62:	6f 5f       	subi	r22, 0xFF	; 255
    1c64:	7f 4f       	sbci	r23, 0xFF	; 255
    1c66:	80 91 c7 19 	lds	r24, 0x19C7	; 0x8019c7 <scanStatusQ>
    1c6a:	90 91 c8 19 	lds	r25, 0x19C8	; 0x8019c8 <scanStatusQ+0x1>
    1c6e:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
    1c72:	81 30       	cpi	r24, 0x01	; 1
    1c74:	d9 f4       	brne	.+54     	; 0x1cac <vMainSensorTowerTask+0xb4>
                // Set servo step length according to movement, 
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
    1c76:	89 81       	ldd	r24, Y+1	; 0x01
    1c78:	88 23       	and	r24, r24
    1c7a:	19 f0       	breq	.+6      	; 0x1c82 <vMainSensorTowerTask+0x8a>
    1c7c:	83 30       	cpi	r24, 0x03	; 3
    1c7e:	a8 f4       	brcc	.+42     	; 0x1caa <vMainSensorTowerTask+0xb2>
    1c80:	08 c0       	rjmp	.+16     	; 0x1c92 <vMainSensorTowerTask+0x9a>
                {
                    case moveStop:
                        servoStep *= servoResolution;
    1c82:	13 9d       	mul	r17, r3
    1c84:	10 2d       	mov	r17, r0
    1c86:	11 24       	eor	r1, r1
                        servoResolution = 1;
                        idleCounter = 1;
    1c88:	ff 24       	eor	r15, r15
    1c8a:	f3 94       	inc	r15
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
                {
                    case moveStop:
                        servoStep *= servoResolution;
                        servoResolution = 1;
    1c8c:	33 24       	eor	r3, r3
    1c8e:	33 94       	inc	r3
                        idleCounter = 1;
                    break;
    1c90:	0d c0       	rjmp	.+26     	; 0x1cac <vMainSensorTowerTask+0xb4>
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
                        servoStep /= servoResolution;
    1c92:	8d ec       	ldi	r24, 0xCD	; 205
    1c94:	18 9f       	mul	r17, r24
    1c96:	11 2d       	mov	r17, r1
    1c98:	11 24       	eor	r1, r1
    1c9a:	16 95       	lsr	r17
    1c9c:	16 95       	lsr	r17
                        idleCounter = 0;
    1c9e:	f1 2c       	mov	r15, r1
                        servoResolution = 1;
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
    1ca0:	0f 2e       	mov	r0, r31
    1ca2:	f5 e0       	ldi	r31, 0x05	; 5
    1ca4:	3f 2e       	mov	r3, r31
    1ca6:	f0 2d       	mov	r31, r0
                        servoStep /= servoResolution;
                        idleCounter = 0;
                    break;
    1ca8:	01 c0       	rjmp	.+2      	; 0x1cac <vMainSensorTowerTask+0xb4>
                    case moveClockwise:
                    case moveCounterClockwise:
                        // Iterations are frozen while rotating, see further down
                        idleCounter = 0;
    1caa:	f1 2c       	mov	r15, r1
                    default:
                        idleCounter = 0;
                    break;
                }
            }
            vServo_setAngle(servoStep*servoResolution);
    1cac:	13 9d       	mul	r17, r3
    1cae:	80 2d       	mov	r24, r0
    1cb0:	11 24       	eor	r1, r1
    1cb2:	0e 94 68 21 	call	0x42d0	; 0x42d0 <vServo_setAngle>
            vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_PERIOD_MS); // Wait total of 200 ms for servo to reach set point
    1cb6:	68 ec       	ldi	r22, 0xC8	; 200
    1cb8:	70 e0       	ldi	r23, 0x00	; 0
    1cba:	ce 01       	movw	r24, r28
    1cbc:	02 96       	adiw	r24, 0x02	; 2
    1cbe:	0e 94 b5 23 	call	0x476a	; 0x476a <vTaskDelayUntil>
            
            uint8_t forwardSensor = ui8DistSens_readCM(distSensFwd);
    1cc2:	80 e0       	ldi	r24, 0x00	; 0
    1cc4:	94 d9       	rcall	.-3288   	; 0xfee <ui8DistSens_readCM>
    1cc6:	8e 87       	std	Y+14, r24	; 0x0e
            uint8_t leftSensor = ui8DistSens_readCM(distSensLeft);
    1cc8:	81 e0       	ldi	r24, 0x01	; 1
    1cca:	91 d9       	rcall	.-3294   	; 0xfee <ui8DistSens_readCM>
    1ccc:	e8 2e       	mov	r14, r24
            uint8_t rearSensor = ui8DistSens_readCM(distSensRear);
    1cce:	83 e0       	ldi	r24, 0x03	; 3
    1cd0:	8e d9       	rcall	.-3300   	; 0xfee <ui8DistSens_readCM>
    1cd2:	c8 2e       	mov	r12, r24
            uint8_t rightSensor = ui8DistSens_readCM(distSensRight);
    1cd4:	82 e0       	ldi	r24, 0x02	; 2
    1cd6:	8b d9       	rcall	.-3306   	; 0xfee <ui8DistSens_readCM>
    1cd8:	8f 87       	std	Y+15, r24	; 0x0f
    1cda:	20 e0       	ldi	r18, 0x00	; 0
            
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
    1cdc:	48 e2       	ldi	r20, 0x28	; 40
    1cde:	50 e0       	ldi	r21, 0x00	; 0
    1ce0:	60 e0       	ldi	r22, 0x00	; 0
    1ce2:	70 e0       	ldi	r23, 0x00	; 0
    1ce4:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xPoseMutex>
    1ce8:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xPoseMutex+0x1>
    1cec:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
    1cf0:	80 91 bd 19 	lds	r24, 0x19BD	; 0x8019bd <gTheta_hat>
                thetahat = gTheta_hat;
    1cf4:	90 91 be 19 	lds	r25, 0x19BE	; 0x8019be <gTheta_hat+0x1>
    1cf8:	a0 91 bf 19 	lds	r26, 0x19BF	; 0x8019bf <gTheta_hat+0x2>
    1cfc:	b0 91 c0 19 	lds	r27, 0x19C0	; 0x8019c0 <gTheta_hat+0x3>
    1d00:	8a 87       	std	Y+10, r24	; 0x0a
    1d02:	9b 87       	std	Y+11, r25	; 0x0b
    1d04:	ac 87       	std	Y+12, r26	; 0x0c
    1d06:	bd 87       	std	Y+13, r27	; 0x0d
    1d08:	a0 90 bb 19 	lds	r10, 0x19BB	; 0x8019bb <gX_hat>
                xhat = gX_hat;
    1d0c:	b0 90 bc 19 	lds	r11, 0x19BC	; 0x8019bc <gX_hat+0x1>
    1d10:	60 90 b9 19 	lds	r6, 0x19B9	; 0x8019b9 <gY_hat>
                yhat = gY_hat;
    1d14:	70 90 ba 19 	lds	r7, 0x19BA	; 0x8019ba <gY_hat+0x1>
    1d18:	60 e0       	ldi	r22, 0x00	; 0
            xSemaphoreGive(xPoseMutex);
    1d1a:	70 e0       	ldi	r23, 0x00	; 0
    1d1c:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xPoseMutex>
    1d20:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xPoseMutex+0x1>
    1d24:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
    1d28:	9a e0       	ldi	r25, 0x0A	; 10
            
            // Experimental
            if ((idleCounter > 10) && (robotMovement == moveStop)){
    1d2a:	9f 15       	cp	r25, r15
    1d2c:	40 f4       	brcc	.+16     	; 0x1d3e <vMainSensorTowerTask+0x146>
    1d2e:	89 81       	ldd	r24, Y+1	; 0x01
    1d30:	81 11       	cpse	r24, r1
    1d32:	05 c0       	rjmp	.+10     	; 0x1d3e <vMainSensorTowerTask+0x146>
    1d34:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <send_idle>
                // If the robot stands idle for 1 second, send 'status:idle' in case the server missed it.
                send_idle();
    1d38:	ff 24       	eor	r15, r15
                idleCounter = 1;
    1d3a:	f3 94       	inc	r15
    1d3c:	06 c0       	rjmp	.+12     	; 0x1d4a <vMainSensorTowerTask+0x152>
    1d3e:	ff 20       	and	r15, r15
            }
            else if ((idleCounter >= 1) && (robotMovement == moveStop)){
    1d40:	21 f0       	breq	.+8      	; 0x1d4a <vMainSensorTowerTask+0x152>
    1d42:	89 81       	ldd	r24, Y+1	; 0x01
    1d44:	81 11       	cpse	r24, r1
    1d46:	01 c0       	rjmp	.+2      	; 0x1d4a <vMainSensorTowerTask+0x152>
    1d48:	f3 94       	inc	r15
                idleCounter++;
    1d4a:	43 2c       	mov	r4, r3
            }             

            // Send updates to server
			
			//[Commented out to decrease messages, ]
            send_update(xhat/10,yhat/10,thetahat*RAD2DEG,servoStep*servoResolution,forwardSensor,leftSensor,rearSensor,rightSensor);
    1d4c:	51 2c       	mov	r5, r1
    1d4e:	14 9d       	mul	r17, r4
    1d50:	40 01       	movw	r8, r0
    1d52:	15 9d       	mul	r17, r5
    1d54:	90 0c       	add	r9, r0
    1d56:	11 24       	eor	r1, r1
    1d58:	20 e0       	ldi	r18, 0x00	; 0
    1d5a:	30 e0       	ldi	r19, 0x00	; 0
    1d5c:	44 e3       	ldi	r20, 0x34	; 52
    1d5e:	53 e4       	ldi	r21, 0x43	; 67
    1d60:	6a 85       	ldd	r22, Y+10	; 0x0a
    1d62:	7b 85       	ldd	r23, Y+11	; 0x0b
    1d64:	8c 85       	ldd	r24, Y+12	; 0x0c
    1d66:	9d 85       	ldd	r25, Y+13	; 0x0d
    1d68:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    1d6c:	2b ed       	ldi	r18, 0xDB	; 219
    1d6e:	3f e0       	ldi	r19, 0x0F	; 15
    1d70:	49 e4       	ldi	r20, 0x49	; 73
    1d72:	50 e4       	ldi	r21, 0x40	; 64
    1d74:	0e 94 01 31 	call	0x6202	; 0x6202 <__divsf3>
    1d78:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
    1d7c:	6a 87       	std	Y+10, r22	; 0x0a
    1d7e:	7b 87       	std	Y+11, r23	; 0x0b
    1d80:	8c 87       	std	Y+12, r24	; 0x0c
    1d82:	9d 87       	std	Y+13, r25	; 0x0d
    1d84:	c3 01       	movw	r24, r6
    1d86:	6a e0       	ldi	r22, 0x0A	; 10
    1d88:	70 e0       	ldi	r23, 0x00	; 0
    1d8a:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__divmodhi4>
    1d8e:	fb 01       	movw	r30, r22
    1d90:	c5 01       	movw	r24, r10
    1d92:	6a e0       	ldi	r22, 0x0A	; 10
    1d94:	70 e0       	ldi	r23, 0x00	; 0
    1d96:	0e 94 12 37 	call	0x6e24	; 0x6e24 <__divmodhi4>
    1d9a:	cb 01       	movw	r24, r22
    1d9c:	af 84       	ldd	r10, Y+15	; 0x0f
    1d9e:	0e 85       	ldd	r16, Y+14	; 0x0e
    1da0:	94 01       	movw	r18, r8
    1da2:	4a 85       	ldd	r20, Y+10	; 0x0a
    1da4:	5b 85       	ldd	r21, Y+11	; 0x0b
    1da6:	bf 01       	movw	r22, r30
    1da8:	0e 94 a1 20 	call	0x4142	; 0x4142 <send_update>
    1dac:	af e1       	ldi	r26, 0x1F	; 31
            
            
            // Low level anti collision
            uint8_t objectX;
            if ((servoStep*servoResolution) <= 30) objectX = forwardSensor;// * cos(servoStep*5);
    1dae:	8a 16       	cp	r8, r26
    1db0:	91 04       	cpc	r9, r1
    1db2:	34 f0       	brlt	.+12     	; 0x1dc0 <vMainSensorTowerTask+0x1c8>
    1db4:	bc e3       	ldi	r27, 0x3C	; 60
            else if((servoStep*servoResolution) >= 60) objectX = rightSensor;// * cos(270 + servoStep*5);
    1db6:	8b 16       	cp	r8, r27
    1db8:	91 04       	cpc	r9, r1
    1dba:	c4 f0       	brlt	.+48     	; 0x1dec <vMainSensorTowerTask+0x1f4>
    1dbc:	af 84       	ldd	r10, Y+15	; 0x0f
    1dbe:	ae 86       	std	Y+14, r10	; 0x0e
    1dc0:	8e 85       	ldd	r24, Y+14	; 0x0e
            else objectX = 0;
            

			
            if ((objectX > 0) && (objectX < 20)){
    1dc2:	81 50       	subi	r24, 0x01	; 1
    1dc4:	83 31       	cpi	r24, 0x13	; 19
    1dc6:	90 f4       	brcc	.+36     	; 0x1dec <vMainSensorTowerTask+0x1f4>
    1dc8:	1c 82       	std	Y+4, r1	; 0x04
                // Stop controller
                struct sPolar Setpoint = {0, 0};
    1dca:	1d 82       	std	Y+5, r1	; 0x05
    1dcc:	1e 82       	std	Y+6, r1	; 0x06
    1dce:	1f 82       	std	Y+7, r1	; 0x07
    1dd0:	19 86       	std	Y+9, r1	; 0x09
    1dd2:	18 86       	std	Y+8, r1	; 0x08
    1dd4:	20 e0       	ldi	r18, 0x00	; 0
                xQueueSend(poseControllerQ, &Setpoint, 100);
    1dd6:	44 e6       	ldi	r20, 0x64	; 100
    1dd8:	50 e0       	ldi	r21, 0x00	; 0
    1dda:	be 01       	movw	r22, r28
    1ddc:	6c 5f       	subi	r22, 0xFC	; 252
    1dde:	7f 4f       	sbci	r23, 0xFF	; 255
    1de0:	80 91 c9 19 	lds	r24, 0x19C9	; 0x8019c9 <poseControllerQ>
    1de4:	90 91 ca 19 	lds	r25, 0x19CA	; 0x8019ca <poseControllerQ+0x1>
    1de8:	0e 94 08 1b 	call	0x3610	; 0x3610 <xQueueGenericSend>
    1dec:	8b e5       	ldi	r24, 0x5B	; 91
				
				
            }
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
    1dee:	88 16       	cp	r8, r24
    1df0:	91 04       	cpc	r9, r1
    1df2:	9c f4       	brge	.+38     	; 0x1e1a <vMainSensorTowerTask+0x222>
    1df4:	94 e0       	ldi	r25, 0x04	; 4
    1df6:	d9 12       	cpse	r13, r25
    1df8:	10 c0       	rjmp	.+32     	; 0x1e1a <vMainSensorTowerTask+0x222>
    1dfa:	89 81       	ldd	r24, Y+1	; 0x01
    1dfc:	83 30       	cpi	r24, 0x03	; 3
    1dfe:	08 f0       	brcs	.+2      	; 0x1e02 <vMainSensorTowerTask+0x20a>
    1e00:	40 c0       	rjmp	.+128    	; 0x1e82 <vMainSensorTowerTask+0x28a>
    1e02:	1f 5f       	subi	r17, 0xFF	; 255
                servoStep++;
    1e04:	14 9d       	mul	r17, r4
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1e06:	40 01       	movw	r8, r0
    1e08:	15 9d       	mul	r17, r5
    1e0a:	90 0c       	add	r9, r0
    1e0c:	11 24       	eor	r1, r1
    1e0e:	aa e5       	ldi	r26, 0x5A	; 90
    1e10:	8a 16       	cp	r8, r26
    1e12:	91 04       	cpc	r9, r1
    1e14:	0c f0       	brlt	.+2      	; 0x1e18 <vMainSensorTowerTask+0x220>
    1e16:	06 cf       	rjmp	.-500    	; 0x1c24 <vMainSensorTowerTask+0x2c>
    1e18:	15 c0       	rjmp	.+42     	; 0x1e44 <vMainSensorTowerTask+0x24c>
    1e1a:	18 14       	cp	r1, r8
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1e1c:	19 04       	cpc	r1, r9
    1e1e:	34 f5       	brge	.+76     	; 0x1e6c <vMainSensorTowerTask+0x274>
    1e20:	b3 e0       	ldi	r27, 0x03	; 3
    1e22:	db 12       	cpse	r13, r27
    1e24:	28 c0       	rjmp	.+80     	; 0x1e76 <vMainSensorTowerTask+0x27e>
    1e26:	89 81       	ldd	r24, Y+1	; 0x01
    1e28:	83 30       	cpi	r24, 0x03	; 3
    1e2a:	08 f0       	brcs	.+2      	; 0x1e2e <vMainSensorTowerTask+0x236>
    1e2c:	09 cf       	rjmp	.-494    	; 0x1c40 <vMainSensorTowerTask+0x48>
    1e2e:	11 50       	subi	r17, 0x01	; 1
                servoStep --;
    1e30:	14 9d       	mul	r17, r4
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1e32:	40 01       	movw	r8, r0
    1e34:	15 9d       	mul	r17, r5
    1e36:	90 0c       	add	r9, r0
    1e38:	11 24       	eor	r1, r1
    1e3a:	04 c0       	rjmp	.+8      	; 0x1e44 <vMainSensorTowerTask+0x24c>
    1e3c:	84 e0       	ldi	r24, 0x04	; 4
    1e3e:	d8 16       	cp	r13, r24
    1e40:	09 f4       	brne	.+2      	; 0x1e44 <vMainSensorTowerTask+0x24c>
    1e42:	f5 ce       	rjmp	.-534    	; 0x1c2e <vMainSensorTowerTask+0x36>
    1e44:	18 14       	cp	r1, r8
                rotationDirection = moveClockwise;
            }
            else if ((servoStep*servoResolution <= 0) && (rotationDirection == moveClockwise)){
    1e46:	19 04       	cpc	r1, r9
    1e48:	0c f4       	brge	.+2      	; 0x1e4c <vMainSensorTowerTask+0x254>
    1e4a:	fa ce       	rjmp	.-524    	; 0x1c40 <vMainSensorTowerTask+0x48>
    1e4c:	93 e0       	ldi	r25, 0x03	; 3
    1e4e:	d9 12       	cpse	r13, r25
    1e50:	f7 ce       	rjmp	.-530    	; 0x1c40 <vMainSensorTowerTask+0x48>
    1e52:	d2 2c       	mov	r13, r2
                rotationDirection = moveCounterClockwise;
    1e54:	f5 ce       	rjmp	.-534    	; 0x1c40 <vMainSensorTowerTask+0x48>
    1e56:	80 e0       	ldi	r24, 0x00	; 0
            }    
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
    1e58:	0e 94 68 21 	call	0x42d0	; 0x42d0 <vServo_setAngle>
    1e5c:	84 e6       	ldi	r24, 0x64	; 100
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
            vTaskDelay(100/portTICK_PERIOD_MS);
    1e5e:	90 e0       	ldi	r25, 0x00	; 0
    1e60:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vTaskDelay>
    1e64:	f1 2c       	mov	r15, r1
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
    1e66:	10 e0       	ldi	r17, 0x00	; 0
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
    1e68:	d2 2c       	mov	r13, r2
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1e6a:	ea ce       	rjmp	.-556    	; 0x1c40 <vMainSensorTowerTask+0x48>
    1e6c:	aa e5       	ldi	r26, 0x5A	; 90
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1e6e:	8a 16       	cp	r8, r26
    1e70:	91 04       	cpc	r9, r1
    1e72:	64 f3       	brlt	.-40     	; 0x1e4c <vMainSensorTowerTask+0x254>
    1e74:	0a c0       	rjmp	.+20     	; 0x1e8a <vMainSensorTowerTask+0x292>
    1e76:	ba e5       	ldi	r27, 0x5A	; 90
    1e78:	8b 16       	cp	r8, r27
    1e7a:	91 04       	cpc	r9, r1
    1e7c:	0c f4       	brge	.+2      	; 0x1e80 <vMainSensorTowerTask+0x288>
    1e7e:	e0 ce       	rjmp	.-576    	; 0x1c40 <vMainSensorTowerTask+0x48>
    1e80:	dd cf       	rjmp	.-70     	; 0x1e3c <vMainSensorTowerTask+0x244>
    1e82:	18 14       	cp	r1, r8
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1e84:	19 04       	cpc	r1, r9
    1e86:	bc f3       	brlt	.-18     	; 0x1e76 <vMainSensorTowerTask+0x27e>
    1e88:	f1 cf       	rjmp	.-30     	; 0x1e6c <vMainSensorTowerTask+0x274>
    1e8a:	84 e0       	ldi	r24, 0x04	; 4
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1e8c:	d8 16       	cp	r13, r24
    1e8e:	09 f4       	brne	.+2      	; 0x1e92 <vMainSensorTowerTask+0x29a>
    1e90:	d3 ce       	rjmp	.-602    	; 0x1c38 <vMainSensorTowerTask+0x40>
    1e92:	dc cf       	rjmp	.-72     	; 0x1e4c <vMainSensorTowerTask+0x254>

00001e94 <vMainPoseControllerTask>:
    1e94:	cf 93       	push	r28
        }
    }// While end
}

/*  Calculates new settings for the movement task */
void vMainPoseControllerTask( void *pvParameters ){
    1e96:	df 93       	push	r29
    1e98:	cd b7       	in	r28, 0x3d	; 61
    1e9a:	de b7       	in	r29, 0x3e	; 62
    1e9c:	ab 97       	sbiw	r28, 0x2b	; 43
    1e9e:	0f b6       	in	r0, 0x3f	; 63
    1ea0:	f8 94       	cli
    1ea2:	de bf       	out	0x3e, r29	; 62
    1ea4:	0f be       	out	0x3f, r0	; 63
    1ea6:	cd bf       	out	0x3d, r28	; 61
    #ifdef DEBUG
        printf("PoseController OK\n");
        uint8_t tellar = 0;
    #endif
    /* Task init */    
    struct sPolar Setpoint = {0}; // Updates from server
    1ea8:	fe 01       	movw	r30, r28
    1eaa:	31 96       	adiw	r30, 0x01	; 1
    1eac:	86 e0       	ldi	r24, 0x06	; 6
    1eae:	df 01       	movw	r26, r30
    1eb0:	1d 92       	st	X+, r1
    1eb2:	8a 95       	dec	r24
    1eb4:	e9 f7       	brne	.-6      	; 0x1eb0 <vMainPoseControllerTask+0x1c>
    struct sCartesian Error = {0}; // Error values
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
	float radiusEpsilon = 15; //[mm]The acceptable radius from goal for completion
	uint8_t lastMovement = 0;
    1eb6:	1f 82       	std	Y+7, r1	; 0x07
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
	
	
	int16_t leftWheelTicks = 0;
    1eb8:	19 86       	std	Y+9, r1	; 0x09
    1eba:	18 86       	std	Y+8, r1	; 0x08
	int16_t rightWheelTicks = 0;
    1ebc:	1b 86       	std	Y+11, r1	; 0x0b
    1ebe:	1a 86       	std	Y+10, r1	; 0x0a
	
	uint8_t leftEncoderVal = 0;
	uint8_t rightEncoderVal = 0;
	
	uint8_t gLeftWheelDirection = 0;
    1ec0:	1c 86       	std	Y+12, r1	; 0x0c
	uint8_t gRightWheelDirection = 0;
    1ec2:	1d 86       	std	Y+13, r1	; 0x0d
	
	uint8_t idleSendt = FALSE;
    1ec4:	1a 8e       	std	Y+26, r1	; 0x1a
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
    1ec6:	b1 e0       	ldi	r27, 0x01	; 1
    1ec8:	bb a7       	std	Y+43, r27	; 0x2b
	float yTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
    1eca:	1f a2       	std	Y+39, r1	; 0x27
    1ecc:	18 a6       	std	Y+40, r1	; 0x28
    1ece:	19 a6       	std	Y+41, r1	; 0x29
    1ed0:	1a a6       	std	Y+42, r1	; 0x2a
	float xTargt = 0;
	float yTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
    1ed2:	1b a2       	std	Y+35, r1	; 0x23
    1ed4:	1c a2       	std	Y+36, r1	; 0x24
    1ed6:	1d a2       	std	Y+37, r1	; 0x25
    1ed8:	1e a2       	std	Y+38, r1	; 0x26
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
	float yTargt = 0;
    1eda:	1f 8e       	std	Y+31, r1	; 0x1f
    1edc:	18 a2       	std	Y+32, r1	; 0x20
    1ede:	19 a2       	std	Y+33, r1	; 0x21
    1ee0:	1a a2       	std	Y+34, r1	; 0x22
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
    1ee2:	1b 8e       	std	Y+27, r1	; 0x1b
    1ee4:	1c 8e       	std	Y+28, r1	; 0x1c
    1ee6:	1d 8e       	std	Y+29, r1	; 0x1d
    1ee8:	1e 8e       	std	Y+30, r1	; 0x1e
	
	
      
	while(1){
		// Checking if server is ready
		if (gHandshook){
    1eea:	80 91 c2 19 	lds	r24, 0x19C2	; 0x8019c2 <gHandshook>
    1eee:	88 23       	and	r24, r24
    1ef0:	e1 f3       	breq	.-8      	; 0x1eea <vMainPoseControllerTask+0x56>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1ef2:	f8 94       	cli
			
			
			
			ATOMIC_BLOCK(ATOMIC_FORCEON){
				leftEncoderVal = gISR_leftWheelTicks;
    1ef4:	40 91 c3 19 	lds	r20, 0x19C3	; 0x8019c3 <gISR_leftWheelTicks>
				gISR_leftWheelTicks = 0;
    1ef8:	10 92 c3 19 	sts	0x19C3, r1	; 0x8019c3 <gISR_leftWheelTicks>
				rightEncoderVal = gISR_rightWheelTicks;
    1efc:	10 91 c4 19 	lds	r17, 0x19C4	; 0x8019c4 <gISR_rightWheelTicks>
				gISR_rightWheelTicks = 0;
    1f00:	10 92 c4 19 	sts	0x19C4, r1	; 0x8019c4 <gISR_rightWheelTicks>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1f04:	78 94       	sei
			
			
			
			
			
			vMotorEncoderLeftTickFromISR(gLeftWheelDirection, &leftWheelTicks, leftEncoderVal);
    1f06:	be 01       	movw	r22, r28
    1f08:	68 5f       	subi	r22, 0xF8	; 248
    1f0a:	7f 4f       	sbci	r23, 0xFF	; 255
    1f0c:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f0e:	10 d7       	rcall	.+3616   	; 0x2d30 <vMotorEncoderLeftTickFromISR>
			vMotorEncoderRightTickFromISR(gRightWheelDirection, &rightWheelTicks, rightEncoderVal);
    1f10:	41 2f       	mov	r20, r17
    1f12:	be 01       	movw	r22, r28
    1f14:	66 5f       	subi	r22, 0xF6	; 246
    1f16:	7f 4f       	sbci	r23, 0xFF	; 255
    1f18:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f1a:	21 d7       	rcall	.+3650   	; 0x2d5e <vMotorEncoderRightTickFromISR>
			
			xSemaphoreTake(xTickMutex,1 / portTICK_PERIOD_MS);
    1f1c:	20 e0       	ldi	r18, 0x00	; 0
    1f1e:	41 e0       	ldi	r20, 0x01	; 1
    1f20:	50 e0       	ldi	r21, 0x00	; 0
    1f22:	60 e0       	ldi	r22, 0x00	; 0
    1f24:	70 e0       	ldi	r23, 0x00	; 0
    1f26:	80 91 2f 1b 	lds	r24, 0x1B2F	; 0x801b2f <xTickMutex>
    1f2a:	90 91 30 1b 	lds	r25, 0x1B30	; 0x801b30 <xTickMutex+0x1>
    1f2e:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
			gLeftWheelTicks = leftWheelTicks;
    1f32:	88 85       	ldd	r24, Y+8	; 0x08
    1f34:	99 85       	ldd	r25, Y+9	; 0x09
    1f36:	90 93 b6 19 	sts	0x19B6, r25	; 0x8019b6 <gLeftWheelTicks+0x1>
    1f3a:	80 93 b5 19 	sts	0x19B5, r24	; 0x8019b5 <gLeftWheelTicks>
			gRightWheelTicks = rightWheelTicks;
    1f3e:	8a 85       	ldd	r24, Y+10	; 0x0a
    1f40:	9b 85       	ldd	r25, Y+11	; 0x0b
    1f42:	90 93 b8 19 	sts	0x19B8, r25	; 0x8019b8 <gRightWheelTicks+0x1>
    1f46:	80 93 b7 19 	sts	0x19B7, r24	; 0x8019b7 <gRightWheelTicks>
			xSemaphoreGive(xTickMutex);
    1f4a:	60 e0       	ldi	r22, 0x00	; 0
    1f4c:	70 e0       	ldi	r23, 0x00	; 0
    1f4e:	80 91 2f 1b 	lds	r24, 0x1B2F	; 0x801b2f <xTickMutex>
    1f52:	90 91 30 1b 	lds	r25, 0x1B30	; 0x801b30 <xTickMutex+0x1>
    1f56:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
			
			
			
			
			
			if (xSemaphoreTake(xControllerBSem, portMAX_DELAY) == pdTRUE){    // Wait for synchronization from estimator
    1f5a:	20 e0       	ldi	r18, 0x00	; 0
    1f5c:	4f ef       	ldi	r20, 0xFF	; 255
    1f5e:	5f ef       	ldi	r21, 0xFF	; 255
    1f60:	60 e0       	ldi	r22, 0x00	; 0
    1f62:	70 e0       	ldi	r23, 0x00	; 0
    1f64:	80 91 2d 1b 	lds	r24, 0x1B2D	; 0x801b2d <xControllerBSem>
    1f68:	90 91 2e 1b 	lds	r25, 0x1B2E	; 0x801b2e <xControllerBSem+0x1>
    1f6c:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
    1f70:	81 30       	cpi	r24, 0x01	; 1
    1f72:	09 f0       	breq	.+2      	; 0x1f76 <vMainPoseControllerTask+0xe2>
    1f74:	ba cf       	rjmp	.-140    	; 0x1eea <vMainPoseControllerTask+0x56>
				// Get robot pose
				xSemaphoreTake(xPoseMutex,portMAX_DELAY);
    1f76:	20 e0       	ldi	r18, 0x00	; 0
    1f78:	4f ef       	ldi	r20, 0xFF	; 255
    1f7a:	5f ef       	ldi	r21, 0xFF	; 255
    1f7c:	60 e0       	ldi	r22, 0x00	; 0
    1f7e:	70 e0       	ldi	r23, 0x00	; 0
    1f80:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xPoseMutex>
    1f84:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xPoseMutex+0x1>
    1f88:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
					thetahat = gTheta_hat;
    1f8c:	40 90 bd 19 	lds	r4, 0x19BD	; 0x8019bd <gTheta_hat>
    1f90:	50 90 be 19 	lds	r5, 0x19BE	; 0x8019be <gTheta_hat+0x1>
    1f94:	60 90 bf 19 	lds	r6, 0x19BF	; 0x8019bf <gTheta_hat+0x2>
    1f98:	70 90 c0 19 	lds	r7, 0x19C0	; 0x8019c0 <gTheta_hat+0x3>
					xhat = gX_hat;
    1f9c:	00 91 bb 19 	lds	r16, 0x19BB	; 0x8019bb <gX_hat>
    1fa0:	10 91 bc 19 	lds	r17, 0x19BC	; 0x8019bc <gX_hat+0x1>
					yhat = gY_hat;
    1fa4:	20 90 b9 19 	lds	r2, 0x19B9	; 0x8019b9 <gY_hat>
    1fa8:	30 90 ba 19 	lds	r3, 0x19BA	; 0x8019ba <gY_hat+0x1>
				xSemaphoreGive(xPoseMutex);
    1fac:	60 e0       	ldi	r22, 0x00	; 0
    1fae:	70 e0       	ldi	r23, 0x00	; 0
    1fb0:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xPoseMutex>
    1fb4:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xPoseMutex+0x1>
    1fb8:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
				
				// Check if a new update is received
				if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
    1fbc:	20 e0       	ldi	r18, 0x00	; 0
    1fbe:	40 e0       	ldi	r20, 0x00	; 0
    1fc0:	50 e0       	ldi	r21, 0x00	; 0
    1fc2:	be 01       	movw	r22, r28
    1fc4:	6f 5f       	subi	r22, 0xFF	; 255
    1fc6:	7f 4f       	sbci	r23, 0xFF	; 255
    1fc8:	80 91 c9 19 	lds	r24, 0x19C9	; 0x8019c9 <poseControllerQ>
    1fcc:	90 91 ca 19 	lds	r25, 0x19CA	; 0x8019ca <poseControllerQ+0x1>
    1fd0:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
    1fd4:	81 30       	cpi	r24, 0x01	; 1
    1fd6:	09 f0       	breq	.+2      	; 0x1fda <vMainPoseControllerTask+0x146>
    1fd8:	73 c0       	rjmp	.+230    	; 0x20c0 <vMainPoseControllerTask+0x22c>
					xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
    1fda:	20 e0       	ldi	r18, 0x00	; 0
    1fdc:	44 e1       	ldi	r20, 0x14	; 20
    1fde:	50 e0       	ldi	r21, 0x00	; 0
    1fe0:	be 01       	movw	r22, r28
    1fe2:	6f 5f       	subi	r22, 0xFF	; 255
    1fe4:	7f 4f       	sbci	r23, 0xFF	; 255
    1fe6:	80 91 c9 19 	lds	r24, 0x19C9	; 0x8019c9 <poseControllerQ>
    1fea:	90 91 ca 19 	lds	r25, 0x19CA	; 0x8019ca <poseControllerQ+0x1>
    1fee:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
					Setpoint.distance = Setpoint.distance*10; //Distance is received in cm, convert to mm for continuity
    1ff2:	8d 81       	ldd	r24, Y+5	; 0x05
    1ff4:	9e 81       	ldd	r25, Y+6	; 0x06
    1ff6:	bc 01       	movw	r22, r24
    1ff8:	66 0f       	add	r22, r22
    1ffa:	77 1f       	adc	r23, r23
    1ffc:	88 0f       	add	r24, r24
    1ffe:	99 1f       	adc	r25, r25
    2000:	88 0f       	add	r24, r24
    2002:	99 1f       	adc	r25, r25
    2004:	88 0f       	add	r24, r24
    2006:	99 1f       	adc	r25, r25
    2008:	68 0f       	add	r22, r24
    200a:	79 1f       	adc	r23, r25
    200c:	7e 83       	std	Y+6, r23	; 0x06
    200e:	6d 83       	std	Y+5, r22	; 0x05
					
					
					
					xTargt = xhat + Setpoint.distance*cos(Setpoint.heading + thetahat);
    2010:	07 2e       	mov	r0, r23
    2012:	00 0c       	add	r0, r0
    2014:	88 0b       	sbc	r24, r24
    2016:	99 0b       	sbc	r25, r25
    2018:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    201c:	6a 8b       	std	Y+18, r22	; 0x12
    201e:	7b 8b       	std	Y+19, r23	; 0x13
    2020:	8c 8b       	std	Y+20, r24	; 0x14
    2022:	9d 8b       	std	Y+21, r25	; 0x15
    2024:	29 81       	ldd	r18, Y+1	; 0x01
    2026:	3a 81       	ldd	r19, Y+2	; 0x02
    2028:	4b 81       	ldd	r20, Y+3	; 0x03
    202a:	5c 81       	ldd	r21, Y+4	; 0x04
    202c:	c3 01       	movw	r24, r6
    202e:	b2 01       	movw	r22, r4
    2030:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    2034:	6b 01       	movw	r12, r22
    2036:	7c 01       	movw	r14, r24
    2038:	0e 94 fe 30 	call	0x61fc	; 0x61fc <cos>
    203c:	6e 8b       	std	Y+22, r22	; 0x16
    203e:	7f 8b       	std	Y+23, r23	; 0x17
    2040:	88 8f       	std	Y+24, r24	; 0x18
    2042:	99 8f       	std	Y+25, r25	; 0x19
    2044:	b8 01       	movw	r22, r16
    2046:	01 2e       	mov	r0, r17
    2048:	00 0c       	add	r0, r0
    204a:	88 0b       	sbc	r24, r24
    204c:	99 0b       	sbc	r25, r25
    204e:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    2052:	4b 01       	movw	r8, r22
    2054:	5c 01       	movw	r10, r24
    2056:	2e 89       	ldd	r18, Y+22	; 0x16
    2058:	3f 89       	ldd	r19, Y+23	; 0x17
    205a:	48 8d       	ldd	r20, Y+24	; 0x18
    205c:	59 8d       	ldd	r21, Y+25	; 0x19
    205e:	6a 89       	ldd	r22, Y+18	; 0x12
    2060:	7b 89       	ldd	r23, Y+19	; 0x13
    2062:	8c 89       	ldd	r24, Y+20	; 0x14
    2064:	9d 89       	ldd	r25, Y+21	; 0x15
    2066:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    206a:	9b 01       	movw	r18, r22
    206c:	ac 01       	movw	r20, r24
    206e:	c5 01       	movw	r24, r10
    2070:	b4 01       	movw	r22, r8
    2072:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    2076:	6b 8f       	std	Y+27, r22	; 0x1b
    2078:	7c 8f       	std	Y+28, r23	; 0x1c
    207a:	8d 8f       	std	Y+29, r24	; 0x1d
    207c:	9e 8f       	std	Y+30, r25	; 0x1e
					yTargt = yhat + Setpoint.distance*sin(Setpoint.heading + thetahat);
    207e:	c7 01       	movw	r24, r14
    2080:	b6 01       	movw	r22, r12
    2082:	0e 94 18 33 	call	0x6630	; 0x6630 <sin>
    2086:	4b 01       	movw	r8, r22
    2088:	5c 01       	movw	r10, r24
    208a:	b1 01       	movw	r22, r2
    208c:	03 2c       	mov	r0, r3
    208e:	00 0c       	add	r0, r0
    2090:	88 0b       	sbc	r24, r24
    2092:	99 0b       	sbc	r25, r25
    2094:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    2098:	6b 01       	movw	r12, r22
    209a:	7c 01       	movw	r14, r24
    209c:	a5 01       	movw	r20, r10
    209e:	94 01       	movw	r18, r8
    20a0:	6a 89       	ldd	r22, Y+18	; 0x12
    20a2:	7b 89       	ldd	r23, Y+19	; 0x13
    20a4:	8c 89       	ldd	r24, Y+20	; 0x14
    20a6:	9d 89       	ldd	r25, Y+21	; 0x15
    20a8:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    20ac:	9b 01       	movw	r18, r22
    20ae:	ac 01       	movw	r20, r24
    20b0:	c7 01       	movw	r24, r14
    20b2:	b6 01       	movw	r22, r12
    20b4:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    20b8:	6f 8f       	std	Y+31, r22	; 0x1f
    20ba:	78 a3       	std	Y+32, r23	; 0x20
    20bc:	89 a3       	std	Y+33, r24	; 0x21
    20be:	9a a3       	std	Y+34, r25	; 0x22
					
					
				
				}
				
				distance = (float)sqrt((xTargt-xhat)*(xTargt-xhat) + (yTargt-yhat)*(yTargt-yhat));
    20c0:	b8 01       	movw	r22, r16
    20c2:	11 0f       	add	r17, r17
    20c4:	88 0b       	sbc	r24, r24
    20c6:	99 0b       	sbc	r25, r25
    20c8:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    20cc:	9b 01       	movw	r18, r22
    20ce:	ac 01       	movw	r20, r24
    20d0:	6b 8d       	ldd	r22, Y+27	; 0x1b
    20d2:	7c 8d       	ldd	r23, Y+28	; 0x1c
    20d4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    20d6:	9e 8d       	ldd	r25, Y+30	; 0x1e
    20d8:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    20dc:	6a 8b       	std	Y+18, r22	; 0x12
    20de:	7b 8b       	std	Y+19, r23	; 0x13
    20e0:	8c 8b       	std	Y+20, r24	; 0x14
    20e2:	9d 8b       	std	Y+21, r25	; 0x15
    20e4:	b1 01       	movw	r22, r2
    20e6:	33 0c       	add	r3, r3
    20e8:	88 0b       	sbc	r24, r24
    20ea:	99 0b       	sbc	r25, r25
    20ec:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    20f0:	9b 01       	movw	r18, r22
    20f2:	ac 01       	movw	r20, r24
    20f4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    20f6:	78 a1       	ldd	r23, Y+32	; 0x20
    20f8:	89 a1       	ldd	r24, Y+33	; 0x21
    20fa:	9a a1       	ldd	r25, Y+34	; 0x22
    20fc:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    2100:	6b 01       	movw	r12, r22
    2102:	7c 01       	movw	r14, r24
    2104:	2a 89       	ldd	r18, Y+18	; 0x12
    2106:	3b 89       	ldd	r19, Y+19	; 0x13
    2108:	4c 89       	ldd	r20, Y+20	; 0x14
    210a:	5d 89       	ldd	r21, Y+21	; 0x15
    210c:	ca 01       	movw	r24, r20
    210e:	b9 01       	movw	r22, r18
    2110:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2114:	4b 01       	movw	r8, r22
    2116:	5c 01       	movw	r10, r24
    2118:	a7 01       	movw	r20, r14
    211a:	96 01       	movw	r18, r12
    211c:	c7 01       	movw	r24, r14
    211e:	b6 01       	movw	r22, r12
    2120:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2124:	6e 8b       	std	Y+22, r22	; 0x16
    2126:	7f 8b       	std	Y+23, r23	; 0x17
    2128:	88 8f       	std	Y+24, r24	; 0x18
    212a:	99 8f       	std	Y+25, r25	; 0x19
    212c:	2e 89       	ldd	r18, Y+22	; 0x16
    212e:	3f 89       	ldd	r19, Y+23	; 0x17
    2130:	48 8d       	ldd	r20, Y+24	; 0x18
    2132:	59 8d       	ldd	r21, Y+25	; 0x19
    2134:	c5 01       	movw	r24, r10
    2136:	b4 01       	movw	r22, r8
    2138:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    213c:	0e 94 22 33 	call	0x6644	; 0x6644 <sqrt>
    2140:	4b 01       	movw	r8, r22
    2142:	5c 01       	movw	r10, r24
				
				//Simple speed controller as the robot nears the target
				if (distance < speedDecreaseThreshold){
    2144:	20 e0       	ldi	r18, 0x00	; 0
    2146:	30 e0       	ldi	r19, 0x00	; 0
    2148:	4a ef       	ldi	r20, 0xFA	; 250
    214a:	53 e4       	ldi	r21, 0x43	; 67
    214c:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__cmpsf2>
    2150:	88 23       	and	r24, r24
    2152:	c4 f4       	brge	.+48     	; 0x2184 <vMainPoseControllerTask+0x2f0>
					currentDriveActuation = (maxDriveActuation - 0.32*maxDriveActuation)*distance/speedDecreaseThreshold + 0.32*maxDriveActuation; //Reverse proportional + a constant so it reaches. 
    2154:	20 e0       	ldi	r18, 0x00	; 0
    2156:	30 e0       	ldi	r19, 0x00	; 0
    2158:	48 e8       	ldi	r20, 0x88	; 136
    215a:	52 e4       	ldi	r21, 0x42	; 66
    215c:	c5 01       	movw	r24, r10
    215e:	b4 01       	movw	r22, r8
    2160:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2164:	20 e0       	ldi	r18, 0x00	; 0
    2166:	30 e0       	ldi	r19, 0x00	; 0
    2168:	4a ef       	ldi	r20, 0xFA	; 250
    216a:	53 e4       	ldi	r21, 0x43	; 67
    216c:	0e 94 01 31 	call	0x6202	; 0x6202 <__divsf3>
    2170:	20 e0       	ldi	r18, 0x00	; 0
    2172:	30 e0       	ldi	r19, 0x00	; 0
    2174:	40 e0       	ldi	r20, 0x00	; 0
    2176:	52 e4       	ldi	r21, 0x42	; 66
    2178:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    217c:	0e 94 6e 31 	call	0x62dc	; 0x62dc <__fixunssfsi>
    2180:	06 2f       	mov	r16, r22
    2182:	01 c0       	rjmp	.+2      	; 0x2186 <vMainPoseControllerTask+0x2f2>
				}else{
					currentDriveActuation = maxDriveActuation;
    2184:	04 e6       	ldi	r16, 0x64	; 100
				}
				
				
				
				if(distance > radiusEpsilon){//Not close enough to target
    2186:	20 e0       	ldi	r18, 0x00	; 0
    2188:	30 e0       	ldi	r19, 0x00	; 0
    218a:	40 e7       	ldi	r20, 0x70	; 112
    218c:	51 e4       	ldi	r21, 0x41	; 65
    218e:	c5 01       	movw	r24, r10
    2190:	b4 01       	movw	r22, r8
    2192:	0e 94 aa 32 	call	0x6554	; 0x6554 <__gesf2>
    2196:	18 16       	cp	r1, r24
    2198:	0c f0       	brlt	.+2      	; 0x219c <vMainPoseControllerTask+0x308>
    219a:	4e c1       	rjmp	.+668    	; 0x2438 <__stack+0x239>
					
					idleSendt = FALSE;
					
					float xdiff = xTargt - xhat;
					float ydiff = yTargt - yhat;
					float thetaTargt = atan2(ydiff,xdiff); //atan() returns radians
    219c:	2a 89       	ldd	r18, Y+18	; 0x12
    219e:	3b 89       	ldd	r19, Y+19	; 0x13
    21a0:	4c 89       	ldd	r20, Y+20	; 0x14
    21a2:	5d 89       	ldd	r21, Y+21	; 0x15
    21a4:	c7 01       	movw	r24, r14
    21a6:	b6 01       	movw	r22, r12
    21a8:	0e 94 a7 30 	call	0x614e	; 0x614e <atan2>
					float thetaDiff = thetaTargt-thetahat; //Might be outside pi to -pi degrees
    21ac:	a3 01       	movw	r20, r6
    21ae:	92 01       	movw	r18, r4
    21b0:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    21b4:	6e 87       	std	Y+14, r22	; 0x0e
    21b6:	7f 87       	std	Y+15, r23	; 0x0f
    21b8:	88 8b       	std	Y+16, r24	; 0x10
    21ba:	99 8b       	std	Y+17, r25	; 0x11
					vFunc_Inf2pi(&thetaDiff);
    21bc:	ce 01       	movw	r24, r28
    21be:	0e 96       	adiw	r24, 0x0e	; 14
    21c0:	0e 94 1a 08 	call	0x1034	; 0x1034 <vFunc_Inf2pi>
					
					
					
					//Hysteresis mechanics
					if (fabs(thetaDiff) > rotateThreshold){
    21c4:	4e 84       	ldd	r4, Y+14	; 0x0e
    21c6:	5f 84       	ldd	r5, Y+15	; 0x0f
    21c8:	68 88       	ldd	r6, Y+16	; 0x10
    21ca:	79 88       	ldd	r7, Y+17	; 0x11
    21cc:	53 01       	movw	r10, r6
    21ce:	42 01       	movw	r8, r4
    21d0:	e8 94       	clt
    21d2:	b7 f8       	bld	r11, 7
    21d4:	29 e1       	ldi	r18, 0x19	; 25
    21d6:	34 e0       	ldi	r19, 0x04	; 4
    21d8:	46 e0       	ldi	r20, 0x06	; 6
    21da:	5f e3       	ldi	r21, 0x3F	; 63
    21dc:	c5 01       	movw	r24, r10
    21de:	b4 01       	movw	r22, r8
    21e0:	0e 94 aa 32 	call	0x6554	; 0x6554 <__gesf2>
    21e4:	18 16       	cp	r1, r24
    21e6:	0c f4       	brge	.+2      	; 0x21ea <vMainPoseControllerTask+0x356>
    21e8:	ac c0       	rjmp	.+344    	; 0x2342 <__stack+0x143>
						doneTurning = FALSE;
						
					}else if (fabs(thetaDiff) < driveThreshold){
    21ea:	22 e7       	ldi	r18, 0x72	; 114
    21ec:	3a e8       	ldi	r19, 0x8A	; 138
    21ee:	4e e8       	ldi	r20, 0x8E	; 142
    21f0:	5c e3       	ldi	r21, 0x3C	; 60
    21f2:	c5 01       	movw	r24, r10
    21f4:	b4 01       	movw	r22, r8
    21f6:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__cmpsf2>
    21fa:	88 23       	and	r24, r24
    21fc:	24 f0       	brlt	.+8      	; 0x2206 <__stack+0x7>
					}
					
					int16_t LSpeed = 0;
					int16_t RSpeed = 0;
					
					if (doneTurning){//Start forward movement
    21fe:	8b a5       	ldd	r24, Y+43	; 0x2b
    2200:	81 11       	cpse	r24, r1
    2202:	03 c0       	rjmp	.+6      	; 0x220a <__stack+0xb>
    2204:	9e c0       	rjmp	.+316    	; 0x2342 <__stack+0x143>
					//Hysteresis mechanics
					if (fabs(thetaDiff) > rotateThreshold){
						doneTurning = FALSE;
						
					}else if (fabs(thetaDiff) < driveThreshold){
						doneTurning = TRUE;
    2206:	a1 e0       	ldi	r26, 0x01	; 1
    2208:	ab a7       	std	Y+43, r26	; 0x2b
					
					int16_t LSpeed = 0;
					int16_t RSpeed = 0;
					
					if (doneTurning){//Start forward movement
						if (thetaDiff >= 0){//Moving left
    220a:	20 e0       	ldi	r18, 0x00	; 0
    220c:	30 e0       	ldi	r19, 0x00	; 0
    220e:	a9 01       	movw	r20, r18
    2210:	c3 01       	movw	r24, r6
    2212:	b2 01       	movw	r22, r4
    2214:	0e 94 aa 32 	call	0x6554	; 0x6554 <__gesf2>
    2218:	88 23       	and	r24, r24
    221a:	bc f1       	brlt	.+110    	; 0x228a <__stack+0x8b>
							LSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*leftIntError; //Simple PI controller for theta 
    221c:	10 e0       	ldi	r17, 0x00	; 0
    221e:	b8 01       	movw	r22, r16
    2220:	01 2e       	mov	r0, r17
    2222:	00 0c       	add	r0, r0
    2224:	88 0b       	sbc	r24, r24
    2226:	99 0b       	sbc	r25, r25
    2228:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    222c:	6b 01       	movw	r12, r22
    222e:	7c 01       	movw	r14, r24
    2230:	20 e0       	ldi	r18, 0x00	; 0
    2232:	30 e0       	ldi	r19, 0x00	; 0
    2234:	46 e1       	ldi	r20, 0x16	; 22
    2236:	54 e4       	ldi	r21, 0x44	; 68
    2238:	c5 01       	movw	r24, r10
    223a:	b4 01       	movw	r22, r8
    223c:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2240:	9b 01       	movw	r18, r22
    2242:	ac 01       	movw	r20, r24
    2244:	c7 01       	movw	r24, r14
    2246:	b6 01       	movw	r22, r12
    2248:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    224c:	6b 01       	movw	r12, r22
    224e:	7c 01       	movw	r14, r24
    2250:	20 e0       	ldi	r18, 0x00	; 0
    2252:	30 e0       	ldi	r19, 0x00	; 0
    2254:	40 e2       	ldi	r20, 0x20	; 32
    2256:	51 e4       	ldi	r21, 0x41	; 65
    2258:	6b a1       	ldd	r22, Y+35	; 0x23
    225a:	7c a1       	ldd	r23, Y+36	; 0x24
    225c:	8d a1       	ldd	r24, Y+37	; 0x25
    225e:	9e a1       	ldd	r25, Y+38	; 0x26
    2260:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2264:	9b 01       	movw	r18, r22
    2266:	ac 01       	movw	r20, r24
    2268:	c7 01       	movw	r24, r14
    226a:	b6 01       	movw	r22, r12
    226c:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    2270:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
							
							//Saturation
							if (LSpeed > currentDriveActuation){
    2274:	06 17       	cp	r16, r22
    2276:	17 07       	cpc	r17, r23
    2278:	0c f4       	brge	.+2      	; 0x227c <__stack+0x7d>
    227a:	41 c0       	rjmp	.+130    	; 0x22fe <__stack+0xff>
    227c:	7b 01       	movw	r14, r22
    227e:	77 23       	and	r23, r23
    2280:	0c f0       	brlt	.+2      	; 0x2284 <__stack+0x85>
    2282:	40 c0       	rjmp	.+128    	; 0x2304 <__stack+0x105>
    2284:	e1 2c       	mov	r14, r1
    2286:	f1 2c       	mov	r15, r1
    2288:	3d c0       	rjmp	.+122    	; 0x2304 <__stack+0x105>
							
							RSpeed = currentDriveActuation;
							
							
						}else{//Moving right
							RSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*rightIntError; //Simple PI controller for theta
    228a:	e0 2e       	mov	r14, r16
    228c:	f1 2c       	mov	r15, r1
    228e:	b7 01       	movw	r22, r14
    2290:	0f 2c       	mov	r0, r15
    2292:	00 0c       	add	r0, r0
    2294:	88 0b       	sbc	r24, r24
    2296:	99 0b       	sbc	r25, r25
    2298:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    229c:	6a 8b       	std	Y+18, r22	; 0x12
    229e:	7b 8b       	std	Y+19, r23	; 0x13
    22a0:	8c 8b       	std	Y+20, r24	; 0x14
    22a2:	9d 8b       	std	Y+21, r25	; 0x15
    22a4:	20 e0       	ldi	r18, 0x00	; 0
    22a6:	30 e0       	ldi	r19, 0x00	; 0
    22a8:	46 e1       	ldi	r20, 0x16	; 22
    22aa:	54 e4       	ldi	r21, 0x44	; 68
    22ac:	c5 01       	movw	r24, r10
    22ae:	b4 01       	movw	r22, r8
    22b0:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    22b4:	9b 01       	movw	r18, r22
    22b6:	ac 01       	movw	r20, r24
    22b8:	6a 89       	ldd	r22, Y+18	; 0x12
    22ba:	7b 89       	ldd	r23, Y+19	; 0x13
    22bc:	8c 89       	ldd	r24, Y+20	; 0x14
    22be:	9d 89       	ldd	r25, Y+21	; 0x15
    22c0:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    22c4:	4b 01       	movw	r8, r22
    22c6:	5c 01       	movw	r10, r24
    22c8:	20 e0       	ldi	r18, 0x00	; 0
    22ca:	30 e0       	ldi	r19, 0x00	; 0
    22cc:	40 e2       	ldi	r20, 0x20	; 32
    22ce:	51 e4       	ldi	r21, 0x41	; 65
    22d0:	6f a1       	ldd	r22, Y+39	; 0x27
    22d2:	78 a5       	ldd	r23, Y+40	; 0x28
    22d4:	89 a5       	ldd	r24, Y+41	; 0x29
    22d6:	9a a5       	ldd	r25, Y+42	; 0x2a
    22d8:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    22dc:	9b 01       	movw	r18, r22
    22de:	ac 01       	movw	r20, r24
    22e0:	c5 01       	movw	r24, r10
    22e2:	b4 01       	movw	r22, r8
    22e4:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    22e8:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
							
							//Saturation
							if (RSpeed > currentDriveActuation){
    22ec:	e6 16       	cp	r14, r22
    22ee:	f7 06       	cpc	r15, r23
    22f0:	44 f0       	brlt	.+16     	; 0x2302 <__stack+0x103>
    22f2:	8b 01       	movw	r16, r22
    22f4:	77 23       	and	r23, r23
    22f6:	34 f4       	brge	.+12     	; 0x2304 <__stack+0x105>
    22f8:	00 e0       	ldi	r16, 0x00	; 0
    22fa:	10 e0       	ldi	r17, 0x00	; 0
    22fc:	03 c0       	rjmp	.+6      	; 0x2304 <__stack+0x105>
						if (thetaDiff >= 0){//Moving left
							LSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*leftIntError; //Simple PI controller for theta 
							
							//Saturation
							if (LSpeed > currentDriveActuation){
								LSpeed = currentDriveActuation;
    22fe:	78 01       	movw	r14, r16
    2300:	01 c0       	rjmp	.+2      	; 0x2304 <__stack+0x105>
						}else{//Moving right
							RSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*rightIntError; //Simple PI controller for theta
							
							//Saturation
							if (RSpeed > currentDriveActuation){
								RSpeed = currentDriveActuation;
    2302:	87 01       	movw	r16, r14
							
							
							
						}
						
						leftIntError += thetaDiff;
    2304:	a3 01       	movw	r20, r6
    2306:	92 01       	movw	r18, r4
    2308:	6b a1       	ldd	r22, Y+35	; 0x23
    230a:	7c a1       	ldd	r23, Y+36	; 0x24
    230c:	8d a1       	ldd	r24, Y+37	; 0x25
    230e:	9e a1       	ldd	r25, Y+38	; 0x26
    2310:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    2314:	6b a3       	std	Y+35, r22	; 0x23
    2316:	7c a3       	std	Y+36, r23	; 0x24
    2318:	8d a3       	std	Y+37, r24	; 0x25
    231a:	9e a3       	std	Y+38, r25	; 0x26
						rightIntError -= thetaDiff;
    231c:	a3 01       	movw	r20, r6
    231e:	92 01       	movw	r18, r4
    2320:	6f a1       	ldd	r22, Y+39	; 0x27
    2322:	78 a5       	ldd	r23, Y+40	; 0x28
    2324:	89 a5       	ldd	r24, Y+41	; 0x29
    2326:	9a a5       	ldd	r25, Y+42	; 0x2a
    2328:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    232c:	6f a3       	std	Y+39, r22	; 0x27
    232e:	78 a7       	std	Y+40, r23	; 0x28
    2330:	89 a7       	std	Y+41, r24	; 0x29
    2332:	9a a7       	std	Y+42, r25	; 0x2a
						
						
						gRightWheelDirection = motorRightForward;
    2334:	b6 e0       	ldi	r27, 0x06	; 6
    2336:	bd 87       	std	Y+13, r27	; 0x0d
						gLeftWheelDirection = motorLeftForward;
    2338:	84 e0       	ldi	r24, 0x04	; 4
    233a:	8c 87       	std	Y+12, r24	; 0x0c
						lastMovement = moveForward;
    233c:	a1 e0       	ldi	r26, 0x01	; 1
    233e:	af 83       	std	Y+7, r26	; 0x07
    2340:	70 c0       	rjmp	.+224    	; 0x2422 <__stack+0x223>
						
						
						
					}else{ //Turn within 1 degree of target
						if (thetaDiff >= 0){//Rotating left
    2342:	20 e0       	ldi	r18, 0x00	; 0
    2344:	30 e0       	ldi	r19, 0x00	; 0
    2346:	a9 01       	movw	r20, r18
    2348:	c3 01       	movw	r24, r6
    234a:	b2 01       	movw	r22, r4
    234c:	0e 94 aa 32 	call	0x6554	; 0x6554 <__gesf2>
    2350:	88 23       	and	r24, r24
    2352:	a4 f1       	brlt	.+104    	; 0x23bc <__stack+0x1bd>
							LSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    2354:	2e ea       	ldi	r18, 0xAE	; 174
    2356:	37 e4       	ldi	r19, 0x47	; 71
    2358:	41 e6       	ldi	r20, 0x61	; 97
    235a:	5e e3       	ldi	r21, 0x3E	; 62
    235c:	c5 01       	movw	r24, r10
    235e:	b4 01       	movw	r22, r8
    2360:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2364:	2a e9       	ldi	r18, 0x9A	; 154
    2366:	39 e9       	ldi	r19, 0x99	; 153
    2368:	49 e9       	ldi	r20, 0x99	; 153
    236a:	5e e3       	ldi	r21, 0x3E	; 62
    236c:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    2370:	4b 01       	movw	r8, r22
    2372:	5c 01       	movw	r10, r24
    2374:	20 e0       	ldi	r18, 0x00	; 0
    2376:	30 e0       	ldi	r19, 0x00	; 0
    2378:	46 e9       	ldi	r20, 0x96	; 150
    237a:	52 ec       	ldi	r21, 0xC2	; 194
    237c:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2380:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
    2384:	7b 01       	movw	r14, r22
							gLeftWheelDirection = motorLeftBackward;
    2386:	b5 e0       	ldi	r27, 0x05	; 5
    2388:	bc 87       	std	Y+12, r27	; 0x0c
							RSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    238a:	20 e0       	ldi	r18, 0x00	; 0
    238c:	30 e0       	ldi	r19, 0x00	; 0
    238e:	46 e9       	ldi	r20, 0x96	; 150
    2390:	52 e4       	ldi	r21, 0x42	; 66
    2392:	c5 01       	movw	r24, r10
    2394:	b4 01       	movw	r22, r8
    2396:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    239a:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
    239e:	8b 01       	movw	r16, r22
							gRightWheelDirection = motorRightForward;
    23a0:	86 e0       	ldi	r24, 0x06	; 6
    23a2:	8d 87       	std	Y+13, r24	; 0x0d
							lastMovement = moveCounterClockwise;
    23a4:	a4 e0       	ldi	r26, 0x04	; 4
    23a6:	af 83       	std	Y+7, r26	; 0x07
    23a8:	1b a6       	std	Y+43, r1	; 0x2b
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
						}
						
						leftIntError = 0;
						rightIntError = 0;
    23aa:	1f a2       	std	Y+39, r1	; 0x27
    23ac:	18 a6       	std	Y+40, r1	; 0x28
    23ae:	19 a6       	std	Y+41, r1	; 0x29
    23b0:	1a a6       	std	Y+42, r1	; 0x2a
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
						}
						
						leftIntError = 0;
    23b2:	1b a2       	std	Y+35, r1	; 0x23
    23b4:	1c a2       	std	Y+36, r1	; 0x24
    23b6:	1d a2       	std	Y+37, r1	; 0x25
    23b8:	1e a2       	std	Y+38, r1	; 0x26
    23ba:	33 c0       	rjmp	.+102    	; 0x2422 <__stack+0x223>
							gLeftWheelDirection = motorLeftBackward;
							RSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightForward;
							lastMovement = moveCounterClockwise;
						}else{//Rotating right
							LSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    23bc:	2e ea       	ldi	r18, 0xAE	; 174
    23be:	37 e4       	ldi	r19, 0x47	; 71
    23c0:	41 e6       	ldi	r20, 0x61	; 97
    23c2:	5e e3       	ldi	r21, 0x3E	; 62
    23c4:	c5 01       	movw	r24, r10
    23c6:	b4 01       	movw	r22, r8
    23c8:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    23cc:	2a e9       	ldi	r18, 0x9A	; 154
    23ce:	39 e9       	ldi	r19, 0x99	; 153
    23d0:	49 e9       	ldi	r20, 0x99	; 153
    23d2:	5e e3       	ldi	r21, 0x3E	; 62
    23d4:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    23d8:	4b 01       	movw	r8, r22
    23da:	5c 01       	movw	r10, r24
    23dc:	20 e0       	ldi	r18, 0x00	; 0
    23de:	30 e0       	ldi	r19, 0x00	; 0
    23e0:	46 e9       	ldi	r20, 0x96	; 150
    23e2:	52 e4       	ldi	r21, 0x42	; 66
    23e4:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    23e8:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
    23ec:	7b 01       	movw	r14, r22
							gLeftWheelDirection = motorLeftForward;
    23ee:	b4 e0       	ldi	r27, 0x04	; 4
    23f0:	bc 87       	std	Y+12, r27	; 0x0c
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    23f2:	20 e0       	ldi	r18, 0x00	; 0
    23f4:	30 e0       	ldi	r19, 0x00	; 0
    23f6:	46 e9       	ldi	r20, 0x96	; 150
    23f8:	52 ec       	ldi	r21, 0xC2	; 194
    23fa:	c5 01       	movw	r24, r10
    23fc:	b4 01       	movw	r22, r8
    23fe:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2402:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
    2406:	8b 01       	movw	r16, r22
							gRightWheelDirection = motorRightBackward;
    2408:	85 e0       	ldi	r24, 0x05	; 5
    240a:	8d 87       	std	Y+13, r24	; 0x0d
							lastMovement = moveClockwise;
    240c:	a3 e0       	ldi	r26, 0x03	; 3
    240e:	af 83       	std	Y+7, r26	; 0x07
    2410:	1b a6       	std	Y+43, r1	; 0x2b
						}
						
						leftIntError = 0;
						rightIntError = 0;
    2412:	1f a2       	std	Y+39, r1	; 0x27
    2414:	18 a6       	std	Y+40, r1	; 0x28
    2416:	19 a6       	std	Y+41, r1	; 0x29
    2418:	1a a6       	std	Y+42, r1	; 0x2a
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
						}
						
						leftIntError = 0;
    241a:	1b a2       	std	Y+35, r1	; 0x23
    241c:	1c a2       	std	Y+36, r1	; 0x24
    241e:	1d a2       	std	Y+37, r1	; 0x25
    2420:	1e a2       	std	Y+38, r1	; 0x26
					
					
					
					
					
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
    2422:	9e 01       	movw	r18, r28
    2424:	23 5f       	subi	r18, 0xF3	; 243
    2426:	3f 4f       	sbci	r19, 0xFF	; 255
    2428:	ae 01       	movw	r20, r28
    242a:	44 5f       	subi	r20, 0xF4	; 244
    242c:	5f 4f       	sbci	r21, 0xFF	; 255
    242e:	b8 01       	movw	r22, r16
    2430:	c7 01       	movw	r24, r14
    2432:	57 d4       	rcall	.+2222   	; 0x2ce2 <vMotorMovementSwitch>
				
				
				if(distance > radiusEpsilon){//Not close enough to target
					
					
					idleSendt = FALSE;
    2434:	1a 8e       	std	Y+26, r1	; 0x1a
    2436:	0a c0       	rjmp	.+20     	; 0x244c <__stack+0x24d>
					
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
			
				}else{
					
					if (idleSendt == FALSE){
    2438:	ba 8d       	ldd	r27, Y+26	; 0x1a
    243a:	b1 11       	cpse	r27, r1
    243c:	04 c0       	rjmp	.+8      	; 0x2446 <__stack+0x247>
						send_idle();
    243e:	0e 94 e3 20 	call	0x41c6	; 0x41c6 <send_idle>
						idleSendt = TRUE;
					}
					
					
					vMotorBrakeLeft();
    2442:	81 e0       	ldi	r24, 0x01	; 1
    2444:	8a 8f       	std	Y+26, r24	; 0x1a
					vMotorBrakeRight();
    2446:	39 d4       	rcall	.+2162   	; 0x2cba <vMotorBrakeLeft>
    2448:	3d d4       	rcall	.+2170   	; 0x2cc4 <vMotorBrakeRight>
					lastMovement = moveStop;
    244a:	1f 82       	std	Y+7, r1	; 0x07
				}
				
				
				
				xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
    244c:	20 e0       	ldi	r18, 0x00	; 0
    244e:	40 e0       	ldi	r20, 0x00	; 0
    2450:	50 e0       	ldi	r21, 0x00	; 0
    2452:	be 01       	movw	r22, r28
    2454:	69 5f       	subi	r22, 0xF9	; 249
    2456:	7f 4f       	sbci	r23, 0xFF	; 255
    2458:	80 91 c7 19 	lds	r24, 0x19C7	; 0x8019c7 <scanStatusQ>
    245c:	90 91 c8 19 	lds	r25, 0x19C8	; 0x8019c8 <scanStatusQ+0x1>
    2460:	0e 94 08 1b 	call	0x3610	; 0x3610 <xQueueGenericSend>
    2464:	42 cd       	rjmp	.-1404   	; 0x1eea <vMainPoseControllerTask+0x56>

00002466 <vMainPoseEstimatorTask>:
	  
	
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    2466:	cf 93       	push	r28
    2468:	df 93       	push	r29
    246a:	cd b7       	in	r28, 0x3d	; 61
    246c:	de b7       	in	r29, 0x3e	; 62
    246e:	e1 97       	sbiw	r28, 0x31	; 49
    2470:	0f b6       	in	r0, 0x3f	; 63
    2472:	f8 94       	cli
    2474:	de bf       	out	0x3e, r29	; 62
    2476:	0f be       	out	0x3f, r0	; 63
    2478:	cd bf       	out	0x3d, r28	; 61
    const TickType_t xDelay = PERIOD_ESTIMATOR_MS;
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    247a:	19 82       	std	Y+1, r1	; 0x01
    247c:	1a 82       	std	Y+2, r1	; 0x02
    247e:	1b 82       	std	Y+3, r1	; 0x03
    2480:	1c 82       	std	Y+4, r1	; 0x04
        uint8_t printerTellar = 0;     
    #endif
    
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    2482:	0e 94 02 29 	call	0x5204	; 0x5204 <xTaskGetTickCount>
    2486:	9e 83       	std	Y+6, r25	; 0x06
    2488:	8d 83       	std	Y+5, r24	; 0x05
    
    float variance_gyro = 0.0482f; // [rad] calculated offline, see report
    float variance_encoder = (2.0f * WHEEL_FACTOR_MM) / (WHEELBASE_MM / 2.0f); // approximation, 0.0257 [rad]
    
    float variance_gyro_encoder = (variance_gyro + variance_encoder) * period_in_S; // (Var gyro + var encoder) * timestep
    float covariance_filter_predicted = 0;
    248a:	1d a6       	std	Y+45, r1	; 0x2d
    248c:	1e a6       	std	Y+46, r1	; 0x2e
    248e:	1f a6       	std	Y+47, r1	; 0x2f
    2490:	18 aa       	std	Y+48, r1	; 0x30
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    float compassOffset = 0.0;
    2492:	19 a2       	std	Y+33, r1	; 0x21
    2494:	1a a2       	std	Y+34, r1	; 0x22
    2496:	1b a2       	std	Y+35, r1	; 0x23
    2498:	1c a2       	std	Y+36, r1	; 0x24
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    249a:	1d 8e       	std	Y+29, r1	; 0x1d
    249c:	1e 8e       	std	Y+30, r1	; 0x1e
    249e:	1f 8e       	std	Y+31, r1	; 0x1f
    24a0:	18 a2       	std	Y+32, r1	; 0x20
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    24a2:	1d 8a       	std	Y+21, r1	; 0x15
    24a4:	1e 8a       	std	Y+22, r1	; 0x16
    24a6:	1f 8a       	std	Y+23, r1	; 0x17
    24a8:	18 8e       	std	Y+24, r1	; 0x18
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    24aa:	19 8a       	std	Y+17, r1	; 0x11
    24ac:	1a 8a       	std	Y+18, r1	; 0x12
    24ae:	1b 8a       	std	Y+19, r1	; 0x13
    24b0:	1c 8a       	std	Y+20, r1	; 0x14
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    int16_t previous_ticksRight = 0;  
    24b2:	61 2c       	mov	r6, r1
    24b4:	71 2c       	mov	r7, r1
	
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    24b6:	1a 8e       	std	Y+26, r1	; 0x1a
    24b8:	19 8e       	std	Y+25, r1	; 0x19
    24ba:	41 2c       	mov	r4, r1
    24bc:	31 2c       	mov	r3, r1
    24be:	21 2c       	mov	r2, r1
    24c0:	51 2c       	mov	r5, r1
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    
    while(1){
        // Loop
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    24c2:	68 e2       	ldi	r22, 0x28	; 40
    24c4:	70 e0       	ldi	r23, 0x00	; 0
    24c6:	ce 01       	movw	r24, r28
    24c8:	05 96       	adiw	r24, 0x05	; 5
    24ca:	0e 94 b5 23 	call	0x476a	; 0x476a <vTaskDelayUntil>
        if (gHandshook){ // Check if we are ready    
    24ce:	80 91 c2 19 	lds	r24, 0x19C2	; 0x8019c2 <gHandshook>
    24d2:	88 23       	and	r24, r24
    24d4:	09 f4       	brne	.+2      	; 0x24d8 <vMainPoseEstimatorTask+0x72>
    24d6:	f0 c1       	rjmp	.+992    	; 0x28b8 <vMainPoseEstimatorTask+0x452>
            int16_t leftWheelTicks = 0;
            int16_t rightWheelTicks = 0;
            
            // Get encoder data, protect the global tick variables
            xSemaphoreTake(xTickMutex, 15 / portTICK_PERIOD_MS);
    24d8:	20 e0       	ldi	r18, 0x00	; 0
    24da:	4f e0       	ldi	r20, 0x0F	; 15
    24dc:	50 e0       	ldi	r21, 0x00	; 0
    24de:	60 e0       	ldi	r22, 0x00	; 0
    24e0:	70 e0       	ldi	r23, 0x00	; 0
    24e2:	80 91 2f 1b 	lds	r24, 0x1B2F	; 0x801b2f <xTickMutex>
    24e6:	90 91 30 1b 	lds	r25, 0x1B30	; 0x801b30 <xTickMutex+0x1>
    24ea:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
                leftWheelTicks = gLeftWheelTicks;
    24ee:	80 91 b5 19 	lds	r24, 0x19B5	; 0x8019b5 <gLeftWheelTicks>
    24f2:	90 91 b6 19 	lds	r25, 0x19B6	; 0x8019b6 <gLeftWheelTicks+0x1>
    24f6:	9e a3       	std	Y+38, r25	; 0x26
    24f8:	8d a3       	std	Y+37, r24	; 0x25
                rightWheelTicks = gRightWheelTicks;
    24fa:	80 91 b7 19 	lds	r24, 0x19B7	; 0x8019b7 <gRightWheelTicks>
    24fe:	90 91 b8 19 	lds	r25, 0x19B8	; 0x8019b8 <gRightWheelTicks+0x1>
    2502:	98 a7       	std	Y+40, r25	; 0x28
    2504:	8f a3       	std	Y+39, r24	; 0x27
            xSemaphoreGive(xTickMutex);
    2506:	60 e0       	ldi	r22, 0x00	; 0
    2508:	70 e0       	ldi	r23, 0x00	; 0
    250a:	80 91 2f 1b 	lds	r24, 0x1B2F	; 0x801b2f <xTickMutex>
    250e:	90 91 30 1b 	lds	r25, 0x1B30	; 0x801b30 <xTickMutex+0x1>
    2512:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
    2516:	6d a1       	ldd	r22, Y+37	; 0x25
    2518:	7e a1       	ldd	r23, Y+38	; 0x26
    251a:	89 8d       	ldd	r24, Y+25	; 0x19
    251c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    251e:	68 1b       	sub	r22, r24
    2520:	79 0b       	sbc	r23, r25
    2522:	07 2e       	mov	r0, r23
    2524:	00 0c       	add	r0, r0
    2526:	88 0b       	sbc	r24, r24
    2528:	99 0b       	sbc	r25, r25
    252a:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    252e:	28 ef       	ldi	r18, 0xF8	; 248
    2530:	33 e5       	ldi	r19, 0x53	; 83
    2532:	43 e2       	ldi	r20, 0x23	; 35
    2534:	5f e3       	ldi	r21, 0x3F	; 63
    2536:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    253a:	4b 01       	movw	r8, r22
    253c:	5c 01       	movw	r10, r24
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
    253e:	6f a1       	ldd	r22, Y+39	; 0x27
    2540:	78 a5       	ldd	r23, Y+40	; 0x28
    2542:	66 19       	sub	r22, r6
    2544:	77 09       	sbc	r23, r7
    2546:	07 2e       	mov	r0, r23
    2548:	00 0c       	add	r0, r0
    254a:	88 0b       	sbc	r24, r24
    254c:	99 0b       	sbc	r25, r25
    254e:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    2552:	28 ef       	ldi	r18, 0xF8	; 248
    2554:	33 e5       	ldi	r19, 0x53	; 83
    2556:	43 e2       	ldi	r20, 0x23	; 35
    2558:	5f e3       	ldi	r21, 0x3F	; 63
    255a:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    255e:	6b 01       	movw	r12, r22
    2560:	7c 01       	movw	r14, r24
            
			
			
					   
					   
            float dRobot = (dLeft + dRight) / 2;           
    2562:	9b 01       	movw	r18, r22
    2564:	ac 01       	movw	r20, r24
    2566:	c5 01       	movw	r24, r10
    2568:	b4 01       	movw	r22, r8
    256a:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    256e:	20 e0       	ldi	r18, 0x00	; 0
    2570:	30 e0       	ldi	r19, 0x00	; 0
    2572:	40 e0       	ldi	r20, 0x00	; 0
    2574:	5f e3       	ldi	r21, 0x3F	; 63
    2576:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    257a:	69 8f       	std	Y+25, r22	; 0x19
    257c:	7a 8f       	std	Y+26, r23	; 0x1a
    257e:	8b 8f       	std	Y+27, r24	; 0x1b
    2580:	9c 8f       	std	Y+28, r25	; 0x1c
            float dTheta = (dRight - dLeft) / WHEELBASE_MM; // Get angle from encoders, dervied from arch of circles formula
    2582:	a5 01       	movw	r20, r10
    2584:	94 01       	movw	r18, r8
    2586:	c7 01       	movw	r24, r14
    2588:	b6 01       	movw	r22, r12
    258a:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    258e:	20 e0       	ldi	r18, 0x00	; 0
    2590:	30 e0       	ldi	r19, 0x00	; 0
    2592:	43 e1       	ldi	r20, 0x13	; 19
    2594:	53 e4       	ldi	r21, 0x43	; 67
    2596:	0e 94 01 31 	call	0x6202	; 0x6202 <__divsf3>
    259a:	4b 01       	movw	r8, r22
    259c:	5c 01       	movw	r10, r24
			
			
            
            /* PREDICT */
            // Get gyro data:
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
    259e:	5e d9       	rcall	.-3396   	; 0x185c <fIMU_readFloatGyroZ>
    25a0:	2d 8d       	ldd	r18, Y+29	; 0x1d
    25a2:	3e 8d       	ldd	r19, Y+30	; 0x1e
    25a4:	4f 8d       	ldd	r20, Y+31	; 0x1f
    25a6:	58 a1       	ldd	r21, Y+32	; 0x20
    25a8:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    25ac:	6b 01       	movw	r12, r22
    25ae:	7c 01       	movw	r14, r24
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
    25b0:	9f 77       	andi	r25, 0x7F	; 127
    25b2:	20 e0       	ldi	r18, 0x00	; 0
    25b4:	30 e0       	ldi	r19, 0x00	; 0
    25b6:	40 e2       	ldi	r20, 0x20	; 32
    25b8:	51 e4       	ldi	r21, 0x41	; 65
    25ba:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__cmpsf2>
    25be:	88 23       	and	r24, r24
    25c0:	6c f0       	brlt	.+26     	; 0x25dc <vMainPoseEstimatorTask+0x176>
                gyroWeight = 0; // Disregard gyro while driving in a straight line
                robot_is_turning = FALSE; // Don't update angle estimates
                }
            else {
                robot_is_turning = TRUE;
    25c2:	91 e0       	ldi	r25, 0x01	; 1
    25c4:	99 ab       	std	Y+49, r25	; 0x31
                gyroWeight = 0.85; // Found by experiment, after 20x90 degree turns, gyro seems 85% more accurate than encoders
    25c6:	1a e9       	ldi	r17, 0x9A	; 154
    25c8:	09 e9       	ldi	r16, 0x99	; 153
    25ca:	0f 2e       	mov	r0, r31
    25cc:	f9 e5       	ldi	r31, 0x59	; 89
    25ce:	7f 2e       	mov	r7, r31
    25d0:	f0 2d       	mov	r31, r0
    25d2:	0f 2e       	mov	r0, r31
    25d4:	ff e3       	ldi	r31, 0x3F	; 63
    25d6:	6f 2e       	mov	r6, r31
    25d8:	f0 2d       	mov	r31, r0
    25da:	05 c0       	rjmp	.+10     	; 0x25e6 <vMainPoseEstimatorTask+0x180>
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
                gyroWeight = 0; // Disregard gyro while driving in a straight line
                robot_is_turning = FALSE; // Don't update angle estimates
    25dc:	19 aa       	std	Y+49, r1	; 0x31
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
                gyroWeight = 0; // Disregard gyro while driving in a straight line
    25de:	14 2d       	mov	r17, r4
    25e0:	03 2d       	mov	r16, r3
    25e2:	72 2c       	mov	r7, r2
    25e4:	65 2c       	mov	r6, r5
            gyrZ *= period_in_S * DEG2RAD; // Scale gyro measurement      
            
			
			
            // Fuse heading from sensors to predict heading:
            dTheta =  (1 - gyroWeight) * dTheta + gyroWeight * gyrZ;
    25e6:	21 2f       	mov	r18, r17
    25e8:	30 2f       	mov	r19, r16
    25ea:	47 2d       	mov	r20, r7
    25ec:	56 2d       	mov	r21, r6
    25ee:	60 e0       	ldi	r22, 0x00	; 0
    25f0:	70 e0       	ldi	r23, 0x00	; 0
    25f2:	80 e8       	ldi	r24, 0x80	; 128
    25f4:	9f e3       	ldi	r25, 0x3F	; 63
    25f6:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    25fa:	a5 01       	movw	r20, r10
    25fc:	94 01       	movw	r18, r8
    25fe:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2602:	4b 01       	movw	r8, r22
    2604:	5c 01       	movw	r10, r24
    2606:	24 ed       	ldi	r18, 0xD4	; 212
    2608:	32 e0       	ldi	r19, 0x02	; 2
    260a:	47 e3       	ldi	r20, 0x37	; 55
    260c:	5a e3       	ldi	r21, 0x3A	; 58
    260e:	c7 01       	movw	r24, r14
    2610:	b6 01       	movw	r22, r12
    2612:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2616:	21 2f       	mov	r18, r17
    2618:	30 2f       	mov	r19, r16
    261a:	47 2d       	mov	r20, r7
    261c:	56 2d       	mov	r21, r6
    261e:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2622:	a5 01       	movw	r20, r10
    2624:	94 01       	movw	r18, r8
    2626:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    262a:	69 a7       	std	Y+41, r22	; 0x29
    262c:	7a a7       	std	Y+42, r23	; 0x2a
    262e:	8b a7       	std	Y+43, r24	; 0x2b
    2630:	9c a7       	std	Y+44, r25	; 0x2c
            
            
            // Estimate global X and Y pos
            // Todo; Include accelerator measurements to estimate position and handle wheel slippage
            predictedX = predictedX + (dRobot * cos(predictedTheta + 0.5 * dTheta)); 
    2632:	c9 80       	ldd	r12, Y+1	; 0x01
    2634:	da 80       	ldd	r13, Y+2	; 0x02
    2636:	eb 80       	ldd	r14, Y+3	; 0x03
    2638:	fc 80       	ldd	r15, Y+4	; 0x04
    263a:	20 e0       	ldi	r18, 0x00	; 0
    263c:	30 e0       	ldi	r19, 0x00	; 0
    263e:	40 e0       	ldi	r20, 0x00	; 0
    2640:	5f e3       	ldi	r21, 0x3F	; 63
    2642:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2646:	a7 01       	movw	r20, r14
    2648:	96 01       	movw	r18, r12
    264a:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    264e:	4b 01       	movw	r8, r22
    2650:	5c 01       	movw	r10, r24
    2652:	0e 94 fe 30 	call	0x61fc	; 0x61fc <cos>
    2656:	9b 01       	movw	r18, r22
    2658:	ac 01       	movw	r20, r24
    265a:	69 8d       	ldd	r22, Y+25	; 0x19
    265c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    265e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2660:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2662:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2666:	9b 01       	movw	r18, r22
    2668:	ac 01       	movw	r20, r24
    266a:	69 89       	ldd	r22, Y+17	; 0x11
    266c:	7a 89       	ldd	r23, Y+18	; 0x12
    266e:	8b 89       	ldd	r24, Y+19	; 0x13
    2670:	9c 89       	ldd	r25, Y+20	; 0x14
    2672:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    2676:	69 8b       	std	Y+17, r22	; 0x11
    2678:	7a 8b       	std	Y+18, r23	; 0x12
    267a:	8b 8b       	std	Y+19, r24	; 0x13
    267c:	9c 8b       	std	Y+20, r25	; 0x14
            predictedY = predictedY + (dRobot * sin(predictedTheta + 0.5 * dTheta));
    267e:	c5 01       	movw	r24, r10
    2680:	b4 01       	movw	r22, r8
    2682:	0e 94 18 33 	call	0x6630	; 0x6630 <sin>
    2686:	9b 01       	movw	r18, r22
    2688:	ac 01       	movw	r20, r24
    268a:	69 8d       	ldd	r22, Y+25	; 0x19
    268c:	7a 8d       	ldd	r23, Y+26	; 0x1a
    268e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2690:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2692:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    2696:	9b 01       	movw	r18, r22
    2698:	ac 01       	movw	r20, r24
    269a:	6d 89       	ldd	r22, Y+21	; 0x15
    269c:	7e 89       	ldd	r23, Y+22	; 0x16
    269e:	8f 89       	ldd	r24, Y+23	; 0x17
    26a0:	98 8d       	ldd	r25, Y+24	; 0x18
    26a2:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    26a6:	6d 8b       	std	Y+21, r22	; 0x15
    26a8:	7e 8b       	std	Y+22, r23	; 0x16
    26aa:	8f 8b       	std	Y+23, r24	; 0x17
    26ac:	98 8f       	std	Y+24, r25	; 0x18

            // Predicted (a priori) state estimate for theta
            predictedTheta += dTheta;
    26ae:	a7 01       	movw	r20, r14
    26b0:	96 01       	movw	r18, r12
    26b2:	69 a5       	ldd	r22, Y+41	; 0x29
    26b4:	7a a5       	ldd	r23, Y+42	; 0x2a
    26b6:	8b a5       	ldd	r24, Y+43	; 0x2b
    26b8:	9c a5       	ldd	r25, Y+44	; 0x2c
    26ba:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    26be:	69 83       	std	Y+1, r22	; 0x01
    26c0:	7a 83       	std	Y+2, r23	; 0x02
    26c2:	8b 83       	std	Y+3, r24	; 0x03
    26c4:	9c 83       	std	Y+4, r25	; 0x04
                  
            // Predicted (a priori) estimate covariance
            covariance_filter_predicted += variance_gyro_encoder;
    26c6:	2f ee       	ldi	r18, 0xEF	; 239
    26c8:	3c ed       	ldi	r19, 0xDC	; 220
    26ca:	4b e2       	ldi	r20, 0x2B	; 43
    26cc:	5b e3       	ldi	r21, 0x3B	; 59
    26ce:	6d a5       	ldd	r22, Y+45	; 0x2d
    26d0:	7e a5       	ldd	r23, Y+46	; 0x2e
    26d2:	8f a5       	ldd	r24, Y+47	; 0x2f
    26d4:	98 a9       	ldd	r25, Y+48	; 0x30
    26d6:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    26da:	4b 01       	movw	r8, r22
    26dc:	5c 01       	movw	r10, r24
            
            /* UPDATE */
            // Get compass data: ( Request and recheck after 6 ms?)
            int16_t xCom, yCom, zCom;
            vCOM_getData(&xCom, &yCom, &zCom);
    26de:	ae 01       	movw	r20, r28
    26e0:	45 5f       	subi	r20, 0xF5	; 245
    26e2:	5f 4f       	sbci	r21, 0xFF	; 255
    26e4:	be 01       	movw	r22, r28
    26e6:	63 5f       	subi	r22, 0xF3	; 243
    26e8:	7f 4f       	sbci	r23, 0xFF	; 255
    26ea:	ce 01       	movw	r24, r28
    26ec:	0f 96       	adiw	r24, 0x0f	; 15
    26ee:	0e 94 82 07 	call	0xf04	; 0xf04 <vCOM_getData>
            // Add calibrated bias
            xCom += xComOff;
    26f2:	6f 85       	ldd	r22, Y+15	; 0x0f
    26f4:	78 89       	ldd	r23, Y+16	; 0x10
    26f6:	65 5f       	subi	r22, 0xF5	; 245
    26f8:	7f 4f       	sbci	r23, 0xFF	; 255
    26fa:	78 8b       	std	Y+16, r23	; 0x10
    26fc:	6f 87       	std	Y+15, r22	; 0x0f
            yCom += yComOff;
    26fe:	0d 85       	ldd	r16, Y+13	; 0x0d
    2700:	1e 85       	ldd	r17, Y+14	; 0x0e
    2702:	0e 54       	subi	r16, 0x4E	; 78
    2704:	11 09       	sbc	r17, r1
    2706:	1e 87       	std	Y+14, r17	; 0x0e
    2708:	0d 87       	std	Y+13, r16	; 0x0d
            // calculate heading
            float compassHeading;
            compassHeading = atan2(yCom, xCom) - compassOffset ; // returns -pi, pi
    270a:	07 2e       	mov	r0, r23
    270c:	00 0c       	add	r0, r0
    270e:	88 0b       	sbc	r24, r24
    2710:	99 0b       	sbc	r25, r25
    2712:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    2716:	6b 01       	movw	r12, r22
    2718:	7c 01       	movw	r14, r24
    271a:	b8 01       	movw	r22, r16
    271c:	11 0f       	add	r17, r17
    271e:	88 0b       	sbc	r24, r24
    2720:	99 0b       	sbc	r25, r25
    2722:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    2726:	a7 01       	movw	r20, r14
    2728:	96 01       	movw	r18, r12
    272a:	0e 94 a7 30 	call	0x614e	; 0x614e <atan2>
            // Update predicted state:    
            float error = (compassHeading - predictedTheta);
    272e:	29 a1       	ldd	r18, Y+33	; 0x21
    2730:	3a a1       	ldd	r19, Y+34	; 0x22
    2732:	4b a1       	ldd	r20, Y+35	; 0x23
    2734:	5c a1       	ldd	r21, Y+36	; 0x24
    2736:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    273a:	29 81       	ldd	r18, Y+1	; 0x01
    273c:	3a 81       	ldd	r19, Y+2	; 0x02
    273e:	4b 81       	ldd	r20, Y+3	; 0x03
    2740:	5c 81       	ldd	r21, Y+4	; 0x04
    2742:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    2746:	6f 83       	std	Y+7, r22	; 0x07
    2748:	78 87       	std	Y+8, r23	; 0x08
    274a:	89 87       	std	Y+9, r24	; 0x09
    274c:	9a 87       	std	Y+10, r25	; 0x0a
            vFunc_Inf2pi(&error);
    274e:	ce 01       	movw	r24, r28
    2750:	07 96       	adiw	r24, 0x07	; 7
    2752:	0e 94 1a 08 	call	0x1034	; 0x1034 <vFunc_Inf2pi>
            
            
            //kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
            ///* Commented back in due to fixed encoder
            if (fabs(error) > (0.8727*period_in_S)){ // 0.8727 rad/s is top speed while turning
    2756:	8f 81       	ldd	r24, Y+7	; 0x07
    2758:	98 85       	ldd	r25, Y+8	; 0x08
    275a:	a9 85       	ldd	r26, Y+9	; 0x09
    275c:	ba 85       	ldd	r27, Y+10	; 0x0a
    275e:	bc 01       	movw	r22, r24
    2760:	cd 01       	movw	r24, r26
    2762:	9f 77       	andi	r25, 0x7F	; 127
    2764:	20 eb       	ldi	r18, 0xB0	; 176
    2766:	3b ef       	ldi	r19, 0xFB	; 251
    2768:	4e e0       	ldi	r20, 0x0E	; 14
    276a:	5d e3       	ldi	r21, 0x3D	; 61
    276c:	0e 94 aa 32 	call	0x6554	; 0x6554 <__gesf2>
    2770:	18 16       	cp	r1, r24
    2772:	44 f4       	brge	.+16     	; 0x2784 <vMainPoseEstimatorTask+0x31e>
                // If we have a reading over this, we can safely ignore the compass
                // Ignore compass while driving in a straight line
                kalmanGain = 0;
                vLED_singleLow(ledYELLOW);
    2774:	81 e0       	ldi	r24, 0x01	; 1
    2776:	90 e0       	ldi	r25, 0x00	; 0
    2778:	94 d8       	rcall	.-3800   	; 0x18a2 <vLED_singleLow>
            //kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
            ///* Commented back in due to fixed encoder
            if (fabs(error) > (0.8727*period_in_S)){ // 0.8727 rad/s is top speed while turning
                // If we have a reading over this, we can safely ignore the compass
                // Ignore compass while driving in a straight line
                kalmanGain = 0;
    277a:	14 2d       	mov	r17, r4
    277c:	03 2d       	mov	r16, r3
    277e:	f2 2c       	mov	r15, r2
    2780:	e5 2c       	mov	r14, r5
    2782:	2c c0       	rjmp	.+88     	; 0x27dc <vMainPoseEstimatorTask+0x376>
                vLED_singleLow(ledYELLOW);
            }
            else if ((robot_is_turning == FALSE) && (dRobot == 0)){
    2784:	89 a9       	ldd	r24, Y+49	; 0x31
    2786:	81 11       	cpse	r24, r1
    2788:	22 c0       	rjmp	.+68     	; 0x27ce <vMainPoseEstimatorTask+0x368>
    278a:	24 2d       	mov	r18, r4
    278c:	33 2d       	mov	r19, r3
    278e:	42 2d       	mov	r20, r2
    2790:	55 2d       	mov	r21, r5
    2792:	69 8d       	ldd	r22, Y+25	; 0x19
    2794:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2796:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2798:	9c 8d       	ldd	r25, Y+28	; 0x1c
    279a:	0e 94 fa 30 	call	0x61f4	; 0x61f4 <__cmpsf2>
    279e:	81 11       	cpse	r24, r1
    27a0:	16 c0       	rjmp	.+44     	; 0x27ce <vMainPoseEstimatorTask+0x368>
                // Updated (a posteriori) state estimate
                kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
    27a2:	21 e2       	ldi	r18, 0x21	; 33
    27a4:	30 eb       	ldi	r19, 0xB0	; 176
    27a6:	42 eb       	ldi	r20, 0xB2	; 178
    27a8:	5e e3       	ldi	r21, 0x3E	; 62
    27aa:	c5 01       	movw	r24, r10
    27ac:	b4 01       	movw	r22, r8
    27ae:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    27b2:	9b 01       	movw	r18, r22
    27b4:	ac 01       	movw	r20, r24
    27b6:	c5 01       	movw	r24, r10
    27b8:	b4 01       	movw	r22, r8
    27ba:	0e 94 01 31 	call	0x6202	; 0x6202 <__divsf3>
    27be:	16 2f       	mov	r17, r22
    27c0:	07 2f       	mov	r16, r23
    27c2:	f8 2e       	mov	r15, r24
    27c4:	e9 2e       	mov	r14, r25
                vLED_singleHigh(ledYELLOW);
    27c6:	81 e0       	ldi	r24, 0x01	; 1
    27c8:	90 e0       	ldi	r25, 0x00	; 0
    27ca:	51 d8       	rcall	.-3934   	; 0x186e <vLED_singleHigh>
    27cc:	07 c0       	rjmp	.+14     	; 0x27dc <vMainPoseEstimatorTask+0x376>
            }
            else{
                kalmanGain = 0;
                vLED_singleLow(ledYELLOW);
    27ce:	81 e0       	ldi	r24, 0x01	; 1
    27d0:	90 e0       	ldi	r25, 0x00	; 0
    27d2:	67 d8       	rcall	.-3890   	; 0x18a2 <vLED_singleLow>
    27d4:	14 2d       	mov	r17, r4
                // Updated (a posteriori) state estimate
                kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
                vLED_singleHigh(ledYELLOW);
            }
            else{
                kalmanGain = 0;
    27d6:	03 2d       	mov	r16, r3
    27d8:	f2 2c       	mov	r15, r2
    27da:	e5 2c       	mov	r14, r5
    27dc:	2f 81       	ldd	r18, Y+7	; 0x07
                vLED_singleLow(ledYELLOW);
            }            
            //*/
           
            predictedTheta  += kalmanGain*(error);
    27de:	38 85       	ldd	r19, Y+8	; 0x08
    27e0:	49 85       	ldd	r20, Y+9	; 0x09
    27e2:	5a 85       	ldd	r21, Y+10	; 0x0a
    27e4:	61 2f       	mov	r22, r17
    27e6:	70 2f       	mov	r23, r16
    27e8:	8f 2d       	mov	r24, r15
    27ea:	9e 2d       	mov	r25, r14
    27ec:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    27f0:	9b 01       	movw	r18, r22
    27f2:	ac 01       	movw	r20, r24
    27f4:	69 81       	ldd	r22, Y+1	; 0x01
    27f6:	7a 81       	ldd	r23, Y+2	; 0x02
    27f8:	8b 81       	ldd	r24, Y+3	; 0x03
    27fa:	9c 81       	ldd	r25, Y+4	; 0x04
    27fc:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    2800:	69 83       	std	Y+1, r22	; 0x01
    2802:	7a 83       	std	Y+2, r23	; 0x02
    2804:	8b 83       	std	Y+3, r24	; 0x03
    2806:	9c 83       	std	Y+4, r25	; 0x04
    2808:	ce 01       	movw	r24, r28
			vFunc_Inf2pi(&predictedTheta);            
    280a:	01 96       	adiw	r24, 0x01	; 1
    280c:	0e 94 1a 08 	call	0x1034	; 0x1034 <vFunc_Inf2pi>
    2810:	21 2f       	mov	r18, r17
            
            // Updated (a posteriori) estimate covariance
            covariance_filter_predicted = (1 - kalmanGain) * covariance_filter_predicted;  
    2812:	30 2f       	mov	r19, r16
    2814:	4f 2d       	mov	r20, r15
    2816:	5e 2d       	mov	r21, r14
    2818:	60 e0       	ldi	r22, 0x00	; 0
    281a:	70 e0       	ldi	r23, 0x00	; 0
    281c:	80 e8       	ldi	r24, 0x80	; 128
    281e:	9f e3       	ldi	r25, 0x3F	; 63
    2820:	0e 94 33 30 	call	0x6066	; 0x6066 <__subsf3>
    2824:	a5 01       	movw	r20, r10
    2826:	94 01       	movw	r18, r8
    2828:	0e 94 b5 32 	call	0x656a	; 0x656a <__mulsf3>
    282c:	6d a7       	std	Y+45, r22	; 0x2d
    282e:	7e a7       	std	Y+46, r23	; 0x2e
    2830:	8f a7       	std	Y+47, r24	; 0x2f
    2832:	98 ab       	std	Y+48, r25	; 0x30
    2834:	20 e0       	ldi	r18, 0x00	; 0

			

            // Update pose
            xSemaphoreTake(xPoseMutex, 15 / portTICK_PERIOD_MS);
    2836:	4f e0       	ldi	r20, 0x0F	; 15
    2838:	50 e0       	ldi	r21, 0x00	; 0
    283a:	60 e0       	ldi	r22, 0x00	; 0
    283c:	70 e0       	ldi	r23, 0x00	; 0
    283e:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xPoseMutex>
    2842:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xPoseMutex+0x1>
    2846:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
    284a:	89 81       	ldd	r24, Y+1	; 0x01
                gTheta_hat = predictedTheta;
    284c:	9a 81       	ldd	r25, Y+2	; 0x02
    284e:	ab 81       	ldd	r26, Y+3	; 0x03
    2850:	bc 81       	ldd	r27, Y+4	; 0x04
    2852:	80 93 bd 19 	sts	0x19BD, r24	; 0x8019bd <gTheta_hat>
    2856:	90 93 be 19 	sts	0x19BE, r25	; 0x8019be <gTheta_hat+0x1>
    285a:	a0 93 bf 19 	sts	0x19BF, r26	; 0x8019bf <gTheta_hat+0x2>
    285e:	b0 93 c0 19 	sts	0x19C0, r27	; 0x8019c0 <gTheta_hat+0x3>
    2862:	69 89       	ldd	r22, Y+17	; 0x11
                gX_hat = predictedX;
    2864:	7a 89       	ldd	r23, Y+18	; 0x12
    2866:	8b 89       	ldd	r24, Y+19	; 0x13
    2868:	9c 89       	ldd	r25, Y+20	; 0x14
    286a:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
    286e:	70 93 bc 19 	sts	0x19BC, r23	; 0x8019bc <gX_hat+0x1>
    2872:	60 93 bb 19 	sts	0x19BB, r22	; 0x8019bb <gX_hat>
    2876:	6d 89       	ldd	r22, Y+21	; 0x15
                gY_hat = predictedY;
    2878:	7e 89       	ldd	r23, Y+22	; 0x16
    287a:	8f 89       	ldd	r24, Y+23	; 0x17
    287c:	98 8d       	ldd	r25, Y+24	; 0x18
    287e:	0e 94 69 31 	call	0x62d2	; 0x62d2 <__fixsfsi>
    2882:	70 93 ba 19 	sts	0x19BA, r23	; 0x8019ba <gY_hat+0x1>
    2886:	60 93 b9 19 	sts	0x19B9, r22	; 0x8019b9 <gY_hat>
    288a:	60 e0       	ldi	r22, 0x00	; 0
            xSemaphoreGive(xPoseMutex);
    288c:	70 e0       	ldi	r23, 0x00	; 0
    288e:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xPoseMutex>
    2892:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xPoseMutex+0x1>
    2896:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
    289a:	60 e0       	ldi	r22, 0x00	; 0
            // Send semaphore to controller
            xSemaphoreGive(xControllerBSem);
    289c:	70 e0       	ldi	r23, 0x00	; 0
    289e:	80 91 2d 1b 	lds	r24, 0x1B2D	; 0x801b2d <xControllerBSem>
    28a2:	90 91 2e 1b 	lds	r25, 0x1B2E	; 0x801b2e <xControllerBSem+0x1>
    28a6:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
    28aa:	6f a0       	ldd	r6, Y+39	; 0x27
            xSemaphoreGive(xTickMutex);
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
    28ac:	78 a4       	ldd	r7, Y+40	; 0x28
    28ae:	8d a1       	ldd	r24, Y+37	; 0x25
                rightWheelTicks = gRightWheelTicks;
            xSemaphoreGive(xTickMutex);
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
    28b0:	9e a1       	ldd	r25, Y+38	; 0x26
    28b2:	9a 8f       	std	Y+26, r25	; 0x1a
    28b4:	89 8f       	std	Y+25, r24	; 0x19
    28b6:	05 ce       	rjmp	.-1014   	; 0x24c2 <vMainPoseEstimatorTask+0x5c>
    28b8:	05 e6       	ldi	r16, 0x65	; 101
    28ba:	10 e0       	ldi	r17, 0x00	; 0
    28bc:	c4 2c       	mov	r12, r4
    28be:	d3 2c       	mov	r13, r3
    28c0:	e2 2c       	mov	r14, r2
    28c2:	f5 2c       	mov	r15, r5
    28c4:	0e 94 2e 0c 	call	0x185c	; 0x185c <fIMU_readFloatGyroZ>
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
                gyro+= fIMU_readFloatGyroZ();
    28c8:	9b 01       	movw	r18, r22
    28ca:	ac 01       	movw	r20, r24
    28cc:	6c 2d       	mov	r22, r12
    28ce:	7d 2d       	mov	r23, r13
    28d0:	8e 2d       	mov	r24, r14
    28d2:	9f 2d       	mov	r25, r15
    28d4:	0e 94 34 30 	call	0x6068	; 0x6068 <__addsf3>
    28d8:	c6 2e       	mov	r12, r22
    28da:	d7 2e       	mov	r13, r23
    28dc:	e8 2e       	mov	r14, r24
    28de:	f9 2e       	mov	r15, r25
    28e0:	01 50       	subi	r16, 0x01	; 1
    28e2:	11 09       	sbc	r17, r1
    28e4:	79 f7       	brne	.-34     	; 0x28c4 <vMainPoseEstimatorTask+0x45e>
        else{
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
    28e6:	ae 01       	movw	r20, r28
                gyro+= fIMU_readFloatGyroZ();
            }
            
            int16_t xCom, yCom, zCom;
            vCOM_getData(&xCom, &yCom, &zCom);
    28e8:	49 5f       	subi	r20, 0xF9	; 249
    28ea:	5f 4f       	sbci	r21, 0xFF	; 255
    28ec:	be 01       	movw	r22, r28
    28ee:	65 5f       	subi	r22, 0xF5	; 245
    28f0:	7f 4f       	sbci	r23, 0xFF	; 255
    28f2:	ce 01       	movw	r24, r28
    28f4:	0d 96       	adiw	r24, 0x0d	; 13
    28f6:	0e 94 82 07 	call	0xf04	; 0xf04 <vCOM_getData>
    28fa:	6d 85       	ldd	r22, Y+13	; 0x0d
            xCom += xComOff;
    28fc:	7e 85       	ldd	r23, Y+14	; 0x0e
    28fe:	65 5f       	subi	r22, 0xF5	; 245
    2900:	7f 4f       	sbci	r23, 0xFF	; 255
    2902:	0b 85       	ldd	r16, Y+11	; 0x0b
            yCom += yComOff;
    2904:	1c 85       	ldd	r17, Y+12	; 0x0c
    2906:	0e 54       	subi	r16, 0x4E	; 78
    2908:	11 09       	sbc	r17, r1
    290a:	84 2d       	mov	r24, r4
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
            predictedY = 0;
            predictedTheta = 0;
    290c:	93 2d       	mov	r25, r3
    290e:	a2 2d       	mov	r26, r2
    2910:	b5 2d       	mov	r27, r5
    2912:	89 83       	std	Y+1, r24	; 0x01
    2914:	9a 83       	std	Y+2, r25	; 0x02
    2916:	ab 83       	std	Y+3, r26	; 0x03
    2918:	bc 83       	std	Y+4, r27	; 0x04
    291a:	07 2e       	mov	r0, r23
            
            compassOffset = atan2(yCom, xCom);    
    291c:	00 0c       	add	r0, r0
    291e:	88 0b       	sbc	r24, r24
    2920:	99 0b       	sbc	r25, r25
    2922:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    2926:	4b 01       	movw	r8, r22
    2928:	5c 01       	movw	r10, r24
    292a:	b8 01       	movw	r22, r16
    292c:	11 0f       	add	r17, r17
    292e:	88 0b       	sbc	r24, r24
    2930:	99 0b       	sbc	r25, r25
    2932:	0e 94 9c 31 	call	0x6338	; 0x6338 <__floatsisf>
    2936:	a5 01       	movw	r20, r10
    2938:	94 01       	movw	r18, r8
    293a:	0e 94 a7 30 	call	0x614e	; 0x614e <atan2>
    293e:	69 a3       	std	Y+33, r22	; 0x21
    2940:	7a a3       	std	Y+34, r23	; 0x22
    2942:	8b a3       	std	Y+35, r24	; 0x23
    2944:	9c a3       	std	Y+36, r25	; 0x24
    2946:	20 e0       	ldi	r18, 0x00	; 0
            gyroOffset = gyro / (float)i;               
    2948:	30 e0       	ldi	r19, 0x00	; 0
    294a:	4a ec       	ldi	r20, 0xCA	; 202
    294c:	52 e4       	ldi	r21, 0x42	; 66
    294e:	6c 2d       	mov	r22, r12
    2950:	7d 2d       	mov	r23, r13
    2952:	8e 2d       	mov	r24, r14
    2954:	9f 2d       	mov	r25, r15
    2956:	0e 94 01 31 	call	0x6202	; 0x6202 <__divsf3>
    295a:	6d 8f       	std	Y+29, r22	; 0x1d
    295c:	7e 8f       	std	Y+30, r23	; 0x1e
    295e:	8f 8f       	std	Y+31, r24	; 0x1f
    2960:	98 a3       	std	Y+32, r25	; 0x20
    2962:	4d 8a       	std	Y+21, r4	; 0x15
            yCom += yComOff;
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
            predictedY = 0;
    2964:	3e 8a       	std	Y+22, r3	; 0x16
    2966:	2f 8a       	std	Y+23, r2	; 0x17
    2968:	58 8e       	std	Y+24, r5	; 0x18
    296a:	49 8a       	std	Y+17, r4	; 0x11
            xCom += xComOff;
            yCom += yComOff;
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
    296c:	3a 8a       	std	Y+18, r3	; 0x12
    296e:	2b 8a       	std	Y+19, r2	; 0x13
    2970:	5c 8a       	std	Y+20, r5	; 0x14
    2972:	a7 cd       	rjmp	.-1202   	; 0x24c2 <vMainPoseEstimatorTask+0x5c>

00002974 <vApplicationStackOverflowHook>:
    2974:	f8 94       	cli
    /*  Handle overflow */
    #ifdef DEBUG
       debug("Overflow\n");
    #endif
    while(1){
        vLED_toggle(ledRED);
    2976:	80 e0       	ldi	r24, 0x00	; 0
    2978:	90 e0       	ldi	r25, 0x00	; 0
    297a:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <vLED_toggle>
    297e:	fb cf       	rjmp	.-10     	; 0x2976 <vApplicationStackOverflowHook+0x2>

00002980 <main>:

/*  Main function   */
int main(void){
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */
    vLED_init();
    2980:	0e 94 31 0c 	call	0x1862	; 0x1862 <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    2984:	80 e0       	ldi	r24, 0x00	; 0
    2986:	90 e0       	ldi	r25, 0x00	; 0
    2988:	0e 94 37 0c 	call	0x186e	; 0x186e <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    298c:	0e 94 51 2f 	call	0x5ea2	; 0x5ea2 <vUSART_init>
    network_init();
    2990:	54 d2       	rcall	.+1192   	; 0x2e3a <network_init>
    arq_init();
    2992:	0e 94 43 01 	call	0x286	; 0x286 <arq_init>
    simple_p_init(server_receiver);
    2996:	84 e1       	ldi	r24, 0x14	; 20
    2998:	90 e2       	ldi	r25, 0x20	; 32
    299a:	0e 94 00 22 	call	0x4400	; 0x4400 <simple_p_init>
        debug("tictoc!\n");
        tic;
    #endif
    
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    299e:	80 e0       	ldi	r24, 0x00	; 0
    29a0:	0e 94 78 21 	call	0x42f0	; 0x42f0 <vServo_init>
    /* Initialize sensors */
    vDistSens_init();
    29a4:	0e 94 e7 07 	call	0xfce	; 0xfce <vDistSens_init>
    /* Initialize motor controller */
    vMotor_init();
    29a8:	05 d1       	rcall	.+522    	; 0x2bb4 <vMotor_init>
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        debug("IMU init..\n");
    #endif
    sIMU_begin(); 
    29aa:	0e 94 a7 0a 	call	0x154e	; 0x154e <sIMU_begin>
    #endif
    
    //vCOM_init();
    
    /* Initialize RTOS utilities  */
    movementQ = xQueueCreate(2,sizeof(uint8_t)); // For sending movements to vMainMovementTask
    29ae:	40 e0       	ldi	r20, 0x00	; 0
    29b0:	61 e0       	ldi	r22, 0x01	; 1
    29b2:	82 e0       	ldi	r24, 0x02	; 2
    29b4:	59 d4       	rcall	.+2226   	; 0x3268 <xQueueGenericCreate>
    29b6:	90 93 cc 19 	sts	0x19CC, r25	; 0x8019cc <movementQ+0x1>
    29ba:	80 93 cb 19 	sts	0x19CB, r24	; 0x8019cb <movementQ>
    poseControllerQ = xQueueCreate(1, sizeof(struct sPolar)); // For setpoints to controller
    29be:	40 e0       	ldi	r20, 0x00	; 0
    29c0:	66 e0       	ldi	r22, 0x06	; 6
    29c2:	81 e0       	ldi	r24, 0x01	; 1
    29c4:	51 d4       	rcall	.+2210   	; 0x3268 <xQueueGenericCreate>
    29c6:	90 93 ca 19 	sts	0x19CA, r25	; 0x8019ca <poseControllerQ+0x1>
    29ca:	80 93 c9 19 	sts	0x19C9, r24	; 0x8019c9 <poseControllerQ>
    scanStatusQ = xQueueCreate(1,sizeof(uint8_t)); // For robot status
    29ce:	40 e0       	ldi	r20, 0x00	; 0
    29d0:	61 e0       	ldi	r22, 0x01	; 1
    29d2:	81 e0       	ldi	r24, 0x01	; 1
    29d4:	49 d4       	rcall	.+2194   	; 0x3268 <xQueueGenericCreate>
    29d6:	90 93 c8 19 	sts	0x19C8, r25	; 0x8019c8 <scanStatusQ+0x1>
    29da:	80 93 c7 19 	sts	0x19C7, r24	; 0x8019c7 <scanStatusQ>
    actuationQ = xQueueCreate(2,sizeof(uint8_t)); // To send variable actuation to motors
    29de:	40 e0       	ldi	r20, 0x00	; 0
    29e0:	61 e0       	ldi	r22, 0x01	; 1
    29e2:	82 e0       	ldi	r24, 0x02	; 2
    29e4:	41 d4       	rcall	.+2178   	; 0x3268 <xQueueGenericCreate>
    29e6:	90 93 c6 19 	sts	0x19C6, r25	; 0x8019c6 <actuationQ+0x1>
    29ea:	80 93 c5 19 	sts	0x19C5, r24	; 0x8019c5 <actuationQ>
    
    xPoseMutex = xSemaphoreCreateMutex(); // Global variables for robot pose. Only updated from estimator, accessed from many
    29ee:	81 e0       	ldi	r24, 0x01	; 1
    29f0:	8d d4       	rcall	.+2330   	; 0x330c <xQueueCreateMutex>
    29f2:	90 93 36 1b 	sts	0x1B36, r25	; 0x801b36 <xPoseMutex+0x1>
    29f6:	80 93 35 1b 	sts	0x1B35, r24	; 0x801b35 <xPoseMutex>
    xUartMutex = xSemaphoreCreateMutex(); // Protected printf with a mutex, may cause fragmented bytes if higher priority task want to print as well
    29fa:	81 e0       	ldi	r24, 0x01	; 1
    29fc:	87 d4       	rcall	.+2318   	; 0x330c <xQueueCreateMutex>
    29fe:	90 93 32 1b 	sts	0x1B32, r25	; 0x801b32 <xUartMutex+0x1>
    2a02:	80 93 31 1b 	sts	0x1B31, r24	; 0x801b31 <xUartMutex>
    xTickMutex = xSemaphoreCreateMutex(); // Global variable to hold robot tick values
    2a06:	81 e0       	ldi	r24, 0x01	; 1
    2a08:	81 d4       	rcall	.+2306   	; 0x330c <xQueueCreateMutex>
    2a0a:	90 93 30 1b 	sts	0x1B30, r25	; 0x801b30 <xTickMutex+0x1>
    2a0e:	80 93 2f 1b 	sts	0x1B2F, r24	; 0x801b2f <xTickMutex>
    
    xControllerBSem = xSemaphoreCreateBinary(); // Estimator to Controller synchronization
    2a12:	43 e0       	ldi	r20, 0x03	; 3
    2a14:	60 e0       	ldi	r22, 0x00	; 0
    2a16:	81 e0       	ldi	r24, 0x01	; 1
    2a18:	27 d4       	rcall	.+2126   	; 0x3268 <xQueueGenericCreate>
    2a1a:	90 93 2e 1b 	sts	0x1B2E, r25	; 0x801b2e <xControllerBSem+0x1>
    2a1e:	80 93 2d 1b 	sts	0x1B2D, r24	; 0x801b2d <xControllerBSem>
    xCommandReadyBSem = xSemaphoreCreateBinary(); // uart ISR to comm task sync
    2a22:	43 e0       	ldi	r20, 0x03	; 3
    2a24:	60 e0       	ldi	r22, 0x00	; 0
    2a26:	81 e0       	ldi	r24, 0x01	; 1
    2a28:	1f d4       	rcall	.+2110   	; 0x3268 <xQueueGenericCreate>
    2a2a:	90 93 34 1b 	sts	0x1B34, r25	; 0x801b34 <xCommandReadyBSem+0x1>
    2a2e:	80 93 33 1b 	sts	0x1B33, r24	; 0x801b33 <xCommandReadyBSem>
    2a32:	a1 2c       	mov	r10, r1
    
    // Todo: Check return variable to ensure RTOS utilities were successfully initialized before continue
    xTaskCreate(vMainMovementTask, "Movement", 300, NULL, 4, NULL); // Independent task, uses ticks from ISR
    2a34:	b1 2c       	mov	r11, r1
    2a36:	c1 2c       	mov	r12, r1
    2a38:	d1 2c       	mov	r13, r1
    2a3a:	e1 2c       	mov	r14, r1
    2a3c:	f1 2c       	mov	r15, r1
    2a3e:	04 e0       	ldi	r16, 0x04	; 4
    2a40:	20 e0       	ldi	r18, 0x00	; 0
    2a42:	30 e0       	ldi	r19, 0x00	; 0
    2a44:	4c e2       	ldi	r20, 0x2C	; 44
    2a46:	51 e0       	ldi	r21, 0x01	; 1
    2a48:	6f e0       	ldi	r22, 0x0F	; 15
    2a4a:	76 e0       	ldi	r23, 0x06	; 6
    2a4c:	8b ee       	ldi	r24, 0xEB	; 235
    2a4e:	9d e0       	ldi	r25, 0x0D	; 13
    2a50:	0e 94 a1 22 	call	0x4542	; 0x4542 <xTaskGenericCreate>
    2a54:	03 e0       	ldi	r16, 0x03	; 3
    xTaskCreate(vMainCommunicationTask, "Comm", 300, NULL, 3, NULL); // Dependant on ISR from UART, sends instructions to other tasks
    2a56:	20 e0       	ldi	r18, 0x00	; 0
    2a58:	30 e0       	ldi	r19, 0x00	; 0
    2a5a:	4c e2       	ldi	r20, 0x2C	; 44
    2a5c:	51 e0       	ldi	r21, 0x01	; 1
    2a5e:	68 e1       	ldi	r22, 0x18	; 24
    2a60:	76 e0       	ldi	r23, 0x06	; 6
    2a62:	82 e1       	ldi	r24, 0x12	; 18
    2a64:	9d e0       	ldi	r25, 0x0D	; 13
    2a66:	0e 94 a1 22 	call	0x4542	; 0x4542 <xTaskGenericCreate>
    2a6a:	02 e0       	ldi	r16, 0x02	; 2
    
    #ifndef COMPASS_CALIBRATE // If compass calibration task is running dont use these tasks
        xTaskCreate(vMainPoseControllerTask, "PoseCon", 300, NULL, 2, NULL); // Dependant on estimator, sends instructions to movement task
    2a6c:	20 e0       	ldi	r18, 0x00	; 0
    2a6e:	30 e0       	ldi	r19, 0x00	; 0
    2a70:	4c e2       	ldi	r20, 0x2C	; 44
    2a72:	51 e0       	ldi	r21, 0x01	; 1
    2a74:	6d e1       	ldi	r22, 0x1D	; 29
    2a76:	76 e0       	ldi	r23, 0x06	; 6
    2a78:	8a e4       	ldi	r24, 0x4A	; 74
    2a7a:	9f e0       	ldi	r25, 0x0F	; 15
    2a7c:	0e 94 a1 22 	call	0x4542	; 0x4542 <xTaskGenericCreate>
    2a80:	05 e0       	ldi	r16, 0x05	; 5
        xTaskCreate(vMainPoseEstimatorTask, "PoseEst", 300, NULL, 5, NULL); // Independent task, uses ticks from ISR
    2a82:	20 e0       	ldi	r18, 0x00	; 0
    2a84:	30 e0       	ldi	r19, 0x00	; 0
    2a86:	4c e2       	ldi	r20, 0x2C	; 44
    2a88:	51 e0       	ldi	r21, 0x01	; 1
    2a8a:	65 e2       	ldi	r22, 0x25	; 37
    2a8c:	76 e0       	ldi	r23, 0x06	; 6
    2a8e:	83 e3       	ldi	r24, 0x33	; 51
    2a90:	92 e1       	ldi	r25, 0x12	; 18
    2a92:	0e 94 a1 22 	call	0x4542	; 0x4542 <xTaskGenericCreate>
    2a96:	01 e0       	ldi	r16, 0x01	; 1
        xTaskCreate(vMainSensorTowerTask,"Tower",300, NULL, 1, NULL); // Independent task, but use pose updates from estimator
    2a98:	20 e0       	ldi	r18, 0x00	; 0
    2a9a:	30 e0       	ldi	r19, 0x00	; 0
    2a9c:	4c e2       	ldi	r20, 0x2C	; 44
    2a9e:	51 e0       	ldi	r21, 0x01	; 1
    2aa0:	6d e2       	ldi	r22, 0x2D	; 45
    2aa2:	76 e0       	ldi	r23, 0x06	; 6
    2aa4:	8c ef       	ldi	r24, 0xFC	; 252
    2aa6:	9d e0       	ldi	r25, 0x0D	; 13
    2aa8:	0e 94 a1 22 	call	0x4542	; 0x4542 <xTaskGenericCreate>
    2aac:	78 94       	sei
        xTaskCreate(compassTask, "compasscal", 3500, NULL, 3, NULL); // Task used for compass calibration, dependant on communication and movement task
    #endif
    
    

    sei();
    2aae:	80 e0       	ldi	r24, 0x00	; 0
    vLED_singleLow(ledRED);
    2ab0:	90 e0       	ldi	r25, 0x00	; 0
    2ab2:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <vLED_singleLow>
    2ab6:	0e 94 dd 26 	call	0x4dba	; 0x4dba <vTaskStartScheduler>
    #ifdef DEBUG
    debug("Starting scheduler ....\n");
    #endif
    /*  Start scheduler */
    vTaskStartScheduler();
    2aba:	c3 e3       	ldi	r28, 0x33	; 51

    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
        debug("RAM fail\n");
    2abc:	d6 e0       	ldi	r29, 0x06	; 6
    2abe:	f8 94       	cli
    /*  Start scheduler */
    vTaskStartScheduler();

    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
    2ac0:	df 93       	push	r29
        debug("RAM fail\n");
    2ac2:	cf 93       	push	r28
    2ac4:	0e 94 07 21 	call	0x420e	; 0x420e <debug>
    2ac8:	0f 90       	pop	r0
    2aca:	0f 90       	pop	r0
    2acc:	f8 cf       	rjmp	.-16     	; 0x2abe <main+0x13e>

00002ace <__vector_4>:
    2ace:	1f 92       	push	r1

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    2ad0:	0f 92       	push	r0
    2ad2:	0f b6       	in	r0, 0x3f	; 63
    2ad4:	0f 92       	push	r0
    2ad6:	11 24       	eor	r1, r1
    2ad8:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    2ada:	80 91 c3 19 	lds	r24, 0x19C3	; 0x8019c3 <gISR_leftWheelTicks>
    2ade:	8f 5f       	subi	r24, 0xFF	; 255
    2ae0:	80 93 c3 19 	sts	0x19C3, r24	; 0x8019c3 <gISR_leftWheelTicks>
}
    2ae4:	8f 91       	pop	r24
    2ae6:	0f 90       	pop	r0
    2ae8:	0f be       	out	0x3f, r0	; 63
    2aea:	0f 90       	pop	r0
    2aec:	1f 90       	pop	r1
    2aee:	18 95       	reti

00002af0 <__vector_3>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    2af0:	1f 92       	push	r1
    2af2:	0f 92       	push	r0
    2af4:	0f b6       	in	r0, 0x3f	; 63
    2af6:	0f 92       	push	r0
    2af8:	11 24       	eor	r1, r1
    2afa:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    2afc:	80 91 c4 19 	lds	r24, 0x19C4	; 0x8019c4 <gISR_rightWheelTicks>
    2b00:	8f 5f       	subi	r24, 0xFF	; 255
    2b02:	80 93 c4 19 	sts	0x19C4, r24	; 0x8019c4 <gISR_rightWheelTicks>
}
    2b06:	8f 91       	pop	r24
    2b08:	0f 90       	pop	r0
    2b0a:	0f be       	out	0x3f, r0	; 63
    2b0c:	0f 90       	pop	r0
    2b0e:	1f 90       	pop	r1
    2b10:	18 95       	reti

00002b12 <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    2b12:	1f 92       	push	r1
    2b14:	0f 92       	push	r0
    2b16:	0f b6       	in	r0, 0x3f	; 63
    2b18:	0f 92       	push	r0
    2b1a:	11 24       	eor	r1, r1
    2b1c:	0b b6       	in	r0, 0x3b	; 59
    2b1e:	0f 92       	push	r0
    2b20:	2f 93       	push	r18
    2b22:	3f 93       	push	r19
    2b24:	4f 93       	push	r20
    2b26:	5f 93       	push	r21
    2b28:	6f 93       	push	r22
    2b2a:	7f 93       	push	r23
    2b2c:	8f 93       	push	r24
    2b2e:	9f 93       	push	r25
    2b30:	af 93       	push	r26
    2b32:	bf 93       	push	r27
    2b34:	ef 93       	push	r30
    2b36:	ff 93       	push	r31
    if (nRFconnected){
    2b38:	64 99       	sbic	0x0c, 4	; 12
    2b3a:	09 c0       	rjmp	.+18     	; 0x2b4e <__vector_5+0x3c>
        // indicate we are connected
        vLED_singleHigh(ledGREEN);
    2b3c:	82 e0       	ldi	r24, 0x02	; 2
    2b3e:	90 e0       	ldi	r25, 0x00	; 0
    2b40:	0e 94 37 0c 	call	0x186e	; 0x186e <vLED_singleHigh>
        vLED_singleHigh(ledYELLOW);
    2b44:	81 e0       	ldi	r24, 0x01	; 1
    2b46:	90 e0       	ldi	r25, 0x00	; 0
    2b48:	0e 94 37 0c 	call	0x186e	; 0x186e <vLED_singleHigh>
    2b4c:	18 c0       	rjmp	.+48     	; 0x2b7e <__vector_5+0x6c>
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    2b4e:	10 92 c2 19 	sts	0x19C2, r1	; 0x8019c2 <gHandshook>
        gPaused = FALSE;
    2b52:	10 92 c1 19 	sts	0x19C1, r1	; 0x8019c1 <gPaused>
        vLED_singleLow(ledGREEN);
    2b56:	82 e0       	ldi	r24, 0x02	; 2
    2b58:	90 e0       	ldi	r25, 0x00	; 0
    2b5a:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <vLED_singleLow>
        vLED_singleLow(ledYELLOW);
    2b5e:	81 e0       	ldi	r24, 0x01	; 1
    2b60:	90 e0       	ldi	r25, 0x00	; 0
    2b62:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <vLED_singleLow>
        vLED_singleLow(ledRED);
    2b66:	80 e0       	ldi	r24, 0x00	; 0
    2b68:	90 e0       	ldi	r25, 0x00	; 0
    2b6a:	0e 94 51 0c 	call	0x18a2	; 0x18a2 <vLED_singleLow>
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    2b6e:	60 e0       	ldi	r22, 0x00	; 0
    2b70:	70 e0       	ldi	r23, 0x00	; 0
    2b72:	80 91 33 1b 	lds	r24, 0x1B33	; 0x801b33 <xCommandReadyBSem>
    2b76:	90 91 34 1b 	lds	r25, 0x1B34	; 0x801b34 <xCommandReadyBSem+0x1>
    2b7a:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <xQueueGiveFromISR>
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    2b7e:	60 e0       	ldi	r22, 0x00	; 0
    2b80:	70 e0       	ldi	r23, 0x00	; 0
    2b82:	80 91 2d 1b 	lds	r24, 0x1B2D	; 0x801b2d <xControllerBSem>
    2b86:	90 91 2e 1b 	lds	r25, 0x1B2E	; 0x801b2e <xControllerBSem+0x1>
    2b8a:	0e 94 49 1e 	call	0x3c92	; 0x3c92 <xQueueGiveFromISR>
}
    2b8e:	ff 91       	pop	r31
    2b90:	ef 91       	pop	r30
    2b92:	bf 91       	pop	r27
    2b94:	af 91       	pop	r26
    2b96:	9f 91       	pop	r25
    2b98:	8f 91       	pop	r24
    2b9a:	7f 91       	pop	r23
    2b9c:	6f 91       	pop	r22
    2b9e:	5f 91       	pop	r21
    2ba0:	4f 91       	pop	r20
    2ba2:	3f 91       	pop	r19
    2ba4:	2f 91       	pop	r18
    2ba6:	0f 90       	pop	r0
    2ba8:	0b be       	out	0x3b, r0	; 59
    2baa:	0f 90       	pop	r0
    2bac:	0f be       	out	0x3f, r0	; 63
    2bae:	0f 90       	pop	r0
    2bb0:	1f 90       	pop	r1
    2bb2:	18 95       	reti

00002bb4 <vMotor_init>:

void vMotorGlideRight(){
    motorRightPWM = 0;
    //PORTH &= ~(1<<motorRightOn);
    PORTH &= ~(1<<motorRightForward);
    PORTH &= ~(1<<motorRightBackward);
    2bb4:	27 9a       	sbi	0x04, 7	; 4
    2bb6:	84 b1       	in	r24, 0x04	; 4
    2bb8:	80 63       	ori	r24, 0x30	; 48
    2bba:	84 b9       	out	0x04, r24	; 4
    2bbc:	26 9a       	sbi	0x04, 6	; 4
    2bbe:	e1 e0       	ldi	r30, 0x01	; 1
    2bc0:	f1 e0       	ldi	r31, 0x01	; 1
    2bc2:	80 81       	ld	r24, Z
    2bc4:	80 66       	ori	r24, 0x60	; 96
    2bc6:	80 83       	st	Z, r24
    2bc8:	2f 98       	cbi	0x05, 7	; 5
    2bca:	2e 98       	cbi	0x05, 6	; 5
    2bcc:	e2 e0       	ldi	r30, 0x02	; 2
    2bce:	f1 e0       	ldi	r31, 0x01	; 1
    2bd0:	80 81       	ld	r24, Z
    2bd2:	8f 79       	andi	r24, 0x9F	; 159
    2bd4:	80 83       	st	Z, r24
    2bd6:	85 b1       	in	r24, 0x05	; 5
    2bd8:	8f 7c       	andi	r24, 0xCF	; 207
    2bda:	85 b9       	out	0x05, r24	; 5
    2bdc:	8a b1       	in	r24, 0x0a	; 10
    2bde:	8a b9       	out	0x0a, r24	; 10
    2be0:	8b b1       	in	r24, 0x0b	; 11
    2be2:	8c 60       	ori	r24, 0x0C	; 12
    2be4:	8b b9       	out	0x0b, r24	; 11
    2be6:	6c 98       	cbi	0x0d, 4	; 13
    2be8:	8d b3       	in	r24, 0x1d	; 29
    2bea:	8d bb       	out	0x1d, r24	; 29
    2bec:	e9 e6       	ldi	r30, 0x69	; 105
    2bee:	f0 e0       	ldi	r31, 0x00	; 0
    2bf0:	80 81       	ld	r24, Z
    2bf2:	80 6f       	ori	r24, 0xF0	; 240
    2bf4:	80 83       	st	Z, r24
    2bf6:	ea e6       	ldi	r30, 0x6A	; 106
    2bf8:	f0 e0       	ldi	r31, 0x00	; 0
    2bfa:	80 81       	ld	r24, Z
    2bfc:	81 60       	ori	r24, 0x01	; 1
    2bfe:	80 83       	st	Z, r24
    2c00:	8c e1       	ldi	r24, 0x1C	; 28
    2c02:	8c bb       	out	0x1c, r24	; 28
    2c04:	8d b3       	in	r24, 0x1d	; 29
    2c06:	8c 61       	ori	r24, 0x1C	; 28
    2c08:	8d bb       	out	0x1d, r24	; 29
    2c0a:	84 b5       	in	r24, 0x24	; 36
    2c0c:	80 68       	ori	r24, 0x80	; 128
    2c0e:	84 bd       	out	0x24, r24	; 36
    2c10:	e0 e8       	ldi	r30, 0x80	; 128
    2c12:	f0 e0       	ldi	r31, 0x00	; 0
    2c14:	80 81       	ld	r24, Z
    2c16:	80 62       	ori	r24, 0x20	; 32
    2c18:	80 83       	st	Z, r24
    2c1a:	85 b5       	in	r24, 0x25	; 37
    2c1c:	85 bd       	out	0x25, r24	; 37
    2c1e:	84 b5       	in	r24, 0x24	; 36
    2c20:	83 60       	ori	r24, 0x03	; 3
    2c22:	84 bd       	out	0x24, r24	; 36
    2c24:	a1 e8       	ldi	r26, 0x81	; 129
    2c26:	b0 e0       	ldi	r27, 0x00	; 0
    2c28:	8c 91       	ld	r24, X
    2c2a:	88 60       	ori	r24, 0x08	; 8
    2c2c:	8c 93       	st	X, r24
    2c2e:	80 81       	ld	r24, Z
    2c30:	81 60       	ori	r24, 0x01	; 1
    2c32:	80 83       	st	Z, r24
    2c34:	85 b5       	in	r24, 0x25	; 37
    2c36:	82 60       	ori	r24, 0x02	; 2
    2c38:	85 bd       	out	0x25, r24	; 37
    2c3a:	8c 91       	ld	r24, X
    2c3c:	82 60       	ori	r24, 0x02	; 2
    2c3e:	8c 93       	st	X, r24
    2c40:	80 81       	ld	r24, Z
    2c42:	80 83       	st	Z, r24
    2c44:	e0 eb       	ldi	r30, 0xB0	; 176
    2c46:	f0 e0       	ldi	r31, 0x00	; 0
    2c48:	80 81       	ld	r24, Z
    2c4a:	80 83       	st	Z, r24
    2c4c:	80 81       	ld	r24, Z
    2c4e:	80 83       	st	Z, r24
    2c50:	e0 ea       	ldi	r30, 0xA0	; 160
    2c52:	f0 e0       	ldi	r31, 0x00	; 0
    2c54:	80 81       	ld	r24, Z
    2c56:	80 83       	st	Z, r24
    2c58:	08 95       	ret

00002c5a <vMotorMoveLeftForward>:
    2c5a:	87 bd       	out	0x27, r24	; 39
    2c5c:	2c 9a       	sbi	0x05, 4	; 5
    2c5e:	2d 98       	cbi	0x05, 5	; 5
    2c60:	84 e0       	ldi	r24, 0x04	; 4
    2c62:	fb 01       	movw	r30, r22
    2c64:	80 83       	st	Z, r24
    2c66:	08 95       	ret

00002c68 <vMotorMoveRightForward>:
    2c68:	90 e0       	ldi	r25, 0x00	; 0
    2c6a:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    2c6e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    2c72:	e2 e0       	ldi	r30, 0x02	; 2
    2c74:	f1 e0       	ldi	r31, 0x01	; 1
    2c76:	80 81       	ld	r24, Z
    2c78:	80 64       	ori	r24, 0x40	; 64
    2c7a:	80 83       	st	Z, r24
    2c7c:	80 81       	ld	r24, Z
    2c7e:	8f 7d       	andi	r24, 0xDF	; 223
    2c80:	80 83       	st	Z, r24
    2c82:	86 e0       	ldi	r24, 0x06	; 6
    2c84:	fb 01       	movw	r30, r22
    2c86:	80 83       	st	Z, r24
    2c88:	08 95       	ret

00002c8a <vMotorMoveLeftBackward>:
    2c8a:	87 bd       	out	0x27, r24	; 39
    2c8c:	2c 98       	cbi	0x05, 4	; 5
    2c8e:	2d 9a       	sbi	0x05, 5	; 5
    2c90:	85 e0       	ldi	r24, 0x05	; 5
    2c92:	fb 01       	movw	r30, r22
    2c94:	80 83       	st	Z, r24
    2c96:	08 95       	ret

00002c98 <vMotorMoveRightBackward>:
    2c98:	90 e0       	ldi	r25, 0x00	; 0
    2c9a:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    2c9e:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    2ca2:	e2 e0       	ldi	r30, 0x02	; 2
    2ca4:	f1 e0       	ldi	r31, 0x01	; 1
    2ca6:	80 81       	ld	r24, Z
    2ca8:	8f 7b       	andi	r24, 0xBF	; 191
    2caa:	80 83       	st	Z, r24
    2cac:	80 81       	ld	r24, Z
    2cae:	80 62       	ori	r24, 0x20	; 32
    2cb0:	80 83       	st	Z, r24
    2cb2:	85 e0       	ldi	r24, 0x05	; 5
    2cb4:	fb 01       	movw	r30, r22
    2cb6:	80 83       	st	Z, r24
    2cb8:	08 95       	ret

00002cba <vMotorBrakeLeft>:
    2cba:	8f ef       	ldi	r24, 0xFF	; 255
    2cbc:	87 bd       	out	0x27, r24	; 39
    2cbe:	2c 98       	cbi	0x05, 4	; 5
    2cc0:	2d 98       	cbi	0x05, 5	; 5
    2cc2:	08 95       	ret

00002cc4 <vMotorBrakeRight>:
    2cc4:	8f ef       	ldi	r24, 0xFF	; 255
    2cc6:	90 e0       	ldi	r25, 0x00	; 0
    2cc8:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    2ccc:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    2cd0:	e2 e0       	ldi	r30, 0x02	; 2
    2cd2:	f1 e0       	ldi	r31, 0x01	; 1
    2cd4:	80 81       	ld	r24, Z
    2cd6:	8f 7b       	andi	r24, 0xBF	; 191
    2cd8:	80 83       	st	Z, r24
    2cda:	80 81       	ld	r24, Z
    2cdc:	8f 7d       	andi	r24, 0xDF	; 223
    2cde:	80 83       	st	Z, r24
    2ce0:	08 95       	ret

00002ce2 <vMotorMovementSwitch>:
}

/* Switch for robot movement to abstract the logic away from main */

void vMotorMovementSwitch(int16_t leftSpeed, int16_t rightSpeed, uint8_t *leftWheelDirection, uint8_t *rightWheelDirection){
    2ce2:	0f 93       	push	r16
    2ce4:	1f 93       	push	r17
    2ce6:	cf 93       	push	r28
    2ce8:	df 93       	push	r29
    2cea:	eb 01       	movw	r28, r22
    2cec:	89 01       	movw	r16, r18
    if (leftSpeed > 0){
    2cee:	18 16       	cp	r1, r24
    2cf0:	19 06       	cpc	r1, r25
    2cf2:	1c f4       	brge	.+6      	; 0x2cfa <vMotorMovementSwitch+0x18>
		vMotorMoveLeftForward(leftSpeed, leftWheelDirection);
    2cf4:	ba 01       	movw	r22, r20
    2cf6:	b1 df       	rcall	.-158    	; 0x2c5a <vMotorMoveLeftForward>
    2cf8:	07 c0       	rjmp	.+14     	; 0x2d08 <vMotorMovementSwitch+0x26>
    }else if(leftSpeed < 0){
    2cfa:	99 23       	and	r25, r25
    2cfc:	24 f4       	brge	.+8      	; 0x2d06 <vMotorMovementSwitch+0x24>
		vMotorMoveLeftBackward(-leftSpeed,leftWheelDirection);
    2cfe:	ba 01       	movw	r22, r20
    2d00:	81 95       	neg	r24
    2d02:	c3 df       	rcall	.-122    	; 0x2c8a <vMotorMoveLeftBackward>
    }else{
		vMotorBrakeLeft();
    2d04:	01 c0       	rjmp	.+2      	; 0x2d08 <vMotorMovementSwitch+0x26>
    2d06:	d9 df       	rcall	.-78     	; 0x2cba <vMotorBrakeLeft>
	}
	
	if (rightSpeed > 0) {
    2d08:	1c 16       	cp	r1, r28
    2d0a:	1d 06       	cpc	r1, r29
		vMotorMoveRightForward(rightSpeed,rightWheelDirection);
    2d0c:	24 f4       	brge	.+8      	; 0x2d16 <vMotorMovementSwitch+0x34>
    2d0e:	b8 01       	movw	r22, r16
    2d10:	8c 2f       	mov	r24, r28
    2d12:	aa df       	rcall	.-172    	; 0x2c68 <vMotorMoveRightForward>
    2d14:	08 c0       	rjmp	.+16     	; 0x2d26 <vMotorMovementSwitch+0x44>
	}else if (rightSpeed < 0) {
    2d16:	dd 23       	and	r29, r29
		vMotorMoveRightBackward(-rightSpeed,rightWheelDirection);
    2d18:	2c f4       	brge	.+10     	; 0x2d24 <vMotorMovementSwitch+0x42>
    2d1a:	b8 01       	movw	r22, r16
    2d1c:	8c 2f       	mov	r24, r28
    2d1e:	81 95       	neg	r24
    2d20:	bb df       	rcall	.-138    	; 0x2c98 <vMotorMoveRightBackward>
	}else {
		vMotorBrakeRight();
    2d22:	01 c0       	rjmp	.+2      	; 0x2d26 <vMotorMovementSwitch+0x44>
    2d24:	cf df       	rcall	.-98     	; 0x2cc4 <vMotorBrakeRight>
	
	
	
	

}
    2d26:	df 91       	pop	r29
    2d28:	cf 91       	pop	r28
    2d2a:	1f 91       	pop	r17
    2d2c:	0f 91       	pop	r16
    2d2e:	08 95       	ret

00002d30 <vMotorEncoderLeftTickFromISR>:

/* Handle ISR ticks from encoder, Please note that we are losing accuracy here due to division */
void vMotorEncoderLeftTickFromISR(uint8_t wheelDirection, int16_t *leftWheelTicks, uint8_t leftEncoderTicks){
    switch (wheelDirection){
    2d30:	84 30       	cpi	r24, 0x04	; 4
    2d32:	19 f0       	breq	.+6      	; 0x2d3a <vMotorEncoderLeftTickFromISR+0xa>
    2d34:	85 30       	cpi	r24, 0x05	; 5
    2d36:	51 f0       	breq	.+20     	; 0x2d4c <vMotorEncoderLeftTickFromISR+0x1c>
    2d38:	08 95       	ret
        case motorLeftForward:{
            *leftWheelTicks += leftEncoderTicks / 2;
    2d3a:	46 95       	lsr	r20
    2d3c:	fb 01       	movw	r30, r22
    2d3e:	80 81       	ld	r24, Z
    2d40:	91 81       	ldd	r25, Z+1	; 0x01
    2d42:	84 0f       	add	r24, r20
    2d44:	91 1d       	adc	r25, r1
    2d46:	91 83       	std	Z+1, r25	; 0x01
    2d48:	80 83       	st	Z, r24
            break;
    2d4a:	08 95       	ret
        }
        case  motorLeftBackward:{
            *leftWheelTicks -= leftEncoderTicks / 2;
    2d4c:	46 95       	lsr	r20
    2d4e:	fb 01       	movw	r30, r22
    2d50:	80 81       	ld	r24, Z
    2d52:	91 81       	ldd	r25, Z+1	; 0x01
    2d54:	84 1b       	sub	r24, r20
    2d56:	91 09       	sbc	r25, r1
    2d58:	91 83       	std	Z+1, r25	; 0x01
    2d5a:	80 83       	st	Z, r24
    2d5c:	08 95       	ret

00002d5e <vMotorEncoderRightTickFromISR>:
        // We have a count when the robot is supposedly not moving.
        break;
    }
}
void vMotorEncoderRightTickFromISR(uint8_t wheelDirection, int16_t *rightWheelTicks, uint8_t rightEncoderTicks){
    switch (wheelDirection){
    2d5e:	85 30       	cpi	r24, 0x05	; 5
    2d60:	59 f0       	breq	.+22     	; 0x2d78 <vMotorEncoderRightTickFromISR+0x1a>
    2d62:	86 30       	cpi	r24, 0x06	; 6
    2d64:	89 f4       	brne	.+34     	; 0x2d88 <vMotorEncoderRightTickFromISR+0x2a>
        case motorRightForward:{
            *rightWheelTicks += rightEncoderTicks / 2;
    2d66:	46 95       	lsr	r20
    2d68:	fb 01       	movw	r30, r22
    2d6a:	80 81       	ld	r24, Z
    2d6c:	91 81       	ldd	r25, Z+1	; 0x01
    2d6e:	84 0f       	add	r24, r20
    2d70:	91 1d       	adc	r25, r1
    2d72:	91 83       	std	Z+1, r25	; 0x01
    2d74:	80 83       	st	Z, r24
            break;
    2d76:	08 95       	ret
        }
        case  motorRightBackward:{
            *rightWheelTicks -= rightEncoderTicks / 2;
    2d78:	46 95       	lsr	r20
    2d7a:	fb 01       	movw	r30, r22
    2d7c:	80 81       	ld	r24, Z
    2d7e:	91 81       	ldd	r25, Z+1	; 0x01
    2d80:	84 1b       	sub	r24, r20
    2d82:	91 09       	sbc	r25, r1
    2d84:	91 83       	std	Z+1, r25	; 0x01
    2d86:	80 83       	st	Z, r24
    2d88:	08 95       	ret

00002d8a <network_receive>:

uint8_t network_get_address(void) {
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
    2d8a:	ef 92       	push	r14
    2d8c:	ff 92       	push	r15
    2d8e:	0f 93       	push	r16
    2d90:	1f 93       	push	r17
    2d92:	cf 93       	push	r28
    2d94:	df 93       	push	r29
    2d96:	7c 01       	movw	r14, r24
    2d98:	8b 01       	movw	r16, r22
   uint8_t *decoded_data = pvPortMalloc(len);
    2d9a:	cb 01       	movw	r24, r22
    2d9c:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    2da0:	ec 01       	movw	r28, r24
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    2da2:	98 01       	movw	r18, r16
    2da4:	21 50       	subi	r18, 0x01	; 1
    2da6:	31 09       	sbc	r19, r1
    2da8:	a7 01       	movw	r20, r14
    2daa:	b8 01       	movw	r22, r16
    2dac:	0e 94 04 07 	call	0xe08	; 0xe08 <cobs_decode>
   static uint8_t cobs = 0;
   static uint8_t crc = 0;
   if(result.status != COBS_DECODE_OK) {
    2db0:	88 23       	and	r24, r24
    2db2:	49 f0       	breq	.+18     	; 0x2dc6 <network_receive+0x3c>
	   ++cobs;
    2db4:	80 91 ce 19 	lds	r24, 0x19CE	; 0x8019ce <cobs.2024>
    2db8:	8f 5f       	subi	r24, 0xFF	; 255
    2dba:	80 93 ce 19 	sts	0x19CE, r24	; 0x8019ce <cobs.2024>
	   vPortFree(decoded_data);
    2dbe:	ce 01       	movw	r24, r28
    2dc0:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
	   return;
    2dc4:	33 c0       	rjmp	.+102    	; 0x2e2c <network_receive+0xa2>
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
   uint8_t *decoded_data = pvPortMalloc(len);
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    2dc6:	86 2f       	mov	r24, r22
    2dc8:	97 2f       	mov	r25, r23
    2dca:	8c 01       	movw	r16, r24
   if(result.status != COBS_DECODE_OK) {
	   ++cobs;
	   vPortFree(decoded_data);
	   return;
   }
   if(decoded_data[result.out_len-1] != calculate_crc(decoded_data, result.out_len-1) ) {
    2dcc:	fe 01       	movw	r30, r28
    2dce:	e8 0f       	add	r30, r24
    2dd0:	f9 1f       	adc	r31, r25
    2dd2:	31 97       	sbiw	r30, 0x01	; 1
    2dd4:	f0 80       	ld	r15, Z
    2dd6:	6f ef       	ldi	r22, 0xFF	; 255
    2dd8:	68 0f       	add	r22, r24
    2dda:	ce 01       	movw	r24, r28
    2ddc:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <calculate_crc>
    2de0:	f8 16       	cp	r15, r24
    2de2:	49 f0       	breq	.+18     	; 0x2df6 <network_receive+0x6c>
	   ++crc;
    2de4:	80 91 cd 19 	lds	r24, 0x19CD	; 0x8019cd <crc.2025>
    2de8:	8f 5f       	subi	r24, 0xFF	; 255
    2dea:	80 93 cd 19 	sts	0x19CD, r24	; 0x8019cd <crc.2025>
	   vPortFree(decoded_data);
    2dee:	ce 01       	movw	r24, r28
    2df0:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
	   return;
    2df4:	1b c0       	rjmp	.+54     	; 0x2e2c <network_receive+0xa2>
   }
   uint8_t receiver = decoded_data[0];
   uint8_t sender = decoded_data[1];
   uint8_t protocol = decoded_data[2];
   if(receiver != ADDRESS) {
    2df6:	88 81       	ld	r24, Y
    2df8:	83 30       	cpi	r24, 0x03	; 3
    2dfa:	21 f0       	breq	.+8      	; 0x2e04 <network_receive+0x7a>
	   vPortFree(decoded_data);
    2dfc:	ce 01       	movw	r24, r28
    2dfe:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
	   return;
    2e02:	14 c0       	rjmp	.+40     	; 0x2e2c <network_receive+0xa2>
   }
   receive_callbacks[protocol](sender, decoded_data+3, result.out_len-4);
    2e04:	a8 01       	movw	r20, r16
    2e06:	44 50       	subi	r20, 0x04	; 4
    2e08:	51 09       	sbc	r21, r1
    2e0a:	be 01       	movw	r22, r28
    2e0c:	6d 5f       	subi	r22, 0xFD	; 253
    2e0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2e10:	ea 81       	ldd	r30, Y+2	; 0x02
    2e12:	f0 e0       	ldi	r31, 0x00	; 0
    2e14:	ee 0f       	add	r30, r30
    2e16:	ff 1f       	adc	r31, r31
    2e18:	eb 5a       	subi	r30, 0xAB	; 171
    2e1a:	f4 4e       	sbci	r31, 0xE4	; 228
    2e1c:	01 90       	ld	r0, Z+
    2e1e:	f0 81       	ld	r31, Z
    2e20:	e0 2d       	mov	r30, r0
    2e22:	89 81       	ldd	r24, Y+1	; 0x01
    2e24:	19 95       	eicall
   vPortFree(decoded_data);
    2e26:	ce 01       	movw	r24, r28
    2e28:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
}
    2e2c:	df 91       	pop	r29
    2e2e:	cf 91       	pop	r28
    2e30:	1f 91       	pop	r17
    2e32:	0f 91       	pop	r16
    2e34:	ff 90       	pop	r15
    2e36:	ef 90       	pop	r14
    2e38:	08 95       	ret

00002e3a <network_init>:
void network_receive(uint8_t *frame, uint16_t len);

void (*receive_callbacks[10])(uint8_t, uint8_t*, uint16_t);

void network_init(void) {
  vUSART_set_receive_callback(network_receive);
    2e3a:	85 ec       	ldi	r24, 0xC5	; 197
    2e3c:	96 e1       	ldi	r25, 0x16	; 22
    2e3e:	0c 94 c2 2f 	jmp	0x5f84	; 0x5f84 <vUSART_set_receive_callback>
    2e42:	08 95       	ret

00002e44 <network_set_callback>:
}

void network_set_callback(uint8_t protocol, void (*cb)(uint8_t, uint8_t*, uint16_t)) {
  if(protocol == PROTOCOL_ARQ || protocol == PROTOCOL_SIMPLE) receive_callbacks[protocol] = cb;
    2e44:	82 30       	cpi	r24, 0x02	; 2
    2e46:	40 f4       	brcc	.+16     	; 0x2e58 <network_set_callback+0x14>
    2e48:	e8 2f       	mov	r30, r24
    2e4a:	f0 e0       	ldi	r31, 0x00	; 0
    2e4c:	ee 0f       	add	r30, r30
    2e4e:	ff 1f       	adc	r31, r31
    2e50:	eb 5a       	subi	r30, 0xAB	; 171
    2e52:	f4 4e       	sbci	r31, 0xE4	; 228
    2e54:	71 83       	std	Z+1, r23	; 0x01
    2e56:	60 83       	st	Z, r22
    2e58:	08 95       	ret

00002e5a <network_send>:
}
    
uint8_t network_send(uint8_t remote_address, uint8_t protocol, uint8_t *data, uint16_t len) {
    2e5a:	8f 92       	push	r8
    2e5c:	9f 92       	push	r9
    2e5e:	af 92       	push	r10
    2e60:	bf 92       	push	r11
    2e62:	cf 92       	push	r12
    2e64:	df 92       	push	r13
    2e66:	ef 92       	push	r14
    2e68:	ff 92       	push	r15
    2e6a:	0f 93       	push	r16
    2e6c:	1f 93       	push	r17
    2e6e:	cf 93       	push	r28
    2e70:	df 93       	push	r29
    2e72:	88 2e       	mov	r8, r24
    2e74:	96 2e       	mov	r9, r22
    2e76:	5a 01       	movw	r10, r20
    2e78:	89 01       	movw	r16, r18
  uint8_t *packet = pvPortMalloc(len+4);
    2e7a:	69 01       	movw	r12, r18
    2e7c:	84 e0       	ldi	r24, 0x04	; 4
    2e7e:	c8 0e       	add	r12, r24
    2e80:	d1 1c       	adc	r13, r1
    2e82:	c6 01       	movw	r24, r12
    2e84:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    2e88:	ec 01       	movw	r28, r24
  uint8_t *encoded_data = pvPortMalloc(len+6);
    2e8a:	c8 01       	movw	r24, r16
    2e8c:	06 96       	adiw	r24, 0x06	; 6
    2e8e:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    2e92:	7c 01       	movw	r14, r24
  if(packet == NULL || encoded_data == NULL) {
    2e94:	20 97       	sbiw	r28, 0x00	; 0
    2e96:	11 f0       	breq	.+4      	; 0x2e9c <network_send+0x42>
    2e98:	89 2b       	or	r24, r25
    2e9a:	41 f4       	brne	.+16     	; 0x2eac <network_send+0x52>
    vPortFree(packet);
    2e9c:	ce 01       	movw	r24, r28
    2e9e:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
    vPortFree(encoded_data);
    2ea2:	c7 01       	movw	r24, r14
    2ea4:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
    return 0;
    2ea8:	80 e0       	ldi	r24, 0x00	; 0
    2eaa:	3c c0       	rjmp	.+120    	; 0x2f24 <network_send+0xca>
  }
  packet[0] = remote_address;
    2eac:	88 82       	st	Y, r8
  packet[1] = ADDRESS;
    2eae:	83 e0       	ldi	r24, 0x03	; 3
    2eb0:	89 83       	std	Y+1, r24	; 0x01
  packet[2] = protocol;
    2eb2:	9a 82       	std	Y+2, r9	; 0x02
  memcpy(packet+3, data, len);
    2eb4:	a8 01       	movw	r20, r16
    2eb6:	b5 01       	movw	r22, r10
    2eb8:	ce 01       	movw	r24, r28
    2eba:	03 96       	adiw	r24, 0x03	; 3
    2ebc:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
  packet[3+len] = calculate_crc(packet, 3+len);
    2ec0:	58 01       	movw	r10, r16
    2ec2:	e3 e0       	ldi	r30, 0x03	; 3
    2ec4:	ae 0e       	add	r10, r30
    2ec6:	b1 1c       	adc	r11, r1
    2ec8:	ac 0e       	add	r10, r28
    2eca:	bd 1e       	adc	r11, r29
    2ecc:	63 e0       	ldi	r22, 0x03	; 3
    2ece:	60 0f       	add	r22, r16
    2ed0:	ce 01       	movw	r24, r28
    2ed2:	0e 94 d0 07 	call	0xfa0	; 0xfa0 <calculate_crc>
    2ed6:	f5 01       	movw	r30, r10
    2ed8:	80 83       	st	Z, r24
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    2eda:	b8 01       	movw	r22, r16
    2edc:	6b 5f       	subi	r22, 0xFB	; 251
    2ede:	7f 4f       	sbci	r23, 0xFF	; 255
    2ee0:	96 01       	movw	r18, r12
    2ee2:	ae 01       	movw	r20, r28
    2ee4:	c7 01       	movw	r24, r14
    2ee6:	0e 94 9e 06 	call	0xd3c	; 0xd3c <cobs_encode>
  if(result.status != COBS_ENCODE_OK) {
    2eea:	88 23       	and	r24, r24
    2eec:	41 f0       	breq	.+16     	; 0x2efe <network_send+0xa4>
    vPortFree(packet);
    2eee:	ce 01       	movw	r24, r28
    2ef0:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
    vPortFree(encoded_data);
    2ef4:	c7 01       	movw	r24, r14
    2ef6:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
    return 0;
    2efa:	80 e0       	ldi	r24, 0x00	; 0
    2efc:	13 c0       	rjmp	.+38     	; 0x2f24 <network_send+0xca>
  packet[0] = remote_address;
  packet[1] = ADDRESS;
  packet[2] = protocol;
  memcpy(packet+3, data, len);
  packet[3+len] = calculate_crc(packet, 3+len);
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    2efe:	86 2f       	mov	r24, r22
    2f00:	97 2f       	mov	r25, r23
  if(result.status != COBS_ENCODE_OK) {
    vPortFree(packet);
    vPortFree(encoded_data);
    return 0;
  }
  encoded_data[result.out_len] = 0x00;
    2f02:	f7 01       	movw	r30, r14
    2f04:	e8 0f       	add	r30, r24
    2f06:	f9 1f       	adc	r31, r25
    2f08:	10 82       	st	Z, r1
  vUSART_send(encoded_data, result.out_len+1);
    2f0a:	bc 01       	movw	r22, r24
    2f0c:	6f 5f       	subi	r22, 0xFF	; 255
    2f0e:	7f 4f       	sbci	r23, 0xFF	; 255
    2f10:	c7 01       	movw	r24, r14
    2f12:	0e 94 9e 2f 	call	0x5f3c	; 0x5f3c <vUSART_send>
  vPortFree(packet);
    2f16:	ce 01       	movw	r24, r28
    2f18:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
  vPortFree(encoded_data);
    2f1c:	c7 01       	movw	r24, r14
    2f1e:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
  return 1;
    2f22:	81 e0       	ldi	r24, 0x01	; 1
}
    2f24:	df 91       	pop	r29
    2f26:	cf 91       	pop	r28
    2f28:	1f 91       	pop	r17
    2f2a:	0f 91       	pop	r16
    2f2c:	ff 90       	pop	r15
    2f2e:	ef 90       	pop	r14
    2f30:	df 90       	pop	r13
    2f32:	cf 90       	pop	r12
    2f34:	bf 90       	pop	r11
    2f36:	af 90       	pop	r10
    2f38:	9f 90       	pop	r9
    2f3a:	8f 90       	pop	r8
    2f3c:	08 95       	ret

00002f3e <pxPortInitialiseStack>:
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    2f3e:	31 e1       	ldi	r19, 0x11	; 17
    2f40:	fc 01       	movw	r30, r24
    2f42:	30 83       	st	Z, r19
    2f44:	31 97       	sbiw	r30, 0x01	; 1
    2f46:	22 e2       	ldi	r18, 0x22	; 34
    2f48:	20 83       	st	Z, r18
    2f4a:	31 97       	sbiw	r30, 0x01	; 1
    2f4c:	a3 e3       	ldi	r26, 0x33	; 51
    2f4e:	a0 83       	st	Z, r26
    2f50:	31 97       	sbiw	r30, 0x01	; 1
    2f52:	60 83       	st	Z, r22
    2f54:	31 97       	sbiw	r30, 0x01	; 1
    2f56:	70 83       	st	Z, r23
    2f58:	31 97       	sbiw	r30, 0x01	; 1
    2f5a:	10 82       	st	Z, r1
    2f5c:	31 97       	sbiw	r30, 0x01	; 1
    2f5e:	10 82       	st	Z, r1
    2f60:	31 97       	sbiw	r30, 0x01	; 1
    2f62:	60 e8       	ldi	r22, 0x80	; 128
    2f64:	60 83       	st	Z, r22
    2f66:	31 97       	sbiw	r30, 0x01	; 1
    2f68:	10 82       	st	Z, r1
    2f6a:	31 97       	sbiw	r30, 0x01	; 1
    2f6c:	10 82       	st	Z, r1
    2f6e:	31 97       	sbiw	r30, 0x01	; 1
    2f70:	10 82       	st	Z, r1
    2f72:	31 97       	sbiw	r30, 0x01	; 1
    2f74:	62 e0       	ldi	r22, 0x02	; 2
    2f76:	60 83       	st	Z, r22
    2f78:	31 97       	sbiw	r30, 0x01	; 1
    2f7a:	63 e0       	ldi	r22, 0x03	; 3
    2f7c:	60 83       	st	Z, r22
    2f7e:	31 97       	sbiw	r30, 0x01	; 1
    2f80:	64 e0       	ldi	r22, 0x04	; 4
    2f82:	60 83       	st	Z, r22
    2f84:	31 97       	sbiw	r30, 0x01	; 1
    2f86:	65 e0       	ldi	r22, 0x05	; 5
    2f88:	60 83       	st	Z, r22
    2f8a:	31 97       	sbiw	r30, 0x01	; 1
    2f8c:	66 e0       	ldi	r22, 0x06	; 6
    2f8e:	60 83       	st	Z, r22
    2f90:	31 97       	sbiw	r30, 0x01	; 1
    2f92:	67 e0       	ldi	r22, 0x07	; 7
    2f94:	60 83       	st	Z, r22
    2f96:	31 97       	sbiw	r30, 0x01	; 1
    2f98:	68 e0       	ldi	r22, 0x08	; 8
    2f9a:	60 83       	st	Z, r22
    2f9c:	31 97       	sbiw	r30, 0x01	; 1
    2f9e:	69 e0       	ldi	r22, 0x09	; 9
    2fa0:	60 83       	st	Z, r22
    2fa2:	31 97       	sbiw	r30, 0x01	; 1
    2fa4:	60 e1       	ldi	r22, 0x10	; 16
    2fa6:	60 83       	st	Z, r22
    2fa8:	31 97       	sbiw	r30, 0x01	; 1
    2faa:	30 83       	st	Z, r19
    2fac:	31 97       	sbiw	r30, 0x01	; 1
    2fae:	32 e1       	ldi	r19, 0x12	; 18
    2fb0:	30 83       	st	Z, r19
    2fb2:	31 97       	sbiw	r30, 0x01	; 1
    2fb4:	33 e1       	ldi	r19, 0x13	; 19
    2fb6:	30 83       	st	Z, r19
    2fb8:	31 97       	sbiw	r30, 0x01	; 1
    2fba:	34 e1       	ldi	r19, 0x14	; 20
    2fbc:	30 83       	st	Z, r19
    2fbe:	31 97       	sbiw	r30, 0x01	; 1
    2fc0:	35 e1       	ldi	r19, 0x15	; 21
    2fc2:	30 83       	st	Z, r19
    2fc4:	31 97       	sbiw	r30, 0x01	; 1
    2fc6:	36 e1       	ldi	r19, 0x16	; 22
    2fc8:	30 83       	st	Z, r19
    2fca:	31 97       	sbiw	r30, 0x01	; 1
    2fcc:	37 e1       	ldi	r19, 0x17	; 23
    2fce:	30 83       	st	Z, r19
    2fd0:	31 97       	sbiw	r30, 0x01	; 1
    2fd2:	38 e1       	ldi	r19, 0x18	; 24
    2fd4:	30 83       	st	Z, r19
    2fd6:	31 97       	sbiw	r30, 0x01	; 1
    2fd8:	39 e1       	ldi	r19, 0x19	; 25
    2fda:	30 83       	st	Z, r19
    2fdc:	31 97       	sbiw	r30, 0x01	; 1
    2fde:	30 e2       	ldi	r19, 0x20	; 32
    2fe0:	30 83       	st	Z, r19
    2fe2:	31 97       	sbiw	r30, 0x01	; 1
    2fe4:	31 e2       	ldi	r19, 0x21	; 33
    2fe6:	30 83       	st	Z, r19
    2fe8:	31 97       	sbiw	r30, 0x01	; 1
    2fea:	20 83       	st	Z, r18
    2fec:	31 97       	sbiw	r30, 0x01	; 1
    2fee:	23 e2       	ldi	r18, 0x23	; 35
    2ff0:	20 83       	st	Z, r18
    2ff2:	31 97       	sbiw	r30, 0x01	; 1
    2ff4:	40 83       	st	Z, r20
    2ff6:	31 97       	sbiw	r30, 0x01	; 1
    2ff8:	50 83       	st	Z, r21
    2ffa:	31 97       	sbiw	r30, 0x01	; 1
    2ffc:	26 e2       	ldi	r18, 0x26	; 38
    2ffe:	20 83       	st	Z, r18
    3000:	31 97       	sbiw	r30, 0x01	; 1
    3002:	27 e2       	ldi	r18, 0x27	; 39
    3004:	20 83       	st	Z, r18
    3006:	31 97       	sbiw	r30, 0x01	; 1
    3008:	28 e2       	ldi	r18, 0x28	; 40
    300a:	20 83       	st	Z, r18
    300c:	31 97       	sbiw	r30, 0x01	; 1
    300e:	29 e2       	ldi	r18, 0x29	; 41
    3010:	20 83       	st	Z, r18
    3012:	31 97       	sbiw	r30, 0x01	; 1
    3014:	20 e3       	ldi	r18, 0x30	; 48
    3016:	20 83       	st	Z, r18
    3018:	31 97       	sbiw	r30, 0x01	; 1
    301a:	21 e3       	ldi	r18, 0x31	; 49
    301c:	20 83       	st	Z, r18
    301e:	89 97       	sbiw	r24, 0x29	; 41
    3020:	08 95       	ret

00003022 <xPortStartScheduler>:
    3022:	88 ee       	ldi	r24, 0xE8	; 232
    3024:	93 e0       	ldi	r25, 0x03	; 3
    3026:	90 93 6a 1b 	sts	0x1B6A, r25	; 0x801b6a <portTickRateHz+0x1>
    302a:	80 93 69 1b 	sts	0x1B69, r24	; 0x801b69 <portTickRateHz>
    302e:	90 93 6c 1b 	sts	0x1B6C, r25	; 0x801b6c <ticksRemainingInSec+0x1>
    3032:	80 93 6b 1b 	sts	0x1B6B, r24	; 0x801b6b <ticksRemainingInSec>
    3036:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    303a:	89 ef       	ldi	r24, 0xF9	; 249
    303c:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
    3040:	8b e0       	ldi	r24, 0x0B	; 11
    3042:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    3046:	e1 e7       	ldi	r30, 0x71	; 113
    3048:	f0 e0       	ldi	r31, 0x00	; 0
    304a:	80 81       	ld	r24, Z
    304c:	82 60       	ori	r24, 0x02	; 2
    304e:	80 83       	st	Z, r24
    3050:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    3054:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    3058:	cd 91       	ld	r28, X+
    305a:	cd bf       	out	0x3d, r28	; 61
    305c:	dd 91       	ld	r29, X+
    305e:	de bf       	out	0x3e, r29	; 62
    3060:	ff 91       	pop	r31
    3062:	ef 91       	pop	r30
    3064:	df 91       	pop	r29
    3066:	cf 91       	pop	r28
    3068:	bf 91       	pop	r27
    306a:	af 91       	pop	r26
    306c:	9f 91       	pop	r25
    306e:	8f 91       	pop	r24
    3070:	7f 91       	pop	r23
    3072:	6f 91       	pop	r22
    3074:	5f 91       	pop	r21
    3076:	4f 91       	pop	r20
    3078:	3f 91       	pop	r19
    307a:	2f 91       	pop	r18
    307c:	1f 91       	pop	r17
    307e:	0f 91       	pop	r16
    3080:	ff 90       	pop	r15
    3082:	ef 90       	pop	r14
    3084:	df 90       	pop	r13
    3086:	cf 90       	pop	r12
    3088:	bf 90       	pop	r11
    308a:	af 90       	pop	r10
    308c:	9f 90       	pop	r9
    308e:	8f 90       	pop	r8
    3090:	7f 90       	pop	r7
    3092:	6f 90       	pop	r6
    3094:	5f 90       	pop	r5
    3096:	4f 90       	pop	r4
    3098:	3f 90       	pop	r3
    309a:	2f 90       	pop	r2
    309c:	1f 90       	pop	r1
    309e:	0f 90       	pop	r0
    30a0:	0c be       	out	0x3c, r0	; 60
    30a2:	0f 90       	pop	r0
    30a4:	0b be       	out	0x3b, r0	; 59
    30a6:	0f 90       	pop	r0
    30a8:	0f be       	out	0x3f, r0	; 63
    30aa:	0f 90       	pop	r0
    30ac:	08 95       	ret
    30ae:	81 e0       	ldi	r24, 0x01	; 1
    30b0:	08 95       	ret

000030b2 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    30b2:	0f 92       	push	r0
    30b4:	0f b6       	in	r0, 0x3f	; 63
    30b6:	f8 94       	cli
    30b8:	0f 92       	push	r0
    30ba:	0b b6       	in	r0, 0x3b	; 59
    30bc:	0f 92       	push	r0
    30be:	0c b6       	in	r0, 0x3c	; 60
    30c0:	0f 92       	push	r0
    30c2:	1f 92       	push	r1
    30c4:	11 24       	eor	r1, r1
    30c6:	2f 92       	push	r2
    30c8:	3f 92       	push	r3
    30ca:	4f 92       	push	r4
    30cc:	5f 92       	push	r5
    30ce:	6f 92       	push	r6
    30d0:	7f 92       	push	r7
    30d2:	8f 92       	push	r8
    30d4:	9f 92       	push	r9
    30d6:	af 92       	push	r10
    30d8:	bf 92       	push	r11
    30da:	cf 92       	push	r12
    30dc:	df 92       	push	r13
    30de:	ef 92       	push	r14
    30e0:	ff 92       	push	r15
    30e2:	0f 93       	push	r16
    30e4:	1f 93       	push	r17
    30e6:	2f 93       	push	r18
    30e8:	3f 93       	push	r19
    30ea:	4f 93       	push	r20
    30ec:	5f 93       	push	r21
    30ee:	6f 93       	push	r22
    30f0:	7f 93       	push	r23
    30f2:	8f 93       	push	r24
    30f4:	9f 93       	push	r25
    30f6:	af 93       	push	r26
    30f8:	bf 93       	push	r27
    30fa:	cf 93       	push	r28
    30fc:	df 93       	push	r29
    30fe:	ef 93       	push	r30
    3100:	ff 93       	push	r31
    3102:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    3106:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    310a:	0d b6       	in	r0, 0x3d	; 61
    310c:	0d 92       	st	X+, r0
    310e:	0e b6       	in	r0, 0x3e	; 62
    3110:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3112:	0e 94 cd 29 	call	0x539a	; 0x539a <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3116:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    311a:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    311e:	cd 91       	ld	r28, X+
    3120:	cd bf       	out	0x3d, r28	; 61
    3122:	dd 91       	ld	r29, X+
    3124:	de bf       	out	0x3e, r29	; 62
    3126:	ff 91       	pop	r31
    3128:	ef 91       	pop	r30
    312a:	df 91       	pop	r29
    312c:	cf 91       	pop	r28
    312e:	bf 91       	pop	r27
    3130:	af 91       	pop	r26
    3132:	9f 91       	pop	r25
    3134:	8f 91       	pop	r24
    3136:	7f 91       	pop	r23
    3138:	6f 91       	pop	r22
    313a:	5f 91       	pop	r21
    313c:	4f 91       	pop	r20
    313e:	3f 91       	pop	r19
    3140:	2f 91       	pop	r18
    3142:	1f 91       	pop	r17
    3144:	0f 91       	pop	r16
    3146:	ff 90       	pop	r15
    3148:	ef 90       	pop	r14
    314a:	df 90       	pop	r13
    314c:	cf 90       	pop	r12
    314e:	bf 90       	pop	r11
    3150:	af 90       	pop	r10
    3152:	9f 90       	pop	r9
    3154:	8f 90       	pop	r8
    3156:	7f 90       	pop	r7
    3158:	6f 90       	pop	r6
    315a:	5f 90       	pop	r5
    315c:	4f 90       	pop	r4
    315e:	3f 90       	pop	r3
    3160:	2f 90       	pop	r2
    3162:	1f 90       	pop	r1
    3164:	0f 90       	pop	r0
    3166:	0c be       	out	0x3c, r0	; 60
    3168:	0f 90       	pop	r0
    316a:	0b be       	out	0x3b, r0	; 59
    316c:	0f 90       	pop	r0
    316e:	0f be       	out	0x3f, r0	; 63
    3170:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3172:	08 95       	ret

00003174 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    3174:	0f 92       	push	r0
    3176:	0f b6       	in	r0, 0x3f	; 63
    3178:	f8 94       	cli
    317a:	0f 92       	push	r0
    317c:	0b b6       	in	r0, 0x3b	; 59
    317e:	0f 92       	push	r0
    3180:	0c b6       	in	r0, 0x3c	; 60
    3182:	0f 92       	push	r0
    3184:	1f 92       	push	r1
    3186:	11 24       	eor	r1, r1
    3188:	2f 92       	push	r2
    318a:	3f 92       	push	r3
    318c:	4f 92       	push	r4
    318e:	5f 92       	push	r5
    3190:	6f 92       	push	r6
    3192:	7f 92       	push	r7
    3194:	8f 92       	push	r8
    3196:	9f 92       	push	r9
    3198:	af 92       	push	r10
    319a:	bf 92       	push	r11
    319c:	cf 92       	push	r12
    319e:	df 92       	push	r13
    31a0:	ef 92       	push	r14
    31a2:	ff 92       	push	r15
    31a4:	0f 93       	push	r16
    31a6:	1f 93       	push	r17
    31a8:	2f 93       	push	r18
    31aa:	3f 93       	push	r19
    31ac:	4f 93       	push	r20
    31ae:	5f 93       	push	r21
    31b0:	6f 93       	push	r22
    31b2:	7f 93       	push	r23
    31b4:	8f 93       	push	r24
    31b6:	9f 93       	push	r25
    31b8:	af 93       	push	r26
    31ba:	bf 93       	push	r27
    31bc:	cf 93       	push	r28
    31be:	df 93       	push	r29
    31c0:	ef 93       	push	r30
    31c2:	ff 93       	push	r31
    31c4:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    31c8:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    31cc:	0d b6       	in	r0, 0x3d	; 61
    31ce:	0d 92       	st	X+, r0
    31d0:	0e b6       	in	r0, 0x3e	; 62
    31d2:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    31d4:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    31d6:	80 91 6b 1b 	lds	r24, 0x1B6B	; 0x801b6b <ticksRemainingInSec>
    31da:	90 91 6c 1b 	lds	r25, 0x1B6C	; 0x801b6c <ticksRemainingInSec+0x1>
    31de:	01 97       	sbiw	r24, 0x01	; 1
    31e0:	90 93 6c 1b 	sts	0x1B6C, r25	; 0x801b6c <ticksRemainingInSec+0x1>
    31e4:	80 93 6b 1b 	sts	0x1B6B, r24	; 0x801b6b <ticksRemainingInSec>
    31e8:	89 2b       	or	r24, r25
    31ea:	41 f4       	brne	.+16     	; 0x31fc <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    31ec:	80 91 69 1b 	lds	r24, 0x1B69	; 0x801b69 <portTickRateHz>
    31f0:	90 91 6a 1b 	lds	r25, 0x1B6A	; 0x801b6a <portTickRateHz+0x1>
    31f4:	90 93 6c 1b 	sts	0x1B6C, r25	; 0x801b6c <ticksRemainingInSec+0x1>
    31f8:	80 93 6b 1b 	sts	0x1B6B, r24	; 0x801b6b <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    31fc:	0e 94 0c 29 	call	0x5218	; 0x5218 <xTaskIncrementTick>
    3200:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    3202:	0e 94 cd 29 	call	0x539a	; 0x539a <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    3206:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    320a:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    320e:	cd 91       	ld	r28, X+
    3210:	cd bf       	out	0x3d, r28	; 61
    3212:	dd 91       	ld	r29, X+
    3214:	de bf       	out	0x3e, r29	; 62
    3216:	ff 91       	pop	r31
    3218:	ef 91       	pop	r30
    321a:	df 91       	pop	r29
    321c:	cf 91       	pop	r28
    321e:	bf 91       	pop	r27
    3220:	af 91       	pop	r26
    3222:	9f 91       	pop	r25
    3224:	8f 91       	pop	r24
    3226:	7f 91       	pop	r23
    3228:	6f 91       	pop	r22
    322a:	5f 91       	pop	r21
    322c:	4f 91       	pop	r20
    322e:	3f 91       	pop	r19
    3230:	2f 91       	pop	r18
    3232:	1f 91       	pop	r17
    3234:	0f 91       	pop	r16
    3236:	ff 90       	pop	r15
    3238:	ef 90       	pop	r14
    323a:	df 90       	pop	r13
    323c:	cf 90       	pop	r12
    323e:	bf 90       	pop	r11
    3240:	af 90       	pop	r10
    3242:	9f 90       	pop	r9
    3244:	8f 90       	pop	r8
    3246:	7f 90       	pop	r7
    3248:	6f 90       	pop	r6
    324a:	5f 90       	pop	r5
    324c:	4f 90       	pop	r4
    324e:	3f 90       	pop	r3
    3250:	2f 90       	pop	r2
    3252:	1f 90       	pop	r1
    3254:	0f 90       	pop	r0
    3256:	0c be       	out	0x3c, r0	; 60
    3258:	0f 90       	pop	r0
    325a:	0b be       	out	0x3b, r0	; 59
    325c:	0f 90       	pop	r0
    325e:	0f be       	out	0x3f, r0	; 63
    3260:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3262:	08 95       	ret

00003264 <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    3264:	87 df       	rcall	.-242    	; 0x3174 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    3266:	18 95       	reti

00003268 <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3268:	0f 93       	push	r16
    326a:	1f 93       	push	r17
    326c:	cf 93       	push	r28
    326e:	df 93       	push	r29
    3270:	08 2f       	mov	r16, r24
    3272:	16 2f       	mov	r17, r22
    3274:	66 23       	and	r22, r22
    3276:	09 f4       	brne	.+2      	; 0x327a <xQueueGenericCreate+0x12>
    3278:	3b c0       	rjmp	.+118    	; 0x32f0 <xQueueGenericCreate+0x88>
    327a:	86 9f       	mul	r24, r22
    327c:	c0 01       	movw	r24, r0
    327e:	11 24       	eor	r1, r1
    3280:	80 96       	adiw	r24, 0x20	; 32
    3282:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    3286:	ec 01       	movw	r28, r24
    3288:	00 97       	sbiw	r24, 0x00	; 0
    328a:	21 f4       	brne	.+8      	; 0x3294 <xQueueGenericCreate+0x2c>
    328c:	39 c0       	rjmp	.+114    	; 0x3300 <xQueueGenericCreate+0x98>
    328e:	d9 83       	std	Y+1, r29	; 0x01
    3290:	c8 83       	st	Y, r28
    3292:	03 c0       	rjmp	.+6      	; 0x329a <xQueueGenericCreate+0x32>
    3294:	4f 96       	adiw	r24, 0x1f	; 31
    3296:	99 83       	std	Y+1, r25	; 0x01
    3298:	88 83       	st	Y, r24
    329a:	0b 8f       	std	Y+27, r16	; 0x1b
    329c:	1c 8f       	std	Y+28, r17	; 0x1c
    329e:	0f b6       	in	r0, 0x3f	; 63
    32a0:	f8 94       	cli
    32a2:	0f 92       	push	r0
    32a4:	48 81       	ld	r20, Y
    32a6:	59 81       	ldd	r21, Y+1	; 0x01
    32a8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    32aa:	30 e0       	ldi	r19, 0x00	; 0
    32ac:	6b 8d       	ldd	r22, Y+27	; 0x1b
    32ae:	62 9f       	mul	r22, r18
    32b0:	c0 01       	movw	r24, r0
    32b2:	63 9f       	mul	r22, r19
    32b4:	90 0d       	add	r25, r0
    32b6:	11 24       	eor	r1, r1
    32b8:	ba 01       	movw	r22, r20
    32ba:	68 0f       	add	r22, r24
    32bc:	79 1f       	adc	r23, r25
    32be:	7b 83       	std	Y+3, r23	; 0x03
    32c0:	6a 83       	std	Y+2, r22	; 0x02
    32c2:	1a 8e       	std	Y+26, r1	; 0x1a
    32c4:	5d 83       	std	Y+5, r21	; 0x05
    32c6:	4c 83       	std	Y+4, r20	; 0x04
    32c8:	82 1b       	sub	r24, r18
    32ca:	93 0b       	sbc	r25, r19
    32cc:	84 0f       	add	r24, r20
    32ce:	95 1f       	adc	r25, r21
    32d0:	9f 83       	std	Y+7, r25	; 0x07
    32d2:	8e 83       	std	Y+6, r24	; 0x06
    32d4:	8f ef       	ldi	r24, 0xFF	; 255
    32d6:	8d 8f       	std	Y+29, r24	; 0x1d
    32d8:	8e 8f       	std	Y+30, r24	; 0x1e
    32da:	ce 01       	movw	r24, r28
    32dc:	08 96       	adiw	r24, 0x08	; 8
    32de:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    32e2:	ce 01       	movw	r24, r28
    32e4:	41 96       	adiw	r24, 0x11	; 17
    32e6:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    32ea:	0f 90       	pop	r0
    32ec:	0f be       	out	0x3f, r0	; 63
    32ee:	08 c0       	rjmp	.+16     	; 0x3300 <xQueueGenericCreate+0x98>
    32f0:	8f e1       	ldi	r24, 0x1F	; 31
    32f2:	90 e0       	ldi	r25, 0x00	; 0
    32f4:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    32f8:	ec 01       	movw	r28, r24
    32fa:	89 2b       	or	r24, r25
    32fc:	09 f0       	breq	.+2      	; 0x3300 <xQueueGenericCreate+0x98>
    32fe:	c7 cf       	rjmp	.-114    	; 0x328e <xQueueGenericCreate+0x26>
    3300:	ce 01       	movw	r24, r28
    3302:	df 91       	pop	r29
    3304:	cf 91       	pop	r28
    3306:	1f 91       	pop	r17
    3308:	0f 91       	pop	r16
    330a:	08 95       	ret

0000330c <xQueueCreateMutex>:
    330c:	9f 92       	push	r9
    330e:	af 92       	push	r10
    3310:	bf 92       	push	r11
    3312:	cf 92       	push	r12
    3314:	df 92       	push	r13
    3316:	ef 92       	push	r14
    3318:	ff 92       	push	r15
    331a:	0f 93       	push	r16
    331c:	1f 93       	push	r17
    331e:	cf 93       	push	r28
    3320:	df 93       	push	r29
    3322:	00 d0       	rcall	.+0      	; 0x3324 <xQueueCreateMutex+0x18>
    3324:	1f 92       	push	r1
    3326:	1f 92       	push	r1
    3328:	cd b7       	in	r28, 0x3d	; 61
    332a:	de b7       	in	r29, 0x3e	; 62
    332c:	8f e1       	ldi	r24, 0x1F	; 31
    332e:	90 e0       	ldi	r25, 0x00	; 0
    3330:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    3334:	8c 01       	movw	r16, r24
    3336:	00 97       	sbiw	r24, 0x00	; 0
    3338:	09 f4       	brne	.+2      	; 0x333c <xQueueCreateMutex+0x30>
    333a:	58 c1       	rjmp	.+688    	; 0x35ec <xQueueCreateMutex+0x2e0>
    333c:	fc 01       	movw	r30, r24
    333e:	13 82       	std	Z+3, r1	; 0x03
    3340:	12 82       	std	Z+2, r1	; 0x02
    3342:	11 82       	std	Z+1, r1	; 0x01
    3344:	10 82       	st	Z, r1
    3346:	15 82       	std	Z+5, r1	; 0x05
    3348:	14 82       	std	Z+4, r1	; 0x04
    334a:	17 82       	std	Z+7, r1	; 0x07
    334c:	16 82       	std	Z+6, r1	; 0x06
    334e:	12 8e       	std	Z+26, r1	; 0x1a
    3350:	81 e0       	ldi	r24, 0x01	; 1
    3352:	83 8f       	std	Z+27, r24	; 0x1b
    3354:	14 8e       	std	Z+28, r1	; 0x1c
    3356:	8f ef       	ldi	r24, 0xFF	; 255
    3358:	85 8f       	std	Z+29, r24	; 0x1d
    335a:	86 8f       	std	Z+30, r24	; 0x1e
    335c:	78 01       	movw	r14, r16
    335e:	f8 e0       	ldi	r31, 0x08	; 8
    3360:	ef 0e       	add	r14, r31
    3362:	f1 1c       	adc	r15, r1
    3364:	c7 01       	movw	r24, r14
    3366:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    336a:	68 01       	movw	r12, r16
    336c:	81 e1       	ldi	r24, 0x11	; 17
    336e:	c8 0e       	add	r12, r24
    3370:	d1 1c       	adc	r13, r1
    3372:	c6 01       	movw	r24, r12
    3374:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    3378:	1d 82       	std	Y+5, r1	; 0x05
    337a:	1c 82       	std	Y+4, r1	; 0x04
    337c:	a1 2c       	mov	r10, r1
    337e:	99 24       	eor	r9, r9
    3380:	93 94       	inc	r9
    3382:	bb 24       	eor	r11, r11
    3384:	ba 94       	dec	r11
    3386:	0f b6       	in	r0, 0x3f	; 63
    3388:	f8 94       	cli
    338a:	0f 92       	push	r0
    338c:	f8 01       	movw	r30, r16
    338e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3390:	83 8d       	ldd	r24, Z+27	; 0x1b
    3392:	98 17       	cp	r25, r24
    3394:	f0 f4       	brcc	.+60     	; 0x33d2 <xQueueCreateMutex+0xc6>
    3396:	80 81       	ld	r24, Z
    3398:	91 81       	ldd	r25, Z+1	; 0x01
    339a:	89 2b       	or	r24, r25
    339c:	09 f0       	breq	.+2      	; 0x33a0 <xQueueCreateMutex+0x94>
    339e:	1d c1       	rjmp	.+570    	; 0x35da <xQueueCreateMutex+0x2ce>
    33a0:	82 81       	ldd	r24, Z+2	; 0x02
    33a2:	93 81       	ldd	r25, Z+3	; 0x03
    33a4:	0e 94 a9 2b 	call	0x5752	; 0x5752 <xTaskPriorityDisinherit>
    33a8:	f8 01       	movw	r30, r16
    33aa:	13 82       	std	Z+3, r1	; 0x03
    33ac:	12 82       	std	Z+2, r1	; 0x02
    33ae:	92 8d       	ldd	r25, Z+26	; 0x1a
    33b0:	9f 5f       	subi	r25, 0xFF	; 255
    33b2:	92 8f       	std	Z+26, r25	; 0x1a
    33b4:	91 89       	ldd	r25, Z+17	; 0x11
    33b6:	99 23       	and	r25, r25
    33b8:	39 f0       	breq	.+14     	; 0x33c8 <xQueueCreateMutex+0xbc>
    33ba:	c6 01       	movw	r24, r12
    33bc:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    33c0:	81 30       	cpi	r24, 0x01	; 1
    33c2:	21 f4       	brne	.+8      	; 0x33cc <xQueueCreateMutex+0xc0>
    33c4:	76 de       	rcall	.-788    	; 0x30b2 <vPortYield>
    33c6:	02 c0       	rjmp	.+4      	; 0x33cc <xQueueCreateMutex+0xc0>
    33c8:	81 11       	cpse	r24, r1
    33ca:	73 de       	rcall	.-794    	; 0x30b2 <vPortYield>
    33cc:	0f 90       	pop	r0
    33ce:	0f be       	out	0x3f, r0	; 63
    33d0:	0d c1       	rjmp	.+538    	; 0x35ec <xQueueCreateMutex+0x2e0>
    33d2:	8c 81       	ldd	r24, Y+4	; 0x04
    33d4:	9d 81       	ldd	r25, Y+5	; 0x05
    33d6:	89 2b       	or	r24, r25
    33d8:	19 f4       	brne	.+6      	; 0x33e0 <xQueueCreateMutex+0xd4>
    33da:	0f 90       	pop	r0
    33dc:	0f be       	out	0x3f, r0	; 63
    33de:	06 c1       	rjmp	.+524    	; 0x35ec <xQueueCreateMutex+0x2e0>
    33e0:	a1 10       	cpse	r10, r1
    33e2:	05 c0       	rjmp	.+10     	; 0x33ee <xQueueCreateMutex+0xe2>
    33e4:	ce 01       	movw	r24, r28
    33e6:	01 96       	adiw	r24, 0x01	; 1
    33e8:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <vTaskSetTimeOutState>
    33ec:	a9 2c       	mov	r10, r9
    33ee:	0f 90       	pop	r0
    33f0:	0f be       	out	0x3f, r0	; 63
    33f2:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <vTaskSuspendAll>
    33f6:	0f b6       	in	r0, 0x3f	; 63
    33f8:	f8 94       	cli
    33fa:	0f 92       	push	r0
    33fc:	f8 01       	movw	r30, r16
    33fe:	85 8d       	ldd	r24, Z+29	; 0x1d
    3400:	8f 3f       	cpi	r24, 0xFF	; 255
    3402:	09 f4       	brne	.+2      	; 0x3406 <xQueueCreateMutex+0xfa>
    3404:	15 8e       	std	Z+29, r1	; 0x1d
    3406:	f8 01       	movw	r30, r16
    3408:	86 8d       	ldd	r24, Z+30	; 0x1e
    340a:	8f 3f       	cpi	r24, 0xFF	; 255
    340c:	09 f4       	brne	.+2      	; 0x3410 <xQueueCreateMutex+0x104>
    340e:	16 8e       	std	Z+30, r1	; 0x1e
    3410:	0f 90       	pop	r0
    3412:	0f be       	out	0x3f, r0	; 63
    3414:	be 01       	movw	r22, r28
    3416:	6c 5f       	subi	r22, 0xFC	; 252
    3418:	7f 4f       	sbci	r23, 0xFF	; 255
    341a:	ce 01       	movw	r24, r28
    341c:	01 96       	adiw	r24, 0x01	; 1
    341e:	0e 94 03 2b 	call	0x5606	; 0x5606 <xTaskCheckForTimeOut>
    3422:	81 11       	cpse	r24, r1
    3424:	96 c0       	rjmp	.+300    	; 0x3552 <xQueueCreateMutex+0x246>
    3426:	0f b6       	in	r0, 0x3f	; 63
    3428:	f8 94       	cli
    342a:	0f 92       	push	r0
    342c:	f8 01       	movw	r30, r16
    342e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3430:	83 8d       	ldd	r24, Z+27	; 0x1b
    3432:	0f 90       	pop	r0
    3434:	0f be       	out	0x3f, r0	; 63
    3436:	98 13       	cpse	r25, r24
    3438:	4a c0       	rjmp	.+148    	; 0x34ce <xQueueCreateMutex+0x1c2>
    343a:	6c 81       	ldd	r22, Y+4	; 0x04
    343c:	7d 81       	ldd	r23, Y+5	; 0x05
    343e:	c7 01       	movw	r24, r14
    3440:	0e 94 55 2a 	call	0x54aa	; 0x54aa <vTaskPlaceOnEventList>
    3444:	0f b6       	in	r0, 0x3f	; 63
    3446:	f8 94       	cli
    3448:	0f 92       	push	r0
    344a:	f8 01       	movw	r30, r16
    344c:	86 8d       	ldd	r24, Z+30	; 0x1e
    344e:	18 16       	cp	r1, r24
    3450:	ac f4       	brge	.+42     	; 0x347c <xQueueCreateMutex+0x170>
    3452:	81 89       	ldd	r24, Z+17	; 0x11
    3454:	81 11       	cpse	r24, r1
    3456:	05 c0       	rjmp	.+10     	; 0x3462 <xQueueCreateMutex+0x156>
    3458:	11 c0       	rjmp	.+34     	; 0x347c <xQueueCreateMutex+0x170>
    345a:	f8 01       	movw	r30, r16
    345c:	81 89       	ldd	r24, Z+17	; 0x11
    345e:	88 23       	and	r24, r24
    3460:	69 f0       	breq	.+26     	; 0x347c <xQueueCreateMutex+0x170>
    3462:	c6 01       	movw	r24, r12
    3464:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3468:	81 11       	cpse	r24, r1
    346a:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    346e:	f8 01       	movw	r30, r16
    3470:	86 8d       	ldd	r24, Z+30	; 0x1e
    3472:	81 50       	subi	r24, 0x01	; 1
    3474:	86 8f       	std	Z+30, r24	; 0x1e
    3476:	86 8d       	ldd	r24, Z+30	; 0x1e
    3478:	18 16       	cp	r1, r24
    347a:	7c f3       	brlt	.-34     	; 0x345a <xQueueCreateMutex+0x14e>
    347c:	f8 01       	movw	r30, r16
    347e:	b6 8e       	std	Z+30, r11	; 0x1e
    3480:	0f 90       	pop	r0
    3482:	0f be       	out	0x3f, r0	; 63
    3484:	0f b6       	in	r0, 0x3f	; 63
    3486:	f8 94       	cli
    3488:	0f 92       	push	r0
    348a:	85 8d       	ldd	r24, Z+29	; 0x1d
    348c:	18 16       	cp	r1, r24
    348e:	ac f4       	brge	.+42     	; 0x34ba <xQueueCreateMutex+0x1ae>
    3490:	80 85       	ldd	r24, Z+8	; 0x08
    3492:	81 11       	cpse	r24, r1
    3494:	05 c0       	rjmp	.+10     	; 0x34a0 <xQueueCreateMutex+0x194>
    3496:	11 c0       	rjmp	.+34     	; 0x34ba <xQueueCreateMutex+0x1ae>
    3498:	f8 01       	movw	r30, r16
    349a:	80 85       	ldd	r24, Z+8	; 0x08
    349c:	88 23       	and	r24, r24
    349e:	69 f0       	breq	.+26     	; 0x34ba <xQueueCreateMutex+0x1ae>
    34a0:	c7 01       	movw	r24, r14
    34a2:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    34a6:	81 11       	cpse	r24, r1
    34a8:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    34ac:	f8 01       	movw	r30, r16
    34ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    34b0:	81 50       	subi	r24, 0x01	; 1
    34b2:	85 8f       	std	Z+29, r24	; 0x1d
    34b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    34b6:	18 16       	cp	r1, r24
    34b8:	7c f3       	brlt	.-34     	; 0x3498 <xQueueCreateMutex+0x18c>
    34ba:	f8 01       	movw	r30, r16
    34bc:	b5 8e       	std	Z+29, r11	; 0x1d
    34be:	0f 90       	pop	r0
    34c0:	0f be       	out	0x3f, r0	; 63
    34c2:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    34c6:	81 11       	cpse	r24, r1
    34c8:	5e cf       	rjmp	.-324    	; 0x3386 <xQueueCreateMutex+0x7a>
    34ca:	f3 dd       	rcall	.-1050   	; 0x30b2 <vPortYield>
    34cc:	5c cf       	rjmp	.-328    	; 0x3386 <xQueueCreateMutex+0x7a>
    34ce:	0f b6       	in	r0, 0x3f	; 63
    34d0:	f8 94       	cli
    34d2:	0f 92       	push	r0
    34d4:	f8 01       	movw	r30, r16
    34d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    34d8:	18 16       	cp	r1, r24
    34da:	ac f4       	brge	.+42     	; 0x3506 <xQueueCreateMutex+0x1fa>
    34dc:	81 89       	ldd	r24, Z+17	; 0x11
    34de:	81 11       	cpse	r24, r1
    34e0:	05 c0       	rjmp	.+10     	; 0x34ec <xQueueCreateMutex+0x1e0>
    34e2:	11 c0       	rjmp	.+34     	; 0x3506 <xQueueCreateMutex+0x1fa>
    34e4:	f8 01       	movw	r30, r16
    34e6:	81 89       	ldd	r24, Z+17	; 0x11
    34e8:	88 23       	and	r24, r24
    34ea:	69 f0       	breq	.+26     	; 0x3506 <xQueueCreateMutex+0x1fa>
    34ec:	c6 01       	movw	r24, r12
    34ee:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    34f2:	81 11       	cpse	r24, r1
    34f4:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    34f8:	f8 01       	movw	r30, r16
    34fa:	86 8d       	ldd	r24, Z+30	; 0x1e
    34fc:	81 50       	subi	r24, 0x01	; 1
    34fe:	86 8f       	std	Z+30, r24	; 0x1e
    3500:	86 8d       	ldd	r24, Z+30	; 0x1e
    3502:	18 16       	cp	r1, r24
    3504:	7c f3       	brlt	.-34     	; 0x34e4 <xQueueCreateMutex+0x1d8>
    3506:	f8 01       	movw	r30, r16
    3508:	b6 8e       	std	Z+30, r11	; 0x1e
    350a:	0f 90       	pop	r0
    350c:	0f be       	out	0x3f, r0	; 63
    350e:	0f b6       	in	r0, 0x3f	; 63
    3510:	f8 94       	cli
    3512:	0f 92       	push	r0
    3514:	85 8d       	ldd	r24, Z+29	; 0x1d
    3516:	18 16       	cp	r1, r24
    3518:	ac f4       	brge	.+42     	; 0x3544 <xQueueCreateMutex+0x238>
    351a:	80 85       	ldd	r24, Z+8	; 0x08
    351c:	81 11       	cpse	r24, r1
    351e:	05 c0       	rjmp	.+10     	; 0x352a <xQueueCreateMutex+0x21e>
    3520:	11 c0       	rjmp	.+34     	; 0x3544 <xQueueCreateMutex+0x238>
    3522:	f8 01       	movw	r30, r16
    3524:	80 85       	ldd	r24, Z+8	; 0x08
    3526:	88 23       	and	r24, r24
    3528:	69 f0       	breq	.+26     	; 0x3544 <xQueueCreateMutex+0x238>
    352a:	c7 01       	movw	r24, r14
    352c:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3530:	81 11       	cpse	r24, r1
    3532:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3536:	f8 01       	movw	r30, r16
    3538:	85 8d       	ldd	r24, Z+29	; 0x1d
    353a:	81 50       	subi	r24, 0x01	; 1
    353c:	85 8f       	std	Z+29, r24	; 0x1d
    353e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3540:	18 16       	cp	r1, r24
    3542:	7c f3       	brlt	.-34     	; 0x3522 <xQueueCreateMutex+0x216>
    3544:	f8 01       	movw	r30, r16
    3546:	b5 8e       	std	Z+29, r11	; 0x1d
    3548:	0f 90       	pop	r0
    354a:	0f be       	out	0x3f, r0	; 63
    354c:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    3550:	1a cf       	rjmp	.-460    	; 0x3386 <xQueueCreateMutex+0x7a>
    3552:	0f b6       	in	r0, 0x3f	; 63
    3554:	f8 94       	cli
    3556:	0f 92       	push	r0
    3558:	f8 01       	movw	r30, r16
    355a:	86 8d       	ldd	r24, Z+30	; 0x1e
    355c:	18 16       	cp	r1, r24
    355e:	ac f4       	brge	.+42     	; 0x358a <xQueueCreateMutex+0x27e>
    3560:	81 89       	ldd	r24, Z+17	; 0x11
    3562:	81 11       	cpse	r24, r1
    3564:	05 c0       	rjmp	.+10     	; 0x3570 <xQueueCreateMutex+0x264>
    3566:	11 c0       	rjmp	.+34     	; 0x358a <xQueueCreateMutex+0x27e>
    3568:	f8 01       	movw	r30, r16
    356a:	81 89       	ldd	r24, Z+17	; 0x11
    356c:	88 23       	and	r24, r24
    356e:	69 f0       	breq	.+26     	; 0x358a <xQueueCreateMutex+0x27e>
    3570:	c6 01       	movw	r24, r12
    3572:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3576:	81 11       	cpse	r24, r1
    3578:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    357c:	f8 01       	movw	r30, r16
    357e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3580:	81 50       	subi	r24, 0x01	; 1
    3582:	86 8f       	std	Z+30, r24	; 0x1e
    3584:	86 8d       	ldd	r24, Z+30	; 0x1e
    3586:	18 16       	cp	r1, r24
    3588:	7c f3       	brlt	.-34     	; 0x3568 <xQueueCreateMutex+0x25c>
    358a:	8f ef       	ldi	r24, 0xFF	; 255
    358c:	f8 01       	movw	r30, r16
    358e:	86 8f       	std	Z+30, r24	; 0x1e
    3590:	0f 90       	pop	r0
    3592:	0f be       	out	0x3f, r0	; 63
    3594:	0f b6       	in	r0, 0x3f	; 63
    3596:	f8 94       	cli
    3598:	0f 92       	push	r0
    359a:	85 8d       	ldd	r24, Z+29	; 0x1d
    359c:	18 16       	cp	r1, r24
    359e:	ac f4       	brge	.+42     	; 0x35ca <xQueueCreateMutex+0x2be>
    35a0:	80 85       	ldd	r24, Z+8	; 0x08
    35a2:	81 11       	cpse	r24, r1
    35a4:	05 c0       	rjmp	.+10     	; 0x35b0 <xQueueCreateMutex+0x2a4>
    35a6:	11 c0       	rjmp	.+34     	; 0x35ca <xQueueCreateMutex+0x2be>
    35a8:	f8 01       	movw	r30, r16
    35aa:	80 85       	ldd	r24, Z+8	; 0x08
    35ac:	88 23       	and	r24, r24
    35ae:	69 f0       	breq	.+26     	; 0x35ca <xQueueCreateMutex+0x2be>
    35b0:	c7 01       	movw	r24, r14
    35b2:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    35b6:	81 11       	cpse	r24, r1
    35b8:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    35bc:	f8 01       	movw	r30, r16
    35be:	85 8d       	ldd	r24, Z+29	; 0x1d
    35c0:	81 50       	subi	r24, 0x01	; 1
    35c2:	85 8f       	std	Z+29, r24	; 0x1d
    35c4:	85 8d       	ldd	r24, Z+29	; 0x1d
    35c6:	18 16       	cp	r1, r24
    35c8:	7c f3       	brlt	.-34     	; 0x35a8 <xQueueCreateMutex+0x29c>
    35ca:	8f ef       	ldi	r24, 0xFF	; 255
    35cc:	f8 01       	movw	r30, r16
    35ce:	85 8f       	std	Z+29, r24	; 0x1d
    35d0:	0f 90       	pop	r0
    35d2:	0f be       	out	0x3f, r0	; 63
    35d4:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    35d8:	09 c0       	rjmp	.+18     	; 0x35ec <xQueueCreateMutex+0x2e0>
    35da:	f8 01       	movw	r30, r16
    35dc:	82 8d       	ldd	r24, Z+26	; 0x1a
    35de:	8f 5f       	subi	r24, 0xFF	; 255
    35e0:	82 8f       	std	Z+26, r24	; 0x1a
    35e2:	81 89       	ldd	r24, Z+17	; 0x11
    35e4:	88 23       	and	r24, r24
    35e6:	09 f4       	brne	.+2      	; 0x35ea <xQueueCreateMutex+0x2de>
    35e8:	f1 ce       	rjmp	.-542    	; 0x33cc <xQueueCreateMutex+0xc0>
    35ea:	e7 ce       	rjmp	.-562    	; 0x33ba <xQueueCreateMutex+0xae>
    35ec:	c8 01       	movw	r24, r16
    35ee:	0f 90       	pop	r0
    35f0:	0f 90       	pop	r0
    35f2:	0f 90       	pop	r0
    35f4:	0f 90       	pop	r0
    35f6:	0f 90       	pop	r0
    35f8:	df 91       	pop	r29
    35fa:	cf 91       	pop	r28
    35fc:	1f 91       	pop	r17
    35fe:	0f 91       	pop	r16
    3600:	ff 90       	pop	r15
    3602:	ef 90       	pop	r14
    3604:	df 90       	pop	r13
    3606:	cf 90       	pop	r12
    3608:	bf 90       	pop	r11
    360a:	af 90       	pop	r10
    360c:	9f 90       	pop	r9
    360e:	08 95       	ret

00003610 <xQueueGenericSend>:
    3610:	6f 92       	push	r6
    3612:	7f 92       	push	r7
    3614:	8f 92       	push	r8
    3616:	9f 92       	push	r9
    3618:	af 92       	push	r10
    361a:	bf 92       	push	r11
    361c:	cf 92       	push	r12
    361e:	df 92       	push	r13
    3620:	ef 92       	push	r14
    3622:	ff 92       	push	r15
    3624:	0f 93       	push	r16
    3626:	1f 93       	push	r17
    3628:	cf 93       	push	r28
    362a:	df 93       	push	r29
    362c:	00 d0       	rcall	.+0      	; 0x362e <xQueueGenericSend+0x1e>
    362e:	1f 92       	push	r1
    3630:	1f 92       	push	r1
    3632:	cd b7       	in	r28, 0x3d	; 61
    3634:	de b7       	in	r29, 0x3e	; 62
    3636:	8c 01       	movw	r16, r24
    3638:	5b 01       	movw	r10, r22
    363a:	5d 83       	std	Y+5, r21	; 0x05
    363c:	4c 83       	std	Y+4, r20	; 0x04
    363e:	72 2e       	mov	r7, r18
    3640:	81 2c       	mov	r8, r1
    3642:	66 24       	eor	r6, r6
    3644:	63 94       	inc	r6
    3646:	99 24       	eor	r9, r9
    3648:	9a 94       	dec	r9
    364a:	7c 01       	movw	r14, r24
    364c:	88 e0       	ldi	r24, 0x08	; 8
    364e:	e8 0e       	add	r14, r24
    3650:	f1 1c       	adc	r15, r1
    3652:	68 01       	movw	r12, r16
    3654:	e1 e1       	ldi	r30, 0x11	; 17
    3656:	ce 0e       	add	r12, r30
    3658:	d1 1c       	adc	r13, r1
    365a:	0f b6       	in	r0, 0x3f	; 63
    365c:	f8 94       	cli
    365e:	0f 92       	push	r0
    3660:	f8 01       	movw	r30, r16
    3662:	92 8d       	ldd	r25, Z+26	; 0x1a
    3664:	83 8d       	ldd	r24, Z+27	; 0x1b
    3666:	98 17       	cp	r25, r24
    3668:	20 f0       	brcs	.+8      	; 0x3672 <xQueueGenericSend+0x62>
    366a:	f2 e0       	ldi	r31, 0x02	; 2
    366c:	7f 12       	cpse	r7, r31
    366e:	6e c0       	rjmp	.+220    	; 0x374c <xQueueGenericSend+0x13c>
    3670:	7d c1       	rjmp	.+762    	; 0x396c <xQueueGenericSend+0x35c>
    3672:	f8 01       	movw	r30, r16
    3674:	44 8d       	ldd	r20, Z+28	; 0x1c
    3676:	41 11       	cpse	r20, r1
    3678:	15 c0       	rjmp	.+42     	; 0x36a4 <xQueueGenericSend+0x94>
    367a:	f8 01       	movw	r30, r16
    367c:	80 81       	ld	r24, Z
    367e:	91 81       	ldd	r25, Z+1	; 0x01
    3680:	89 2b       	or	r24, r25
    3682:	09 f0       	breq	.+2      	; 0x3686 <xQueueGenericSend+0x76>
    3684:	79 c1       	rjmp	.+754    	; 0x3978 <xQueueGenericSend+0x368>
    3686:	82 81       	ldd	r24, Z+2	; 0x02
    3688:	93 81       	ldd	r25, Z+3	; 0x03
    368a:	0e 94 a9 2b 	call	0x5752	; 0x5752 <xTaskPriorityDisinherit>
    368e:	f8 01       	movw	r30, r16
    3690:	13 82       	std	Z+3, r1	; 0x03
    3692:	12 82       	std	Z+2, r1	; 0x02
    3694:	92 8d       	ldd	r25, Z+26	; 0x1a
    3696:	9f 5f       	subi	r25, 0xFF	; 255
    3698:	92 8f       	std	Z+26, r25	; 0x1a
    369a:	91 89       	ldd	r25, Z+17	; 0x11
    369c:	99 23       	and	r25, r25
    369e:	09 f4       	brne	.+2      	; 0x36a2 <xQueueGenericSend+0x92>
    36a0:	4f c0       	rjmp	.+158    	; 0x3740 <xQueueGenericSend+0x130>
    36a2:	46 c0       	rjmp	.+140    	; 0x3730 <xQueueGenericSend+0x120>
    36a4:	71 10       	cpse	r7, r1
    36a6:	1a c0       	rjmp	.+52     	; 0x36dc <xQueueGenericSend+0xcc>
    36a8:	50 e0       	ldi	r21, 0x00	; 0
    36aa:	b5 01       	movw	r22, r10
    36ac:	f8 01       	movw	r30, r16
    36ae:	84 81       	ldd	r24, Z+4	; 0x04
    36b0:	95 81       	ldd	r25, Z+5	; 0x05
    36b2:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    36b6:	f8 01       	movw	r30, r16
    36b8:	24 8d       	ldd	r18, Z+28	; 0x1c
    36ba:	84 81       	ldd	r24, Z+4	; 0x04
    36bc:	95 81       	ldd	r25, Z+5	; 0x05
    36be:	82 0f       	add	r24, r18
    36c0:	91 1d       	adc	r25, r1
    36c2:	95 83       	std	Z+5, r25	; 0x05
    36c4:	84 83       	std	Z+4, r24	; 0x04
    36c6:	22 81       	ldd	r18, Z+2	; 0x02
    36c8:	33 81       	ldd	r19, Z+3	; 0x03
    36ca:	82 17       	cp	r24, r18
    36cc:	93 07       	cpc	r25, r19
    36ce:	08 f4       	brcc	.+2      	; 0x36d2 <xQueueGenericSend+0xc2>
    36d0:	53 c1       	rjmp	.+678    	; 0x3978 <xQueueGenericSend+0x368>
    36d2:	80 81       	ld	r24, Z
    36d4:	91 81       	ldd	r25, Z+1	; 0x01
    36d6:	95 83       	std	Z+5, r25	; 0x05
    36d8:	84 83       	std	Z+4, r24	; 0x04
    36da:	4e c1       	rjmp	.+668    	; 0x3978 <xQueueGenericSend+0x368>
    36dc:	50 e0       	ldi	r21, 0x00	; 0
    36de:	b5 01       	movw	r22, r10
    36e0:	f8 01       	movw	r30, r16
    36e2:	86 81       	ldd	r24, Z+6	; 0x06
    36e4:	97 81       	ldd	r25, Z+7	; 0x07
    36e6:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    36ea:	f8 01       	movw	r30, r16
    36ec:	84 8d       	ldd	r24, Z+28	; 0x1c
    36ee:	90 e0       	ldi	r25, 0x00	; 0
    36f0:	91 95       	neg	r25
    36f2:	81 95       	neg	r24
    36f4:	91 09       	sbc	r25, r1
    36f6:	26 81       	ldd	r18, Z+6	; 0x06
    36f8:	37 81       	ldd	r19, Z+7	; 0x07
    36fa:	28 0f       	add	r18, r24
    36fc:	39 1f       	adc	r19, r25
    36fe:	37 83       	std	Z+7, r19	; 0x07
    3700:	26 83       	std	Z+6, r18	; 0x06
    3702:	40 81       	ld	r20, Z
    3704:	51 81       	ldd	r21, Z+1	; 0x01
    3706:	24 17       	cp	r18, r20
    3708:	35 07       	cpc	r19, r21
    370a:	30 f4       	brcc	.+12     	; 0x3718 <xQueueGenericSend+0x108>
    370c:	22 81       	ldd	r18, Z+2	; 0x02
    370e:	33 81       	ldd	r19, Z+3	; 0x03
    3710:	82 0f       	add	r24, r18
    3712:	93 1f       	adc	r25, r19
    3714:	97 83       	std	Z+7, r25	; 0x07
    3716:	86 83       	std	Z+6, r24	; 0x06
    3718:	f2 e0       	ldi	r31, 0x02	; 2
    371a:	7f 12       	cpse	r7, r31
    371c:	2d c1       	rjmp	.+602    	; 0x3978 <xQueueGenericSend+0x368>
    371e:	f8 01       	movw	r30, r16
    3720:	82 8d       	ldd	r24, Z+26	; 0x1a
    3722:	88 23       	and	r24, r24
    3724:	09 f4       	brne	.+2      	; 0x3728 <xQueueGenericSend+0x118>
    3726:	28 c1       	rjmp	.+592    	; 0x3978 <xQueueGenericSend+0x368>
    3728:	82 8d       	ldd	r24, Z+26	; 0x1a
    372a:	81 50       	subi	r24, 0x01	; 1
    372c:	82 8f       	std	Z+26, r24	; 0x1a
    372e:	24 c1       	rjmp	.+584    	; 0x3978 <xQueueGenericSend+0x368>
    3730:	c8 01       	movw	r24, r16
    3732:	41 96       	adiw	r24, 0x11	; 17
    3734:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3738:	81 30       	cpi	r24, 0x01	; 1
    373a:	21 f4       	brne	.+8      	; 0x3744 <xQueueGenericSend+0x134>
    373c:	ba dc       	rcall	.-1676   	; 0x30b2 <vPortYield>
    373e:	02 c0       	rjmp	.+4      	; 0x3744 <xQueueGenericSend+0x134>
    3740:	81 11       	cpse	r24, r1
    3742:	b7 dc       	rcall	.-1682   	; 0x30b2 <vPortYield>
    3744:	0f 90       	pop	r0
    3746:	0f be       	out	0x3f, r0	; 63
    3748:	81 e0       	ldi	r24, 0x01	; 1
    374a:	1e c1       	rjmp	.+572    	; 0x3988 <xQueueGenericSend+0x378>
    374c:	8c 81       	ldd	r24, Y+4	; 0x04
    374e:	9d 81       	ldd	r25, Y+5	; 0x05
    3750:	89 2b       	or	r24, r25
    3752:	21 f4       	brne	.+8      	; 0x375c <xQueueGenericSend+0x14c>
    3754:	0f 90       	pop	r0
    3756:	0f be       	out	0x3f, r0	; 63
    3758:	80 e0       	ldi	r24, 0x00	; 0
    375a:	16 c1       	rjmp	.+556    	; 0x3988 <xQueueGenericSend+0x378>
    375c:	81 10       	cpse	r8, r1
    375e:	05 c0       	rjmp	.+10     	; 0x376a <xQueueGenericSend+0x15a>
    3760:	ce 01       	movw	r24, r28
    3762:	01 96       	adiw	r24, 0x01	; 1
    3764:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <vTaskSetTimeOutState>
    3768:	86 2c       	mov	r8, r6
    376a:	0f 90       	pop	r0
    376c:	0f be       	out	0x3f, r0	; 63
    376e:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <vTaskSuspendAll>
    3772:	0f b6       	in	r0, 0x3f	; 63
    3774:	f8 94       	cli
    3776:	0f 92       	push	r0
    3778:	f8 01       	movw	r30, r16
    377a:	85 8d       	ldd	r24, Z+29	; 0x1d
    377c:	8f 3f       	cpi	r24, 0xFF	; 255
    377e:	09 f4       	brne	.+2      	; 0x3782 <xQueueGenericSend+0x172>
    3780:	15 8e       	std	Z+29, r1	; 0x1d
    3782:	f8 01       	movw	r30, r16
    3784:	86 8d       	ldd	r24, Z+30	; 0x1e
    3786:	8f 3f       	cpi	r24, 0xFF	; 255
    3788:	09 f4       	brne	.+2      	; 0x378c <xQueueGenericSend+0x17c>
    378a:	16 8e       	std	Z+30, r1	; 0x1e
    378c:	0f 90       	pop	r0
    378e:	0f be       	out	0x3f, r0	; 63
    3790:	be 01       	movw	r22, r28
    3792:	6c 5f       	subi	r22, 0xFC	; 252
    3794:	7f 4f       	sbci	r23, 0xFF	; 255
    3796:	ce 01       	movw	r24, r28
    3798:	01 96       	adiw	r24, 0x01	; 1
    379a:	0e 94 03 2b 	call	0x5606	; 0x5606 <xTaskCheckForTimeOut>
    379e:	81 11       	cpse	r24, r1
    37a0:	96 c0       	rjmp	.+300    	; 0x38ce <xQueueGenericSend+0x2be>
    37a2:	0f b6       	in	r0, 0x3f	; 63
    37a4:	f8 94       	cli
    37a6:	0f 92       	push	r0
    37a8:	f8 01       	movw	r30, r16
    37aa:	92 8d       	ldd	r25, Z+26	; 0x1a
    37ac:	83 8d       	ldd	r24, Z+27	; 0x1b
    37ae:	0f 90       	pop	r0
    37b0:	0f be       	out	0x3f, r0	; 63
    37b2:	98 13       	cpse	r25, r24
    37b4:	4a c0       	rjmp	.+148    	; 0x384a <xQueueGenericSend+0x23a>
    37b6:	6c 81       	ldd	r22, Y+4	; 0x04
    37b8:	7d 81       	ldd	r23, Y+5	; 0x05
    37ba:	c7 01       	movw	r24, r14
    37bc:	0e 94 55 2a 	call	0x54aa	; 0x54aa <vTaskPlaceOnEventList>
    37c0:	0f b6       	in	r0, 0x3f	; 63
    37c2:	f8 94       	cli
    37c4:	0f 92       	push	r0
    37c6:	f8 01       	movw	r30, r16
    37c8:	86 8d       	ldd	r24, Z+30	; 0x1e
    37ca:	18 16       	cp	r1, r24
    37cc:	ac f4       	brge	.+42     	; 0x37f8 <xQueueGenericSend+0x1e8>
    37ce:	81 89       	ldd	r24, Z+17	; 0x11
    37d0:	81 11       	cpse	r24, r1
    37d2:	05 c0       	rjmp	.+10     	; 0x37de <xQueueGenericSend+0x1ce>
    37d4:	11 c0       	rjmp	.+34     	; 0x37f8 <xQueueGenericSend+0x1e8>
    37d6:	f8 01       	movw	r30, r16
    37d8:	81 89       	ldd	r24, Z+17	; 0x11
    37da:	88 23       	and	r24, r24
    37dc:	69 f0       	breq	.+26     	; 0x37f8 <xQueueGenericSend+0x1e8>
    37de:	c6 01       	movw	r24, r12
    37e0:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    37e4:	81 11       	cpse	r24, r1
    37e6:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    37ea:	f8 01       	movw	r30, r16
    37ec:	86 8d       	ldd	r24, Z+30	; 0x1e
    37ee:	81 50       	subi	r24, 0x01	; 1
    37f0:	86 8f       	std	Z+30, r24	; 0x1e
    37f2:	86 8d       	ldd	r24, Z+30	; 0x1e
    37f4:	18 16       	cp	r1, r24
    37f6:	7c f3       	brlt	.-34     	; 0x37d6 <xQueueGenericSend+0x1c6>
    37f8:	f8 01       	movw	r30, r16
    37fa:	96 8e       	std	Z+30, r9	; 0x1e
    37fc:	0f 90       	pop	r0
    37fe:	0f be       	out	0x3f, r0	; 63
    3800:	0f b6       	in	r0, 0x3f	; 63
    3802:	f8 94       	cli
    3804:	0f 92       	push	r0
    3806:	85 8d       	ldd	r24, Z+29	; 0x1d
    3808:	18 16       	cp	r1, r24
    380a:	ac f4       	brge	.+42     	; 0x3836 <xQueueGenericSend+0x226>
    380c:	80 85       	ldd	r24, Z+8	; 0x08
    380e:	81 11       	cpse	r24, r1
    3810:	05 c0       	rjmp	.+10     	; 0x381c <xQueueGenericSend+0x20c>
    3812:	11 c0       	rjmp	.+34     	; 0x3836 <xQueueGenericSend+0x226>
    3814:	f8 01       	movw	r30, r16
    3816:	80 85       	ldd	r24, Z+8	; 0x08
    3818:	88 23       	and	r24, r24
    381a:	69 f0       	breq	.+26     	; 0x3836 <xQueueGenericSend+0x226>
    381c:	c7 01       	movw	r24, r14
    381e:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3822:	81 11       	cpse	r24, r1
    3824:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3828:	f8 01       	movw	r30, r16
    382a:	85 8d       	ldd	r24, Z+29	; 0x1d
    382c:	81 50       	subi	r24, 0x01	; 1
    382e:	85 8f       	std	Z+29, r24	; 0x1d
    3830:	85 8d       	ldd	r24, Z+29	; 0x1d
    3832:	18 16       	cp	r1, r24
    3834:	7c f3       	brlt	.-34     	; 0x3814 <xQueueGenericSend+0x204>
    3836:	f8 01       	movw	r30, r16
    3838:	95 8e       	std	Z+29, r9	; 0x1d
    383a:	0f 90       	pop	r0
    383c:	0f be       	out	0x3f, r0	; 63
    383e:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    3842:	81 11       	cpse	r24, r1
    3844:	0a cf       	rjmp	.-492    	; 0x365a <xQueueGenericSend+0x4a>
    3846:	35 dc       	rcall	.-1942   	; 0x30b2 <vPortYield>
    3848:	08 cf       	rjmp	.-496    	; 0x365a <xQueueGenericSend+0x4a>
    384a:	0f b6       	in	r0, 0x3f	; 63
    384c:	f8 94       	cli
    384e:	0f 92       	push	r0
    3850:	f8 01       	movw	r30, r16
    3852:	86 8d       	ldd	r24, Z+30	; 0x1e
    3854:	18 16       	cp	r1, r24
    3856:	ac f4       	brge	.+42     	; 0x3882 <xQueueGenericSend+0x272>
    3858:	81 89       	ldd	r24, Z+17	; 0x11
    385a:	81 11       	cpse	r24, r1
    385c:	05 c0       	rjmp	.+10     	; 0x3868 <xQueueGenericSend+0x258>
    385e:	11 c0       	rjmp	.+34     	; 0x3882 <xQueueGenericSend+0x272>
    3860:	f8 01       	movw	r30, r16
    3862:	81 89       	ldd	r24, Z+17	; 0x11
    3864:	88 23       	and	r24, r24
    3866:	69 f0       	breq	.+26     	; 0x3882 <xQueueGenericSend+0x272>
    3868:	c6 01       	movw	r24, r12
    386a:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    386e:	81 11       	cpse	r24, r1
    3870:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3874:	f8 01       	movw	r30, r16
    3876:	86 8d       	ldd	r24, Z+30	; 0x1e
    3878:	81 50       	subi	r24, 0x01	; 1
    387a:	86 8f       	std	Z+30, r24	; 0x1e
    387c:	86 8d       	ldd	r24, Z+30	; 0x1e
    387e:	18 16       	cp	r1, r24
    3880:	7c f3       	brlt	.-34     	; 0x3860 <xQueueGenericSend+0x250>
    3882:	f8 01       	movw	r30, r16
    3884:	96 8e       	std	Z+30, r9	; 0x1e
    3886:	0f 90       	pop	r0
    3888:	0f be       	out	0x3f, r0	; 63
    388a:	0f b6       	in	r0, 0x3f	; 63
    388c:	f8 94       	cli
    388e:	0f 92       	push	r0
    3890:	85 8d       	ldd	r24, Z+29	; 0x1d
    3892:	18 16       	cp	r1, r24
    3894:	ac f4       	brge	.+42     	; 0x38c0 <xQueueGenericSend+0x2b0>
    3896:	80 85       	ldd	r24, Z+8	; 0x08
    3898:	81 11       	cpse	r24, r1
    389a:	05 c0       	rjmp	.+10     	; 0x38a6 <xQueueGenericSend+0x296>
    389c:	11 c0       	rjmp	.+34     	; 0x38c0 <xQueueGenericSend+0x2b0>
    389e:	f8 01       	movw	r30, r16
    38a0:	80 85       	ldd	r24, Z+8	; 0x08
    38a2:	88 23       	and	r24, r24
    38a4:	69 f0       	breq	.+26     	; 0x38c0 <xQueueGenericSend+0x2b0>
    38a6:	c7 01       	movw	r24, r14
    38a8:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    38ac:	81 11       	cpse	r24, r1
    38ae:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    38b2:	f8 01       	movw	r30, r16
    38b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    38b6:	81 50       	subi	r24, 0x01	; 1
    38b8:	85 8f       	std	Z+29, r24	; 0x1d
    38ba:	85 8d       	ldd	r24, Z+29	; 0x1d
    38bc:	18 16       	cp	r1, r24
    38be:	7c f3       	brlt	.-34     	; 0x389e <xQueueGenericSend+0x28e>
    38c0:	f8 01       	movw	r30, r16
    38c2:	95 8e       	std	Z+29, r9	; 0x1d
    38c4:	0f 90       	pop	r0
    38c6:	0f be       	out	0x3f, r0	; 63
    38c8:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    38cc:	c6 ce       	rjmp	.-628    	; 0x365a <xQueueGenericSend+0x4a>
    38ce:	0f b6       	in	r0, 0x3f	; 63
    38d0:	f8 94       	cli
    38d2:	0f 92       	push	r0
    38d4:	f8 01       	movw	r30, r16
    38d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    38d8:	18 16       	cp	r1, r24
    38da:	d4 f4       	brge	.+52     	; 0x3910 <xQueueGenericSend+0x300>
    38dc:	81 89       	ldd	r24, Z+17	; 0x11
    38de:	81 11       	cpse	r24, r1
    38e0:	06 c0       	rjmp	.+12     	; 0x38ee <xQueueGenericSend+0x2de>
    38e2:	16 c0       	rjmp	.+44     	; 0x3910 <xQueueGenericSend+0x300>
    38e4:	f8 01       	movw	r30, r16
    38e6:	81 89       	ldd	r24, Z+17	; 0x11
    38e8:	81 11       	cpse	r24, r1
    38ea:	05 c0       	rjmp	.+10     	; 0x38f6 <xQueueGenericSend+0x2e6>
    38ec:	11 c0       	rjmp	.+34     	; 0x3910 <xQueueGenericSend+0x300>
    38ee:	78 01       	movw	r14, r16
    38f0:	f1 e1       	ldi	r31, 0x11	; 17
    38f2:	ef 0e       	add	r14, r31
    38f4:	f1 1c       	adc	r15, r1
    38f6:	c7 01       	movw	r24, r14
    38f8:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    38fc:	81 11       	cpse	r24, r1
    38fe:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3902:	f8 01       	movw	r30, r16
    3904:	86 8d       	ldd	r24, Z+30	; 0x1e
    3906:	81 50       	subi	r24, 0x01	; 1
    3908:	86 8f       	std	Z+30, r24	; 0x1e
    390a:	86 8d       	ldd	r24, Z+30	; 0x1e
    390c:	18 16       	cp	r1, r24
    390e:	54 f3       	brlt	.-44     	; 0x38e4 <xQueueGenericSend+0x2d4>
    3910:	8f ef       	ldi	r24, 0xFF	; 255
    3912:	f8 01       	movw	r30, r16
    3914:	86 8f       	std	Z+30, r24	; 0x1e
    3916:	0f 90       	pop	r0
    3918:	0f be       	out	0x3f, r0	; 63
    391a:	0f b6       	in	r0, 0x3f	; 63
    391c:	f8 94       	cli
    391e:	0f 92       	push	r0
    3920:	85 8d       	ldd	r24, Z+29	; 0x1d
    3922:	18 16       	cp	r1, r24
    3924:	d4 f4       	brge	.+52     	; 0x395a <xQueueGenericSend+0x34a>
    3926:	80 85       	ldd	r24, Z+8	; 0x08
    3928:	81 11       	cpse	r24, r1
    392a:	06 c0       	rjmp	.+12     	; 0x3938 <xQueueGenericSend+0x328>
    392c:	16 c0       	rjmp	.+44     	; 0x395a <xQueueGenericSend+0x34a>
    392e:	f8 01       	movw	r30, r16
    3930:	80 85       	ldd	r24, Z+8	; 0x08
    3932:	81 11       	cpse	r24, r1
    3934:	05 c0       	rjmp	.+10     	; 0x3940 <xQueueGenericSend+0x330>
    3936:	11 c0       	rjmp	.+34     	; 0x395a <xQueueGenericSend+0x34a>
    3938:	78 01       	movw	r14, r16
    393a:	f8 e0       	ldi	r31, 0x08	; 8
    393c:	ef 0e       	add	r14, r31
    393e:	f1 1c       	adc	r15, r1
    3940:	c7 01       	movw	r24, r14
    3942:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3946:	81 11       	cpse	r24, r1
    3948:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    394c:	f8 01       	movw	r30, r16
    394e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3950:	81 50       	subi	r24, 0x01	; 1
    3952:	85 8f       	std	Z+29, r24	; 0x1d
    3954:	85 8d       	ldd	r24, Z+29	; 0x1d
    3956:	18 16       	cp	r1, r24
    3958:	54 f3       	brlt	.-44     	; 0x392e <xQueueGenericSend+0x31e>
    395a:	8f ef       	ldi	r24, 0xFF	; 255
    395c:	f8 01       	movw	r30, r16
    395e:	85 8f       	std	Z+29, r24	; 0x1d
    3960:	0f 90       	pop	r0
    3962:	0f be       	out	0x3f, r0	; 63
    3964:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    3968:	80 e0       	ldi	r24, 0x00	; 0
    396a:	0e c0       	rjmp	.+28     	; 0x3988 <xQueueGenericSend+0x378>
    396c:	f8 01       	movw	r30, r16
    396e:	44 8d       	ldd	r20, Z+28	; 0x1c
    3970:	44 23       	and	r20, r20
    3972:	09 f4       	brne	.+2      	; 0x3976 <xQueueGenericSend+0x366>
    3974:	82 ce       	rjmp	.-764    	; 0x367a <xQueueGenericSend+0x6a>
    3976:	b2 ce       	rjmp	.-668    	; 0x36dc <xQueueGenericSend+0xcc>
    3978:	f8 01       	movw	r30, r16
    397a:	82 8d       	ldd	r24, Z+26	; 0x1a
    397c:	8f 5f       	subi	r24, 0xFF	; 255
    397e:	82 8f       	std	Z+26, r24	; 0x1a
    3980:	81 89       	ldd	r24, Z+17	; 0x11
    3982:	81 11       	cpse	r24, r1
    3984:	d5 ce       	rjmp	.-598    	; 0x3730 <xQueueGenericSend+0x120>
    3986:	de ce       	rjmp	.-580    	; 0x3744 <xQueueGenericSend+0x134>
    3988:	0f 90       	pop	r0
    398a:	0f 90       	pop	r0
    398c:	0f 90       	pop	r0
    398e:	0f 90       	pop	r0
    3990:	0f 90       	pop	r0
    3992:	df 91       	pop	r29
    3994:	cf 91       	pop	r28
    3996:	1f 91       	pop	r17
    3998:	0f 91       	pop	r16
    399a:	ff 90       	pop	r15
    399c:	ef 90       	pop	r14
    399e:	df 90       	pop	r13
    39a0:	cf 90       	pop	r12
    39a2:	bf 90       	pop	r11
    39a4:	af 90       	pop	r10
    39a6:	9f 90       	pop	r9
    39a8:	8f 90       	pop	r8
    39aa:	7f 90       	pop	r7
    39ac:	6f 90       	pop	r6
    39ae:	08 95       	ret

000039b0 <xQueueGive>:
    39b0:	9f 92       	push	r9
    39b2:	af 92       	push	r10
    39b4:	bf 92       	push	r11
    39b6:	cf 92       	push	r12
    39b8:	df 92       	push	r13
    39ba:	ef 92       	push	r14
    39bc:	ff 92       	push	r15
    39be:	0f 93       	push	r16
    39c0:	1f 93       	push	r17
    39c2:	cf 93       	push	r28
    39c4:	df 93       	push	r29
    39c6:	00 d0       	rcall	.+0      	; 0x39c8 <xQueueGive+0x18>
    39c8:	1f 92       	push	r1
    39ca:	1f 92       	push	r1
    39cc:	cd b7       	in	r28, 0x3d	; 61
    39ce:	de b7       	in	r29, 0x3e	; 62
    39d0:	8c 01       	movw	r16, r24
    39d2:	7d 83       	std	Y+5, r23	; 0x05
    39d4:	6c 83       	std	Y+4, r22	; 0x04
    39d6:	a1 2c       	mov	r10, r1
    39d8:	99 24       	eor	r9, r9
    39da:	93 94       	inc	r9
    39dc:	bb 24       	eor	r11, r11
    39de:	ba 94       	dec	r11
    39e0:	7c 01       	movw	r14, r24
    39e2:	88 e0       	ldi	r24, 0x08	; 8
    39e4:	e8 0e       	add	r14, r24
    39e6:	f1 1c       	adc	r15, r1
    39e8:	68 01       	movw	r12, r16
    39ea:	e1 e1       	ldi	r30, 0x11	; 17
    39ec:	ce 0e       	add	r12, r30
    39ee:	d1 1c       	adc	r13, r1
    39f0:	0f b6       	in	r0, 0x3f	; 63
    39f2:	f8 94       	cli
    39f4:	0f 92       	push	r0
    39f6:	f8 01       	movw	r30, r16
    39f8:	92 8d       	ldd	r25, Z+26	; 0x1a
    39fa:	83 8d       	ldd	r24, Z+27	; 0x1b
    39fc:	98 17       	cp	r25, r24
    39fe:	00 f5       	brcc	.+64     	; 0x3a40 <xQueueGive+0x90>
    3a00:	80 81       	ld	r24, Z
    3a02:	91 81       	ldd	r25, Z+1	; 0x01
    3a04:	89 2b       	or	r24, r25
    3a06:	09 f0       	breq	.+2      	; 0x3a0a <xQueueGive+0x5a>
    3a08:	2b c1       	rjmp	.+598    	; 0x3c60 <xQueueGive+0x2b0>
    3a0a:	82 81       	ldd	r24, Z+2	; 0x02
    3a0c:	93 81       	ldd	r25, Z+3	; 0x03
    3a0e:	0e 94 a9 2b 	call	0x5752	; 0x5752 <xTaskPriorityDisinherit>
    3a12:	f8 01       	movw	r30, r16
    3a14:	13 82       	std	Z+3, r1	; 0x03
    3a16:	12 82       	std	Z+2, r1	; 0x02
    3a18:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a1a:	9f 5f       	subi	r25, 0xFF	; 255
    3a1c:	92 8f       	std	Z+26, r25	; 0x1a
    3a1e:	91 89       	ldd	r25, Z+17	; 0x11
    3a20:	99 23       	and	r25, r25
    3a22:	41 f0       	breq	.+16     	; 0x3a34 <xQueueGive+0x84>
    3a24:	c8 01       	movw	r24, r16
    3a26:	41 96       	adiw	r24, 0x11	; 17
    3a28:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3a2c:	81 30       	cpi	r24, 0x01	; 1
    3a2e:	21 f4       	brne	.+8      	; 0x3a38 <xQueueGive+0x88>
    3a30:	40 db       	rcall	.-2432   	; 0x30b2 <vPortYield>
    3a32:	02 c0       	rjmp	.+4      	; 0x3a38 <xQueueGive+0x88>
    3a34:	81 11       	cpse	r24, r1
    3a36:	3d db       	rcall	.-2438   	; 0x30b2 <vPortYield>
    3a38:	0f 90       	pop	r0
    3a3a:	0f be       	out	0x3f, r0	; 63
    3a3c:	81 e0       	ldi	r24, 0x01	; 1
    3a3e:	18 c1       	rjmp	.+560    	; 0x3c70 <xQueueGive+0x2c0>
    3a40:	8c 81       	ldd	r24, Y+4	; 0x04
    3a42:	9d 81       	ldd	r25, Y+5	; 0x05
    3a44:	89 2b       	or	r24, r25
    3a46:	21 f4       	brne	.+8      	; 0x3a50 <xQueueGive+0xa0>
    3a48:	0f 90       	pop	r0
    3a4a:	0f be       	out	0x3f, r0	; 63
    3a4c:	80 e0       	ldi	r24, 0x00	; 0
    3a4e:	10 c1       	rjmp	.+544    	; 0x3c70 <xQueueGive+0x2c0>
    3a50:	a1 10       	cpse	r10, r1
    3a52:	05 c0       	rjmp	.+10     	; 0x3a5e <xQueueGive+0xae>
    3a54:	ce 01       	movw	r24, r28
    3a56:	01 96       	adiw	r24, 0x01	; 1
    3a58:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <vTaskSetTimeOutState>
    3a5c:	a9 2c       	mov	r10, r9
    3a5e:	0f 90       	pop	r0
    3a60:	0f be       	out	0x3f, r0	; 63
    3a62:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <vTaskSuspendAll>
    3a66:	0f b6       	in	r0, 0x3f	; 63
    3a68:	f8 94       	cli
    3a6a:	0f 92       	push	r0
    3a6c:	f8 01       	movw	r30, r16
    3a6e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3a70:	8f 3f       	cpi	r24, 0xFF	; 255
    3a72:	09 f4       	brne	.+2      	; 0x3a76 <xQueueGive+0xc6>
    3a74:	15 8e       	std	Z+29, r1	; 0x1d
    3a76:	f8 01       	movw	r30, r16
    3a78:	86 8d       	ldd	r24, Z+30	; 0x1e
    3a7a:	8f 3f       	cpi	r24, 0xFF	; 255
    3a7c:	09 f4       	brne	.+2      	; 0x3a80 <xQueueGive+0xd0>
    3a7e:	16 8e       	std	Z+30, r1	; 0x1e
    3a80:	0f 90       	pop	r0
    3a82:	0f be       	out	0x3f, r0	; 63
    3a84:	be 01       	movw	r22, r28
    3a86:	6c 5f       	subi	r22, 0xFC	; 252
    3a88:	7f 4f       	sbci	r23, 0xFF	; 255
    3a8a:	ce 01       	movw	r24, r28
    3a8c:	01 96       	adiw	r24, 0x01	; 1
    3a8e:	0e 94 03 2b 	call	0x5606	; 0x5606 <xTaskCheckForTimeOut>
    3a92:	81 11       	cpse	r24, r1
    3a94:	96 c0       	rjmp	.+300    	; 0x3bc2 <xQueueGive+0x212>
    3a96:	0f b6       	in	r0, 0x3f	; 63
    3a98:	f8 94       	cli
    3a9a:	0f 92       	push	r0
    3a9c:	f8 01       	movw	r30, r16
    3a9e:	92 8d       	ldd	r25, Z+26	; 0x1a
    3aa0:	83 8d       	ldd	r24, Z+27	; 0x1b
    3aa2:	0f 90       	pop	r0
    3aa4:	0f be       	out	0x3f, r0	; 63
    3aa6:	98 13       	cpse	r25, r24
    3aa8:	4a c0       	rjmp	.+148    	; 0x3b3e <xQueueGive+0x18e>
    3aaa:	6c 81       	ldd	r22, Y+4	; 0x04
    3aac:	7d 81       	ldd	r23, Y+5	; 0x05
    3aae:	c7 01       	movw	r24, r14
    3ab0:	0e 94 55 2a 	call	0x54aa	; 0x54aa <vTaskPlaceOnEventList>
    3ab4:	0f b6       	in	r0, 0x3f	; 63
    3ab6:	f8 94       	cli
    3ab8:	0f 92       	push	r0
    3aba:	f8 01       	movw	r30, r16
    3abc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3abe:	18 16       	cp	r1, r24
    3ac0:	ac f4       	brge	.+42     	; 0x3aec <xQueueGive+0x13c>
    3ac2:	81 89       	ldd	r24, Z+17	; 0x11
    3ac4:	81 11       	cpse	r24, r1
    3ac6:	05 c0       	rjmp	.+10     	; 0x3ad2 <xQueueGive+0x122>
    3ac8:	11 c0       	rjmp	.+34     	; 0x3aec <xQueueGive+0x13c>
    3aca:	f8 01       	movw	r30, r16
    3acc:	81 89       	ldd	r24, Z+17	; 0x11
    3ace:	88 23       	and	r24, r24
    3ad0:	69 f0       	breq	.+26     	; 0x3aec <xQueueGive+0x13c>
    3ad2:	c6 01       	movw	r24, r12
    3ad4:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3ad8:	81 11       	cpse	r24, r1
    3ada:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3ade:	f8 01       	movw	r30, r16
    3ae0:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ae2:	81 50       	subi	r24, 0x01	; 1
    3ae4:	86 8f       	std	Z+30, r24	; 0x1e
    3ae6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ae8:	18 16       	cp	r1, r24
    3aea:	7c f3       	brlt	.-34     	; 0x3aca <xQueueGive+0x11a>
    3aec:	f8 01       	movw	r30, r16
    3aee:	b6 8e       	std	Z+30, r11	; 0x1e
    3af0:	0f 90       	pop	r0
    3af2:	0f be       	out	0x3f, r0	; 63
    3af4:	0f b6       	in	r0, 0x3f	; 63
    3af6:	f8 94       	cli
    3af8:	0f 92       	push	r0
    3afa:	85 8d       	ldd	r24, Z+29	; 0x1d
    3afc:	18 16       	cp	r1, r24
    3afe:	ac f4       	brge	.+42     	; 0x3b2a <xQueueGive+0x17a>
    3b00:	80 85       	ldd	r24, Z+8	; 0x08
    3b02:	81 11       	cpse	r24, r1
    3b04:	05 c0       	rjmp	.+10     	; 0x3b10 <xQueueGive+0x160>
    3b06:	11 c0       	rjmp	.+34     	; 0x3b2a <xQueueGive+0x17a>
    3b08:	f8 01       	movw	r30, r16
    3b0a:	80 85       	ldd	r24, Z+8	; 0x08
    3b0c:	88 23       	and	r24, r24
    3b0e:	69 f0       	breq	.+26     	; 0x3b2a <xQueueGive+0x17a>
    3b10:	c7 01       	movw	r24, r14
    3b12:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3b16:	81 11       	cpse	r24, r1
    3b18:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3b1c:	f8 01       	movw	r30, r16
    3b1e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b20:	81 50       	subi	r24, 0x01	; 1
    3b22:	85 8f       	std	Z+29, r24	; 0x1d
    3b24:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b26:	18 16       	cp	r1, r24
    3b28:	7c f3       	brlt	.-34     	; 0x3b08 <xQueueGive+0x158>
    3b2a:	f8 01       	movw	r30, r16
    3b2c:	b5 8e       	std	Z+29, r11	; 0x1d
    3b2e:	0f 90       	pop	r0
    3b30:	0f be       	out	0x3f, r0	; 63
    3b32:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    3b36:	81 11       	cpse	r24, r1
    3b38:	5b cf       	rjmp	.-330    	; 0x39f0 <xQueueGive+0x40>
    3b3a:	bb da       	rcall	.-2698   	; 0x30b2 <vPortYield>
    3b3c:	59 cf       	rjmp	.-334    	; 0x39f0 <xQueueGive+0x40>
    3b3e:	0f b6       	in	r0, 0x3f	; 63
    3b40:	f8 94       	cli
    3b42:	0f 92       	push	r0
    3b44:	f8 01       	movw	r30, r16
    3b46:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b48:	18 16       	cp	r1, r24
    3b4a:	ac f4       	brge	.+42     	; 0x3b76 <xQueueGive+0x1c6>
    3b4c:	81 89       	ldd	r24, Z+17	; 0x11
    3b4e:	81 11       	cpse	r24, r1
    3b50:	05 c0       	rjmp	.+10     	; 0x3b5c <xQueueGive+0x1ac>
    3b52:	11 c0       	rjmp	.+34     	; 0x3b76 <xQueueGive+0x1c6>
    3b54:	f8 01       	movw	r30, r16
    3b56:	81 89       	ldd	r24, Z+17	; 0x11
    3b58:	88 23       	and	r24, r24
    3b5a:	69 f0       	breq	.+26     	; 0x3b76 <xQueueGive+0x1c6>
    3b5c:	c6 01       	movw	r24, r12
    3b5e:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3b62:	81 11       	cpse	r24, r1
    3b64:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3b68:	f8 01       	movw	r30, r16
    3b6a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b6c:	81 50       	subi	r24, 0x01	; 1
    3b6e:	86 8f       	std	Z+30, r24	; 0x1e
    3b70:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b72:	18 16       	cp	r1, r24
    3b74:	7c f3       	brlt	.-34     	; 0x3b54 <xQueueGive+0x1a4>
    3b76:	f8 01       	movw	r30, r16
    3b78:	b6 8e       	std	Z+30, r11	; 0x1e
    3b7a:	0f 90       	pop	r0
    3b7c:	0f be       	out	0x3f, r0	; 63
    3b7e:	0f b6       	in	r0, 0x3f	; 63
    3b80:	f8 94       	cli
    3b82:	0f 92       	push	r0
    3b84:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b86:	18 16       	cp	r1, r24
    3b88:	ac f4       	brge	.+42     	; 0x3bb4 <xQueueGive+0x204>
    3b8a:	80 85       	ldd	r24, Z+8	; 0x08
    3b8c:	81 11       	cpse	r24, r1
    3b8e:	05 c0       	rjmp	.+10     	; 0x3b9a <xQueueGive+0x1ea>
    3b90:	11 c0       	rjmp	.+34     	; 0x3bb4 <xQueueGive+0x204>
    3b92:	f8 01       	movw	r30, r16
    3b94:	80 85       	ldd	r24, Z+8	; 0x08
    3b96:	88 23       	and	r24, r24
    3b98:	69 f0       	breq	.+26     	; 0x3bb4 <xQueueGive+0x204>
    3b9a:	c7 01       	movw	r24, r14
    3b9c:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3ba0:	81 11       	cpse	r24, r1
    3ba2:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3ba6:	f8 01       	movw	r30, r16
    3ba8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3baa:	81 50       	subi	r24, 0x01	; 1
    3bac:	85 8f       	std	Z+29, r24	; 0x1d
    3bae:	85 8d       	ldd	r24, Z+29	; 0x1d
    3bb0:	18 16       	cp	r1, r24
    3bb2:	7c f3       	brlt	.-34     	; 0x3b92 <xQueueGive+0x1e2>
    3bb4:	f8 01       	movw	r30, r16
    3bb6:	b5 8e       	std	Z+29, r11	; 0x1d
    3bb8:	0f 90       	pop	r0
    3bba:	0f be       	out	0x3f, r0	; 63
    3bbc:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    3bc0:	17 cf       	rjmp	.-466    	; 0x39f0 <xQueueGive+0x40>
    3bc2:	0f b6       	in	r0, 0x3f	; 63
    3bc4:	f8 94       	cli
    3bc6:	0f 92       	push	r0
    3bc8:	f8 01       	movw	r30, r16
    3bca:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bcc:	18 16       	cp	r1, r24
    3bce:	d4 f4       	brge	.+52     	; 0x3c04 <xQueueGive+0x254>
    3bd0:	81 89       	ldd	r24, Z+17	; 0x11
    3bd2:	81 11       	cpse	r24, r1
    3bd4:	06 c0       	rjmp	.+12     	; 0x3be2 <xQueueGive+0x232>
    3bd6:	16 c0       	rjmp	.+44     	; 0x3c04 <xQueueGive+0x254>
    3bd8:	f8 01       	movw	r30, r16
    3bda:	81 89       	ldd	r24, Z+17	; 0x11
    3bdc:	81 11       	cpse	r24, r1
    3bde:	05 c0       	rjmp	.+10     	; 0x3bea <xQueueGive+0x23a>
    3be0:	11 c0       	rjmp	.+34     	; 0x3c04 <xQueueGive+0x254>
    3be2:	78 01       	movw	r14, r16
    3be4:	f1 e1       	ldi	r31, 0x11	; 17
    3be6:	ef 0e       	add	r14, r31
    3be8:	f1 1c       	adc	r15, r1
    3bea:	c7 01       	movw	r24, r14
    3bec:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3bf0:	81 11       	cpse	r24, r1
    3bf2:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3bf6:	f8 01       	movw	r30, r16
    3bf8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bfa:	81 50       	subi	r24, 0x01	; 1
    3bfc:	86 8f       	std	Z+30, r24	; 0x1e
    3bfe:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c00:	18 16       	cp	r1, r24
    3c02:	54 f3       	brlt	.-44     	; 0x3bd8 <xQueueGive+0x228>
    3c04:	8f ef       	ldi	r24, 0xFF	; 255
    3c06:	f8 01       	movw	r30, r16
    3c08:	86 8f       	std	Z+30, r24	; 0x1e
    3c0a:	0f 90       	pop	r0
    3c0c:	0f be       	out	0x3f, r0	; 63
    3c0e:	0f b6       	in	r0, 0x3f	; 63
    3c10:	f8 94       	cli
    3c12:	0f 92       	push	r0
    3c14:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c16:	18 16       	cp	r1, r24
    3c18:	d4 f4       	brge	.+52     	; 0x3c4e <xQueueGive+0x29e>
    3c1a:	80 85       	ldd	r24, Z+8	; 0x08
    3c1c:	81 11       	cpse	r24, r1
    3c1e:	06 c0       	rjmp	.+12     	; 0x3c2c <xQueueGive+0x27c>
    3c20:	16 c0       	rjmp	.+44     	; 0x3c4e <xQueueGive+0x29e>
    3c22:	f8 01       	movw	r30, r16
    3c24:	80 85       	ldd	r24, Z+8	; 0x08
    3c26:	81 11       	cpse	r24, r1
    3c28:	05 c0       	rjmp	.+10     	; 0x3c34 <xQueueGive+0x284>
    3c2a:	11 c0       	rjmp	.+34     	; 0x3c4e <xQueueGive+0x29e>
    3c2c:	78 01       	movw	r14, r16
    3c2e:	f8 e0       	ldi	r31, 0x08	; 8
    3c30:	ef 0e       	add	r14, r31
    3c32:	f1 1c       	adc	r15, r1
    3c34:	c7 01       	movw	r24, r14
    3c36:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3c3a:	81 11       	cpse	r24, r1
    3c3c:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
    3c40:	f8 01       	movw	r30, r16
    3c42:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c44:	81 50       	subi	r24, 0x01	; 1
    3c46:	85 8f       	std	Z+29, r24	; 0x1d
    3c48:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c4a:	18 16       	cp	r1, r24
    3c4c:	54 f3       	brlt	.-44     	; 0x3c22 <xQueueGive+0x272>
    3c4e:	8f ef       	ldi	r24, 0xFF	; 255
    3c50:	f8 01       	movw	r30, r16
    3c52:	85 8f       	std	Z+29, r24	; 0x1d
    3c54:	0f 90       	pop	r0
    3c56:	0f be       	out	0x3f, r0	; 63
    3c58:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    3c5c:	80 e0       	ldi	r24, 0x00	; 0
    3c5e:	08 c0       	rjmp	.+16     	; 0x3c70 <xQueueGive+0x2c0>
    3c60:	f8 01       	movw	r30, r16
    3c62:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c64:	8f 5f       	subi	r24, 0xFF	; 255
    3c66:	82 8f       	std	Z+26, r24	; 0x1a
    3c68:	81 89       	ldd	r24, Z+17	; 0x11
    3c6a:	81 11       	cpse	r24, r1
    3c6c:	db ce       	rjmp	.-586    	; 0x3a24 <xQueueGive+0x74>
    3c6e:	e4 ce       	rjmp	.-568    	; 0x3a38 <xQueueGive+0x88>
    3c70:	0f 90       	pop	r0
    3c72:	0f 90       	pop	r0
    3c74:	0f 90       	pop	r0
    3c76:	0f 90       	pop	r0
    3c78:	0f 90       	pop	r0
    3c7a:	df 91       	pop	r29
    3c7c:	cf 91       	pop	r28
    3c7e:	1f 91       	pop	r17
    3c80:	0f 91       	pop	r16
    3c82:	ff 90       	pop	r15
    3c84:	ef 90       	pop	r14
    3c86:	df 90       	pop	r13
    3c88:	cf 90       	pop	r12
    3c8a:	bf 90       	pop	r11
    3c8c:	af 90       	pop	r10
    3c8e:	9f 90       	pop	r9
    3c90:	08 95       	ret

00003c92 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3c92:	cf 93       	push	r28
    3c94:	df 93       	push	r29
    3c96:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3c98:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c9a:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c9c:	98 17       	cp	r25, r24
    3c9e:	d0 f4       	brcc	.+52     	; 0x3cd4 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    3ca0:	82 8d       	ldd	r24, Z+26	; 0x1a
    3ca2:	8f 5f       	subi	r24, 0xFF	; 255
    3ca4:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3ca6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ca8:	8f 3f       	cpi	r24, 0xFF	; 255
    3caa:	79 f4       	brne	.+30     	; 0x3cca <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3cac:	81 89       	ldd	r24, Z+17	; 0x11
    3cae:	88 23       	and	r24, r24
    3cb0:	99 f0       	breq	.+38     	; 0x3cd8 <xQueueGiveFromISR+0x46>
    3cb2:	eb 01       	movw	r28, r22
    3cb4:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3cb6:	41 96       	adiw	r24, 0x11	; 17
    3cb8:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3cbc:	88 23       	and	r24, r24
    3cbe:	71 f0       	breq	.+28     	; 0x3cdc <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3cc0:	20 97       	sbiw	r28, 0x00	; 0
    3cc2:	71 f0       	breq	.+28     	; 0x3ce0 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3cc4:	81 e0       	ldi	r24, 0x01	; 1
    3cc6:	88 83       	st	Y, r24
    3cc8:	0c c0       	rjmp	.+24     	; 0x3ce2 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3cca:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ccc:	8f 5f       	subi	r24, 0xFF	; 255
    3cce:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3cd0:	81 e0       	ldi	r24, 0x01	; 1
    3cd2:	07 c0       	rjmp	.+14     	; 0x3ce2 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3cd4:	80 e0       	ldi	r24, 0x00	; 0
    3cd6:	05 c0       	rjmp	.+10     	; 0x3ce2 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    3cd8:	81 e0       	ldi	r24, 0x01	; 1
    3cda:	03 c0       	rjmp	.+6      	; 0x3ce2 <xQueueGiveFromISR+0x50>
    3cdc:	81 e0       	ldi	r24, 0x01	; 1
    3cde:	01 c0       	rjmp	.+2      	; 0x3ce2 <xQueueGiveFromISR+0x50>
    3ce0:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3ce2:	df 91       	pop	r29
    3ce4:	cf 91       	pop	r28
    3ce6:	08 95       	ret

00003ce8 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    3ce8:	6f 92       	push	r6
    3cea:	7f 92       	push	r7
    3cec:	8f 92       	push	r8
    3cee:	9f 92       	push	r9
    3cf0:	af 92       	push	r10
    3cf2:	bf 92       	push	r11
    3cf4:	cf 92       	push	r12
    3cf6:	df 92       	push	r13
    3cf8:	ef 92       	push	r14
    3cfa:	ff 92       	push	r15
    3cfc:	0f 93       	push	r16
    3cfe:	1f 93       	push	r17
    3d00:	cf 93       	push	r28
    3d02:	df 93       	push	r29
    3d04:	00 d0       	rcall	.+0      	; 0x3d06 <xQueueGenericReceive+0x1e>
    3d06:	1f 92       	push	r1
    3d08:	1f 92       	push	r1
    3d0a:	cd b7       	in	r28, 0x3d	; 61
    3d0c:	de b7       	in	r29, 0x3e	; 62
    3d0e:	8c 01       	movw	r16, r24
    3d10:	5b 01       	movw	r10, r22
    3d12:	5d 83       	std	Y+5, r21	; 0x05
    3d14:	4c 83       	std	Y+4, r20	; 0x04
    3d16:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    3d18:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3d1a:	77 24       	eor	r7, r7
    3d1c:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3d1e:	99 24       	eor	r9, r9
    3d20:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3d22:	6c 01       	movw	r12, r24
    3d24:	88 e0       	ldi	r24, 0x08	; 8
    3d26:	c8 0e       	add	r12, r24
    3d28:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3d2a:	78 01       	movw	r14, r16
    3d2c:	e1 e1       	ldi	r30, 0x11	; 17
    3d2e:	ee 0e       	add	r14, r30
    3d30:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3d32:	0f b6       	in	r0, 0x3f	; 63
    3d34:	f8 94       	cli
    3d36:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3d38:	f8 01       	movw	r30, r16
    3d3a:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d3c:	88 23       	and	r24, r24
    3d3e:	09 f4       	brne	.+2      	; 0x3d42 <xQueueGenericReceive+0x5a>
    3d40:	45 c0       	rjmp	.+138    	; 0x3dcc <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    3d42:	e6 80       	ldd	r14, Z+6	; 0x06
    3d44:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3d46:	44 8d       	ldd	r20, Z+28	; 0x1c
    3d48:	44 23       	and	r20, r20
    3d4a:	a9 f0       	breq	.+42     	; 0x3d76 <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3d4c:	50 e0       	ldi	r21, 0x00	; 0
    3d4e:	c7 01       	movw	r24, r14
    3d50:	84 0f       	add	r24, r20
    3d52:	95 1f       	adc	r25, r21
    3d54:	97 83       	std	Z+7, r25	; 0x07
    3d56:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3d58:	22 81       	ldd	r18, Z+2	; 0x02
    3d5a:	33 81       	ldd	r19, Z+3	; 0x03
    3d5c:	82 17       	cp	r24, r18
    3d5e:	93 07       	cpc	r25, r19
    3d60:	20 f0       	brcs	.+8      	; 0x3d6a <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3d62:	80 81       	ld	r24, Z
    3d64:	91 81       	ldd	r25, Z+1	; 0x01
    3d66:	97 83       	std	Z+7, r25	; 0x07
    3d68:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    3d6a:	f8 01       	movw	r30, r16
    3d6c:	66 81       	ldd	r22, Z+6	; 0x06
    3d6e:	77 81       	ldd	r23, Z+7	; 0x07
    3d70:	c5 01       	movw	r24, r10
    3d72:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    3d76:	61 10       	cpse	r6, r1
    3d78:	19 c0       	rjmp	.+50     	; 0x3dac <xQueueGenericReceive+0xc4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    3d7a:	f8 01       	movw	r30, r16
    3d7c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d7e:	81 50       	subi	r24, 0x01	; 1
    3d80:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3d82:	80 81       	ld	r24, Z
    3d84:	91 81       	ldd	r25, Z+1	; 0x01
    3d86:	89 2b       	or	r24, r25
    3d88:	29 f4       	brne	.+10     	; 0x3d94 <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    3d8a:	0e 94 e9 2b 	call	0x57d2	; 0x57d2 <pvTaskIncrementMutexHeldCount>
    3d8e:	f8 01       	movw	r30, r16
    3d90:	93 83       	std	Z+3, r25	; 0x03
    3d92:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3d94:	f8 01       	movw	r30, r16
    3d96:	80 85       	ldd	r24, Z+8	; 0x08
    3d98:	88 23       	and	r24, r24
    3d9a:	a1 f0       	breq	.+40     	; 0x3dc4 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3d9c:	c8 01       	movw	r24, r16
    3d9e:	08 96       	adiw	r24, 0x08	; 8
    3da0:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3da4:	81 30       	cpi	r24, 0x01	; 1
    3da6:	71 f4       	brne	.+28     	; 0x3dc4 <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
    3da8:	84 d9       	rcall	.-3320   	; 0x30b2 <vPortYield>
    3daa:	0c c0       	rjmp	.+24     	; 0x3dc4 <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3dac:	f8 01       	movw	r30, r16
    3dae:	f7 82       	std	Z+7, r15	; 0x07
    3db0:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3db2:	81 89       	ldd	r24, Z+17	; 0x11
    3db4:	88 23       	and	r24, r24
    3db6:	31 f0       	breq	.+12     	; 0x3dc4 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3db8:	c8 01       	movw	r24, r16
    3dba:	41 96       	adiw	r24, 0x11	; 17
    3dbc:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3dc0:	81 11       	cpse	r24, r1
    3dc2:	77 d9       	rcall	.-3346   	; 0x30b2 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    3dc4:	0f 90       	pop	r0
    3dc6:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3dc8:	81 e0       	ldi	r24, 0x01	; 1
    3dca:	1a c1       	rjmp	.+564    	; 0x4000 <xQueueGenericReceive+0x318>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3dcc:	8c 81       	ldd	r24, Y+4	; 0x04
    3dce:	9d 81       	ldd	r25, Y+5	; 0x05
    3dd0:	89 2b       	or	r24, r25
    3dd2:	21 f4       	brne	.+8      	; 0x3ddc <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3dd4:	0f 90       	pop	r0
    3dd6:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3dd8:	80 e0       	ldi	r24, 0x00	; 0
    3dda:	12 c1       	rjmp	.+548    	; 0x4000 <xQueueGenericReceive+0x318>
				}
				else if( xEntryTimeSet == pdFALSE )
    3ddc:	81 10       	cpse	r8, r1
    3dde:	05 c0       	rjmp	.+10     	; 0x3dea <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3de0:	ce 01       	movw	r24, r28
    3de2:	01 96       	adiw	r24, 0x01	; 1
    3de4:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3de8:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3dea:	0f 90       	pop	r0
    3dec:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3dee:	0e 94 c1 27 	call	0x4f82	; 0x4f82 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3df2:	0f b6       	in	r0, 0x3f	; 63
    3df4:	f8 94       	cli
    3df6:	0f 92       	push	r0
    3df8:	f8 01       	movw	r30, r16
    3dfa:	85 8d       	ldd	r24, Z+29	; 0x1d
    3dfc:	8f 3f       	cpi	r24, 0xFF	; 255
    3dfe:	09 f4       	brne	.+2      	; 0x3e02 <xQueueGenericReceive+0x11a>
    3e00:	15 8e       	std	Z+29, r1	; 0x1d
    3e02:	f8 01       	movw	r30, r16
    3e04:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e06:	8f 3f       	cpi	r24, 0xFF	; 255
    3e08:	09 f4       	brne	.+2      	; 0x3e0c <xQueueGenericReceive+0x124>
    3e0a:	16 8e       	std	Z+30, r1	; 0x1e
    3e0c:	0f 90       	pop	r0
    3e0e:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3e10:	be 01       	movw	r22, r28
    3e12:	6c 5f       	subi	r22, 0xFC	; 252
    3e14:	7f 4f       	sbci	r23, 0xFF	; 255
    3e16:	ce 01       	movw	r24, r28
    3e18:	01 96       	adiw	r24, 0x01	; 1
    3e1a:	0e 94 03 2b 	call	0x5606	; 0x5606 <xTaskCheckForTimeOut>
    3e1e:	81 11       	cpse	r24, r1
    3e20:	a2 c0       	rjmp	.+324    	; 0x3f66 <xQueueGenericReceive+0x27e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3e22:	0f b6       	in	r0, 0x3f	; 63
    3e24:	f8 94       	cli
    3e26:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3e28:	f8 01       	movw	r30, r16
    3e2a:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    3e2c:	0f 90       	pop	r0
    3e2e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3e30:	81 11       	cpse	r24, r1
    3e32:	57 c0       	rjmp	.+174    	; 0x3ee2 <xQueueGenericReceive+0x1fa>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3e34:	80 81       	ld	r24, Z
    3e36:	91 81       	ldd	r25, Z+1	; 0x01
    3e38:	89 2b       	or	r24, r25
    3e3a:	49 f4       	brne	.+18     	; 0x3e4e <xQueueGenericReceive+0x166>
					{
						taskENTER_CRITICAL();
    3e3c:	0f b6       	in	r0, 0x3f	; 63
    3e3e:	f8 94       	cli
    3e40:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    3e42:	82 81       	ldd	r24, Z+2	; 0x02
    3e44:	93 81       	ldd	r25, Z+3	; 0x03
    3e46:	0e 94 47 2b 	call	0x568e	; 0x568e <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    3e4a:	0f 90       	pop	r0
    3e4c:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3e4e:	6c 81       	ldd	r22, Y+4	; 0x04
    3e50:	7d 81       	ldd	r23, Y+5	; 0x05
    3e52:	c7 01       	movw	r24, r14
    3e54:	0e 94 55 2a 	call	0x54aa	; 0x54aa <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3e58:	0f b6       	in	r0, 0x3f	; 63
    3e5a:	f8 94       	cli
    3e5c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3e5e:	f8 01       	movw	r30, r16
    3e60:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e62:	18 16       	cp	r1, r24
    3e64:	ac f4       	brge	.+42     	; 0x3e90 <xQueueGenericReceive+0x1a8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3e66:	81 89       	ldd	r24, Z+17	; 0x11
    3e68:	81 11       	cpse	r24, r1
    3e6a:	05 c0       	rjmp	.+10     	; 0x3e76 <xQueueGenericReceive+0x18e>
    3e6c:	11 c0       	rjmp	.+34     	; 0x3e90 <xQueueGenericReceive+0x1a8>
    3e6e:	f8 01       	movw	r30, r16
    3e70:	81 89       	ldd	r24, Z+17	; 0x11
    3e72:	88 23       	and	r24, r24
    3e74:	69 f0       	breq	.+26     	; 0x3e90 <xQueueGenericReceive+0x1a8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3e76:	c7 01       	movw	r24, r14
    3e78:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3e7c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3e7e:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3e82:	f8 01       	movw	r30, r16
    3e84:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e86:	81 50       	subi	r24, 0x01	; 1
    3e88:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3e8a:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e8c:	18 16       	cp	r1, r24
    3e8e:	7c f3       	brlt	.-34     	; 0x3e6e <xQueueGenericReceive+0x186>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3e90:	f8 01       	movw	r30, r16
    3e92:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    3e94:	0f 90       	pop	r0
    3e96:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3e98:	0f b6       	in	r0, 0x3f	; 63
    3e9a:	f8 94       	cli
    3e9c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3e9e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ea0:	18 16       	cp	r1, r24
    3ea2:	ac f4       	brge	.+42     	; 0x3ece <xQueueGenericReceive+0x1e6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3ea4:	80 85       	ldd	r24, Z+8	; 0x08
    3ea6:	81 11       	cpse	r24, r1
    3ea8:	05 c0       	rjmp	.+10     	; 0x3eb4 <xQueueGenericReceive+0x1cc>
    3eaa:	11 c0       	rjmp	.+34     	; 0x3ece <xQueueGenericReceive+0x1e6>
    3eac:	f8 01       	movw	r30, r16
    3eae:	80 85       	ldd	r24, Z+8	; 0x08
    3eb0:	88 23       	and	r24, r24
    3eb2:	69 f0       	breq	.+26     	; 0x3ece <xQueueGenericReceive+0x1e6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3eb4:	c6 01       	movw	r24, r12
    3eb6:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3eba:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    3ebc:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3ec0:	f8 01       	movw	r30, r16
    3ec2:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ec4:	81 50       	subi	r24, 0x01	; 1
    3ec6:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3ec8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3eca:	18 16       	cp	r1, r24
    3ecc:	7c f3       	brlt	.-34     	; 0x3eac <xQueueGenericReceive+0x1c4>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3ece:	f8 01       	movw	r30, r16
    3ed0:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    3ed2:	0f 90       	pop	r0
    3ed4:	0f be       	out	0x3f, r0	; 63
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    3ed6:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    3eda:	81 11       	cpse	r24, r1
				{
					portYIELD_WITHIN_API();
    3edc:	2a cf       	rjmp	.-428    	; 0x3d32 <xQueueGenericReceive+0x4a>
    3ede:	e9 d8       	rcall	.-3630   	; 0x30b2 <vPortYield>
    3ee0:	28 cf       	rjmp	.-432    	; 0x3d32 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3ee2:	0f b6       	in	r0, 0x3f	; 63
    3ee4:	f8 94       	cli
    3ee6:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3ee8:	f8 01       	movw	r30, r16
    3eea:	86 8d       	ldd	r24, Z+30	; 0x1e
    3eec:	18 16       	cp	r1, r24
    3eee:	ac f4       	brge	.+42     	; 0x3f1a <xQueueGenericReceive+0x232>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3ef0:	81 89       	ldd	r24, Z+17	; 0x11
    3ef2:	81 11       	cpse	r24, r1
    3ef4:	05 c0       	rjmp	.+10     	; 0x3f00 <xQueueGenericReceive+0x218>
    3ef6:	11 c0       	rjmp	.+34     	; 0x3f1a <xQueueGenericReceive+0x232>
    3ef8:	f8 01       	movw	r30, r16
    3efa:	81 89       	ldd	r24, Z+17	; 0x11
    3efc:	88 23       	and	r24, r24
    3efe:	69 f0       	breq	.+26     	; 0x3f1a <xQueueGenericReceive+0x232>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f00:	c7 01       	movw	r24, r14
    3f02:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3f06:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3f08:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3f0c:	f8 01       	movw	r30, r16
    3f0e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f10:	81 50       	subi	r24, 0x01	; 1
    3f12:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3f14:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f16:	18 16       	cp	r1, r24
    3f18:	7c f3       	brlt	.-34     	; 0x3ef8 <xQueueGenericReceive+0x210>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3f1a:	f8 01       	movw	r30, r16
    3f1c:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    3f1e:	0f 90       	pop	r0
    3f20:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3f22:	0f b6       	in	r0, 0x3f	; 63
    3f24:	f8 94       	cli
    3f26:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3f28:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f2a:	18 16       	cp	r1, r24
    3f2c:	ac f4       	brge	.+42     	; 0x3f58 <xQueueGenericReceive+0x270>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3f2e:	80 85       	ldd	r24, Z+8	; 0x08
    3f30:	81 11       	cpse	r24, r1
    3f32:	05 c0       	rjmp	.+10     	; 0x3f3e <xQueueGenericReceive+0x256>
    3f34:	11 c0       	rjmp	.+34     	; 0x3f58 <xQueueGenericReceive+0x270>
    3f36:	f8 01       	movw	r30, r16
    3f38:	80 85       	ldd	r24, Z+8	; 0x08
    3f3a:	88 23       	and	r24, r24
    3f3c:	69 f0       	breq	.+26     	; 0x3f58 <xQueueGenericReceive+0x270>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3f3e:	c6 01       	movw	r24, r12
    3f40:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3f44:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    3f46:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3f4a:	f8 01       	movw	r30, r16
    3f4c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f4e:	81 50       	subi	r24, 0x01	; 1
    3f50:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3f52:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f54:	18 16       	cp	r1, r24
    3f56:	7c f3       	brlt	.-34     	; 0x3f36 <xQueueGenericReceive+0x24e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3f58:	f8 01       	movw	r30, r16
    3f5a:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    3f5c:	0f 90       	pop	r0
    3f5e:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    3f60:	0e 94 c7 27 	call	0x4f8e	; 0x4f8e <xTaskResumeAll>
    3f64:	e6 ce       	rjmp	.-564    	; 0x3d32 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3f66:	0f b6       	in	r0, 0x3f	; 63
    3f68:	f8 94       	cli
    3f6a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3f6c:	f8 01       	movw	r30, r16
    3f6e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f70:	18 16       	cp	r1, r24
    3f72:	d4 f4       	brge	.+52     	; 0x3fa8 <xQueueGenericReceive+0x2c0>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3f74:	81 89       	ldd	r24, Z+17	; 0x11
    3f76:	81 11       	cpse	r24, r1
    3f78:	06 c0       	rjmp	.+12     	; 0x3f86 <xQueueGenericReceive+0x29e>
    3f7a:	16 c0       	rjmp	.+44     	; 0x3fa8 <xQueueGenericReceive+0x2c0>
    3f7c:	f8 01       	movw	r30, r16
    3f7e:	81 89       	ldd	r24, Z+17	; 0x11
    3f80:	81 11       	cpse	r24, r1
    3f82:	05 c0       	rjmp	.+10     	; 0x3f8e <xQueueGenericReceive+0x2a6>
    3f84:	11 c0       	rjmp	.+34     	; 0x3fa8 <xQueueGenericReceive+0x2c0>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f86:	78 01       	movw	r14, r16
    3f88:	f1 e1       	ldi	r31, 0x11	; 17
    3f8a:	ef 0e       	add	r14, r31
    3f8c:	f1 1c       	adc	r15, r1
    3f8e:	c7 01       	movw	r24, r14
    3f90:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3f94:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3f96:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3f9a:	f8 01       	movw	r30, r16
    3f9c:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f9e:	81 50       	subi	r24, 0x01	; 1
    3fa0:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3fa2:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fa4:	18 16       	cp	r1, r24
    3fa6:	54 f3       	brlt	.-44     	; 0x3f7c <xQueueGenericReceive+0x294>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3fa8:	8f ef       	ldi	r24, 0xFF	; 255
    3faa:	f8 01       	movw	r30, r16
    3fac:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3fae:	0f 90       	pop	r0
    3fb0:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3fb2:	0f b6       	in	r0, 0x3f	; 63
    3fb4:	f8 94       	cli
    3fb6:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3fb8:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fba:	18 16       	cp	r1, r24
    3fbc:	d4 f4       	brge	.+52     	; 0x3ff2 <xQueueGenericReceive+0x30a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3fbe:	80 85       	ldd	r24, Z+8	; 0x08
    3fc0:	81 11       	cpse	r24, r1
    3fc2:	06 c0       	rjmp	.+12     	; 0x3fd0 <xQueueGenericReceive+0x2e8>
    3fc4:	16 c0       	rjmp	.+44     	; 0x3ff2 <xQueueGenericReceive+0x30a>
    3fc6:	f8 01       	movw	r30, r16
    3fc8:	80 85       	ldd	r24, Z+8	; 0x08
    3fca:	81 11       	cpse	r24, r1
    3fcc:	05 c0       	rjmp	.+10     	; 0x3fd8 <xQueueGenericReceive+0x2f0>
    3fce:	11 c0       	rjmp	.+34     	; 0x3ff2 <xQueueGenericReceive+0x30a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3fd0:	78 01       	movw	r14, r16
    3fd2:	f8 e0       	ldi	r31, 0x08	; 8
    3fd4:	ef 0e       	add	r14, r31
    3fd6:	f1 1c       	adc	r15, r1
    3fd8:	c7 01       	movw	r24, r14
    3fda:	0e 94 b0 2a 	call	0x5560	; 0x5560 <xTaskRemoveFromEventList>
    3fde:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    3fe0:	0e 94 3e 2b 	call	0x567c	; 0x567c <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3fe4:	f8 01       	movw	r30, r16
    3fe6:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fe8:	81 50       	subi	r24, 0x01	; 1
    3fea:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3fec:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fee:	18 16       	cp	r1, r24
    3ff0:	54 f3       	brlt	.-44     	; 0x3fc6 <xQueueGenericReceive+0x2de>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3ff2:	8f ef       	ldi	r24, 0xFF	; 255
    3ff4:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    3ff6:	85 8f       	std	Z+29, r24	; 0x1d
    3ff8:	0f 90       	pop	r0
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    3ffa:	0f be       	out	0x3f, r0	; 63
    3ffc:	c8 d7       	rcall	.+3984   	; 0x4f8e <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    3ffe:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    4000:	0f 90       	pop	r0
    4002:	0f 90       	pop	r0
    4004:	0f 90       	pop	r0
    4006:	0f 90       	pop	r0
    4008:	0f 90       	pop	r0
    400a:	df 91       	pop	r29
    400c:	cf 91       	pop	r28
    400e:	1f 91       	pop	r17
    4010:	0f 91       	pop	r16
    4012:	ff 90       	pop	r15
    4014:	ef 90       	pop	r14
    4016:	df 90       	pop	r13
    4018:	cf 90       	pop	r12
    401a:	bf 90       	pop	r11
    401c:	af 90       	pop	r10
    401e:	9f 90       	pop	r9
    4020:	8f 90       	pop	r8
    4022:	7f 90       	pop	r7
    4024:	6f 90       	pop	r6
    4026:	08 95       	ret

00004028 <server_receiver>:
  uint8_t status = TYPE_PING_RESPONSE;
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
  else simple_p_send(SERVER_ADDRESS, &status, 1);
}

void server_receiver(uint8_t *data, uint16_t len) {
    4028:	ab 01       	movw	r20, r22
  if(data == NULL) { // ARQ passes NULL to the callback when connection is lost
    402a:	00 97       	sbiw	r24, 0x00	; 0
    402c:	11 f4       	brne	.+4      	; 0x4032 <server_receiver+0xa>
      gHandshook = 0;
    402e:	10 92 c2 19 	sts	0x19C2, r1	; 0x8019c2 <gHandshook>
  }
  memcpy(&message_in, data, len);
    4032:	bc 01       	movw	r22, r24
    4034:	87 e3       	ldi	r24, 0x37	; 55
    4036:	9b e1       	ldi	r25, 0x1B	; 27
    4038:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
  xSemaphoreGive(xCommandReadyBSem);
    403c:	60 e0       	ldi	r22, 0x00	; 0
    403e:	70 e0       	ldi	r23, 0x00	; 0
    4040:	80 91 33 1b 	lds	r24, 0x1B33	; 0x801b33 <xCommandReadyBSem>
    4044:	90 91 34 1b 	lds	r25, 0x1B34	; 0x801b34 <xCommandReadyBSem+0x1>
    4048:	b3 cc       	rjmp	.-1690   	; 0x39b0 <xQueueGive>
    404a:	08 95       	ret

0000404c <server_communication_init>:
#define TYPE_PING           8
#define TYPE_PING_RESPONSE  9
#define TYPE_DEBUG          10

void server_communication_init(void) {
  if(connected) return;
    404c:	80 91 cf 19 	lds	r24, 0x19CF	; 0x8019cf <connected>
    4050:	81 11       	cpse	r24, r1
    4052:	04 c0       	rjmp	.+8      	; 0x405c <server_communication_init+0x10>
  server_connection = arq_new_connection();
    4054:	0e 94 60 01 	call	0x2c0	; 0x2c0 <arq_new_connection>
    4058:	80 93 6d 1b 	sts	0x1B6D, r24	; 0x801b6d <server_connection>
    405c:	08 95       	ret

0000405e <server_connect>:
}

uint8_t server_connect(void) {
  connected = arq_connect(server_connection, SERVER_ADDRESS, server_receiver, 1000);
    405e:	28 ee       	ldi	r18, 0xE8	; 232
    4060:	33 e0       	ldi	r19, 0x03	; 3
    4062:	44 e1       	ldi	r20, 0x14	; 20
    4064:	50 e2       	ldi	r21, 0x20	; 32
    4066:	60 e0       	ldi	r22, 0x00	; 0
    4068:	80 91 6d 1b 	lds	r24, 0x1B6D	; 0x801b6d <server_connection>
    406c:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <arq_connect>
    4070:	80 93 cf 19 	sts	0x19CF, r24	; 0x8019cf <connected>
  return connected;
}
    4074:	08 95       	ret

00004076 <send_handshake>:

uint8_t send_handshake(void) {
    4076:	cf 93       	push	r28
    4078:	df 93       	push	r29
    407a:	cd b7       	in	r28, 0x3d	; 61
    407c:	de b7       	in	r29, 0x3e	; 62
    407e:	ec 97       	sbiw	r28, 0x3c	; 60
    4080:	0f b6       	in	r0, 0x3f	; 63
    4082:	f8 94       	cli
    4084:	de bf       	out	0x3e, r29	; 62
    4086:	0f be       	out	0x3f, r0	; 63
    4088:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return 0;
    408a:	80 91 cf 19 	lds	r24, 0x19CF	; 0x8019cf <connected>
    408e:	88 23       	and	r24, r24
    4090:	09 f4       	brne	.+2      	; 0x4094 <send_handshake+0x1e>
    4092:	4e c0       	rjmp	.+156    	; 0x4130 <send_handshake+0xba>
  message_t msg;
  msg.type = TYPE_HANDSHAKE;
    4094:	19 82       	std	Y+1, r1	; 0x01
  msg.message.handshake.name_length = ROBOT_NAME_LENGTH;
    4096:	87 e0       	ldi	r24, 0x07	; 7
    4098:	8a 83       	std	Y+2, r24	; 0x02
  strcpy((char*)msg.message.handshake.name, ROBOT_NAME);
    409a:	88 e0       	ldi	r24, 0x08	; 8
    409c:	ed e3       	ldi	r30, 0x3D	; 61
    409e:	f6 e0       	ldi	r31, 0x06	; 6
    40a0:	de 01       	movw	r26, r28
    40a2:	13 96       	adiw	r26, 0x03	; 3
    40a4:	01 90       	ld	r0, Z+
    40a6:	0d 92       	st	X+, r0
    40a8:	8a 95       	dec	r24
    40aa:	e1 f7       	brne	.-8      	; 0x40a4 <send_handshake+0x2e>
  msg.message.handshake.width = ROBOT_TOTAL_WIDTH_MM;
    40ac:	24 eb       	ldi	r18, 0xB4	; 180
    40ae:	30 e0       	ldi	r19, 0x00	; 0
    40b0:	3b 87       	std	Y+11, r19	; 0x0b
    40b2:	2a 87       	std	Y+10, r18	; 0x0a
  msg.message.handshake.length = ROBOT_TOTAL_LENGTH_MM;
    40b4:	85 ef       	ldi	r24, 0xF5	; 245
    40b6:	90 e0       	ldi	r25, 0x00	; 0
    40b8:	9d 87       	std	Y+13, r25	; 0x0d
    40ba:	8c 87       	std	Y+12, r24	; 0x0c
  msg.message.handshake.axel_offset = ROBOT_AXEL_OFFSET_MM;
    40bc:	88 e3       	ldi	r24, 0x38	; 56
    40be:	88 8b       	std	Y+16, r24	; 0x10
  msg.message.handshake.tower_offset_x = SENSOR_TOWER_OFFSET_X_MM;
    40c0:	8e 87       	std	Y+14, r24	; 0x0e
  msg.message.handshake.tower_offset_y = SENSOR_TOWER_OFFSET_Y_MM;
    40c2:	1f 86       	std	Y+15, r1	; 0x0f
  msg.message.handshake.sensor_offset1 = SENSOR_OFFSET_RADIUS_MM;
    40c4:	85 e1       	ldi	r24, 0x15	; 21
    40c6:	89 8b       	std	Y+17, r24	; 0x11
  msg.message.handshake.sensor_offset2 = SENSOR_OFFSET_RADIUS_MM;
    40c8:	8a 8b       	std	Y+18, r24	; 0x12
  msg.message.handshake.sensor_offset3 = SENSOR_OFFSET_RADIUS_MM;
    40ca:	8b 8b       	std	Y+19, r24	; 0x13
  msg.message.handshake.sensor_offset4 = SENSOR_OFFSET_RADIUS_MM;
    40cc:	8c 8b       	std	Y+20, r24	; 0x14
  msg.message.handshake.sensor_heading1 = SENSOR1_HEADING_DEG;
    40ce:	1e 8a       	std	Y+22, r1	; 0x16
    40d0:	1d 8a       	std	Y+21, r1	; 0x15
  msg.message.handshake.sensor_heading2 = SENSOR2_HEADING_DEG;
    40d2:	8a e5       	ldi	r24, 0x5A	; 90
    40d4:	90 e0       	ldi	r25, 0x00	; 0
    40d6:	98 8f       	std	Y+24, r25	; 0x18
    40d8:	8f 8b       	std	Y+23, r24	; 0x17
  msg.message.handshake.sensor_heading3 = SENSOR3_HEADING_DEG;
    40da:	3a 8f       	std	Y+26, r19	; 0x1a
    40dc:	29 8f       	std	Y+25, r18	; 0x19
  msg.message.handshake.sensor_heading4 = SENSOR4_HEADING_DEG;
    40de:	8e e0       	ldi	r24, 0x0E	; 14
    40e0:	91 e0       	ldi	r25, 0x01	; 1
    40e2:	9c 8f       	std	Y+28, r25	; 0x1c
    40e4:	8b 8f       	std	Y+27, r24	; 0x1b
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
    40e6:	88 ec       	ldi	r24, 0xC8	; 200
    40e8:	90 e0       	ldi	r25, 0x00	; 0
    40ea:	9e 8f       	std	Y+30, r25	; 0x1e
    40ec:	8d 8f       	std	Y+29, r24	; 0x1d
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    40ee:	8e e1       	ldi	r24, 0x1E	; 30
    40f0:	fe 01       	movw	r30, r28
    40f2:	31 96       	adiw	r30, 0x01	; 1
    40f4:	de 01       	movw	r26, r28
    40f6:	5f 96       	adiw	r26, 0x1f	; 31
    40f8:	01 90       	ld	r0, Z+
    40fa:	0d 92       	st	X+, r0
    40fc:	8a 95       	dec	r24
    40fe:	e1 f7       	brne	.-8      	; 0x40f8 <send_handshake+0x82>
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
    4100:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <use_arq>
    4104:	88 23       	and	r24, r24
    4106:	59 f0       	breq	.+22     	; 0x411e <send_handshake+0xa8>
    4108:	4e e1       	ldi	r20, 0x1E	; 30
    410a:	50 e0       	ldi	r21, 0x00	; 0
    410c:	be 01       	movw	r22, r28
    410e:	61 5e       	subi	r22, 0xE1	; 225
    4110:	7f 4f       	sbci	r23, 0xFF	; 255
    4112:	80 91 6d 1b 	lds	r24, 0x1B6D	; 0x801b6d <server_connection>
    4116:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
  else simple_p_send(server_connection, data, sizeof(data));
  return 1;
    411a:	81 e0       	ldi	r24, 0x01	; 1
    411c:	09 c0       	rjmp	.+18     	; 0x4130 <send_handshake+0xba>
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
  else simple_p_send(server_connection, data, sizeof(data));
    411e:	4e e1       	ldi	r20, 0x1E	; 30
    4120:	50 e0       	ldi	r21, 0x00	; 0
    4122:	be 01       	movw	r22, r28
    4124:	61 5e       	subi	r22, 0xE1	; 225
    4126:	7f 4f       	sbci	r23, 0xFF	; 255
    4128:	80 91 6d 1b 	lds	r24, 0x1B6D	; 0x801b6d <server_connection>
    412c:	76 d1       	rcall	.+748    	; 0x441a <simple_p_send>
  return 1;
    412e:	81 e0       	ldi	r24, 0x01	; 1
}
    4130:	ec 96       	adiw	r28, 0x3c	; 60
    4132:	0f b6       	in	r0, 0x3f	; 63
    4134:	f8 94       	cli
    4136:	de bf       	out	0x3e, r29	; 62
    4138:	0f be       	out	0x3f, r0	; 63
    413a:	cd bf       	out	0x3d, r28	; 61
    413c:	df 91       	pop	r29
    413e:	cf 91       	pop	r28
    4140:	08 95       	ret

00004142 <send_update>:

void send_update(int16_t x_cm, int16_t y_cm, int16_t heading_deg, int16_t towerAngle_deg, uint8_t S1_cm, uint8_t S2_cm, uint8_t S3_cm, uint8_t S4_cm){
    4142:	af 92       	push	r10
    4144:	cf 92       	push	r12
    4146:	ef 92       	push	r14
    4148:	0f 93       	push	r16
    414a:	cf 93       	push	r28
    414c:	df 93       	push	r29
    414e:	cd b7       	in	r28, 0x3d	; 61
    4150:	de b7       	in	r29, 0x3e	; 62
    4152:	2d 97       	sbiw	r28, 0x0d	; 13
    4154:	0f b6       	in	r0, 0x3f	; 63
    4156:	f8 94       	cli
    4158:	de bf       	out	0x3e, r29	; 62
    415a:	0f be       	out	0x3f, r0	; 63
    415c:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return;
    415e:	e0 91 cf 19 	lds	r30, 0x19CF	; 0x8019cf <connected>
    4162:	ee 23       	and	r30, r30
    4164:	19 f1       	breq	.+70     	; 0x41ac <send_update+0x6a>
  msg.message.update.sensor1 = S1_cm;
  msg.message.update.sensor2 = S2_cm;
  msg.message.update.sensor3 = S3_cm;
  msg.message.update.sensor4 = S4_cm;
  uint8_t data[sizeof(update_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    4166:	e1 e0       	ldi	r30, 0x01	; 1
    4168:	e9 83       	std	Y+1, r30	; 0x01
    416a:	9b 83       	std	Y+3, r25	; 0x03
    416c:	8a 83       	std	Y+2, r24	; 0x02
    416e:	7d 83       	std	Y+5, r23	; 0x05
    4170:	6c 83       	std	Y+4, r22	; 0x04
    4172:	5f 83       	std	Y+7, r21	; 0x07
    4174:	4e 83       	std	Y+6, r20	; 0x06
    4176:	39 87       	std	Y+9, r19	; 0x09
    4178:	28 87       	std	Y+8, r18	; 0x08
    417a:	0a 87       	std	Y+10, r16	; 0x0a
    417c:	eb 86       	std	Y+11, r14	; 0x0b
    417e:	cc 86       	std	Y+12, r12	; 0x0c
    4180:	ad 86       	std	Y+13, r10	; 0x0d
  if(use_arq[TYPE_UPDATE]) arq_send(server_connection, data, sizeof(data));
    4182:	80 91 01 06 	lds	r24, 0x0601	; 0x800601 <use_arq+0x1>
    4186:	88 23       	and	r24, r24
    4188:	51 f0       	breq	.+20     	; 0x419e <send_update+0x5c>
    418a:	4d e0       	ldi	r20, 0x0D	; 13
    418c:	50 e0       	ldi	r21, 0x00	; 0
    418e:	be 01       	movw	r22, r28
    4190:	6f 5f       	subi	r22, 0xFF	; 255
    4192:	7f 4f       	sbci	r23, 0xFF	; 255
    4194:	80 91 6d 1b 	lds	r24, 0x1B6D	; 0x801b6d <server_connection>
    4198:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    419c:	07 c0       	rjmp	.+14     	; 0x41ac <send_update+0x6a>
  else simple_p_send(SERVER_ADDRESS, data, sizeof(data));
    419e:	4d e0       	ldi	r20, 0x0D	; 13
    41a0:	50 e0       	ldi	r21, 0x00	; 0
    41a2:	be 01       	movw	r22, r28
    41a4:	6f 5f       	subi	r22, 0xFF	; 255
    41a6:	7f 4f       	sbci	r23, 0xFF	; 255
    41a8:	80 e0       	ldi	r24, 0x00	; 0
    41aa:	37 d1       	rcall	.+622    	; 0x441a <simple_p_send>
}
    41ac:	2d 96       	adiw	r28, 0x0d	; 13
    41ae:	0f b6       	in	r0, 0x3f	; 63
    41b0:	f8 94       	cli
    41b2:	de bf       	out	0x3e, r29	; 62
    41b4:	0f be       	out	0x3f, r0	; 63
    41b6:	cd bf       	out	0x3d, r28	; 61
    41b8:	df 91       	pop	r29
    41ba:	cf 91       	pop	r28
    41bc:	0f 91       	pop	r16
    41be:	ef 90       	pop	r14
    41c0:	cf 90       	pop	r12
    41c2:	af 90       	pop	r10
    41c4:	08 95       	ret

000041c6 <send_idle>:

void send_idle(void) {
    41c6:	cf 93       	push	r28
    41c8:	df 93       	push	r29
    41ca:	1f 92       	push	r1
    41cc:	cd b7       	in	r28, 0x3d	; 61
    41ce:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    41d0:	80 91 cf 19 	lds	r24, 0x19CF	; 0x8019cf <connected>
    41d4:	88 23       	and	r24, r24
    41d6:	b9 f0       	breq	.+46     	; 0x4206 <send_idle+0x40>
  uint8_t status = TYPE_IDLE;
    41d8:	83 e0       	ldi	r24, 0x03	; 3
    41da:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_IDLE]) arq_send(server_connection, &status, 1);
    41dc:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <use_arq+0x3>
    41e0:	88 23       	and	r24, r24
    41e2:	51 f0       	breq	.+20     	; 0x41f8 <send_idle+0x32>
    41e4:	41 e0       	ldi	r20, 0x01	; 1
    41e6:	50 e0       	ldi	r21, 0x00	; 0
    41e8:	be 01       	movw	r22, r28
    41ea:	6f 5f       	subi	r22, 0xFF	; 255
    41ec:	7f 4f       	sbci	r23, 0xFF	; 255
    41ee:	80 91 6d 1b 	lds	r24, 0x1B6D	; 0x801b6d <server_connection>
    41f2:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    41f6:	07 c0       	rjmp	.+14     	; 0x4206 <send_idle+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    41f8:	41 e0       	ldi	r20, 0x01	; 1
    41fa:	50 e0       	ldi	r21, 0x00	; 0
    41fc:	be 01       	movw	r22, r28
    41fe:	6f 5f       	subi	r22, 0xFF	; 255
    4200:	7f 4f       	sbci	r23, 0xFF	; 255
    4202:	80 e0       	ldi	r24, 0x00	; 0
    4204:	0a d1       	rcall	.+532    	; 0x441a <simple_p_send>
}
    4206:	0f 90       	pop	r0
    4208:	df 91       	pop	r29
    420a:	cf 91       	pop	r28
    420c:	08 95       	ret

0000420e <debug>:
void debug(const char *fmt, ...) {
    420e:	cf 93       	push	r28
    4210:	df 93       	push	r29
    4212:	cd b7       	in	r28, 0x3d	; 61
    4214:	de b7       	in	r29, 0x3e	; 62
    4216:	c4 56       	subi	r28, 0x64	; 100
    4218:	d1 09       	sbc	r29, r1
    421a:	0f b6       	in	r0, 0x3f	; 63
    421c:	f8 94       	cli
    421e:	de bf       	out	0x3e, r29	; 62
    4220:	0f be       	out	0x3f, r0	; 63
    4222:	cd bf       	out	0x3d, r28	; 61
    4224:	ae 01       	movw	r20, r28
    4226:	46 59       	subi	r20, 0x96	; 150
    4228:	5f 4f       	sbci	r21, 0xFF	; 255
    422a:	fa 01       	movw	r30, r20
    422c:	61 91       	ld	r22, Z+
    422e:	71 91       	ld	r23, Z+
    4230:	af 01       	movw	r20, r30
	uint8_t buf[100];
	va_list ap;
	buf[0] = TYPE_DEBUG;
    4232:	8a e0       	ldi	r24, 0x0A	; 10
    4234:	89 83       	std	Y+1, r24	; 0x01
	va_start(ap, fmt);
	uint8_t ret = vsprintf((char*)buf+1, fmt, ap);
    4236:	ce 01       	movw	r24, r28
    4238:	02 96       	adiw	r24, 0x02	; 2
    423a:	0e 94 7b 38 	call	0x70f6	; 0x70f6 <vsprintf>
	va_end(ap);
	if (ret > 0) {
    423e:	88 23       	and	r24, r24
    4240:	c9 f0       	breq	.+50     	; 0x4274 <debug+0x66>
		if(use_arq[TYPE_DEBUG]) arq_send(server_connection, buf, ret+1);
    4242:	20 91 0a 06 	lds	r18, 0x060A	; 0x80060a <use_arq+0xa>
    4246:	22 23       	and	r18, r18
    4248:	61 f0       	breq	.+24     	; 0x4262 <debug+0x54>
    424a:	99 27       	eor	r25, r25
    424c:	ac 01       	movw	r20, r24
    424e:	4f 5f       	subi	r20, 0xFF	; 255
    4250:	5f 4f       	sbci	r21, 0xFF	; 255
    4252:	be 01       	movw	r22, r28
    4254:	6f 5f       	subi	r22, 0xFF	; 255
    4256:	7f 4f       	sbci	r23, 0xFF	; 255
    4258:	80 91 6d 1b 	lds	r24, 0x1B6D	; 0x801b6d <server_connection>
    425c:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4260:	09 c0       	rjmp	.+18     	; 0x4274 <debug+0x66>
		else simple_p_send(SERVER_ADDRESS, buf, ret+1);
    4262:	99 27       	eor	r25, r25
    4264:	ac 01       	movw	r20, r24
    4266:	4f 5f       	subi	r20, 0xFF	; 255
    4268:	5f 4f       	sbci	r21, 0xFF	; 255
    426a:	be 01       	movw	r22, r28
    426c:	6f 5f       	subi	r22, 0xFF	; 255
    426e:	7f 4f       	sbci	r23, 0xFF	; 255
    4270:	80 e0       	ldi	r24, 0x00	; 0
    4272:	d3 d0       	rcall	.+422    	; 0x441a <simple_p_send>
	}
}
    4274:	cc 59       	subi	r28, 0x9C	; 156
    4276:	df 4f       	sbci	r29, 0xFF	; 255
    4278:	0f b6       	in	r0, 0x3f	; 63
    427a:	f8 94       	cli
    427c:	de bf       	out	0x3e, r29	; 62
    427e:	0f be       	out	0x3f, r0	; 63
    4280:	cd bf       	out	0x3d, r28	; 61
    4282:	df 91       	pop	r29
    4284:	cf 91       	pop	r28
    4286:	08 95       	ret

00004288 <send_ping_response>:

void send_ping_response(void) {
    4288:	cf 93       	push	r28
    428a:	df 93       	push	r29
    428c:	1f 92       	push	r1
    428e:	cd b7       	in	r28, 0x3d	; 61
    4290:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    4292:	80 91 cf 19 	lds	r24, 0x19CF	; 0x8019cf <connected>
    4296:	88 23       	and	r24, r24
    4298:	b9 f0       	breq	.+46     	; 0x42c8 <send_ping_response+0x40>
  uint8_t status = TYPE_PING_RESPONSE;
    429a:	89 e0       	ldi	r24, 0x09	; 9
    429c:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
    429e:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <use_arq+0x9>
    42a2:	88 23       	and	r24, r24
    42a4:	51 f0       	breq	.+20     	; 0x42ba <send_ping_response+0x32>
    42a6:	41 e0       	ldi	r20, 0x01	; 1
    42a8:	50 e0       	ldi	r21, 0x00	; 0
    42aa:	be 01       	movw	r22, r28
    42ac:	6f 5f       	subi	r22, 0xFF	; 255
    42ae:	7f 4f       	sbci	r23, 0xFF	; 255
    42b0:	80 91 6d 1b 	lds	r24, 0x1B6D	; 0x801b6d <server_connection>
    42b4:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    42b8:	07 c0       	rjmp	.+14     	; 0x42c8 <send_ping_response+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    42ba:	41 e0       	ldi	r20, 0x01	; 1
    42bc:	50 e0       	ldi	r21, 0x00	; 0
    42be:	be 01       	movw	r22, r28
    42c0:	6f 5f       	subi	r22, 0xFF	; 255
    42c2:	7f 4f       	sbci	r23, 0xFF	; 255
    42c4:	80 e0       	ldi	r24, 0x00	; 0
    42c6:	a9 d0       	rcall	.+338    	; 0x441a <simple_p_send>
}
    42c8:	0f 90       	pop	r0
    42ca:	df 91       	pop	r29
    42cc:	cf 91       	pop	r28
    42ce:	08 95       	ret

000042d0 <vServo_setAngle>:
}

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
    /* Ensure feasible values */
    if (ServoAngleDeg >= 90){
    42d0:	8a 35       	cpi	r24, 0x5A	; 90
    42d2:	08 f0       	brcs	.+2      	; 0x42d6 <vServo_setAngle+0x6>
        ServoAngleDeg = 90;
    42d4:	8a e5       	ldi	r24, 0x5A	; 90
    }
    else if(ServoAngleDeg <= 0){
        ServoAngleDeg = 0;
    }
    /* Fetch pulse width from array and set to output */
    servoOCR = DEG_TO_PWM[ServoAngleDeg];
    42d6:	e8 2f       	mov	r30, r24
    42d8:	f0 e0       	ldi	r31, 0x00	; 0
    42da:	ee 0f       	add	r30, r30
    42dc:	ff 1f       	adc	r31, r31
    42de:	eb 5b       	subi	r30, 0xBB	; 187
    42e0:	f9 4f       	sbci	r31, 0xF9	; 249
    42e2:	80 81       	ld	r24, Z
    42e4:	91 81       	ldd	r25, Z+1	; 0x01
    42e6:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    42ea:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    42ee:	08 95       	ret

000042f0 <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
    /* Clear OCnA/OCnB on Compare Match, set */
    /* OCnA/OCnB at BOTTOM (non-inverting mode) */
    /* Datasheet p.155 Table 17-4 */
    TCCR4A |= (1<<COM4B1) | (0<<COM4B0);
    42f0:	a0 ea       	ldi	r26, 0xA0	; 160
    42f2:	b0 e0       	ldi	r27, 0x00	; 0
    42f4:	9c 91       	ld	r25, X
    42f6:	90 62       	ori	r25, 0x20	; 32
    42f8:	9c 93       	st	X, r25
    
    /* Waveform generation mode 14: Fast PWM */
    /* top: ICRn, Update bottom, flag set on top */
    /* Datasheet p.145 Table 17-2 */
	
    TCCR4B |= (1<<WGM43) | (1<<WGM42);                                             
    42fa:	e1 ea       	ldi	r30, 0xA1	; 161
    42fc:	f0 e0       	ldi	r31, 0x00	; 0
    42fe:	90 81       	ld	r25, Z
    4300:	98 61       	ori	r25, 0x18	; 24
    4302:	90 83       	st	Z, r25
    TCCR4A |= (1<<WGM41) | (0<<WGM40);
    4304:	9c 91       	ld	r25, X
    4306:	92 60       	ori	r25, 0x02	; 2
    4308:	9c 93       	st	X, r25

    /* Clock select bit description: */
    /* clkI/O/8 (From prescaler) - Datasheet p.157 Table 17-6*/

     TCCR4B |= (0<<CS42) | (1<<CS41) | (0<<CS40);                                           
    430a:	90 81       	ld	r25, Z
    430c:	92 60       	ori	r25, 0x02	; 2
    430e:	90 83       	st	Z, r25
    
    /* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
    /* Datasheet p.125 */
    ICR4 = 39999; // 49999 for 20mhz, 39 999 for 16Mhz                                      
    4310:	2f e3       	ldi	r18, 0x3F	; 63
    4312:	3c e9       	ldi	r19, 0x9C	; 156
    4314:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>
    4318:	20 93 a6 00 	sts	0x00A6, r18	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
    
    /*Port H Pin 7 as servo PWM Output (OC4B)*/
    servoReg |= (1<<servoPin);
    431c:	e1 e0       	ldi	r30, 0x01	; 1
    431e:	f1 e0       	ldi	r31, 0x01	; 1
    4320:	90 81       	ld	r25, Z
    4322:	90 61       	ori	r25, 0x10	; 16
    4324:	90 83       	st	Z, r25
    
    /*  Set angle to desired start angle (usually 0)*/
    vServo_setAngle(servoAngleDeg);
    4326:	d4 cf       	rjmp	.-88     	; 0x42d0 <vServo_setAngle>
    4328:	08 95       	ret

0000432a <simple_p_reassembly>:
    432a:	ef 92       	push	r14
    432c:	ff 92       	push	r15
    432e:	0f 93       	push	r16
    4330:	1f 93       	push	r17
    4332:	cf 93       	push	r28
    4334:	df 93       	push	r29
    4336:	90 91 d1 19 	lds	r25, 0x19D1	; 0x8019d1 <messages+0x1>
    433a:	9f 3f       	cpi	r25, 0xFF	; 255
    433c:	11 f0       	breq	.+4      	; 0x4342 <simple_p_reassembly+0x18>
    433e:	98 13       	cpse	r25, r24
    4340:	58 c0       	rjmp	.+176    	; 0x43f2 <simple_p_reassembly+0xc8>
    4342:	fb 01       	movw	r30, r22
    4344:	80 81       	ld	r24, Z
    4346:	81 11       	cpse	r24, r1
    4348:	05 c0       	rjmp	.+10     	; 0x4354 <simple_p_reassembly+0x2a>
    434a:	10 92 d3 19 	sts	0x19D3, r1	; 0x8019d3 <messages+0x3>
    434e:	10 92 d2 19 	sts	0x19D2, r1	; 0x8019d2 <messages+0x2>
    4352:	0c c0       	rjmp	.+24     	; 0x436c <simple_p_reassembly+0x42>
    4354:	90 91 d4 19 	lds	r25, 0x19D4	; 0x8019d4 <messages+0x4>
    4358:	89 17       	cp	r24, r25
    435a:	41 f0       	breq	.+16     	; 0x436c <simple_p_reassembly+0x42>
    435c:	e0 ed       	ldi	r30, 0xD0	; 208
    435e:	f9 e1       	ldi	r31, 0x19	; 25
    4360:	14 82       	std	Z+4, r1	; 0x04
    4362:	13 82       	std	Z+3, r1	; 0x03
    4364:	12 82       	std	Z+2, r1	; 0x02
    4366:	8f ef       	ldi	r24, 0xFF	; 255
    4368:	81 83       	std	Z+1, r24	; 0x01
    436a:	43 c0       	rjmp	.+134    	; 0x43f2 <simple_p_reassembly+0xc8>
    436c:	80 91 d2 19 	lds	r24, 0x19D2	; 0x8019d2 <messages+0x2>
    4370:	90 91 d3 19 	lds	r25, 0x19D3	; 0x8019d3 <messages+0x3>
    4374:	02 97       	sbiw	r24, 0x02	; 2
    4376:	84 0f       	add	r24, r20
    4378:	95 1f       	adc	r25, r21
    437a:	85 36       	cpi	r24, 0x65	; 101
    437c:	91 05       	cpc	r25, r1
    437e:	40 f0       	brcs	.+16     	; 0x4390 <simple_p_reassembly+0x66>
    4380:	e0 ed       	ldi	r30, 0xD0	; 208
    4382:	f9 e1       	ldi	r31, 0x19	; 25
    4384:	13 82       	std	Z+3, r1	; 0x03
    4386:	12 82       	std	Z+2, r1	; 0x02
    4388:	14 82       	std	Z+4, r1	; 0x04
    438a:	8f ef       	ldi	r24, 0xFF	; 255
    438c:	81 83       	std	Z+1, r24	; 0x01
    438e:	31 c0       	rjmp	.+98     	; 0x43f2 <simple_p_reassembly+0xc8>
    4390:	8a 01       	movw	r16, r20
    4392:	eb 01       	movw	r28, r22
    4394:	0f 2e       	mov	r0, r31
    4396:	f0 ed       	ldi	r31, 0xD0	; 208
    4398:	ef 2e       	mov	r14, r31
    439a:	f9 e1       	ldi	r31, 0x19	; 25
    439c:	ff 2e       	mov	r15, r31
    439e:	f0 2d       	mov	r31, r0
    43a0:	f7 01       	movw	r30, r14
    43a2:	84 81       	ldd	r24, Z+4	; 0x04
    43a4:	8f 5f       	subi	r24, 0xFF	; 255
    43a6:	84 83       	std	Z+4, r24	; 0x04
    43a8:	82 81       	ldd	r24, Z+2	; 0x02
    43aa:	93 81       	ldd	r25, Z+3	; 0x03
    43ac:	42 50       	subi	r20, 0x02	; 2
    43ae:	51 09       	sbc	r21, r1
    43b0:	6e 5f       	subi	r22, 0xFE	; 254
    43b2:	7f 4f       	sbci	r23, 0xFF	; 255
    43b4:	8b 52       	subi	r24, 0x2B	; 43
    43b6:	96 4e       	sbci	r25, 0xE6	; 230
    43b8:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    43bc:	f7 01       	movw	r30, r14
    43be:	42 81       	ldd	r20, Z+2	; 0x02
    43c0:	53 81       	ldd	r21, Z+3	; 0x03
    43c2:	42 50       	subi	r20, 0x02	; 2
    43c4:	51 09       	sbc	r21, r1
    43c6:	ba 01       	movw	r22, r20
    43c8:	60 0f       	add	r22, r16
    43ca:	71 1f       	adc	r23, r17
    43cc:	73 83       	std	Z+3, r23	; 0x03
    43ce:	62 83       	std	Z+2, r22	; 0x02
    43d0:	98 81       	ld	r25, Y
    43d2:	89 81       	ldd	r24, Y+1	; 0x01
    43d4:	98 13       	cpse	r25, r24
    43d6:	0d c0       	rjmp	.+26     	; 0x43f2 <simple_p_reassembly+0xc8>
    43d8:	e0 91 6e 1b 	lds	r30, 0x1B6E	; 0x801b6e <callback_data_received>
    43dc:	f0 91 6f 1b 	lds	r31, 0x1B6F	; 0x801b6f <callback_data_received+0x1>
    43e0:	85 ed       	ldi	r24, 0xD5	; 213
    43e2:	99 e1       	ldi	r25, 0x19	; 25
    43e4:	19 95       	eicall
    43e6:	f7 01       	movw	r30, r14
    43e8:	14 82       	std	Z+4, r1	; 0x04
    43ea:	13 82       	std	Z+3, r1	; 0x03
    43ec:	12 82       	std	Z+2, r1	; 0x02
    43ee:	8f ef       	ldi	r24, 0xFF	; 255
    43f0:	81 83       	std	Z+1, r24	; 0x01
    43f2:	df 91       	pop	r29
    43f4:	cf 91       	pop	r28
    43f6:	1f 91       	pop	r17
    43f8:	0f 91       	pop	r16
    43fa:	ff 90       	pop	r15
    43fc:	ef 90       	pop	r14
    43fe:	08 95       	ret

00004400 <simple_p_init>:
    4400:	90 93 6f 1b 	sts	0x1B6F, r25	; 0x801b6f <callback_data_received+0x1>
    4404:	80 93 6e 1b 	sts	0x1B6E, r24	; 0x801b6e <callback_data_received>
    4408:	65 e9       	ldi	r22, 0x95	; 149
    440a:	71 e2       	ldi	r23, 0x21	; 33
    440c:	80 e0       	ldi	r24, 0x00	; 0
    440e:	0e 94 22 17 	call	0x2e44	; 0x2e44 <network_set_callback>
    4412:	8f ef       	ldi	r24, 0xFF	; 255
    4414:	80 93 d1 19 	sts	0x19D1, r24	; 0x8019d1 <messages+0x1>
    4418:	08 95       	ret

0000441a <simple_p_send>:
    441a:	5f 92       	push	r5
    441c:	6f 92       	push	r6
    441e:	7f 92       	push	r7
    4420:	8f 92       	push	r8
    4422:	9f 92       	push	r9
    4424:	af 92       	push	r10
    4426:	bf 92       	push	r11
    4428:	cf 92       	push	r12
    442a:	df 92       	push	r13
    442c:	ef 92       	push	r14
    442e:	ff 92       	push	r15
    4430:	0f 93       	push	r16
    4432:	1f 93       	push	r17
    4434:	cf 93       	push	r28
    4436:	df 93       	push	r29
    4438:	58 2e       	mov	r5, r24
    443a:	5b 01       	movw	r10, r22
    443c:	8a 01       	movw	r16, r20
    443e:	8c e2       	ldi	r24, 0x2C	; 44
    4440:	90 e0       	ldi	r25, 0x00	; 0
    4442:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    4446:	7c 01       	movw	r14, r24
    4448:	98 01       	movw	r18, r16
    444a:	36 95       	lsr	r19
    444c:	27 95       	ror	r18
    444e:	ad e0       	ldi	r26, 0x0D	; 13
    4450:	b3 ec       	ldi	r27, 0xC3	; 195
    4452:	0e 94 25 37 	call	0x6e4a	; 0x6e4a <__umulhisi3>
    4456:	92 95       	swap	r25
    4458:	82 95       	swap	r24
    445a:	8f 70       	andi	r24, 0x0F	; 15
    445c:	89 27       	eor	r24, r25
    445e:	9f 70       	andi	r25, 0x0F	; 15
    4460:	89 27       	eor	r24, r25
    4462:	4a e2       	ldi	r20, 0x2A	; 42
    4464:	48 9f       	mul	r20, r24
    4466:	90 01       	movw	r18, r0
    4468:	49 9f       	mul	r20, r25
    446a:	30 0d       	add	r19, r0
    446c:	11 24       	eor	r1, r1
    446e:	41 e0       	ldi	r20, 0x01	; 1
    4470:	02 17       	cp	r16, r18
    4472:	13 07       	cpc	r17, r19
    4474:	09 f4       	brne	.+2      	; 0x4478 <simple_p_send+0x5e>
    4476:	40 e0       	ldi	r20, 0x00	; 0
    4478:	98 01       	movw	r18, r16
    447a:	36 95       	lsr	r19
    447c:	27 95       	ror	r18
    447e:	ad e0       	ldi	r26, 0x0D	; 13
    4480:	b3 ec       	ldi	r27, 0xC3	; 195
    4482:	0e 94 25 37 	call	0x6e4a	; 0x6e4a <__umulhisi3>
    4486:	92 95       	swap	r25
    4488:	82 95       	swap	r24
    448a:	8f 70       	andi	r24, 0x0F	; 15
    448c:	89 27       	eor	r24, r25
    448e:	9f 70       	andi	r25, 0x0F	; 15
    4490:	89 27       	eor	r24, r25
    4492:	84 0f       	add	r24, r20
    4494:	01 15       	cp	r16, r1
    4496:	11 05       	cpc	r17, r1
    4498:	59 f1       	breq	.+86     	; 0x44f0 <simple_p_send+0xd6>
    449a:	90 e0       	ldi	r25, 0x00	; 0
    449c:	c1 2c       	mov	r12, r1
    449e:	d1 2c       	mov	r13, r1
    44a0:	66 24       	eor	r6, r6
    44a2:	6a 94       	dec	r6
    44a4:	68 0e       	add	r6, r24
    44a6:	47 01       	movw	r8, r14
    44a8:	82 e0       	ldi	r24, 0x02	; 2
    44aa:	88 0e       	add	r8, r24
    44ac:	91 1c       	adc	r9, r1
    44ae:	e8 01       	movw	r28, r16
    44b0:	0b 32       	cpi	r16, 0x2B	; 43
    44b2:	11 05       	cpc	r17, r1
    44b4:	10 f0       	brcs	.+4      	; 0x44ba <simple_p_send+0xa0>
    44b6:	ca e2       	ldi	r28, 0x2A	; 42
    44b8:	d0 e0       	ldi	r29, 0x00	; 0
    44ba:	77 24       	eor	r7, r7
    44bc:	73 94       	inc	r7
    44be:	79 0e       	add	r7, r25
    44c0:	f7 01       	movw	r30, r14
    44c2:	90 83       	st	Z, r25
    44c4:	61 82       	std	Z+1, r6	; 0x01
    44c6:	b5 01       	movw	r22, r10
    44c8:	6c 0d       	add	r22, r12
    44ca:	7d 1d       	adc	r23, r13
    44cc:	ae 01       	movw	r20, r28
    44ce:	c4 01       	movw	r24, r8
    44d0:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
    44d4:	9e 01       	movw	r18, r28
    44d6:	2e 5f       	subi	r18, 0xFE	; 254
    44d8:	3f 4f       	sbci	r19, 0xFF	; 255
    44da:	a7 01       	movw	r20, r14
    44dc:	60 e0       	ldi	r22, 0x00	; 0
    44de:	85 2d       	mov	r24, r5
    44e0:	0e 94 2d 17 	call	0x2e5a	; 0x2e5a <network_send>
    44e4:	cc 0e       	add	r12, r28
    44e6:	dd 1e       	adc	r13, r29
    44e8:	0c 1b       	sub	r16, r28
    44ea:	1d 0b       	sbc	r17, r29
    44ec:	97 2d       	mov	r25, r7
    44ee:	f9 f6       	brne	.-66     	; 0x44ae <simple_p_send+0x94>
    44f0:	c7 01       	movw	r24, r14
    44f2:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
    44f6:	81 e0       	ldi	r24, 0x01	; 1
    44f8:	df 91       	pop	r29
    44fa:	cf 91       	pop	r28
    44fc:	1f 91       	pop	r17
    44fe:	0f 91       	pop	r16
    4500:	ff 90       	pop	r15
    4502:	ef 90       	pop	r14
    4504:	df 90       	pop	r13
    4506:	cf 90       	pop	r12
    4508:	bf 90       	pop	r11
    450a:	af 90       	pop	r10
    450c:	9f 90       	pop	r9
    450e:	8f 90       	pop	r8
    4510:	7f 90       	pop	r7
    4512:	6f 90       	pop	r6
    4514:	5f 90       	pop	r5
    4516:	08 95       	ret

00004518 <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    4518:	84 b1       	in	r24, 0x04	; 4
    451a:	87 60       	ori	r24, 0x07	; 7
    451c:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    451e:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    4520:	8c b5       	in	r24, 0x2c	; 44
    4522:	81 60       	ori	r24, 0x01	; 1
    4524:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    4526:	8c b5       	in	r24, 0x2c	; 44
    4528:	8c 65       	ori	r24, 0x5C	; 92
    452a:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    452c:	8c b5       	in	r24, 0x2c	; 44
    452e:	8f 7d       	andi	r24, 0xDF	; 223
    4530:	8c bd       	out	0x2c, r24	; 44
    4532:	08 95       	ret

00004534 <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    4534:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    4536:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    4538:	0d b4       	in	r0, 0x2d	; 45
    453a:	07 fe       	sbrs	r0, 7
    453c:	fd cf       	rjmp	.-6      	; 0x4538 <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    453e:	8e b5       	in	r24, 0x2e	; 46
}
    4540:	08 95       	ret

00004542 <xTaskGenericCreate>:
    4542:	4f 92       	push	r4
    4544:	5f 92       	push	r5
    4546:	6f 92       	push	r6
    4548:	7f 92       	push	r7
    454a:	8f 92       	push	r8
    454c:	9f 92       	push	r9
    454e:	af 92       	push	r10
    4550:	bf 92       	push	r11
    4552:	cf 92       	push	r12
    4554:	df 92       	push	r13
    4556:	ef 92       	push	r14
    4558:	ff 92       	push	r15
    455a:	0f 93       	push	r16
    455c:	1f 93       	push	r17
    455e:	cf 93       	push	r28
    4560:	df 93       	push	r29
    4562:	3c 01       	movw	r6, r24
    4564:	5b 01       	movw	r10, r22
    4566:	4a 01       	movw	r8, r20
    4568:	29 01       	movw	r4, r18
    456a:	c1 14       	cp	r12, r1
    456c:	d1 04       	cpc	r13, r1
    456e:	39 f4       	brne	.+14     	; 0x457e <xTaskGenericCreate+0x3c>
    4570:	ca 01       	movw	r24, r20
    4572:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    4576:	6c 01       	movw	r12, r24
    4578:	89 2b       	or	r24, r25
    457a:	09 f4       	brne	.+2      	; 0x457e <xTaskGenericCreate+0x3c>
    457c:	e4 c0       	rjmp	.+456    	; 0x4746 <xTaskGenericCreate+0x204>
    457e:	88 e2       	ldi	r24, 0x28	; 40
    4580:	90 e0       	ldi	r25, 0x00	; 0
    4582:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    4586:	ec 01       	movw	r28, r24
    4588:	89 2b       	or	r24, r25
    458a:	71 f0       	breq	.+28     	; 0x45a8 <xTaskGenericCreate+0x66>
    458c:	d8 8e       	std	Y+24, r13	; 0x18
    458e:	cf 8a       	std	Y+23, r12	; 0x17
    4590:	81 e0       	ldi	r24, 0x01	; 1
    4592:	88 1a       	sub	r8, r24
    4594:	91 08       	sbc	r9, r1
    4596:	c8 0c       	add	r12, r8
    4598:	d9 1c       	adc	r13, r9
    459a:	d5 01       	movw	r26, r10
    459c:	8c 91       	ld	r24, X
    459e:	89 8f       	std	Y+25, r24	; 0x19
    45a0:	8c 91       	ld	r24, X
    45a2:	81 11       	cpse	r24, r1
    45a4:	05 c0       	rjmp	.+10     	; 0x45b0 <xTaskGenericCreate+0x6e>
    45a6:	18 c0       	rjmp	.+48     	; 0x45d8 <xTaskGenericCreate+0x96>
    45a8:	c6 01       	movw	r24, r12
    45aa:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
    45ae:	cb c0       	rjmp	.+406    	; 0x4746 <xTaskGenericCreate+0x204>
    45b0:	ae 01       	movw	r20, r28
    45b2:	46 5e       	subi	r20, 0xE6	; 230
    45b4:	5f 4f       	sbci	r21, 0xFF	; 255
    45b6:	f5 01       	movw	r30, r10
    45b8:	31 96       	adiw	r30, 0x01	; 1
    45ba:	b8 e0       	ldi	r27, 0x08	; 8
    45bc:	ab 0e       	add	r10, r27
    45be:	b1 1c       	adc	r11, r1
    45c0:	cf 01       	movw	r24, r30
    45c2:	21 91       	ld	r18, Z+
    45c4:	da 01       	movw	r26, r20
    45c6:	2d 93       	st	X+, r18
    45c8:	ad 01       	movw	r20, r26
    45ca:	dc 01       	movw	r26, r24
    45cc:	8c 91       	ld	r24, X
    45ce:	88 23       	and	r24, r24
    45d0:	19 f0       	breq	.+6      	; 0x45d8 <xTaskGenericCreate+0x96>
    45d2:	ae 16       	cp	r10, r30
    45d4:	bf 06       	cpc	r11, r31
    45d6:	a1 f7       	brne	.-24     	; 0x45c0 <xTaskGenericCreate+0x7e>
    45d8:	18 a2       	std	Y+32, r1	; 0x20
    45da:	10 2f       	mov	r17, r16
    45dc:	06 30       	cpi	r16, 0x06	; 6
    45de:	08 f0       	brcs	.+2      	; 0x45e2 <xTaskGenericCreate+0xa0>
    45e0:	15 e0       	ldi	r17, 0x05	; 5
    45e2:	1e 8b       	std	Y+22, r17	; 0x16
    45e4:	19 a3       	std	Y+33, r17	; 0x21
    45e6:	1a a2       	std	Y+34, r1	; 0x22
    45e8:	5e 01       	movw	r10, r28
    45ea:	b2 e0       	ldi	r27, 0x02	; 2
    45ec:	ab 0e       	add	r10, r27
    45ee:	b1 1c       	adc	r11, r1
    45f0:	c5 01       	movw	r24, r10
    45f2:	0e 94 96 0c 	call	0x192c	; 0x192c <vListInitialiseItem>
    45f6:	ce 01       	movw	r24, r28
    45f8:	0c 96       	adiw	r24, 0x0c	; 12
    45fa:	0e 94 96 0c 	call	0x192c	; 0x192c <vListInitialiseItem>
    45fe:	d9 87       	std	Y+9, r29	; 0x09
    4600:	c8 87       	std	Y+8, r28	; 0x08
    4602:	86 e0       	ldi	r24, 0x06	; 6
    4604:	90 e0       	ldi	r25, 0x00	; 0
    4606:	81 1b       	sub	r24, r17
    4608:	91 09       	sbc	r25, r1
    460a:	9d 87       	std	Y+13, r25	; 0x0d
    460c:	8c 87       	std	Y+12, r24	; 0x0c
    460e:	db 8b       	std	Y+19, r29	; 0x13
    4610:	ca 8b       	std	Y+18, r28	; 0x12
    4612:	1b a2       	std	Y+35, r1	; 0x23
    4614:	1c a2       	std	Y+36, r1	; 0x24
    4616:	1d a2       	std	Y+37, r1	; 0x25
    4618:	1e a2       	std	Y+38, r1	; 0x26
    461a:	1f a2       	std	Y+39, r1	; 0x27
    461c:	a2 01       	movw	r20, r4
    461e:	b3 01       	movw	r22, r6
    4620:	c6 01       	movw	r24, r12
    4622:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <pxPortInitialiseStack>
    4626:	99 83       	std	Y+1, r25	; 0x01
    4628:	88 83       	st	Y, r24
    462a:	e1 14       	cp	r14, r1
    462c:	f1 04       	cpc	r15, r1
    462e:	19 f0       	breq	.+6      	; 0x4636 <xTaskGenericCreate+0xf4>
    4630:	f7 01       	movw	r30, r14
    4632:	d1 83       	std	Z+1, r29	; 0x01
    4634:	c0 83       	st	Z, r28
    4636:	0f b6       	in	r0, 0x3f	; 63
    4638:	f8 94       	cli
    463a:	0f 92       	push	r0
    463c:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <uxCurrentNumberOfTasks>
    4640:	8f 5f       	subi	r24, 0xFF	; 255
    4642:	80 93 44 1a 	sts	0x1A44, r24	; 0x801a44 <uxCurrentNumberOfTasks>
    4646:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    464a:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    464e:	89 2b       	or	r24, r25
    4650:	d9 f5       	brne	.+118    	; 0x46c8 <xTaskGenericCreate+0x186>
    4652:	d0 93 a4 1a 	sts	0x1AA4, r29	; 0x801aa4 <pxCurrentTCB+0x1>
    4656:	c0 93 a3 1a 	sts	0x1AA3, r28	; 0x801aa3 <pxCurrentTCB>
    465a:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <uxCurrentNumberOfTasks>
    465e:	81 30       	cpi	r24, 0x01	; 1
    4660:	09 f0       	breq	.+2      	; 0x4664 <xTaskGenericCreate+0x122>
    4662:	41 c0       	rjmp	.+130    	; 0x46e6 <xTaskGenericCreate+0x1a4>
    4664:	0f 2e       	mov	r0, r31
    4666:	fd e6       	ldi	r31, 0x6D	; 109
    4668:	ef 2e       	mov	r14, r31
    466a:	fa e1       	ldi	r31, 0x1A	; 26
    466c:	ff 2e       	mov	r15, r31
    466e:	f0 2d       	mov	r31, r0
    4670:	0f 2e       	mov	r0, r31
    4672:	f3 ea       	ldi	r31, 0xA3	; 163
    4674:	cf 2e       	mov	r12, r31
    4676:	fa e1       	ldi	r31, 0x1A	; 26
    4678:	df 2e       	mov	r13, r31
    467a:	f0 2d       	mov	r31, r0
    467c:	c7 01       	movw	r24, r14
    467e:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    4682:	f9 e0       	ldi	r31, 0x09	; 9
    4684:	ef 0e       	add	r14, r31
    4686:	f1 1c       	adc	r15, r1
    4688:	ec 14       	cp	r14, r12
    468a:	fd 04       	cpc	r15, r13
    468c:	b9 f7       	brne	.-18     	; 0x467c <xTaskGenericCreate+0x13a>
    468e:	84 e6       	ldi	r24, 0x64	; 100
    4690:	9a e1       	ldi	r25, 0x1A	; 26
    4692:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    4696:	8b e5       	ldi	r24, 0x5B	; 91
    4698:	9a e1       	ldi	r25, 0x1A	; 26
    469a:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    469e:	8e e4       	ldi	r24, 0x4E	; 78
    46a0:	9a e1       	ldi	r25, 0x1A	; 26
    46a2:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    46a6:	85 e4       	ldi	r24, 0x45	; 69
    46a8:	9a e1       	ldi	r25, 0x1A	; 26
    46aa:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    46ae:	84 e6       	ldi	r24, 0x64	; 100
    46b0:	9a e1       	ldi	r25, 0x1A	; 26
    46b2:	90 93 5a 1a 	sts	0x1A5A, r25	; 0x801a5a <pxDelayedTaskList+0x1>
    46b6:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <pxDelayedTaskList>
    46ba:	8b e5       	ldi	r24, 0x5B	; 91
    46bc:	9a e1       	ldi	r25, 0x1A	; 26
    46be:	90 93 58 1a 	sts	0x1A58, r25	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    46c2:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <pxOverflowDelayedTaskList>
    46c6:	0f c0       	rjmp	.+30     	; 0x46e6 <xTaskGenericCreate+0x1a4>
    46c8:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xSchedulerRunning>
    46cc:	81 11       	cpse	r24, r1
    46ce:	0b c0       	rjmp	.+22     	; 0x46e6 <xTaskGenericCreate+0x1a4>
    46d0:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    46d4:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    46d8:	86 89       	ldd	r24, Z+22	; 0x16
    46da:	08 17       	cp	r16, r24
    46dc:	20 f0       	brcs	.+8      	; 0x46e6 <xTaskGenericCreate+0x1a4>
    46de:	d0 93 a4 1a 	sts	0x1AA4, r29	; 0x801aa4 <pxCurrentTCB+0x1>
    46e2:	c0 93 a3 1a 	sts	0x1AA3, r28	; 0x801aa3 <pxCurrentTCB>
    46e6:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <uxTaskNumber>
    46ea:	8f 5f       	subi	r24, 0xFF	; 255
    46ec:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <uxTaskNumber>
    46f0:	8e 89       	ldd	r24, Y+22	; 0x16
    46f2:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    46f6:	98 17       	cp	r25, r24
    46f8:	10 f4       	brcc	.+4      	; 0x46fe <xTaskGenericCreate+0x1bc>
    46fa:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    46fe:	90 e0       	ldi	r25, 0x00	; 0
    4700:	9c 01       	movw	r18, r24
    4702:	22 0f       	add	r18, r18
    4704:	33 1f       	adc	r19, r19
    4706:	22 0f       	add	r18, r18
    4708:	33 1f       	adc	r19, r19
    470a:	22 0f       	add	r18, r18
    470c:	33 1f       	adc	r19, r19
    470e:	82 0f       	add	r24, r18
    4710:	93 1f       	adc	r25, r19
    4712:	b5 01       	movw	r22, r10
    4714:	83 59       	subi	r24, 0x93	; 147
    4716:	95 4e       	sbci	r25, 0xE5	; 229
    4718:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    471c:	0f 90       	pop	r0
    471e:	0f be       	out	0x3f, r0	; 63
    4720:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xSchedulerRunning>
    4724:	88 23       	and	r24, r24
    4726:	59 f0       	breq	.+22     	; 0x473e <xTaskGenericCreate+0x1fc>
    4728:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    472c:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4730:	86 89       	ldd	r24, Z+22	; 0x16
    4732:	80 17       	cp	r24, r16
    4734:	30 f4       	brcc	.+12     	; 0x4742 <xTaskGenericCreate+0x200>
    4736:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    473a:	81 e0       	ldi	r24, 0x01	; 1
    473c:	05 c0       	rjmp	.+10     	; 0x4748 <xTaskGenericCreate+0x206>
    473e:	81 e0       	ldi	r24, 0x01	; 1
    4740:	03 c0       	rjmp	.+6      	; 0x4748 <xTaskGenericCreate+0x206>
    4742:	81 e0       	ldi	r24, 0x01	; 1
    4744:	01 c0       	rjmp	.+2      	; 0x4748 <xTaskGenericCreate+0x206>
    4746:	8f ef       	ldi	r24, 0xFF	; 255
    4748:	df 91       	pop	r29
    474a:	cf 91       	pop	r28
    474c:	1f 91       	pop	r17
    474e:	0f 91       	pop	r16
    4750:	ff 90       	pop	r15
    4752:	ef 90       	pop	r14
    4754:	df 90       	pop	r13
    4756:	cf 90       	pop	r12
    4758:	bf 90       	pop	r11
    475a:	af 90       	pop	r10
    475c:	9f 90       	pop	r9
    475e:	8f 90       	pop	r8
    4760:	7f 90       	pop	r7
    4762:	6f 90       	pop	r6
    4764:	5f 90       	pop	r5
    4766:	4f 90       	pop	r4
    4768:	08 95       	ret

0000476a <vTaskDelayUntil>:
    476a:	9f 92       	push	r9
    476c:	af 92       	push	r10
    476e:	bf 92       	push	r11
    4770:	cf 92       	push	r12
    4772:	df 92       	push	r13
    4774:	ef 92       	push	r14
    4776:	ff 92       	push	r15
    4778:	0f 93       	push	r16
    477a:	1f 93       	push	r17
    477c:	cf 93       	push	r28
    477e:	df 93       	push	r29
    4780:	fc 01       	movw	r30, r24
    4782:	90 91 39 1a 	lds	r25, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4786:	9f 5f       	subi	r25, 0xFF	; 255
    4788:	90 93 39 1a 	sts	0x1A39, r25	; 0x801a39 <uxSchedulerSuspended>
    478c:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    4790:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    4794:	20 81       	ld	r18, Z
    4796:	31 81       	ldd	r19, Z+1	; 0x01
    4798:	e9 01       	movw	r28, r18
    479a:	c6 0f       	add	r28, r22
    479c:	d7 1f       	adc	r29, r23
    479e:	82 17       	cp	r24, r18
    47a0:	93 07       	cpc	r25, r19
    47a2:	58 f4       	brcc	.+22     	; 0x47ba <vTaskDelayUntil+0x50>
    47a4:	c2 17       	cp	r28, r18
    47a6:	d3 07       	cpc	r29, r19
    47a8:	08 f0       	brcs	.+2      	; 0x47ac <vTaskDelayUntil+0x42>
    47aa:	6e c1       	rjmp	.+732    	; 0x4a88 <vTaskDelayUntil+0x31e>
    47ac:	d1 83       	std	Z+1, r29	; 0x01
    47ae:	c0 83       	st	Z, r28
    47b0:	8c 17       	cp	r24, r28
    47b2:	9d 07       	cpc	r25, r29
    47b4:	08 f0       	brcs	.+2      	; 0x47b8 <vTaskDelayUntil+0x4e>
    47b6:	42 c0       	rjmp	.+132    	; 0x483c <vTaskDelayUntil+0xd2>
    47b8:	09 c0       	rjmp	.+18     	; 0x47cc <vTaskDelayUntil+0x62>
    47ba:	c2 17       	cp	r28, r18
    47bc:	d3 07       	cpc	r29, r19
    47be:	08 f4       	brcc	.+2      	; 0x47c2 <vTaskDelayUntil+0x58>
    47c0:	60 c1       	rjmp	.+704    	; 0x4a82 <vTaskDelayUntil+0x318>
    47c2:	8c 17       	cp	r24, r28
    47c4:	9d 07       	cpc	r25, r29
    47c6:	08 f4       	brcc	.+2      	; 0x47ca <vTaskDelayUntil+0x60>
    47c8:	5c c1       	rjmp	.+696    	; 0x4a82 <vTaskDelayUntil+0x318>
    47ca:	5e c1       	rjmp	.+700    	; 0x4a88 <vTaskDelayUntil+0x31e>
    47cc:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    47d0:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    47d4:	02 96       	adiw	r24, 0x02	; 2
    47d6:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    47da:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    47de:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    47e2:	d3 83       	std	Z+3, r29	; 0x03
    47e4:	c2 83       	std	Z+2, r28	; 0x02
    47e6:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    47ea:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    47ee:	c8 17       	cp	r28, r24
    47f0:	d9 07       	cpc	r29, r25
    47f2:	68 f4       	brcc	.+26     	; 0x480e <vTaskDelayUntil+0xa4>
    47f4:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    47f8:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    47fc:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    4800:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    4804:	6e 5f       	subi	r22, 0xFE	; 254
    4806:	7f 4f       	sbci	r23, 0xFF	; 255
    4808:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    480c:	17 c0       	rjmp	.+46     	; 0x483c <vTaskDelayUntil+0xd2>
    480e:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4812:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4816:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    481a:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    481e:	6e 5f       	subi	r22, 0xFE	; 254
    4820:	7f 4f       	sbci	r23, 0xFF	; 255
    4822:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    4826:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    482a:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    482e:	c8 17       	cp	r28, r24
    4830:	d9 07       	cpc	r29, r25
    4832:	20 f4       	brcc	.+8      	; 0x483c <vTaskDelayUntil+0xd2>
    4834:	d0 93 3b 1a 	sts	0x1A3B, r29	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4838:	c0 93 3a 1a 	sts	0x1A3A, r28	; 0x801a3a <xNextTaskUnblockTime>
    483c:	0f b6       	in	r0, 0x3f	; 63
    483e:	f8 94       	cli
    4840:	0f 92       	push	r0
    4842:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4846:	81 50       	subi	r24, 0x01	; 1
    4848:	80 93 39 1a 	sts	0x1A39, r24	; 0x801a39 <uxSchedulerSuspended>
    484c:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4850:	81 11       	cpse	r24, r1
    4852:	0d c1       	rjmp	.+538    	; 0x4a6e <vTaskDelayUntil+0x304>
    4854:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <uxCurrentNumberOfTasks>
    4858:	81 11       	cpse	r24, r1
    485a:	33 c0       	rjmp	.+102    	; 0x48c2 <vTaskDelayUntil+0x158>
    485c:	0b c1       	rjmp	.+534    	; 0x4a74 <vTaskDelayUntil+0x30a>
    485e:	d7 01       	movw	r26, r14
    4860:	15 96       	adiw	r26, 0x05	; 5
    4862:	ed 91       	ld	r30, X+
    4864:	fc 91       	ld	r31, X
    4866:	16 97       	sbiw	r26, 0x06	; 6
    4868:	c6 81       	ldd	r28, Z+6	; 0x06
    486a:	d7 81       	ldd	r29, Z+7	; 0x07
    486c:	ce 01       	movw	r24, r28
    486e:	0c 96       	adiw	r24, 0x0c	; 12
    4870:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4874:	8e 01       	movw	r16, r28
    4876:	0e 5f       	subi	r16, 0xFE	; 254
    4878:	1f 4f       	sbci	r17, 0xFF	; 255
    487a:	c8 01       	movw	r24, r16
    487c:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4880:	8e 89       	ldd	r24, Y+22	; 0x16
    4882:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    4886:	98 17       	cp	r25, r24
    4888:	10 f4       	brcc	.+4      	; 0x488e <vTaskDelayUntil+0x124>
    488a:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    488e:	90 e0       	ldi	r25, 0x00	; 0
    4890:	9c 01       	movw	r18, r24
    4892:	22 0f       	add	r18, r18
    4894:	33 1f       	adc	r19, r19
    4896:	22 0f       	add	r18, r18
    4898:	33 1f       	adc	r19, r19
    489a:	22 0f       	add	r18, r18
    489c:	33 1f       	adc	r19, r19
    489e:	82 0f       	add	r24, r18
    48a0:	93 1f       	adc	r25, r19
    48a2:	b8 01       	movw	r22, r16
    48a4:	83 59       	subi	r24, 0x93	; 147
    48a6:	95 4e       	sbci	r25, 0xE5	; 229
    48a8:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    48ac:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    48b0:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    48b4:	9e 89       	ldd	r25, Y+22	; 0x16
    48b6:	86 89       	ldd	r24, Z+22	; 0x16
    48b8:	98 17       	cp	r25, r24
    48ba:	58 f0       	brcs	.+22     	; 0x48d2 <vTaskDelayUntil+0x168>
    48bc:	d0 92 3e 1a 	sts	0x1A3E, r13	; 0x801a3e <xYieldPending>
    48c0:	08 c0       	rjmp	.+16     	; 0x48d2 <vTaskDelayUntil+0x168>
    48c2:	0f 2e       	mov	r0, r31
    48c4:	fe e4       	ldi	r31, 0x4E	; 78
    48c6:	ef 2e       	mov	r14, r31
    48c8:	fa e1       	ldi	r31, 0x1A	; 26
    48ca:	ff 2e       	mov	r15, r31
    48cc:	f0 2d       	mov	r31, r0
    48ce:	dd 24       	eor	r13, r13
    48d0:	d3 94       	inc	r13
    48d2:	f7 01       	movw	r30, r14
    48d4:	80 81       	ld	r24, Z
    48d6:	81 11       	cpse	r24, r1
    48d8:	c2 cf       	rjmp	.-124    	; 0x485e <vTaskDelayUntil+0xf4>
    48da:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    48de:	88 23       	and	r24, r24
    48e0:	09 f4       	brne	.+2      	; 0x48e4 <vTaskDelayUntil+0x17a>
    48e2:	bd c0       	rjmp	.+378    	; 0x4a5e <vTaskDelayUntil+0x2f4>
    48e4:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    48e8:	88 23       	and	r24, r24
    48ea:	09 f4       	brne	.+2      	; 0x48ee <vTaskDelayUntil+0x184>
    48ec:	b8 c0       	rjmp	.+368    	; 0x4a5e <vTaskDelayUntil+0x2f4>
    48ee:	91 2c       	mov	r9, r1
    48f0:	bb 24       	eor	r11, r11
    48f2:	b3 94       	inc	r11
    48f4:	cc 24       	eor	r12, r12
    48f6:	ca 94       	dec	r12
    48f8:	dc 2c       	mov	r13, r12
    48fa:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    48fe:	81 11       	cpse	r24, r1
    4900:	98 c0       	rjmp	.+304    	; 0x4a32 <vTaskDelayUntil+0x2c8>
    4902:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    4906:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    490a:	01 96       	adiw	r24, 0x01	; 1
    490c:	90 93 43 1a 	sts	0x1A43, r25	; 0x801a43 <xTickCount+0x1>
    4910:	80 93 42 1a 	sts	0x1A42, r24	; 0x801a42 <xTickCount>
    4914:	e0 90 42 1a 	lds	r14, 0x1A42	; 0x801a42 <xTickCount>
    4918:	f0 90 43 1a 	lds	r15, 0x1A43	; 0x801a43 <xTickCount+0x1>
    491c:	e1 14       	cp	r14, r1
    491e:	f1 04       	cpc	r15, r1
    4920:	89 f5       	brne	.+98     	; 0x4984 <vTaskDelayUntil+0x21a>
    4922:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4926:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    492a:	20 91 57 1a 	lds	r18, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    492e:	30 91 58 1a 	lds	r19, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    4932:	30 93 5a 1a 	sts	0x1A5A, r19	; 0x801a5a <pxDelayedTaskList+0x1>
    4936:	20 93 59 1a 	sts	0x1A59, r18	; 0x801a59 <pxDelayedTaskList>
    493a:	90 93 58 1a 	sts	0x1A58, r25	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    493e:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <pxOverflowDelayedTaskList>
    4942:	80 91 3d 1a 	lds	r24, 0x1A3D	; 0x801a3d <xNumOfOverflows>
    4946:	8f 5f       	subi	r24, 0xFF	; 255
    4948:	80 93 3d 1a 	sts	0x1A3D, r24	; 0x801a3d <xNumOfOverflows>
    494c:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4950:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    4954:	80 81       	ld	r24, Z
    4956:	81 11       	cpse	r24, r1
    4958:	05 c0       	rjmp	.+10     	; 0x4964 <vTaskDelayUntil+0x1fa>
    495a:	d0 92 3b 1a 	sts	0x1A3B, r13	; 0x801a3b <xNextTaskUnblockTime+0x1>
    495e:	c0 92 3a 1a 	sts	0x1A3A, r12	; 0x801a3a <xNextTaskUnblockTime>
    4962:	10 c0       	rjmp	.+32     	; 0x4984 <vTaskDelayUntil+0x21a>
    4964:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4968:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    496c:	05 80       	ldd	r0, Z+5	; 0x05
    496e:	f6 81       	ldd	r31, Z+6	; 0x06
    4970:	e0 2d       	mov	r30, r0
    4972:	06 80       	ldd	r0, Z+6	; 0x06
    4974:	f7 81       	ldd	r31, Z+7	; 0x07
    4976:	e0 2d       	mov	r30, r0
    4978:	82 81       	ldd	r24, Z+2	; 0x02
    497a:	93 81       	ldd	r25, Z+3	; 0x03
    497c:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4980:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    4984:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    4988:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    498c:	e8 16       	cp	r14, r24
    498e:	f9 06       	cpc	r15, r25
    4990:	08 f4       	brcc	.+2      	; 0x4994 <vTaskDelayUntil+0x22a>
    4992:	7d c0       	rjmp	.+250    	; 0x4a8e <vTaskDelayUntil+0x324>
    4994:	a9 2c       	mov	r10, r9
    4996:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    499a:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    499e:	80 81       	ld	r24, Z
    49a0:	81 11       	cpse	r24, r1
    49a2:	05 c0       	rjmp	.+10     	; 0x49ae <vTaskDelayUntil+0x244>
    49a4:	d0 92 3b 1a 	sts	0x1A3B, r13	; 0x801a3b <xNextTaskUnblockTime+0x1>
    49a8:	c0 92 3a 1a 	sts	0x1A3A, r12	; 0x801a3a <xNextTaskUnblockTime>
    49ac:	48 c0       	rjmp	.+144    	; 0x4a3e <vTaskDelayUntil+0x2d4>
    49ae:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    49b2:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    49b6:	05 80       	ldd	r0, Z+5	; 0x05
    49b8:	f6 81       	ldd	r31, Z+6	; 0x06
    49ba:	e0 2d       	mov	r30, r0
    49bc:	c6 81       	ldd	r28, Z+6	; 0x06
    49be:	d7 81       	ldd	r29, Z+7	; 0x07
    49c0:	8a 81       	ldd	r24, Y+2	; 0x02
    49c2:	9b 81       	ldd	r25, Y+3	; 0x03
    49c4:	e8 16       	cp	r14, r24
    49c6:	f9 06       	cpc	r15, r25
    49c8:	28 f4       	brcc	.+10     	; 0x49d4 <vTaskDelayUntil+0x26a>
    49ca:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    49ce:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    49d2:	35 c0       	rjmp	.+106    	; 0x4a3e <vTaskDelayUntil+0x2d4>
    49d4:	8e 01       	movw	r16, r28
    49d6:	0e 5f       	subi	r16, 0xFE	; 254
    49d8:	1f 4f       	sbci	r17, 0xFF	; 255
    49da:	c8 01       	movw	r24, r16
    49dc:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    49e0:	8c 89       	ldd	r24, Y+20	; 0x14
    49e2:	9d 89       	ldd	r25, Y+21	; 0x15
    49e4:	89 2b       	or	r24, r25
    49e6:	21 f0       	breq	.+8      	; 0x49f0 <vTaskDelayUntil+0x286>
    49e8:	ce 01       	movw	r24, r28
    49ea:	0c 96       	adiw	r24, 0x0c	; 12
    49ec:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    49f0:	8e 89       	ldd	r24, Y+22	; 0x16
    49f2:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    49f6:	98 17       	cp	r25, r24
    49f8:	10 f4       	brcc	.+4      	; 0x49fe <vTaskDelayUntil+0x294>
    49fa:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    49fe:	90 e0       	ldi	r25, 0x00	; 0
    4a00:	9c 01       	movw	r18, r24
    4a02:	22 0f       	add	r18, r18
    4a04:	33 1f       	adc	r19, r19
    4a06:	22 0f       	add	r18, r18
    4a08:	33 1f       	adc	r19, r19
    4a0a:	22 0f       	add	r18, r18
    4a0c:	33 1f       	adc	r19, r19
    4a0e:	82 0f       	add	r24, r18
    4a10:	93 1f       	adc	r25, r19
    4a12:	b8 01       	movw	r22, r16
    4a14:	83 59       	subi	r24, 0x93	; 147
    4a16:	95 4e       	sbci	r25, 0xE5	; 229
    4a18:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    4a1c:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4a20:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4a24:	9e 89       	ldd	r25, Y+22	; 0x16
    4a26:	86 89       	ldd	r24, Z+22	; 0x16
    4a28:	98 17       	cp	r25, r24
    4a2a:	08 f4       	brcc	.+2      	; 0x4a2e <vTaskDelayUntil+0x2c4>
    4a2c:	b4 cf       	rjmp	.-152    	; 0x4996 <vTaskDelayUntil+0x22c>
    4a2e:	ab 2c       	mov	r10, r11
    4a30:	b2 cf       	rjmp	.-156    	; 0x4996 <vTaskDelayUntil+0x22c>
    4a32:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    4a36:	8f 5f       	subi	r24, 0xFF	; 255
    4a38:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <uxPendedTicks>
    4a3c:	28 c0       	rjmp	.+80     	; 0x4a8e <vTaskDelayUntil+0x324>
    4a3e:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    4a42:	81 11       	cpse	r24, r1
    4a44:	01 c0       	rjmp	.+2      	; 0x4a48 <vTaskDelayUntil+0x2de>
    4a46:	a1 10       	cpse	r10, r1
    4a48:	b0 92 3e 1a 	sts	0x1A3E, r11	; 0x801a3e <xYieldPending>
    4a4c:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    4a50:	81 50       	subi	r24, 0x01	; 1
    4a52:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <uxPendedTicks>
    4a56:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    4a5a:	81 11       	cpse	r24, r1
    4a5c:	4e cf       	rjmp	.-356    	; 0x48fa <vTaskDelayUntil+0x190>
    4a5e:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    4a62:	81 30       	cpi	r24, 0x01	; 1
    4a64:	31 f4       	brne	.+12     	; 0x4a72 <vTaskDelayUntil+0x308>
    4a66:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    4a6a:	81 e0       	ldi	r24, 0x01	; 1
    4a6c:	03 c0       	rjmp	.+6      	; 0x4a74 <vTaskDelayUntil+0x30a>
    4a6e:	80 e0       	ldi	r24, 0x00	; 0
    4a70:	01 c0       	rjmp	.+2      	; 0x4a74 <vTaskDelayUntil+0x30a>
    4a72:	80 e0       	ldi	r24, 0x00	; 0
    4a74:	0f 90       	pop	r0
    4a76:	0f be       	out	0x3f, r0	; 63
    4a78:	81 11       	cpse	r24, r1
    4a7a:	0e c0       	rjmp	.+28     	; 0x4a98 <vTaskDelayUntil+0x32e>
    4a7c:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    4a80:	0b c0       	rjmp	.+22     	; 0x4a98 <vTaskDelayUntil+0x32e>
    4a82:	d1 83       	std	Z+1, r29	; 0x01
    4a84:	c0 83       	st	Z, r28
    4a86:	a2 ce       	rjmp	.-700    	; 0x47cc <vTaskDelayUntil+0x62>
    4a88:	d1 83       	std	Z+1, r29	; 0x01
    4a8a:	c0 83       	st	Z, r28
    4a8c:	d7 ce       	rjmp	.-594    	; 0x483c <vTaskDelayUntil+0xd2>
    4a8e:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    4a92:	81 11       	cpse	r24, r1
    4a94:	d9 cf       	rjmp	.-78     	; 0x4a48 <vTaskDelayUntil+0x2de>
    4a96:	da cf       	rjmp	.-76     	; 0x4a4c <vTaskDelayUntil+0x2e2>
    4a98:	df 91       	pop	r29
    4a9a:	cf 91       	pop	r28
    4a9c:	1f 91       	pop	r17
    4a9e:	0f 91       	pop	r16
    4aa0:	ff 90       	pop	r15
    4aa2:	ef 90       	pop	r14
    4aa4:	df 90       	pop	r13
    4aa6:	cf 90       	pop	r12
    4aa8:	bf 90       	pop	r11
    4aaa:	af 90       	pop	r10
    4aac:	9f 90       	pop	r9
    4aae:	08 95       	ret

00004ab0 <vTaskDelay>:
    4ab0:	9f 92       	push	r9
    4ab2:	af 92       	push	r10
    4ab4:	bf 92       	push	r11
    4ab6:	cf 92       	push	r12
    4ab8:	df 92       	push	r13
    4aba:	ef 92       	push	r14
    4abc:	ff 92       	push	r15
    4abe:	0f 93       	push	r16
    4ac0:	1f 93       	push	r17
    4ac2:	cf 93       	push	r28
    4ac4:	df 93       	push	r29
    4ac6:	00 97       	sbiw	r24, 0x00	; 0
    4ac8:	09 f4       	brne	.+2      	; 0x4acc <vTaskDelay+0x1c>
    4aca:	63 c1       	rjmp	.+710    	; 0x4d92 <vTaskDelay+0x2e2>
    4acc:	20 91 39 1a 	lds	r18, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4ad0:	2f 5f       	subi	r18, 0xFF	; 255
    4ad2:	20 93 39 1a 	sts	0x1A39, r18	; 0x801a39 <uxSchedulerSuspended>
    4ad6:	c0 91 42 1a 	lds	r28, 0x1A42	; 0x801a42 <xTickCount>
    4ada:	d0 91 43 1a 	lds	r29, 0x1A43	; 0x801a43 <xTickCount+0x1>
    4ade:	c8 0f       	add	r28, r24
    4ae0:	d9 1f       	adc	r29, r25
    4ae2:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4ae6:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4aea:	02 96       	adiw	r24, 0x02	; 2
    4aec:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4af0:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4af4:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4af8:	d3 83       	std	Z+3, r29	; 0x03
    4afa:	c2 83       	std	Z+2, r28	; 0x02
    4afc:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    4b00:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    4b04:	c8 17       	cp	r28, r24
    4b06:	d9 07       	cpc	r29, r25
    4b08:	68 f4       	brcc	.+26     	; 0x4b24 <vTaskDelay+0x74>
    4b0a:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4b0e:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4b12:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    4b16:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    4b1a:	6e 5f       	subi	r22, 0xFE	; 254
    4b1c:	7f 4f       	sbci	r23, 0xFF	; 255
    4b1e:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    4b22:	17 c0       	rjmp	.+46     	; 0x4b52 <vTaskDelay+0xa2>
    4b24:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4b28:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4b2c:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4b30:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    4b34:	6e 5f       	subi	r22, 0xFE	; 254
    4b36:	7f 4f       	sbci	r23, 0xFF	; 255
    4b38:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    4b3c:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    4b40:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4b44:	c8 17       	cp	r28, r24
    4b46:	d9 07       	cpc	r29, r25
    4b48:	20 f4       	brcc	.+8      	; 0x4b52 <vTaskDelay+0xa2>
    4b4a:	d0 93 3b 1a 	sts	0x1A3B, r29	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4b4e:	c0 93 3a 1a 	sts	0x1A3A, r28	; 0x801a3a <xNextTaskUnblockTime>
    4b52:	0f b6       	in	r0, 0x3f	; 63
    4b54:	f8 94       	cli
    4b56:	0f 92       	push	r0
    4b58:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4b5c:	81 50       	subi	r24, 0x01	; 1
    4b5e:	80 93 39 1a 	sts	0x1A39, r24	; 0x801a39 <uxSchedulerSuspended>
    4b62:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4b66:	81 11       	cpse	r24, r1
    4b68:	0d c1       	rjmp	.+538    	; 0x4d84 <vTaskDelay+0x2d4>
    4b6a:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <uxCurrentNumberOfTasks>
    4b6e:	81 11       	cpse	r24, r1
    4b70:	33 c0       	rjmp	.+102    	; 0x4bd8 <vTaskDelay+0x128>
    4b72:	0b c1       	rjmp	.+534    	; 0x4d8a <vTaskDelay+0x2da>
    4b74:	d7 01       	movw	r26, r14
    4b76:	15 96       	adiw	r26, 0x05	; 5
    4b78:	ed 91       	ld	r30, X+
    4b7a:	fc 91       	ld	r31, X
    4b7c:	16 97       	sbiw	r26, 0x06	; 6
    4b7e:	c6 81       	ldd	r28, Z+6	; 0x06
    4b80:	d7 81       	ldd	r29, Z+7	; 0x07
    4b82:	ce 01       	movw	r24, r28
    4b84:	0c 96       	adiw	r24, 0x0c	; 12
    4b86:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4b8a:	8e 01       	movw	r16, r28
    4b8c:	0e 5f       	subi	r16, 0xFE	; 254
    4b8e:	1f 4f       	sbci	r17, 0xFF	; 255
    4b90:	c8 01       	movw	r24, r16
    4b92:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4b96:	8e 89       	ldd	r24, Y+22	; 0x16
    4b98:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    4b9c:	98 17       	cp	r25, r24
    4b9e:	10 f4       	brcc	.+4      	; 0x4ba4 <vTaskDelay+0xf4>
    4ba0:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    4ba4:	90 e0       	ldi	r25, 0x00	; 0
    4ba6:	9c 01       	movw	r18, r24
    4ba8:	22 0f       	add	r18, r18
    4baa:	33 1f       	adc	r19, r19
    4bac:	22 0f       	add	r18, r18
    4bae:	33 1f       	adc	r19, r19
    4bb0:	22 0f       	add	r18, r18
    4bb2:	33 1f       	adc	r19, r19
    4bb4:	82 0f       	add	r24, r18
    4bb6:	93 1f       	adc	r25, r19
    4bb8:	b8 01       	movw	r22, r16
    4bba:	83 59       	subi	r24, 0x93	; 147
    4bbc:	95 4e       	sbci	r25, 0xE5	; 229
    4bbe:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    4bc2:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4bc6:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4bca:	9e 89       	ldd	r25, Y+22	; 0x16
    4bcc:	86 89       	ldd	r24, Z+22	; 0x16
    4bce:	98 17       	cp	r25, r24
    4bd0:	58 f0       	brcs	.+22     	; 0x4be8 <vTaskDelay+0x138>
    4bd2:	d0 92 3e 1a 	sts	0x1A3E, r13	; 0x801a3e <xYieldPending>
    4bd6:	08 c0       	rjmp	.+16     	; 0x4be8 <vTaskDelay+0x138>
    4bd8:	0f 2e       	mov	r0, r31
    4bda:	fe e4       	ldi	r31, 0x4E	; 78
    4bdc:	ef 2e       	mov	r14, r31
    4bde:	fa e1       	ldi	r31, 0x1A	; 26
    4be0:	ff 2e       	mov	r15, r31
    4be2:	f0 2d       	mov	r31, r0
    4be4:	dd 24       	eor	r13, r13
    4be6:	d3 94       	inc	r13
    4be8:	f7 01       	movw	r30, r14
    4bea:	80 81       	ld	r24, Z
    4bec:	81 11       	cpse	r24, r1
    4bee:	c2 cf       	rjmp	.-124    	; 0x4b74 <vTaskDelay+0xc4>
    4bf0:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    4bf4:	88 23       	and	r24, r24
    4bf6:	09 f4       	brne	.+2      	; 0x4bfa <vTaskDelay+0x14a>
    4bf8:	bd c0       	rjmp	.+378    	; 0x4d74 <vTaskDelay+0x2c4>
    4bfa:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    4bfe:	88 23       	and	r24, r24
    4c00:	09 f4       	brne	.+2      	; 0x4c04 <vTaskDelay+0x154>
    4c02:	b8 c0       	rjmp	.+368    	; 0x4d74 <vTaskDelay+0x2c4>
    4c04:	91 2c       	mov	r9, r1
    4c06:	bb 24       	eor	r11, r11
    4c08:	b3 94       	inc	r11
    4c0a:	cc 24       	eor	r12, r12
    4c0c:	ca 94       	dec	r12
    4c0e:	dc 2c       	mov	r13, r12
    4c10:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4c14:	81 11       	cpse	r24, r1
    4c16:	98 c0       	rjmp	.+304    	; 0x4d48 <vTaskDelay+0x298>
    4c18:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    4c1c:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    4c20:	01 96       	adiw	r24, 0x01	; 1
    4c22:	90 93 43 1a 	sts	0x1A43, r25	; 0x801a43 <xTickCount+0x1>
    4c26:	80 93 42 1a 	sts	0x1A42, r24	; 0x801a42 <xTickCount>
    4c2a:	e0 90 42 1a 	lds	r14, 0x1A42	; 0x801a42 <xTickCount>
    4c2e:	f0 90 43 1a 	lds	r15, 0x1A43	; 0x801a43 <xTickCount+0x1>
    4c32:	e1 14       	cp	r14, r1
    4c34:	f1 04       	cpc	r15, r1
    4c36:	89 f5       	brne	.+98     	; 0x4c9a <vTaskDelay+0x1ea>
    4c38:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4c3c:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    4c40:	20 91 57 1a 	lds	r18, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    4c44:	30 91 58 1a 	lds	r19, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    4c48:	30 93 5a 1a 	sts	0x1A5A, r19	; 0x801a5a <pxDelayedTaskList+0x1>
    4c4c:	20 93 59 1a 	sts	0x1A59, r18	; 0x801a59 <pxDelayedTaskList>
    4c50:	90 93 58 1a 	sts	0x1A58, r25	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    4c54:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <pxOverflowDelayedTaskList>
    4c58:	80 91 3d 1a 	lds	r24, 0x1A3D	; 0x801a3d <xNumOfOverflows>
    4c5c:	8f 5f       	subi	r24, 0xFF	; 255
    4c5e:	80 93 3d 1a 	sts	0x1A3D, r24	; 0x801a3d <xNumOfOverflows>
    4c62:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4c66:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    4c6a:	80 81       	ld	r24, Z
    4c6c:	81 11       	cpse	r24, r1
    4c6e:	05 c0       	rjmp	.+10     	; 0x4c7a <vTaskDelay+0x1ca>
    4c70:	d0 92 3b 1a 	sts	0x1A3B, r13	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4c74:	c0 92 3a 1a 	sts	0x1A3A, r12	; 0x801a3a <xNextTaskUnblockTime>
    4c78:	10 c0       	rjmp	.+32     	; 0x4c9a <vTaskDelay+0x1ea>
    4c7a:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4c7e:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    4c82:	05 80       	ldd	r0, Z+5	; 0x05
    4c84:	f6 81       	ldd	r31, Z+6	; 0x06
    4c86:	e0 2d       	mov	r30, r0
    4c88:	06 80       	ldd	r0, Z+6	; 0x06
    4c8a:	f7 81       	ldd	r31, Z+7	; 0x07
    4c8c:	e0 2d       	mov	r30, r0
    4c8e:	82 81       	ldd	r24, Z+2	; 0x02
    4c90:	93 81       	ldd	r25, Z+3	; 0x03
    4c92:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4c96:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    4c9a:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    4c9e:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4ca2:	e8 16       	cp	r14, r24
    4ca4:	f9 06       	cpc	r15, r25
    4ca6:	08 f4       	brcc	.+2      	; 0x4caa <vTaskDelay+0x1fa>
    4ca8:	77 c0       	rjmp	.+238    	; 0x4d98 <vTaskDelay+0x2e8>
    4caa:	a9 2c       	mov	r10, r9
    4cac:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4cb0:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    4cb4:	80 81       	ld	r24, Z
    4cb6:	81 11       	cpse	r24, r1
    4cb8:	05 c0       	rjmp	.+10     	; 0x4cc4 <vTaskDelay+0x214>
    4cba:	d0 92 3b 1a 	sts	0x1A3B, r13	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4cbe:	c0 92 3a 1a 	sts	0x1A3A, r12	; 0x801a3a <xNextTaskUnblockTime>
    4cc2:	48 c0       	rjmp	.+144    	; 0x4d54 <vTaskDelay+0x2a4>
    4cc4:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    4cc8:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    4ccc:	05 80       	ldd	r0, Z+5	; 0x05
    4cce:	f6 81       	ldd	r31, Z+6	; 0x06
    4cd0:	e0 2d       	mov	r30, r0
    4cd2:	c6 81       	ldd	r28, Z+6	; 0x06
    4cd4:	d7 81       	ldd	r29, Z+7	; 0x07
    4cd6:	8a 81       	ldd	r24, Y+2	; 0x02
    4cd8:	9b 81       	ldd	r25, Y+3	; 0x03
    4cda:	e8 16       	cp	r14, r24
    4cdc:	f9 06       	cpc	r15, r25
    4cde:	28 f4       	brcc	.+10     	; 0x4cea <vTaskDelay+0x23a>
    4ce0:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4ce4:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    4ce8:	35 c0       	rjmp	.+106    	; 0x4d54 <vTaskDelay+0x2a4>
    4cea:	8e 01       	movw	r16, r28
    4cec:	0e 5f       	subi	r16, 0xFE	; 254
    4cee:	1f 4f       	sbci	r17, 0xFF	; 255
    4cf0:	c8 01       	movw	r24, r16
    4cf2:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4cf6:	8c 89       	ldd	r24, Y+20	; 0x14
    4cf8:	9d 89       	ldd	r25, Y+21	; 0x15
    4cfa:	89 2b       	or	r24, r25
    4cfc:	21 f0       	breq	.+8      	; 0x4d06 <vTaskDelay+0x256>
    4cfe:	ce 01       	movw	r24, r28
    4d00:	0c 96       	adiw	r24, 0x0c	; 12
    4d02:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4d06:	8e 89       	ldd	r24, Y+22	; 0x16
    4d08:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    4d0c:	98 17       	cp	r25, r24
    4d0e:	10 f4       	brcc	.+4      	; 0x4d14 <vTaskDelay+0x264>
    4d10:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    4d14:	90 e0       	ldi	r25, 0x00	; 0
    4d16:	9c 01       	movw	r18, r24
    4d18:	22 0f       	add	r18, r18
    4d1a:	33 1f       	adc	r19, r19
    4d1c:	22 0f       	add	r18, r18
    4d1e:	33 1f       	adc	r19, r19
    4d20:	22 0f       	add	r18, r18
    4d22:	33 1f       	adc	r19, r19
    4d24:	82 0f       	add	r24, r18
    4d26:	93 1f       	adc	r25, r19
    4d28:	b8 01       	movw	r22, r16
    4d2a:	83 59       	subi	r24, 0x93	; 147
    4d2c:	95 4e       	sbci	r25, 0xE5	; 229
    4d2e:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    4d32:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4d36:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4d3a:	9e 89       	ldd	r25, Y+22	; 0x16
    4d3c:	86 89       	ldd	r24, Z+22	; 0x16
    4d3e:	98 17       	cp	r25, r24
    4d40:	08 f4       	brcc	.+2      	; 0x4d44 <vTaskDelay+0x294>
    4d42:	b4 cf       	rjmp	.-152    	; 0x4cac <vTaskDelay+0x1fc>
    4d44:	ab 2c       	mov	r10, r11
    4d46:	b2 cf       	rjmp	.-156    	; 0x4cac <vTaskDelay+0x1fc>
    4d48:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    4d4c:	8f 5f       	subi	r24, 0xFF	; 255
    4d4e:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <uxPendedTicks>
    4d52:	22 c0       	rjmp	.+68     	; 0x4d98 <vTaskDelay+0x2e8>
    4d54:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    4d58:	81 11       	cpse	r24, r1
    4d5a:	01 c0       	rjmp	.+2      	; 0x4d5e <vTaskDelay+0x2ae>
    4d5c:	a1 10       	cpse	r10, r1
    4d5e:	b0 92 3e 1a 	sts	0x1A3E, r11	; 0x801a3e <xYieldPending>
    4d62:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    4d66:	81 50       	subi	r24, 0x01	; 1
    4d68:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <uxPendedTicks>
    4d6c:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    4d70:	81 11       	cpse	r24, r1
    4d72:	4e cf       	rjmp	.-356    	; 0x4c10 <vTaskDelay+0x160>
    4d74:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    4d78:	81 30       	cpi	r24, 0x01	; 1
    4d7a:	31 f4       	brne	.+12     	; 0x4d88 <vTaskDelay+0x2d8>
    4d7c:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    4d80:	81 e0       	ldi	r24, 0x01	; 1
    4d82:	03 c0       	rjmp	.+6      	; 0x4d8a <vTaskDelay+0x2da>
    4d84:	80 e0       	ldi	r24, 0x00	; 0
    4d86:	01 c0       	rjmp	.+2      	; 0x4d8a <vTaskDelay+0x2da>
    4d88:	80 e0       	ldi	r24, 0x00	; 0
    4d8a:	0f 90       	pop	r0
    4d8c:	0f be       	out	0x3f, r0	; 63
    4d8e:	81 11       	cpse	r24, r1
    4d90:	08 c0       	rjmp	.+16     	; 0x4da2 <vTaskDelay+0x2f2>
    4d92:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    4d96:	05 c0       	rjmp	.+10     	; 0x4da2 <vTaskDelay+0x2f2>
    4d98:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    4d9c:	81 11       	cpse	r24, r1
    4d9e:	df cf       	rjmp	.-66     	; 0x4d5e <vTaskDelay+0x2ae>
    4da0:	e0 cf       	rjmp	.-64     	; 0x4d62 <vTaskDelay+0x2b2>
    4da2:	df 91       	pop	r29
    4da4:	cf 91       	pop	r28
    4da6:	1f 91       	pop	r17
    4da8:	0f 91       	pop	r16
    4daa:	ff 90       	pop	r15
    4dac:	ef 90       	pop	r14
    4dae:	df 90       	pop	r13
    4db0:	cf 90       	pop	r12
    4db2:	bf 90       	pop	r11
    4db4:	af 90       	pop	r10
    4db6:	9f 90       	pop	r9
    4db8:	08 95       	ret

00004dba <vTaskStartScheduler>:
    4dba:	cf 92       	push	r12
    4dbc:	df 92       	push	r13
    4dbe:	ef 92       	push	r14
    4dc0:	ff 92       	push	r15
    4dc2:	0f 93       	push	r16
    4dc4:	1f 93       	push	r17
    4dc6:	cf 93       	push	r28
    4dc8:	df 93       	push	r29
    4dca:	85 e5       	ldi	r24, 0x55	; 85
    4dcc:	90 e0       	ldi	r25, 0x00	; 0
    4dce:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    4dd2:	8c 01       	movw	r16, r24
    4dd4:	89 2b       	or	r24, r25
    4dd6:	09 f4       	brne	.+2      	; 0x4dda <vTaskStartScheduler+0x20>
    4dd8:	cb c0       	rjmp	.+406    	; 0x4f70 <vTaskStartScheduler+0x1b6>
    4dda:	88 e2       	ldi	r24, 0x28	; 40
    4ddc:	90 e0       	ldi	r25, 0x00	; 0
    4dde:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
    4de2:	ec 01       	movw	r28, r24
    4de4:	89 2b       	or	r24, r25
    4de6:	69 f0       	breq	.+26     	; 0x4e02 <vTaskStartScheduler+0x48>
    4de8:	18 8f       	std	Y+24, r17	; 0x18
    4dea:	0f 8b       	std	Y+23, r16	; 0x17
    4dec:	0c 5a       	subi	r16, 0xAC	; 172
    4dee:	1f 4f       	sbci	r17, 0xFF	; 255
    4df0:	89 e4       	ldi	r24, 0x49	; 73
    4df2:	89 8f       	std	Y+25, r24	; 0x19
    4df4:	ec ef       	ldi	r30, 0xFC	; 252
    4df6:	f6 e0       	ldi	r31, 0x06	; 6
    4df8:	de 01       	movw	r26, r28
    4dfa:	5a 96       	adiw	r26, 0x1a	; 26
    4dfc:	23 e0       	ldi	r18, 0x03	; 3
    4dfe:	37 e0       	ldi	r19, 0x07	; 7
    4e00:	04 c0       	rjmp	.+8      	; 0x4e0a <vTaskStartScheduler+0x50>
    4e02:	c8 01       	movw	r24, r16
    4e04:	0e 94 73 09 	call	0x12e6	; 0x12e6 <vPortFree>
    4e08:	b3 c0       	rjmp	.+358    	; 0x4f70 <vTaskStartScheduler+0x1b6>
    4e0a:	91 91       	ld	r25, Z+
    4e0c:	9d 93       	st	X+, r25
    4e0e:	99 23       	and	r25, r25
    4e10:	19 f0       	breq	.+6      	; 0x4e18 <vTaskStartScheduler+0x5e>
    4e12:	2e 17       	cp	r18, r30
    4e14:	3f 07       	cpc	r19, r31
    4e16:	c9 f7       	brne	.-14     	; 0x4e0a <vTaskStartScheduler+0x50>
    4e18:	18 a2       	std	Y+32, r1	; 0x20
    4e1a:	1e 8a       	std	Y+22, r1	; 0x16
    4e1c:	19 a2       	std	Y+33, r1	; 0x21
    4e1e:	1a a2       	std	Y+34, r1	; 0x22
    4e20:	7e 01       	movw	r14, r28
    4e22:	82 e0       	ldi	r24, 0x02	; 2
    4e24:	e8 0e       	add	r14, r24
    4e26:	f1 1c       	adc	r15, r1
    4e28:	c7 01       	movw	r24, r14
    4e2a:	0e 94 96 0c 	call	0x192c	; 0x192c <vListInitialiseItem>
    4e2e:	ce 01       	movw	r24, r28
    4e30:	0c 96       	adiw	r24, 0x0c	; 12
    4e32:	0e 94 96 0c 	call	0x192c	; 0x192c <vListInitialiseItem>
    4e36:	d9 87       	std	Y+9, r29	; 0x09
    4e38:	c8 87       	std	Y+8, r28	; 0x08
    4e3a:	86 e0       	ldi	r24, 0x06	; 6
    4e3c:	90 e0       	ldi	r25, 0x00	; 0
    4e3e:	9d 87       	std	Y+13, r25	; 0x0d
    4e40:	8c 87       	std	Y+12, r24	; 0x0c
    4e42:	db 8b       	std	Y+19, r29	; 0x13
    4e44:	ca 8b       	std	Y+18, r28	; 0x12
    4e46:	1b a2       	std	Y+35, r1	; 0x23
    4e48:	1c a2       	std	Y+36, r1	; 0x24
    4e4a:	1d a2       	std	Y+37, r1	; 0x25
    4e4c:	1e a2       	std	Y+38, r1	; 0x26
    4e4e:	1f a2       	std	Y+39, r1	; 0x27
    4e50:	40 e0       	ldi	r20, 0x00	; 0
    4e52:	50 e0       	ldi	r21, 0x00	; 0
    4e54:	69 e1       	ldi	r22, 0x19	; 25
    4e56:	71 e0       	ldi	r23, 0x01	; 1
    4e58:	c8 01       	movw	r24, r16
    4e5a:	0e 94 9f 17 	call	0x2f3e	; 0x2f3e <pxPortInitialiseStack>
    4e5e:	99 83       	std	Y+1, r25	; 0x01
    4e60:	88 83       	st	Y, r24
    4e62:	0f b6       	in	r0, 0x3f	; 63
    4e64:	f8 94       	cli
    4e66:	0f 92       	push	r0
    4e68:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <uxCurrentNumberOfTasks>
    4e6c:	8f 5f       	subi	r24, 0xFF	; 255
    4e6e:	80 93 44 1a 	sts	0x1A44, r24	; 0x801a44 <uxCurrentNumberOfTasks>
    4e72:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4e76:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4e7a:	89 2b       	or	r24, r25
    4e7c:	a9 f5       	brne	.+106    	; 0x4ee8 <vTaskStartScheduler+0x12e>
    4e7e:	d0 93 a4 1a 	sts	0x1AA4, r29	; 0x801aa4 <pxCurrentTCB+0x1>
    4e82:	c0 93 a3 1a 	sts	0x1AA3, r28	; 0x801aa3 <pxCurrentTCB>
    4e86:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <uxCurrentNumberOfTasks>
    4e8a:	81 30       	cpi	r24, 0x01	; 1
    4e8c:	e1 f5       	brne	.+120    	; 0x4f06 <vTaskStartScheduler+0x14c>
    4e8e:	0d e6       	ldi	r16, 0x6D	; 109
    4e90:	1a e1       	ldi	r17, 0x1A	; 26
    4e92:	0f 2e       	mov	r0, r31
    4e94:	f3 ea       	ldi	r31, 0xA3	; 163
    4e96:	cf 2e       	mov	r12, r31
    4e98:	fa e1       	ldi	r31, 0x1A	; 26
    4e9a:	df 2e       	mov	r13, r31
    4e9c:	f0 2d       	mov	r31, r0
    4e9e:	c8 01       	movw	r24, r16
    4ea0:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    4ea4:	07 5f       	subi	r16, 0xF7	; 247
    4ea6:	1f 4f       	sbci	r17, 0xFF	; 255
    4ea8:	0c 15       	cp	r16, r12
    4eaa:	1d 05       	cpc	r17, r13
    4eac:	c1 f7       	brne	.-16     	; 0x4e9e <vTaskStartScheduler+0xe4>
    4eae:	84 e6       	ldi	r24, 0x64	; 100
    4eb0:	9a e1       	ldi	r25, 0x1A	; 26
    4eb2:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    4eb6:	8b e5       	ldi	r24, 0x5B	; 91
    4eb8:	9a e1       	ldi	r25, 0x1A	; 26
    4eba:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    4ebe:	8e e4       	ldi	r24, 0x4E	; 78
    4ec0:	9a e1       	ldi	r25, 0x1A	; 26
    4ec2:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    4ec6:	85 e4       	ldi	r24, 0x45	; 69
    4ec8:	9a e1       	ldi	r25, 0x1A	; 26
    4eca:	0e 94 88 0c 	call	0x1910	; 0x1910 <vListInitialise>
    4ece:	84 e6       	ldi	r24, 0x64	; 100
    4ed0:	9a e1       	ldi	r25, 0x1A	; 26
    4ed2:	90 93 5a 1a 	sts	0x1A5A, r25	; 0x801a5a <pxDelayedTaskList+0x1>
    4ed6:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <pxDelayedTaskList>
    4eda:	8b e5       	ldi	r24, 0x5B	; 91
    4edc:	9a e1       	ldi	r25, 0x1A	; 26
    4ede:	90 93 58 1a 	sts	0x1A58, r25	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    4ee2:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <pxOverflowDelayedTaskList>
    4ee6:	0f c0       	rjmp	.+30     	; 0x4f06 <vTaskStartScheduler+0x14c>
    4ee8:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xSchedulerRunning>
    4eec:	81 11       	cpse	r24, r1
    4eee:	0b c0       	rjmp	.+22     	; 0x4f06 <vTaskStartScheduler+0x14c>
    4ef0:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4ef4:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4ef8:	86 89       	ldd	r24, Z+22	; 0x16
    4efa:	81 11       	cpse	r24, r1
    4efc:	04 c0       	rjmp	.+8      	; 0x4f06 <vTaskStartScheduler+0x14c>
    4efe:	d0 93 a4 1a 	sts	0x1AA4, r29	; 0x801aa4 <pxCurrentTCB+0x1>
    4f02:	c0 93 a3 1a 	sts	0x1AA3, r28	; 0x801aa3 <pxCurrentTCB>
    4f06:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <uxTaskNumber>
    4f0a:	8f 5f       	subi	r24, 0xFF	; 255
    4f0c:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <uxTaskNumber>
    4f10:	8e 89       	ldd	r24, Y+22	; 0x16
    4f12:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    4f16:	98 17       	cp	r25, r24
    4f18:	10 f4       	brcc	.+4      	; 0x4f1e <vTaskStartScheduler+0x164>
    4f1a:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    4f1e:	90 e0       	ldi	r25, 0x00	; 0
    4f20:	9c 01       	movw	r18, r24
    4f22:	22 0f       	add	r18, r18
    4f24:	33 1f       	adc	r19, r19
    4f26:	22 0f       	add	r18, r18
    4f28:	33 1f       	adc	r19, r19
    4f2a:	22 0f       	add	r18, r18
    4f2c:	33 1f       	adc	r19, r19
    4f2e:	82 0f       	add	r24, r18
    4f30:	93 1f       	adc	r25, r19
    4f32:	b7 01       	movw	r22, r14
    4f34:	83 59       	subi	r24, 0x93	; 147
    4f36:	95 4e       	sbci	r25, 0xE5	; 229
    4f38:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    4f3c:	0f 90       	pop	r0
    4f3e:	0f be       	out	0x3f, r0	; 63
    4f40:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xSchedulerRunning>
    4f44:	88 23       	and	r24, r24
    4f46:	21 f0       	breq	.+8      	; 0x4f50 <vTaskStartScheduler+0x196>
    4f48:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    4f4c:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    4f50:	f8 94       	cli
    4f52:	8f ef       	ldi	r24, 0xFF	; 255
    4f54:	9f ef       	ldi	r25, 0xFF	; 255
    4f56:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    4f5a:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    4f5e:	81 e0       	ldi	r24, 0x01	; 1
    4f60:	80 93 40 1a 	sts	0x1A40, r24	; 0x801a40 <xSchedulerRunning>
    4f64:	10 92 43 1a 	sts	0x1A43, r1	; 0x801a43 <xTickCount+0x1>
    4f68:	10 92 42 1a 	sts	0x1A42, r1	; 0x801a42 <xTickCount>
    4f6c:	0e 94 11 18 	call	0x3022	; 0x3022 <xPortStartScheduler>
    4f70:	df 91       	pop	r29
    4f72:	cf 91       	pop	r28
    4f74:	1f 91       	pop	r17
    4f76:	0f 91       	pop	r16
    4f78:	ff 90       	pop	r15
    4f7a:	ef 90       	pop	r14
    4f7c:	df 90       	pop	r13
    4f7e:	cf 90       	pop	r12
    4f80:	08 95       	ret

00004f82 <vTaskSuspendAll>:
    4f82:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4f86:	8f 5f       	subi	r24, 0xFF	; 255
    4f88:	80 93 39 1a 	sts	0x1A39, r24	; 0x801a39 <uxSchedulerSuspended>
    4f8c:	08 95       	ret

00004f8e <xTaskResumeAll>:
    4f8e:	9f 92       	push	r9
    4f90:	af 92       	push	r10
    4f92:	bf 92       	push	r11
    4f94:	cf 92       	push	r12
    4f96:	df 92       	push	r13
    4f98:	ef 92       	push	r14
    4f9a:	ff 92       	push	r15
    4f9c:	0f 93       	push	r16
    4f9e:	1f 93       	push	r17
    4fa0:	cf 93       	push	r28
    4fa2:	df 93       	push	r29
    4fa4:	0f b6       	in	r0, 0x3f	; 63
    4fa6:	f8 94       	cli
    4fa8:	0f 92       	push	r0
    4faa:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4fae:	81 50       	subi	r24, 0x01	; 1
    4fb0:	80 93 39 1a 	sts	0x1A39, r24	; 0x801a39 <uxSchedulerSuspended>
    4fb4:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    4fb8:	81 11       	cpse	r24, r1
    4fba:	0d c1       	rjmp	.+538    	; 0x51d6 <xTaskResumeAll+0x248>
    4fbc:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <uxCurrentNumberOfTasks>
    4fc0:	81 11       	cpse	r24, r1
    4fc2:	33 c0       	rjmp	.+102    	; 0x502a <xTaskResumeAll+0x9c>
    4fc4:	0b c1       	rjmp	.+534    	; 0x51dc <xTaskResumeAll+0x24e>
    4fc6:	d7 01       	movw	r26, r14
    4fc8:	15 96       	adiw	r26, 0x05	; 5
    4fca:	ed 91       	ld	r30, X+
    4fcc:	fc 91       	ld	r31, X
    4fce:	16 97       	sbiw	r26, 0x06	; 6
    4fd0:	c6 81       	ldd	r28, Z+6	; 0x06
    4fd2:	d7 81       	ldd	r29, Z+7	; 0x07
    4fd4:	ce 01       	movw	r24, r28
    4fd6:	0c 96       	adiw	r24, 0x0c	; 12
    4fd8:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4fdc:	8e 01       	movw	r16, r28
    4fde:	0e 5f       	subi	r16, 0xFE	; 254
    4fe0:	1f 4f       	sbci	r17, 0xFF	; 255
    4fe2:	c8 01       	movw	r24, r16
    4fe4:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    4fe8:	8e 89       	ldd	r24, Y+22	; 0x16
    4fea:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    4fee:	98 17       	cp	r25, r24
    4ff0:	10 f4       	brcc	.+4      	; 0x4ff6 <xTaskResumeAll+0x68>
    4ff2:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    4ff6:	90 e0       	ldi	r25, 0x00	; 0
    4ff8:	9c 01       	movw	r18, r24
    4ffa:	22 0f       	add	r18, r18
    4ffc:	33 1f       	adc	r19, r19
    4ffe:	22 0f       	add	r18, r18
    5000:	33 1f       	adc	r19, r19
    5002:	22 0f       	add	r18, r18
    5004:	33 1f       	adc	r19, r19
    5006:	82 0f       	add	r24, r18
    5008:	93 1f       	adc	r25, r19
    500a:	b8 01       	movw	r22, r16
    500c:	83 59       	subi	r24, 0x93	; 147
    500e:	95 4e       	sbci	r25, 0xE5	; 229
    5010:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    5014:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5018:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    501c:	9e 89       	ldd	r25, Y+22	; 0x16
    501e:	86 89       	ldd	r24, Z+22	; 0x16
    5020:	98 17       	cp	r25, r24
    5022:	58 f0       	brcs	.+22     	; 0x503a <xTaskResumeAll+0xac>
    5024:	d0 92 3e 1a 	sts	0x1A3E, r13	; 0x801a3e <xYieldPending>
    5028:	08 c0       	rjmp	.+16     	; 0x503a <xTaskResumeAll+0xac>
    502a:	0f 2e       	mov	r0, r31
    502c:	fe e4       	ldi	r31, 0x4E	; 78
    502e:	ef 2e       	mov	r14, r31
    5030:	fa e1       	ldi	r31, 0x1A	; 26
    5032:	ff 2e       	mov	r15, r31
    5034:	f0 2d       	mov	r31, r0
    5036:	dd 24       	eor	r13, r13
    5038:	d3 94       	inc	r13
    503a:	f7 01       	movw	r30, r14
    503c:	80 81       	ld	r24, Z
    503e:	81 11       	cpse	r24, r1
    5040:	c2 cf       	rjmp	.-124    	; 0x4fc6 <xTaskResumeAll+0x38>
    5042:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    5046:	88 23       	and	r24, r24
    5048:	09 f4       	brne	.+2      	; 0x504c <xTaskResumeAll+0xbe>
    504a:	bd c0       	rjmp	.+378    	; 0x51c6 <xTaskResumeAll+0x238>
    504c:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    5050:	88 23       	and	r24, r24
    5052:	09 f4       	brne	.+2      	; 0x5056 <xTaskResumeAll+0xc8>
    5054:	b8 c0       	rjmp	.+368    	; 0x51c6 <xTaskResumeAll+0x238>
    5056:	91 2c       	mov	r9, r1
    5058:	bb 24       	eor	r11, r11
    505a:	b3 94       	inc	r11
    505c:	cc 24       	eor	r12, r12
    505e:	ca 94       	dec	r12
    5060:	dc 2c       	mov	r13, r12
    5062:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    5066:	81 11       	cpse	r24, r1
    5068:	98 c0       	rjmp	.+304    	; 0x519a <xTaskResumeAll+0x20c>
    506a:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    506e:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5072:	01 96       	adiw	r24, 0x01	; 1
    5074:	90 93 43 1a 	sts	0x1A43, r25	; 0x801a43 <xTickCount+0x1>
    5078:	80 93 42 1a 	sts	0x1A42, r24	; 0x801a42 <xTickCount>
    507c:	e0 90 42 1a 	lds	r14, 0x1A42	; 0x801a42 <xTickCount>
    5080:	f0 90 43 1a 	lds	r15, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5084:	e1 14       	cp	r14, r1
    5086:	f1 04       	cpc	r15, r1
    5088:	89 f5       	brne	.+98     	; 0x50ec <xTaskResumeAll+0x15e>
    508a:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    508e:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    5092:	20 91 57 1a 	lds	r18, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    5096:	30 91 58 1a 	lds	r19, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    509a:	30 93 5a 1a 	sts	0x1A5A, r19	; 0x801a5a <pxDelayedTaskList+0x1>
    509e:	20 93 59 1a 	sts	0x1A59, r18	; 0x801a59 <pxDelayedTaskList>
    50a2:	90 93 58 1a 	sts	0x1A58, r25	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    50a6:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <pxOverflowDelayedTaskList>
    50aa:	80 91 3d 1a 	lds	r24, 0x1A3D	; 0x801a3d <xNumOfOverflows>
    50ae:	8f 5f       	subi	r24, 0xFF	; 255
    50b0:	80 93 3d 1a 	sts	0x1A3D, r24	; 0x801a3d <xNumOfOverflows>
    50b4:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    50b8:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    50bc:	80 81       	ld	r24, Z
    50be:	81 11       	cpse	r24, r1
    50c0:	05 c0       	rjmp	.+10     	; 0x50cc <xTaskResumeAll+0x13e>
    50c2:	d0 92 3b 1a 	sts	0x1A3B, r13	; 0x801a3b <xNextTaskUnblockTime+0x1>
    50c6:	c0 92 3a 1a 	sts	0x1A3A, r12	; 0x801a3a <xNextTaskUnblockTime>
    50ca:	10 c0       	rjmp	.+32     	; 0x50ec <xTaskResumeAll+0x15e>
    50cc:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    50d0:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    50d4:	05 80       	ldd	r0, Z+5	; 0x05
    50d6:	f6 81       	ldd	r31, Z+6	; 0x06
    50d8:	e0 2d       	mov	r30, r0
    50da:	06 80       	ldd	r0, Z+6	; 0x06
    50dc:	f7 81       	ldd	r31, Z+7	; 0x07
    50de:	e0 2d       	mov	r30, r0
    50e0:	82 81       	ldd	r24, Z+2	; 0x02
    50e2:	93 81       	ldd	r25, Z+3	; 0x03
    50e4:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    50e8:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    50ec:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    50f0:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    50f4:	e8 16       	cp	r14, r24
    50f6:	f9 06       	cpc	r15, r25
    50f8:	08 f4       	brcc	.+2      	; 0x50fc <xTaskResumeAll+0x16e>
    50fa:	73 c0       	rjmp	.+230    	; 0x51e2 <xTaskResumeAll+0x254>
    50fc:	a9 2c       	mov	r10, r9
    50fe:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    5102:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    5106:	80 81       	ld	r24, Z
    5108:	81 11       	cpse	r24, r1
    510a:	05 c0       	rjmp	.+10     	; 0x5116 <xTaskResumeAll+0x188>
    510c:	d0 92 3b 1a 	sts	0x1A3B, r13	; 0x801a3b <xNextTaskUnblockTime+0x1>
    5110:	c0 92 3a 1a 	sts	0x1A3A, r12	; 0x801a3a <xNextTaskUnblockTime>
    5114:	48 c0       	rjmp	.+144    	; 0x51a6 <xTaskResumeAll+0x218>
    5116:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    511a:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    511e:	05 80       	ldd	r0, Z+5	; 0x05
    5120:	f6 81       	ldd	r31, Z+6	; 0x06
    5122:	e0 2d       	mov	r30, r0
    5124:	c6 81       	ldd	r28, Z+6	; 0x06
    5126:	d7 81       	ldd	r29, Z+7	; 0x07
    5128:	8a 81       	ldd	r24, Y+2	; 0x02
    512a:	9b 81       	ldd	r25, Y+3	; 0x03
    512c:	e8 16       	cp	r14, r24
    512e:	f9 06       	cpc	r15, r25
    5130:	28 f4       	brcc	.+10     	; 0x513c <xTaskResumeAll+0x1ae>
    5132:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    5136:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    513a:	35 c0       	rjmp	.+106    	; 0x51a6 <xTaskResumeAll+0x218>
    513c:	8e 01       	movw	r16, r28
    513e:	0e 5f       	subi	r16, 0xFE	; 254
    5140:	1f 4f       	sbci	r17, 0xFF	; 255
    5142:	c8 01       	movw	r24, r16
    5144:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5148:	8c 89       	ldd	r24, Y+20	; 0x14
    514a:	9d 89       	ldd	r25, Y+21	; 0x15
    514c:	89 2b       	or	r24, r25
    514e:	21 f0       	breq	.+8      	; 0x5158 <xTaskResumeAll+0x1ca>
    5150:	ce 01       	movw	r24, r28
    5152:	0c 96       	adiw	r24, 0x0c	; 12
    5154:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5158:	8e 89       	ldd	r24, Y+22	; 0x16
    515a:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    515e:	98 17       	cp	r25, r24
    5160:	10 f4       	brcc	.+4      	; 0x5166 <xTaskResumeAll+0x1d8>
    5162:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    5166:	90 e0       	ldi	r25, 0x00	; 0
    5168:	9c 01       	movw	r18, r24
    516a:	22 0f       	add	r18, r18
    516c:	33 1f       	adc	r19, r19
    516e:	22 0f       	add	r18, r18
    5170:	33 1f       	adc	r19, r19
    5172:	22 0f       	add	r18, r18
    5174:	33 1f       	adc	r19, r19
    5176:	82 0f       	add	r24, r18
    5178:	93 1f       	adc	r25, r19
    517a:	b8 01       	movw	r22, r16
    517c:	83 59       	subi	r24, 0x93	; 147
    517e:	95 4e       	sbci	r25, 0xE5	; 229
    5180:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    5184:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5188:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    518c:	9e 89       	ldd	r25, Y+22	; 0x16
    518e:	86 89       	ldd	r24, Z+22	; 0x16
    5190:	98 17       	cp	r25, r24
    5192:	08 f4       	brcc	.+2      	; 0x5196 <xTaskResumeAll+0x208>
    5194:	b4 cf       	rjmp	.-152    	; 0x50fe <xTaskResumeAll+0x170>
    5196:	ab 2c       	mov	r10, r11
    5198:	b2 cf       	rjmp	.-156    	; 0x50fe <xTaskResumeAll+0x170>
    519a:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    519e:	8f 5f       	subi	r24, 0xFF	; 255
    51a0:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <uxPendedTicks>
    51a4:	1e c0       	rjmp	.+60     	; 0x51e2 <xTaskResumeAll+0x254>
    51a6:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    51aa:	81 11       	cpse	r24, r1
    51ac:	01 c0       	rjmp	.+2      	; 0x51b0 <xTaskResumeAll+0x222>
    51ae:	a1 10       	cpse	r10, r1
    51b0:	b0 92 3e 1a 	sts	0x1A3E, r11	; 0x801a3e <xYieldPending>
    51b4:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    51b8:	81 50       	subi	r24, 0x01	; 1
    51ba:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <uxPendedTicks>
    51be:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    51c2:	81 11       	cpse	r24, r1
    51c4:	4e cf       	rjmp	.-356    	; 0x5062 <xTaskResumeAll+0xd4>
    51c6:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    51ca:	81 30       	cpi	r24, 0x01	; 1
    51cc:	31 f4       	brne	.+12     	; 0x51da <xTaskResumeAll+0x24c>
    51ce:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    51d2:	81 e0       	ldi	r24, 0x01	; 1
    51d4:	03 c0       	rjmp	.+6      	; 0x51dc <xTaskResumeAll+0x24e>
    51d6:	80 e0       	ldi	r24, 0x00	; 0
    51d8:	01 c0       	rjmp	.+2      	; 0x51dc <xTaskResumeAll+0x24e>
    51da:	80 e0       	ldi	r24, 0x00	; 0
    51dc:	0f 90       	pop	r0
    51de:	0f be       	out	0x3f, r0	; 63
    51e0:	05 c0       	rjmp	.+10     	; 0x51ec <xTaskResumeAll+0x25e>
    51e2:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    51e6:	81 11       	cpse	r24, r1
    51e8:	e3 cf       	rjmp	.-58     	; 0x51b0 <xTaskResumeAll+0x222>
    51ea:	e4 cf       	rjmp	.-56     	; 0x51b4 <xTaskResumeAll+0x226>
    51ec:	df 91       	pop	r29
    51ee:	cf 91       	pop	r28
    51f0:	1f 91       	pop	r17
    51f2:	0f 91       	pop	r16
    51f4:	ff 90       	pop	r15
    51f6:	ef 90       	pop	r14
    51f8:	df 90       	pop	r13
    51fa:	cf 90       	pop	r12
    51fc:	bf 90       	pop	r11
    51fe:	af 90       	pop	r10
    5200:	9f 90       	pop	r9
    5202:	08 95       	ret

00005204 <xTaskGetTickCount>:
    5204:	0f b6       	in	r0, 0x3f	; 63
    5206:	f8 94       	cli
    5208:	0f 92       	push	r0
    520a:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    520e:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5212:	0f 90       	pop	r0
    5214:	0f be       	out	0x3f, r0	; 63
    5216:	08 95       	ret

00005218 <xTaskIncrementTick>:
    5218:	cf 92       	push	r12
    521a:	df 92       	push	r13
    521c:	ef 92       	push	r14
    521e:	ff 92       	push	r15
    5220:	0f 93       	push	r16
    5222:	1f 93       	push	r17
    5224:	cf 93       	push	r28
    5226:	df 93       	push	r29
    5228:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    522c:	81 11       	cpse	r24, r1
    522e:	9f c0       	rjmp	.+318    	; 0x536e <xTaskIncrementTick+0x156>
    5230:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    5234:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5238:	01 96       	adiw	r24, 0x01	; 1
    523a:	90 93 43 1a 	sts	0x1A43, r25	; 0x801a43 <xTickCount+0x1>
    523e:	80 93 42 1a 	sts	0x1A42, r24	; 0x801a42 <xTickCount>
    5242:	e0 90 42 1a 	lds	r14, 0x1A42	; 0x801a42 <xTickCount>
    5246:	f0 90 43 1a 	lds	r15, 0x1A43	; 0x801a43 <xTickCount+0x1>
    524a:	e1 14       	cp	r14, r1
    524c:	f1 04       	cpc	r15, r1
    524e:	99 f5       	brne	.+102    	; 0x52b6 <xTaskIncrementTick+0x9e>
    5250:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    5254:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    5258:	20 91 57 1a 	lds	r18, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    525c:	30 91 58 1a 	lds	r19, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    5260:	30 93 5a 1a 	sts	0x1A5A, r19	; 0x801a5a <pxDelayedTaskList+0x1>
    5264:	20 93 59 1a 	sts	0x1A59, r18	; 0x801a59 <pxDelayedTaskList>
    5268:	90 93 58 1a 	sts	0x1A58, r25	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    526c:	80 93 57 1a 	sts	0x1A57, r24	; 0x801a57 <pxOverflowDelayedTaskList>
    5270:	80 91 3d 1a 	lds	r24, 0x1A3D	; 0x801a3d <xNumOfOverflows>
    5274:	8f 5f       	subi	r24, 0xFF	; 255
    5276:	80 93 3d 1a 	sts	0x1A3D, r24	; 0x801a3d <xNumOfOverflows>
    527a:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    527e:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    5282:	80 81       	ld	r24, Z
    5284:	81 11       	cpse	r24, r1
    5286:	07 c0       	rjmp	.+14     	; 0x5296 <xTaskIncrementTick+0x7e>
    5288:	8f ef       	ldi	r24, 0xFF	; 255
    528a:	9f ef       	ldi	r25, 0xFF	; 255
    528c:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    5290:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    5294:	10 c0       	rjmp	.+32     	; 0x52b6 <xTaskIncrementTick+0x9e>
    5296:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    529a:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    529e:	05 80       	ldd	r0, Z+5	; 0x05
    52a0:	f6 81       	ldd	r31, Z+6	; 0x06
    52a2:	e0 2d       	mov	r30, r0
    52a4:	06 80       	ldd	r0, Z+6	; 0x06
    52a6:	f7 81       	ldd	r31, Z+7	; 0x07
    52a8:	e0 2d       	mov	r30, r0
    52aa:	82 81       	ldd	r24, Z+2	; 0x02
    52ac:	93 81       	ldd	r25, Z+3	; 0x03
    52ae:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    52b2:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    52b6:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    52ba:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    52be:	e8 16       	cp	r14, r24
    52c0:	f9 06       	cpc	r15, r25
    52c2:	10 f4       	brcc	.+4      	; 0x52c8 <xTaskIncrementTick+0xb0>
    52c4:	d1 2c       	mov	r13, r1
    52c6:	59 c0       	rjmp	.+178    	; 0x537a <xTaskIncrementTick+0x162>
    52c8:	d1 2c       	mov	r13, r1
    52ca:	cc 24       	eor	r12, r12
    52cc:	c3 94       	inc	r12
    52ce:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    52d2:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    52d6:	80 81       	ld	r24, Z
    52d8:	81 11       	cpse	r24, r1
    52da:	07 c0       	rjmp	.+14     	; 0x52ea <xTaskIncrementTick+0xd2>
    52dc:	8f ef       	ldi	r24, 0xFF	; 255
    52de:	9f ef       	ldi	r25, 0xFF	; 255
    52e0:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    52e4:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    52e8:	48 c0       	rjmp	.+144    	; 0x537a <xTaskIncrementTick+0x162>
    52ea:	e0 91 59 1a 	lds	r30, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    52ee:	f0 91 5a 1a 	lds	r31, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    52f2:	05 80       	ldd	r0, Z+5	; 0x05
    52f4:	f6 81       	ldd	r31, Z+6	; 0x06
    52f6:	e0 2d       	mov	r30, r0
    52f8:	c6 81       	ldd	r28, Z+6	; 0x06
    52fa:	d7 81       	ldd	r29, Z+7	; 0x07
    52fc:	8a 81       	ldd	r24, Y+2	; 0x02
    52fe:	9b 81       	ldd	r25, Y+3	; 0x03
    5300:	e8 16       	cp	r14, r24
    5302:	f9 06       	cpc	r15, r25
    5304:	28 f4       	brcc	.+10     	; 0x5310 <xTaskIncrementTick+0xf8>
    5306:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <xNextTaskUnblockTime+0x1>
    530a:	80 93 3a 1a 	sts	0x1A3A, r24	; 0x801a3a <xNextTaskUnblockTime>
    530e:	35 c0       	rjmp	.+106    	; 0x537a <xTaskIncrementTick+0x162>
    5310:	8e 01       	movw	r16, r28
    5312:	0e 5f       	subi	r16, 0xFE	; 254
    5314:	1f 4f       	sbci	r17, 0xFF	; 255
    5316:	c8 01       	movw	r24, r16
    5318:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    531c:	8c 89       	ldd	r24, Y+20	; 0x14
    531e:	9d 89       	ldd	r25, Y+21	; 0x15
    5320:	89 2b       	or	r24, r25
    5322:	21 f0       	breq	.+8      	; 0x532c <xTaskIncrementTick+0x114>
    5324:	ce 01       	movw	r24, r28
    5326:	0c 96       	adiw	r24, 0x0c	; 12
    5328:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    532c:	8e 89       	ldd	r24, Y+22	; 0x16
    532e:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    5332:	98 17       	cp	r25, r24
    5334:	10 f4       	brcc	.+4      	; 0x533a <xTaskIncrementTick+0x122>
    5336:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    533a:	90 e0       	ldi	r25, 0x00	; 0
    533c:	9c 01       	movw	r18, r24
    533e:	22 0f       	add	r18, r18
    5340:	33 1f       	adc	r19, r19
    5342:	22 0f       	add	r18, r18
    5344:	33 1f       	adc	r19, r19
    5346:	22 0f       	add	r18, r18
    5348:	33 1f       	adc	r19, r19
    534a:	82 0f       	add	r24, r18
    534c:	93 1f       	adc	r25, r19
    534e:	b8 01       	movw	r22, r16
    5350:	83 59       	subi	r24, 0x93	; 147
    5352:	95 4e       	sbci	r25, 0xE5	; 229
    5354:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    5358:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    535c:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5360:	9e 89       	ldd	r25, Y+22	; 0x16
    5362:	86 89       	ldd	r24, Z+22	; 0x16
    5364:	98 17       	cp	r25, r24
    5366:	08 f4       	brcc	.+2      	; 0x536a <xTaskIncrementTick+0x152>
    5368:	b2 cf       	rjmp	.-156    	; 0x52ce <xTaskIncrementTick+0xb6>
    536a:	dc 2c       	mov	r13, r12
    536c:	b0 cf       	rjmp	.-160    	; 0x52ce <xTaskIncrementTick+0xb6>
    536e:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <uxPendedTicks>
    5372:	8f 5f       	subi	r24, 0xFF	; 255
    5374:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <uxPendedTicks>
    5378:	d1 2c       	mov	r13, r1
    537a:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <xYieldPending>
    537e:	88 23       	and	r24, r24
    5380:	11 f0       	breq	.+4      	; 0x5386 <xTaskIncrementTick+0x16e>
    5382:	dd 24       	eor	r13, r13
    5384:	d3 94       	inc	r13
    5386:	8d 2d       	mov	r24, r13
    5388:	df 91       	pop	r29
    538a:	cf 91       	pop	r28
    538c:	1f 91       	pop	r17
    538e:	0f 91       	pop	r16
    5390:	ff 90       	pop	r15
    5392:	ef 90       	pop	r14
    5394:	df 90       	pop	r13
    5396:	cf 90       	pop	r12
    5398:	08 95       	ret

0000539a <vTaskSwitchContext>:
    539a:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    539e:	88 23       	and	r24, r24
    53a0:	21 f0       	breq	.+8      	; 0x53aa <vTaskSwitchContext+0x10>
    53a2:	81 e0       	ldi	r24, 0x01	; 1
    53a4:	80 93 3e 1a 	sts	0x1A3E, r24	; 0x801a3e <xYieldPending>
    53a8:	08 95       	ret
    53aa:	10 92 3e 1a 	sts	0x1A3E, r1	; 0x801a3e <xYieldPending>
    53ae:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    53b2:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    53b6:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    53ba:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    53be:	2d 91       	ld	r18, X+
    53c0:	3c 91       	ld	r19, X
    53c2:	87 89       	ldd	r24, Z+23	; 0x17
    53c4:	90 8d       	ldd	r25, Z+24	; 0x18
    53c6:	82 17       	cp	r24, r18
    53c8:	93 07       	cpc	r25, r19
    53ca:	60 f0       	brcs	.+24     	; 0x53e4 <vTaskSwitchContext+0x4a>
    53cc:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    53d0:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    53d4:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    53d8:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    53dc:	67 5e       	subi	r22, 0xE7	; 231
    53de:	7f 4f       	sbci	r23, 0xFF	; 255
    53e0:	0e 94 ba 14 	call	0x2974	; 0x2974 <vApplicationStackOverflowHook>
    53e4:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    53e8:	90 e0       	ldi	r25, 0x00	; 0
    53ea:	fc 01       	movw	r30, r24
    53ec:	ee 0f       	add	r30, r30
    53ee:	ff 1f       	adc	r31, r31
    53f0:	ee 0f       	add	r30, r30
    53f2:	ff 1f       	adc	r31, r31
    53f4:	ee 0f       	add	r30, r30
    53f6:	ff 1f       	adc	r31, r31
    53f8:	8e 0f       	add	r24, r30
    53fa:	9f 1f       	adc	r25, r31
    53fc:	fc 01       	movw	r30, r24
    53fe:	e3 59       	subi	r30, 0x93	; 147
    5400:	f5 4e       	sbci	r31, 0xE5	; 229
    5402:	80 81       	ld	r24, Z
    5404:	81 11       	cpse	r24, r1
    5406:	17 c0       	rjmp	.+46     	; 0x5436 <vTaskSwitchContext+0x9c>
    5408:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    540c:	81 50       	subi	r24, 0x01	; 1
    540e:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    5412:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    5416:	90 e0       	ldi	r25, 0x00	; 0
    5418:	fc 01       	movw	r30, r24
    541a:	ee 0f       	add	r30, r30
    541c:	ff 1f       	adc	r31, r31
    541e:	ee 0f       	add	r30, r30
    5420:	ff 1f       	adc	r31, r31
    5422:	ee 0f       	add	r30, r30
    5424:	ff 1f       	adc	r31, r31
    5426:	8e 0f       	add	r24, r30
    5428:	9f 1f       	adc	r25, r31
    542a:	fc 01       	movw	r30, r24
    542c:	e3 59       	subi	r30, 0x93	; 147
    542e:	f5 4e       	sbci	r31, 0xE5	; 229
    5430:	80 81       	ld	r24, Z
    5432:	88 23       	and	r24, r24
    5434:	49 f3       	breq	.-46     	; 0x5408 <vTaskSwitchContext+0x6e>
    5436:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    543a:	90 e0       	ldi	r25, 0x00	; 0
    543c:	9c 01       	movw	r18, r24
    543e:	22 0f       	add	r18, r18
    5440:	33 1f       	adc	r19, r19
    5442:	22 0f       	add	r18, r18
    5444:	33 1f       	adc	r19, r19
    5446:	22 0f       	add	r18, r18
    5448:	33 1f       	adc	r19, r19
    544a:	28 0f       	add	r18, r24
    544c:	39 1f       	adc	r19, r25
    544e:	d9 01       	movw	r26, r18
    5450:	a3 59       	subi	r26, 0x93	; 147
    5452:	b5 4e       	sbci	r27, 0xE5	; 229
    5454:	11 96       	adiw	r26, 0x01	; 1
    5456:	ed 91       	ld	r30, X+
    5458:	fc 91       	ld	r31, X
    545a:	12 97       	sbiw	r26, 0x02	; 2
    545c:	02 80       	ldd	r0, Z+2	; 0x02
    545e:	f3 81       	ldd	r31, Z+3	; 0x03
    5460:	e0 2d       	mov	r30, r0
    5462:	12 96       	adiw	r26, 0x02	; 2
    5464:	fc 93       	st	X, r31
    5466:	ee 93       	st	-X, r30
    5468:	11 97       	sbiw	r26, 0x01	; 1
    546a:	20 59       	subi	r18, 0x90	; 144
    546c:	35 4e       	sbci	r19, 0xE5	; 229
    546e:	e2 17       	cp	r30, r18
    5470:	f3 07       	cpc	r31, r19
    5472:	29 f4       	brne	.+10     	; 0x547e <vTaskSwitchContext+0xe4>
    5474:	22 81       	ldd	r18, Z+2	; 0x02
    5476:	33 81       	ldd	r19, Z+3	; 0x03
    5478:	fd 01       	movw	r30, r26
    547a:	32 83       	std	Z+2, r19	; 0x02
    547c:	21 83       	std	Z+1, r18	; 0x01
    547e:	fc 01       	movw	r30, r24
    5480:	ee 0f       	add	r30, r30
    5482:	ff 1f       	adc	r31, r31
    5484:	ee 0f       	add	r30, r30
    5486:	ff 1f       	adc	r31, r31
    5488:	ee 0f       	add	r30, r30
    548a:	ff 1f       	adc	r31, r31
    548c:	8e 0f       	add	r24, r30
    548e:	9f 1f       	adc	r25, r31
    5490:	fc 01       	movw	r30, r24
    5492:	e3 59       	subi	r30, 0x93	; 147
    5494:	f5 4e       	sbci	r31, 0xE5	; 229
    5496:	01 80       	ldd	r0, Z+1	; 0x01
    5498:	f2 81       	ldd	r31, Z+2	; 0x02
    549a:	e0 2d       	mov	r30, r0
    549c:	86 81       	ldd	r24, Z+6	; 0x06
    549e:	97 81       	ldd	r25, Z+7	; 0x07
    54a0:	90 93 a4 1a 	sts	0x1AA4, r25	; 0x801aa4 <pxCurrentTCB+0x1>
    54a4:	80 93 a3 1a 	sts	0x1AA3, r24	; 0x801aa3 <pxCurrentTCB>
    54a8:	08 95       	ret

000054aa <vTaskPlaceOnEventList>:
    54aa:	cf 93       	push	r28
    54ac:	df 93       	push	r29
    54ae:	eb 01       	movw	r28, r22
    54b0:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    54b4:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    54b8:	64 5f       	subi	r22, 0xF4	; 244
    54ba:	7f 4f       	sbci	r23, 0xFF	; 255
    54bc:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    54c0:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    54c4:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    54c8:	02 96       	adiw	r24, 0x02	; 2
    54ca:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    54ce:	cf 3f       	cpi	r28, 0xFF	; 255
    54d0:	8f ef       	ldi	r24, 0xFF	; 255
    54d2:	d8 07       	cpc	r29, r24
    54d4:	59 f4       	brne	.+22     	; 0x54ec <vTaskPlaceOnEventList+0x42>
    54d6:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    54da:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    54de:	6e 5f       	subi	r22, 0xFE	; 254
    54e0:	7f 4f       	sbci	r23, 0xFF	; 255
    54e2:	85 e4       	ldi	r24, 0x45	; 69
    54e4:	9a e1       	ldi	r25, 0x1A	; 26
    54e6:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    54ea:	37 c0       	rjmp	.+110    	; 0x555a <vTaskPlaceOnEventList+0xb0>
    54ec:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    54f0:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    54f4:	c8 0f       	add	r28, r24
    54f6:	d9 1f       	adc	r29, r25
    54f8:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    54fc:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5500:	d3 83       	std	Z+3, r29	; 0x03
    5502:	c2 83       	std	Z+2, r28	; 0x02
    5504:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    5508:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    550c:	c8 17       	cp	r28, r24
    550e:	d9 07       	cpc	r29, r25
    5510:	68 f4       	brcc	.+26     	; 0x552c <vTaskPlaceOnEventList+0x82>
    5512:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5516:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    551a:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    551e:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    5522:	6e 5f       	subi	r22, 0xFE	; 254
    5524:	7f 4f       	sbci	r23, 0xFF	; 255
    5526:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    552a:	17 c0       	rjmp	.+46     	; 0x555a <vTaskPlaceOnEventList+0xb0>
    552c:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5530:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5534:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    5538:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    553c:	6e 5f       	subi	r22, 0xFE	; 254
    553e:	7f 4f       	sbci	r23, 0xFF	; 255
    5540:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    5544:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    5548:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    554c:	c8 17       	cp	r28, r24
    554e:	d9 07       	cpc	r29, r25
    5550:	20 f4       	brcc	.+8      	; 0x555a <vTaskPlaceOnEventList+0xb0>
    5552:	d0 93 3b 1a 	sts	0x1A3B, r29	; 0x801a3b <xNextTaskUnblockTime+0x1>
    5556:	c0 93 3a 1a 	sts	0x1A3A, r28	; 0x801a3a <xNextTaskUnblockTime>
    555a:	df 91       	pop	r29
    555c:	cf 91       	pop	r28
    555e:	08 95       	ret

00005560 <xTaskRemoveFromEventList>:
    5560:	0f 93       	push	r16
    5562:	1f 93       	push	r17
    5564:	cf 93       	push	r28
    5566:	df 93       	push	r29
    5568:	dc 01       	movw	r26, r24
    556a:	15 96       	adiw	r26, 0x05	; 5
    556c:	ed 91       	ld	r30, X+
    556e:	fc 91       	ld	r31, X
    5570:	16 97       	sbiw	r26, 0x06	; 6
    5572:	c6 81       	ldd	r28, Z+6	; 0x06
    5574:	d7 81       	ldd	r29, Z+7	; 0x07
    5576:	8e 01       	movw	r16, r28
    5578:	04 5f       	subi	r16, 0xF4	; 244
    557a:	1f 4f       	sbci	r17, 0xFF	; 255
    557c:	c8 01       	movw	r24, r16
    557e:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5582:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    5586:	81 11       	cpse	r24, r1
    5588:	1c c0       	rjmp	.+56     	; 0x55c2 <xTaskRemoveFromEventList+0x62>
    558a:	0a 50       	subi	r16, 0x0A	; 10
    558c:	11 09       	sbc	r17, r1
    558e:	c8 01       	movw	r24, r16
    5590:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5594:	8e 89       	ldd	r24, Y+22	; 0x16
    5596:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    559a:	98 17       	cp	r25, r24
    559c:	10 f4       	brcc	.+4      	; 0x55a2 <xTaskRemoveFromEventList+0x42>
    559e:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    55a2:	90 e0       	ldi	r25, 0x00	; 0
    55a4:	9c 01       	movw	r18, r24
    55a6:	22 0f       	add	r18, r18
    55a8:	33 1f       	adc	r19, r19
    55aa:	22 0f       	add	r18, r18
    55ac:	33 1f       	adc	r19, r19
    55ae:	22 0f       	add	r18, r18
    55b0:	33 1f       	adc	r19, r19
    55b2:	82 0f       	add	r24, r18
    55b4:	93 1f       	adc	r25, r19
    55b6:	b8 01       	movw	r22, r16
    55b8:	83 59       	subi	r24, 0x93	; 147
    55ba:	95 4e       	sbci	r25, 0xE5	; 229
    55bc:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    55c0:	05 c0       	rjmp	.+10     	; 0x55cc <xTaskRemoveFromEventList+0x6c>
    55c2:	b8 01       	movw	r22, r16
    55c4:	8e e4       	ldi	r24, 0x4E	; 78
    55c6:	9a e1       	ldi	r25, 0x1A	; 26
    55c8:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    55cc:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    55d0:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    55d4:	9e 89       	ldd	r25, Y+22	; 0x16
    55d6:	86 89       	ldd	r24, Z+22	; 0x16
    55d8:	89 17       	cp	r24, r25
    55da:	20 f4       	brcc	.+8      	; 0x55e4 <xTaskRemoveFromEventList+0x84>
    55dc:	81 e0       	ldi	r24, 0x01	; 1
    55de:	80 93 3e 1a 	sts	0x1A3E, r24	; 0x801a3e <xYieldPending>
    55e2:	01 c0       	rjmp	.+2      	; 0x55e6 <xTaskRemoveFromEventList+0x86>
    55e4:	80 e0       	ldi	r24, 0x00	; 0
    55e6:	df 91       	pop	r29
    55e8:	cf 91       	pop	r28
    55ea:	1f 91       	pop	r17
    55ec:	0f 91       	pop	r16
    55ee:	08 95       	ret

000055f0 <vTaskSetTimeOutState>:
    55f0:	20 91 3d 1a 	lds	r18, 0x1A3D	; 0x801a3d <xNumOfOverflows>
    55f4:	fc 01       	movw	r30, r24
    55f6:	20 83       	st	Z, r18
    55f8:	20 91 42 1a 	lds	r18, 0x1A42	; 0x801a42 <xTickCount>
    55fc:	30 91 43 1a 	lds	r19, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5600:	32 83       	std	Z+2, r19	; 0x02
    5602:	21 83       	std	Z+1, r18	; 0x01
    5604:	08 95       	ret

00005606 <xTaskCheckForTimeOut>:
    5606:	fc 01       	movw	r30, r24
    5608:	0f b6       	in	r0, 0x3f	; 63
    560a:	f8 94       	cli
    560c:	0f 92       	push	r0
    560e:	20 91 42 1a 	lds	r18, 0x1A42	; 0x801a42 <xTickCount>
    5612:	30 91 43 1a 	lds	r19, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5616:	db 01       	movw	r26, r22
    5618:	8d 91       	ld	r24, X+
    561a:	9c 91       	ld	r25, X
    561c:	8f 3f       	cpi	r24, 0xFF	; 255
    561e:	bf ef       	ldi	r27, 0xFF	; 255
    5620:	9b 07       	cpc	r25, r27
    5622:	21 f1       	breq	.+72     	; 0x566c <xTaskCheckForTimeOut+0x66>
    5624:	40 91 3d 1a 	lds	r20, 0x1A3D	; 0x801a3d <xNumOfOverflows>
    5628:	50 81       	ld	r21, Z
    562a:	54 17       	cp	r21, r20
    562c:	29 f0       	breq	.+10     	; 0x5638 <xTaskCheckForTimeOut+0x32>
    562e:	41 81       	ldd	r20, Z+1	; 0x01
    5630:	52 81       	ldd	r21, Z+2	; 0x02
    5632:	24 17       	cp	r18, r20
    5634:	35 07       	cpc	r19, r21
    5636:	e0 f4       	brcc	.+56     	; 0x5670 <xTaskCheckForTimeOut+0x6a>
    5638:	41 81       	ldd	r20, Z+1	; 0x01
    563a:	52 81       	ldd	r21, Z+2	; 0x02
    563c:	d9 01       	movw	r26, r18
    563e:	a4 1b       	sub	r26, r20
    5640:	b5 0b       	sbc	r27, r21
    5642:	a8 17       	cp	r26, r24
    5644:	b9 07       	cpc	r27, r25
    5646:	b0 f4       	brcc	.+44     	; 0x5674 <xTaskCheckForTimeOut+0x6e>
    5648:	42 1b       	sub	r20, r18
    564a:	53 0b       	sbc	r21, r19
    564c:	84 0f       	add	r24, r20
    564e:	95 1f       	adc	r25, r21
    5650:	db 01       	movw	r26, r22
    5652:	8d 93       	st	X+, r24
    5654:	9c 93       	st	X, r25
    5656:	80 91 3d 1a 	lds	r24, 0x1A3D	; 0x801a3d <xNumOfOverflows>
    565a:	80 83       	st	Z, r24
    565c:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    5660:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5664:	92 83       	std	Z+2, r25	; 0x02
    5666:	81 83       	std	Z+1, r24	; 0x01
    5668:	80 e0       	ldi	r24, 0x00	; 0
    566a:	05 c0       	rjmp	.+10     	; 0x5676 <xTaskCheckForTimeOut+0x70>
    566c:	80 e0       	ldi	r24, 0x00	; 0
    566e:	03 c0       	rjmp	.+6      	; 0x5676 <xTaskCheckForTimeOut+0x70>
    5670:	81 e0       	ldi	r24, 0x01	; 1
    5672:	01 c0       	rjmp	.+2      	; 0x5676 <xTaskCheckForTimeOut+0x70>
    5674:	81 e0       	ldi	r24, 0x01	; 1
    5676:	0f 90       	pop	r0
    5678:	0f be       	out	0x3f, r0	; 63
    567a:	08 95       	ret

0000567c <vTaskMissedYield>:
    567c:	81 e0       	ldi	r24, 0x01	; 1
    567e:	80 93 3e 1a 	sts	0x1A3E, r24	; 0x801a3e <xYieldPending>
    5682:	08 95       	ret

00005684 <xTaskGetCurrentTaskHandle>:
    5684:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5688:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    568c:	08 95       	ret

0000568e <vTaskPriorityInherit>:
    568e:	0f 93       	push	r16
    5690:	1f 93       	push	r17
    5692:	cf 93       	push	r28
    5694:	df 93       	push	r29
    5696:	fc 01       	movw	r30, r24
    5698:	89 2b       	or	r24, r25
    569a:	09 f4       	brne	.+2      	; 0x569e <vTaskPriorityInherit+0x10>
    569c:	55 c0       	rjmp	.+170    	; 0x5748 <vTaskPriorityInherit+0xba>
    569e:	26 89       	ldd	r18, Z+22	; 0x16
    56a0:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    56a4:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    56a8:	56 96       	adiw	r26, 0x16	; 22
    56aa:	8c 91       	ld	r24, X
    56ac:	28 17       	cp	r18, r24
    56ae:	08 f0       	brcs	.+2      	; 0x56b2 <vTaskPriorityInherit+0x24>
    56b0:	4b c0       	rjmp	.+150    	; 0x5748 <vTaskPriorityInherit+0xba>
    56b2:	84 85       	ldd	r24, Z+12	; 0x0c
    56b4:	95 85       	ldd	r25, Z+13	; 0x0d
    56b6:	99 23       	and	r25, r25
    56b8:	64 f0       	brlt	.+24     	; 0x56d2 <vTaskPriorityInherit+0x44>
    56ba:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    56be:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    56c2:	56 96       	adiw	r26, 0x16	; 22
    56c4:	3c 91       	ld	r19, X
    56c6:	86 e0       	ldi	r24, 0x06	; 6
    56c8:	90 e0       	ldi	r25, 0x00	; 0
    56ca:	83 1b       	sub	r24, r19
    56cc:	91 09       	sbc	r25, r1
    56ce:	95 87       	std	Z+13, r25	; 0x0d
    56d0:	84 87       	std	Z+12, r24	; 0x0c
    56d2:	30 e0       	ldi	r19, 0x00	; 0
    56d4:	c9 01       	movw	r24, r18
    56d6:	88 0f       	add	r24, r24
    56d8:	99 1f       	adc	r25, r25
    56da:	88 0f       	add	r24, r24
    56dc:	99 1f       	adc	r25, r25
    56de:	88 0f       	add	r24, r24
    56e0:	99 1f       	adc	r25, r25
    56e2:	28 0f       	add	r18, r24
    56e4:	39 1f       	adc	r19, r25
    56e6:	23 59       	subi	r18, 0x93	; 147
    56e8:	35 4e       	sbci	r19, 0xE5	; 229
    56ea:	82 85       	ldd	r24, Z+10	; 0x0a
    56ec:	93 85       	ldd	r25, Z+11	; 0x0b
    56ee:	82 17       	cp	r24, r18
    56f0:	93 07       	cpc	r25, r19
    56f2:	19 f5       	brne	.+70     	; 0x573a <vTaskPriorityInherit+0xac>
    56f4:	8f 01       	movw	r16, r30
    56f6:	ef 01       	movw	r28, r30
    56f8:	22 96       	adiw	r28, 0x02	; 2
    56fa:	ce 01       	movw	r24, r28
    56fc:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5700:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5704:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5708:	86 89       	ldd	r24, Z+22	; 0x16
    570a:	f8 01       	movw	r30, r16
    570c:	86 8b       	std	Z+22, r24	; 0x16
    570e:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    5712:	98 17       	cp	r25, r24
    5714:	10 f4       	brcc	.+4      	; 0x571a <vTaskPriorityInherit+0x8c>
    5716:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    571a:	90 e0       	ldi	r25, 0x00	; 0
    571c:	9c 01       	movw	r18, r24
    571e:	22 0f       	add	r18, r18
    5720:	33 1f       	adc	r19, r19
    5722:	22 0f       	add	r18, r18
    5724:	33 1f       	adc	r19, r19
    5726:	22 0f       	add	r18, r18
    5728:	33 1f       	adc	r19, r19
    572a:	82 0f       	add	r24, r18
    572c:	93 1f       	adc	r25, r19
    572e:	be 01       	movw	r22, r28
    5730:	83 59       	subi	r24, 0x93	; 147
    5732:	95 4e       	sbci	r25, 0xE5	; 229
    5734:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    5738:	07 c0       	rjmp	.+14     	; 0x5748 <vTaskPriorityInherit+0xba>
    573a:	a0 91 a3 1a 	lds	r26, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    573e:	b0 91 a4 1a 	lds	r27, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5742:	56 96       	adiw	r26, 0x16	; 22
    5744:	8c 91       	ld	r24, X
    5746:	86 8b       	std	Z+22, r24	; 0x16
    5748:	df 91       	pop	r29
    574a:	cf 91       	pop	r28
    574c:	1f 91       	pop	r17
    574e:	0f 91       	pop	r16
    5750:	08 95       	ret

00005752 <xTaskPriorityDisinherit>:
    5752:	0f 93       	push	r16
    5754:	1f 93       	push	r17
    5756:	cf 93       	push	r28
    5758:	df 93       	push	r29
    575a:	fc 01       	movw	r30, r24
    575c:	89 2b       	or	r24, r25
    575e:	79 f1       	breq	.+94     	; 0x57be <xTaskPriorityDisinherit+0x6c>
    5760:	82 a1       	ldd	r24, Z+34	; 0x22
    5762:	81 50       	subi	r24, 0x01	; 1
    5764:	82 a3       	std	Z+34, r24	; 0x22
    5766:	26 89       	ldd	r18, Z+22	; 0x16
    5768:	91 a1       	ldd	r25, Z+33	; 0x21
    576a:	29 17       	cp	r18, r25
    576c:	51 f1       	breq	.+84     	; 0x57c2 <xTaskPriorityDisinherit+0x70>
    576e:	81 11       	cpse	r24, r1
    5770:	2a c0       	rjmp	.+84     	; 0x57c6 <xTaskPriorityDisinherit+0x74>
    5772:	ef 01       	movw	r28, r30
    5774:	8f 01       	movw	r16, r30
    5776:	0e 5f       	subi	r16, 0xFE	; 254
    5778:	1f 4f       	sbci	r17, 0xFF	; 255
    577a:	c8 01       	movw	r24, r16
    577c:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5780:	89 a1       	ldd	r24, Y+33	; 0x21
    5782:	8e 8b       	std	Y+22, r24	; 0x16
    5784:	26 e0       	ldi	r18, 0x06	; 6
    5786:	30 e0       	ldi	r19, 0x00	; 0
    5788:	28 1b       	sub	r18, r24
    578a:	31 09       	sbc	r19, r1
    578c:	3d 87       	std	Y+13, r19	; 0x0d
    578e:	2c 87       	std	Y+12, r18	; 0x0c
    5790:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    5794:	98 17       	cp	r25, r24
    5796:	10 f4       	brcc	.+4      	; 0x579c <xTaskPriorityDisinherit+0x4a>
    5798:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    579c:	90 e0       	ldi	r25, 0x00	; 0
    579e:	9c 01       	movw	r18, r24
    57a0:	22 0f       	add	r18, r18
    57a2:	33 1f       	adc	r19, r19
    57a4:	22 0f       	add	r18, r18
    57a6:	33 1f       	adc	r19, r19
    57a8:	22 0f       	add	r18, r18
    57aa:	33 1f       	adc	r19, r19
    57ac:	82 0f       	add	r24, r18
    57ae:	93 1f       	adc	r25, r19
    57b0:	b8 01       	movw	r22, r16
    57b2:	83 59       	subi	r24, 0x93	; 147
    57b4:	95 4e       	sbci	r25, 0xE5	; 229
    57b6:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    57ba:	81 e0       	ldi	r24, 0x01	; 1
    57bc:	05 c0       	rjmp	.+10     	; 0x57c8 <xTaskPriorityDisinherit+0x76>
    57be:	80 e0       	ldi	r24, 0x00	; 0
    57c0:	03 c0       	rjmp	.+6      	; 0x57c8 <xTaskPriorityDisinherit+0x76>
    57c2:	80 e0       	ldi	r24, 0x00	; 0
    57c4:	01 c0       	rjmp	.+2      	; 0x57c8 <xTaskPriorityDisinherit+0x76>
    57c6:	80 e0       	ldi	r24, 0x00	; 0
    57c8:	df 91       	pop	r29
    57ca:	cf 91       	pop	r28
    57cc:	1f 91       	pop	r17
    57ce:	0f 91       	pop	r16
    57d0:	08 95       	ret

000057d2 <pvTaskIncrementMutexHeldCount>:
    57d2:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    57d6:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    57da:	89 2b       	or	r24, r25
    57dc:	39 f0       	breq	.+14     	; 0x57ec <pvTaskIncrementMutexHeldCount+0x1a>
    57de:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    57e2:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    57e6:	82 a1       	ldd	r24, Z+34	; 0x22
    57e8:	8f 5f       	subi	r24, 0xFF	; 255
    57ea:	82 a3       	std	Z+34, r24	; 0x22
    57ec:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    57f0:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    57f4:	08 95       	ret

000057f6 <ulTaskNotifyTake>:
    57f6:	0f 93       	push	r16
    57f8:	1f 93       	push	r17
    57fa:	cf 93       	push	r28
    57fc:	df 93       	push	r29
    57fe:	18 2f       	mov	r17, r24
    5800:	eb 01       	movw	r28, r22
    5802:	0f b6       	in	r0, 0x3f	; 63
    5804:	f8 94       	cli
    5806:	0f 92       	push	r0
    5808:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    580c:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5810:	83 a1       	ldd	r24, Z+35	; 0x23
    5812:	94 a1       	ldd	r25, Z+36	; 0x24
    5814:	a5 a1       	ldd	r26, Z+37	; 0x25
    5816:	b6 a1       	ldd	r27, Z+38	; 0x26
    5818:	89 2b       	or	r24, r25
    581a:	8a 2b       	or	r24, r26
    581c:	8b 2b       	or	r24, r27
    581e:	09 f0       	breq	.+2      	; 0x5822 <ulTaskNotifyTake+0x2c>
    5820:	58 c0       	rjmp	.+176    	; 0x58d2 <ulTaskNotifyTake+0xdc>
    5822:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5826:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    582a:	81 e0       	ldi	r24, 0x01	; 1
    582c:	87 a3       	std	Z+39, r24	; 0x27
    582e:	20 97       	sbiw	r28, 0x00	; 0
    5830:	09 f4       	brne	.+2      	; 0x5834 <ulTaskNotifyTake+0x3e>
    5832:	4f c0       	rjmp	.+158    	; 0x58d2 <ulTaskNotifyTake+0xdc>
    5834:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5838:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    583c:	02 96       	adiw	r24, 0x02	; 2
    583e:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5842:	cf 3f       	cpi	r28, 0xFF	; 255
    5844:	8f ef       	ldi	r24, 0xFF	; 255
    5846:	d8 07       	cpc	r29, r24
    5848:	59 f4       	brne	.+22     	; 0x5860 <ulTaskNotifyTake+0x6a>
    584a:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    584e:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5852:	6e 5f       	subi	r22, 0xFE	; 254
    5854:	7f 4f       	sbci	r23, 0xFF	; 255
    5856:	85 e4       	ldi	r24, 0x45	; 69
    5858:	9a e1       	ldi	r25, 0x1A	; 26
    585a:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    585e:	37 c0       	rjmp	.+110    	; 0x58ce <ulTaskNotifyTake+0xd8>
    5860:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    5864:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5868:	c8 0f       	add	r28, r24
    586a:	d9 1f       	adc	r29, r25
    586c:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5870:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5874:	d3 83       	std	Z+3, r29	; 0x03
    5876:	c2 83       	std	Z+2, r28	; 0x02
    5878:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    587c:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5880:	c8 17       	cp	r28, r24
    5882:	d9 07       	cpc	r29, r25
    5884:	68 f4       	brcc	.+26     	; 0x58a0 <ulTaskNotifyTake+0xaa>
    5886:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    588a:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    588e:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    5892:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    5896:	6e 5f       	subi	r22, 0xFE	; 254
    5898:	7f 4f       	sbci	r23, 0xFF	; 255
    589a:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    589e:	17 c0       	rjmp	.+46     	; 0x58ce <ulTaskNotifyTake+0xd8>
    58a0:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    58a4:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    58a8:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    58ac:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    58b0:	6e 5f       	subi	r22, 0xFE	; 254
    58b2:	7f 4f       	sbci	r23, 0xFF	; 255
    58b4:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    58b8:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    58bc:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    58c0:	c8 17       	cp	r28, r24
    58c2:	d9 07       	cpc	r29, r25
    58c4:	20 f4       	brcc	.+8      	; 0x58ce <ulTaskNotifyTake+0xd8>
    58c6:	d0 93 3b 1a 	sts	0x1A3B, r29	; 0x801a3b <xNextTaskUnblockTime+0x1>
    58ca:	c0 93 3a 1a 	sts	0x1A3A, r28	; 0x801a3a <xNextTaskUnblockTime>
    58ce:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    58d2:	0f 90       	pop	r0
    58d4:	0f be       	out	0x3f, r0	; 63
    58d6:	0f b6       	in	r0, 0x3f	; 63
    58d8:	f8 94       	cli
    58da:	0f 92       	push	r0
    58dc:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    58e0:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    58e4:	63 a1       	ldd	r22, Z+35	; 0x23
    58e6:	74 a1       	ldd	r23, Z+36	; 0x24
    58e8:	85 a1       	ldd	r24, Z+37	; 0x25
    58ea:	96 a1       	ldd	r25, Z+38	; 0x26
    58ec:	61 15       	cp	r22, r1
    58ee:	71 05       	cpc	r23, r1
    58f0:	81 05       	cpc	r24, r1
    58f2:	91 05       	cpc	r25, r1
    58f4:	d9 f0       	breq	.+54     	; 0x592c <ulTaskNotifyTake+0x136>
    58f6:	11 23       	and	r17, r17
    58f8:	49 f0       	breq	.+18     	; 0x590c <ulTaskNotifyTake+0x116>
    58fa:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    58fe:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5902:	13 a2       	std	Z+35, r1	; 0x23
    5904:	14 a2       	std	Z+36, r1	; 0x24
    5906:	15 a2       	std	Z+37, r1	; 0x25
    5908:	16 a2       	std	Z+38, r1	; 0x26
    590a:	10 c0       	rjmp	.+32     	; 0x592c <ulTaskNotifyTake+0x136>
    590c:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5910:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5914:	03 a1       	ldd	r16, Z+35	; 0x23
    5916:	14 a1       	ldd	r17, Z+36	; 0x24
    5918:	25 a1       	ldd	r18, Z+37	; 0x25
    591a:	36 a1       	ldd	r19, Z+38	; 0x26
    591c:	01 50       	subi	r16, 0x01	; 1
    591e:	11 09       	sbc	r17, r1
    5920:	21 09       	sbc	r18, r1
    5922:	31 09       	sbc	r19, r1
    5924:	03 a3       	std	Z+35, r16	; 0x23
    5926:	14 a3       	std	Z+36, r17	; 0x24
    5928:	25 a3       	std	Z+37, r18	; 0x25
    592a:	36 a3       	std	Z+38, r19	; 0x26
    592c:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5930:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5934:	17 a2       	std	Z+39, r1	; 0x27
    5936:	0f 90       	pop	r0
    5938:	0f be       	out	0x3f, r0	; 63
    593a:	df 91       	pop	r29
    593c:	cf 91       	pop	r28
    593e:	1f 91       	pop	r17
    5940:	0f 91       	pop	r16
    5942:	08 95       	ret

00005944 <xTaskNotifyWait>:
    5944:	4f 92       	push	r4
    5946:	5f 92       	push	r5
    5948:	6f 92       	push	r6
    594a:	7f 92       	push	r7
    594c:	8f 92       	push	r8
    594e:	9f 92       	push	r9
    5950:	af 92       	push	r10
    5952:	bf 92       	push	r11
    5954:	ef 92       	push	r14
    5956:	ff 92       	push	r15
    5958:	0f 93       	push	r16
    595a:	1f 93       	push	r17
    595c:	49 01       	movw	r8, r18
    595e:	5a 01       	movw	r10, r20
    5960:	0f b6       	in	r0, 0x3f	; 63
    5962:	f8 94       	cli
    5964:	0f 92       	push	r0
    5966:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    596a:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    596e:	27 a1       	ldd	r18, Z+39	; 0x27
    5970:	22 30       	cpi	r18, 0x02	; 2
    5972:	09 f4       	brne	.+2      	; 0x5976 <xTaskNotifyWait+0x32>
    5974:	6f c0       	rjmp	.+222    	; 0x5a54 <xTaskNotifyWait+0x110>
    5976:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    597a:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    597e:	43 a0       	ldd	r4, Z+35	; 0x23
    5980:	54 a0       	ldd	r5, Z+36	; 0x24
    5982:	65 a0       	ldd	r6, Z+37	; 0x25
    5984:	76 a0       	ldd	r7, Z+38	; 0x26
    5986:	dc 01       	movw	r26, r24
    5988:	cb 01       	movw	r24, r22
    598a:	80 95       	com	r24
    598c:	90 95       	com	r25
    598e:	a0 95       	com	r26
    5990:	b0 95       	com	r27
    5992:	84 21       	and	r24, r4
    5994:	95 21       	and	r25, r5
    5996:	a6 21       	and	r26, r6
    5998:	b7 21       	and	r27, r7
    599a:	83 a3       	std	Z+35, r24	; 0x23
    599c:	94 a3       	std	Z+36, r25	; 0x24
    599e:	a5 a3       	std	Z+37, r26	; 0x25
    59a0:	b6 a3       	std	Z+38, r27	; 0x26
    59a2:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    59a6:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    59aa:	81 e0       	ldi	r24, 0x01	; 1
    59ac:	87 a3       	std	Z+39, r24	; 0x27
    59ae:	e1 14       	cp	r14, r1
    59b0:	f1 04       	cpc	r15, r1
    59b2:	09 f4       	brne	.+2      	; 0x59b6 <xTaskNotifyWait+0x72>
    59b4:	4f c0       	rjmp	.+158    	; 0x5a54 <xTaskNotifyWait+0x110>
    59b6:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    59ba:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    59be:	02 96       	adiw	r24, 0x02	; 2
    59c0:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    59c4:	8f ef       	ldi	r24, 0xFF	; 255
    59c6:	e8 16       	cp	r14, r24
    59c8:	f8 06       	cpc	r15, r24
    59ca:	59 f4       	brne	.+22     	; 0x59e2 <xTaskNotifyWait+0x9e>
    59cc:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    59d0:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    59d4:	6e 5f       	subi	r22, 0xFE	; 254
    59d6:	7f 4f       	sbci	r23, 0xFF	; 255
    59d8:	85 e4       	ldi	r24, 0x45	; 69
    59da:	9a e1       	ldi	r25, 0x1A	; 26
    59dc:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    59e0:	37 c0       	rjmp	.+110    	; 0x5a50 <xTaskNotifyWait+0x10c>
    59e2:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    59e6:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    59ea:	e8 0e       	add	r14, r24
    59ec:	f9 1e       	adc	r15, r25
    59ee:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    59f2:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    59f6:	f3 82       	std	Z+3, r15	; 0x03
    59f8:	e2 82       	std	Z+2, r14	; 0x02
    59fa:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xTickCount>
    59fe:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <xTickCount+0x1>
    5a02:	e8 16       	cp	r14, r24
    5a04:	f9 06       	cpc	r15, r25
    5a06:	68 f4       	brcc	.+26     	; 0x5a22 <xTaskNotifyWait+0xde>
    5a08:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5a0c:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5a10:	80 91 57 1a 	lds	r24, 0x1A57	; 0x801a57 <pxOverflowDelayedTaskList>
    5a14:	90 91 58 1a 	lds	r25, 0x1A58	; 0x801a58 <pxOverflowDelayedTaskList+0x1>
    5a18:	6e 5f       	subi	r22, 0xFE	; 254
    5a1a:	7f 4f       	sbci	r23, 0xFF	; 255
    5a1c:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    5a20:	17 c0       	rjmp	.+46     	; 0x5a50 <xTaskNotifyWait+0x10c>
    5a22:	60 91 a3 1a 	lds	r22, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5a26:	70 91 a4 1a 	lds	r23, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5a2a:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxDelayedTaskList>
    5a2e:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxDelayedTaskList+0x1>
    5a32:	6e 5f       	subi	r22, 0xFE	; 254
    5a34:	7f 4f       	sbci	r23, 0xFF	; 255
    5a36:	0e 94 bb 0c 	call	0x1976	; 0x1976 <vListInsert>
    5a3a:	80 91 3a 1a 	lds	r24, 0x1A3A	; 0x801a3a <xNextTaskUnblockTime>
    5a3e:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <xNextTaskUnblockTime+0x1>
    5a42:	e8 16       	cp	r14, r24
    5a44:	f9 06       	cpc	r15, r25
    5a46:	20 f4       	brcc	.+8      	; 0x5a50 <xTaskNotifyWait+0x10c>
    5a48:	f0 92 3b 1a 	sts	0x1A3B, r15	; 0x801a3b <xNextTaskUnblockTime+0x1>
    5a4c:	e0 92 3a 1a 	sts	0x1A3A, r14	; 0x801a3a <xNextTaskUnblockTime>
    5a50:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    5a54:	0f 90       	pop	r0
    5a56:	0f be       	out	0x3f, r0	; 63
    5a58:	0f b6       	in	r0, 0x3f	; 63
    5a5a:	f8 94       	cli
    5a5c:	0f 92       	push	r0
    5a5e:	01 15       	cp	r16, r1
    5a60:	11 05       	cpc	r17, r1
    5a62:	69 f0       	breq	.+26     	; 0x5a7e <xTaskNotifyWait+0x13a>
    5a64:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5a68:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5a6c:	83 a1       	ldd	r24, Z+35	; 0x23
    5a6e:	94 a1       	ldd	r25, Z+36	; 0x24
    5a70:	a5 a1       	ldd	r26, Z+37	; 0x25
    5a72:	b6 a1       	ldd	r27, Z+38	; 0x26
    5a74:	f8 01       	movw	r30, r16
    5a76:	80 83       	st	Z, r24
    5a78:	91 83       	std	Z+1, r25	; 0x01
    5a7a:	a2 83       	std	Z+2, r26	; 0x02
    5a7c:	b3 83       	std	Z+3, r27	; 0x03
    5a7e:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5a82:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5a86:	87 a1       	ldd	r24, Z+39	; 0x27
    5a88:	81 30       	cpi	r24, 0x01	; 1
    5a8a:	b1 f0       	breq	.+44     	; 0x5ab8 <xTaskNotifyWait+0x174>
    5a8c:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5a90:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5a94:	83 a1       	ldd	r24, Z+35	; 0x23
    5a96:	94 a1       	ldd	r25, Z+36	; 0x24
    5a98:	a5 a1       	ldd	r26, Z+37	; 0x25
    5a9a:	b6 a1       	ldd	r27, Z+38	; 0x26
    5a9c:	80 94       	com	r8
    5a9e:	90 94       	com	r9
    5aa0:	a0 94       	com	r10
    5aa2:	b0 94       	com	r11
    5aa4:	88 22       	and	r8, r24
    5aa6:	99 22       	and	r9, r25
    5aa8:	aa 22       	and	r10, r26
    5aaa:	bb 22       	and	r11, r27
    5aac:	83 a2       	std	Z+35, r8	; 0x23
    5aae:	94 a2       	std	Z+36, r9	; 0x24
    5ab0:	a5 a2       	std	Z+37, r10	; 0x25
    5ab2:	b6 a2       	std	Z+38, r11	; 0x26
    5ab4:	81 e0       	ldi	r24, 0x01	; 1
    5ab6:	01 c0       	rjmp	.+2      	; 0x5aba <xTaskNotifyWait+0x176>
    5ab8:	80 e0       	ldi	r24, 0x00	; 0
    5aba:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5abe:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5ac2:	17 a2       	std	Z+39, r1	; 0x27
    5ac4:	0f 90       	pop	r0
    5ac6:	0f be       	out	0x3f, r0	; 63
    5ac8:	1f 91       	pop	r17
    5aca:	0f 91       	pop	r16
    5acc:	ff 90       	pop	r15
    5ace:	ef 90       	pop	r14
    5ad0:	bf 90       	pop	r11
    5ad2:	af 90       	pop	r10
    5ad4:	9f 90       	pop	r9
    5ad6:	8f 90       	pop	r8
    5ad8:	7f 90       	pop	r7
    5ada:	6f 90       	pop	r6
    5adc:	5f 90       	pop	r5
    5ade:	4f 90       	pop	r4
    5ae0:	08 95       	ret

00005ae2 <xTaskGenericNotify>:
    5ae2:	0f 93       	push	r16
    5ae4:	1f 93       	push	r17
    5ae6:	cf 93       	push	r28
    5ae8:	df 93       	push	r29
    5aea:	fc 01       	movw	r30, r24
    5aec:	0f b6       	in	r0, 0x3f	; 63
    5aee:	f8 94       	cli
    5af0:	0f 92       	push	r0
    5af2:	01 15       	cp	r16, r1
    5af4:	11 05       	cpc	r17, r1
    5af6:	49 f0       	breq	.+18     	; 0x5b0a <xTaskGenericNotify+0x28>
    5af8:	83 a1       	ldd	r24, Z+35	; 0x23
    5afa:	94 a1       	ldd	r25, Z+36	; 0x24
    5afc:	a5 a1       	ldd	r26, Z+37	; 0x25
    5afe:	b6 a1       	ldd	r27, Z+38	; 0x26
    5b00:	e8 01       	movw	r28, r16
    5b02:	88 83       	st	Y, r24
    5b04:	99 83       	std	Y+1, r25	; 0x01
    5b06:	aa 83       	std	Y+2, r26	; 0x02
    5b08:	bb 83       	std	Y+3, r27	; 0x03
    5b0a:	87 a1       	ldd	r24, Z+39	; 0x27
    5b0c:	92 e0       	ldi	r25, 0x02	; 2
    5b0e:	97 a3       	std	Z+39, r25	; 0x27
    5b10:	22 30       	cpi	r18, 0x02	; 2
    5b12:	b1 f0       	breq	.+44     	; 0x5b40 <xTaskGenericNotify+0x5e>
    5b14:	18 f4       	brcc	.+6      	; 0x5b1c <xTaskGenericNotify+0x3a>
    5b16:	21 30       	cpi	r18, 0x01	; 1
    5b18:	31 f0       	breq	.+12     	; 0x5b26 <xTaskGenericNotify+0x44>
    5b1a:	2a c0       	rjmp	.+84     	; 0x5b70 <xTaskGenericNotify+0x8e>
    5b1c:	23 30       	cpi	r18, 0x03	; 3
    5b1e:	e9 f0       	breq	.+58     	; 0x5b5a <xTaskGenericNotify+0x78>
    5b20:	24 30       	cpi	r18, 0x04	; 4
    5b22:	01 f1       	breq	.+64     	; 0x5b64 <xTaskGenericNotify+0x82>
    5b24:	25 c0       	rjmp	.+74     	; 0x5b70 <xTaskGenericNotify+0x8e>
    5b26:	03 a1       	ldd	r16, Z+35	; 0x23
    5b28:	14 a1       	ldd	r17, Z+36	; 0x24
    5b2a:	25 a1       	ldd	r18, Z+37	; 0x25
    5b2c:	36 a1       	ldd	r19, Z+38	; 0x26
    5b2e:	40 2b       	or	r20, r16
    5b30:	51 2b       	or	r21, r17
    5b32:	62 2b       	or	r22, r18
    5b34:	73 2b       	or	r23, r19
    5b36:	43 a3       	std	Z+35, r20	; 0x23
    5b38:	54 a3       	std	Z+36, r21	; 0x24
    5b3a:	65 a3       	std	Z+37, r22	; 0x25
    5b3c:	76 a3       	std	Z+38, r23	; 0x26
    5b3e:	18 c0       	rjmp	.+48     	; 0x5b70 <xTaskGenericNotify+0x8e>
    5b40:	43 a1       	ldd	r20, Z+35	; 0x23
    5b42:	54 a1       	ldd	r21, Z+36	; 0x24
    5b44:	65 a1       	ldd	r22, Z+37	; 0x25
    5b46:	76 a1       	ldd	r23, Z+38	; 0x26
    5b48:	4f 5f       	subi	r20, 0xFF	; 255
    5b4a:	5f 4f       	sbci	r21, 0xFF	; 255
    5b4c:	6f 4f       	sbci	r22, 0xFF	; 255
    5b4e:	7f 4f       	sbci	r23, 0xFF	; 255
    5b50:	43 a3       	std	Z+35, r20	; 0x23
    5b52:	54 a3       	std	Z+36, r21	; 0x24
    5b54:	65 a3       	std	Z+37, r22	; 0x25
    5b56:	76 a3       	std	Z+38, r23	; 0x26
    5b58:	0b c0       	rjmp	.+22     	; 0x5b70 <xTaskGenericNotify+0x8e>
    5b5a:	43 a3       	std	Z+35, r20	; 0x23
    5b5c:	54 a3       	std	Z+36, r21	; 0x24
    5b5e:	65 a3       	std	Z+37, r22	; 0x25
    5b60:	76 a3       	std	Z+38, r23	; 0x26
    5b62:	06 c0       	rjmp	.+12     	; 0x5b70 <xTaskGenericNotify+0x8e>
    5b64:	82 30       	cpi	r24, 0x02	; 2
    5b66:	79 f1       	breq	.+94     	; 0x5bc6 <xTaskGenericNotify+0xe4>
    5b68:	43 a3       	std	Z+35, r20	; 0x23
    5b6a:	54 a3       	std	Z+36, r21	; 0x24
    5b6c:	65 a3       	std	Z+37, r22	; 0x25
    5b6e:	76 a3       	std	Z+38, r23	; 0x26
    5b70:	81 30       	cpi	r24, 0x01	; 1
    5b72:	59 f5       	brne	.+86     	; 0x5bca <xTaskGenericNotify+0xe8>
    5b74:	ef 01       	movw	r28, r30
    5b76:	8f 01       	movw	r16, r30
    5b78:	0e 5f       	subi	r16, 0xFE	; 254
    5b7a:	1f 4f       	sbci	r17, 0xFF	; 255
    5b7c:	c8 01       	movw	r24, r16
    5b7e:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5b82:	8e 89       	ldd	r24, Y+22	; 0x16
    5b84:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    5b88:	98 17       	cp	r25, r24
    5b8a:	10 f4       	brcc	.+4      	; 0x5b90 <xTaskGenericNotify+0xae>
    5b8c:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    5b90:	90 e0       	ldi	r25, 0x00	; 0
    5b92:	9c 01       	movw	r18, r24
    5b94:	22 0f       	add	r18, r18
    5b96:	33 1f       	adc	r19, r19
    5b98:	22 0f       	add	r18, r18
    5b9a:	33 1f       	adc	r19, r19
    5b9c:	22 0f       	add	r18, r18
    5b9e:	33 1f       	adc	r19, r19
    5ba0:	82 0f       	add	r24, r18
    5ba2:	93 1f       	adc	r25, r19
    5ba4:	b8 01       	movw	r22, r16
    5ba6:	83 59       	subi	r24, 0x93	; 147
    5ba8:	95 4e       	sbci	r25, 0xE5	; 229
    5baa:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    5bae:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5bb2:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5bb6:	9e 89       	ldd	r25, Y+22	; 0x16
    5bb8:	86 89       	ldd	r24, Z+22	; 0x16
    5bba:	89 17       	cp	r24, r25
    5bbc:	40 f4       	brcc	.+16     	; 0x5bce <xTaskGenericNotify+0xec>
    5bbe:	0e 94 59 18 	call	0x30b2	; 0x30b2 <vPortYield>
    5bc2:	81 e0       	ldi	r24, 0x01	; 1
    5bc4:	05 c0       	rjmp	.+10     	; 0x5bd0 <xTaskGenericNotify+0xee>
    5bc6:	80 e0       	ldi	r24, 0x00	; 0
    5bc8:	03 c0       	rjmp	.+6      	; 0x5bd0 <xTaskGenericNotify+0xee>
    5bca:	81 e0       	ldi	r24, 0x01	; 1
    5bcc:	01 c0       	rjmp	.+2      	; 0x5bd0 <xTaskGenericNotify+0xee>
    5bce:	81 e0       	ldi	r24, 0x01	; 1
    5bd0:	0f 90       	pop	r0
    5bd2:	0f be       	out	0x3f, r0	; 63
    5bd4:	df 91       	pop	r29
    5bd6:	cf 91       	pop	r28
    5bd8:	1f 91       	pop	r17
    5bda:	0f 91       	pop	r16
    5bdc:	08 95       	ret

00005bde <xTaskGenericNotifyFromISR>:
    5bde:	ef 92       	push	r14
    5be0:	ff 92       	push	r15
    5be2:	0f 93       	push	r16
    5be4:	1f 93       	push	r17
    5be6:	cf 93       	push	r28
    5be8:	df 93       	push	r29
    5bea:	fc 01       	movw	r30, r24
    5bec:	01 15       	cp	r16, r1
    5bee:	11 05       	cpc	r17, r1
    5bf0:	49 f0       	breq	.+18     	; 0x5c04 <xTaskGenericNotifyFromISR+0x26>
    5bf2:	83 a1       	ldd	r24, Z+35	; 0x23
    5bf4:	94 a1       	ldd	r25, Z+36	; 0x24
    5bf6:	a5 a1       	ldd	r26, Z+37	; 0x25
    5bf8:	b6 a1       	ldd	r27, Z+38	; 0x26
    5bfa:	e8 01       	movw	r28, r16
    5bfc:	88 83       	st	Y, r24
    5bfe:	99 83       	std	Y+1, r25	; 0x01
    5c00:	aa 83       	std	Y+2, r26	; 0x02
    5c02:	bb 83       	std	Y+3, r27	; 0x03
    5c04:	87 a1       	ldd	r24, Z+39	; 0x27
    5c06:	92 e0       	ldi	r25, 0x02	; 2
    5c08:	97 a3       	std	Z+39, r25	; 0x27
    5c0a:	22 30       	cpi	r18, 0x02	; 2
    5c0c:	b1 f0       	breq	.+44     	; 0x5c3a <xTaskGenericNotifyFromISR+0x5c>
    5c0e:	18 f4       	brcc	.+6      	; 0x5c16 <xTaskGenericNotifyFromISR+0x38>
    5c10:	21 30       	cpi	r18, 0x01	; 1
    5c12:	31 f0       	breq	.+12     	; 0x5c20 <xTaskGenericNotifyFromISR+0x42>
    5c14:	2a c0       	rjmp	.+84     	; 0x5c6a <xTaskGenericNotifyFromISR+0x8c>
    5c16:	23 30       	cpi	r18, 0x03	; 3
    5c18:	e9 f0       	breq	.+58     	; 0x5c54 <xTaskGenericNotifyFromISR+0x76>
    5c1a:	24 30       	cpi	r18, 0x04	; 4
    5c1c:	01 f1       	breq	.+64     	; 0x5c5e <xTaskGenericNotifyFromISR+0x80>
    5c1e:	25 c0       	rjmp	.+74     	; 0x5c6a <xTaskGenericNotifyFromISR+0x8c>
    5c20:	03 a1       	ldd	r16, Z+35	; 0x23
    5c22:	14 a1       	ldd	r17, Z+36	; 0x24
    5c24:	25 a1       	ldd	r18, Z+37	; 0x25
    5c26:	36 a1       	ldd	r19, Z+38	; 0x26
    5c28:	40 2b       	or	r20, r16
    5c2a:	51 2b       	or	r21, r17
    5c2c:	62 2b       	or	r22, r18
    5c2e:	73 2b       	or	r23, r19
    5c30:	43 a3       	std	Z+35, r20	; 0x23
    5c32:	54 a3       	std	Z+36, r21	; 0x24
    5c34:	65 a3       	std	Z+37, r22	; 0x25
    5c36:	76 a3       	std	Z+38, r23	; 0x26
    5c38:	18 c0       	rjmp	.+48     	; 0x5c6a <xTaskGenericNotifyFromISR+0x8c>
    5c3a:	43 a1       	ldd	r20, Z+35	; 0x23
    5c3c:	54 a1       	ldd	r21, Z+36	; 0x24
    5c3e:	65 a1       	ldd	r22, Z+37	; 0x25
    5c40:	76 a1       	ldd	r23, Z+38	; 0x26
    5c42:	4f 5f       	subi	r20, 0xFF	; 255
    5c44:	5f 4f       	sbci	r21, 0xFF	; 255
    5c46:	6f 4f       	sbci	r22, 0xFF	; 255
    5c48:	7f 4f       	sbci	r23, 0xFF	; 255
    5c4a:	43 a3       	std	Z+35, r20	; 0x23
    5c4c:	54 a3       	std	Z+36, r21	; 0x24
    5c4e:	65 a3       	std	Z+37, r22	; 0x25
    5c50:	76 a3       	std	Z+38, r23	; 0x26
    5c52:	0b c0       	rjmp	.+22     	; 0x5c6a <xTaskGenericNotifyFromISR+0x8c>
    5c54:	43 a3       	std	Z+35, r20	; 0x23
    5c56:	54 a3       	std	Z+36, r21	; 0x24
    5c58:	65 a3       	std	Z+37, r22	; 0x25
    5c5a:	76 a3       	std	Z+38, r23	; 0x26
    5c5c:	06 c0       	rjmp	.+12     	; 0x5c6a <xTaskGenericNotifyFromISR+0x8c>
    5c5e:	82 30       	cpi	r24, 0x02	; 2
    5c60:	f1 f1       	breq	.+124    	; 0x5cde <xTaskGenericNotifyFromISR+0x100>
    5c62:	43 a3       	std	Z+35, r20	; 0x23
    5c64:	54 a3       	std	Z+36, r21	; 0x24
    5c66:	65 a3       	std	Z+37, r22	; 0x25
    5c68:	76 a3       	std	Z+38, r23	; 0x26
    5c6a:	81 30       	cpi	r24, 0x01	; 1
    5c6c:	d1 f5       	brne	.+116    	; 0x5ce2 <xTaskGenericNotifyFromISR+0x104>
    5c6e:	ef 01       	movw	r28, r30
    5c70:	80 91 39 1a 	lds	r24, 0x1A39	; 0x801a39 <uxSchedulerSuspended>
    5c74:	81 11       	cpse	r24, r1
    5c76:	1d c0       	rjmp	.+58     	; 0x5cb2 <xTaskGenericNotifyFromISR+0xd4>
    5c78:	8f 01       	movw	r16, r30
    5c7a:	0e 5f       	subi	r16, 0xFE	; 254
    5c7c:	1f 4f       	sbci	r17, 0xFF	; 255
    5c7e:	c8 01       	movw	r24, r16
    5c80:	0e 94 ec 0c 	call	0x19d8	; 0x19d8 <uxListRemove>
    5c84:	8e 89       	ldd	r24, Y+22	; 0x16
    5c86:	90 91 41 1a 	lds	r25, 0x1A41	; 0x801a41 <uxTopReadyPriority>
    5c8a:	98 17       	cp	r25, r24
    5c8c:	10 f4       	brcc	.+4      	; 0x5c92 <xTaskGenericNotifyFromISR+0xb4>
    5c8e:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxTopReadyPriority>
    5c92:	90 e0       	ldi	r25, 0x00	; 0
    5c94:	9c 01       	movw	r18, r24
    5c96:	22 0f       	add	r18, r18
    5c98:	33 1f       	adc	r19, r19
    5c9a:	22 0f       	add	r18, r18
    5c9c:	33 1f       	adc	r19, r19
    5c9e:	22 0f       	add	r18, r18
    5ca0:	33 1f       	adc	r19, r19
    5ca2:	82 0f       	add	r24, r18
    5ca4:	93 1f       	adc	r25, r19
    5ca6:	b8 01       	movw	r22, r16
    5ca8:	83 59       	subi	r24, 0x93	; 147
    5caa:	95 4e       	sbci	r25, 0xE5	; 229
    5cac:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    5cb0:	07 c0       	rjmp	.+14     	; 0x5cc0 <xTaskGenericNotifyFromISR+0xe2>
    5cb2:	bf 01       	movw	r22, r30
    5cb4:	64 5f       	subi	r22, 0xF4	; 244
    5cb6:	7f 4f       	sbci	r23, 0xFF	; 255
    5cb8:	8e e4       	ldi	r24, 0x4E	; 78
    5cba:	9a e1       	ldi	r25, 0x1A	; 26
    5cbc:	0e 94 9a 0c 	call	0x1934	; 0x1934 <vListInsertEnd>
    5cc0:	e0 91 a3 1a 	lds	r30, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5cc4:	f0 91 a4 1a 	lds	r31, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>
    5cc8:	9e 89       	ldd	r25, Y+22	; 0x16
    5cca:	86 89       	ldd	r24, Z+22	; 0x16
    5ccc:	89 17       	cp	r24, r25
    5cce:	58 f4       	brcc	.+22     	; 0x5ce6 <xTaskGenericNotifyFromISR+0x108>
    5cd0:	e1 14       	cp	r14, r1
    5cd2:	f1 04       	cpc	r15, r1
    5cd4:	51 f0       	breq	.+20     	; 0x5cea <xTaskGenericNotifyFromISR+0x10c>
    5cd6:	81 e0       	ldi	r24, 0x01	; 1
    5cd8:	f7 01       	movw	r30, r14
    5cda:	80 83       	st	Z, r24
    5cdc:	07 c0       	rjmp	.+14     	; 0x5cec <xTaskGenericNotifyFromISR+0x10e>
    5cde:	80 e0       	ldi	r24, 0x00	; 0
    5ce0:	05 c0       	rjmp	.+10     	; 0x5cec <xTaskGenericNotifyFromISR+0x10e>
    5ce2:	81 e0       	ldi	r24, 0x01	; 1
    5ce4:	03 c0       	rjmp	.+6      	; 0x5cec <xTaskGenericNotifyFromISR+0x10e>
    5ce6:	81 e0       	ldi	r24, 0x01	; 1
    5ce8:	01 c0       	rjmp	.+2      	; 0x5cec <xTaskGenericNotifyFromISR+0x10e>
    5cea:	81 e0       	ldi	r24, 0x01	; 1
    5cec:	df 91       	pop	r29
    5cee:	cf 91       	pop	r28
    5cf0:	1f 91       	pop	r17
    5cf2:	0f 91       	pop	r16
    5cf4:	ff 90       	pop	r15
    5cf6:	ef 90       	pop	r14
    5cf8:	08 95       	ret

00005cfa <xTaskNotifyStateClear>:

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    5cfa:	00 97       	sbiw	r24, 0x00	; 0
    5cfc:	21 f4       	brne	.+8      	; 0x5d06 <xTaskNotifyStateClear+0xc>
    5cfe:	80 91 a3 1a 	lds	r24, 0x1AA3	; 0x801aa3 <pxCurrentTCB>
    5d02:	90 91 a4 1a 	lds	r25, 0x1AA4	; 0x801aa4 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    5d06:	0f b6       	in	r0, 0x3f	; 63
    5d08:	f8 94       	cli
    5d0a:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    5d0c:	fc 01       	movw	r30, r24
    5d0e:	27 a1       	ldd	r18, Z+39	; 0x27
    5d10:	22 30       	cpi	r18, 0x02	; 2
    5d12:	19 f4       	brne	.+6      	; 0x5d1a <xTaskNotifyStateClear+0x20>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    5d14:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5d16:	81 e0       	ldi	r24, 0x01	; 1
    5d18:	01 c0       	rjmp	.+2      	; 0x5d1c <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    5d1a:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    5d1c:	0f 90       	pop	r0
    5d1e:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    5d20:	08 95       	ret

00005d22 <ui8TWI_start>:
    data[(length-1)] = ui8TWI_read_nack();

    vTWI_stop();

    return 0;
}
    5d22:	ec eb       	ldi	r30, 0xBC	; 188
    5d24:	f0 e0       	ldi	r31, 0x00	; 0
    5d26:	10 82       	st	Z, r1
    5d28:	94 ea       	ldi	r25, 0xA4	; 164
    5d2a:	90 83       	st	Z, r25
    5d2c:	90 81       	ld	r25, Z
    5d2e:	99 23       	and	r25, r25
    5d30:	ec f7       	brge	.-6      	; 0x5d2c <ui8TWI_start+0xa>
    5d32:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    5d36:	98 7f       	andi	r25, 0xF8	; 248
    5d38:	98 30       	cpi	r25, 0x08	; 8
    5d3a:	a1 f4       	brne	.+40     	; 0x5d64 <ui8TWI_start+0x42>
    5d3c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5d40:	84 e8       	ldi	r24, 0x84	; 132
    5d42:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5d46:	ec eb       	ldi	r30, 0xBC	; 188
    5d48:	f0 e0       	ldi	r31, 0x00	; 0
    5d4a:	80 81       	ld	r24, Z
    5d4c:	88 23       	and	r24, r24
    5d4e:	ec f7       	brge	.-6      	; 0x5d4a <ui8TWI_start+0x28>
    5d50:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    5d54:	98 7f       	andi	r25, 0xF8	; 248
    5d56:	98 31       	cpi	r25, 0x18	; 24
    5d58:	39 f0       	breq	.+14     	; 0x5d68 <ui8TWI_start+0x46>
    5d5a:	81 e0       	ldi	r24, 0x01	; 1
    5d5c:	90 34       	cpi	r25, 0x40	; 64
    5d5e:	29 f4       	brne	.+10     	; 0x5d6a <ui8TWI_start+0x48>
    5d60:	80 e0       	ldi	r24, 0x00	; 0
    5d62:	08 95       	ret
    5d64:	81 e0       	ldi	r24, 0x01	; 1
    5d66:	08 95       	ret
    5d68:	80 e0       	ldi	r24, 0x00	; 0
    5d6a:	08 95       	ret

00005d6c <ui8TWI_write>:
    5d6c:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5d70:	84 e8       	ldi	r24, 0x84	; 132
    5d72:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5d76:	ec eb       	ldi	r30, 0xBC	; 188
    5d78:	f0 e0       	ldi	r31, 0x00	; 0
    5d7a:	80 81       	ld	r24, Z
    5d7c:	88 23       	and	r24, r24
    5d7e:	ec f7       	brge	.-6      	; 0x5d7a <ui8TWI_write+0xe>
    5d80:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    5d84:	98 7f       	andi	r25, 0xF8	; 248
    5d86:	81 e0       	ldi	r24, 0x01	; 1
    5d88:	98 32       	cpi	r25, 0x28	; 40
    5d8a:	09 f4       	brne	.+2      	; 0x5d8e <ui8TWI_write+0x22>
    5d8c:	80 e0       	ldi	r24, 0x00	; 0
    5d8e:	08 95       	ret

00005d90 <ui8TWI_read_ack>:
    5d90:	84 ec       	ldi	r24, 0xC4	; 196
    5d92:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5d96:	ec eb       	ldi	r30, 0xBC	; 188
    5d98:	f0 e0       	ldi	r31, 0x00	; 0
    5d9a:	80 81       	ld	r24, Z
    5d9c:	88 23       	and	r24, r24
    5d9e:	ec f7       	brge	.-6      	; 0x5d9a <ui8TWI_read_ack+0xa>
    5da0:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5da4:	08 95       	ret

00005da6 <ui8TWI_read_nack>:
    5da6:	84 e8       	ldi	r24, 0x84	; 132
    5da8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5dac:	ec eb       	ldi	r30, 0xBC	; 188
    5dae:	f0 e0       	ldi	r31, 0x00	; 0
    5db0:	80 81       	ld	r24, Z
    5db2:	88 23       	and	r24, r24
    5db4:	ec f7       	brge	.-6      	; 0x5db0 <ui8TWI_read_nack+0xa>
    5db6:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5dba:	08 95       	ret

00005dbc <vTWI_stop>:

void vTWI_stop(void){
    // transmit STOP condition
    TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    5dbc:	84 e9       	ldi	r24, 0x94	; 148
    5dbe:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5dc2:	08 95       	ret

00005dc4 <vFrameReaderTask>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
}

void vFrameReaderTask( void *pvParameters ){
    5dc4:	cf 93       	push	r28
    5dc6:	df 93       	push	r29
    5dc8:	00 d0       	rcall	.+0      	; 0x5dca <vFrameReaderTask+0x6>
    5dca:	1f 92       	push	r1
    5dcc:	cd b7       	in	r28, 0x3d	; 61
    5dce:	de b7       	in	r29, 0x3e	; 62
	frame_receiver = xTaskGetCurrentTaskHandle();
    5dd0:	59 dc       	rcall	.-1870   	; 0x5684 <xTaskGetCurrentTaskHandle>
    5dd2:	90 93 0c 1b 	sts	0x1B0C, r25	; 0x801b0c <frame_receiver+0x1>
    5dd6:	80 93 0b 1b 	sts	0x1B0B, r24	; 0x801b0b <frame_receiver>
	uint32_t notification_value = 0;
    5dda:	19 82       	std	Y+1, r1	; 0x01
    5ddc:	1a 82       	std	Y+2, r1	; 0x02
    5dde:	1b 82       	std	Y+3, r1	; 0x03
    5de0:	1c 82       	std	Y+4, r1	; 0x04
	while(1){
		xTaskNotifyWait(0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);
    5de2:	ee 24       	eor	r14, r14
    5de4:	ea 94       	dec	r14
    5de6:	fe 2c       	mov	r15, r14
    5de8:	8e 01       	movw	r16, r28
    5dea:	0f 5f       	subi	r16, 0xFF	; 255
    5dec:	1f 4f       	sbci	r17, 0xFF	; 255
    5dee:	2f ef       	ldi	r18, 0xFF	; 255
    5df0:	3f ef       	ldi	r19, 0xFF	; 255
    5df2:	a9 01       	movw	r20, r18
    5df4:	6f ef       	ldi	r22, 0xFF	; 255
    5df6:	7f ef       	ldi	r23, 0xFF	; 255
    5df8:	cb 01       	movw	r24, r22
    5dfa:	a4 dd       	rcall	.-1208   	; 0x5944 <xTaskNotifyWait>
		if(receive_callback != NULL) receive_callback(receive_buffer, (uint16_t)notification_value);
    5dfc:	e0 91 70 1b 	lds	r30, 0x1B70	; 0x801b70 <receive_callback>
    5e00:	f0 91 71 1b 	lds	r31, 0x1B71	; 0x801b71 <receive_callback+0x1>
    5e04:	30 97       	sbiw	r30, 0x00	; 0
    5e06:	69 f3       	breq	.-38     	; 0x5de2 <vFrameReaderTask+0x1e>
    5e08:	69 81       	ldd	r22, Y+1	; 0x01
    5e0a:	7a 81       	ldd	r23, Y+2	; 0x02
    5e0c:	82 e7       	ldi	r24, 0x72	; 114
    5e0e:	9b e1       	ldi	r25, 0x1B	; 27
    5e10:	19 95       	eicall
    5e12:	e7 cf       	rjmp	.-50     	; 0x5de2 <vFrameReaderTask+0x1e>

00005e14 <vUartSendTask>:
	}
}

void vUartSendTask(void *pvParamters) {
    5e14:	cf 93       	push	r28
    5e16:	df 93       	push	r29
    5e18:	cd b7       	in	r28, 0x3d	; 61
    5e1a:	de b7       	in	r29, 0x3e	; 62
    5e1c:	c4 56       	subi	r28, 0x64	; 100
    5e1e:	d1 09       	sbc	r29, r1
    5e20:	0f b6       	in	r0, 0x3f	; 63
    5e22:	f8 94       	cli
    5e24:	de bf       	out	0x3e, r29	; 62
    5e26:	0f be       	out	0x3f, r0	; 63
    5e28:	cd bf       	out	0x3d, r28	; 61
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    5e2a:	00 ed       	ldi	r16, 0xD0	; 208
    5e2c:	10 e0       	ldi	r17, 0x00	; 0
				UDR2 = data[i];
    5e2e:	0f 2e       	mov	r0, r31
    5e30:	f6 ed       	ldi	r31, 0xD6	; 214
    5e32:	ef 2e       	mov	r14, r31
    5e34:	f1 2c       	mov	r15, r1
    5e36:	f0 2d       	mov	r31, r0
void vUartSendTask(void *pvParamters) {
	uint8_t data[100];
	uint16_t num;
	uint16_t i;
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
    5e38:	20 e0       	ldi	r18, 0x00	; 0
    5e3a:	4f ef       	ldi	r20, 0xFF	; 255
    5e3c:	5f ef       	ldi	r21, 0xFF	; 255
    5e3e:	60 e0       	ldi	r22, 0x00	; 0
    5e40:	70 e0       	ldi	r23, 0x00	; 0
    5e42:	80 91 31 1b 	lds	r24, 0x1B31	; 0x801b31 <xUartMutex>
    5e46:	90 91 32 1b 	lds	r25, 0x1B32	; 0x801b32 <xUartMutex+0x1>
    5e4a:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
    5e4e:	24 e6       	ldi	r18, 0x64	; 100
    5e50:	30 e0       	ldi	r19, 0x00	; 0
    5e52:	40 e0       	ldi	r20, 0x00	; 0
    5e54:	be 01       	movw	r22, r28
    5e56:	6f 5f       	subi	r22, 0xFF	; 255
    5e58:	7f 4f       	sbci	r23, 0xFF	; 255
    5e5a:	86 ed       	ldi	r24, 0xD6	; 214
    5e5c:	9b e1       	ldi	r25, 0x1B	; 27
    5e5e:	0e 94 a2 05 	call	0xb44	; 0xb44 <buffer_remove_token>
    5e62:	6c 01       	movw	r12, r24
		xSemaphoreGive(xUartMutex);
    5e64:	60 e0       	ldi	r22, 0x00	; 0
    5e66:	70 e0       	ldi	r23, 0x00	; 0
    5e68:	80 91 31 1b 	lds	r24, 0x1B31	; 0x801b31 <xUartMutex>
    5e6c:	90 91 32 1b 	lds	r25, 0x1B32	; 0x801b32 <xUartMutex+0x1>
    5e70:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
		if(num>0) {
    5e74:	c1 14       	cp	r12, r1
    5e76:	d1 04       	cpc	r13, r1
    5e78:	79 f0       	breq	.+30     	; 0x5e98 <vUartSendTask+0x84>
    5e7a:	fe 01       	movw	r30, r28
    5e7c:	31 96       	adiw	r30, 0x01	; 1
    5e7e:	9f 01       	movw	r18, r30
    5e80:	2c 0d       	add	r18, r12
    5e82:	3d 1d       	adc	r19, r13
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    5e84:	d8 01       	movw	r26, r16
    5e86:	8c 91       	ld	r24, X
    5e88:	85 ff       	sbrs	r24, 5
    5e8a:	fc cf       	rjmp	.-8      	; 0x5e84 <vUartSendTask+0x70>
				UDR2 = data[i];
    5e8c:	81 91       	ld	r24, Z+
    5e8e:	d7 01       	movw	r26, r14
    5e90:	8c 93       	st	X, r24
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
    5e92:	2e 17       	cp	r18, r30
    5e94:	3f 07       	cpc	r19, r31
    5e96:	b1 f7       	brne	.-20     	; 0x5e84 <vUartSendTask+0x70>
				while ( !( UCSR2A & (1<<UDRE2)) );
				UDR2 = data[i];
			}
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
    5e98:	8a e0       	ldi	r24, 0x0A	; 10
    5e9a:	90 e0       	ldi	r25, 0x00	; 0
    5e9c:	0e 94 58 25 	call	0x4ab0	; 0x4ab0 <vTaskDelay>
	}
    5ea0:	cb cf       	rjmp	.-106    	; 0x5e38 <vUartSendTask+0x24>

00005ea2 <vUSART_init>:
/************************************************************************/
//Initialize USART driver, note that RXD0/TXD0 (PD0/PD1) is used
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    5ea2:	af 92       	push	r10
    5ea4:	bf 92       	push	r11
    5ea6:	cf 92       	push	r12
    5ea8:	df 92       	push	r13
    5eaa:	ef 92       	push	r14
    5eac:	ff 92       	push	r15
    5eae:	0f 93       	push	r16
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    5eb0:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    5eb4:	89 e1       	ldi	r24, 0x19	; 25
    5eb6:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    5eba:	80 ee       	ldi	r24, 0xE0	; 224
    5ebc:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    5ec0:	88 e9       	ldi	r24, 0x98	; 152
    5ec2:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    5ec6:	e2 ed       	ldi	r30, 0xD2	; 210
    5ec8:	f0 e0       	ldi	r31, 0x00	; 0
    5eca:	86 e0       	ldi	r24, 0x06	; 6
    5ecc:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    5ece:	80 81       	ld	r24, Z
    5ed0:	80 83       	st	Z, r24

	uint8_t *buf = pvPortMalloc(100);
    5ed2:	84 e6       	ldi	r24, 0x64	; 100
    5ed4:	90 e0       	ldi	r25, 0x00	; 0
    5ed6:	0e 94 69 08 	call	0x10d2	; 0x10d2 <pvPortMalloc>
	buffer_init(&send_buffer, buf, 100);
    5eda:	44 e6       	ldi	r20, 0x64	; 100
    5edc:	50 e0       	ldi	r21, 0x00	; 0
    5ede:	bc 01       	movw	r22, r24
    5ee0:	86 ed       	ldi	r24, 0xD6	; 214
    5ee2:	9b e1       	ldi	r25, 0x1B	; 27
    5ee4:	0e 94 2c 05 	call	0xa58	; 0xa58 <buffer_init>
	xTaskCreate(vFrameReaderTask, "FrameReader", 300, NULL, 4, NULL);
    5ee8:	a1 2c       	mov	r10, r1
    5eea:	b1 2c       	mov	r11, r1
    5eec:	c1 2c       	mov	r12, r1
    5eee:	d1 2c       	mov	r13, r1
    5ef0:	e1 2c       	mov	r14, r1
    5ef2:	f1 2c       	mov	r15, r1
    5ef4:	04 e0       	ldi	r16, 0x04	; 4
    5ef6:	20 e0       	ldi	r18, 0x00	; 0
    5ef8:	30 e0       	ldi	r19, 0x00	; 0
    5efa:	4c e2       	ldi	r20, 0x2C	; 44
    5efc:	51 e0       	ldi	r21, 0x01	; 1
    5efe:	60 e0       	ldi	r22, 0x00	; 0
    5f00:	77 e0       	ldi	r23, 0x07	; 7
    5f02:	82 ee       	ldi	r24, 0xE2	; 226
    5f04:	9e e2       	ldi	r25, 0x2E	; 46
    5f06:	0e 94 a1 22 	call	0x4542	; 0x4542 <xTaskGenericCreate>
	xTaskCreate(vUartSendTask, "UartSendTask", 300, NULL, 4, NULL);
    5f0a:	20 e0       	ldi	r18, 0x00	; 0
    5f0c:	30 e0       	ldi	r19, 0x00	; 0
    5f0e:	4c e2       	ldi	r20, 0x2C	; 44
    5f10:	51 e0       	ldi	r21, 0x01	; 1
    5f12:	6c e0       	ldi	r22, 0x0C	; 12
    5f14:	77 e0       	ldi	r23, 0x07	; 7
    5f16:	8a e0       	ldi	r24, 0x0A	; 10
    5f18:	9f e2       	ldi	r25, 0x2F	; 47
    5f1a:	0e 94 a1 22 	call	0x4542	; 0x4542 <xTaskGenericCreate>
	
	xUartMutex = xSemaphoreCreateMutex();
    5f1e:	81 e0       	ldi	r24, 0x01	; 1
    5f20:	0e 94 86 19 	call	0x330c	; 0x330c <xQueueCreateMutex>
    5f24:	90 93 32 1b 	sts	0x1B32, r25	; 0x801b32 <xUartMutex+0x1>
    5f28:	80 93 31 1b 	sts	0x1B31, r24	; 0x801b31 <xUartMutex>
}
    5f2c:	0f 91       	pop	r16
    5f2e:	ff 90       	pop	r15
    5f30:	ef 90       	pop	r14
    5f32:	df 90       	pop	r13
    5f34:	cf 90       	pop	r12
    5f36:	bf 90       	pop	r11
    5f38:	af 90       	pop	r10
    5f3a:	08 95       	ret

00005f3c <vUSART_send>:

void vUSART_send(uint8_t *data, uint16_t len) {
    5f3c:	0f 93       	push	r16
    5f3e:	1f 93       	push	r17
    5f40:	cf 93       	push	r28
    5f42:	df 93       	push	r29
    5f44:	ec 01       	movw	r28, r24
    5f46:	8b 01       	movw	r16, r22
	xSemaphoreTake(xUartMutex, portMAX_DELAY);
    5f48:	20 e0       	ldi	r18, 0x00	; 0
    5f4a:	4f ef       	ldi	r20, 0xFF	; 255
    5f4c:	5f ef       	ldi	r21, 0xFF	; 255
    5f4e:	60 e0       	ldi	r22, 0x00	; 0
    5f50:	70 e0       	ldi	r23, 0x00	; 0
    5f52:	80 91 31 1b 	lds	r24, 0x1B31	; 0x801b31 <xUartMutex>
    5f56:	90 91 32 1b 	lds	r25, 0x1B32	; 0x801b32 <xUartMutex+0x1>
    5f5a:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <xQueueGenericReceive>
	buffer_append(&send_buffer, data, len);
    5f5e:	a8 01       	movw	r20, r16
    5f60:	be 01       	movw	r22, r28
    5f62:	86 ed       	ldi	r24, 0xD6	; 214
    5f64:	9b e1       	ldi	r25, 0x1B	; 27
    5f66:	0e 94 3e 05 	call	0xa7c	; 0xa7c <buffer_append>
	xSemaphoreGive(xUartMutex);
    5f6a:	60 e0       	ldi	r22, 0x00	; 0
    5f6c:	70 e0       	ldi	r23, 0x00	; 0
    5f6e:	80 91 31 1b 	lds	r24, 0x1B31	; 0x801b31 <xUartMutex>
    5f72:	90 91 32 1b 	lds	r25, 0x1B32	; 0x801b32 <xUartMutex+0x1>
    5f76:	0e 94 d8 1c 	call	0x39b0	; 0x39b0 <xQueueGive>
}
    5f7a:	df 91       	pop	r29
    5f7c:	cf 91       	pop	r28
    5f7e:	1f 91       	pop	r17
    5f80:	0f 91       	pop	r16
    5f82:	08 95       	ret

00005f84 <vUSART_set_receive_callback>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
    5f84:	90 93 71 1b 	sts	0x1B71, r25	; 0x801b71 <receive_callback+0x1>
    5f88:	80 93 70 1b 	sts	0x1B70, r24	; 0x801b70 <receive_callback>
    5f8c:	08 95       	ret

00005f8e <__vector_51>:
		vTaskDelay(10*portTICK_PERIOD_MS);
	}
}


ISR(USART2_RX_vect){
    5f8e:	1f 92       	push	r1
    5f90:	0f 92       	push	r0
    5f92:	0f b6       	in	r0, 0x3f	; 63
    5f94:	0f 92       	push	r0
    5f96:	11 24       	eor	r1, r1
    5f98:	0b b6       	in	r0, 0x3b	; 59
    5f9a:	0f 92       	push	r0
    5f9c:	cf 92       	push	r12
    5f9e:	df 92       	push	r13
    5fa0:	ef 92       	push	r14
    5fa2:	ff 92       	push	r15
    5fa4:	0f 93       	push	r16
    5fa6:	1f 93       	push	r17
    5fa8:	2f 93       	push	r18
    5faa:	3f 93       	push	r19
    5fac:	4f 93       	push	r20
    5fae:	5f 93       	push	r21
    5fb0:	6f 93       	push	r22
    5fb2:	7f 93       	push	r23
    5fb4:	8f 93       	push	r24
    5fb6:	9f 93       	push	r25
    5fb8:	af 93       	push	r26
    5fba:	bf 93       	push	r27
    5fbc:	cf 93       	push	r28
    5fbe:	df 93       	push	r29
    5fc0:	ef 93       	push	r30
    5fc2:	ff 93       	push	r31
	static uint8_t input_buffer[100];
	static uint16_t input_index = 0;
	input_buffer[input_index++] = UDR2;
    5fc4:	80 91 09 1b 	lds	r24, 0x1B09	; 0x801b09 <input_index.2398>
    5fc8:	90 91 0a 1b 	lds	r25, 0x1B0A	; 0x801b0a <input_index.2398+0x1>
    5fcc:	ec 01       	movw	r28, r24
    5fce:	21 96       	adiw	r28, 0x01	; 1
    5fd0:	d0 93 0a 1b 	sts	0x1B0A, r29	; 0x801b0a <input_index.2398+0x1>
    5fd4:	c0 93 09 1b 	sts	0x1B09, r28	; 0x801b09 <input_index.2398>
    5fd8:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    5fdc:	fc 01       	movw	r30, r24
    5fde:	eb 55       	subi	r30, 0x5B	; 91
    5fe0:	f5 4e       	sbci	r31, 0xE5	; 229
    5fe2:	20 83       	st	Z, r18
	if(input_buffer[input_index-1] == 0x00) {
    5fe4:	21 11       	cpse	r18, r1
    5fe6:	1d c0       	rjmp	.+58     	; 0x6022 <__vector_51+0x94>
		if(frame_receiver != NULL) {
    5fe8:	c0 90 0b 1b 	lds	r12, 0x1B0B	; 0x801b0b <frame_receiver>
    5fec:	d0 90 0c 1b 	lds	r13, 0x1B0C	; 0x801b0c <frame_receiver+0x1>
    5ff0:	c1 14       	cp	r12, r1
    5ff2:	d1 04       	cpc	r13, r1
    5ff4:	89 f0       	breq	.+34     	; 0x6018 <__vector_51+0x8a>
			memcpy(receive_buffer, input_buffer, input_index);
    5ff6:	ae 01       	movw	r20, r28
    5ff8:	65 ea       	ldi	r22, 0xA5	; 165
    5ffa:	7a e1       	ldi	r23, 0x1A	; 26
    5ffc:	82 e7       	ldi	r24, 0x72	; 114
    5ffe:	9b e1       	ldi	r25, 0x1B	; 27
    6000:	0e 94 2b 38 	call	0x7056	; 0x7056 <memcpy>
			xTaskNotifyFromISR(frame_receiver, input_index, eSetValueWithoutOverwrite, NULL);
    6004:	ae 01       	movw	r20, r28
    6006:	60 e0       	ldi	r22, 0x00	; 0
    6008:	70 e0       	ldi	r23, 0x00	; 0
    600a:	e1 2c       	mov	r14, r1
    600c:	f1 2c       	mov	r15, r1
    600e:	00 e0       	ldi	r16, 0x00	; 0
    6010:	10 e0       	ldi	r17, 0x00	; 0
    6012:	24 e0       	ldi	r18, 0x04	; 4
    6014:	c6 01       	movw	r24, r12
    6016:	e3 dd       	rcall	.-1082   	; 0x5bde <xTaskGenericNotifyFromISR>
		}
		input_index = 0;
    6018:	10 92 0a 1b 	sts	0x1B0A, r1	; 0x801b0a <input_index.2398+0x1>
    601c:	10 92 09 1b 	sts	0x1B09, r1	; 0x801b09 <input_index.2398>
    6020:	07 c0       	rjmp	.+14     	; 0x6030 <__vector_51+0xa2>
	}
	if(input_index > 100) input_index = 0; // Something went wrong, received too many bytes
    6022:	c5 36       	cpi	r28, 0x65	; 101
    6024:	d1 05       	cpc	r29, r1
    6026:	20 f0       	brcs	.+8      	; 0x6030 <__vector_51+0xa2>
    6028:	10 92 0a 1b 	sts	0x1B0A, r1	; 0x801b0a <input_index.2398+0x1>
    602c:	10 92 09 1b 	sts	0x1B09, r1	; 0x801b09 <input_index.2398>
    6030:	ff 91       	pop	r31
    6032:	ef 91       	pop	r30
    6034:	df 91       	pop	r29
    6036:	cf 91       	pop	r28
    6038:	bf 91       	pop	r27
    603a:	af 91       	pop	r26
    603c:	9f 91       	pop	r25
    603e:	8f 91       	pop	r24
    6040:	7f 91       	pop	r23
    6042:	6f 91       	pop	r22
    6044:	5f 91       	pop	r21
    6046:	4f 91       	pop	r20
    6048:	3f 91       	pop	r19
    604a:	2f 91       	pop	r18
    604c:	1f 91       	pop	r17
    604e:	0f 91       	pop	r16
    6050:	ff 90       	pop	r15
    6052:	ef 90       	pop	r14
    6054:	df 90       	pop	r13
    6056:	cf 90       	pop	r12
    6058:	0f 90       	pop	r0
    605a:	0b be       	out	0x3b, r0	; 59
    605c:	0f 90       	pop	r0
    605e:	0f be       	out	0x3f, r0	; 63
    6060:	0f 90       	pop	r0
    6062:	1f 90       	pop	r1
    6064:	18 95       	reti

00006066 <__subsf3>:
    6066:	50 58       	subi	r21, 0x80	; 128

00006068 <__addsf3>:
    6068:	bb 27       	eor	r27, r27
    606a:	aa 27       	eor	r26, r26
    606c:	0e d0       	rcall	.+28     	; 0x608a <__addsf3x>
    606e:	27 c2       	rjmp	.+1102   	; 0x64be <__fp_round>
    6070:	f0 d1       	rcall	.+992    	; 0x6452 <__fp_pscA>
    6072:	30 f0       	brcs	.+12     	; 0x6080 <__addsf3+0x18>
    6074:	f5 d1       	rcall	.+1002   	; 0x6460 <__fp_pscB>
    6076:	20 f0       	brcs	.+8      	; 0x6080 <__addsf3+0x18>
    6078:	31 f4       	brne	.+12     	; 0x6086 <__addsf3+0x1e>
    607a:	9f 3f       	cpi	r25, 0xFF	; 255
    607c:	11 f4       	brne	.+4      	; 0x6082 <__addsf3+0x1a>
    607e:	1e f4       	brtc	.+6      	; 0x6086 <__addsf3+0x1e>
    6080:	c0 c1       	rjmp	.+896    	; 0x6402 <__fp_nan>
    6082:	0e f4       	brtc	.+2      	; 0x6086 <__addsf3+0x1e>
    6084:	e0 95       	com	r30
    6086:	e7 fb       	bst	r30, 7
    6088:	b6 c1       	rjmp	.+876    	; 0x63f6 <__fp_inf>

0000608a <__addsf3x>:
    608a:	e9 2f       	mov	r30, r25
    608c:	3a d2       	rcall	.+1140   	; 0x6502 <__fp_split3>
    608e:	80 f3       	brcs	.-32     	; 0x6070 <__addsf3+0x8>
    6090:	ba 17       	cp	r27, r26
    6092:	62 07       	cpc	r22, r18
    6094:	73 07       	cpc	r23, r19
    6096:	84 07       	cpc	r24, r20
    6098:	95 07       	cpc	r25, r21
    609a:	18 f0       	brcs	.+6      	; 0x60a2 <__addsf3x+0x18>
    609c:	71 f4       	brne	.+28     	; 0x60ba <__addsf3x+0x30>
    609e:	9e f5       	brtc	.+102    	; 0x6106 <__addsf3x+0x7c>
    60a0:	52 c2       	rjmp	.+1188   	; 0x6546 <__fp_zero>
    60a2:	0e f4       	brtc	.+2      	; 0x60a6 <__addsf3x+0x1c>
    60a4:	e0 95       	com	r30
    60a6:	0b 2e       	mov	r0, r27
    60a8:	ba 2f       	mov	r27, r26
    60aa:	a0 2d       	mov	r26, r0
    60ac:	0b 01       	movw	r0, r22
    60ae:	b9 01       	movw	r22, r18
    60b0:	90 01       	movw	r18, r0
    60b2:	0c 01       	movw	r0, r24
    60b4:	ca 01       	movw	r24, r20
    60b6:	a0 01       	movw	r20, r0
    60b8:	11 24       	eor	r1, r1
    60ba:	ff 27       	eor	r31, r31
    60bc:	59 1b       	sub	r21, r25
    60be:	99 f0       	breq	.+38     	; 0x60e6 <__addsf3x+0x5c>
    60c0:	59 3f       	cpi	r21, 0xF9	; 249
    60c2:	50 f4       	brcc	.+20     	; 0x60d8 <__addsf3x+0x4e>
    60c4:	50 3e       	cpi	r21, 0xE0	; 224
    60c6:	68 f1       	brcs	.+90     	; 0x6122 <__addsf3x+0x98>
    60c8:	1a 16       	cp	r1, r26
    60ca:	f0 40       	sbci	r31, 0x00	; 0
    60cc:	a2 2f       	mov	r26, r18
    60ce:	23 2f       	mov	r18, r19
    60d0:	34 2f       	mov	r19, r20
    60d2:	44 27       	eor	r20, r20
    60d4:	58 5f       	subi	r21, 0xF8	; 248
    60d6:	f3 cf       	rjmp	.-26     	; 0x60be <__addsf3x+0x34>
    60d8:	46 95       	lsr	r20
    60da:	37 95       	ror	r19
    60dc:	27 95       	ror	r18
    60de:	a7 95       	ror	r26
    60e0:	f0 40       	sbci	r31, 0x00	; 0
    60e2:	53 95       	inc	r21
    60e4:	c9 f7       	brne	.-14     	; 0x60d8 <__addsf3x+0x4e>
    60e6:	7e f4       	brtc	.+30     	; 0x6106 <__addsf3x+0x7c>
    60e8:	1f 16       	cp	r1, r31
    60ea:	ba 0b       	sbc	r27, r26
    60ec:	62 0b       	sbc	r22, r18
    60ee:	73 0b       	sbc	r23, r19
    60f0:	84 0b       	sbc	r24, r20
    60f2:	ba f0       	brmi	.+46     	; 0x6122 <__addsf3x+0x98>
    60f4:	91 50       	subi	r25, 0x01	; 1
    60f6:	a1 f0       	breq	.+40     	; 0x6120 <__addsf3x+0x96>
    60f8:	ff 0f       	add	r31, r31
    60fa:	bb 1f       	adc	r27, r27
    60fc:	66 1f       	adc	r22, r22
    60fe:	77 1f       	adc	r23, r23
    6100:	88 1f       	adc	r24, r24
    6102:	c2 f7       	brpl	.-16     	; 0x60f4 <__addsf3x+0x6a>
    6104:	0e c0       	rjmp	.+28     	; 0x6122 <__addsf3x+0x98>
    6106:	ba 0f       	add	r27, r26
    6108:	62 1f       	adc	r22, r18
    610a:	73 1f       	adc	r23, r19
    610c:	84 1f       	adc	r24, r20
    610e:	48 f4       	brcc	.+18     	; 0x6122 <__addsf3x+0x98>
    6110:	87 95       	ror	r24
    6112:	77 95       	ror	r23
    6114:	67 95       	ror	r22
    6116:	b7 95       	ror	r27
    6118:	f7 95       	ror	r31
    611a:	9e 3f       	cpi	r25, 0xFE	; 254
    611c:	08 f0       	brcs	.+2      	; 0x6120 <__addsf3x+0x96>
    611e:	b3 cf       	rjmp	.-154    	; 0x6086 <__addsf3+0x1e>
    6120:	93 95       	inc	r25
    6122:	88 0f       	add	r24, r24
    6124:	08 f0       	brcs	.+2      	; 0x6128 <__addsf3x+0x9e>
    6126:	99 27       	eor	r25, r25
    6128:	ee 0f       	add	r30, r30
    612a:	97 95       	ror	r25
    612c:	87 95       	ror	r24
    612e:	08 95       	ret
    6130:	90 d1       	rcall	.+800    	; 0x6452 <__fp_pscA>
    6132:	58 f0       	brcs	.+22     	; 0x614a <__addsf3x+0xc0>
    6134:	80 e8       	ldi	r24, 0x80	; 128
    6136:	91 e0       	ldi	r25, 0x01	; 1
    6138:	09 f4       	brne	.+2      	; 0x613c <__addsf3x+0xb2>
    613a:	9e ef       	ldi	r25, 0xFE	; 254
    613c:	91 d1       	rcall	.+802    	; 0x6460 <__fp_pscB>
    613e:	28 f0       	brcs	.+10     	; 0x614a <__addsf3x+0xc0>
    6140:	40 e8       	ldi	r20, 0x80	; 128
    6142:	51 e0       	ldi	r21, 0x01	; 1
    6144:	59 f4       	brne	.+22     	; 0x615c <atan2+0xe>
    6146:	5e ef       	ldi	r21, 0xFE	; 254
    6148:	09 c0       	rjmp	.+18     	; 0x615c <atan2+0xe>
    614a:	5b c1       	rjmp	.+694    	; 0x6402 <__fp_nan>
    614c:	fc c1       	rjmp	.+1016   	; 0x6546 <__fp_zero>

0000614e <atan2>:
    614e:	e9 2f       	mov	r30, r25
    6150:	e0 78       	andi	r30, 0x80	; 128
    6152:	d7 d1       	rcall	.+942    	; 0x6502 <__fp_split3>
    6154:	68 f3       	brcs	.-38     	; 0x6130 <__addsf3x+0xa6>
    6156:	09 2e       	mov	r0, r25
    6158:	05 2a       	or	r0, r21
    615a:	c1 f3       	breq	.-16     	; 0x614c <__addsf3x+0xc2>
    615c:	26 17       	cp	r18, r22
    615e:	37 07       	cpc	r19, r23
    6160:	48 07       	cpc	r20, r24
    6162:	59 07       	cpc	r21, r25
    6164:	38 f0       	brcs	.+14     	; 0x6174 <atan2+0x26>
    6166:	0e 2e       	mov	r0, r30
    6168:	07 f8       	bld	r0, 7
    616a:	e0 25       	eor	r30, r0
    616c:	69 f0       	breq	.+26     	; 0x6188 <atan2+0x3a>
    616e:	e0 25       	eor	r30, r0
    6170:	e0 64       	ori	r30, 0x40	; 64
    6172:	0a c0       	rjmp	.+20     	; 0x6188 <atan2+0x3a>
    6174:	ef 63       	ori	r30, 0x3F	; 63
    6176:	07 f8       	bld	r0, 7
    6178:	00 94       	com	r0
    617a:	07 fa       	bst	r0, 7
    617c:	db 01       	movw	r26, r22
    617e:	b9 01       	movw	r22, r18
    6180:	9d 01       	movw	r18, r26
    6182:	dc 01       	movw	r26, r24
    6184:	ca 01       	movw	r24, r20
    6186:	ad 01       	movw	r20, r26
    6188:	ef 93       	push	r30
    618a:	4a d0       	rcall	.+148    	; 0x6220 <__divsf3_pse>
    618c:	98 d1       	rcall	.+816    	; 0x64be <__fp_round>
    618e:	0a d0       	rcall	.+20     	; 0x61a4 <atan>
    6190:	5f 91       	pop	r21
    6192:	55 23       	and	r21, r21
    6194:	31 f0       	breq	.+12     	; 0x61a2 <atan2+0x54>
    6196:	2b ed       	ldi	r18, 0xDB	; 219
    6198:	3f e0       	ldi	r19, 0x0F	; 15
    619a:	49 e4       	ldi	r20, 0x49	; 73
    619c:	50 fd       	sbrc	r21, 0
    619e:	49 ec       	ldi	r20, 0xC9	; 201
    61a0:	63 cf       	rjmp	.-314    	; 0x6068 <__addsf3>
    61a2:	08 95       	ret

000061a4 <atan>:
    61a4:	df 93       	push	r29
    61a6:	dd 27       	eor	r29, r29
    61a8:	b9 2f       	mov	r27, r25
    61aa:	bf 77       	andi	r27, 0x7F	; 127
    61ac:	40 e8       	ldi	r20, 0x80	; 128
    61ae:	5f e3       	ldi	r21, 0x3F	; 63
    61b0:	16 16       	cp	r1, r22
    61b2:	17 06       	cpc	r1, r23
    61b4:	48 07       	cpc	r20, r24
    61b6:	5b 07       	cpc	r21, r27
    61b8:	10 f4       	brcc	.+4      	; 0x61be <atan+0x1a>
    61ba:	d9 2f       	mov	r29, r25
    61bc:	cf d1       	rcall	.+926    	; 0x655c <inverse>
    61be:	9f 93       	push	r25
    61c0:	8f 93       	push	r24
    61c2:	7f 93       	push	r23
    61c4:	6f 93       	push	r22
    61c6:	7c d2       	rcall	.+1272   	; 0x66c0 <square>
    61c8:	e4 ee       	ldi	r30, 0xE4	; 228
    61ca:	f0 e0       	ldi	r31, 0x00	; 0
    61cc:	1d d1       	rcall	.+570    	; 0x6408 <__fp_powser>
    61ce:	77 d1       	rcall	.+750    	; 0x64be <__fp_round>
    61d0:	2f 91       	pop	r18
    61d2:	3f 91       	pop	r19
    61d4:	4f 91       	pop	r20
    61d6:	5f 91       	pop	r21
    61d8:	d4 d1       	rcall	.+936    	; 0x6582 <__mulsf3x>
    61da:	dd 23       	and	r29, r29
    61dc:	49 f0       	breq	.+18     	; 0x61f0 <atan+0x4c>
    61de:	90 58       	subi	r25, 0x80	; 128
    61e0:	a2 ea       	ldi	r26, 0xA2	; 162
    61e2:	2a ed       	ldi	r18, 0xDA	; 218
    61e4:	3f e0       	ldi	r19, 0x0F	; 15
    61e6:	49 ec       	ldi	r20, 0xC9	; 201
    61e8:	5f e3       	ldi	r21, 0x3F	; 63
    61ea:	d0 78       	andi	r29, 0x80	; 128
    61ec:	5d 27       	eor	r21, r29
    61ee:	4d df       	rcall	.-358    	; 0x608a <__addsf3x>
    61f0:	df 91       	pop	r29
    61f2:	65 c1       	rjmp	.+714    	; 0x64be <__fp_round>

000061f4 <__cmpsf2>:
    61f4:	dc d0       	rcall	.+440    	; 0x63ae <__fp_cmp>
    61f6:	08 f4       	brcc	.+2      	; 0x61fa <__cmpsf2+0x6>
    61f8:	81 e0       	ldi	r24, 0x01	; 1
    61fa:	08 95       	ret

000061fc <cos>:
    61fc:	39 d1       	rcall	.+626    	; 0x6470 <__fp_rempio2>
    61fe:	e3 95       	inc	r30
    6200:	6f c1       	rjmp	.+734    	; 0x64e0 <__fp_sinus>

00006202 <__divsf3>:
    6202:	0c d0       	rcall	.+24     	; 0x621c <__divsf3x>
    6204:	5c c1       	rjmp	.+696    	; 0x64be <__fp_round>
    6206:	2c d1       	rcall	.+600    	; 0x6460 <__fp_pscB>
    6208:	40 f0       	brcs	.+16     	; 0x621a <__divsf3+0x18>
    620a:	23 d1       	rcall	.+582    	; 0x6452 <__fp_pscA>
    620c:	30 f0       	brcs	.+12     	; 0x621a <__divsf3+0x18>
    620e:	21 f4       	brne	.+8      	; 0x6218 <__divsf3+0x16>
    6210:	5f 3f       	cpi	r21, 0xFF	; 255
    6212:	19 f0       	breq	.+6      	; 0x621a <__divsf3+0x18>
    6214:	f0 c0       	rjmp	.+480    	; 0x63f6 <__fp_inf>
    6216:	51 11       	cpse	r21, r1
    6218:	97 c1       	rjmp	.+814    	; 0x6548 <__fp_szero>
    621a:	f3 c0       	rjmp	.+486    	; 0x6402 <__fp_nan>

0000621c <__divsf3x>:
    621c:	72 d1       	rcall	.+740    	; 0x6502 <__fp_split3>
    621e:	98 f3       	brcs	.-26     	; 0x6206 <__divsf3+0x4>

00006220 <__divsf3_pse>:
    6220:	99 23       	and	r25, r25
    6222:	c9 f3       	breq	.-14     	; 0x6216 <__divsf3+0x14>
    6224:	55 23       	and	r21, r21
    6226:	b1 f3       	breq	.-20     	; 0x6214 <__divsf3+0x12>
    6228:	95 1b       	sub	r25, r21
    622a:	55 0b       	sbc	r21, r21
    622c:	bb 27       	eor	r27, r27
    622e:	aa 27       	eor	r26, r26
    6230:	62 17       	cp	r22, r18
    6232:	73 07       	cpc	r23, r19
    6234:	84 07       	cpc	r24, r20
    6236:	38 f0       	brcs	.+14     	; 0x6246 <__divsf3_pse+0x26>
    6238:	9f 5f       	subi	r25, 0xFF	; 255
    623a:	5f 4f       	sbci	r21, 0xFF	; 255
    623c:	22 0f       	add	r18, r18
    623e:	33 1f       	adc	r19, r19
    6240:	44 1f       	adc	r20, r20
    6242:	aa 1f       	adc	r26, r26
    6244:	a9 f3       	breq	.-22     	; 0x6230 <__divsf3_pse+0x10>
    6246:	33 d0       	rcall	.+102    	; 0x62ae <__divsf3_pse+0x8e>
    6248:	0e 2e       	mov	r0, r30
    624a:	3a f0       	brmi	.+14     	; 0x625a <__divsf3_pse+0x3a>
    624c:	e0 e8       	ldi	r30, 0x80	; 128
    624e:	30 d0       	rcall	.+96     	; 0x62b0 <__divsf3_pse+0x90>
    6250:	91 50       	subi	r25, 0x01	; 1
    6252:	50 40       	sbci	r21, 0x00	; 0
    6254:	e6 95       	lsr	r30
    6256:	00 1c       	adc	r0, r0
    6258:	ca f7       	brpl	.-14     	; 0x624c <__divsf3_pse+0x2c>
    625a:	29 d0       	rcall	.+82     	; 0x62ae <__divsf3_pse+0x8e>
    625c:	fe 2f       	mov	r31, r30
    625e:	27 d0       	rcall	.+78     	; 0x62ae <__divsf3_pse+0x8e>
    6260:	66 0f       	add	r22, r22
    6262:	77 1f       	adc	r23, r23
    6264:	88 1f       	adc	r24, r24
    6266:	bb 1f       	adc	r27, r27
    6268:	26 17       	cp	r18, r22
    626a:	37 07       	cpc	r19, r23
    626c:	48 07       	cpc	r20, r24
    626e:	ab 07       	cpc	r26, r27
    6270:	b0 e8       	ldi	r27, 0x80	; 128
    6272:	09 f0       	breq	.+2      	; 0x6276 <__divsf3_pse+0x56>
    6274:	bb 0b       	sbc	r27, r27
    6276:	80 2d       	mov	r24, r0
    6278:	bf 01       	movw	r22, r30
    627a:	ff 27       	eor	r31, r31
    627c:	93 58       	subi	r25, 0x83	; 131
    627e:	5f 4f       	sbci	r21, 0xFF	; 255
    6280:	2a f0       	brmi	.+10     	; 0x628c <__divsf3_pse+0x6c>
    6282:	9e 3f       	cpi	r25, 0xFE	; 254
    6284:	51 05       	cpc	r21, r1
    6286:	68 f0       	brcs	.+26     	; 0x62a2 <__divsf3_pse+0x82>
    6288:	b6 c0       	rjmp	.+364    	; 0x63f6 <__fp_inf>
    628a:	5e c1       	rjmp	.+700    	; 0x6548 <__fp_szero>
    628c:	5f 3f       	cpi	r21, 0xFF	; 255
    628e:	ec f3       	brlt	.-6      	; 0x628a <__divsf3_pse+0x6a>
    6290:	98 3e       	cpi	r25, 0xE8	; 232
    6292:	dc f3       	brlt	.-10     	; 0x628a <__divsf3_pse+0x6a>
    6294:	86 95       	lsr	r24
    6296:	77 95       	ror	r23
    6298:	67 95       	ror	r22
    629a:	b7 95       	ror	r27
    629c:	f7 95       	ror	r31
    629e:	9f 5f       	subi	r25, 0xFF	; 255
    62a0:	c9 f7       	brne	.-14     	; 0x6294 <__divsf3_pse+0x74>
    62a2:	88 0f       	add	r24, r24
    62a4:	91 1d       	adc	r25, r1
    62a6:	96 95       	lsr	r25
    62a8:	87 95       	ror	r24
    62aa:	97 f9       	bld	r25, 7
    62ac:	08 95       	ret
    62ae:	e1 e0       	ldi	r30, 0x01	; 1
    62b0:	66 0f       	add	r22, r22
    62b2:	77 1f       	adc	r23, r23
    62b4:	88 1f       	adc	r24, r24
    62b6:	bb 1f       	adc	r27, r27
    62b8:	62 17       	cp	r22, r18
    62ba:	73 07       	cpc	r23, r19
    62bc:	84 07       	cpc	r24, r20
    62be:	ba 07       	cpc	r27, r26
    62c0:	20 f0       	brcs	.+8      	; 0x62ca <__divsf3_pse+0xaa>
    62c2:	62 1b       	sub	r22, r18
    62c4:	73 0b       	sbc	r23, r19
    62c6:	84 0b       	sbc	r24, r20
    62c8:	ba 0b       	sbc	r27, r26
    62ca:	ee 1f       	adc	r30, r30
    62cc:	88 f7       	brcc	.-30     	; 0x62b0 <__divsf3_pse+0x90>
    62ce:	e0 95       	com	r30
    62d0:	08 95       	ret

000062d2 <__fixsfsi>:
    62d2:	04 d0       	rcall	.+8      	; 0x62dc <__fixunssfsi>
    62d4:	68 94       	set
    62d6:	b1 11       	cpse	r27, r1
    62d8:	37 c1       	rjmp	.+622    	; 0x6548 <__fp_szero>
    62da:	08 95       	ret

000062dc <__fixunssfsi>:
    62dc:	1a d1       	rcall	.+564    	; 0x6512 <__fp_splitA>
    62de:	88 f0       	brcs	.+34     	; 0x6302 <__fixunssfsi+0x26>
    62e0:	9f 57       	subi	r25, 0x7F	; 127
    62e2:	90 f0       	brcs	.+36     	; 0x6308 <__fixunssfsi+0x2c>
    62e4:	b9 2f       	mov	r27, r25
    62e6:	99 27       	eor	r25, r25
    62e8:	b7 51       	subi	r27, 0x17	; 23
    62ea:	a0 f0       	brcs	.+40     	; 0x6314 <__fixunssfsi+0x38>
    62ec:	d1 f0       	breq	.+52     	; 0x6322 <__fixunssfsi+0x46>
    62ee:	66 0f       	add	r22, r22
    62f0:	77 1f       	adc	r23, r23
    62f2:	88 1f       	adc	r24, r24
    62f4:	99 1f       	adc	r25, r25
    62f6:	1a f0       	brmi	.+6      	; 0x62fe <__fixunssfsi+0x22>
    62f8:	ba 95       	dec	r27
    62fa:	c9 f7       	brne	.-14     	; 0x62ee <__fixunssfsi+0x12>
    62fc:	12 c0       	rjmp	.+36     	; 0x6322 <__fixunssfsi+0x46>
    62fe:	b1 30       	cpi	r27, 0x01	; 1
    6300:	81 f0       	breq	.+32     	; 0x6322 <__fixunssfsi+0x46>
    6302:	21 d1       	rcall	.+578    	; 0x6546 <__fp_zero>
    6304:	b1 e0       	ldi	r27, 0x01	; 1
    6306:	08 95       	ret
    6308:	1e c1       	rjmp	.+572    	; 0x6546 <__fp_zero>
    630a:	67 2f       	mov	r22, r23
    630c:	78 2f       	mov	r23, r24
    630e:	88 27       	eor	r24, r24
    6310:	b8 5f       	subi	r27, 0xF8	; 248
    6312:	39 f0       	breq	.+14     	; 0x6322 <__fixunssfsi+0x46>
    6314:	b9 3f       	cpi	r27, 0xF9	; 249
    6316:	cc f3       	brlt	.-14     	; 0x630a <__fixunssfsi+0x2e>
    6318:	86 95       	lsr	r24
    631a:	77 95       	ror	r23
    631c:	67 95       	ror	r22
    631e:	b3 95       	inc	r27
    6320:	d9 f7       	brne	.-10     	; 0x6318 <__fixunssfsi+0x3c>
    6322:	3e f4       	brtc	.+14     	; 0x6332 <__fixunssfsi+0x56>
    6324:	90 95       	com	r25
    6326:	80 95       	com	r24
    6328:	70 95       	com	r23
    632a:	61 95       	neg	r22
    632c:	7f 4f       	sbci	r23, 0xFF	; 255
    632e:	8f 4f       	sbci	r24, 0xFF	; 255
    6330:	9f 4f       	sbci	r25, 0xFF	; 255
    6332:	08 95       	ret

00006334 <__floatunsisf>:
    6334:	e8 94       	clt
    6336:	09 c0       	rjmp	.+18     	; 0x634a <__floatsisf+0x12>

00006338 <__floatsisf>:
    6338:	97 fb       	bst	r25, 7
    633a:	3e f4       	brtc	.+14     	; 0x634a <__floatsisf+0x12>
    633c:	90 95       	com	r25
    633e:	80 95       	com	r24
    6340:	70 95       	com	r23
    6342:	61 95       	neg	r22
    6344:	7f 4f       	sbci	r23, 0xFF	; 255
    6346:	8f 4f       	sbci	r24, 0xFF	; 255
    6348:	9f 4f       	sbci	r25, 0xFF	; 255
    634a:	99 23       	and	r25, r25
    634c:	a9 f0       	breq	.+42     	; 0x6378 <__floatsisf+0x40>
    634e:	f9 2f       	mov	r31, r25
    6350:	96 e9       	ldi	r25, 0x96	; 150
    6352:	bb 27       	eor	r27, r27
    6354:	93 95       	inc	r25
    6356:	f6 95       	lsr	r31
    6358:	87 95       	ror	r24
    635a:	77 95       	ror	r23
    635c:	67 95       	ror	r22
    635e:	b7 95       	ror	r27
    6360:	f1 11       	cpse	r31, r1
    6362:	f8 cf       	rjmp	.-16     	; 0x6354 <__floatsisf+0x1c>
    6364:	fa f4       	brpl	.+62     	; 0x63a4 <__floatsisf+0x6c>
    6366:	bb 0f       	add	r27, r27
    6368:	11 f4       	brne	.+4      	; 0x636e <__floatsisf+0x36>
    636a:	60 ff       	sbrs	r22, 0
    636c:	1b c0       	rjmp	.+54     	; 0x63a4 <__floatsisf+0x6c>
    636e:	6f 5f       	subi	r22, 0xFF	; 255
    6370:	7f 4f       	sbci	r23, 0xFF	; 255
    6372:	8f 4f       	sbci	r24, 0xFF	; 255
    6374:	9f 4f       	sbci	r25, 0xFF	; 255
    6376:	16 c0       	rjmp	.+44     	; 0x63a4 <__floatsisf+0x6c>
    6378:	88 23       	and	r24, r24
    637a:	11 f0       	breq	.+4      	; 0x6380 <__floatsisf+0x48>
    637c:	96 e9       	ldi	r25, 0x96	; 150
    637e:	11 c0       	rjmp	.+34     	; 0x63a2 <__floatsisf+0x6a>
    6380:	77 23       	and	r23, r23
    6382:	21 f0       	breq	.+8      	; 0x638c <__floatsisf+0x54>
    6384:	9e e8       	ldi	r25, 0x8E	; 142
    6386:	87 2f       	mov	r24, r23
    6388:	76 2f       	mov	r23, r22
    638a:	05 c0       	rjmp	.+10     	; 0x6396 <__floatsisf+0x5e>
    638c:	66 23       	and	r22, r22
    638e:	71 f0       	breq	.+28     	; 0x63ac <__floatsisf+0x74>
    6390:	96 e8       	ldi	r25, 0x86	; 134
    6392:	86 2f       	mov	r24, r22
    6394:	70 e0       	ldi	r23, 0x00	; 0
    6396:	60 e0       	ldi	r22, 0x00	; 0
    6398:	2a f0       	brmi	.+10     	; 0x63a4 <__floatsisf+0x6c>
    639a:	9a 95       	dec	r25
    639c:	66 0f       	add	r22, r22
    639e:	77 1f       	adc	r23, r23
    63a0:	88 1f       	adc	r24, r24
    63a2:	da f7       	brpl	.-10     	; 0x639a <__floatsisf+0x62>
    63a4:	88 0f       	add	r24, r24
    63a6:	96 95       	lsr	r25
    63a8:	87 95       	ror	r24
    63aa:	97 f9       	bld	r25, 7
    63ac:	08 95       	ret

000063ae <__fp_cmp>:
    63ae:	99 0f       	add	r25, r25
    63b0:	00 08       	sbc	r0, r0
    63b2:	55 0f       	add	r21, r21
    63b4:	aa 0b       	sbc	r26, r26
    63b6:	e0 e8       	ldi	r30, 0x80	; 128
    63b8:	fe ef       	ldi	r31, 0xFE	; 254
    63ba:	16 16       	cp	r1, r22
    63bc:	17 06       	cpc	r1, r23
    63be:	e8 07       	cpc	r30, r24
    63c0:	f9 07       	cpc	r31, r25
    63c2:	c0 f0       	brcs	.+48     	; 0x63f4 <__fp_cmp+0x46>
    63c4:	12 16       	cp	r1, r18
    63c6:	13 06       	cpc	r1, r19
    63c8:	e4 07       	cpc	r30, r20
    63ca:	f5 07       	cpc	r31, r21
    63cc:	98 f0       	brcs	.+38     	; 0x63f4 <__fp_cmp+0x46>
    63ce:	62 1b       	sub	r22, r18
    63d0:	73 0b       	sbc	r23, r19
    63d2:	84 0b       	sbc	r24, r20
    63d4:	95 0b       	sbc	r25, r21
    63d6:	39 f4       	brne	.+14     	; 0x63e6 <__fp_cmp+0x38>
    63d8:	0a 26       	eor	r0, r26
    63da:	61 f0       	breq	.+24     	; 0x63f4 <__fp_cmp+0x46>
    63dc:	23 2b       	or	r18, r19
    63de:	24 2b       	or	r18, r20
    63e0:	25 2b       	or	r18, r21
    63e2:	21 f4       	brne	.+8      	; 0x63ec <__fp_cmp+0x3e>
    63e4:	08 95       	ret
    63e6:	0a 26       	eor	r0, r26
    63e8:	09 f4       	brne	.+2      	; 0x63ec <__fp_cmp+0x3e>
    63ea:	a1 40       	sbci	r26, 0x01	; 1
    63ec:	a6 95       	lsr	r26
    63ee:	8f ef       	ldi	r24, 0xFF	; 255
    63f0:	81 1d       	adc	r24, r1
    63f2:	81 1d       	adc	r24, r1
    63f4:	08 95       	ret

000063f6 <__fp_inf>:
    63f6:	97 f9       	bld	r25, 7
    63f8:	9f 67       	ori	r25, 0x7F	; 127
    63fa:	80 e8       	ldi	r24, 0x80	; 128
    63fc:	70 e0       	ldi	r23, 0x00	; 0
    63fe:	60 e0       	ldi	r22, 0x00	; 0
    6400:	08 95       	ret

00006402 <__fp_nan>:
    6402:	9f ef       	ldi	r25, 0xFF	; 255
    6404:	80 ec       	ldi	r24, 0xC0	; 192
    6406:	08 95       	ret

00006408 <__fp_powser>:
    6408:	df 93       	push	r29
    640a:	cf 93       	push	r28
    640c:	1f 93       	push	r17
    640e:	0f 93       	push	r16
    6410:	ff 92       	push	r15
    6412:	ef 92       	push	r14
    6414:	df 92       	push	r13
    6416:	7b 01       	movw	r14, r22
    6418:	8c 01       	movw	r16, r24
    641a:	68 94       	set
    641c:	05 c0       	rjmp	.+10     	; 0x6428 <__fp_powser+0x20>
    641e:	da 2e       	mov	r13, r26
    6420:	ef 01       	movw	r28, r30
    6422:	af d0       	rcall	.+350    	; 0x6582 <__mulsf3x>
    6424:	fe 01       	movw	r30, r28
    6426:	e8 94       	clt
    6428:	a5 91       	lpm	r26, Z+
    642a:	25 91       	lpm	r18, Z+
    642c:	35 91       	lpm	r19, Z+
    642e:	45 91       	lpm	r20, Z+
    6430:	55 91       	lpm	r21, Z+
    6432:	ae f3       	brts	.-22     	; 0x641e <__fp_powser+0x16>
    6434:	ef 01       	movw	r28, r30
    6436:	29 de       	rcall	.-942    	; 0x608a <__addsf3x>
    6438:	fe 01       	movw	r30, r28
    643a:	97 01       	movw	r18, r14
    643c:	a8 01       	movw	r20, r16
    643e:	da 94       	dec	r13
    6440:	79 f7       	brne	.-34     	; 0x6420 <__fp_powser+0x18>
    6442:	df 90       	pop	r13
    6444:	ef 90       	pop	r14
    6446:	ff 90       	pop	r15
    6448:	0f 91       	pop	r16
    644a:	1f 91       	pop	r17
    644c:	cf 91       	pop	r28
    644e:	df 91       	pop	r29
    6450:	08 95       	ret

00006452 <__fp_pscA>:
    6452:	00 24       	eor	r0, r0
    6454:	0a 94       	dec	r0
    6456:	16 16       	cp	r1, r22
    6458:	17 06       	cpc	r1, r23
    645a:	18 06       	cpc	r1, r24
    645c:	09 06       	cpc	r0, r25
    645e:	08 95       	ret

00006460 <__fp_pscB>:
    6460:	00 24       	eor	r0, r0
    6462:	0a 94       	dec	r0
    6464:	12 16       	cp	r1, r18
    6466:	13 06       	cpc	r1, r19
    6468:	14 06       	cpc	r1, r20
    646a:	05 06       	cpc	r0, r21
    646c:	08 95       	ret
    646e:	c9 cf       	rjmp	.-110    	; 0x6402 <__fp_nan>

00006470 <__fp_rempio2>:
    6470:	50 d0       	rcall	.+160    	; 0x6512 <__fp_splitA>
    6472:	e8 f3       	brcs	.-6      	; 0x646e <__fp_pscB+0xe>
    6474:	e8 94       	clt
    6476:	e0 e0       	ldi	r30, 0x00	; 0
    6478:	bb 27       	eor	r27, r27
    647a:	9f 57       	subi	r25, 0x7F	; 127
    647c:	f0 f0       	brcs	.+60     	; 0x64ba <__fp_rempio2+0x4a>
    647e:	2a ed       	ldi	r18, 0xDA	; 218
    6480:	3f e0       	ldi	r19, 0x0F	; 15
    6482:	49 ec       	ldi	r20, 0xC9	; 201
    6484:	06 c0       	rjmp	.+12     	; 0x6492 <__fp_rempio2+0x22>
    6486:	ee 0f       	add	r30, r30
    6488:	bb 0f       	add	r27, r27
    648a:	66 1f       	adc	r22, r22
    648c:	77 1f       	adc	r23, r23
    648e:	88 1f       	adc	r24, r24
    6490:	28 f0       	brcs	.+10     	; 0x649c <__fp_rempio2+0x2c>
    6492:	b2 3a       	cpi	r27, 0xA2	; 162
    6494:	62 07       	cpc	r22, r18
    6496:	73 07       	cpc	r23, r19
    6498:	84 07       	cpc	r24, r20
    649a:	28 f0       	brcs	.+10     	; 0x64a6 <__fp_rempio2+0x36>
    649c:	b2 5a       	subi	r27, 0xA2	; 162
    649e:	62 0b       	sbc	r22, r18
    64a0:	73 0b       	sbc	r23, r19
    64a2:	84 0b       	sbc	r24, r20
    64a4:	e3 95       	inc	r30
    64a6:	9a 95       	dec	r25
    64a8:	72 f7       	brpl	.-36     	; 0x6486 <__fp_rempio2+0x16>
    64aa:	80 38       	cpi	r24, 0x80	; 128
    64ac:	30 f4       	brcc	.+12     	; 0x64ba <__fp_rempio2+0x4a>
    64ae:	9a 95       	dec	r25
    64b0:	bb 0f       	add	r27, r27
    64b2:	66 1f       	adc	r22, r22
    64b4:	77 1f       	adc	r23, r23
    64b6:	88 1f       	adc	r24, r24
    64b8:	d2 f7       	brpl	.-12     	; 0x64ae <__fp_rempio2+0x3e>
    64ba:	90 48       	sbci	r25, 0x80	; 128
    64bc:	06 c1       	rjmp	.+524    	; 0x66ca <__fp_mpack_finite>

000064be <__fp_round>:
    64be:	09 2e       	mov	r0, r25
    64c0:	03 94       	inc	r0
    64c2:	00 0c       	add	r0, r0
    64c4:	11 f4       	brne	.+4      	; 0x64ca <__fp_round+0xc>
    64c6:	88 23       	and	r24, r24
    64c8:	52 f0       	brmi	.+20     	; 0x64de <__fp_round+0x20>
    64ca:	bb 0f       	add	r27, r27
    64cc:	40 f4       	brcc	.+16     	; 0x64de <__fp_round+0x20>
    64ce:	bf 2b       	or	r27, r31
    64d0:	11 f4       	brne	.+4      	; 0x64d6 <__fp_round+0x18>
    64d2:	60 ff       	sbrs	r22, 0
    64d4:	04 c0       	rjmp	.+8      	; 0x64de <__fp_round+0x20>
    64d6:	6f 5f       	subi	r22, 0xFF	; 255
    64d8:	7f 4f       	sbci	r23, 0xFF	; 255
    64da:	8f 4f       	sbci	r24, 0xFF	; 255
    64dc:	9f 4f       	sbci	r25, 0xFF	; 255
    64de:	08 95       	ret

000064e0 <__fp_sinus>:
    64e0:	ef 93       	push	r30
    64e2:	e0 ff       	sbrs	r30, 0
    64e4:	06 c0       	rjmp	.+12     	; 0x64f2 <__fp_sinus+0x12>
    64e6:	a2 ea       	ldi	r26, 0xA2	; 162
    64e8:	2a ed       	ldi	r18, 0xDA	; 218
    64ea:	3f e0       	ldi	r19, 0x0F	; 15
    64ec:	49 ec       	ldi	r20, 0xC9	; 201
    64ee:	5f eb       	ldi	r21, 0xBF	; 191
    64f0:	cc dd       	rcall	.-1128   	; 0x608a <__addsf3x>
    64f2:	e5 df       	rcall	.-54     	; 0x64be <__fp_round>
    64f4:	0f 90       	pop	r0
    64f6:	03 94       	inc	r0
    64f8:	01 fc       	sbrc	r0, 1
    64fa:	90 58       	subi	r25, 0x80	; 128
    64fc:	e1 e1       	ldi	r30, 0x11	; 17
    64fe:	f1 e0       	ldi	r31, 0x01	; 1
    6500:	f7 c0       	rjmp	.+494    	; 0x66f0 <__fp_powsodd>

00006502 <__fp_split3>:
    6502:	57 fd       	sbrc	r21, 7
    6504:	90 58       	subi	r25, 0x80	; 128
    6506:	44 0f       	add	r20, r20
    6508:	55 1f       	adc	r21, r21
    650a:	59 f0       	breq	.+22     	; 0x6522 <__fp_splitA+0x10>
    650c:	5f 3f       	cpi	r21, 0xFF	; 255
    650e:	71 f0       	breq	.+28     	; 0x652c <__fp_splitA+0x1a>
    6510:	47 95       	ror	r20

00006512 <__fp_splitA>:
    6512:	88 0f       	add	r24, r24
    6514:	97 fb       	bst	r25, 7
    6516:	99 1f       	adc	r25, r25
    6518:	61 f0       	breq	.+24     	; 0x6532 <__fp_splitA+0x20>
    651a:	9f 3f       	cpi	r25, 0xFF	; 255
    651c:	79 f0       	breq	.+30     	; 0x653c <__fp_splitA+0x2a>
    651e:	87 95       	ror	r24
    6520:	08 95       	ret
    6522:	12 16       	cp	r1, r18
    6524:	13 06       	cpc	r1, r19
    6526:	14 06       	cpc	r1, r20
    6528:	55 1f       	adc	r21, r21
    652a:	f2 cf       	rjmp	.-28     	; 0x6510 <__fp_split3+0xe>
    652c:	46 95       	lsr	r20
    652e:	f1 df       	rcall	.-30     	; 0x6512 <__fp_splitA>
    6530:	08 c0       	rjmp	.+16     	; 0x6542 <__fp_splitA+0x30>
    6532:	16 16       	cp	r1, r22
    6534:	17 06       	cpc	r1, r23
    6536:	18 06       	cpc	r1, r24
    6538:	99 1f       	adc	r25, r25
    653a:	f1 cf       	rjmp	.-30     	; 0x651e <__fp_splitA+0xc>
    653c:	86 95       	lsr	r24
    653e:	71 05       	cpc	r23, r1
    6540:	61 05       	cpc	r22, r1
    6542:	08 94       	sec
    6544:	08 95       	ret

00006546 <__fp_zero>:
    6546:	e8 94       	clt

00006548 <__fp_szero>:
    6548:	bb 27       	eor	r27, r27
    654a:	66 27       	eor	r22, r22
    654c:	77 27       	eor	r23, r23
    654e:	cb 01       	movw	r24, r22
    6550:	97 f9       	bld	r25, 7
    6552:	08 95       	ret

00006554 <__gesf2>:
    6554:	2c df       	rcall	.-424    	; 0x63ae <__fp_cmp>
    6556:	08 f4       	brcc	.+2      	; 0x655a <__gesf2+0x6>
    6558:	8f ef       	ldi	r24, 0xFF	; 255
    655a:	08 95       	ret

0000655c <inverse>:
    655c:	9b 01       	movw	r18, r22
    655e:	ac 01       	movw	r20, r24
    6560:	60 e0       	ldi	r22, 0x00	; 0
    6562:	70 e0       	ldi	r23, 0x00	; 0
    6564:	80 e8       	ldi	r24, 0x80	; 128
    6566:	9f e3       	ldi	r25, 0x3F	; 63
    6568:	4c ce       	rjmp	.-872    	; 0x6202 <__divsf3>

0000656a <__mulsf3>:
    656a:	0b d0       	rcall	.+22     	; 0x6582 <__mulsf3x>
    656c:	a8 cf       	rjmp	.-176    	; 0x64be <__fp_round>
    656e:	71 df       	rcall	.-286    	; 0x6452 <__fp_pscA>
    6570:	28 f0       	brcs	.+10     	; 0x657c <__mulsf3+0x12>
    6572:	76 df       	rcall	.-276    	; 0x6460 <__fp_pscB>
    6574:	18 f0       	brcs	.+6      	; 0x657c <__mulsf3+0x12>
    6576:	95 23       	and	r25, r21
    6578:	09 f0       	breq	.+2      	; 0x657c <__mulsf3+0x12>
    657a:	3d cf       	rjmp	.-390    	; 0x63f6 <__fp_inf>
    657c:	42 cf       	rjmp	.-380    	; 0x6402 <__fp_nan>
    657e:	11 24       	eor	r1, r1
    6580:	e3 cf       	rjmp	.-58     	; 0x6548 <__fp_szero>

00006582 <__mulsf3x>:
    6582:	bf df       	rcall	.-130    	; 0x6502 <__fp_split3>
    6584:	a0 f3       	brcs	.-24     	; 0x656e <__mulsf3+0x4>

00006586 <__mulsf3_pse>:
    6586:	95 9f       	mul	r25, r21
    6588:	d1 f3       	breq	.-12     	; 0x657e <__mulsf3+0x14>
    658a:	95 0f       	add	r25, r21
    658c:	50 e0       	ldi	r21, 0x00	; 0
    658e:	55 1f       	adc	r21, r21
    6590:	62 9f       	mul	r22, r18
    6592:	f0 01       	movw	r30, r0
    6594:	72 9f       	mul	r23, r18
    6596:	bb 27       	eor	r27, r27
    6598:	f0 0d       	add	r31, r0
    659a:	b1 1d       	adc	r27, r1
    659c:	63 9f       	mul	r22, r19
    659e:	aa 27       	eor	r26, r26
    65a0:	f0 0d       	add	r31, r0
    65a2:	b1 1d       	adc	r27, r1
    65a4:	aa 1f       	adc	r26, r26
    65a6:	64 9f       	mul	r22, r20
    65a8:	66 27       	eor	r22, r22
    65aa:	b0 0d       	add	r27, r0
    65ac:	a1 1d       	adc	r26, r1
    65ae:	66 1f       	adc	r22, r22
    65b0:	82 9f       	mul	r24, r18
    65b2:	22 27       	eor	r18, r18
    65b4:	b0 0d       	add	r27, r0
    65b6:	a1 1d       	adc	r26, r1
    65b8:	62 1f       	adc	r22, r18
    65ba:	73 9f       	mul	r23, r19
    65bc:	b0 0d       	add	r27, r0
    65be:	a1 1d       	adc	r26, r1
    65c0:	62 1f       	adc	r22, r18
    65c2:	83 9f       	mul	r24, r19
    65c4:	a0 0d       	add	r26, r0
    65c6:	61 1d       	adc	r22, r1
    65c8:	22 1f       	adc	r18, r18
    65ca:	74 9f       	mul	r23, r20
    65cc:	33 27       	eor	r19, r19
    65ce:	a0 0d       	add	r26, r0
    65d0:	61 1d       	adc	r22, r1
    65d2:	23 1f       	adc	r18, r19
    65d4:	84 9f       	mul	r24, r20
    65d6:	60 0d       	add	r22, r0
    65d8:	21 1d       	adc	r18, r1
    65da:	82 2f       	mov	r24, r18
    65dc:	76 2f       	mov	r23, r22
    65de:	6a 2f       	mov	r22, r26
    65e0:	11 24       	eor	r1, r1
    65e2:	9f 57       	subi	r25, 0x7F	; 127
    65e4:	50 40       	sbci	r21, 0x00	; 0
    65e6:	8a f0       	brmi	.+34     	; 0x660a <__mulsf3_pse+0x84>
    65e8:	e1 f0       	breq	.+56     	; 0x6622 <__mulsf3_pse+0x9c>
    65ea:	88 23       	and	r24, r24
    65ec:	4a f0       	brmi	.+18     	; 0x6600 <__mulsf3_pse+0x7a>
    65ee:	ee 0f       	add	r30, r30
    65f0:	ff 1f       	adc	r31, r31
    65f2:	bb 1f       	adc	r27, r27
    65f4:	66 1f       	adc	r22, r22
    65f6:	77 1f       	adc	r23, r23
    65f8:	88 1f       	adc	r24, r24
    65fa:	91 50       	subi	r25, 0x01	; 1
    65fc:	50 40       	sbci	r21, 0x00	; 0
    65fe:	a9 f7       	brne	.-22     	; 0x65ea <__mulsf3_pse+0x64>
    6600:	9e 3f       	cpi	r25, 0xFE	; 254
    6602:	51 05       	cpc	r21, r1
    6604:	70 f0       	brcs	.+28     	; 0x6622 <__mulsf3_pse+0x9c>
    6606:	f7 ce       	rjmp	.-530    	; 0x63f6 <__fp_inf>
    6608:	9f cf       	rjmp	.-194    	; 0x6548 <__fp_szero>
    660a:	5f 3f       	cpi	r21, 0xFF	; 255
    660c:	ec f3       	brlt	.-6      	; 0x6608 <__mulsf3_pse+0x82>
    660e:	98 3e       	cpi	r25, 0xE8	; 232
    6610:	dc f3       	brlt	.-10     	; 0x6608 <__mulsf3_pse+0x82>
    6612:	86 95       	lsr	r24
    6614:	77 95       	ror	r23
    6616:	67 95       	ror	r22
    6618:	b7 95       	ror	r27
    661a:	f7 95       	ror	r31
    661c:	e7 95       	ror	r30
    661e:	9f 5f       	subi	r25, 0xFF	; 255
    6620:	c1 f7       	brne	.-16     	; 0x6612 <__mulsf3_pse+0x8c>
    6622:	fe 2b       	or	r31, r30
    6624:	88 0f       	add	r24, r24
    6626:	91 1d       	adc	r25, r1
    6628:	96 95       	lsr	r25
    662a:	87 95       	ror	r24
    662c:	97 f9       	bld	r25, 7
    662e:	08 95       	ret

00006630 <sin>:
    6630:	9f 93       	push	r25
    6632:	1e df       	rcall	.-452    	; 0x6470 <__fp_rempio2>
    6634:	0f 90       	pop	r0
    6636:	07 fc       	sbrc	r0, 7
    6638:	ee 5f       	subi	r30, 0xFE	; 254
    663a:	52 cf       	rjmp	.-348    	; 0x64e0 <__fp_sinus>
    663c:	11 f4       	brne	.+4      	; 0x6642 <sin+0x12>
    663e:	0e f4       	brtc	.+2      	; 0x6642 <sin+0x12>
    6640:	e0 ce       	rjmp	.-576    	; 0x6402 <__fp_nan>
    6642:	41 c0       	rjmp	.+130    	; 0x66c6 <__fp_mpack>

00006644 <sqrt>:
    6644:	66 df       	rcall	.-308    	; 0x6512 <__fp_splitA>
    6646:	d0 f3       	brcs	.-12     	; 0x663c <sin+0xc>
    6648:	99 23       	and	r25, r25
    664a:	d9 f3       	breq	.-10     	; 0x6642 <sin+0x12>
    664c:	ce f3       	brts	.-14     	; 0x6640 <sin+0x10>
    664e:	9f 57       	subi	r25, 0x7F	; 127
    6650:	55 0b       	sbc	r21, r21
    6652:	87 ff       	sbrs	r24, 7
    6654:	46 d0       	rcall	.+140    	; 0x66e2 <__fp_norm2>
    6656:	00 24       	eor	r0, r0
    6658:	a0 e6       	ldi	r26, 0x60	; 96
    665a:	40 ea       	ldi	r20, 0xA0	; 160
    665c:	90 01       	movw	r18, r0
    665e:	80 58       	subi	r24, 0x80	; 128
    6660:	56 95       	lsr	r21
    6662:	97 95       	ror	r25
    6664:	28 f4       	brcc	.+10     	; 0x6670 <sqrt+0x2c>
    6666:	80 5c       	subi	r24, 0xC0	; 192
    6668:	66 0f       	add	r22, r22
    666a:	77 1f       	adc	r23, r23
    666c:	88 1f       	adc	r24, r24
    666e:	20 f0       	brcs	.+8      	; 0x6678 <sqrt+0x34>
    6670:	26 17       	cp	r18, r22
    6672:	37 07       	cpc	r19, r23
    6674:	48 07       	cpc	r20, r24
    6676:	30 f4       	brcc	.+12     	; 0x6684 <sqrt+0x40>
    6678:	62 1b       	sub	r22, r18
    667a:	73 0b       	sbc	r23, r19
    667c:	84 0b       	sbc	r24, r20
    667e:	20 29       	or	r18, r0
    6680:	31 29       	or	r19, r1
    6682:	4a 2b       	or	r20, r26
    6684:	a6 95       	lsr	r26
    6686:	17 94       	ror	r1
    6688:	07 94       	ror	r0
    668a:	20 25       	eor	r18, r0
    668c:	31 25       	eor	r19, r1
    668e:	4a 27       	eor	r20, r26
    6690:	58 f7       	brcc	.-42     	; 0x6668 <sqrt+0x24>
    6692:	66 0f       	add	r22, r22
    6694:	77 1f       	adc	r23, r23
    6696:	88 1f       	adc	r24, r24
    6698:	20 f0       	brcs	.+8      	; 0x66a2 <sqrt+0x5e>
    669a:	26 17       	cp	r18, r22
    669c:	37 07       	cpc	r19, r23
    669e:	48 07       	cpc	r20, r24
    66a0:	30 f4       	brcc	.+12     	; 0x66ae <sqrt+0x6a>
    66a2:	62 0b       	sbc	r22, r18
    66a4:	73 0b       	sbc	r23, r19
    66a6:	84 0b       	sbc	r24, r20
    66a8:	20 0d       	add	r18, r0
    66aa:	31 1d       	adc	r19, r1
    66ac:	41 1d       	adc	r20, r1
    66ae:	a0 95       	com	r26
    66b0:	81 f7       	brne	.-32     	; 0x6692 <sqrt+0x4e>
    66b2:	b9 01       	movw	r22, r18
    66b4:	84 2f       	mov	r24, r20
    66b6:	91 58       	subi	r25, 0x81	; 129
    66b8:	88 0f       	add	r24, r24
    66ba:	96 95       	lsr	r25
    66bc:	87 95       	ror	r24
    66be:	08 95       	ret

000066c0 <square>:
    66c0:	9b 01       	movw	r18, r22
    66c2:	ac 01       	movw	r20, r24
    66c4:	52 cf       	rjmp	.-348    	; 0x656a <__mulsf3>

000066c6 <__fp_mpack>:
    66c6:	9f 3f       	cpi	r25, 0xFF	; 255
    66c8:	31 f0       	breq	.+12     	; 0x66d6 <__fp_mpack_finite+0xc>

000066ca <__fp_mpack_finite>:
    66ca:	91 50       	subi	r25, 0x01	; 1
    66cc:	20 f4       	brcc	.+8      	; 0x66d6 <__fp_mpack_finite+0xc>
    66ce:	87 95       	ror	r24
    66d0:	77 95       	ror	r23
    66d2:	67 95       	ror	r22
    66d4:	b7 95       	ror	r27
    66d6:	88 0f       	add	r24, r24
    66d8:	91 1d       	adc	r25, r1
    66da:	96 95       	lsr	r25
    66dc:	87 95       	ror	r24
    66de:	97 f9       	bld	r25, 7
    66e0:	08 95       	ret

000066e2 <__fp_norm2>:
    66e2:	91 50       	subi	r25, 0x01	; 1
    66e4:	50 40       	sbci	r21, 0x00	; 0
    66e6:	66 0f       	add	r22, r22
    66e8:	77 1f       	adc	r23, r23
    66ea:	88 1f       	adc	r24, r24
    66ec:	d2 f7       	brpl	.-12     	; 0x66e2 <__fp_norm2>
    66ee:	08 95       	ret

000066f0 <__fp_powsodd>:
    66f0:	9f 93       	push	r25
    66f2:	8f 93       	push	r24
    66f4:	7f 93       	push	r23
    66f6:	6f 93       	push	r22
    66f8:	ff 93       	push	r31
    66fa:	ef 93       	push	r30
    66fc:	9b 01       	movw	r18, r22
    66fe:	ac 01       	movw	r20, r24
    6700:	34 df       	rcall	.-408    	; 0x656a <__mulsf3>
    6702:	ef 91       	pop	r30
    6704:	ff 91       	pop	r31
    6706:	80 de       	rcall	.-768    	; 0x6408 <__fp_powser>
    6708:	2f 91       	pop	r18
    670a:	3f 91       	pop	r19
    670c:	4f 91       	pop	r20
    670e:	5f 91       	pop	r21
    6710:	2c cf       	rjmp	.-424    	; 0x656a <__mulsf3>

00006712 <vfprintf>:
    6712:	2f 92       	push	r2
    6714:	3f 92       	push	r3
    6716:	4f 92       	push	r4
    6718:	5f 92       	push	r5
    671a:	6f 92       	push	r6
    671c:	7f 92       	push	r7
    671e:	8f 92       	push	r8
    6720:	9f 92       	push	r9
    6722:	af 92       	push	r10
    6724:	bf 92       	push	r11
    6726:	cf 92       	push	r12
    6728:	df 92       	push	r13
    672a:	ef 92       	push	r14
    672c:	ff 92       	push	r15
    672e:	0f 93       	push	r16
    6730:	1f 93       	push	r17
    6732:	cf 93       	push	r28
    6734:	df 93       	push	r29
    6736:	cd b7       	in	r28, 0x3d	; 61
    6738:	de b7       	in	r29, 0x3e	; 62
    673a:	60 97       	sbiw	r28, 0x10	; 16
    673c:	0f b6       	in	r0, 0x3f	; 63
    673e:	f8 94       	cli
    6740:	de bf       	out	0x3e, r29	; 62
    6742:	0f be       	out	0x3f, r0	; 63
    6744:	cd bf       	out	0x3d, r28	; 61
    6746:	7c 01       	movw	r14, r24
    6748:	1b 01       	movw	r2, r22
    674a:	6a 01       	movw	r12, r20
    674c:	fc 01       	movw	r30, r24
    674e:	17 82       	std	Z+7, r1	; 0x07
    6750:	16 82       	std	Z+6, r1	; 0x06
    6752:	83 81       	ldd	r24, Z+3	; 0x03
    6754:	81 ff       	sbrs	r24, 1
    6756:	2a c3       	rjmp	.+1620   	; 0x6dac <vfprintf+0x69a>
    6758:	9e 01       	movw	r18, r28
    675a:	2f 5f       	subi	r18, 0xFF	; 255
    675c:	3f 4f       	sbci	r19, 0xFF	; 255
    675e:	39 01       	movw	r6, r18
    6760:	f7 01       	movw	r30, r14
    6762:	93 81       	ldd	r25, Z+3	; 0x03
    6764:	f1 01       	movw	r30, r2
    6766:	93 fd       	sbrc	r25, 3
    6768:	85 91       	lpm	r24, Z+
    676a:	93 ff       	sbrs	r25, 3
    676c:	81 91       	ld	r24, Z+
    676e:	1f 01       	movw	r2, r30
    6770:	88 23       	and	r24, r24
    6772:	09 f4       	brne	.+2      	; 0x6776 <vfprintf+0x64>
    6774:	17 c3       	rjmp	.+1582   	; 0x6da4 <vfprintf+0x692>
    6776:	85 32       	cpi	r24, 0x25	; 37
    6778:	39 f4       	brne	.+14     	; 0x6788 <vfprintf+0x76>
    677a:	93 fd       	sbrc	r25, 3
    677c:	85 91       	lpm	r24, Z+
    677e:	93 ff       	sbrs	r25, 3
    6780:	81 91       	ld	r24, Z+
    6782:	1f 01       	movw	r2, r30
    6784:	85 32       	cpi	r24, 0x25	; 37
    6786:	31 f4       	brne	.+12     	; 0x6794 <vfprintf+0x82>
    6788:	b7 01       	movw	r22, r14
    678a:	90 e0       	ldi	r25, 0x00	; 0
    678c:	78 d4       	rcall	.+2288   	; 0x707e <fputc>
    678e:	56 01       	movw	r10, r12
    6790:	65 01       	movw	r12, r10
    6792:	e6 cf       	rjmp	.-52     	; 0x6760 <vfprintf+0x4e>
    6794:	10 e0       	ldi	r17, 0x00	; 0
    6796:	51 2c       	mov	r5, r1
    6798:	91 2c       	mov	r9, r1
    679a:	ff e1       	ldi	r31, 0x1F	; 31
    679c:	f9 15       	cp	r31, r9
    679e:	d8 f0       	brcs	.+54     	; 0x67d6 <vfprintf+0xc4>
    67a0:	8b 32       	cpi	r24, 0x2B	; 43
    67a2:	79 f0       	breq	.+30     	; 0x67c2 <vfprintf+0xb0>
    67a4:	38 f4       	brcc	.+14     	; 0x67b4 <vfprintf+0xa2>
    67a6:	80 32       	cpi	r24, 0x20	; 32
    67a8:	79 f0       	breq	.+30     	; 0x67c8 <vfprintf+0xb6>
    67aa:	83 32       	cpi	r24, 0x23	; 35
    67ac:	a1 f4       	brne	.+40     	; 0x67d6 <vfprintf+0xc4>
    67ae:	f9 2d       	mov	r31, r9
    67b0:	f0 61       	ori	r31, 0x10	; 16
    67b2:	2e c0       	rjmp	.+92     	; 0x6810 <vfprintf+0xfe>
    67b4:	8d 32       	cpi	r24, 0x2D	; 45
    67b6:	61 f0       	breq	.+24     	; 0x67d0 <vfprintf+0xbe>
    67b8:	80 33       	cpi	r24, 0x30	; 48
    67ba:	69 f4       	brne	.+26     	; 0x67d6 <vfprintf+0xc4>
    67bc:	29 2d       	mov	r18, r9
    67be:	21 60       	ori	r18, 0x01	; 1
    67c0:	2d c0       	rjmp	.+90     	; 0x681c <vfprintf+0x10a>
    67c2:	39 2d       	mov	r19, r9
    67c4:	32 60       	ori	r19, 0x02	; 2
    67c6:	93 2e       	mov	r9, r19
    67c8:	89 2d       	mov	r24, r9
    67ca:	84 60       	ori	r24, 0x04	; 4
    67cc:	98 2e       	mov	r9, r24
    67ce:	2a c0       	rjmp	.+84     	; 0x6824 <vfprintf+0x112>
    67d0:	e9 2d       	mov	r30, r9
    67d2:	e8 60       	ori	r30, 0x08	; 8
    67d4:	15 c0       	rjmp	.+42     	; 0x6800 <vfprintf+0xee>
    67d6:	97 fc       	sbrc	r9, 7
    67d8:	2d c0       	rjmp	.+90     	; 0x6834 <vfprintf+0x122>
    67da:	20 ed       	ldi	r18, 0xD0	; 208
    67dc:	28 0f       	add	r18, r24
    67de:	2a 30       	cpi	r18, 0x0A	; 10
    67e0:	88 f4       	brcc	.+34     	; 0x6804 <vfprintf+0xf2>
    67e2:	96 fe       	sbrs	r9, 6
    67e4:	06 c0       	rjmp	.+12     	; 0x67f2 <vfprintf+0xe0>
    67e6:	3a e0       	ldi	r19, 0x0A	; 10
    67e8:	13 9f       	mul	r17, r19
    67ea:	20 0d       	add	r18, r0
    67ec:	11 24       	eor	r1, r1
    67ee:	12 2f       	mov	r17, r18
    67f0:	19 c0       	rjmp	.+50     	; 0x6824 <vfprintf+0x112>
    67f2:	8a e0       	ldi	r24, 0x0A	; 10
    67f4:	58 9e       	mul	r5, r24
    67f6:	20 0d       	add	r18, r0
    67f8:	11 24       	eor	r1, r1
    67fa:	52 2e       	mov	r5, r18
    67fc:	e9 2d       	mov	r30, r9
    67fe:	e0 62       	ori	r30, 0x20	; 32
    6800:	9e 2e       	mov	r9, r30
    6802:	10 c0       	rjmp	.+32     	; 0x6824 <vfprintf+0x112>
    6804:	8e 32       	cpi	r24, 0x2E	; 46
    6806:	31 f4       	brne	.+12     	; 0x6814 <vfprintf+0x102>
    6808:	96 fc       	sbrc	r9, 6
    680a:	cc c2       	rjmp	.+1432   	; 0x6da4 <vfprintf+0x692>
    680c:	f9 2d       	mov	r31, r9
    680e:	f0 64       	ori	r31, 0x40	; 64
    6810:	9f 2e       	mov	r9, r31
    6812:	08 c0       	rjmp	.+16     	; 0x6824 <vfprintf+0x112>
    6814:	8c 36       	cpi	r24, 0x6C	; 108
    6816:	21 f4       	brne	.+8      	; 0x6820 <vfprintf+0x10e>
    6818:	29 2d       	mov	r18, r9
    681a:	20 68       	ori	r18, 0x80	; 128
    681c:	92 2e       	mov	r9, r18
    681e:	02 c0       	rjmp	.+4      	; 0x6824 <vfprintf+0x112>
    6820:	88 36       	cpi	r24, 0x68	; 104
    6822:	41 f4       	brne	.+16     	; 0x6834 <vfprintf+0x122>
    6824:	f1 01       	movw	r30, r2
    6826:	93 fd       	sbrc	r25, 3
    6828:	85 91       	lpm	r24, Z+
    682a:	93 ff       	sbrs	r25, 3
    682c:	81 91       	ld	r24, Z+
    682e:	1f 01       	movw	r2, r30
    6830:	81 11       	cpse	r24, r1
    6832:	b3 cf       	rjmp	.-154    	; 0x679a <vfprintf+0x88>
    6834:	9b eb       	ldi	r25, 0xBB	; 187
    6836:	98 0f       	add	r25, r24
    6838:	93 30       	cpi	r25, 0x03	; 3
    683a:	20 f4       	brcc	.+8      	; 0x6844 <vfprintf+0x132>
    683c:	99 2d       	mov	r25, r9
    683e:	90 61       	ori	r25, 0x10	; 16
    6840:	80 5e       	subi	r24, 0xE0	; 224
    6842:	07 c0       	rjmp	.+14     	; 0x6852 <vfprintf+0x140>
    6844:	9b e9       	ldi	r25, 0x9B	; 155
    6846:	98 0f       	add	r25, r24
    6848:	93 30       	cpi	r25, 0x03	; 3
    684a:	08 f0       	brcs	.+2      	; 0x684e <vfprintf+0x13c>
    684c:	59 c1       	rjmp	.+690    	; 0x6b00 <vfprintf+0x3ee>
    684e:	99 2d       	mov	r25, r9
    6850:	9f 7e       	andi	r25, 0xEF	; 239
    6852:	96 ff       	sbrs	r25, 6
    6854:	16 e0       	ldi	r17, 0x06	; 6
    6856:	9f 73       	andi	r25, 0x3F	; 63
    6858:	99 2e       	mov	r9, r25
    685a:	85 36       	cpi	r24, 0x65	; 101
    685c:	19 f4       	brne	.+6      	; 0x6864 <vfprintf+0x152>
    685e:	90 64       	ori	r25, 0x40	; 64
    6860:	99 2e       	mov	r9, r25
    6862:	08 c0       	rjmp	.+16     	; 0x6874 <vfprintf+0x162>
    6864:	86 36       	cpi	r24, 0x66	; 102
    6866:	21 f4       	brne	.+8      	; 0x6870 <vfprintf+0x15e>
    6868:	39 2f       	mov	r19, r25
    686a:	30 68       	ori	r19, 0x80	; 128
    686c:	93 2e       	mov	r9, r19
    686e:	02 c0       	rjmp	.+4      	; 0x6874 <vfprintf+0x162>
    6870:	11 11       	cpse	r17, r1
    6872:	11 50       	subi	r17, 0x01	; 1
    6874:	97 fe       	sbrs	r9, 7
    6876:	07 c0       	rjmp	.+14     	; 0x6886 <vfprintf+0x174>
    6878:	1c 33       	cpi	r17, 0x3C	; 60
    687a:	50 f4       	brcc	.+20     	; 0x6890 <vfprintf+0x17e>
    687c:	44 24       	eor	r4, r4
    687e:	43 94       	inc	r4
    6880:	41 0e       	add	r4, r17
    6882:	27 e0       	ldi	r18, 0x07	; 7
    6884:	0b c0       	rjmp	.+22     	; 0x689c <vfprintf+0x18a>
    6886:	18 30       	cpi	r17, 0x08	; 8
    6888:	38 f0       	brcs	.+14     	; 0x6898 <vfprintf+0x186>
    688a:	27 e0       	ldi	r18, 0x07	; 7
    688c:	17 e0       	ldi	r17, 0x07	; 7
    688e:	05 c0       	rjmp	.+10     	; 0x689a <vfprintf+0x188>
    6890:	27 e0       	ldi	r18, 0x07	; 7
    6892:	9c e3       	ldi	r25, 0x3C	; 60
    6894:	49 2e       	mov	r4, r25
    6896:	02 c0       	rjmp	.+4      	; 0x689c <vfprintf+0x18a>
    6898:	21 2f       	mov	r18, r17
    689a:	41 2c       	mov	r4, r1
    689c:	56 01       	movw	r10, r12
    689e:	84 e0       	ldi	r24, 0x04	; 4
    68a0:	a8 0e       	add	r10, r24
    68a2:	b1 1c       	adc	r11, r1
    68a4:	f6 01       	movw	r30, r12
    68a6:	60 81       	ld	r22, Z
    68a8:	71 81       	ldd	r23, Z+1	; 0x01
    68aa:	82 81       	ldd	r24, Z+2	; 0x02
    68ac:	93 81       	ldd	r25, Z+3	; 0x03
    68ae:	04 2d       	mov	r16, r4
    68b0:	a3 01       	movw	r20, r6
    68b2:	ee d2       	rcall	.+1500   	; 0x6e90 <__ftoa_engine>
    68b4:	6c 01       	movw	r12, r24
    68b6:	f9 81       	ldd	r31, Y+1	; 0x01
    68b8:	fc 87       	std	Y+12, r31	; 0x0c
    68ba:	f0 ff       	sbrs	r31, 0
    68bc:	02 c0       	rjmp	.+4      	; 0x68c2 <vfprintf+0x1b0>
    68be:	f3 ff       	sbrs	r31, 3
    68c0:	06 c0       	rjmp	.+12     	; 0x68ce <vfprintf+0x1bc>
    68c2:	91 fc       	sbrc	r9, 1
    68c4:	06 c0       	rjmp	.+12     	; 0x68d2 <vfprintf+0x1c0>
    68c6:	92 fe       	sbrs	r9, 2
    68c8:	06 c0       	rjmp	.+12     	; 0x68d6 <vfprintf+0x1c4>
    68ca:	00 e2       	ldi	r16, 0x20	; 32
    68cc:	05 c0       	rjmp	.+10     	; 0x68d8 <vfprintf+0x1c6>
    68ce:	0d e2       	ldi	r16, 0x2D	; 45
    68d0:	03 c0       	rjmp	.+6      	; 0x68d8 <vfprintf+0x1c6>
    68d2:	0b e2       	ldi	r16, 0x2B	; 43
    68d4:	01 c0       	rjmp	.+2      	; 0x68d8 <vfprintf+0x1c6>
    68d6:	00 e0       	ldi	r16, 0x00	; 0
    68d8:	8c 85       	ldd	r24, Y+12	; 0x0c
    68da:	8c 70       	andi	r24, 0x0C	; 12
    68dc:	19 f0       	breq	.+6      	; 0x68e4 <vfprintf+0x1d2>
    68de:	01 11       	cpse	r16, r1
    68e0:	43 c2       	rjmp	.+1158   	; 0x6d68 <vfprintf+0x656>
    68e2:	80 c2       	rjmp	.+1280   	; 0x6de4 <vfprintf+0x6d2>
    68e4:	97 fe       	sbrs	r9, 7
    68e6:	10 c0       	rjmp	.+32     	; 0x6908 <vfprintf+0x1f6>
    68e8:	4c 0c       	add	r4, r12
    68ea:	fc 85       	ldd	r31, Y+12	; 0x0c
    68ec:	f4 ff       	sbrs	r31, 4
    68ee:	04 c0       	rjmp	.+8      	; 0x68f8 <vfprintf+0x1e6>
    68f0:	8a 81       	ldd	r24, Y+2	; 0x02
    68f2:	81 33       	cpi	r24, 0x31	; 49
    68f4:	09 f4       	brne	.+2      	; 0x68f8 <vfprintf+0x1e6>
    68f6:	4a 94       	dec	r4
    68f8:	14 14       	cp	r1, r4
    68fa:	74 f5       	brge	.+92     	; 0x6958 <vfprintf+0x246>
    68fc:	28 e0       	ldi	r18, 0x08	; 8
    68fe:	24 15       	cp	r18, r4
    6900:	78 f5       	brcc	.+94     	; 0x6960 <vfprintf+0x24e>
    6902:	88 e0       	ldi	r24, 0x08	; 8
    6904:	48 2e       	mov	r4, r24
    6906:	2c c0       	rjmp	.+88     	; 0x6960 <vfprintf+0x24e>
    6908:	96 fc       	sbrc	r9, 6
    690a:	2a c0       	rjmp	.+84     	; 0x6960 <vfprintf+0x24e>
    690c:	81 2f       	mov	r24, r17
    690e:	90 e0       	ldi	r25, 0x00	; 0
    6910:	8c 15       	cp	r24, r12
    6912:	9d 05       	cpc	r25, r13
    6914:	9c f0       	brlt	.+38     	; 0x693c <vfprintf+0x22a>
    6916:	3c ef       	ldi	r19, 0xFC	; 252
    6918:	c3 16       	cp	r12, r19
    691a:	3f ef       	ldi	r19, 0xFF	; 255
    691c:	d3 06       	cpc	r13, r19
    691e:	74 f0       	brlt	.+28     	; 0x693c <vfprintf+0x22a>
    6920:	89 2d       	mov	r24, r9
    6922:	80 68       	ori	r24, 0x80	; 128
    6924:	98 2e       	mov	r9, r24
    6926:	0a c0       	rjmp	.+20     	; 0x693c <vfprintf+0x22a>
    6928:	e2 e0       	ldi	r30, 0x02	; 2
    692a:	f0 e0       	ldi	r31, 0x00	; 0
    692c:	ec 0f       	add	r30, r28
    692e:	fd 1f       	adc	r31, r29
    6930:	e1 0f       	add	r30, r17
    6932:	f1 1d       	adc	r31, r1
    6934:	80 81       	ld	r24, Z
    6936:	80 33       	cpi	r24, 0x30	; 48
    6938:	19 f4       	brne	.+6      	; 0x6940 <vfprintf+0x22e>
    693a:	11 50       	subi	r17, 0x01	; 1
    693c:	11 11       	cpse	r17, r1
    693e:	f4 cf       	rjmp	.-24     	; 0x6928 <vfprintf+0x216>
    6940:	97 fe       	sbrs	r9, 7
    6942:	0e c0       	rjmp	.+28     	; 0x6960 <vfprintf+0x24e>
    6944:	44 24       	eor	r4, r4
    6946:	43 94       	inc	r4
    6948:	41 0e       	add	r4, r17
    694a:	81 2f       	mov	r24, r17
    694c:	90 e0       	ldi	r25, 0x00	; 0
    694e:	c8 16       	cp	r12, r24
    6950:	d9 06       	cpc	r13, r25
    6952:	2c f4       	brge	.+10     	; 0x695e <vfprintf+0x24c>
    6954:	1c 19       	sub	r17, r12
    6956:	04 c0       	rjmp	.+8      	; 0x6960 <vfprintf+0x24e>
    6958:	44 24       	eor	r4, r4
    695a:	43 94       	inc	r4
    695c:	01 c0       	rjmp	.+2      	; 0x6960 <vfprintf+0x24e>
    695e:	10 e0       	ldi	r17, 0x00	; 0
    6960:	97 fe       	sbrs	r9, 7
    6962:	06 c0       	rjmp	.+12     	; 0x6970 <vfprintf+0x25e>
    6964:	1c 14       	cp	r1, r12
    6966:	1d 04       	cpc	r1, r13
    6968:	34 f4       	brge	.+12     	; 0x6976 <vfprintf+0x264>
    696a:	c6 01       	movw	r24, r12
    696c:	01 96       	adiw	r24, 0x01	; 1
    696e:	05 c0       	rjmp	.+10     	; 0x697a <vfprintf+0x268>
    6970:	85 e0       	ldi	r24, 0x05	; 5
    6972:	90 e0       	ldi	r25, 0x00	; 0
    6974:	02 c0       	rjmp	.+4      	; 0x697a <vfprintf+0x268>
    6976:	81 e0       	ldi	r24, 0x01	; 1
    6978:	90 e0       	ldi	r25, 0x00	; 0
    697a:	01 11       	cpse	r16, r1
    697c:	01 96       	adiw	r24, 0x01	; 1
    697e:	11 23       	and	r17, r17
    6980:	31 f0       	breq	.+12     	; 0x698e <vfprintf+0x27c>
    6982:	21 2f       	mov	r18, r17
    6984:	30 e0       	ldi	r19, 0x00	; 0
    6986:	2f 5f       	subi	r18, 0xFF	; 255
    6988:	3f 4f       	sbci	r19, 0xFF	; 255
    698a:	82 0f       	add	r24, r18
    698c:	93 1f       	adc	r25, r19
    698e:	25 2d       	mov	r18, r5
    6990:	30 e0       	ldi	r19, 0x00	; 0
    6992:	82 17       	cp	r24, r18
    6994:	93 07       	cpc	r25, r19
    6996:	14 f4       	brge	.+4      	; 0x699c <vfprintf+0x28a>
    6998:	58 1a       	sub	r5, r24
    699a:	01 c0       	rjmp	.+2      	; 0x699e <vfprintf+0x28c>
    699c:	51 2c       	mov	r5, r1
    699e:	89 2d       	mov	r24, r9
    69a0:	89 70       	andi	r24, 0x09	; 9
    69a2:	41 f4       	brne	.+16     	; 0x69b4 <vfprintf+0x2a2>
    69a4:	55 20       	and	r5, r5
    69a6:	31 f0       	breq	.+12     	; 0x69b4 <vfprintf+0x2a2>
    69a8:	b7 01       	movw	r22, r14
    69aa:	80 e2       	ldi	r24, 0x20	; 32
    69ac:	90 e0       	ldi	r25, 0x00	; 0
    69ae:	67 d3       	rcall	.+1742   	; 0x707e <fputc>
    69b0:	5a 94       	dec	r5
    69b2:	f8 cf       	rjmp	.-16     	; 0x69a4 <vfprintf+0x292>
    69b4:	00 23       	and	r16, r16
    69b6:	21 f0       	breq	.+8      	; 0x69c0 <vfprintf+0x2ae>
    69b8:	b7 01       	movw	r22, r14
    69ba:	80 2f       	mov	r24, r16
    69bc:	90 e0       	ldi	r25, 0x00	; 0
    69be:	5f d3       	rcall	.+1726   	; 0x707e <fputc>
    69c0:	93 fc       	sbrc	r9, 3
    69c2:	08 c0       	rjmp	.+16     	; 0x69d4 <vfprintf+0x2c2>
    69c4:	55 20       	and	r5, r5
    69c6:	31 f0       	breq	.+12     	; 0x69d4 <vfprintf+0x2c2>
    69c8:	b7 01       	movw	r22, r14
    69ca:	80 e3       	ldi	r24, 0x30	; 48
    69cc:	90 e0       	ldi	r25, 0x00	; 0
    69ce:	57 d3       	rcall	.+1710   	; 0x707e <fputc>
    69d0:	5a 94       	dec	r5
    69d2:	f8 cf       	rjmp	.-16     	; 0x69c4 <vfprintf+0x2b2>
    69d4:	97 fe       	sbrs	r9, 7
    69d6:	4a c0       	rjmp	.+148    	; 0x6a6c <vfprintf+0x35a>
    69d8:	46 01       	movw	r8, r12
    69da:	d7 fe       	sbrs	r13, 7
    69dc:	02 c0       	rjmp	.+4      	; 0x69e2 <vfprintf+0x2d0>
    69de:	81 2c       	mov	r8, r1
    69e0:	91 2c       	mov	r9, r1
    69e2:	c6 01       	movw	r24, r12
    69e4:	88 19       	sub	r24, r8
    69e6:	99 09       	sbc	r25, r9
    69e8:	f3 01       	movw	r30, r6
    69ea:	e8 0f       	add	r30, r24
    69ec:	f9 1f       	adc	r31, r25
    69ee:	fe 87       	std	Y+14, r31	; 0x0e
    69f0:	ed 87       	std	Y+13, r30	; 0x0d
    69f2:	96 01       	movw	r18, r12
    69f4:	24 19       	sub	r18, r4
    69f6:	31 09       	sbc	r19, r1
    69f8:	38 8b       	std	Y+16, r19	; 0x10
    69fa:	2f 87       	std	Y+15, r18	; 0x0f
    69fc:	01 2f       	mov	r16, r17
    69fe:	10 e0       	ldi	r17, 0x00	; 0
    6a00:	11 95       	neg	r17
    6a02:	01 95       	neg	r16
    6a04:	11 09       	sbc	r17, r1
    6a06:	3f ef       	ldi	r19, 0xFF	; 255
    6a08:	83 16       	cp	r8, r19
    6a0a:	93 06       	cpc	r9, r19
    6a0c:	21 f4       	brne	.+8      	; 0x6a16 <vfprintf+0x304>
    6a0e:	b7 01       	movw	r22, r14
    6a10:	8e e2       	ldi	r24, 0x2E	; 46
    6a12:	90 e0       	ldi	r25, 0x00	; 0
    6a14:	34 d3       	rcall	.+1640   	; 0x707e <fputc>
    6a16:	c8 14       	cp	r12, r8
    6a18:	d9 04       	cpc	r13, r9
    6a1a:	4c f0       	brlt	.+18     	; 0x6a2e <vfprintf+0x31c>
    6a1c:	8f 85       	ldd	r24, Y+15	; 0x0f
    6a1e:	98 89       	ldd	r25, Y+16	; 0x10
    6a20:	88 15       	cp	r24, r8
    6a22:	99 05       	cpc	r25, r9
    6a24:	24 f4       	brge	.+8      	; 0x6a2e <vfprintf+0x31c>
    6a26:	ed 85       	ldd	r30, Y+13	; 0x0d
    6a28:	fe 85       	ldd	r31, Y+14	; 0x0e
    6a2a:	81 81       	ldd	r24, Z+1	; 0x01
    6a2c:	01 c0       	rjmp	.+2      	; 0x6a30 <vfprintf+0x31e>
    6a2e:	80 e3       	ldi	r24, 0x30	; 48
    6a30:	f1 e0       	ldi	r31, 0x01	; 1
    6a32:	8f 1a       	sub	r8, r31
    6a34:	91 08       	sbc	r9, r1
    6a36:	2d 85       	ldd	r18, Y+13	; 0x0d
    6a38:	3e 85       	ldd	r19, Y+14	; 0x0e
    6a3a:	2f 5f       	subi	r18, 0xFF	; 255
    6a3c:	3f 4f       	sbci	r19, 0xFF	; 255
    6a3e:	3e 87       	std	Y+14, r19	; 0x0e
    6a40:	2d 87       	std	Y+13, r18	; 0x0d
    6a42:	80 16       	cp	r8, r16
    6a44:	91 06       	cpc	r9, r17
    6a46:	24 f0       	brlt	.+8      	; 0x6a50 <vfprintf+0x33e>
    6a48:	b7 01       	movw	r22, r14
    6a4a:	90 e0       	ldi	r25, 0x00	; 0
    6a4c:	18 d3       	rcall	.+1584   	; 0x707e <fputc>
    6a4e:	db cf       	rjmp	.-74     	; 0x6a06 <vfprintf+0x2f4>
    6a50:	c8 14       	cp	r12, r8
    6a52:	d9 04       	cpc	r13, r9
    6a54:	41 f4       	brne	.+16     	; 0x6a66 <vfprintf+0x354>
    6a56:	9a 81       	ldd	r25, Y+2	; 0x02
    6a58:	96 33       	cpi	r25, 0x36	; 54
    6a5a:	20 f4       	brcc	.+8      	; 0x6a64 <vfprintf+0x352>
    6a5c:	95 33       	cpi	r25, 0x35	; 53
    6a5e:	19 f4       	brne	.+6      	; 0x6a66 <vfprintf+0x354>
    6a60:	3c 85       	ldd	r19, Y+12	; 0x0c
    6a62:	34 ff       	sbrs	r19, 4
    6a64:	81 e3       	ldi	r24, 0x31	; 49
    6a66:	b7 01       	movw	r22, r14
    6a68:	90 e0       	ldi	r25, 0x00	; 0
    6a6a:	48 c0       	rjmp	.+144    	; 0x6afc <vfprintf+0x3ea>
    6a6c:	8a 81       	ldd	r24, Y+2	; 0x02
    6a6e:	81 33       	cpi	r24, 0x31	; 49
    6a70:	19 f0       	breq	.+6      	; 0x6a78 <vfprintf+0x366>
    6a72:	9c 85       	ldd	r25, Y+12	; 0x0c
    6a74:	9f 7e       	andi	r25, 0xEF	; 239
    6a76:	9c 87       	std	Y+12, r25	; 0x0c
    6a78:	b7 01       	movw	r22, r14
    6a7a:	90 e0       	ldi	r25, 0x00	; 0
    6a7c:	00 d3       	rcall	.+1536   	; 0x707e <fputc>
    6a7e:	11 11       	cpse	r17, r1
    6a80:	05 c0       	rjmp	.+10     	; 0x6a8c <vfprintf+0x37a>
    6a82:	94 fc       	sbrc	r9, 4
    6a84:	16 c0       	rjmp	.+44     	; 0x6ab2 <vfprintf+0x3a0>
    6a86:	85 e6       	ldi	r24, 0x65	; 101
    6a88:	90 e0       	ldi	r25, 0x00	; 0
    6a8a:	15 c0       	rjmp	.+42     	; 0x6ab6 <vfprintf+0x3a4>
    6a8c:	b7 01       	movw	r22, r14
    6a8e:	8e e2       	ldi	r24, 0x2E	; 46
    6a90:	90 e0       	ldi	r25, 0x00	; 0
    6a92:	f5 d2       	rcall	.+1514   	; 0x707e <fputc>
    6a94:	1e 5f       	subi	r17, 0xFE	; 254
    6a96:	82 e0       	ldi	r24, 0x02	; 2
    6a98:	01 e0       	ldi	r16, 0x01	; 1
    6a9a:	08 0f       	add	r16, r24
    6a9c:	f3 01       	movw	r30, r6
    6a9e:	e8 0f       	add	r30, r24
    6aa0:	f1 1d       	adc	r31, r1
    6aa2:	80 81       	ld	r24, Z
    6aa4:	b7 01       	movw	r22, r14
    6aa6:	90 e0       	ldi	r25, 0x00	; 0
    6aa8:	ea d2       	rcall	.+1492   	; 0x707e <fputc>
    6aaa:	80 2f       	mov	r24, r16
    6aac:	01 13       	cpse	r16, r17
    6aae:	f4 cf       	rjmp	.-24     	; 0x6a98 <vfprintf+0x386>
    6ab0:	e8 cf       	rjmp	.-48     	; 0x6a82 <vfprintf+0x370>
    6ab2:	85 e4       	ldi	r24, 0x45	; 69
    6ab4:	90 e0       	ldi	r25, 0x00	; 0
    6ab6:	b7 01       	movw	r22, r14
    6ab8:	e2 d2       	rcall	.+1476   	; 0x707e <fputc>
    6aba:	d7 fc       	sbrc	r13, 7
    6abc:	06 c0       	rjmp	.+12     	; 0x6aca <vfprintf+0x3b8>
    6abe:	c1 14       	cp	r12, r1
    6ac0:	d1 04       	cpc	r13, r1
    6ac2:	41 f4       	brne	.+16     	; 0x6ad4 <vfprintf+0x3c2>
    6ac4:	ec 85       	ldd	r30, Y+12	; 0x0c
    6ac6:	e4 ff       	sbrs	r30, 4
    6ac8:	05 c0       	rjmp	.+10     	; 0x6ad4 <vfprintf+0x3c2>
    6aca:	d1 94       	neg	r13
    6acc:	c1 94       	neg	r12
    6ace:	d1 08       	sbc	r13, r1
    6ad0:	8d e2       	ldi	r24, 0x2D	; 45
    6ad2:	01 c0       	rjmp	.+2      	; 0x6ad6 <vfprintf+0x3c4>
    6ad4:	8b e2       	ldi	r24, 0x2B	; 43
    6ad6:	b7 01       	movw	r22, r14
    6ad8:	90 e0       	ldi	r25, 0x00	; 0
    6ada:	d1 d2       	rcall	.+1442   	; 0x707e <fputc>
    6adc:	80 e3       	ldi	r24, 0x30	; 48
    6ade:	2a e0       	ldi	r18, 0x0A	; 10
    6ae0:	c2 16       	cp	r12, r18
    6ae2:	d1 04       	cpc	r13, r1
    6ae4:	2c f0       	brlt	.+10     	; 0x6af0 <vfprintf+0x3de>
    6ae6:	8f 5f       	subi	r24, 0xFF	; 255
    6ae8:	fa e0       	ldi	r31, 0x0A	; 10
    6aea:	cf 1a       	sub	r12, r31
    6aec:	d1 08       	sbc	r13, r1
    6aee:	f7 cf       	rjmp	.-18     	; 0x6ade <vfprintf+0x3cc>
    6af0:	b7 01       	movw	r22, r14
    6af2:	90 e0       	ldi	r25, 0x00	; 0
    6af4:	c4 d2       	rcall	.+1416   	; 0x707e <fputc>
    6af6:	b7 01       	movw	r22, r14
    6af8:	c6 01       	movw	r24, r12
    6afa:	c0 96       	adiw	r24, 0x30	; 48
    6afc:	c0 d2       	rcall	.+1408   	; 0x707e <fputc>
    6afe:	49 c1       	rjmp	.+658    	; 0x6d92 <vfprintf+0x680>
    6b00:	83 36       	cpi	r24, 0x63	; 99
    6b02:	31 f0       	breq	.+12     	; 0x6b10 <vfprintf+0x3fe>
    6b04:	83 37       	cpi	r24, 0x73	; 115
    6b06:	79 f0       	breq	.+30     	; 0x6b26 <vfprintf+0x414>
    6b08:	83 35       	cpi	r24, 0x53	; 83
    6b0a:	09 f0       	breq	.+2      	; 0x6b0e <vfprintf+0x3fc>
    6b0c:	52 c0       	rjmp	.+164    	; 0x6bb2 <vfprintf+0x4a0>
    6b0e:	1f c0       	rjmp	.+62     	; 0x6b4e <vfprintf+0x43c>
    6b10:	56 01       	movw	r10, r12
    6b12:	32 e0       	ldi	r19, 0x02	; 2
    6b14:	a3 0e       	add	r10, r19
    6b16:	b1 1c       	adc	r11, r1
    6b18:	f6 01       	movw	r30, r12
    6b1a:	80 81       	ld	r24, Z
    6b1c:	89 83       	std	Y+1, r24	; 0x01
    6b1e:	01 e0       	ldi	r16, 0x01	; 1
    6b20:	10 e0       	ldi	r17, 0x00	; 0
    6b22:	63 01       	movw	r12, r6
    6b24:	11 c0       	rjmp	.+34     	; 0x6b48 <vfprintf+0x436>
    6b26:	56 01       	movw	r10, r12
    6b28:	f2 e0       	ldi	r31, 0x02	; 2
    6b2a:	af 0e       	add	r10, r31
    6b2c:	b1 1c       	adc	r11, r1
    6b2e:	f6 01       	movw	r30, r12
    6b30:	c0 80       	ld	r12, Z
    6b32:	d1 80       	ldd	r13, Z+1	; 0x01
    6b34:	96 fe       	sbrs	r9, 6
    6b36:	03 c0       	rjmp	.+6      	; 0x6b3e <vfprintf+0x42c>
    6b38:	61 2f       	mov	r22, r17
    6b3a:	70 e0       	ldi	r23, 0x00	; 0
    6b3c:	02 c0       	rjmp	.+4      	; 0x6b42 <vfprintf+0x430>
    6b3e:	6f ef       	ldi	r22, 0xFF	; 255
    6b40:	7f ef       	ldi	r23, 0xFF	; 255
    6b42:	c6 01       	movw	r24, r12
    6b44:	91 d2       	rcall	.+1314   	; 0x7068 <strnlen>
    6b46:	8c 01       	movw	r16, r24
    6b48:	f9 2d       	mov	r31, r9
    6b4a:	ff 77       	andi	r31, 0x7F	; 127
    6b4c:	13 c0       	rjmp	.+38     	; 0x6b74 <vfprintf+0x462>
    6b4e:	56 01       	movw	r10, r12
    6b50:	22 e0       	ldi	r18, 0x02	; 2
    6b52:	a2 0e       	add	r10, r18
    6b54:	b1 1c       	adc	r11, r1
    6b56:	f6 01       	movw	r30, r12
    6b58:	c0 80       	ld	r12, Z
    6b5a:	d1 80       	ldd	r13, Z+1	; 0x01
    6b5c:	96 fe       	sbrs	r9, 6
    6b5e:	03 c0       	rjmp	.+6      	; 0x6b66 <vfprintf+0x454>
    6b60:	61 2f       	mov	r22, r17
    6b62:	70 e0       	ldi	r23, 0x00	; 0
    6b64:	02 c0       	rjmp	.+4      	; 0x6b6a <vfprintf+0x458>
    6b66:	6f ef       	ldi	r22, 0xFF	; 255
    6b68:	7f ef       	ldi	r23, 0xFF	; 255
    6b6a:	c6 01       	movw	r24, r12
    6b6c:	69 d2       	rcall	.+1234   	; 0x7040 <strnlen_P>
    6b6e:	8c 01       	movw	r16, r24
    6b70:	f9 2d       	mov	r31, r9
    6b72:	f0 68       	ori	r31, 0x80	; 128
    6b74:	9f 2e       	mov	r9, r31
    6b76:	f3 fd       	sbrc	r31, 3
    6b78:	18 c0       	rjmp	.+48     	; 0x6baa <vfprintf+0x498>
    6b7a:	85 2d       	mov	r24, r5
    6b7c:	90 e0       	ldi	r25, 0x00	; 0
    6b7e:	08 17       	cp	r16, r24
    6b80:	19 07       	cpc	r17, r25
    6b82:	98 f4       	brcc	.+38     	; 0x6baa <vfprintf+0x498>
    6b84:	b7 01       	movw	r22, r14
    6b86:	80 e2       	ldi	r24, 0x20	; 32
    6b88:	90 e0       	ldi	r25, 0x00	; 0
    6b8a:	79 d2       	rcall	.+1266   	; 0x707e <fputc>
    6b8c:	5a 94       	dec	r5
    6b8e:	f5 cf       	rjmp	.-22     	; 0x6b7a <vfprintf+0x468>
    6b90:	f6 01       	movw	r30, r12
    6b92:	97 fc       	sbrc	r9, 7
    6b94:	85 91       	lpm	r24, Z+
    6b96:	97 fe       	sbrs	r9, 7
    6b98:	81 91       	ld	r24, Z+
    6b9a:	6f 01       	movw	r12, r30
    6b9c:	b7 01       	movw	r22, r14
    6b9e:	90 e0       	ldi	r25, 0x00	; 0
    6ba0:	6e d2       	rcall	.+1244   	; 0x707e <fputc>
    6ba2:	51 10       	cpse	r5, r1
    6ba4:	5a 94       	dec	r5
    6ba6:	01 50       	subi	r16, 0x01	; 1
    6ba8:	11 09       	sbc	r17, r1
    6baa:	01 15       	cp	r16, r1
    6bac:	11 05       	cpc	r17, r1
    6bae:	81 f7       	brne	.-32     	; 0x6b90 <vfprintf+0x47e>
    6bb0:	f0 c0       	rjmp	.+480    	; 0x6d92 <vfprintf+0x680>
    6bb2:	84 36       	cpi	r24, 0x64	; 100
    6bb4:	11 f0       	breq	.+4      	; 0x6bba <vfprintf+0x4a8>
    6bb6:	89 36       	cpi	r24, 0x69	; 105
    6bb8:	59 f5       	brne	.+86     	; 0x6c10 <vfprintf+0x4fe>
    6bba:	56 01       	movw	r10, r12
    6bbc:	97 fe       	sbrs	r9, 7
    6bbe:	09 c0       	rjmp	.+18     	; 0x6bd2 <vfprintf+0x4c0>
    6bc0:	24 e0       	ldi	r18, 0x04	; 4
    6bc2:	a2 0e       	add	r10, r18
    6bc4:	b1 1c       	adc	r11, r1
    6bc6:	f6 01       	movw	r30, r12
    6bc8:	60 81       	ld	r22, Z
    6bca:	71 81       	ldd	r23, Z+1	; 0x01
    6bcc:	82 81       	ldd	r24, Z+2	; 0x02
    6bce:	93 81       	ldd	r25, Z+3	; 0x03
    6bd0:	0a c0       	rjmp	.+20     	; 0x6be6 <vfprintf+0x4d4>
    6bd2:	f2 e0       	ldi	r31, 0x02	; 2
    6bd4:	af 0e       	add	r10, r31
    6bd6:	b1 1c       	adc	r11, r1
    6bd8:	f6 01       	movw	r30, r12
    6bda:	60 81       	ld	r22, Z
    6bdc:	71 81       	ldd	r23, Z+1	; 0x01
    6bde:	07 2e       	mov	r0, r23
    6be0:	00 0c       	add	r0, r0
    6be2:	88 0b       	sbc	r24, r24
    6be4:	99 0b       	sbc	r25, r25
    6be6:	f9 2d       	mov	r31, r9
    6be8:	ff 76       	andi	r31, 0x6F	; 111
    6bea:	9f 2e       	mov	r9, r31
    6bec:	97 ff       	sbrs	r25, 7
    6bee:	09 c0       	rjmp	.+18     	; 0x6c02 <vfprintf+0x4f0>
    6bf0:	90 95       	com	r25
    6bf2:	80 95       	com	r24
    6bf4:	70 95       	com	r23
    6bf6:	61 95       	neg	r22
    6bf8:	7f 4f       	sbci	r23, 0xFF	; 255
    6bfa:	8f 4f       	sbci	r24, 0xFF	; 255
    6bfc:	9f 4f       	sbci	r25, 0xFF	; 255
    6bfe:	f0 68       	ori	r31, 0x80	; 128
    6c00:	9f 2e       	mov	r9, r31
    6c02:	2a e0       	ldi	r18, 0x0A	; 10
    6c04:	30 e0       	ldi	r19, 0x00	; 0
    6c06:	a3 01       	movw	r20, r6
    6c08:	9e d2       	rcall	.+1340   	; 0x7146 <__ultoa_invert>
    6c0a:	c8 2e       	mov	r12, r24
    6c0c:	c6 18       	sub	r12, r6
    6c0e:	3e c0       	rjmp	.+124    	; 0x6c8c <vfprintf+0x57a>
    6c10:	09 2d       	mov	r16, r9
    6c12:	85 37       	cpi	r24, 0x75	; 117
    6c14:	21 f4       	brne	.+8      	; 0x6c1e <vfprintf+0x50c>
    6c16:	0f 7e       	andi	r16, 0xEF	; 239
    6c18:	2a e0       	ldi	r18, 0x0A	; 10
    6c1a:	30 e0       	ldi	r19, 0x00	; 0
    6c1c:	1d c0       	rjmp	.+58     	; 0x6c58 <vfprintf+0x546>
    6c1e:	09 7f       	andi	r16, 0xF9	; 249
    6c20:	8f 36       	cpi	r24, 0x6F	; 111
    6c22:	91 f0       	breq	.+36     	; 0x6c48 <vfprintf+0x536>
    6c24:	18 f4       	brcc	.+6      	; 0x6c2c <vfprintf+0x51a>
    6c26:	88 35       	cpi	r24, 0x58	; 88
    6c28:	59 f0       	breq	.+22     	; 0x6c40 <vfprintf+0x52e>
    6c2a:	bc c0       	rjmp	.+376    	; 0x6da4 <vfprintf+0x692>
    6c2c:	80 37       	cpi	r24, 0x70	; 112
    6c2e:	19 f0       	breq	.+6      	; 0x6c36 <vfprintf+0x524>
    6c30:	88 37       	cpi	r24, 0x78	; 120
    6c32:	11 f0       	breq	.+4      	; 0x6c38 <vfprintf+0x526>
    6c34:	b7 c0       	rjmp	.+366    	; 0x6da4 <vfprintf+0x692>
    6c36:	00 61       	ori	r16, 0x10	; 16
    6c38:	04 ff       	sbrs	r16, 4
    6c3a:	09 c0       	rjmp	.+18     	; 0x6c4e <vfprintf+0x53c>
    6c3c:	04 60       	ori	r16, 0x04	; 4
    6c3e:	07 c0       	rjmp	.+14     	; 0x6c4e <vfprintf+0x53c>
    6c40:	94 fe       	sbrs	r9, 4
    6c42:	08 c0       	rjmp	.+16     	; 0x6c54 <vfprintf+0x542>
    6c44:	06 60       	ori	r16, 0x06	; 6
    6c46:	06 c0       	rjmp	.+12     	; 0x6c54 <vfprintf+0x542>
    6c48:	28 e0       	ldi	r18, 0x08	; 8
    6c4a:	30 e0       	ldi	r19, 0x00	; 0
    6c4c:	05 c0       	rjmp	.+10     	; 0x6c58 <vfprintf+0x546>
    6c4e:	20 e1       	ldi	r18, 0x10	; 16
    6c50:	30 e0       	ldi	r19, 0x00	; 0
    6c52:	02 c0       	rjmp	.+4      	; 0x6c58 <vfprintf+0x546>
    6c54:	20 e1       	ldi	r18, 0x10	; 16
    6c56:	32 e0       	ldi	r19, 0x02	; 2
    6c58:	56 01       	movw	r10, r12
    6c5a:	07 ff       	sbrs	r16, 7
    6c5c:	09 c0       	rjmp	.+18     	; 0x6c70 <vfprintf+0x55e>
    6c5e:	84 e0       	ldi	r24, 0x04	; 4
    6c60:	a8 0e       	add	r10, r24
    6c62:	b1 1c       	adc	r11, r1
    6c64:	f6 01       	movw	r30, r12
    6c66:	60 81       	ld	r22, Z
    6c68:	71 81       	ldd	r23, Z+1	; 0x01
    6c6a:	82 81       	ldd	r24, Z+2	; 0x02
    6c6c:	93 81       	ldd	r25, Z+3	; 0x03
    6c6e:	08 c0       	rjmp	.+16     	; 0x6c80 <vfprintf+0x56e>
    6c70:	f2 e0       	ldi	r31, 0x02	; 2
    6c72:	af 0e       	add	r10, r31
    6c74:	b1 1c       	adc	r11, r1
    6c76:	f6 01       	movw	r30, r12
    6c78:	60 81       	ld	r22, Z
    6c7a:	71 81       	ldd	r23, Z+1	; 0x01
    6c7c:	80 e0       	ldi	r24, 0x00	; 0
    6c7e:	90 e0       	ldi	r25, 0x00	; 0
    6c80:	a3 01       	movw	r20, r6
    6c82:	61 d2       	rcall	.+1218   	; 0x7146 <__ultoa_invert>
    6c84:	c8 2e       	mov	r12, r24
    6c86:	c6 18       	sub	r12, r6
    6c88:	0f 77       	andi	r16, 0x7F	; 127
    6c8a:	90 2e       	mov	r9, r16
    6c8c:	96 fe       	sbrs	r9, 6
    6c8e:	0b c0       	rjmp	.+22     	; 0x6ca6 <vfprintf+0x594>
    6c90:	09 2d       	mov	r16, r9
    6c92:	0e 7f       	andi	r16, 0xFE	; 254
    6c94:	c1 16       	cp	r12, r17
    6c96:	50 f4       	brcc	.+20     	; 0x6cac <vfprintf+0x59a>
    6c98:	94 fe       	sbrs	r9, 4
    6c9a:	0a c0       	rjmp	.+20     	; 0x6cb0 <vfprintf+0x59e>
    6c9c:	92 fc       	sbrc	r9, 2
    6c9e:	08 c0       	rjmp	.+16     	; 0x6cb0 <vfprintf+0x59e>
    6ca0:	09 2d       	mov	r16, r9
    6ca2:	0e 7e       	andi	r16, 0xEE	; 238
    6ca4:	05 c0       	rjmp	.+10     	; 0x6cb0 <vfprintf+0x59e>
    6ca6:	dc 2c       	mov	r13, r12
    6ca8:	09 2d       	mov	r16, r9
    6caa:	03 c0       	rjmp	.+6      	; 0x6cb2 <vfprintf+0x5a0>
    6cac:	dc 2c       	mov	r13, r12
    6cae:	01 c0       	rjmp	.+2      	; 0x6cb2 <vfprintf+0x5a0>
    6cb0:	d1 2e       	mov	r13, r17
    6cb2:	04 ff       	sbrs	r16, 4
    6cb4:	0d c0       	rjmp	.+26     	; 0x6cd0 <vfprintf+0x5be>
    6cb6:	fe 01       	movw	r30, r28
    6cb8:	ec 0d       	add	r30, r12
    6cba:	f1 1d       	adc	r31, r1
    6cbc:	80 81       	ld	r24, Z
    6cbe:	80 33       	cpi	r24, 0x30	; 48
    6cc0:	11 f4       	brne	.+4      	; 0x6cc6 <vfprintf+0x5b4>
    6cc2:	09 7e       	andi	r16, 0xE9	; 233
    6cc4:	09 c0       	rjmp	.+18     	; 0x6cd8 <vfprintf+0x5c6>
    6cc6:	02 ff       	sbrs	r16, 2
    6cc8:	06 c0       	rjmp	.+12     	; 0x6cd6 <vfprintf+0x5c4>
    6cca:	d3 94       	inc	r13
    6ccc:	d3 94       	inc	r13
    6cce:	04 c0       	rjmp	.+8      	; 0x6cd8 <vfprintf+0x5c6>
    6cd0:	80 2f       	mov	r24, r16
    6cd2:	86 78       	andi	r24, 0x86	; 134
    6cd4:	09 f0       	breq	.+2      	; 0x6cd8 <vfprintf+0x5c6>
    6cd6:	d3 94       	inc	r13
    6cd8:	03 fd       	sbrc	r16, 3
    6cda:	10 c0       	rjmp	.+32     	; 0x6cfc <vfprintf+0x5ea>
    6cdc:	00 ff       	sbrs	r16, 0
    6cde:	06 c0       	rjmp	.+12     	; 0x6cec <vfprintf+0x5da>
    6ce0:	1c 2d       	mov	r17, r12
    6ce2:	d5 14       	cp	r13, r5
    6ce4:	78 f4       	brcc	.+30     	; 0x6d04 <vfprintf+0x5f2>
    6ce6:	15 0d       	add	r17, r5
    6ce8:	1d 19       	sub	r17, r13
    6cea:	0c c0       	rjmp	.+24     	; 0x6d04 <vfprintf+0x5f2>
    6cec:	d5 14       	cp	r13, r5
    6cee:	50 f4       	brcc	.+20     	; 0x6d04 <vfprintf+0x5f2>
    6cf0:	b7 01       	movw	r22, r14
    6cf2:	80 e2       	ldi	r24, 0x20	; 32
    6cf4:	90 e0       	ldi	r25, 0x00	; 0
    6cf6:	c3 d1       	rcall	.+902    	; 0x707e <fputc>
    6cf8:	d3 94       	inc	r13
    6cfa:	f8 cf       	rjmp	.-16     	; 0x6cec <vfprintf+0x5da>
    6cfc:	d5 14       	cp	r13, r5
    6cfe:	10 f4       	brcc	.+4      	; 0x6d04 <vfprintf+0x5f2>
    6d00:	5d 18       	sub	r5, r13
    6d02:	01 c0       	rjmp	.+2      	; 0x6d06 <vfprintf+0x5f4>
    6d04:	51 2c       	mov	r5, r1
    6d06:	04 ff       	sbrs	r16, 4
    6d08:	0f c0       	rjmp	.+30     	; 0x6d28 <vfprintf+0x616>
    6d0a:	b7 01       	movw	r22, r14
    6d0c:	80 e3       	ldi	r24, 0x30	; 48
    6d0e:	90 e0       	ldi	r25, 0x00	; 0
    6d10:	b6 d1       	rcall	.+876    	; 0x707e <fputc>
    6d12:	02 ff       	sbrs	r16, 2
    6d14:	16 c0       	rjmp	.+44     	; 0x6d42 <vfprintf+0x630>
    6d16:	01 fd       	sbrc	r16, 1
    6d18:	03 c0       	rjmp	.+6      	; 0x6d20 <vfprintf+0x60e>
    6d1a:	88 e7       	ldi	r24, 0x78	; 120
    6d1c:	90 e0       	ldi	r25, 0x00	; 0
    6d1e:	02 c0       	rjmp	.+4      	; 0x6d24 <vfprintf+0x612>
    6d20:	88 e5       	ldi	r24, 0x58	; 88
    6d22:	90 e0       	ldi	r25, 0x00	; 0
    6d24:	b7 01       	movw	r22, r14
    6d26:	0c c0       	rjmp	.+24     	; 0x6d40 <vfprintf+0x62e>
    6d28:	80 2f       	mov	r24, r16
    6d2a:	86 78       	andi	r24, 0x86	; 134
    6d2c:	51 f0       	breq	.+20     	; 0x6d42 <vfprintf+0x630>
    6d2e:	01 ff       	sbrs	r16, 1
    6d30:	02 c0       	rjmp	.+4      	; 0x6d36 <vfprintf+0x624>
    6d32:	8b e2       	ldi	r24, 0x2B	; 43
    6d34:	01 c0       	rjmp	.+2      	; 0x6d38 <vfprintf+0x626>
    6d36:	80 e2       	ldi	r24, 0x20	; 32
    6d38:	07 fd       	sbrc	r16, 7
    6d3a:	8d e2       	ldi	r24, 0x2D	; 45
    6d3c:	b7 01       	movw	r22, r14
    6d3e:	90 e0       	ldi	r25, 0x00	; 0
    6d40:	9e d1       	rcall	.+828    	; 0x707e <fputc>
    6d42:	c1 16       	cp	r12, r17
    6d44:	30 f4       	brcc	.+12     	; 0x6d52 <vfprintf+0x640>
    6d46:	b7 01       	movw	r22, r14
    6d48:	80 e3       	ldi	r24, 0x30	; 48
    6d4a:	90 e0       	ldi	r25, 0x00	; 0
    6d4c:	98 d1       	rcall	.+816    	; 0x707e <fputc>
    6d4e:	11 50       	subi	r17, 0x01	; 1
    6d50:	f8 cf       	rjmp	.-16     	; 0x6d42 <vfprintf+0x630>
    6d52:	ca 94       	dec	r12
    6d54:	f3 01       	movw	r30, r6
    6d56:	ec 0d       	add	r30, r12
    6d58:	f1 1d       	adc	r31, r1
    6d5a:	80 81       	ld	r24, Z
    6d5c:	b7 01       	movw	r22, r14
    6d5e:	90 e0       	ldi	r25, 0x00	; 0
    6d60:	8e d1       	rcall	.+796    	; 0x707e <fputc>
    6d62:	c1 10       	cpse	r12, r1
    6d64:	f6 cf       	rjmp	.-20     	; 0x6d52 <vfprintf+0x640>
    6d66:	15 c0       	rjmp	.+42     	; 0x6d92 <vfprintf+0x680>
    6d68:	f4 e0       	ldi	r31, 0x04	; 4
    6d6a:	f5 15       	cp	r31, r5
    6d6c:	50 f5       	brcc	.+84     	; 0x6dc2 <vfprintf+0x6b0>
    6d6e:	84 e0       	ldi	r24, 0x04	; 4
    6d70:	58 1a       	sub	r5, r24
    6d72:	93 fe       	sbrs	r9, 3
    6d74:	1e c0       	rjmp	.+60     	; 0x6db2 <vfprintf+0x6a0>
    6d76:	01 11       	cpse	r16, r1
    6d78:	25 c0       	rjmp	.+74     	; 0x6dc4 <vfprintf+0x6b2>
    6d7a:	2c 85       	ldd	r18, Y+12	; 0x0c
    6d7c:	23 ff       	sbrs	r18, 3
    6d7e:	27 c0       	rjmp	.+78     	; 0x6dce <vfprintf+0x6bc>
    6d80:	00 e3       	ldi	r16, 0x30	; 48
    6d82:	11 e0       	ldi	r17, 0x01	; 1
    6d84:	39 2d       	mov	r19, r9
    6d86:	30 71       	andi	r19, 0x10	; 16
    6d88:	93 2e       	mov	r9, r19
    6d8a:	f8 01       	movw	r30, r16
    6d8c:	84 91       	lpm	r24, Z
    6d8e:	81 11       	cpse	r24, r1
    6d90:	21 c0       	rjmp	.+66     	; 0x6dd4 <vfprintf+0x6c2>
    6d92:	55 20       	and	r5, r5
    6d94:	09 f4       	brne	.+2      	; 0x6d98 <vfprintf+0x686>
    6d96:	fc cc       	rjmp	.-1544   	; 0x6790 <vfprintf+0x7e>
    6d98:	b7 01       	movw	r22, r14
    6d9a:	80 e2       	ldi	r24, 0x20	; 32
    6d9c:	90 e0       	ldi	r25, 0x00	; 0
    6d9e:	6f d1       	rcall	.+734    	; 0x707e <fputc>
    6da0:	5a 94       	dec	r5
    6da2:	f7 cf       	rjmp	.-18     	; 0x6d92 <vfprintf+0x680>
    6da4:	f7 01       	movw	r30, r14
    6da6:	86 81       	ldd	r24, Z+6	; 0x06
    6da8:	97 81       	ldd	r25, Z+7	; 0x07
    6daa:	23 c0       	rjmp	.+70     	; 0x6df2 <vfprintf+0x6e0>
    6dac:	8f ef       	ldi	r24, 0xFF	; 255
    6dae:	9f ef       	ldi	r25, 0xFF	; 255
    6db0:	20 c0       	rjmp	.+64     	; 0x6df2 <vfprintf+0x6e0>
    6db2:	b7 01       	movw	r22, r14
    6db4:	80 e2       	ldi	r24, 0x20	; 32
    6db6:	90 e0       	ldi	r25, 0x00	; 0
    6db8:	62 d1       	rcall	.+708    	; 0x707e <fputc>
    6dba:	5a 94       	dec	r5
    6dbc:	51 10       	cpse	r5, r1
    6dbe:	f9 cf       	rjmp	.-14     	; 0x6db2 <vfprintf+0x6a0>
    6dc0:	da cf       	rjmp	.-76     	; 0x6d76 <vfprintf+0x664>
    6dc2:	51 2c       	mov	r5, r1
    6dc4:	b7 01       	movw	r22, r14
    6dc6:	80 2f       	mov	r24, r16
    6dc8:	90 e0       	ldi	r25, 0x00	; 0
    6dca:	59 d1       	rcall	.+690    	; 0x707e <fputc>
    6dcc:	d6 cf       	rjmp	.-84     	; 0x6d7a <vfprintf+0x668>
    6dce:	04 e3       	ldi	r16, 0x34	; 52
    6dd0:	11 e0       	ldi	r17, 0x01	; 1
    6dd2:	d8 cf       	rjmp	.-80     	; 0x6d84 <vfprintf+0x672>
    6dd4:	91 10       	cpse	r9, r1
    6dd6:	80 52       	subi	r24, 0x20	; 32
    6dd8:	b7 01       	movw	r22, r14
    6dda:	90 e0       	ldi	r25, 0x00	; 0
    6ddc:	50 d1       	rcall	.+672    	; 0x707e <fputc>
    6dde:	0f 5f       	subi	r16, 0xFF	; 255
    6de0:	1f 4f       	sbci	r17, 0xFF	; 255
    6de2:	d3 cf       	rjmp	.-90     	; 0x6d8a <vfprintf+0x678>
    6de4:	23 e0       	ldi	r18, 0x03	; 3
    6de6:	25 15       	cp	r18, r5
    6de8:	10 f4       	brcc	.+4      	; 0x6dee <vfprintf+0x6dc>
    6dea:	83 e0       	ldi	r24, 0x03	; 3
    6dec:	c1 cf       	rjmp	.-126    	; 0x6d70 <vfprintf+0x65e>
    6dee:	51 2c       	mov	r5, r1
    6df0:	c4 cf       	rjmp	.-120    	; 0x6d7a <vfprintf+0x668>
    6df2:	60 96       	adiw	r28, 0x10	; 16
    6df4:	0f b6       	in	r0, 0x3f	; 63
    6df6:	f8 94       	cli
    6df8:	de bf       	out	0x3e, r29	; 62
    6dfa:	0f be       	out	0x3f, r0	; 63
    6dfc:	cd bf       	out	0x3d, r28	; 61
    6dfe:	df 91       	pop	r29
    6e00:	cf 91       	pop	r28
    6e02:	1f 91       	pop	r17
    6e04:	0f 91       	pop	r16
    6e06:	ff 90       	pop	r15
    6e08:	ef 90       	pop	r14
    6e0a:	df 90       	pop	r13
    6e0c:	cf 90       	pop	r12
    6e0e:	bf 90       	pop	r11
    6e10:	af 90       	pop	r10
    6e12:	9f 90       	pop	r9
    6e14:	8f 90       	pop	r8
    6e16:	7f 90       	pop	r7
    6e18:	6f 90       	pop	r6
    6e1a:	5f 90       	pop	r5
    6e1c:	4f 90       	pop	r4
    6e1e:	3f 90       	pop	r3
    6e20:	2f 90       	pop	r2
    6e22:	08 95       	ret

00006e24 <__divmodhi4>:
    6e24:	97 fb       	bst	r25, 7
    6e26:	07 2e       	mov	r0, r23
    6e28:	16 f4       	brtc	.+4      	; 0x6e2e <__divmodhi4+0xa>
    6e2a:	00 94       	com	r0
    6e2c:	06 d0       	rcall	.+12     	; 0x6e3a <__divmodhi4_neg1>
    6e2e:	77 fd       	sbrc	r23, 7
    6e30:	08 d0       	rcall	.+16     	; 0x6e42 <__divmodhi4_neg2>
    6e32:	1a d0       	rcall	.+52     	; 0x6e68 <__udivmodhi4>
    6e34:	07 fc       	sbrc	r0, 7
    6e36:	05 d0       	rcall	.+10     	; 0x6e42 <__divmodhi4_neg2>
    6e38:	3e f4       	brtc	.+14     	; 0x6e48 <__divmodhi4_exit>

00006e3a <__divmodhi4_neg1>:
    6e3a:	90 95       	com	r25
    6e3c:	81 95       	neg	r24
    6e3e:	9f 4f       	sbci	r25, 0xFF	; 255
    6e40:	08 95       	ret

00006e42 <__divmodhi4_neg2>:
    6e42:	70 95       	com	r23
    6e44:	61 95       	neg	r22
    6e46:	7f 4f       	sbci	r23, 0xFF	; 255

00006e48 <__divmodhi4_exit>:
    6e48:	08 95       	ret

00006e4a <__umulhisi3>:
    6e4a:	a2 9f       	mul	r26, r18
    6e4c:	b0 01       	movw	r22, r0
    6e4e:	b3 9f       	mul	r27, r19
    6e50:	c0 01       	movw	r24, r0
    6e52:	a3 9f       	mul	r26, r19
    6e54:	70 0d       	add	r23, r0
    6e56:	81 1d       	adc	r24, r1
    6e58:	11 24       	eor	r1, r1
    6e5a:	91 1d       	adc	r25, r1
    6e5c:	b2 9f       	mul	r27, r18
    6e5e:	70 0d       	add	r23, r0
    6e60:	81 1d       	adc	r24, r1
    6e62:	11 24       	eor	r1, r1
    6e64:	91 1d       	adc	r25, r1
    6e66:	08 95       	ret

00006e68 <__udivmodhi4>:
    6e68:	aa 1b       	sub	r26, r26
    6e6a:	bb 1b       	sub	r27, r27
    6e6c:	51 e1       	ldi	r21, 0x11	; 17
    6e6e:	07 c0       	rjmp	.+14     	; 0x6e7e <__udivmodhi4_ep>

00006e70 <__udivmodhi4_loop>:
    6e70:	aa 1f       	adc	r26, r26
    6e72:	bb 1f       	adc	r27, r27
    6e74:	a6 17       	cp	r26, r22
    6e76:	b7 07       	cpc	r27, r23
    6e78:	10 f0       	brcs	.+4      	; 0x6e7e <__udivmodhi4_ep>
    6e7a:	a6 1b       	sub	r26, r22
    6e7c:	b7 0b       	sbc	r27, r23

00006e7e <__udivmodhi4_ep>:
    6e7e:	88 1f       	adc	r24, r24
    6e80:	99 1f       	adc	r25, r25
    6e82:	5a 95       	dec	r21
    6e84:	a9 f7       	brne	.-22     	; 0x6e70 <__udivmodhi4_loop>
    6e86:	80 95       	com	r24
    6e88:	90 95       	com	r25
    6e8a:	bc 01       	movw	r22, r24
    6e8c:	cd 01       	movw	r24, r26
    6e8e:	08 95       	ret

00006e90 <__ftoa_engine>:
    6e90:	28 30       	cpi	r18, 0x08	; 8
    6e92:	08 f0       	brcs	.+2      	; 0x6e96 <__ftoa_engine+0x6>
    6e94:	27 e0       	ldi	r18, 0x07	; 7
    6e96:	33 27       	eor	r19, r19
    6e98:	da 01       	movw	r26, r20
    6e9a:	99 0f       	add	r25, r25
    6e9c:	31 1d       	adc	r19, r1
    6e9e:	87 fd       	sbrc	r24, 7
    6ea0:	91 60       	ori	r25, 0x01	; 1
    6ea2:	00 96       	adiw	r24, 0x00	; 0
    6ea4:	61 05       	cpc	r22, r1
    6ea6:	71 05       	cpc	r23, r1
    6ea8:	39 f4       	brne	.+14     	; 0x6eb8 <__ftoa_engine+0x28>
    6eaa:	32 60       	ori	r19, 0x02	; 2
    6eac:	2e 5f       	subi	r18, 0xFE	; 254
    6eae:	3d 93       	st	X+, r19
    6eb0:	30 e3       	ldi	r19, 0x30	; 48
    6eb2:	2a 95       	dec	r18
    6eb4:	e1 f7       	brne	.-8      	; 0x6eae <__ftoa_engine+0x1e>
    6eb6:	08 95       	ret
    6eb8:	9f 3f       	cpi	r25, 0xFF	; 255
    6eba:	30 f0       	brcs	.+12     	; 0x6ec8 <__ftoa_engine+0x38>
    6ebc:	80 38       	cpi	r24, 0x80	; 128
    6ebe:	71 05       	cpc	r23, r1
    6ec0:	61 05       	cpc	r22, r1
    6ec2:	09 f0       	breq	.+2      	; 0x6ec6 <__ftoa_engine+0x36>
    6ec4:	3c 5f       	subi	r19, 0xFC	; 252
    6ec6:	3c 5f       	subi	r19, 0xFC	; 252
    6ec8:	3d 93       	st	X+, r19
    6eca:	91 30       	cpi	r25, 0x01	; 1
    6ecc:	08 f0       	brcs	.+2      	; 0x6ed0 <__ftoa_engine+0x40>
    6ece:	80 68       	ori	r24, 0x80	; 128
    6ed0:	91 1d       	adc	r25, r1
    6ed2:	df 93       	push	r29
    6ed4:	cf 93       	push	r28
    6ed6:	1f 93       	push	r17
    6ed8:	0f 93       	push	r16
    6eda:	ff 92       	push	r15
    6edc:	ef 92       	push	r14
    6ede:	19 2f       	mov	r17, r25
    6ee0:	98 7f       	andi	r25, 0xF8	; 248
    6ee2:	96 95       	lsr	r25
    6ee4:	e9 2f       	mov	r30, r25
    6ee6:	96 95       	lsr	r25
    6ee8:	96 95       	lsr	r25
    6eea:	e9 0f       	add	r30, r25
    6eec:	ff 27       	eor	r31, r31
    6eee:	ee 56       	subi	r30, 0x6E	; 110
    6ef0:	fe 4f       	sbci	r31, 0xFE	; 254
    6ef2:	99 27       	eor	r25, r25
    6ef4:	33 27       	eor	r19, r19
    6ef6:	ee 24       	eor	r14, r14
    6ef8:	ff 24       	eor	r15, r15
    6efa:	a7 01       	movw	r20, r14
    6efc:	e7 01       	movw	r28, r14
    6efe:	05 90       	lpm	r0, Z+
    6f00:	08 94       	sec
    6f02:	07 94       	ror	r0
    6f04:	28 f4       	brcc	.+10     	; 0x6f10 <__ftoa_engine+0x80>
    6f06:	36 0f       	add	r19, r22
    6f08:	e7 1e       	adc	r14, r23
    6f0a:	f8 1e       	adc	r15, r24
    6f0c:	49 1f       	adc	r20, r25
    6f0e:	51 1d       	adc	r21, r1
    6f10:	66 0f       	add	r22, r22
    6f12:	77 1f       	adc	r23, r23
    6f14:	88 1f       	adc	r24, r24
    6f16:	99 1f       	adc	r25, r25
    6f18:	06 94       	lsr	r0
    6f1a:	a1 f7       	brne	.-24     	; 0x6f04 <__ftoa_engine+0x74>
    6f1c:	05 90       	lpm	r0, Z+
    6f1e:	07 94       	ror	r0
    6f20:	28 f4       	brcc	.+10     	; 0x6f2c <__ftoa_engine+0x9c>
    6f22:	e7 0e       	add	r14, r23
    6f24:	f8 1e       	adc	r15, r24
    6f26:	49 1f       	adc	r20, r25
    6f28:	56 1f       	adc	r21, r22
    6f2a:	c1 1d       	adc	r28, r1
    6f2c:	77 0f       	add	r23, r23
    6f2e:	88 1f       	adc	r24, r24
    6f30:	99 1f       	adc	r25, r25
    6f32:	66 1f       	adc	r22, r22
    6f34:	06 94       	lsr	r0
    6f36:	a1 f7       	brne	.-24     	; 0x6f20 <__ftoa_engine+0x90>
    6f38:	05 90       	lpm	r0, Z+
    6f3a:	07 94       	ror	r0
    6f3c:	28 f4       	brcc	.+10     	; 0x6f48 <__ftoa_engine+0xb8>
    6f3e:	f8 0e       	add	r15, r24
    6f40:	49 1f       	adc	r20, r25
    6f42:	56 1f       	adc	r21, r22
    6f44:	c7 1f       	adc	r28, r23
    6f46:	d1 1d       	adc	r29, r1
    6f48:	88 0f       	add	r24, r24
    6f4a:	99 1f       	adc	r25, r25
    6f4c:	66 1f       	adc	r22, r22
    6f4e:	77 1f       	adc	r23, r23
    6f50:	06 94       	lsr	r0
    6f52:	a1 f7       	brne	.-24     	; 0x6f3c <__ftoa_engine+0xac>
    6f54:	05 90       	lpm	r0, Z+
    6f56:	07 94       	ror	r0
    6f58:	20 f4       	brcc	.+8      	; 0x6f62 <__ftoa_engine+0xd2>
    6f5a:	49 0f       	add	r20, r25
    6f5c:	56 1f       	adc	r21, r22
    6f5e:	c7 1f       	adc	r28, r23
    6f60:	d8 1f       	adc	r29, r24
    6f62:	99 0f       	add	r25, r25
    6f64:	66 1f       	adc	r22, r22
    6f66:	77 1f       	adc	r23, r23
    6f68:	88 1f       	adc	r24, r24
    6f6a:	06 94       	lsr	r0
    6f6c:	a9 f7       	brne	.-22     	; 0x6f58 <__ftoa_engine+0xc8>
    6f6e:	84 91       	lpm	r24, Z
    6f70:	10 95       	com	r17
    6f72:	17 70       	andi	r17, 0x07	; 7
    6f74:	41 f0       	breq	.+16     	; 0x6f86 <__ftoa_engine+0xf6>
    6f76:	d6 95       	lsr	r29
    6f78:	c7 95       	ror	r28
    6f7a:	57 95       	ror	r21
    6f7c:	47 95       	ror	r20
    6f7e:	f7 94       	ror	r15
    6f80:	e7 94       	ror	r14
    6f82:	1a 95       	dec	r17
    6f84:	c1 f7       	brne	.-16     	; 0x6f76 <__ftoa_engine+0xe6>
    6f86:	e8 e3       	ldi	r30, 0x38	; 56
    6f88:	f1 e0       	ldi	r31, 0x01	; 1
    6f8a:	68 94       	set
    6f8c:	15 90       	lpm	r1, Z+
    6f8e:	15 91       	lpm	r17, Z+
    6f90:	35 91       	lpm	r19, Z+
    6f92:	65 91       	lpm	r22, Z+
    6f94:	95 91       	lpm	r25, Z+
    6f96:	05 90       	lpm	r0, Z+
    6f98:	7f e2       	ldi	r23, 0x2F	; 47
    6f9a:	73 95       	inc	r23
    6f9c:	e1 18       	sub	r14, r1
    6f9e:	f1 0a       	sbc	r15, r17
    6fa0:	43 0b       	sbc	r20, r19
    6fa2:	56 0b       	sbc	r21, r22
    6fa4:	c9 0b       	sbc	r28, r25
    6fa6:	d0 09       	sbc	r29, r0
    6fa8:	c0 f7       	brcc	.-16     	; 0x6f9a <__ftoa_engine+0x10a>
    6faa:	e1 0c       	add	r14, r1
    6fac:	f1 1e       	adc	r15, r17
    6fae:	43 1f       	adc	r20, r19
    6fb0:	56 1f       	adc	r21, r22
    6fb2:	c9 1f       	adc	r28, r25
    6fb4:	d0 1d       	adc	r29, r0
    6fb6:	7e f4       	brtc	.+30     	; 0x6fd6 <__ftoa_engine+0x146>
    6fb8:	70 33       	cpi	r23, 0x30	; 48
    6fba:	11 f4       	brne	.+4      	; 0x6fc0 <__ftoa_engine+0x130>
    6fbc:	8a 95       	dec	r24
    6fbe:	e6 cf       	rjmp	.-52     	; 0x6f8c <__ftoa_engine+0xfc>
    6fc0:	e8 94       	clt
    6fc2:	01 50       	subi	r16, 0x01	; 1
    6fc4:	30 f0       	brcs	.+12     	; 0x6fd2 <__ftoa_engine+0x142>
    6fc6:	08 0f       	add	r16, r24
    6fc8:	0a f4       	brpl	.+2      	; 0x6fcc <__ftoa_engine+0x13c>
    6fca:	00 27       	eor	r16, r16
    6fcc:	02 17       	cp	r16, r18
    6fce:	08 f4       	brcc	.+2      	; 0x6fd2 <__ftoa_engine+0x142>
    6fd0:	20 2f       	mov	r18, r16
    6fd2:	23 95       	inc	r18
    6fd4:	02 2f       	mov	r16, r18
    6fd6:	7a 33       	cpi	r23, 0x3A	; 58
    6fd8:	28 f0       	brcs	.+10     	; 0x6fe4 <__ftoa_engine+0x154>
    6fda:	79 e3       	ldi	r23, 0x39	; 57
    6fdc:	7d 93       	st	X+, r23
    6fde:	2a 95       	dec	r18
    6fe0:	e9 f7       	brne	.-6      	; 0x6fdc <__ftoa_engine+0x14c>
    6fe2:	10 c0       	rjmp	.+32     	; 0x7004 <__ftoa_engine+0x174>
    6fe4:	7d 93       	st	X+, r23
    6fe6:	2a 95       	dec	r18
    6fe8:	89 f6       	brne	.-94     	; 0x6f8c <__ftoa_engine+0xfc>
    6fea:	06 94       	lsr	r0
    6fec:	97 95       	ror	r25
    6fee:	67 95       	ror	r22
    6ff0:	37 95       	ror	r19
    6ff2:	17 95       	ror	r17
    6ff4:	17 94       	ror	r1
    6ff6:	e1 18       	sub	r14, r1
    6ff8:	f1 0a       	sbc	r15, r17
    6ffa:	43 0b       	sbc	r20, r19
    6ffc:	56 0b       	sbc	r21, r22
    6ffe:	c9 0b       	sbc	r28, r25
    7000:	d0 09       	sbc	r29, r0
    7002:	98 f0       	brcs	.+38     	; 0x702a <__ftoa_engine+0x19a>
    7004:	23 95       	inc	r18
    7006:	7e 91       	ld	r23, -X
    7008:	73 95       	inc	r23
    700a:	7a 33       	cpi	r23, 0x3A	; 58
    700c:	08 f0       	brcs	.+2      	; 0x7010 <__ftoa_engine+0x180>
    700e:	70 e3       	ldi	r23, 0x30	; 48
    7010:	7c 93       	st	X, r23
    7012:	20 13       	cpse	r18, r16
    7014:	b8 f7       	brcc	.-18     	; 0x7004 <__ftoa_engine+0x174>
    7016:	7e 91       	ld	r23, -X
    7018:	70 61       	ori	r23, 0x10	; 16
    701a:	7d 93       	st	X+, r23
    701c:	30 f0       	brcs	.+12     	; 0x702a <__ftoa_engine+0x19a>
    701e:	83 95       	inc	r24
    7020:	71 e3       	ldi	r23, 0x31	; 49
    7022:	7d 93       	st	X+, r23
    7024:	70 e3       	ldi	r23, 0x30	; 48
    7026:	2a 95       	dec	r18
    7028:	e1 f7       	brne	.-8      	; 0x7022 <__ftoa_engine+0x192>
    702a:	11 24       	eor	r1, r1
    702c:	ef 90       	pop	r14
    702e:	ff 90       	pop	r15
    7030:	0f 91       	pop	r16
    7032:	1f 91       	pop	r17
    7034:	cf 91       	pop	r28
    7036:	df 91       	pop	r29
    7038:	99 27       	eor	r25, r25
    703a:	87 fd       	sbrc	r24, 7
    703c:	90 95       	com	r25
    703e:	08 95       	ret

00007040 <strnlen_P>:
    7040:	fc 01       	movw	r30, r24
    7042:	05 90       	lpm	r0, Z+
    7044:	61 50       	subi	r22, 0x01	; 1
    7046:	70 40       	sbci	r23, 0x00	; 0
    7048:	01 10       	cpse	r0, r1
    704a:	d8 f7       	brcc	.-10     	; 0x7042 <strnlen_P+0x2>
    704c:	80 95       	com	r24
    704e:	90 95       	com	r25
    7050:	8e 0f       	add	r24, r30
    7052:	9f 1f       	adc	r25, r31
    7054:	08 95       	ret

00007056 <memcpy>:
    7056:	fb 01       	movw	r30, r22
    7058:	dc 01       	movw	r26, r24
    705a:	02 c0       	rjmp	.+4      	; 0x7060 <memcpy+0xa>
    705c:	01 90       	ld	r0, Z+
    705e:	0d 92       	st	X+, r0
    7060:	41 50       	subi	r20, 0x01	; 1
    7062:	50 40       	sbci	r21, 0x00	; 0
    7064:	d8 f7       	brcc	.-10     	; 0x705c <memcpy+0x6>
    7066:	08 95       	ret

00007068 <strnlen>:
    7068:	fc 01       	movw	r30, r24
    706a:	61 50       	subi	r22, 0x01	; 1
    706c:	70 40       	sbci	r23, 0x00	; 0
    706e:	01 90       	ld	r0, Z+
    7070:	01 10       	cpse	r0, r1
    7072:	d8 f7       	brcc	.-10     	; 0x706a <strnlen+0x2>
    7074:	80 95       	com	r24
    7076:	90 95       	com	r25
    7078:	8e 0f       	add	r24, r30
    707a:	9f 1f       	adc	r25, r31
    707c:	08 95       	ret

0000707e <fputc>:
    707e:	0f 93       	push	r16
    7080:	1f 93       	push	r17
    7082:	cf 93       	push	r28
    7084:	df 93       	push	r29
    7086:	fb 01       	movw	r30, r22
    7088:	23 81       	ldd	r18, Z+3	; 0x03
    708a:	21 fd       	sbrc	r18, 1
    708c:	03 c0       	rjmp	.+6      	; 0x7094 <fputc+0x16>
    708e:	8f ef       	ldi	r24, 0xFF	; 255
    7090:	9f ef       	ldi	r25, 0xFF	; 255
    7092:	2c c0       	rjmp	.+88     	; 0x70ec <fputc+0x6e>
    7094:	22 ff       	sbrs	r18, 2
    7096:	16 c0       	rjmp	.+44     	; 0x70c4 <fputc+0x46>
    7098:	46 81       	ldd	r20, Z+6	; 0x06
    709a:	57 81       	ldd	r21, Z+7	; 0x07
    709c:	24 81       	ldd	r18, Z+4	; 0x04
    709e:	35 81       	ldd	r19, Z+5	; 0x05
    70a0:	42 17       	cp	r20, r18
    70a2:	53 07       	cpc	r21, r19
    70a4:	44 f4       	brge	.+16     	; 0x70b6 <fputc+0x38>
    70a6:	a0 81       	ld	r26, Z
    70a8:	b1 81       	ldd	r27, Z+1	; 0x01
    70aa:	9d 01       	movw	r18, r26
    70ac:	2f 5f       	subi	r18, 0xFF	; 255
    70ae:	3f 4f       	sbci	r19, 0xFF	; 255
    70b0:	31 83       	std	Z+1, r19	; 0x01
    70b2:	20 83       	st	Z, r18
    70b4:	8c 93       	st	X, r24
    70b6:	26 81       	ldd	r18, Z+6	; 0x06
    70b8:	37 81       	ldd	r19, Z+7	; 0x07
    70ba:	2f 5f       	subi	r18, 0xFF	; 255
    70bc:	3f 4f       	sbci	r19, 0xFF	; 255
    70be:	37 83       	std	Z+7, r19	; 0x07
    70c0:	26 83       	std	Z+6, r18	; 0x06
    70c2:	14 c0       	rjmp	.+40     	; 0x70ec <fputc+0x6e>
    70c4:	8b 01       	movw	r16, r22
    70c6:	ec 01       	movw	r28, r24
    70c8:	fb 01       	movw	r30, r22
    70ca:	00 84       	ldd	r0, Z+8	; 0x08
    70cc:	f1 85       	ldd	r31, Z+9	; 0x09
    70ce:	e0 2d       	mov	r30, r0
    70d0:	19 95       	eicall
    70d2:	89 2b       	or	r24, r25
    70d4:	e1 f6       	brne	.-72     	; 0x708e <fputc+0x10>
    70d6:	d8 01       	movw	r26, r16
    70d8:	16 96       	adiw	r26, 0x06	; 6
    70da:	8d 91       	ld	r24, X+
    70dc:	9c 91       	ld	r25, X
    70de:	17 97       	sbiw	r26, 0x07	; 7
    70e0:	01 96       	adiw	r24, 0x01	; 1
    70e2:	17 96       	adiw	r26, 0x07	; 7
    70e4:	9c 93       	st	X, r25
    70e6:	8e 93       	st	-X, r24
    70e8:	16 97       	sbiw	r26, 0x06	; 6
    70ea:	ce 01       	movw	r24, r28
    70ec:	df 91       	pop	r29
    70ee:	cf 91       	pop	r28
    70f0:	1f 91       	pop	r17
    70f2:	0f 91       	pop	r16
    70f4:	08 95       	ret

000070f6 <vsprintf>:
    70f6:	0f 93       	push	r16
    70f8:	1f 93       	push	r17
    70fa:	cf 93       	push	r28
    70fc:	df 93       	push	r29
    70fe:	cd b7       	in	r28, 0x3d	; 61
    7100:	de b7       	in	r29, 0x3e	; 62
    7102:	2e 97       	sbiw	r28, 0x0e	; 14
    7104:	0f b6       	in	r0, 0x3f	; 63
    7106:	f8 94       	cli
    7108:	de bf       	out	0x3e, r29	; 62
    710a:	0f be       	out	0x3f, r0	; 63
    710c:	cd bf       	out	0x3d, r28	; 61
    710e:	8c 01       	movw	r16, r24
    7110:	86 e0       	ldi	r24, 0x06	; 6
    7112:	8c 83       	std	Y+4, r24	; 0x04
    7114:	1a 83       	std	Y+2, r17	; 0x02
    7116:	09 83       	std	Y+1, r16	; 0x01
    7118:	8f ef       	ldi	r24, 0xFF	; 255
    711a:	9f e7       	ldi	r25, 0x7F	; 127
    711c:	9e 83       	std	Y+6, r25	; 0x06
    711e:	8d 83       	std	Y+5, r24	; 0x05
    7120:	ce 01       	movw	r24, r28
    7122:	01 96       	adiw	r24, 0x01	; 1
    7124:	f6 da       	rcall	.-2580   	; 0x6712 <vfprintf>
    7126:	ef 81       	ldd	r30, Y+7	; 0x07
    7128:	f8 85       	ldd	r31, Y+8	; 0x08
    712a:	e0 0f       	add	r30, r16
    712c:	f1 1f       	adc	r31, r17
    712e:	10 82       	st	Z, r1
    7130:	2e 96       	adiw	r28, 0x0e	; 14
    7132:	0f b6       	in	r0, 0x3f	; 63
    7134:	f8 94       	cli
    7136:	de bf       	out	0x3e, r29	; 62
    7138:	0f be       	out	0x3f, r0	; 63
    713a:	cd bf       	out	0x3d, r28	; 61
    713c:	df 91       	pop	r29
    713e:	cf 91       	pop	r28
    7140:	1f 91       	pop	r17
    7142:	0f 91       	pop	r16
    7144:	08 95       	ret

00007146 <__ultoa_invert>:
    7146:	fa 01       	movw	r30, r20
    7148:	aa 27       	eor	r26, r26
    714a:	28 30       	cpi	r18, 0x08	; 8
    714c:	51 f1       	breq	.+84     	; 0x71a2 <__ultoa_invert+0x5c>
    714e:	20 31       	cpi	r18, 0x10	; 16
    7150:	81 f1       	breq	.+96     	; 0x71b2 <__ultoa_invert+0x6c>
    7152:	e8 94       	clt
    7154:	6f 93       	push	r22
    7156:	6e 7f       	andi	r22, 0xFE	; 254
    7158:	6e 5f       	subi	r22, 0xFE	; 254
    715a:	7f 4f       	sbci	r23, 0xFF	; 255
    715c:	8f 4f       	sbci	r24, 0xFF	; 255
    715e:	9f 4f       	sbci	r25, 0xFF	; 255
    7160:	af 4f       	sbci	r26, 0xFF	; 255
    7162:	b1 e0       	ldi	r27, 0x01	; 1
    7164:	3e d0       	rcall	.+124    	; 0x71e2 <__ultoa_invert+0x9c>
    7166:	b4 e0       	ldi	r27, 0x04	; 4
    7168:	3c d0       	rcall	.+120    	; 0x71e2 <__ultoa_invert+0x9c>
    716a:	67 0f       	add	r22, r23
    716c:	78 1f       	adc	r23, r24
    716e:	89 1f       	adc	r24, r25
    7170:	9a 1f       	adc	r25, r26
    7172:	a1 1d       	adc	r26, r1
    7174:	68 0f       	add	r22, r24
    7176:	79 1f       	adc	r23, r25
    7178:	8a 1f       	adc	r24, r26
    717a:	91 1d       	adc	r25, r1
    717c:	a1 1d       	adc	r26, r1
    717e:	6a 0f       	add	r22, r26
    7180:	71 1d       	adc	r23, r1
    7182:	81 1d       	adc	r24, r1
    7184:	91 1d       	adc	r25, r1
    7186:	a1 1d       	adc	r26, r1
    7188:	20 d0       	rcall	.+64     	; 0x71ca <__ultoa_invert+0x84>
    718a:	09 f4       	brne	.+2      	; 0x718e <__ultoa_invert+0x48>
    718c:	68 94       	set
    718e:	3f 91       	pop	r19
    7190:	2a e0       	ldi	r18, 0x0A	; 10
    7192:	26 9f       	mul	r18, r22
    7194:	11 24       	eor	r1, r1
    7196:	30 19       	sub	r19, r0
    7198:	30 5d       	subi	r19, 0xD0	; 208
    719a:	31 93       	st	Z+, r19
    719c:	de f6       	brtc	.-74     	; 0x7154 <__ultoa_invert+0xe>
    719e:	cf 01       	movw	r24, r30
    71a0:	08 95       	ret
    71a2:	46 2f       	mov	r20, r22
    71a4:	47 70       	andi	r20, 0x07	; 7
    71a6:	40 5d       	subi	r20, 0xD0	; 208
    71a8:	41 93       	st	Z+, r20
    71aa:	b3 e0       	ldi	r27, 0x03	; 3
    71ac:	0f d0       	rcall	.+30     	; 0x71cc <__ultoa_invert+0x86>
    71ae:	c9 f7       	brne	.-14     	; 0x71a2 <__ultoa_invert+0x5c>
    71b0:	f6 cf       	rjmp	.-20     	; 0x719e <__ultoa_invert+0x58>
    71b2:	46 2f       	mov	r20, r22
    71b4:	4f 70       	andi	r20, 0x0F	; 15
    71b6:	40 5d       	subi	r20, 0xD0	; 208
    71b8:	4a 33       	cpi	r20, 0x3A	; 58
    71ba:	18 f0       	brcs	.+6      	; 0x71c2 <__ultoa_invert+0x7c>
    71bc:	49 5d       	subi	r20, 0xD9	; 217
    71be:	31 fd       	sbrc	r19, 1
    71c0:	40 52       	subi	r20, 0x20	; 32
    71c2:	41 93       	st	Z+, r20
    71c4:	02 d0       	rcall	.+4      	; 0x71ca <__ultoa_invert+0x84>
    71c6:	a9 f7       	brne	.-22     	; 0x71b2 <__ultoa_invert+0x6c>
    71c8:	ea cf       	rjmp	.-44     	; 0x719e <__ultoa_invert+0x58>
    71ca:	b4 e0       	ldi	r27, 0x04	; 4
    71cc:	a6 95       	lsr	r26
    71ce:	97 95       	ror	r25
    71d0:	87 95       	ror	r24
    71d2:	77 95       	ror	r23
    71d4:	67 95       	ror	r22
    71d6:	ba 95       	dec	r27
    71d8:	c9 f7       	brne	.-14     	; 0x71cc <__ultoa_invert+0x86>
    71da:	00 97       	sbiw	r24, 0x00	; 0
    71dc:	61 05       	cpc	r22, r1
    71de:	71 05       	cpc	r23, r1
    71e0:	08 95       	ret
    71e2:	9b 01       	movw	r18, r22
    71e4:	ac 01       	movw	r20, r24
    71e6:	0a 2e       	mov	r0, r26
    71e8:	06 94       	lsr	r0
    71ea:	57 95       	ror	r21
    71ec:	47 95       	ror	r20
    71ee:	37 95       	ror	r19
    71f0:	27 95       	ror	r18
    71f2:	ba 95       	dec	r27
    71f4:	c9 f7       	brne	.-14     	; 0x71e8 <__ultoa_invert+0xa2>
    71f6:	62 0f       	add	r22, r18
    71f8:	73 1f       	adc	r23, r19
    71fa:	84 1f       	adc	r24, r20
    71fc:	95 1f       	adc	r25, r21
    71fe:	a0 1d       	adc	r26, r0
    7200:	08 95       	ret

00007202 <_exit>:
    7202:	f8 94       	cli

00007204 <__stop_program>:
    7204:	ff cf       	rjmp	.-2      	; 0x7204 <__stop_program>
