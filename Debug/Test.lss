
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000051a  00800200  00007240  000072d4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007240  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000014c8  0080071a  0080071a  000077ee  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  000077ee  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000784c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000810  00000000  00000000  0000788c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000b8fb  00000000  00000000  0000809c  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000026f5  00000000  00000000  00013997  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000663b  00000000  00000000  0001608c  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001b04  00000000  00000000  0001c6c8  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002fc2  00000000  00000000  0001e1cc  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000bad5  00000000  00000000  0002118e  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008d8  00000000  00000000  0002cc63  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	20 c1       	rjmp	.+576    	; 0x242 <__ctors_end>
       2:	00 00       	nop
       4:	3f c1       	rjmp	.+638    	; 0x284 <__bad_interrupt>
       6:	00 00       	nop
       8:	3d c1       	rjmp	.+634    	; 0x284 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 c2 15 	jmp	0x2b84	; 0x2b84 <__vector_3>
      10:	0c 94 b1 15 	jmp	0x2b62	; 0x2b62 <__vector_4>
      14:	0c 94 d3 15 	jmp	0x2ba6	; 0x2ba6 <__vector_5>
      18:	35 c1       	rjmp	.+618    	; 0x284 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	33 c1       	rjmp	.+614    	; 0x284 <__bad_interrupt>
      1e:	00 00       	nop
      20:	31 c1       	rjmp	.+610    	; 0x284 <__bad_interrupt>
      22:	00 00       	nop
      24:	2f c1       	rjmp	.+606    	; 0x284 <__bad_interrupt>
      26:	00 00       	nop
      28:	2d c1       	rjmp	.+602    	; 0x284 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	2b c1       	rjmp	.+598    	; 0x284 <__bad_interrupt>
      2e:	00 00       	nop
      30:	29 c1       	rjmp	.+594    	; 0x284 <__bad_interrupt>
      32:	00 00       	nop
      34:	27 c1       	rjmp	.+590    	; 0x284 <__bad_interrupt>
      36:	00 00       	nop
      38:	25 c1       	rjmp	.+586    	; 0x284 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	23 c1       	rjmp	.+582    	; 0x284 <__bad_interrupt>
      3e:	00 00       	nop
      40:	21 c1       	rjmp	.+578    	; 0x284 <__bad_interrupt>
      42:	00 00       	nop
      44:	1f c1       	rjmp	.+574    	; 0x284 <__bad_interrupt>
      46:	00 00       	nop
      48:	1d c1       	rjmp	.+570    	; 0x284 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1b c1       	rjmp	.+566    	; 0x284 <__bad_interrupt>
      4e:	00 00       	nop
      50:	19 c1       	rjmp	.+562    	; 0x284 <__bad_interrupt>
      52:	00 00       	nop
      54:	17 c1       	rjmp	.+558    	; 0x284 <__bad_interrupt>
      56:	00 00       	nop
      58:	15 c1       	rjmp	.+554    	; 0x284 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	13 c1       	rjmp	.+550    	; 0x284 <__bad_interrupt>
      5e:	00 00       	nop
      60:	11 c1       	rjmp	.+546    	; 0x284 <__bad_interrupt>
      62:	00 00       	nop
      64:	0f c1       	rjmp	.+542    	; 0x284 <__bad_interrupt>
      66:	00 00       	nop
      68:	0d c1       	rjmp	.+538    	; 0x284 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	0b c1       	rjmp	.+534    	; 0x284 <__bad_interrupt>
      6e:	00 00       	nop
      70:	09 c1       	rjmp	.+530    	; 0x284 <__bad_interrupt>
      72:	00 00       	nop
      74:	07 c1       	rjmp	.+526    	; 0x284 <__bad_interrupt>
      76:	00 00       	nop
      78:	05 c1       	rjmp	.+522    	; 0x284 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	03 c1       	rjmp	.+518    	; 0x284 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 49 19 	jmp	0x3292	; 0x3292 <__vector_32>
      84:	ff c0       	rjmp	.+510    	; 0x284 <__bad_interrupt>
      86:	00 00       	nop
      88:	fd c0       	rjmp	.+506    	; 0x284 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fb c0       	rjmp	.+502    	; 0x284 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f9 c0       	rjmp	.+498    	; 0x284 <__bad_interrupt>
      92:	00 00       	nop
      94:	f7 c0       	rjmp	.+494    	; 0x284 <__bad_interrupt>
      96:	00 00       	nop
      98:	f5 c0       	rjmp	.+490    	; 0x284 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	f3 c0       	rjmp	.+486    	; 0x284 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	f1 c0       	rjmp	.+482    	; 0x284 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	ef c0       	rjmp	.+478    	; 0x284 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	ed c0       	rjmp	.+474    	; 0x284 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	eb c0       	rjmp	.+470    	; 0x284 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	e9 c0       	rjmp	.+466    	; 0x284 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	e7 c0       	rjmp	.+462    	; 0x284 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	e5 c0       	rjmp	.+458    	; 0x284 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	e3 c0       	rjmp	.+454    	; 0x284 <__bad_interrupt>
      be:	00 00       	nop
      c0:	e1 c0       	rjmp	.+450    	; 0x284 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	df c0       	rjmp	.+446    	; 0x284 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	dd c0       	rjmp	.+442    	; 0x284 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 e4 2f 	jmp	0x5fc8	; 0x5fc8 <__vector_51>
      d0:	d9 c0       	rjmp	.+434    	; 0x284 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	d7 c0       	rjmp	.+430    	; 0x284 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	d5 c0       	rjmp	.+426    	; 0x284 <__bad_interrupt>
      da:	00 00       	nop
      dc:	d3 c0       	rjmp	.+422    	; 0x284 <__bad_interrupt>
      de:	00 00       	nop
      e0:	d1 c0       	rjmp	.+418    	; 0x284 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 05       	cpc	r19, r15
     112:	a8 4c       	sbci	r26, 0xC8	; 200
     114:	cd b2       	in	r12, 0x1d	; 29
     116:	d4 4e       	sbci	r29, 0xE4	; 228
     118:	b9 38       	cpi	r27, 0x89	; 137
     11a:	36 a9       	ldd	r19, Z+54	; 0x36
     11c:	02 0c       	add	r0, r2
     11e:	50 b9       	out	0x00, r21	; 0
     120:	91 86       	std	Z+9, r9	; 0x09
     122:	88 08       	sbc	r8, r8
     124:	3c a6       	std	Y+44, r3	; 0x2c
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	2a be       	out	0x3a, r2	; 58
     12a:	00 00       	nop
     12c:	00 80       	ld	r0, Z
     12e:	3f 00       	.word	0x003f	; ????

00000130 <__trampolines_end>:
     130:	6e 61       	ori	r22, 0x1E	; 30
     132:	6e 00       	.word	0x006e	; ????

00000134 <__c.2240>:
     134:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     144:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     154:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     164:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     174:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     184:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     194:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     1a4:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     1b4:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     1c4:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     1d4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     1e4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1f4:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     204:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     214:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     224:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000232 <prvIdleTask>:
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     232:	cf e6       	ldi	r28, 0x6F	; 111
     234:	da e1       	ldi	r29, 0x1A	; 26
     236:	88 81       	ld	r24, Y
     238:	82 30       	cpi	r24, 0x02	; 2
     23a:	f0 f3       	brcs	.-4      	; 0x238 <prvIdleTask+0x6>
     23c:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
     240:	fa cf       	rjmp	.-12     	; 0x236 <prvIdleTask+0x4>

00000242 <__ctors_end>:
     242:	11 24       	eor	r1, r1
     244:	1f be       	out	0x3f, r1	; 63
     246:	cf ef       	ldi	r28, 0xFF	; 255
     248:	d1 e2       	ldi	r29, 0x21	; 33
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	cd bf       	out	0x3d, r28	; 61
     24e:	00 e0       	ldi	r16, 0x00	; 0
     250:	0c bf       	out	0x3c, r16	; 60

00000252 <__do_copy_data>:
     252:	17 e0       	ldi	r17, 0x07	; 7
     254:	a0 e0       	ldi	r26, 0x00	; 0
     256:	b2 e0       	ldi	r27, 0x02	; 2
     258:	e0 e4       	ldi	r30, 0x40	; 64
     25a:	f2 e7       	ldi	r31, 0x72	; 114
     25c:	00 e0       	ldi	r16, 0x00	; 0
     25e:	0b bf       	out	0x3b, r16	; 59
     260:	02 c0       	rjmp	.+4      	; 0x266 <__do_copy_data+0x14>
     262:	07 90       	elpm	r0, Z+
     264:	0d 92       	st	X+, r0
     266:	aa 31       	cpi	r26, 0x1A	; 26
     268:	b1 07       	cpc	r27, r17
     26a:	d9 f7       	brne	.-10     	; 0x262 <__do_copy_data+0x10>

0000026c <__do_clear_bss>:
     26c:	2b e1       	ldi	r18, 0x1B	; 27
     26e:	aa e1       	ldi	r26, 0x1A	; 26
     270:	b7 e0       	ldi	r27, 0x07	; 7
     272:	01 c0       	rjmp	.+2      	; 0x276 <.do_clear_bss_start>

00000274 <.do_clear_bss_loop>:
     274:	1d 92       	st	X+, r1

00000276 <.do_clear_bss_start>:
     276:	a2 3e       	cpi	r26, 0xE2	; 226
     278:	b2 07       	cpc	r27, r18
     27a:	e1 f7       	brne	.-8      	; 0x274 <.do_clear_bss_loop>
     27c:	0e 94 08 15 	call	0x2a10	; 0x2a10 <main>
     280:	0c 94 1e 39 	jmp	0x723c	; 0x723c <_exit>

00000284 <__bad_interrupt>:
     284:	bd ce       	rjmp	.-646    	; 0x0 <__vectors>

00000286 <arq_init>:
  return len;
}

uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}
     286:	cf 93       	push	r28
     288:	df 93       	push	r29
     28a:	6c e3       	ldi	r22, 0x3C	; 60
     28c:	74 e0       	ldi	r23, 0x04	; 4
     28e:	81 e0       	ldi	r24, 0x01	; 1
     290:	0e 94 39 17 	call	0x2e72	; 0x2e72 <network_set_callback>
     294:	10 92 1b 07 	sts	0x071B, r1	; 0x80071b <__data_end+0x1>
     298:	10 92 1a 07 	sts	0x071A, r1	; 0x80071a <__data_end>
     29c:	cc e1       	ldi	r28, 0x1C	; 28
     29e:	d7 e0       	ldi	r29, 0x07	; 7
     2a0:	8d e8       	ldi	r24, 0x8D	; 141
     2a2:	fe 01       	movw	r30, r28
     2a4:	11 92       	st	Z+, r1
     2a6:	8a 95       	dec	r24
     2a8:	e9 f7       	brne	.-6      	; 0x2a4 <arq_init+0x1e>
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	0e 94 9d 19 	call	0x333a	; 0x333a <xQueueCreateMutex>
     2b0:	90 93 a6 07 	sts	0x07A6, r25	; 0x8007a6 <connections+0x8a>
     2b4:	80 93 a5 07 	sts	0x07A5, r24	; 0x8007a5 <connections+0x89>
     2b8:	18 82       	st	Y, r1
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	08 95       	ret

000002c0 <arq_new_connection>:
     2c0:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     2c4:	81 11       	cpse	r24, r1
     2c6:	16 c0       	rjmp	.+44     	; 0x2f4 <arq_new_connection+0x34>
     2c8:	ec e1       	ldi	r30, 0x1C	; 28
     2ca:	f7 e0       	ldi	r31, 0x07	; 7
     2cc:	16 8e       	std	Z+30, r1	; 0x1e
     2ce:	15 8e       	std	Z+29, r1	; 0x1d
     2d0:	16 8a       	std	Z+22, r1	; 0x16
     2d2:	15 8a       	std	Z+21, r1	; 0x15
     2d4:	14 a2       	std	Z+36, r1	; 0x24
     2d6:	13 a2       	std	Z+35, r1	; 0x23
     2d8:	12 a2       	std	Z+34, r1	; 0x22
     2da:	11 a2       	std	Z+33, r1	; 0x21
     2dc:	17 8e       	std	Z+31, r1	; 0x1f
     2de:	14 8e       	std	Z+28, r1	; 0x1c
     2e0:	12 8e       	std	Z+26, r1	; 0x1a
     2e2:	11 8e       	std	Z+25, r1	; 0x19
     2e4:	13 8e       	std	Z+27, r1	; 0x1b
     2e6:	10 92 a8 07 	sts	0x07A8, r1	; 0x8007a8 <connections+0x8c>
     2ea:	10 92 a7 07 	sts	0x07A7, r1	; 0x8007a7 <connections+0x8b>
     2ee:	91 e0       	ldi	r25, 0x01	; 1
     2f0:	90 83       	st	Z, r25
     2f2:	08 95       	ret
     2f4:	8f ef       	ldi	r24, 0xFF	; 255
     2f6:	08 95       	ret

000002f8 <arq_connect>:
     2f8:	cf 92       	push	r12
     2fa:	df 92       	push	r13
     2fc:	ef 92       	push	r14
     2fe:	ff 92       	push	r15
     300:	0f 93       	push	r16
     302:	1f 93       	push	r17
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	1f 92       	push	r1
     30a:	cd b7       	in	r28, 0x3d	; 61
     30c:	de b7       	in	r29, 0x3e	; 62
     30e:	69 01       	movw	r12, r18
     310:	e8 2e       	mov	r14, r24
     312:	f1 2c       	mov	r15, r1
     314:	9d e8       	ldi	r25, 0x8D	; 141
     316:	89 9f       	mul	r24, r25
     318:	80 01       	movw	r16, r0
     31a:	11 24       	eor	r1, r1
     31c:	04 5e       	subi	r16, 0xE4	; 228
     31e:	18 4f       	sbci	r17, 0xF8	; 248
     320:	83 e0       	ldi	r24, 0x03	; 3
     322:	f8 01       	movw	r30, r16
     324:	80 83       	st	Z, r24
     326:	50 8f       	std	Z+24, r21	; 0x18
     328:	47 8b       	std	Z+23, r20	; 0x17
     32a:	60 a3       	std	Z+32, r22	; 0x20
     32c:	82 e0       	ldi	r24, 0x02	; 2
     32e:	89 83       	std	Y+1, r24	; 0x01
     330:	0e 94 5b 2b 	call	0x56b6	; 0x56b6 <xTaskGetCurrentTaskHandle>
     334:	f8 01       	movw	r30, r16
     336:	e5 57       	subi	r30, 0x75	; 117
     338:	ff 4f       	sbci	r31, 0xFF	; 255
     33a:	91 83       	std	Z+1, r25	; 0x01
     33c:	80 83       	st	Z, r24
     33e:	0e 94 96 2e 	call	0x5d2c	; 0x5d2c <xTaskNotifyStateClear>
     342:	21 e0       	ldi	r18, 0x01	; 1
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	ae 01       	movw	r20, r28
     348:	4f 5f       	subi	r20, 0xFF	; 255
     34a:	5f 4f       	sbci	r21, 0xFF	; 255
     34c:	61 e0       	ldi	r22, 0x01	; 1
     34e:	f8 01       	movw	r30, r16
     350:	80 a1       	ldd	r24, Z+32	; 0x20
     352:	0e 94 44 17 	call	0x2e88	; 0x2e88 <network_send>
     356:	b6 01       	movw	r22, r12
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	0e 94 14 2c 	call	0x5828	; 0x5828 <ulTaskNotifyTake>
     35e:	67 2b       	or	r22, r23
     360:	68 2b       	or	r22, r24
     362:	69 2b       	or	r22, r25
     364:	61 f4       	brne	.+24     	; 0x37e <arq_connect+0x86>
     366:	8d e8       	ldi	r24, 0x8D	; 141
     368:	8e 9d       	mul	r24, r14
     36a:	f0 01       	movw	r30, r0
     36c:	8f 9d       	mul	r24, r15
     36e:	f0 0d       	add	r31, r0
     370:	11 24       	eor	r1, r1
     372:	e4 5e       	subi	r30, 0xE4	; 228
     374:	f8 4f       	sbci	r31, 0xF8	; 248
     376:	81 e0       	ldi	r24, 0x01	; 1
     378:	80 83       	st	Z, r24
     37a:	80 e0       	ldi	r24, 0x00	; 0
     37c:	2e c0       	rjmp	.+92     	; 0x3da <arq_connect+0xe2>
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	91 e0       	ldi	r25, 0x01	; 1
     382:	d7 d6       	rcall	.+3502   	; 0x1132 <pvPortMalloc>
     384:	00 97       	sbiw	r24, 0x00	; 0
     386:	31 f1       	breq	.+76     	; 0x3d4 <arq_connect+0xdc>
     388:	4d e8       	ldi	r20, 0x8D	; 141
     38a:	4e 9d       	mul	r20, r14
     38c:	90 01       	movw	r18, r0
     38e:	4f 9d       	mul	r20, r15
     390:	30 0d       	add	r19, r0
     392:	11 24       	eor	r1, r1
     394:	40 e0       	ldi	r20, 0x00	; 0
     396:	51 e0       	ldi	r21, 0x01	; 1
     398:	bc 01       	movw	r22, r24
     39a:	c9 01       	movw	r24, r18
     39c:	83 5e       	subi	r24, 0xE3	; 227
     39e:	98 4f       	sbci	r25, 0xF8	; 248
     3a0:	5b d3       	rcall	.+1718   	; 0xa58 <buffer_init>
     3a2:	84 e1       	ldi	r24, 0x14	; 20
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	c5 d6       	rcall	.+3466   	; 0x1132 <pvPortMalloc>
     3a8:	00 97       	sbiw	r24, 0x00	; 0
     3aa:	b1 f0       	breq	.+44     	; 0x3d8 <arq_connect+0xe0>
     3ac:	2d e8       	ldi	r18, 0x8D	; 141
     3ae:	2e 9d       	mul	r18, r14
     3b0:	80 01       	movw	r16, r0
     3b2:	2f 9d       	mul	r18, r15
     3b4:	10 0d       	add	r17, r0
     3b6:	11 24       	eor	r1, r1
     3b8:	44 e1       	ldi	r20, 0x14	; 20
     3ba:	50 e0       	ldi	r21, 0x00	; 0
     3bc:	bc 01       	movw	r22, r24
     3be:	c8 01       	movw	r24, r16
     3c0:	89 5d       	subi	r24, 0xD9	; 217
     3c2:	98 4f       	sbci	r25, 0xF8	; 248
     3c4:	49 d3       	rcall	.+1682   	; 0xa58 <buffer_init>
     3c6:	f8 01       	movw	r30, r16
     3c8:	e4 5e       	subi	r30, 0xE4	; 228
     3ca:	f8 4f       	sbci	r31, 0xF8	; 248
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	80 83       	st	Z, r24
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	03 c0       	rjmp	.+6      	; 0x3da <arq_connect+0xe2>
     3d4:	8f ef       	ldi	r24, 0xFF	; 255
     3d6:	01 c0       	rjmp	.+2      	; 0x3da <arq_connect+0xe2>
     3d8:	8f ef       	ldi	r24, 0xFF	; 255
     3da:	0f 90       	pop	r0
     3dc:	df 91       	pop	r29
     3de:	cf 91       	pop	r28
     3e0:	1f 91       	pop	r17
     3e2:	0f 91       	pop	r16
     3e4:	ff 90       	pop	r15
     3e6:	ef 90       	pop	r14
     3e8:	df 90       	pop	r13
     3ea:	cf 90       	pop	r12
     3ec:	08 95       	ret

000003ee <arq_close_connection>:
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
     3f2:	81 11       	cpse	r24, r1
     3f4:	34 c0       	rjmp	.+104    	; 0x45e <__FUSE_REGION_LENGTH__+0x5e>
     3f6:	20 e0       	ldi	r18, 0x00	; 0
     3f8:	4f ef       	ldi	r20, 0xFF	; 255
     3fa:	5f ef       	ldi	r21, 0xFF	; 255
     3fc:	60 e0       	ldi	r22, 0x00	; 0
     3fe:	70 e0       	ldi	r23, 0x00	; 0
     400:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     404:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     408:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
     40c:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     410:	82 30       	cpi	r24, 0x02	; 2
     412:	51 f0       	breq	.+20     	; 0x428 <__FUSE_REGION_LENGTH__+0x28>
     414:	60 e0       	ldi	r22, 0x00	; 0
     416:	70 e0       	ldi	r23, 0x00	; 0
     418:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     41c:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     420:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	1c c0       	rjmp	.+56     	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     428:	cc e1       	ldi	r28, 0x1C	; 28
     42a:	d7 e0       	ldi	r29, 0x07	; 7
     42c:	89 81       	ldd	r24, Y+1	; 0x01
     42e:	9a 81       	ldd	r25, Y+2	; 0x02
     430:	8e d7       	rcall	.+3868   	; 0x134e <vPortFree>
     432:	8b 85       	ldd	r24, Y+11	; 0x0b
     434:	9c 85       	ldd	r25, Y+12	; 0x0c
     436:	8b d7       	rcall	.+3862   	; 0x134e <vPortFree>
     438:	81 e0       	ldi	r24, 0x01	; 1
     43a:	88 83       	st	Y, r24
     43c:	ef 89       	ldd	r30, Y+23	; 0x17
     43e:	f8 8d       	ldd	r31, Y+24	; 0x18
     440:	60 e0       	ldi	r22, 0x00	; 0
     442:	70 e0       	ldi	r23, 0x00	; 0
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	19 95       	eicall
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     452:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     456:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
     45a:	81 e0       	ldi	r24, 0x01	; 1
     45c:	01 c0       	rjmp	.+2      	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	08 95       	ret

00000466 <arq_send>:
     466:	ef 92       	push	r14
     468:	ff 92       	push	r15
     46a:	0f 93       	push	r16
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	df 93       	push	r29
     472:	00 d0       	rcall	.+0      	; 0x474 <arq_send+0xe>
     474:	1f 92       	push	r1
     476:	cd b7       	in	r28, 0x3d	; 61
     478:	de b7       	in	r29, 0x3e	; 62
     47a:	5c 83       	std	Y+4, r21	; 0x04
     47c:	4b 83       	std	Y+3, r20	; 0x03
     47e:	81 11       	cpse	r24, r1
     480:	7b c0       	rjmp	.+246    	; 0x578 <arq_send+0x112>
     482:	7b 01       	movw	r14, r22
     484:	20 e0       	ldi	r18, 0x00	; 0
     486:	4f ef       	ldi	r20, 0xFF	; 255
     488:	5f ef       	ldi	r21, 0xFF	; 255
     48a:	60 e0       	ldi	r22, 0x00	; 0
     48c:	70 e0       	ldi	r23, 0x00	; 0
     48e:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     492:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     496:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
     49a:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     49e:	82 30       	cpi	r24, 0x02	; 2
     4a0:	51 f4       	brne	.+20     	; 0x4b6 <arq_send+0x50>
     4a2:	e1 14       	cp	r14, r1
     4a4:	f1 04       	cpc	r15, r1
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <arq_send+0x50>
     4a8:	0b 81       	ldd	r16, Y+3	; 0x03
     4aa:	1c 81       	ldd	r17, Y+4	; 0x04
     4ac:	c8 01       	movw	r24, r16
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	84 36       	cpi	r24, 0x64	; 100
     4b2:	91 05       	cpc	r25, r1
     4b4:	50 f0       	brcs	.+20     	; 0x4ca <arq_send+0x64>
     4b6:	60 e0       	ldi	r22, 0x00	; 0
     4b8:	70 e0       	ldi	r23, 0x00	; 0
     4ba:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     4be:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     4c2:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	58 c0       	rjmp	.+176    	; 0x57a <arq_send+0x114>
     4ca:	0e 5f       	subi	r16, 0xFE	; 254
     4cc:	1f 4f       	sbci	r17, 0xFF	; 255
     4ce:	20 91 25 07 	lds	r18, 0x0725	; 0x800725 <connections+0x9>
     4d2:	30 91 26 07 	lds	r19, 0x0726	; 0x800726 <connections+0xa>
     4d6:	80 e0       	ldi	r24, 0x00	; 0
     4d8:	91 e0       	ldi	r25, 0x01	; 1
     4da:	82 1b       	sub	r24, r18
     4dc:	93 0b       	sbc	r25, r19
     4de:	08 17       	cp	r16, r24
     4e0:	19 07       	cpc	r17, r25
     4e2:	08 f0       	brcs	.+2      	; 0x4e6 <arq_send+0x80>
     4e4:	3f c0       	rjmp	.+126    	; 0x564 <arq_send+0xfe>
     4e6:	20 91 2f 07 	lds	r18, 0x072F	; 0x80072f <connections+0x13>
     4ea:	30 91 30 07 	lds	r19, 0x0730	; 0x800730 <connections+0x14>
     4ee:	84 e1       	ldi	r24, 0x14	; 20
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	82 1b       	sub	r24, r18
     4f4:	93 0b       	sbc	r25, r19
     4f6:	02 97       	sbiw	r24, 0x02	; 2
     4f8:	a8 f1       	brcs	.+106    	; 0x564 <arq_send+0xfe>
     4fa:	8a e2       	ldi	r24, 0x2A	; 42
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	9a 83       	std	Y+2, r25	; 0x02
     500:	89 83       	std	Y+1, r24	; 0x01
     502:	42 e0       	ldi	r20, 0x02	; 2
     504:	50 e0       	ldi	r21, 0x00	; 0
     506:	be 01       	movw	r22, r28
     508:	6d 5f       	subi	r22, 0xFD	; 253
     50a:	7f 4f       	sbci	r23, 0xFF	; 255
     50c:	8d e1       	ldi	r24, 0x1D	; 29
     50e:	97 e0       	ldi	r25, 0x07	; 7
     510:	b5 d2       	rcall	.+1386   	; 0xa7c <buffer_append>
     512:	4b 81       	ldd	r20, Y+3	; 0x03
     514:	5c 81       	ldd	r21, Y+4	; 0x04
     516:	b7 01       	movw	r22, r14
     518:	8d e1       	ldi	r24, 0x1D	; 29
     51a:	97 e0       	ldi	r25, 0x07	; 7
     51c:	af d2       	rcall	.+1374   	; 0xa7c <buffer_append>
     51e:	01 15       	cp	r16, r1
     520:	11 05       	cpc	r17, r1
     522:	b1 f0       	breq	.+44     	; 0x550 <arq_send+0xea>
     524:	90 2f       	mov	r25, r16
     526:	81 2f       	mov	r24, r17
     528:	0b 32       	cpi	r16, 0x2B	; 43
     52a:	11 05       	cpc	r17, r1
     52c:	10 f0       	brcs	.+4      	; 0x532 <arq_send+0xcc>
     52e:	9a e2       	ldi	r25, 0x2A	; 42
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	99 83       	std	Y+1, r25	; 0x01
     534:	8a 83       	std	Y+2, r24	; 0x02
     536:	42 e0       	ldi	r20, 0x02	; 2
     538:	50 e0       	ldi	r21, 0x00	; 0
     53a:	be 01       	movw	r22, r28
     53c:	6f 5f       	subi	r22, 0xFF	; 255
     53e:	7f 4f       	sbci	r23, 0xFF	; 255
     540:	87 e2       	ldi	r24, 0x27	; 39
     542:	97 e0       	ldi	r25, 0x07	; 7
     544:	9b d2       	rcall	.+1334   	; 0xa7c <buffer_append>
     546:	89 81       	ldd	r24, Y+1	; 0x01
     548:	9a 81       	ldd	r25, Y+2	; 0x02
     54a:	08 1b       	sub	r16, r24
     54c:	19 0b       	sbc	r17, r25
     54e:	51 f7       	brne	.-44     	; 0x524 <arq_send+0xbe>
     550:	60 e0       	ldi	r22, 0x00	; 0
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     558:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     55c:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	0b c0       	rjmp	.+22     	; 0x57a <arq_send+0x114>
     564:	60 e0       	ldi	r22, 0x00	; 0
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     56c:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     570:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	01 c0       	rjmp	.+2      	; 0x57a <arq_send+0x114>
     578:	80 e0       	ldi	r24, 0x00	; 0
     57a:	0f 90       	pop	r0
     57c:	0f 90       	pop	r0
     57e:	0f 90       	pop	r0
     580:	0f 90       	pop	r0
     582:	df 91       	pop	r29
     584:	cf 91       	pop	r28
     586:	1f 91       	pop	r17
     588:	0f 91       	pop	r16
     58a:	ff 90       	pop	r15
     58c:	ef 90       	pop	r14
     58e:	08 95       	ret

00000590 <arq_send_ack>:

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	1f 92       	push	r1
     596:	1f 92       	push	r1
     598:	cd b7       	in	r28, 0x3d	; 61
     59a:	de b7       	in	r29, 0x3e	; 62
  if(id >= MAX_CONNECTIONS) return 0;
     59c:	81 11       	cpse	r24, r1
     59e:	14 c0       	rjmp	.+40     	; 0x5c8 <arq_send_ack+0x38>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
     5a0:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     5a4:	82 30       	cpi	r24, 0x02	; 2
     5a6:	91 f4       	brne	.+36     	; 0x5cc <arq_send_ack+0x3c>
     5a8:	66 23       	and	r22, r22
     5aa:	94 f0       	brlt	.+36     	; 0x5d0 <arq_send_ack+0x40>
    return 0;
  }
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	89 83       	std	Y+1, r24	; 0x01
  data[1] = sequence_number;
     5b0:	6a 83       	std	Y+2, r22	; 0x02
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
     5b2:	22 e0       	ldi	r18, 0x02	; 2
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	ae 01       	movw	r20, r28
     5b8:	4f 5f       	subi	r20, 0xFF	; 255
     5ba:	5f 4f       	sbci	r21, 0xFF	; 255
     5bc:	61 e0       	ldi	r22, 0x01	; 1
     5be:	80 91 3c 07 	lds	r24, 0x073C	; 0x80073c <connections+0x20>
     5c2:	0e 94 44 17 	call	0x2e88	; 0x2e88 <network_send>
     5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <arq_send_ack+0x42>
uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
  if(id >= MAX_CONNECTIONS) return 0;
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	03 c0       	rjmp	.+6      	; 0x5d2 <arq_send_ack+0x42>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
    return 0;
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <arq_send_ack+0x42>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}
     5d2:	0f 90       	pop	r0
     5d4:	0f 90       	pop	r0
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	08 95       	ret

000005dc <sender>:
/  When the transmit window has available space, it removes segments from the send buffer 
/  and sends them. It also increments a retransmit timer and timeout timer. When the retransmit timer
/  expires the function resends all the segments in the transmit window. On timeout the connection is
/  closed. 
*/
void sender(arq_connection id) { 
     5dc:	af 92       	push	r10
     5de:	bf 92       	push	r11
     5e0:	cf 92       	push	r12
     5e2:	df 92       	push	r13
     5e4:	ef 92       	push	r14
     5e6:	ff 92       	push	r15
     5e8:	0f 93       	push	r16
     5ea:	1f 93       	push	r17
     5ec:	cf 93       	push	r28
     5ee:	df 93       	push	r29
     5f0:	cd b7       	in	r28, 0x3d	; 61
     5f2:	de b7       	in	r29, 0x3e	; 62
     5f4:	ae 97       	sbiw	r28, 0x2e	; 46
     5f6:	0f b6       	in	r0, 0x3f	; 63
     5f8:	f8 94       	cli
     5fa:	de bf       	out	0x3e, r29	; 62
     5fc:	0f be       	out	0x3f, r0	; 63
     5fe:	cd bf       	out	0x3d, r28	; 61
  if(id >= MAX_CONNECTIONS) return;
     600:	81 11       	cpse	r24, r1
     602:	dc c0       	rjmp	.+440    	; 0x7bc <sender+0x1e0>
  arq_connection_t *con = &connections[id];
  if(con->status == STATUS_NONE) return;
     604:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     608:	88 23       	and	r24, r24
     60a:	09 f4       	brne	.+2      	; 0x60e <sender+0x32>
     60c:	d7 c0       	rjmp	.+430    	; 0x7bc <sender+0x1e0>
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     60e:	20 e0       	ldi	r18, 0x00	; 0
     610:	4f ef       	ldi	r20, 0xFF	; 255
     612:	5f ef       	ldi	r21, 0xFF	; 255
     614:	60 e0       	ldi	r22, 0x00	; 0
     616:	70 e0       	ldi	r23, 0x00	; 0
     618:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     61c:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     620:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
  
  if(con->status != STATUS_CONNECTED) {
     624:	80 91 1c 07 	lds	r24, 0x071C	; 0x80071c <connections>
     628:	82 30       	cpi	r24, 0x02	; 2
     62a:	49 f0       	breq	.+18     	; 0x63e <sender+0x62>
    xSemaphoreGive(con->mutex);
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     634:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     638:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
    return;
     63c:	bf c0       	rjmp	.+382    	; 0x7bc <sender+0x1e0>
  }

  if(con->timer_started) {
     63e:	80 91 3b 07 	lds	r24, 0x073B	; 0x80073b <connections+0x1f>
     642:	88 23       	and	r24, r24
     644:	09 f4       	brne	.+2      	; 0x648 <sender+0x6c>
     646:	62 c0       	rjmp	.+196    	; 0x70c <sender+0x130>
    con->timeout += 10;
     648:	ec e1       	ldi	r30, 0x1C	; 28
     64a:	f7 e0       	ldi	r31, 0x07	; 7
     64c:	85 8d       	ldd	r24, Z+29	; 0x1d
     64e:	96 8d       	ldd	r25, Z+30	; 0x1e
     650:	0a 96       	adiw	r24, 0x0a	; 10
     652:	96 8f       	std	Z+30, r25	; 0x1e
     654:	85 8f       	std	Z+29, r24	; 0x1d
    con->timer += 10;
     656:	24 8d       	ldd	r18, Z+28	; 0x1c
     658:	26 5f       	subi	r18, 0xF6	; 246
     65a:	24 8f       	std	Z+28, r18	; 0x1c
    if(con->timeout > LOST_CONNECTION_TIMEOUT_MS) { 
     65c:	89 3e       	cpi	r24, 0xE9	; 233
     65e:	93 40       	sbci	r25, 0x03	; 3
     660:	58 f0       	brcs	.+22     	; 0x678 <sender+0x9c>
      xSemaphoreGive(con->mutex);
     662:	60 e0       	ldi	r22, 0x00	; 0
     664:	70 e0       	ldi	r23, 0x00	; 0
     666:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     66a:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     66e:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
      arq_close_connection(id);
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	bc de       	rcall	.-648    	; 0x3ee <arq_close_connection>
      return;
     676:	a2 c0       	rjmp	.+324    	; 0x7bc <sender+0x1e0>
    }
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
     678:	29 3c       	cpi	r18, 0xC9	; 201
     67a:	08 f4       	brcc	.+2      	; 0x67e <sender+0xa2>
     67c:	47 c0       	rjmp	.+142    	; 0x70c <sender+0x130>
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
     67e:	ec e1       	ldi	r30, 0x1C	; 28
     680:	f7 e0       	ldi	r31, 0x07	; 7
     682:	07 81       	ldd	r16, Z+7	; 0x07
     684:	10 85       	ldd	r17, Z+8	; 0x08
      uint16_t len = 0;
     686:	1e a6       	std	Y+46, r1	; 0x2e
     688:	1d a6       	std	Y+45, r1	; 0x2d
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
     68a:	a1 8c       	ldd	r10, Z+25	; 0x19
     68c:	83 8d       	ldd	r24, Z+27	; 0x1b
     68e:	a8 1a       	sub	r10, r24
     690:	8a 2d       	mov	r24, r10
     692:	8f 77       	andi	r24, 0x7F	; 127
     694:	a8 2e       	mov	r10, r24
      while(i < resend_count) {
     696:	c1 f1       	breq	.+112    	; 0x708 <sender+0x12c>
     698:	c1 2c       	mov	r12, r1
     69a:	d1 2c       	mov	r13, r1
     69c:	b1 2c       	mov	r11, r1
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
        data[1] = (con->sequence_base+i) & 127; 
     69e:	7f 01       	movw	r14, r30
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
     6a0:	19 82       	std	Y+1, r1	; 0x01
        data[1] = (con->sequence_base+i) & 127; 
     6a2:	f7 01       	movw	r30, r14
     6a4:	83 8d       	ldd	r24, Z+27	; 0x1b
     6a6:	8b 0d       	add	r24, r11
     6a8:	8f 77       	andi	r24, 0x7F	; 127
     6aa:	8a 83       	std	Y+2, r24	; 0x02
        buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*i, 2);
     6ac:	41 89       	ldd	r20, Z+17	; 0x11
     6ae:	52 89       	ldd	r21, Z+18	; 0x12
     6b0:	4c 0d       	add	r20, r12
     6b2:	5d 1d       	adc	r21, r13
     6b4:	22 e0       	ldi	r18, 0x02	; 2
     6b6:	30 e0       	ldi	r19, 0x00	; 0
     6b8:	be 01       	movw	r22, r28
     6ba:	63 5d       	subi	r22, 0xD3	; 211
     6bc:	7f 4f       	sbci	r23, 0xFF	; 255
     6be:	87 e2       	ldi	r24, 0x27	; 39
     6c0:	97 e0       	ldi	r25, 0x07	; 7
     6c2:	8b d2       	rcall	.+1302   	; 0xbda <buffer_read>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
     6c4:	2d a5       	ldd	r18, Y+45	; 0x2d
     6c6:	3e a5       	ldd	r19, Y+46	; 0x2e
     6c8:	a8 01       	movw	r20, r16
     6ca:	be 01       	movw	r22, r28
     6cc:	6d 5f       	subi	r22, 0xFD	; 253
     6ce:	7f 4f       	sbci	r23, 0xFF	; 255
     6d0:	8d e1       	ldi	r24, 0x1D	; 29
     6d2:	97 e0       	ldi	r25, 0x07	; 7
     6d4:	82 d2       	rcall	.+1284   	; 0xbda <buffer_read>
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
     6d6:	2d a5       	ldd	r18, Y+45	; 0x2d
     6d8:	3e a5       	ldd	r19, Y+46	; 0x2e
     6da:	02 0f       	add	r16, r18
     6dc:	13 1f       	adc	r17, r19
     6de:	f7 01       	movw	r30, r14
     6e0:	83 81       	ldd	r24, Z+3	; 0x03
     6e2:	94 81       	ldd	r25, Z+4	; 0x04
     6e4:	01 97       	sbiw	r24, 0x01	; 1
     6e6:	08 23       	and	r16, r24
     6e8:	19 23       	and	r17, r25
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     6ea:	2e 5f       	subi	r18, 0xFE	; 254
     6ec:	3f 4f       	sbci	r19, 0xFF	; 255
     6ee:	ae 01       	movw	r20, r28
     6f0:	4f 5f       	subi	r20, 0xFF	; 255
     6f2:	5f 4f       	sbci	r21, 0xFF	; 255
     6f4:	61 e0       	ldi	r22, 0x01	; 1
     6f6:	80 a1       	ldd	r24, Z+32	; 0x20
     6f8:	0e 94 44 17 	call	0x2e88	; 0x2e88 <network_send>
        ++i;
     6fc:	b3 94       	inc	r11
     6fe:	f2 e0       	ldi	r31, 0x02	; 2
     700:	cf 0e       	add	r12, r31
     702:	d1 1c       	adc	r13, r1
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
     704:	ba 10       	cpse	r11, r10
     706:	cc cf       	rjmp	.-104    	; 0x6a0 <sender+0xc4>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
        ++i;
      }
      con->timer = 0;
     708:	10 92 38 07 	sts	0x0738, r1	; 0x800738 <connections+0x1c>
    }
  }
  if( ((con->sequence_number-con->sequence_base) & 127) < WINDOW_SIZE && con->send_buffer.head != con->send_buffer_window_end) {
     70c:	ec e1       	ldi	r30, 0x1C	; 28
     70e:	f7 e0       	ldi	r31, 0x07	; 7
     710:	81 8d       	ldd	r24, Z+25	; 0x19
     712:	48 2f       	mov	r20, r24
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	93 8d       	ldd	r25, Z+27	; 0x1b
     718:	49 1b       	sub	r20, r25
     71a:	51 09       	sbc	r21, r1
     71c:	4f 77       	andi	r20, 0x7F	; 127
     71e:	55 27       	eor	r21, r21
     720:	44 30       	cpi	r20, 0x04	; 4
     722:	51 05       	cpc	r21, r1
     724:	0c f0       	brlt	.+2      	; 0x728 <sender+0x14c>
     726:	42 c0       	rjmp	.+132    	; 0x7ac <sender+0x1d0>
     728:	65 81       	ldd	r22, Z+5	; 0x05
     72a:	76 81       	ldd	r23, Z+6	; 0x06
     72c:	25 89       	ldd	r18, Z+21	; 0x15
     72e:	36 89       	ldd	r19, Z+22	; 0x16
     730:	62 17       	cp	r22, r18
     732:	73 07       	cpc	r23, r19
     734:	d9 f1       	breq	.+118    	; 0x7ac <sender+0x1d0>
    uint8_t data[MAX_PAYLOAD_SIZE];
    uint16_t len;
    data[0] = TYPE_DATA;
     736:	19 82       	std	Y+1, r1	; 0x01
    data[1] = con->sequence_number;
     738:	8a 83       	std	Y+2, r24	; 0x02
    buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*((con->sequence_number-con->sequence_base) & 127), 2);
     73a:	44 0f       	add	r20, r20
     73c:	55 1f       	adc	r21, r21
     73e:	8f 01       	movw	r16, r30
     740:	81 89       	ldd	r24, Z+17	; 0x11
     742:	92 89       	ldd	r25, Z+18	; 0x12
     744:	48 0f       	add	r20, r24
     746:	59 1f       	adc	r21, r25
     748:	22 e0       	ldi	r18, 0x02	; 2
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	be 01       	movw	r22, r28
     74e:	63 5d       	subi	r22, 0xD3	; 211
     750:	7f 4f       	sbci	r23, 0xFF	; 255
     752:	87 e2       	ldi	r24, 0x27	; 39
     754:	97 e0       	ldi	r25, 0x07	; 7
     756:	41 d2       	rcall	.+1154   	; 0xbda <buffer_read>
    buffer_read(&con->send_buffer, &data[2], con->send_buffer_window_end, len);
     758:	2d a5       	ldd	r18, Y+45	; 0x2d
     75a:	3e a5       	ldd	r19, Y+46	; 0x2e
     75c:	f8 01       	movw	r30, r16
     75e:	45 89       	ldd	r20, Z+21	; 0x15
     760:	56 89       	ldd	r21, Z+22	; 0x16
     762:	be 01       	movw	r22, r28
     764:	6d 5f       	subi	r22, 0xFD	; 253
     766:	7f 4f       	sbci	r23, 0xFF	; 255
     768:	8d e1       	ldi	r24, 0x1D	; 29
     76a:	97 e0       	ldi	r25, 0x07	; 7
     76c:	36 d2       	rcall	.+1132   	; 0xbda <buffer_read>
    con->send_buffer_window_end = (con->send_buffer_window_end+len) & (con->send_buffer.capacity-1);
     76e:	2d a5       	ldd	r18, Y+45	; 0x2d
     770:	3e a5       	ldd	r19, Y+46	; 0x2e
     772:	f8 01       	movw	r30, r16
     774:	83 81       	ldd	r24, Z+3	; 0x03
     776:	94 81       	ldd	r25, Z+4	; 0x04
     778:	ac 01       	movw	r20, r24
     77a:	41 50       	subi	r20, 0x01	; 1
     77c:	51 09       	sbc	r21, r1
     77e:	85 89       	ldd	r24, Z+21	; 0x15
     780:	96 89       	ldd	r25, Z+22	; 0x16
     782:	82 0f       	add	r24, r18
     784:	93 1f       	adc	r25, r19
     786:	84 23       	and	r24, r20
     788:	95 23       	and	r25, r21
     78a:	96 8b       	std	Z+22, r25	; 0x16
     78c:	85 8b       	std	Z+21, r24	; 0x15
    con->timer_started = 1;
     78e:	81 e0       	ldi	r24, 0x01	; 1
     790:	87 8f       	std	Z+31, r24	; 0x1f
    con->sequence_number = (con->sequence_number+1) & 127;
     792:	81 8d       	ldd	r24, Z+25	; 0x19
     794:	8f 5f       	subi	r24, 0xFF	; 255
     796:	8f 77       	andi	r24, 0x7F	; 127
     798:	81 8f       	std	Z+25, r24	; 0x19
    network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     79a:	2e 5f       	subi	r18, 0xFE	; 254
     79c:	3f 4f       	sbci	r19, 0xFF	; 255
     79e:	ae 01       	movw	r20, r28
     7a0:	4f 5f       	subi	r20, 0xFF	; 255
     7a2:	5f 4f       	sbci	r21, 0xFF	; 255
     7a4:	61 e0       	ldi	r22, 0x01	; 1
     7a6:	80 a1       	ldd	r24, Z+32	; 0x20
     7a8:	0e 94 44 17 	call	0x2e88	; 0x2e88 <network_send>
  } 
  
  xSemaphoreGive(con->mutex);
     7ac:	60 e0       	ldi	r22, 0x00	; 0
     7ae:	70 e0       	ldi	r23, 0x00	; 0
     7b0:	80 91 a5 07 	lds	r24, 0x07A5	; 0x8007a5 <connections+0x89>
     7b4:	90 91 a6 07 	lds	r25, 0x07A6	; 0x8007a6 <connections+0x8a>
     7b8:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
}
     7bc:	ae 96       	adiw	r28, 0x2e	; 46
     7be:	0f b6       	in	r0, 0x3f	; 63
     7c0:	f8 94       	cli
     7c2:	de bf       	out	0x3e, r29	; 62
     7c4:	0f be       	out	0x3f, r0	; 63
     7c6:	cd bf       	out	0x3d, r28	; 61
     7c8:	df 91       	pop	r29
     7ca:	cf 91       	pop	r28
     7cc:	1f 91       	pop	r17
     7ce:	0f 91       	pop	r16
     7d0:	ff 90       	pop	r15
     7d2:	ef 90       	pop	r14
     7d4:	df 90       	pop	r13
     7d6:	cf 90       	pop	r12
     7d8:	bf 90       	pop	r11
     7da:	af 90       	pop	r10
     7dc:	08 95       	ret

000007de <arq_reassembly>:

void arq_reassembly(arq_connection id, uint8_t *data, uint16_t len) { 
     7de:	0f 93       	push	r16
     7e0:	1f 93       	push	r17
     7e2:	cf 93       	push	r28
     7e4:	df 93       	push	r29
     7e6:	ea 01       	movw	r28, r20
  if(id >= MAX_CONNECTIONS) return;
     7e8:	81 11       	cpse	r24, r1
     7ea:	41 c0       	rjmp	.+130    	; 0x86e <arq_reassembly+0x90>
  
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
     7ec:	80 91 3f 07 	lds	r24, 0x073F	; 0x80073f <connections+0x23>
     7f0:	90 91 40 07 	lds	r25, 0x0740	; 0x800740 <connections+0x24>
     7f4:	89 2b       	or	r24, r25
     7f6:	99 f4       	brne	.+38     	; 0x81e <arq_reassembly+0x40>
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
     7f8:	db 01       	movw	r26, r22
     7fa:	11 96       	adiw	r26, 0x01	; 1
     7fc:	8c 91       	ld	r24, X
     7fe:	11 97       	sbiw	r26, 0x01	; 1
     800:	90 e0       	ldi	r25, 0x00	; 0
     802:	98 2f       	mov	r25, r24
     804:	88 27       	eor	r24, r24
     806:	2c 91       	ld	r18, X
     808:	82 2b       	or	r24, r18
     80a:	90 93 40 07 	sts	0x0740, r25	; 0x800740 <connections+0x24>
     80e:	80 93 3f 07 	sts	0x073F, r24	; 0x80073f <connections+0x23>
    len-=2; // Remove the header from the length, left with the length of the payload
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
     812:	85 36       	cpi	r24, 0x65	; 101
     814:	91 05       	cpc	r25, r1
     816:	58 f5       	brcc	.+86     	; 0x86e <arq_reassembly+0x90>
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
    len-=2; // Remove the header from the length, left with the length of the payload
     818:	22 97       	sbiw	r28, 0x02	; 2
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
     81a:	6e 5f       	subi	r22, 0xFE	; 254
     81c:	7f 4f       	sbci	r23, 0xFF	; 255
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
      return;
    }
  } 
  memcpy(con->message+con->num_received_bytes, data, len);
     81e:	0c e1       	ldi	r16, 0x1C	; 28
     820:	17 e0       	ldi	r17, 0x07	; 7
     822:	f8 01       	movw	r30, r16
     824:	81 a1       	ldd	r24, Z+33	; 0x21
     826:	92 a1       	ldd	r25, Z+34	; 0x22
     828:	ae 01       	movw	r20, r28
     82a:	8f 5b       	subi	r24, 0xBF	; 191
     82c:	98 4f       	sbci	r25, 0xF8	; 248
     82e:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
  con->num_received_bytes += len;
     832:	d8 01       	movw	r26, r16
     834:	91 96       	adiw	r26, 0x21	; 33
     836:	6d 91       	ld	r22, X+
     838:	7c 91       	ld	r23, X
     83a:	92 97       	sbiw	r26, 0x22	; 34
     83c:	6c 0f       	add	r22, r28
     83e:	7d 1f       	adc	r23, r29
     840:	92 96       	adiw	r26, 0x22	; 34
     842:	7c 93       	st	X, r23
     844:	6e 93       	st	-X, r22
     846:	91 97       	sbiw	r26, 0x21	; 33
  
  if(con->num_received_bytes == con->receive_message_length) {
     848:	93 96       	adiw	r26, 0x23	; 35
     84a:	8d 91       	ld	r24, X+
     84c:	9c 91       	ld	r25, X
     84e:	94 97       	sbiw	r26, 0x24	; 36
     850:	68 17       	cp	r22, r24
     852:	79 07       	cpc	r23, r25
     854:	61 f4       	brne	.+24     	; 0x86e <arq_reassembly+0x90>
    con->callback_data_received(con->message, con->num_received_bytes);
     856:	57 96       	adiw	r26, 0x17	; 23
     858:	ed 91       	ld	r30, X+
     85a:	fc 91       	ld	r31, X
     85c:	58 97       	sbiw	r26, 0x18	; 24
     85e:	81 e4       	ldi	r24, 0x41	; 65
     860:	97 e0       	ldi	r25, 0x07	; 7
     862:	19 95       	eicall
    con->num_received_bytes = con->receive_message_length = 0;
     864:	f8 01       	movw	r30, r16
     866:	14 a2       	std	Z+36, r1	; 0x24
     868:	13 a2       	std	Z+35, r1	; 0x23
     86a:	12 a2       	std	Z+34, r1	; 0x22
     86c:	11 a2       	std	Z+33, r1	; 0x21
  }
}
     86e:	df 91       	pop	r29
     870:	cf 91       	pop	r28
     872:	1f 91       	pop	r17
     874:	0f 91       	pop	r16
     876:	08 95       	ret

00000878 <receiver>:
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
     878:	9f 92       	push	r9
     87a:	af 92       	push	r10
     87c:	bf 92       	push	r11
     87e:	cf 92       	push	r12
     880:	df 92       	push	r13
     882:	ef 92       	push	r14
     884:	ff 92       	push	r15
     886:	0f 93       	push	r16
     888:	1f 93       	push	r17
     88a:	cf 93       	push	r28
     88c:	df 93       	push	r29
     88e:	1f 92       	push	r1
     890:	cd b7       	in	r28, 0x3d	; 61
     892:	de b7       	in	r29, 0x3e	; 62
     894:	8b 01       	movw	r16, r22
     896:	5a 01       	movw	r10, r20
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
     898:	90 91 3c 07 	lds	r25, 0x073C	; 0x80073c <connections+0x20>
     89c:	98 13       	cpse	r25, r24
     89e:	b6 c0       	rjmp	.+364    	; 0xa0c <receiver+0x194>
     8a0:	90 91 1c 07 	lds	r25, 0x071C	; 0x80071c <connections>
     8a4:	99 23       	and	r25, r25
     8a6:	09 f4       	brne	.+2      	; 0x8aa <receiver+0x32>
     8a8:	b1 c0       	rjmp	.+354    	; 0xa0c <receiver+0x194>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     8aa:	fb 01       	movw	r30, r22
     8ac:	d0 80       	ld	r13, Z
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
      con = &connections[i];
     8ae:	0f 2e       	mov	r0, r31
     8b0:	fc e1       	ldi	r31, 0x1C	; 28
     8b2:	ef 2e       	mov	r14, r31
     8b4:	f7 e0       	ldi	r31, 0x07	; 7
     8b6:	ff 2e       	mov	r15, r31
     8b8:	f0 2d       	mov	r31, r0
     8ba:	11 c0       	rjmp	.+34     	; 0x8de <receiver+0x66>
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
  if(con == NULL && type == TYPE_SYN && listening_task != NULL) {
     8bc:	e0 91 1a 07 	lds	r30, 0x071A	; 0x80071a <__data_end>
     8c0:	f0 91 1b 07 	lds	r31, 0x071B	; 0x80071b <__data_end+0x1>
     8c4:	30 97       	sbiw	r30, 0x00	; 0
     8c6:	59 f0       	breq	.+22     	; 0x8de <receiver+0x66>
    xTaskNotify(listening_task, address, eSetValueWithOverwrite);
     8c8:	48 2f       	mov	r20, r24
     8ca:	50 e0       	ldi	r21, 0x00	; 0
     8cc:	60 e0       	ldi	r22, 0x00	; 0
     8ce:	70 e0       	ldi	r23, 0x00	; 0
     8d0:	00 e0       	ldi	r16, 0x00	; 0
     8d2:	10 e0       	ldi	r17, 0x00	; 0
     8d4:	23 e0       	ldi	r18, 0x03	; 3
     8d6:	cf 01       	movw	r24, r30
     8d8:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <xTaskGenericNotify>
    return;
     8dc:	a9 c0       	rjmp	.+338    	; 0xa30 <receiver+0x1b8>
  }
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     8de:	20 e0       	ldi	r18, 0x00	; 0
     8e0:	4f ef       	ldi	r20, 0xFF	; 255
     8e2:	5f ef       	ldi	r21, 0xFF	; 255
     8e4:	60 e0       	ldi	r22, 0x00	; 0
     8e6:	70 e0       	ldi	r23, 0x00	; 0
     8e8:	f7 01       	movw	r30, r14
     8ea:	e7 57       	subi	r30, 0x77	; 119
     8ec:	ff 4f       	sbci	r31, 0xFF	; 255
     8ee:	80 81       	ld	r24, Z
     8f0:	91 81       	ldd	r25, Z+1	; 0x01
     8f2:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
  
  if(con->status == STATUS_CLOSED || con->status == STATUS_NONE || len == 0 || data == NULL) {
     8f6:	f7 01       	movw	r30, r14
     8f8:	80 81       	ld	r24, Z
     8fa:	82 30       	cpi	r24, 0x02	; 2
     8fc:	30 f0       	brcs	.+12     	; 0x90a <receiver+0x92>
     8fe:	a1 14       	cp	r10, r1
     900:	b1 04       	cpc	r11, r1
     902:	19 f0       	breq	.+6      	; 0x90a <receiver+0x92>
     904:	01 15       	cp	r16, r1
     906:	11 05       	cpc	r17, r1
     908:	51 f4       	brne	.+20     	; 0x91e <receiver+0xa6>
    xSemaphoreGive(con->mutex);
     90a:	f7 01       	movw	r30, r14
     90c:	e7 57       	subi	r30, 0x77	; 119
     90e:	ff 4f       	sbci	r31, 0xFF	; 255
     910:	60 e0       	ldi	r22, 0x00	; 0
     912:	70 e0       	ldi	r23, 0x00	; 0
     914:	80 81       	ld	r24, Z
     916:	91 81       	ldd	r25, Z+1	; 0x01
     918:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
    return;
     91c:	89 c0       	rjmp	.+274    	; 0xa30 <receiver+0x1b8>
  }
  
  if(con->status == STATUS_CONNECTING && type == TYPE_SYNACK) {
     91e:	83 30       	cpi	r24, 0x03	; 3
     920:	21 f5       	brne	.+72     	; 0x96a <receiver+0xf2>
     922:	f3 e0       	ldi	r31, 0x03	; 3
     924:	df 12       	cpse	r13, r31
     926:	21 c0       	rjmp	.+66     	; 0x96a <receiver+0xf2>
    if(con->blocked_task != NULL) {
     928:	f7 01       	movw	r30, r14
     92a:	e5 57       	subi	r30, 0x75	; 117
     92c:	ff 4f       	sbci	r31, 0xFF	; 255
     92e:	80 81       	ld	r24, Z
     930:	91 81       	ldd	r25, Z+1	; 0x01
     932:	00 97       	sbiw	r24, 0x00	; 0
     934:	81 f0       	breq	.+32     	; 0x956 <receiver+0xde>
      xTaskNotifyGive(con->blocked_task);
     936:	00 e0       	ldi	r16, 0x00	; 0
     938:	10 e0       	ldi	r17, 0x00	; 0
     93a:	22 e0       	ldi	r18, 0x02	; 2
     93c:	40 e0       	ldi	r20, 0x00	; 0
     93e:	50 e0       	ldi	r21, 0x00	; 0
     940:	ba 01       	movw	r22, r20
     942:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <xTaskGenericNotify>
      con->blocked_task = NULL;
     946:	f7 01       	movw	r30, r14
     948:	e5 57       	subi	r30, 0x75	; 117
     94a:	ff 4f       	sbci	r31, 0xFF	; 255
     94c:	11 82       	std	Z+1, r1	; 0x01
     94e:	10 82       	st	Z, r1
      arq_send_ack(id, 0x00);
     950:	60 e0       	ldi	r22, 0x00	; 0
     952:	80 e0       	ldi	r24, 0x00	; 0
     954:	1d de       	rcall	.-966    	; 0x590 <arq_send_ack>
    }
    
    xSemaphoreGive(con->mutex);
     956:	f7 01       	movw	r30, r14
     958:	e7 57       	subi	r30, 0x77	; 119
     95a:	ff 4f       	sbci	r31, 0xFF	; 255
     95c:	60 e0       	ldi	r22, 0x00	; 0
     95e:	70 e0       	ldi	r23, 0x00	; 0
     960:	80 81       	ld	r24, Z
     962:	91 81       	ldd	r25, Z+1	; 0x01
     964:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
    return;
     968:	63 c0       	rjmp	.+198    	; 0xa30 <receiver+0x1b8>
  }
  
  uint8_t sequence = data[1];
     96a:	f8 01       	movw	r30, r16
     96c:	c1 80       	ldd	r12, Z+1	; 0x01
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
     96e:	dd 20       	and	r13, r13
     970:	09 f4       	brne	.+2      	; 0x974 <receiver+0xfc>
     972:	54 c0       	rjmp	.+168    	; 0xa1c <receiver+0x1a4>
     974:	f4 e0       	ldi	r31, 0x04	; 4
     976:	df 12       	cpse	r13, r31
     978:	13 c0       	rjmp	.+38     	; 0x9a0 <receiver+0x128>
     97a:	55 c0       	rjmp	.+170    	; 0xa26 <receiver+0x1ae>
    if(sequence == con->request_number) {
      if(type == TYPE_DATA) arq_reassembly(id, &data[2], len-2);
     97c:	a5 01       	movw	r20, r10
     97e:	42 50       	subi	r20, 0x02	; 2
     980:	51 09       	sbc	r21, r1
     982:	b8 01       	movw	r22, r16
     984:	6e 5f       	subi	r22, 0xFE	; 254
     986:	7f 4f       	sbci	r23, 0xFF	; 255
     988:	80 e0       	ldi	r24, 0x00	; 0
     98a:	29 df       	rcall	.-430    	; 0x7de <arq_reassembly>
      con->request_number = (con->request_number+1) & 127;
     98c:	f7 01       	movw	r30, r14
     98e:	82 8d       	ldd	r24, Z+26	; 0x1a
     990:	8f 5f       	subi	r24, 0xFF	; 255
     992:	8f 77       	andi	r24, 0x7F	; 127
     994:	82 8f       	std	Z+26, r24	; 0x1a
    }
    arq_send_ack(id, con->request_number);
     996:	f7 01       	movw	r30, r14
     998:	62 8d       	ldd	r22, Z+26	; 0x1a
     99a:	80 e0       	ldi	r24, 0x00	; 0
     99c:	f9 dd       	rcall	.-1038   	; 0x590 <arq_send_ack>
     99e:	2c c0       	rjmp	.+88     	; 0x9f8 <receiver+0x180>
  } else if(type == TYPE_ACK) {
     9a0:	f1 e0       	ldi	r31, 0x01	; 1
     9a2:	df 12       	cpse	r13, r31
     9a4:	29 c0       	rjmp	.+82     	; 0x9f8 <receiver+0x180>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
     9a6:	f7 01       	movw	r30, r14
     9a8:	83 8d       	ldd	r24, Z+27	; 0x1b
     9aa:	fc 2d       	mov	r31, r12
     9ac:	f8 1b       	sub	r31, r24
     9ae:	8f 2f       	mov	r24, r31
     9b0:	8f 77       	andi	r24, 0x7F	; 127
     9b2:	98 2e       	mov	r9, r24
    if(count != 0) {
     9b4:	09 f1       	breq	.+66     	; 0x9f8 <receiver+0x180>
     9b6:	d1 2c       	mov	r13, r1
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9b8:	57 01       	movw	r10, r14
     9ba:	8b e0       	ldi	r24, 0x0B	; 11
     9bc:	a8 0e       	add	r10, r24
     9be:	b1 1c       	adc	r11, r1
        buffer_remove(&con->send_buffer, NULL, len);
     9c0:	87 01       	movw	r16, r14
     9c2:	0f 5f       	subi	r16, 0xFF	; 255
     9c4:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9c6:	42 e0       	ldi	r20, 0x02	; 2
     9c8:	50 e0       	ldi	r21, 0x00	; 0
     9ca:	be 01       	movw	r22, r28
     9cc:	6f 5f       	subi	r22, 0xFF	; 255
     9ce:	7f 4f       	sbci	r23, 0xFF	; 255
     9d0:	c5 01       	movw	r24, r10
     9d2:	54 d1       	rcall	.+680    	; 0xc7c <buffer_remove>
        buffer_remove(&con->send_buffer, NULL, len);
     9d4:	49 81       	ldd	r20, Y+1	; 0x01
     9d6:	50 e0       	ldi	r21, 0x00	; 0
     9d8:	60 e0       	ldi	r22, 0x00	; 0
     9da:	70 e0       	ldi	r23, 0x00	; 0
     9dc:	c8 01       	movw	r24, r16
     9de:	4e d1       	rcall	.+668    	; 0xc7c <buffer_remove>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
     9e0:	d3 94       	inc	r13
     9e2:	d9 10       	cpse	r13, r9
     9e4:	f0 cf       	rjmp	.-32     	; 0x9c6 <receiver+0x14e>
        buffer_remove(&con->segment_lengths, &len, 2);
        buffer_remove(&con->send_buffer, NULL, len);
      }
      con->sequence_base = sequence;
     9e6:	f7 01       	movw	r30, r14
     9e8:	c3 8e       	std	Z+27, r12	; 0x1b

      con->timer = 0;
     9ea:	14 8e       	std	Z+28, r1	; 0x1c
      con->timeout = 0;
     9ec:	16 8e       	std	Z+30, r1	; 0x1e
     9ee:	15 8e       	std	Z+29, r1	; 0x1d
      if(con->sequence_base == con->sequence_number) con->timer_started = 0; // No more un-acked packets
     9f0:	81 8d       	ldd	r24, Z+25	; 0x19
     9f2:	c8 12       	cpse	r12, r24
     9f4:	01 c0       	rjmp	.+2      	; 0x9f8 <receiver+0x180>
     9f6:	17 8e       	std	Z+31, r1	; 0x1f
    }
  }
  
  xSemaphoreGive(con->mutex);
     9f8:	f7 01       	movw	r30, r14
     9fa:	e7 57       	subi	r30, 0x77	; 119
     9fc:	ff 4f       	sbci	r31, 0xFF	; 255
     9fe:	60 e0       	ldi	r22, 0x00	; 0
     a00:	70 e0       	ldi	r23, 0x00	; 0
     a02:	80 81       	ld	r24, Z
     a04:	91 81       	ldd	r25, Z+1	; 0x01
     a06:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
     a0a:	12 c0       	rjmp	.+36     	; 0xa30 <receiver+0x1b8>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     a0c:	f8 01       	movw	r30, r16
     a0e:	d0 80       	ld	r13, Z
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
  arq_connection_t *con = NULL;
     a10:	e1 2c       	mov	r14, r1
     a12:	f1 2c       	mov	r15, r1
      break;
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
     a14:	f2 e0       	ldi	r31, 0x02	; 2
     a16:	df 12       	cpse	r13, r31
     a18:	0b c0       	rjmp	.+22     	; 0xa30 <receiver+0x1b8>
     a1a:	50 cf       	rjmp	.-352    	; 0x8bc <receiver+0x44>
    return;
  }
  
  uint8_t sequence = data[1];
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
    if(sequence == con->request_number) {
     a1c:	f7 01       	movw	r30, r14
     a1e:	82 8d       	ldd	r24, Z+26	; 0x1a
     a20:	8c 11       	cpse	r24, r12
     a22:	b9 cf       	rjmp	.-142    	; 0x996 <receiver+0x11e>
     a24:	ab cf       	rjmp	.-170    	; 0x97c <receiver+0x104>
     a26:	f7 01       	movw	r30, r14
     a28:	82 8d       	ldd	r24, Z+26	; 0x1a
     a2a:	8c 11       	cpse	r24, r12
     a2c:	b4 cf       	rjmp	.-152    	; 0x996 <receiver+0x11e>
     a2e:	ae cf       	rjmp	.-164    	; 0x98c <receiver+0x114>
    }
  }
  
  xSemaphoreGive(con->mutex);
  
}
     a30:	0f 90       	pop	r0
     a32:	df 91       	pop	r29
     a34:	cf 91       	pop	r28
     a36:	1f 91       	pop	r17
     a38:	0f 91       	pop	r16
     a3a:	ff 90       	pop	r15
     a3c:	ef 90       	pop	r14
     a3e:	df 90       	pop	r13
     a40:	cf 90       	pop	r12
     a42:	bf 90       	pop	r11
     a44:	af 90       	pop	r10
     a46:	9f 90       	pop	r9
     a48:	08 95       	ret

00000a4a <vARQTask>:
void vARQTask(void *pvParamters) {
  uint8_t i;
  
  while(1) {
    for(i=0;i<MAX_CONNECTIONS;i++) {
		sender(i);
     a4a:	80 e0       	ldi	r24, 0x00	; 0
     a4c:	c7 dd       	rcall	.-1138   	; 0x5dc <sender>
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
     a4e:	8a e0       	ldi	r24, 0x0A	; 10
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <vTaskDelay>
  }
     a56:	f9 cf       	rjmp	.-14     	; 0xa4a <vARQTask>

00000a58 <buffer_init>:
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
     a58:	fc 01       	movw	r30, r24
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a5a:	61 15       	cp	r22, r1
     a5c:	71 05       	cpc	r23, r1
     a5e:	61 f0       	breq	.+24     	; 0xa78 <buffer_init+0x20>
  b->buf = buf;
     a60:	71 83       	std	Z+1, r23	; 0x01
     a62:	60 83       	st	Z, r22
  b->capacity = size;
     a64:	53 83       	std	Z+3, r21	; 0x03
     a66:	42 83       	std	Z+2, r20	; 0x02
  b->head = b->tail = b->len = 0;
     a68:	11 86       	std	Z+9, r1	; 0x09
     a6a:	10 86       	std	Z+8, r1	; 0x08
     a6c:	17 82       	std	Z+7, r1	; 0x07
     a6e:	16 82       	std	Z+6, r1	; 0x06
     a70:	15 82       	std	Z+5, r1	; 0x05
     a72:	14 82       	std	Z+4, r1	; 0x04
  return 1;
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	08 95       	ret
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a78:	80 e0       	ldi	r24, 0x00	; 0
  b->buf = buf;
  b->capacity = size;
  b->head = b->tail = b->len = 0;
  return 1;
}
     a7a:	08 95       	ret

00000a7c <buffer_append>:

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	ec 01       	movw	r28, r24
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     a8a:	2a 81       	ldd	r18, Y+2	; 0x02
     a8c:	3b 81       	ldd	r19, Y+3	; 0x03
     a8e:	88 85       	ldd	r24, Y+8	; 0x08
     a90:	99 85       	ldd	r25, Y+9	; 0x09
     a92:	f9 01       	movw	r30, r18
     a94:	e8 1b       	sub	r30, r24
     a96:	f9 0b       	sbc	r31, r25
     a98:	e4 17       	cp	r30, r20
     a9a:	f5 07       	cpc	r31, r21
     a9c:	08 f4       	brcc	.+2      	; 0xaa0 <buffer_append+0x24>
     a9e:	49 c0       	rjmp	.+146    	; 0xb32 <buffer_append+0xb6>
     aa0:	8a 01       	movw	r16, r20
     aa2:	7b 01       	movw	r14, r22
  if(len < b->capacity - b->head) {
     aa4:	8c 81       	ldd	r24, Y+4	; 0x04
     aa6:	9d 81       	ldd	r25, Y+5	; 0x05
     aa8:	a9 01       	movw	r20, r18
     aaa:	48 1b       	sub	r20, r24
     aac:	59 0b       	sbc	r21, r25
     aae:	04 17       	cp	r16, r20
     ab0:	15 07       	cpc	r17, r21
     ab2:	a8 f4       	brcc	.+42     	; 0xade <buffer_append+0x62>
    memcpy(b->buf+b->head, data, len);
     ab4:	28 81       	ld	r18, Y
     ab6:	39 81       	ldd	r19, Y+1	; 0x01
     ab8:	a8 01       	movw	r20, r16
     aba:	82 0f       	add	r24, r18
     abc:	93 1f       	adc	r25, r19
     abe:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    b->head += len;
     ac2:	8c 81       	ldd	r24, Y+4	; 0x04
     ac4:	9d 81       	ldd	r25, Y+5	; 0x05
     ac6:	80 0f       	add	r24, r16
     ac8:	91 1f       	adc	r25, r17
     aca:	9d 83       	std	Y+5, r25	; 0x05
     acc:	8c 83       	std	Y+4, r24	; 0x04
    if(b->head == b->capacity) b->head = 0;
     ace:	2a 81       	ldd	r18, Y+2	; 0x02
     ad0:	3b 81       	ldd	r19, Y+3	; 0x03
     ad2:	82 17       	cp	r24, r18
     ad4:	93 07       	cpc	r25, r19
     ad6:	21 f5       	brne	.+72     	; 0xb20 <buffer_append+0xa4>
     ad8:	1d 82       	std	Y+5, r1	; 0x05
     ada:	1c 82       	std	Y+4, r1	; 0x04
     adc:	21 c0       	rjmp	.+66     	; 0xb20 <buffer_append+0xa4>
  } else {
    memcpy(b->buf+b->head, data, (b->capacity - b->head) );
     ade:	28 81       	ld	r18, Y
     ae0:	39 81       	ldd	r19, Y+1	; 0x01
     ae2:	82 0f       	add	r24, r18
     ae4:	93 1f       	adc	r25, r19
     ae6:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
     aea:	8c 81       	ldd	r24, Y+4	; 0x04
     aec:	9d 81       	ldd	r25, Y+5	; 0x05
     aee:	6a 81       	ldd	r22, Y+2	; 0x02
     af0:	7b 81       	ldd	r23, Y+3	; 0x03
     af2:	ac 01       	movw	r20, r24
     af4:	46 1b       	sub	r20, r22
     af6:	57 0b       	sbc	r21, r23
     af8:	40 0f       	add	r20, r16
     afa:	51 1f       	adc	r21, r17
     afc:	68 1b       	sub	r22, r24
     afe:	79 0b       	sbc	r23, r25
     b00:	6e 0d       	add	r22, r14
     b02:	7f 1d       	adc	r23, r15
     b04:	88 81       	ld	r24, Y
     b06:	99 81       	ldd	r25, Y+1	; 0x01
     b08:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    b->head = len-(b->capacity - b->head);
     b0c:	8c 81       	ldd	r24, Y+4	; 0x04
     b0e:	9d 81       	ldd	r25, Y+5	; 0x05
     b10:	2a 81       	ldd	r18, Y+2	; 0x02
     b12:	3b 81       	ldd	r19, Y+3	; 0x03
     b14:	82 1b       	sub	r24, r18
     b16:	93 0b       	sbc	r25, r19
     b18:	80 0f       	add	r24, r16
     b1a:	91 1f       	adc	r25, r17
     b1c:	9d 83       	std	Y+5, r25	; 0x05
     b1e:	8c 83       	std	Y+4, r24	; 0x04
  }
  b->len += len;
     b20:	48 85       	ldd	r20, Y+8	; 0x08
     b22:	59 85       	ldd	r21, Y+9	; 0x09
     b24:	04 0f       	add	r16, r20
     b26:	15 1f       	adc	r17, r21
     b28:	19 87       	std	Y+9, r17	; 0x09
     b2a:	08 87       	std	Y+8, r16	; 0x08
  return 1;
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	02 c0       	rjmp	.+4      	; 0xb36 <buffer_append+0xba>
  b->head = b->tail = b->len = 0;
  return 1;
}

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	90 e0       	ldi	r25, 0x00	; 0
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
    b->head = len-(b->capacity - b->head);
  }
  b->len += len;
  return 1;
}
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	08 95       	ret

00000b44 <buffer_remove_token>:

//This reads bytes from the buffer until token is found, or nbytes is reached
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
     b44:	0f 93       	push	r16
     b46:	1f 93       	push	r17
     b48:	cf 93       	push	r28
     b4a:	df 93       	push	r29
     b4c:	fc 01       	movw	r30, r24
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     b4e:	21 15       	cp	r18, r1
     b50:	31 05       	cpc	r19, r1
     b52:	e1 f1       	breq	.+120    	; 0xbcc <buffer_remove_token+0x88>
    if( b->tail != b->head ){ //see if any data is available
     b54:	a6 81       	ldd	r26, Z+6	; 0x06
     b56:	b7 81       	ldd	r27, Z+7	; 0x07
     b58:	84 81       	ldd	r24, Z+4	; 0x04
     b5a:	95 81       	ldd	r25, Z+5	; 0x05
     b5c:	a8 17       	cp	r26, r24
     b5e:	b9 07       	cpc	r27, r25
     b60:	61 f1       	breq	.+88     	; 0xbba <buffer_remove_token+0x76>
     b62:	c6 2f       	mov	r28, r22
     b64:	d7 2f       	mov	r29, r23
     b66:	80 e0       	ldi	r24, 0x00	; 0
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	07 c0       	rjmp	.+14     	; 0xb7a <buffer_remove_token+0x36>
     b6c:	a6 81       	ldd	r26, Z+6	; 0x06
     b6e:	b7 81       	ldd	r27, Z+7	; 0x07
     b70:	64 81       	ldd	r22, Z+4	; 0x04
     b72:	75 81       	ldd	r23, Z+5	; 0x05
     b74:	a6 17       	cp	r26, r22
     b76:	b7 07       	cpc	r27, r23
     b78:	59 f1       	breq	.+86     	; 0xbd0 <buffer_remove_token+0x8c>
      *p++ = b->buf[b->tail];  //grab a byte from the buffer
     b7a:	60 81       	ld	r22, Z
     b7c:	71 81       	ldd	r23, Z+1	; 0x01
     b7e:	a6 0f       	add	r26, r22
     b80:	b7 1f       	adc	r27, r23
     b82:	5c 91       	ld	r21, X
     b84:	8e 01       	movw	r16, r28
     b86:	58 83       	st	Y, r21
      b->tail++;  //increment the tail
     b88:	66 81       	ldd	r22, Z+6	; 0x06
     b8a:	77 81       	ldd	r23, Z+7	; 0x07
     b8c:	6f 5f       	subi	r22, 0xFF	; 255
     b8e:	7f 4f       	sbci	r23, 0xFF	; 255
     b90:	77 83       	std	Z+7, r23	; 0x07
     b92:	66 83       	std	Z+6, r22	; 0x06
      b->len--;
     b94:	a0 85       	ldd	r26, Z+8	; 0x08
     b96:	b1 85       	ldd	r27, Z+9	; 0x09
     b98:	11 97       	sbiw	r26, 0x01	; 1
     b9a:	b1 87       	std	Z+9, r27	; 0x09
     b9c:	a0 87       	std	Z+8, r26	; 0x08
      if( b->tail == b->capacity ){  //check for wrap-around
     b9e:	a2 81       	ldd	r26, Z+2	; 0x02
     ba0:	b3 81       	ldd	r27, Z+3	; 0x03
     ba2:	6a 17       	cp	r22, r26
     ba4:	7b 07       	cpc	r23, r27
     ba6:	11 f4       	brne	.+4      	; 0xbac <buffer_remove_token+0x68>
        b->tail = 0;
     ba8:	17 82       	std	Z+7, r1	; 0x07
     baa:	16 82       	std	Z+6, r1	; 0x06
     bac:	21 96       	adiw	r28, 0x01	; 1
      }
      if(*(p-1) == token) return i+1;
     bae:	d8 01       	movw	r26, r16
     bb0:	5c 91       	ld	r21, X
     bb2:	54 13       	cpse	r21, r20
     bb4:	05 c0       	rjmp	.+10     	; 0xbc0 <buffer_remove_token+0x7c>
     bb6:	01 96       	adiw	r24, 0x01	; 1
     bb8:	0b c0       	rjmp	.+22     	; 0xbd0 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     bba:	80 e0       	ldi	r24, 0x00	; 0
     bbc:	90 e0       	ldi	r25, 0x00	; 0
      if( b->tail == b->capacity ){  //check for wrap-around
        b->tail = 0;
      }
      if(*(p-1) == token) return i+1;
    } else {
      return i; //number of bytes read
     bbe:	08 c0       	rjmp	.+16     	; 0xbd0 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     bc0:	01 96       	adiw	r24, 0x01	; 1
     bc2:	82 17       	cp	r24, r18
     bc4:	93 07       	cpc	r25, r19
     bc6:	91 f6       	brne	.-92     	; 0xb6c <buffer_remove_token+0x28>
      if(*(p-1) == token) return i+1;
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
     bc8:	c9 01       	movw	r24, r18
     bca:	02 c0       	rjmp	.+4      	; 0xbd0 <buffer_remove_token+0x8c>
     bcc:	80 e0       	ldi	r24, 0x00	; 0
     bce:	90 e0       	ldi	r25, 0x00	; 0
}
     bd0:	df 91       	pop	r29
     bd2:	cf 91       	pop	r28
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	08 95       	ret

00000bda <buffer_read>:
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
     bda:	cf 92       	push	r12
     bdc:	df 92       	push	r13
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	7c 01       	movw	r14, r24
     bec:	6b 01       	movw	r12, r22
     bee:	ea 01       	movw	r28, r20
     bf0:	89 01       	movw	r16, r18
  if(data == NULL) return 0;
     bf2:	67 2b       	or	r22, r23
     bf4:	c1 f1       	breq	.+112    	; 0xc66 <buffer_read+0x8c>
  if(idx >= b->capacity) idx -= b->capacity;
     bf6:	dc 01       	movw	r26, r24
     bf8:	12 96       	adiw	r26, 0x02	; 2
     bfa:	ed 91       	ld	r30, X+
     bfc:	fc 91       	ld	r31, X
     bfe:	13 97       	sbiw	r26, 0x03	; 3
     c00:	4e 17       	cp	r20, r30
     c02:	5f 07       	cpc	r21, r31
     c04:	10 f0       	brcs	.+4      	; 0xc0a <buffer_read+0x30>
     c06:	ce 1b       	sub	r28, r30
     c08:	df 0b       	sbc	r29, r31
  if(b->capacity - idx >= len) {
     c0a:	af 01       	movw	r20, r30
     c0c:	4c 1b       	sub	r20, r28
     c0e:	5d 0b       	sbc	r21, r29
     c10:	40 17       	cp	r20, r16
     c12:	51 07       	cpc	r21, r17
     c14:	60 f0       	brcs	.+24     	; 0xc2e <buffer_read+0x54>
    memcpy(data, b->buf+idx, len);
     c16:	f7 01       	movw	r30, r14
     c18:	60 81       	ld	r22, Z
     c1a:	71 81       	ldd	r23, Z+1	; 0x01
     c1c:	6c 0f       	add	r22, r28
     c1e:	7d 1f       	adc	r23, r29
     c20:	a8 01       	movw	r20, r16
     c22:	c6 01       	movw	r24, r12
     c24:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
     c28:	80 2f       	mov	r24, r16
     c2a:	91 2f       	mov	r25, r17
     c2c:	1e c0       	rjmp	.+60     	; 0xc6a <buffer_read+0x90>
  if(data == NULL) return 0;
  if(idx >= b->capacity) idx -= b->capacity;
  if(b->capacity - idx >= len) {
    memcpy(data, b->buf+idx, len);
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
     c2e:	d7 01       	movw	r26, r14
     c30:	6d 91       	ld	r22, X+
     c32:	7c 91       	ld	r23, X
     c34:	6c 0f       	add	r22, r28
     c36:	7d 1f       	adc	r23, r29
     c38:	c6 01       	movw	r24, r12
     c3a:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
     c3e:	f7 01       	movw	r30, r14
     c40:	22 81       	ldd	r18, Z+2	; 0x02
     c42:	33 81       	ldd	r19, Z+3	; 0x03
     c44:	c9 01       	movw	r24, r18
     c46:	8c 1b       	sub	r24, r28
     c48:	9d 0b       	sbc	r25, r29
     c4a:	a8 01       	movw	r20, r16
     c4c:	42 1b       	sub	r20, r18
     c4e:	53 0b       	sbc	r21, r19
     c50:	4c 0f       	add	r20, r28
     c52:	5d 1f       	adc	r21, r29
     c54:	60 81       	ld	r22, Z
     c56:	71 81       	ldd	r23, Z+1	; 0x01
     c58:	8c 0d       	add	r24, r12
     c5a:	9d 1d       	adc	r25, r13
     c5c:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
  }
  return len;
     c60:	80 2f       	mov	r24, r16
     c62:	91 2f       	mov	r25, r17
     c64:	02 c0       	rjmp	.+4      	; 0xc6a <buffer_read+0x90>
  }
  return nbytes;
}
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
  if(data == NULL) return 0;
     c66:	80 e0       	ldi	r24, 0x00	; 0
     c68:	90 e0       	ldi	r25, 0x00	; 0
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
}
     c6a:	df 91       	pop	r29
     c6c:	cf 91       	pop	r28
     c6e:	1f 91       	pop	r17
     c70:	0f 91       	pop	r16
     c72:	ff 90       	pop	r15
     c74:	ef 90       	pop	r14
     c76:	df 90       	pop	r13
     c78:	cf 90       	pop	r12
     c7a:	08 95       	ret

00000c7c <buffer_remove>:

//Remove 'len' bytes from the buffer and add them to 'data'
uint16_t buffer_remove(buffer_t *b, uint8_t *data, uint16_t len) {
     c7c:	ef 92       	push	r14
     c7e:	ff 92       	push	r15
     c80:	0f 93       	push	r16
     c82:	1f 93       	push	r17
     c84:	cf 93       	push	r28
     c86:	df 93       	push	r29
     c88:	ec 01       	movw	r28, r24
     c8a:	7b 01       	movw	r14, r22
  if(len > b->len) len = b->len;
     c8c:	88 85       	ldd	r24, Y+8	; 0x08
     c8e:	99 85       	ldd	r25, Y+9	; 0x09
     c90:	04 2f       	mov	r16, r20
     c92:	15 2f       	mov	r17, r21
     c94:	80 17       	cp	r24, r16
     c96:	91 07       	cpc	r25, r17
     c98:	08 f4       	brcc	.+2      	; 0xc9c <buffer_remove+0x20>
     c9a:	8c 01       	movw	r16, r24
  if(b->capacity - b->tail >= len) {
     c9c:	2e 81       	ldd	r18, Y+6	; 0x06
     c9e:	3f 81       	ldd	r19, Y+7	; 0x07
     ca0:	4a 81       	ldd	r20, Y+2	; 0x02
     ca2:	5b 81       	ldd	r21, Y+3	; 0x03
     ca4:	42 1b       	sub	r20, r18
     ca6:	53 0b       	sbc	r21, r19
     ca8:	40 17       	cp	r20, r16
     caa:	51 07       	cpc	r21, r17
     cac:	c8 f0       	brcs	.+50     	; 0xce0 <buffer_remove+0x64>
    if(data != NULL) memcpy(data, b->buf+b->tail, len);
     cae:	e1 14       	cp	r14, r1
     cb0:	f1 04       	cpc	r15, r1
     cb2:	41 f0       	breq	.+16     	; 0xcc4 <buffer_remove+0x48>
     cb4:	68 81       	ld	r22, Y
     cb6:	79 81       	ldd	r23, Y+1	; 0x01
     cb8:	62 0f       	add	r22, r18
     cba:	73 1f       	adc	r23, r19
     cbc:	a8 01       	movw	r20, r16
     cbe:	c7 01       	movw	r24, r14
     cc0:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    b->tail = b->tail + len;
     cc4:	8e 81       	ldd	r24, Y+6	; 0x06
     cc6:	9f 81       	ldd	r25, Y+7	; 0x07
     cc8:	80 0f       	add	r24, r16
     cca:	91 1f       	adc	r25, r17
     ccc:	9f 83       	std	Y+7, r25	; 0x07
     cce:	8e 83       	std	Y+6, r24	; 0x06
    if(b->tail == b->capacity) b->tail = 0;
     cd0:	2a 81       	ldd	r18, Y+2	; 0x02
     cd2:	3b 81       	ldd	r19, Y+3	; 0x03
     cd4:	82 17       	cp	r24, r18
     cd6:	93 07       	cpc	r25, r19
     cd8:	41 f5       	brne	.+80     	; 0xd2a <buffer_remove+0xae>
     cda:	1f 82       	std	Y+7, r1	; 0x07
     cdc:	1e 82       	std	Y+6, r1	; 0x06
     cde:	25 c0       	rjmp	.+74     	; 0xd2a <buffer_remove+0xae>
  } else {
    if(data != NULL) {
     ce0:	e1 14       	cp	r14, r1
     ce2:	f1 04       	cpc	r15, r1
     ce4:	c1 f0       	breq	.+48     	; 0xd16 <buffer_remove+0x9a>
      memcpy(data, b->buf+b->tail, b->capacity - b->tail);
     ce6:	68 81       	ld	r22, Y
     ce8:	79 81       	ldd	r23, Y+1	; 0x01
     cea:	62 0f       	add	r22, r18
     cec:	73 1f       	adc	r23, r19
     cee:	c7 01       	movw	r24, r14
     cf0:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
      memcpy(data + (b->capacity - b->tail), b->buf, len - (b->capacity - b->tail) );
     cf4:	4e 81       	ldd	r20, Y+6	; 0x06
     cf6:	5f 81       	ldd	r21, Y+7	; 0x07
     cf8:	2a 81       	ldd	r18, Y+2	; 0x02
     cfa:	3b 81       	ldd	r19, Y+3	; 0x03
     cfc:	c9 01       	movw	r24, r18
     cfe:	84 1b       	sub	r24, r20
     d00:	95 0b       	sbc	r25, r21
     d02:	42 1b       	sub	r20, r18
     d04:	53 0b       	sbc	r21, r19
     d06:	40 0f       	add	r20, r16
     d08:	51 1f       	adc	r21, r17
     d0a:	68 81       	ld	r22, Y
     d0c:	79 81       	ldd	r23, Y+1	; 0x01
     d0e:	8e 0d       	add	r24, r14
     d10:	9f 1d       	adc	r25, r15
     d12:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    }
    b->tail = len - (b->capacity - b->tail);
     d16:	8e 81       	ldd	r24, Y+6	; 0x06
     d18:	9f 81       	ldd	r25, Y+7	; 0x07
     d1a:	2a 81       	ldd	r18, Y+2	; 0x02
     d1c:	3b 81       	ldd	r19, Y+3	; 0x03
     d1e:	82 1b       	sub	r24, r18
     d20:	93 0b       	sbc	r25, r19
     d22:	80 0f       	add	r24, r16
     d24:	91 1f       	adc	r25, r17
     d26:	9f 83       	std	Y+7, r25	; 0x07
     d28:	8e 83       	std	Y+6, r24	; 0x06
  }
  b->len -= len;
     d2a:	88 85       	ldd	r24, Y+8	; 0x08
     d2c:	99 85       	ldd	r25, Y+9	; 0x09
     d2e:	80 1b       	sub	r24, r16
     d30:	91 0b       	sbc	r25, r17
     d32:	99 87       	std	Y+9, r25	; 0x09
     d34:	88 87       	std	Y+8, r24	; 0x08
  return len;
     d36:	c8 01       	movw	r24, r16
     d38:	df 91       	pop	r29
     d3a:	cf 91       	pop	r28
     d3c:	1f 91       	pop	r17
     d3e:	0f 91       	pop	r16
     d40:	ff 90       	pop	r15
     d42:	ef 90       	pop	r14
     d44:	08 95       	ret

00000d46 <cobs_encode>:
/*****************************************************************************
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     d46:	df 92       	push	r13
     d48:	ef 92       	push	r14
     d4a:	ff 92       	push	r15
     d4c:	0f 93       	push	r16
     d4e:	1f 93       	push	r17
     d50:	cf 93       	push	r28
     d52:	df 93       	push	r29
     d54:	7c 01       	movw	r14, r24
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     d56:	68 0f       	add	r22, r24
     d58:	79 1f       	adc	r23, r25
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
     d5a:	fc 01       	movw	r30, r24
     d5c:	31 96       	adiw	r30, 0x01	; 1
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     d5e:	00 97       	sbiw	r24, 0x00	; 0
     d60:	19 f0       	breq	.+6      	; 0xd68 <cobs_encode+0x22>
     d62:	41 15       	cp	r20, r1
     d64:	51 05       	cpc	r21, r1
     d66:	21 f4       	brne	.+8      	; 0xd70 <cobs_encode+0x2a>
    {
        result.status = COBS_ENCODE_NULL_POINTER;
        return result;
     d68:	60 e0       	ldi	r22, 0x00	; 0
     d6a:	70 e0       	ldi	r23, 0x00	; 0
     d6c:	81 e0       	ldi	r24, 0x01	; 1
     d6e:	4e c0       	rjmp	.+156    	; 0xe0c <cobs_encode+0xc6>
    }

    if (src_len != 0)
     d70:	21 15       	cp	r18, r1
     d72:	31 05       	cpc	r19, r1
     d74:	71 f1       	breq	.+92     	; 0xdd2 <cobs_encode+0x8c>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d76:	e6 17       	cp	r30, r22
     d78:	f7 07       	cpc	r31, r23
     d7a:	78 f5       	brcc	.+94     	; 0xdda <cobs_encode+0x94>
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     d7c:	8a 01       	movw	r16, r20
     d7e:	02 0f       	add	r16, r18
     d80:	13 1f       	adc	r17, r19
     d82:	da 01       	movw	r26, r20
     d84:	ec 01       	movw	r28, r24
     d86:	91 e0       	ldi	r25, 0x01	; 1
                }
                if (search_len == 0xFF)
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     d88:	dd 24       	eor	r13, r13
     d8a:	da 94       	dec	r13
                    dst_code_write_ptr = dst_write_ptr++;
                    search_len = 1;
     d8c:	81 e0       	ldi	r24, 0x01	; 1
     d8e:	04 c0       	rjmp	.+8      	; 0xd98 <cobs_encode+0x52>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     d90:	fa 01       	movw	r30, r20
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d92:	e6 17       	cp	r30, r22
     d94:	f7 07       	cpc	r31, r23
     d96:	28 f5       	brcc	.+74     	; 0xde2 <cobs_encode+0x9c>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
                break;
            }

            src_byte = *src_ptr++;
     d98:	3d 91       	ld	r19, X+
            if (src_byte == 0)
     d9a:	31 11       	cpse	r19, r1
     d9c:	0b c0       	rjmp	.+22     	; 0xdb4 <cobs_encode+0x6e>
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
     d9e:	98 83       	st	Y, r25
                dst_code_write_ptr = dst_write_ptr++;
     da0:	9f 01       	movw	r18, r30
     da2:	2f 5f       	subi	r18, 0xFF	; 255
     da4:	3f 4f       	sbci	r19, 0xFF	; 255
                search_len = 1;
                if (src_ptr >= src_end_ptr)
     da6:	a0 17       	cp	r26, r16
     da8:	b1 07       	cpc	r27, r17
     daa:	e8 f4       	brcc	.+58     	; 0xde6 <cobs_encode+0xa0>
     dac:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     dae:	f9 01       	movw	r30, r18
                search_len = 1;
     db0:	98 2f       	mov	r25, r24
     db2:	ef cf       	rjmp	.-34     	; 0xd92 <cobs_encode+0x4c>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     db4:	af 01       	movw	r20, r30
     db6:	4f 5f       	subi	r20, 0xFF	; 255
     db8:	5f 4f       	sbci	r21, 0xFF	; 255
     dba:	30 83       	st	Z, r19
                search_len++;
     dbc:	9f 5f       	subi	r25, 0xFF	; 255
                if (src_ptr >= src_end_ptr)
     dbe:	a0 17       	cp	r26, r16
     dc0:	b1 07       	cpc	r27, r17
     dc2:	b0 f4       	brcc	.+44     	; 0xdf0 <cobs_encode+0xaa>
                {
                    break;
                }
                if (search_len == 0xFF)
     dc4:	9f 3f       	cpi	r25, 0xFF	; 255
     dc6:	21 f7       	brne	.-56     	; 0xd90 <cobs_encode+0x4a>
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     dc8:	d8 82       	st	Y, r13
                    dst_code_write_ptr = dst_write_ptr++;
     dca:	32 96       	adiw	r30, 0x02	; 2
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     dcc:	ea 01       	movw	r28, r20
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
                    dst_code_write_ptr = dst_write_ptr++;
                    search_len = 1;
     dce:	98 2f       	mov	r25, r24
     dd0:	e0 cf       	rjmp	.-64     	; 0xd92 <cobs_encode+0x4c>
cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
     dd2:	ec 01       	movw	r28, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     dd4:	80 e0       	ldi	r24, 0x00	; 0
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;
     dd6:	91 e0       	ldi	r25, 0x01	; 1
     dd8:	0d c0       	rjmp	.+26     	; 0xdf4 <cobs_encode+0xae>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     dda:	ec 01       	movw	r28, r24
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     ddc:	82 e0       	ldi	r24, 0x02	; 2
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     dde:	91 e0       	ldi	r25, 0x01	; 1
     de0:	09 c0       	rjmp	.+18     	; 0xdf4 <cobs_encode+0xae>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     de2:	82 e0       	ldi	r24, 0x02	; 2
     de4:	07 c0       	rjmp	.+14     	; 0xdf4 <cobs_encode+0xae>
     de6:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     de8:	f9 01       	movw	r30, r18
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     dea:	80 e0       	ldi	r24, 0x00	; 0
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
                search_len = 1;
     dec:	91 e0       	ldi	r25, 0x01	; 1
     dee:	02 c0       	rjmp	.+4      	; 0xdf4 <cobs_encode+0xae>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     df0:	fa 01       	movw	r30, r20
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     df2:	80 e0       	ldi	r24, 0x00	; 0

    /* We've reached the end of the source data (or possibly run out of output buffer)
     * Finalise the remaining output. In particular, write the code (length) byte.
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
     df4:	c6 17       	cp	r28, r22
     df6:	d7 07       	cpc	r29, r23
     df8:	18 f4       	brcc	.+6      	; 0xe00 <cobs_encode+0xba>
        dst_write_ptr = dst_buf_end_ptr;
    }
    else
    {
        /* Write the last code (length) byte. */
        *dst_code_write_ptr = search_len;
     dfa:	98 83       	st	Y, r25
     dfc:	bf 01       	movw	r22, r30
     dfe:	01 c0       	rjmp	.+2      	; 0xe02 <cobs_encode+0xbc>
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
    {
        /* We've run out of output buffer to write the code byte. */
        result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     e00:	82 e0       	ldi	r24, 0x02	; 2
        /* Write the last code (length) byte. */
        *dst_code_write_ptr = search_len;
    }

    /* Calculate the output length, from the value of dst_code_write_ptr */
    result.out_len = dst_write_ptr - dst_buf_ptr;
     e02:	9b 01       	movw	r18, r22
     e04:	2e 19       	sub	r18, r14
     e06:	3f 09       	sbc	r19, r15

    return result;
     e08:	62 2f       	mov	r22, r18
     e0a:	73 2f       	mov	r23, r19
}
     e0c:	df 91       	pop	r29
     e0e:	cf 91       	pop	r28
     e10:	1f 91       	pop	r17
     e12:	0f 91       	pop	r16
     e14:	ff 90       	pop	r15
     e16:	ef 90       	pop	r14
     e18:	df 90       	pop	r13
     e1a:	08 95       	ret

00000e1c <cobs_decode>:


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     e1c:	af 92       	push	r10
     e1e:	bf 92       	push	r11
     e20:	cf 92       	push	r12
     e22:	df 92       	push	r13
     e24:	ef 92       	push	r14
     e26:	ff 92       	push	r15
     e28:	0f 93       	push	r16
     e2a:	1f 93       	push	r17
     e2c:	cf 93       	push	r28
     e2e:	df 93       	push	r29
     e30:	7c 01       	movw	r14, r24
     e32:	da 01       	movw	r26, r20
    uint8_t             i;
    uint8_t             len_code;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     e34:	00 97       	sbiw	r24, 0x00	; 0
     e36:	11 f0       	breq	.+4      	; 0xe3c <cobs_decode+0x20>
     e38:	10 97       	sbiw	r26, 0x00	; 0
     e3a:	21 f4       	brne	.+8      	; 0xe44 <cobs_decode+0x28>
    {
        result.status = COBS_DECODE_NULL_POINTER;
        return result;
     e3c:	60 e0       	ldi	r22, 0x00	; 0
     e3e:	70 e0       	ldi	r23, 0x00	; 0
     e40:	81 e0       	ldi	r24, 0x01	; 1
     e42:	5f c0       	rjmp	.+190    	; 0xf02 <cobs_decode+0xe6>
    }

    if (src_len != 0)
     e44:	21 15       	cp	r18, r1
     e46:	31 05       	cpc	r19, r1
     e48:	09 f4       	brne	.+2      	; 0xe4c <cobs_decode+0x30>
     e4a:	4b c0       	rjmp	.+150    	; 0xee2 <cobs_decode+0xc6>


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     e4c:	6a 01       	movw	r12, r20
     e4e:	c2 0e       	add	r12, r18
     e50:	d3 1e       	adc	r13, r19
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     e52:	5c 01       	movw	r10, r24
     e54:	a6 0e       	add	r10, r22
     e56:	b7 1e       	adc	r11, r23
     e58:	8c 01       	movw	r16, r24
     e5a:	50 e0       	ldi	r21, 0x00	; 0
     e5c:	01 c0       	rjmp	.+2      	; 0xe60 <cobs_decode+0x44>
                src_byte = *src_ptr++;
                if (src_byte == 0)
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
     e5e:	8f 01       	movw	r16, r30

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     e60:	ed 01       	movw	r28, r26
     e62:	21 96       	adiw	r28, 0x01	; 1
     e64:	7c 91       	ld	r23, X
            if (len_code == 0)
     e66:	71 11       	cpse	r23, r1
     e68:	03 c0       	rjmp	.+6      	; 0xe70 <cobs_decode+0x54>
            {
                result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e6a:	54 60       	ori	r21, 0x04	; 4
                break;
     e6c:	f8 01       	movw	r30, r16
     e6e:	3d c0       	rjmp	.+122    	; 0xeea <cobs_decode+0xce>
            }
            len_code--;
     e70:	71 50       	subi	r23, 0x01	; 1

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
     e72:	c6 01       	movw	r24, r12
     e74:	8c 1b       	sub	r24, r28
     e76:	9d 0b       	sbc	r25, r29
            if (len_code > remaining_bytes)
     e78:	27 2f       	mov	r18, r23
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	82 17       	cp	r24, r18
     e7e:	93 07       	cpc	r25, r19
     e80:	10 f4       	brcc	.+4      	; 0xe86 <cobs_decode+0x6a>
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
                len_code = remaining_bytes;
     e82:	78 2f       	mov	r23, r24

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
     e84:	58 60       	ori	r21, 0x08	; 8
                len_code = remaining_bytes;
            }

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
     e86:	c5 01       	movw	r24, r10
     e88:	80 1b       	sub	r24, r16
     e8a:	91 0b       	sbc	r25, r17
            if (len_code > remaining_bytes)
     e8c:	27 2f       	mov	r18, r23
     e8e:	30 e0       	ldi	r19, 0x00	; 0
     e90:	82 17       	cp	r24, r18
     e92:	93 07       	cpc	r25, r19
     e94:	10 f4       	brcc	.+4      	; 0xe9a <cobs_decode+0x7e>
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
     e96:	78 2f       	mov	r23, r24

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     e98:	52 60       	ori	r21, 0x02	; 2
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e9a:	77 23       	and	r23, r23
     e9c:	61 f1       	breq	.+88     	; 0xef6 <cobs_decode+0xda>
     e9e:	de 01       	movw	r26, r28
     ea0:	f8 01       	movw	r30, r16
     ea2:	97 2f       	mov	r25, r23
            {
                src_byte = *src_ptr++;
     ea4:	3d 91       	ld	r19, X+
                if (src_byte == 0)
     ea6:	31 11       	cpse	r19, r1
     ea8:	01 c0       	rjmp	.+2      	; 0xeac <cobs_decode+0x90>
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     eaa:	54 60       	ori	r21, 0x04	; 4
                }
                *dst_write_ptr++ = src_byte;
     eac:	31 93       	st	Z+, r19
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     eae:	91 50       	subi	r25, 0x01	; 1
     eb0:	c9 f7       	brne	.-14     	; 0xea4 <cobs_decode+0x88>
     eb2:	ef ef       	ldi	r30, 0xFF	; 255
     eb4:	e7 0f       	add	r30, r23
     eb6:	f0 e0       	ldi	r31, 0x00	; 0
     eb8:	31 96       	adiw	r30, 0x01	; 1
     eba:	de 01       	movw	r26, r28
     ebc:	ae 0f       	add	r26, r30
     ebe:	bf 1f       	adc	r27, r31
     ec0:	e0 0f       	add	r30, r16
     ec2:	f1 1f       	adc	r31, r17
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ec4:	ac 15       	cp	r26, r12
     ec6:	bd 05       	cpc	r27, r13
     ec8:	80 f4       	brcc	.+32     	; 0xeea <cobs_decode+0xce>
            {
                break;
            }

            /* Add a zero to the end */
            if (len_code != 0xFE)
     eca:	7e 3f       	cpi	r23, 0xFE	; 254
     ecc:	41 f2       	breq	.-112    	; 0xe5e <cobs_decode+0x42>
            {
                if (dst_write_ptr >= dst_buf_end_ptr)
     ece:	ea 15       	cp	r30, r10
     ed0:	fb 05       	cpc	r31, r11
     ed2:	10 f0       	brcs	.+4      	; 0xed8 <cobs_decode+0xbc>
                {
                    result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     ed4:	52 60       	ori	r21, 0x02	; 2
                    break;
     ed6:	09 c0       	rjmp	.+18     	; 0xeea <cobs_decode+0xce>
                }
                *dst_write_ptr++ = 0;
     ed8:	8f 01       	movw	r16, r30
     eda:	0f 5f       	subi	r16, 0xFF	; 255
     edc:	1f 4f       	sbci	r17, 0xFF	; 255
     ede:	10 82       	st	Z, r1
     ee0:	bf cf       	rjmp	.-130    	; 0xe60 <cobs_decode+0x44>
cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_write_ptr       = dst_buf_ptr;
     ee2:	fc 01       	movw	r30, r24
}


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
     ee4:	50 e0       	ldi	r21, 0x00	; 0
     ee6:	01 c0       	rjmp	.+2      	; 0xeea <cobs_decode+0xce>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ee8:	f8 01       	movw	r30, r16
                *dst_write_ptr++ = 0;
            }
        }
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;
     eea:	ee 19       	sub	r30, r14
     eec:	ff 09       	sbc	r31, r15

    return result;
     eee:	6e 2f       	mov	r22, r30
     ef0:	7f 2f       	mov	r23, r31
     ef2:	85 2f       	mov	r24, r21
     ef4:	06 c0       	rjmp	.+12     	; 0xf02 <cobs_decode+0xe6>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ef6:	cc 15       	cp	r28, r12
     ef8:	dd 05       	cpc	r29, r13
     efa:	b0 f7       	brcc	.-20     	; 0xee8 <cobs_decode+0xcc>
     efc:	f8 01       	movw	r30, r16

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     efe:	de 01       	movw	r26, r28
     f00:	e6 cf       	rjmp	.-52     	; 0xece <cobs_decode+0xb2>
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
}
     f02:	df 91       	pop	r29
     f04:	cf 91       	pop	r28
     f06:	1f 91       	pop	r17
     f08:	0f 91       	pop	r16
     f0a:	ff 90       	pop	r15
     f0c:	ef 90       	pop	r14
     f0e:	df 90       	pop	r13
     f10:	cf 90       	pop	r12
     f12:	bf 90       	pop	r11
     f14:	af 90       	pop	r10
     f16:	08 95       	ret

00000f18 <vCOM_init>:
#define HMC5883L_WRITE 0x3C
#define HMC5883L_READ 0x3D


void vCOM_init(void){
    vTWI_init();
     f18:	0e 94 aa 2e 	call	0x5d54	; 0x5d54 <vTWI_init>
    ui8TWI_start(HMC5883L_WRITE);
     f1c:	8c e3       	ldi	r24, 0x3C	; 60
     f1e:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <ui8TWI_start>
    ui8TWI_write(0x00); // set pointer to CRA
     f22:	80 e0       	ldi	r24, 0x00	; 0
     f24:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <ui8TWI_write>
    ui8TWI_write(0x70); // write 0x70 to CRA
     f28:	80 e7       	ldi	r24, 0x70	; 112
     f2a:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <ui8TWI_write>
    vTWI_stop();
     f2e:	0e 94 fb 2e 	call	0x5df6	; 0x5df6 <vTWI_stop>

    ui8TWI_start(HMC5883L_WRITE);
     f32:	8c e3       	ldi	r24, 0x3C	; 60
     f34:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <ui8TWI_start>
    ui8TWI_write(0x01); // set pointer to CRB
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <ui8TWI_write>
    ui8TWI_write(0xA0); // Set bit 7 and 5 (GN2, GN0)
     f3e:	80 ea       	ldi	r24, 0xA0	; 160
     f40:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <ui8TWI_write>
    vTWI_stop();
     f44:	0e 94 fb 2e 	call	0x5df6	; 0x5df6 <vTWI_stop>

    ui8TWI_start(HMC5883L_WRITE);
     f48:	8c e3       	ldi	r24, 0x3C	; 60
     f4a:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <ui8TWI_start>
    ui8TWI_write(0x02); // set pointer to measurement mode
     f4e:	82 e0       	ldi	r24, 0x02	; 2
     f50:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <ui8TWI_write>
    ui8TWI_write(0x00); // continous measurement
     f54:	80 e0       	ldi	r24, 0x00	; 0
     f56:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <ui8TWI_write>
    vTWI_stop();
     f5a:	0c 94 fb 2e 	jmp	0x5df6	; 0x5df6 <vTWI_stop>
     f5e:	08 95       	ret

00000f60 <vCOM_getData>:
}

void vCOM_getData(int16_t *xCom, int16_t *yCom, int16_t *zCom){
     f60:	ef 92       	push	r14
     f62:	ff 92       	push	r15
     f64:	0f 93       	push	r16
     f66:	1f 93       	push	r17
     f68:	cf 93       	push	r28
     f6a:	df 93       	push	r29
     f6c:	7c 01       	movw	r14, r24
     f6e:	eb 01       	movw	r28, r22
     f70:	8a 01       	movw	r16, r20
    ui8TWI_start(HMC5883L_WRITE);
     f72:	8c e3       	ldi	r24, 0x3C	; 60
     f74:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <ui8TWI_start>
    ui8TWI_write(0x03); // set pointer to X axis MSB
     f78:	83 e0       	ldi	r24, 0x03	; 3
     f7a:	0e 94 d3 2e 	call	0x5da6	; 0x5da6 <ui8TWI_write>
    vTWI_stop();
     f7e:	0e 94 fb 2e 	call	0x5df6	; 0x5df6 <vTWI_stop>
    ui8TWI_start(HMC5883L_READ);
     f82:	8d e3       	ldi	r24, 0x3D	; 61
     f84:	0e 94 ae 2e 	call	0x5d5c	; 0x5d5c <ui8TWI_start>
    *xCom = ((uint8_t)ui8TWI_read_ack())<<8;
     f88:	0e 94 e5 2e 	call	0x5dca	; 0x5dca <ui8TWI_read_ack>
     f8c:	f7 01       	movw	r30, r14
     f8e:	10 82       	st	Z, r1
     f90:	81 83       	std	Z+1, r24	; 0x01
    *xCom |= ui8TWI_read_ack();
     f92:	0e 94 e5 2e 	call	0x5dca	; 0x5dca <ui8TWI_read_ack>
     f96:	f7 01       	movw	r30, r14
     f98:	20 81       	ld	r18, Z
     f9a:	31 81       	ldd	r19, Z+1	; 0x01
     f9c:	28 2b       	or	r18, r24
     f9e:	31 83       	std	Z+1, r19	; 0x01
     fa0:	20 83       	st	Z, r18
    *zCom = ((uint8_t)ui8TWI_read_ack())<<8;
     fa2:	0e 94 e5 2e 	call	0x5dca	; 0x5dca <ui8TWI_read_ack>
     fa6:	f8 01       	movw	r30, r16
     fa8:	10 82       	st	Z, r1
     faa:	81 83       	std	Z+1, r24	; 0x01
    *zCom |= ui8TWI_read_ack();
     fac:	0e 94 e5 2e 	call	0x5dca	; 0x5dca <ui8TWI_read_ack>
     fb0:	f8 01       	movw	r30, r16
     fb2:	20 81       	ld	r18, Z
     fb4:	31 81       	ldd	r19, Z+1	; 0x01
     fb6:	28 2b       	or	r18, r24
     fb8:	31 83       	std	Z+1, r19	; 0x01
     fba:	20 83       	st	Z, r18
    *yCom = ((uint8_t)ui8TWI_read_ack())<<8;
     fbc:	0e 94 e5 2e 	call	0x5dca	; 0x5dca <ui8TWI_read_ack>
     fc0:	18 82       	st	Y, r1
     fc2:	89 83       	std	Y+1, r24	; 0x01
    *yCom |= ui8TWI_read_nack();
     fc4:	0e 94 f0 2e 	call	0x5de0	; 0x5de0 <ui8TWI_read_nack>
     fc8:	28 81       	ld	r18, Y
     fca:	39 81       	ldd	r19, Y+1	; 0x01
     fcc:	28 2b       	or	r18, r24
     fce:	39 83       	std	Y+1, r19	; 0x01
     fd0:	28 83       	st	Y, r18
    vTWI_stop();
     fd2:	0e 94 fb 2e 	call	0x5df6	; 0x5df6 <vTWI_stop>
}
     fd6:	df 91       	pop	r29
     fd8:	cf 91       	pop	r28
     fda:	1f 91       	pop	r17
     fdc:	0f 91       	pop	r16
     fde:	ff 90       	pop	r15
     fe0:	ef 90       	pop	r14
     fe2:	08 95       	ret

00000fe4 <crc_ibutton_update>:
  return crc;
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
     fe4:	86 27       	eor	r24, r22
     fe6:	98 e0       	ldi	r25, 0x08	; 8
  for (i = 0; i < 8; i++) {
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
     fe8:	2c e8       	ldi	r18, 0x8C	; 140
     fea:	80 ff       	sbrs	r24, 0
     fec:	03 c0       	rjmp	.+6      	; 0xff4 <crc_ibutton_update+0x10>
     fee:	86 95       	lsr	r24
     ff0:	82 27       	eor	r24, r18
     ff2:	01 c0       	rjmp	.+2      	; 0xff6 <crc_ibutton_update+0x12>
    else crc >>= 1;
     ff4:	86 95       	lsr	r24
     ff6:	91 50       	subi	r25, 0x01	; 1
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
  for (i = 0; i < 8; i++) {
     ff8:	c1 f7       	brne	.-16     	; 0xfea <crc_ibutton_update+0x6>
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
    else crc >>= 1;
  }
  return crc;
     ffa:	08 95       	ret

00000ffc <calculate_crc>:

#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
     ffc:	0f 93       	push	r16
     ffe:	1f 93       	push	r17
    1000:	cf 93       	push	r28
    1002:	df 93       	push	r29
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
    1004:	66 23       	and	r22, r22
    1006:	59 f0       	breq	.+22     	; 0x101e <calculate_crc+0x22>
    1008:	8c 01       	movw	r16, r24
    100a:	ec 01       	movw	r28, r24
    100c:	06 0f       	add	r16, r22
    100e:	11 1d       	adc	r17, r1
    1010:	80 e0       	ldi	r24, 0x00	; 0
    crc = crc_ibutton_update(crc, data[i]);
    1012:	69 91       	ld	r22, Y+
    1014:	e7 df       	rcall	.-50     	; 0xfe4 <crc_ibutton_update>
char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
    1016:	c0 17       	cp	r28, r16
    1018:	d1 07       	cpc	r29, r17
    101a:	d9 f7       	brne	.-10     	; 0x1012 <calculate_crc+0x16>
    101c:	01 c0       	rjmp	.+2      	; 0x1020 <calculate_crc+0x24>
#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
    101e:	80 e0       	ldi	r24, 0x00	; 0
  int i;
  for(i=0;i<len;i++) {
    crc = crc_ibutton_update(crc, data[i]);
  }
  return crc;
}
    1020:	df 91       	pop	r29
    1022:	cf 91       	pop	r28
    1024:	1f 91       	pop	r17
    1026:	0f 91       	pop	r16
    1028:	08 95       	ret

0000102a <vDistSens_init>:
};

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
    102a:	80 b3       	in	r24, 0x10	; 16
    102c:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
    102e:	ec e7       	ldi	r30, 0x7C	; 124
    1030:	f0 e0       	ldi	r31, 0x00	; 0
    1032:	80 81       	ld	r24, Z
    1034:	80 6c       	ori	r24, 0xC0	; 192
    1036:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
    1038:	ea e7       	ldi	r30, 0x7A	; 122
    103a:	f0 e0       	ldi	r31, 0x00	; 0
    103c:	80 81       	ld	r24, Z
    103e:	80 68       	ori	r24, 0x80	; 128
    1040:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
    1042:	80 81       	ld	r24, Z
    1044:	84 60       	ori	r24, 0x04	; 4
    1046:	80 83       	st	Z, r24
    1048:	08 95       	ret

0000104a <ui8DistSens_readCM>:
uint8_t ui8DistSens_readCM(uint8_t sensorDirection){
    
    uint8_t ui8_analogValue;
    
    /* Choose channel */
    ADMUX = sensorDirection;
    104a:	ec e7       	ldi	r30, 0x7C	; 124
    104c:	f0 e0       	ldi	r31, 0x00	; 0
    104e:	80 83       	st	Z, r24
    
    /* Enable internal 2,54V AREF */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
    1050:	90 81       	ld	r25, Z
    1052:	90 6c       	ori	r25, 0xC0	; 192
    1054:	90 83       	st	Z, r25
    
    /* Start conversion */
    ADCSRA |= (1<<ADSC);
    1056:	ea e7       	ldi	r30, 0x7A	; 122
    1058:	f0 e0       	ldi	r31, 0x00	; 0
    105a:	90 81       	ld	r25, Z
    105c:	90 64       	ori	r25, 0x40	; 64
    105e:	90 83       	st	Z, r25
    loop_until_bit_is_clear(ADCSRA, ADSC); // Macro from <avr/io.h>, wait until bit bit in IO register is set.
    1060:	90 81       	ld	r25, Z
    1062:	96 fd       	sbrc	r25, 6
    1064:	fd cf       	rjmp	.-6      	; 0x1060 <ui8DistSens_readCM+0x16>

    /* Return the 8 most significant bits from the 10 bit register */
    ui8_analogValue = (ADCL >> 2) | (ADCH << 6);
    1066:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
    106a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    
    // Returns corresponding distance in CM
    return ui8_analogToCM[sensorDirection-1][ui8_analogValue];
    106e:	e8 2f       	mov	r30, r24
    1070:	f0 e0       	ldi	r31, 0x00	; 0
    1072:	31 97       	sbiw	r30, 0x01	; 1
    /* Start conversion */
    ADCSRA |= (1<<ADSC);
    loop_until_bit_is_clear(ADCSRA, ADSC); // Macro from <avr/io.h>, wait until bit bit in IO register is set.

    /* Return the 8 most significant bits from the 10 bit register */
    ui8_analogValue = (ADCL >> 2) | (ADCH << 6);
    1074:	30 e4       	ldi	r19, 0x40	; 64
    1076:	93 9f       	mul	r25, r19
    1078:	c0 01       	movw	r24, r0
    107a:	11 24       	eor	r1, r1
    107c:	92 2f       	mov	r25, r18
    107e:	96 95       	lsr	r25
    1080:	96 95       	lsr	r25
    1082:	89 2b       	or	r24, r25
    
    // Returns corresponding distance in CM
    return ui8_analogToCM[sensorDirection-1][ui8_analogValue];
    1084:	fe 2f       	mov	r31, r30
    1086:	ee 27       	eor	r30, r30
    1088:	e8 0f       	add	r30, r24
    108a:	f1 1d       	adc	r31, r1
    108c:	e0 50       	subi	r30, 0x00	; 0
    108e:	fe 4f       	sbci	r31, 0xFE	; 254
}
    1090:	80 81       	ld	r24, Z
    1092:	08 95       	ret

00001094 <vFunc_Inf2pi>:
#include <string.h>
#include <math.h>
#include <stdlib.h>

/* Take any angle and put it inside -pi,pi */
void vFunc_Inf2pi(float *angle_in_radians){
    1094:	cf 92       	push	r12
    1096:	df 92       	push	r13
    1098:	ef 92       	push	r14
    109a:	ff 92       	push	r15
    109c:	cf 93       	push	r28
    109e:	df 93       	push	r29
    10a0:	ec 01       	movw	r28, r24
    do{
        if (*angle_in_radians > M_PI) *angle_in_radians -= 2*M_PI;
    10a2:	c8 80       	ld	r12, Y
    10a4:	d9 80       	ldd	r13, Y+1	; 0x01
    10a6:	ea 80       	ldd	r14, Y+2	; 0x02
    10a8:	fb 80       	ldd	r15, Y+3	; 0x03
    10aa:	2b ed       	ldi	r18, 0xDB	; 219
    10ac:	3f e0       	ldi	r19, 0x0F	; 15
    10ae:	49 e4       	ldi	r20, 0x49	; 73
    10b0:	50 e4       	ldi	r21, 0x40	; 64
    10b2:	c7 01       	movw	r24, r14
    10b4:	b6 01       	movw	r22, r12
    10b6:	0e 94 cb 32 	call	0x6596	; 0x6596 <__gesf2>
    10ba:	18 16       	cp	r1, r24
    10bc:	6c f4       	brge	.+26     	; 0x10d8 <vFunc_Inf2pi+0x44>
    10be:	2b ed       	ldi	r18, 0xDB	; 219
    10c0:	3f e0       	ldi	r19, 0x0F	; 15
    10c2:	49 ec       	ldi	r20, 0xC9	; 201
    10c4:	50 e4       	ldi	r21, 0x40	; 64
    10c6:	c7 01       	movw	r24, r14
    10c8:	b6 01       	movw	r22, r12
    10ca:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    10ce:	68 83       	st	Y, r22
    10d0:	79 83       	std	Y+1, r23	; 0x01
    10d2:	8a 83       	std	Y+2, r24	; 0x02
    10d4:	9b 83       	std	Y+3, r25	; 0x03
    10d6:	16 c0       	rjmp	.+44     	; 0x1104 <vFunc_Inf2pi+0x70>
        else if (*angle_in_radians < -M_PI) *angle_in_radians += 2*M_PI;
    10d8:	2b ed       	ldi	r18, 0xDB	; 219
    10da:	3f e0       	ldi	r19, 0x0F	; 15
    10dc:	49 e4       	ldi	r20, 0x49	; 73
    10de:	50 ec       	ldi	r21, 0xC0	; 192
    10e0:	c7 01       	movw	r24, r14
    10e2:	b6 01       	movw	r22, r12
    10e4:	0e 94 1b 31 	call	0x6236	; 0x6236 <__cmpsf2>
    10e8:	88 23       	and	r24, r24
    10ea:	64 f4       	brge	.+24     	; 0x1104 <vFunc_Inf2pi+0x70>
    10ec:	2b ed       	ldi	r18, 0xDB	; 219
    10ee:	3f e0       	ldi	r19, 0x0F	; 15
    10f0:	49 ec       	ldi	r20, 0xC9	; 201
    10f2:	50 e4       	ldi	r21, 0x40	; 64
    10f4:	c7 01       	movw	r24, r14
    10f6:	b6 01       	movw	r22, r12
    10f8:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    10fc:	68 83       	st	Y, r22
    10fe:	79 83       	std	Y+1, r23	; 0x01
    1100:	8a 83       	std	Y+2, r24	; 0x02
    1102:	9b 83       	std	Y+3, r25	; 0x03
    } while (fabs(*angle_in_radians) > M_PI);
    1104:	88 81       	ld	r24, Y
    1106:	99 81       	ldd	r25, Y+1	; 0x01
    1108:	aa 81       	ldd	r26, Y+2	; 0x02
    110a:	bb 81       	ldd	r27, Y+3	; 0x03
    110c:	bc 01       	movw	r22, r24
    110e:	cd 01       	movw	r24, r26
    1110:	9f 77       	andi	r25, 0x7F	; 127
    1112:	2b ed       	ldi	r18, 0xDB	; 219
    1114:	3f e0       	ldi	r19, 0x0F	; 15
    1116:	49 e4       	ldi	r20, 0x49	; 73
    1118:	50 e4       	ldi	r21, 0x40	; 64
    111a:	0e 94 cb 32 	call	0x6596	; 0x6596 <__gesf2>
    111e:	18 16       	cp	r1, r24
    1120:	0c f4       	brge	.+2      	; 0x1124 <vFunc_Inf2pi+0x90>
    1122:	bf cf       	rjmp	.-130    	; 0x10a2 <vFunc_Inf2pi+0xe>
}
    1124:	df 91       	pop	r29
    1126:	cf 91       	pop	r28
    1128:	ff 90       	pop	r15
    112a:	ef 90       	pop	r14
    112c:	df 90       	pop	r13
    112e:	cf 90       	pop	r12
    1130:	08 95       	ret

00001132 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1132:	cf 92       	push	r12
    1134:	df 92       	push	r13
    1136:	ef 92       	push	r14
    1138:	ff 92       	push	r15
    113a:	0f 93       	push	r16
    113c:	1f 93       	push	r17
    113e:	cf 93       	push	r28
    1140:	df 93       	push	r29
    1142:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    1144:	0e 94 d9 27 	call	0x4fb2	; 0x4fb2 <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    1148:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <pxEnd>
    114c:	90 91 b0 07 	lds	r25, 0x07B0	; 0x8007b0 <pxEnd+0x1>
    1150:	89 2b       	or	r24, r25
    1152:	41 f5       	brne	.+80     	; 0x11a4 <pvPortMalloc+0x72>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    1154:	e1 eb       	ldi	r30, 0xB1	; 177
    1156:	f7 e0       	ldi	r31, 0x07	; 7
    1158:	a5 eb       	ldi	r26, 0xB5	; 181
    115a:	b7 e0       	ldi	r27, 0x07	; 7
    115c:	b1 83       	std	Z+1, r27	; 0x01
    115e:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    1160:	13 82       	std	Z+3, r1	; 0x03
    1162:	12 82       	std	Z+2, r1	; 0x02

	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
    1164:	e1 eb       	ldi	r30, 0xB1	; 177
    1166:	f9 e1       	ldi	r31, 0x19	; 25
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    1168:	f0 93 b0 07 	sts	0x07B0, r31	; 0x8007b0 <pxEnd+0x1>
    116c:	e0 93 af 07 	sts	0x07AF, r30	; 0x8007af <pxEnd>
	pxEnd->xBlockSize = 0;
    1170:	13 82       	std	Z+3, r1	; 0x03
    1172:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    1174:	11 82       	std	Z+1, r1	; 0x01
    1176:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    1178:	8c ef       	ldi	r24, 0xFC	; 252
    117a:	91 e1       	ldi	r25, 0x11	; 17
    117c:	13 96       	adiw	r26, 0x03	; 3
    117e:	9c 93       	st	X, r25
    1180:	8e 93       	st	-X, r24
    1182:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    1184:	ed 93       	st	X+, r30
    1186:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1188:	90 93 ac 07 	sts	0x07AC, r25	; 0x8007ac <xMinimumEverFreeBytesRemaining+0x1>
    118c:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1190:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <xFreeBytesRemaining+0x1>
    1194:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    1198:	80 e0       	ldi	r24, 0x00	; 0
    119a:	90 e8       	ldi	r25, 0x80	; 128
    119c:	90 93 aa 07 	sts	0x07AA, r25	; 0x8007aa <xBlockAllocatedBit+0x1>
    11a0:	80 93 a9 07 	sts	0x07A9, r24	; 0x8007a9 <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    11a4:	20 91 a9 07 	lds	r18, 0x07A9	; 0x8007a9 <xBlockAllocatedBit>
    11a8:	30 91 aa 07 	lds	r19, 0x07AA	; 0x8007aa <xBlockAllocatedBit+0x1>
    11ac:	2c 23       	and	r18, r28
    11ae:	3d 23       	and	r19, r29
    11b0:	23 2b       	or	r18, r19
    11b2:	09 f0       	breq	.+2      	; 0x11b6 <pvPortMalloc+0x84>
    11b4:	b2 c0       	rjmp	.+356    	; 0x131a <pvPortMalloc+0x1e8>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    11b6:	20 97       	sbiw	r28, 0x00	; 0
    11b8:	09 f4       	brne	.+2      	; 0x11bc <pvPortMalloc+0x8a>
    11ba:	b2 c0       	rjmp	.+356    	; 0x1320 <pvPortMalloc+0x1ee>
			{
				xWantedSize += xHeapStructSize;
    11bc:	ae 01       	movw	r20, r28
    11be:	4c 5f       	subi	r20, 0xFC	; 252
    11c0:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    11c2:	09 f4       	brne	.+2      	; 0x11c6 <pvPortMalloc+0x94>
    11c4:	b0 c0       	rjmp	.+352    	; 0x1326 <pvPortMalloc+0x1f4>
    11c6:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <xFreeBytesRemaining>
    11ca:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <xFreeBytesRemaining+0x1>
    11ce:	84 17       	cp	r24, r20
    11d0:	95 07       	cpc	r25, r21
    11d2:	08 f4       	brcc	.+2      	; 0x11d6 <pvPortMalloc+0xa4>
    11d4:	ab c0       	rjmp	.+342    	; 0x132c <pvPortMalloc+0x1fa>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    11d6:	e0 91 b1 07 	lds	r30, 0x07B1	; 0x8007b1 <xStart>
    11da:	f0 91 b2 07 	lds	r31, 0x07B2	; 0x8007b2 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    11de:	a1 eb       	ldi	r26, 0xB1	; 177
    11e0:	b7 e0       	ldi	r27, 0x07	; 7
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    11e2:	02 c0       	rjmp	.+4      	; 0x11e8 <pvPortMalloc+0xb6>
    11e4:	df 01       	movw	r26, r30
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    11e6:	f9 01       	movw	r30, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    11e8:	22 81       	ldd	r18, Z+2	; 0x02
    11ea:	33 81       	ldd	r19, Z+3	; 0x03
    11ec:	24 17       	cp	r18, r20
    11ee:	35 07       	cpc	r19, r21
    11f0:	28 f4       	brcc	.+10     	; 0x11fc <pvPortMalloc+0xca>
    11f2:	20 81       	ld	r18, Z
    11f4:	31 81       	ldd	r19, Z+1	; 0x01
    11f6:	21 15       	cp	r18, r1
    11f8:	31 05       	cpc	r19, r1
    11fa:	a1 f7       	brne	.-24     	; 0x11e4 <pvPortMalloc+0xb2>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    11fc:	60 91 af 07 	lds	r22, 0x07AF	; 0x8007af <pxEnd>
    1200:	70 91 b0 07 	lds	r23, 0x07B0	; 0x8007b0 <pxEnd+0x1>
    1204:	e6 17       	cp	r30, r22
    1206:	f7 07       	cpc	r31, r23
    1208:	09 f4       	brne	.+2      	; 0x120c <pvPortMalloc+0xda>
    120a:	93 c0       	rjmp	.+294    	; 0x1332 <pvPortMalloc+0x200>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    120c:	cd 91       	ld	r28, X+
    120e:	dc 91       	ld	r29, X
    1210:	11 97       	sbiw	r26, 0x01	; 1
    1212:	6e 01       	movw	r12, r28
    1214:	84 e0       	ldi	r24, 0x04	; 4
    1216:	c8 0e       	add	r12, r24
    1218:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    121a:	80 81       	ld	r24, Z
    121c:	91 81       	ldd	r25, Z+1	; 0x01
    121e:	8d 93       	st	X+, r24
    1220:	9c 93       	st	X, r25

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1222:	22 81       	ldd	r18, Z+2	; 0x02
    1224:	33 81       	ldd	r19, Z+3	; 0x03
    1226:	24 1b       	sub	r18, r20
    1228:	35 0b       	sbc	r19, r21
    122a:	29 30       	cpi	r18, 0x09	; 9
    122c:	31 05       	cpc	r19, r1
    122e:	08 f4       	brcc	.+2      	; 0x1232 <pvPortMalloc+0x100>
    1230:	52 c0       	rjmp	.+164    	; 0x12d6 <pvPortMalloc+0x1a4>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    1232:	cf 01       	movw	r24, r30
    1234:	84 0f       	add	r24, r20
    1236:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1238:	dc 01       	movw	r26, r24
    123a:	13 96       	adiw	r26, 0x03	; 3
    123c:	3c 93       	st	X, r19
    123e:	2e 93       	st	-X, r18
    1240:	12 97       	sbiw	r26, 0x02	; 2
						pxBlock->xBlockSize = xWantedSize;
    1242:	53 83       	std	Z+3, r21	; 0x03
    1244:	42 83       	std	Z+2, r20	; 0x02
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    1246:	a1 eb       	ldi	r26, 0xB1	; 177
    1248:	b7 e0       	ldi	r27, 0x07	; 7
    124a:	01 c0       	rjmp	.+2      	; 0x124e <pvPortMalloc+0x11c>
    124c:	d9 01       	movw	r26, r18
    124e:	2d 91       	ld	r18, X+
    1250:	3c 91       	ld	r19, X
    1252:	11 97       	sbiw	r26, 0x01	; 1
    1254:	28 17       	cp	r18, r24
    1256:	39 07       	cpc	r19, r25
    1258:	c8 f3       	brcs	.-14     	; 0x124c <pvPortMalloc+0x11a>
    125a:	ad 01       	movw	r20, r26
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    125c:	12 96       	adiw	r26, 0x02	; 2
    125e:	0d 91       	ld	r16, X+
    1260:	1c 91       	ld	r17, X
    1262:	13 97       	sbiw	r26, 0x03	; 3
    1264:	7d 01       	movw	r14, r26
    1266:	e0 0e       	add	r14, r16
    1268:	f1 1e       	adc	r15, r17
    126a:	8e 15       	cp	r24, r14
    126c:	9f 05       	cpc	r25, r15
    126e:	51 f4       	brne	.+20     	; 0x1284 <pvPortMalloc+0x152>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    1270:	ec 01       	movw	r28, r24
    1272:	8a 81       	ldd	r24, Y+2	; 0x02
    1274:	9b 81       	ldd	r25, Y+3	; 0x03
    1276:	08 0f       	add	r16, r24
    1278:	19 1f       	adc	r17, r25
    127a:	13 96       	adiw	r26, 0x03	; 3
    127c:	1c 93       	st	X, r17
    127e:	0e 93       	st	-X, r16
    1280:	12 97       	sbiw	r26, 0x02	; 2
    1282:	cd 01       	movw	r24, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    1284:	ec 01       	movw	r28, r24
    1286:	aa 81       	ldd	r26, Y+2	; 0x02
    1288:	bb 81       	ldd	r27, Y+3	; 0x03
    128a:	8c 01       	movw	r16, r24
    128c:	0a 0f       	add	r16, r26
    128e:	1b 1f       	adc	r17, r27
    1290:	02 17       	cp	r16, r18
    1292:	13 07       	cpc	r17, r19
    1294:	c1 f4       	brne	.+48     	; 0x12c6 <pvPortMalloc+0x194>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    1296:	60 17       	cp	r22, r16
    1298:	71 07       	cpc	r23, r17
    129a:	89 f0       	breq	.+34     	; 0x12be <pvPortMalloc+0x18c>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    129c:	e8 01       	movw	r28, r16
    129e:	2a 81       	ldd	r18, Y+2	; 0x02
    12a0:	3b 81       	ldd	r19, Y+3	; 0x03
    12a2:	a2 0f       	add	r26, r18
    12a4:	b3 1f       	adc	r27, r19
    12a6:	ec 01       	movw	r28, r24
    12a8:	bb 83       	std	Y+3, r27	; 0x03
    12aa:	aa 83       	std	Y+2, r26	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    12ac:	ea 01       	movw	r28, r20
    12ae:	a8 81       	ld	r26, Y
    12b0:	b9 81       	ldd	r27, Y+1	; 0x01
    12b2:	2d 91       	ld	r18, X+
    12b4:	3c 91       	ld	r19, X
    12b6:	dc 01       	movw	r26, r24
    12b8:	2d 93       	st	X+, r18
    12ba:	3c 93       	st	X, r19
    12bc:	06 c0       	rjmp	.+12     	; 0x12ca <pvPortMalloc+0x198>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    12be:	ec 01       	movw	r28, r24
    12c0:	79 83       	std	Y+1, r23	; 0x01
    12c2:	68 83       	st	Y, r22
    12c4:	02 c0       	rjmp	.+4      	; 0x12ca <pvPortMalloc+0x198>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    12c6:	39 83       	std	Y+1, r19	; 0x01
    12c8:	28 83       	st	Y, r18

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    12ca:	48 17       	cp	r20, r24
    12cc:	59 07       	cpc	r21, r25
    12ce:	19 f0       	breq	.+6      	; 0x12d6 <pvPortMalloc+0x1a4>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    12d0:	ea 01       	movw	r28, r20
    12d2:	99 83       	std	Y+1, r25	; 0x01
    12d4:	88 83       	st	Y, r24
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    12d6:	22 81       	ldd	r18, Z+2	; 0x02
    12d8:	33 81       	ldd	r19, Z+3	; 0x03
    12da:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <xFreeBytesRemaining>
    12de:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <xFreeBytesRemaining+0x1>
    12e2:	82 1b       	sub	r24, r18
    12e4:	93 0b       	sbc	r25, r19
    12e6:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <xFreeBytesRemaining+0x1>
    12ea:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    12ee:	40 91 ab 07 	lds	r20, 0x07AB	; 0x8007ab <xMinimumEverFreeBytesRemaining>
    12f2:	50 91 ac 07 	lds	r21, 0x07AC	; 0x8007ac <xMinimumEverFreeBytesRemaining+0x1>
    12f6:	84 17       	cp	r24, r20
    12f8:	95 07       	cpc	r25, r21
    12fa:	20 f4       	brcc	.+8      	; 0x1304 <pvPortMalloc+0x1d2>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    12fc:	90 93 ac 07 	sts	0x07AC, r25	; 0x8007ac <xMinimumEverFreeBytesRemaining+0x1>
    1300:	80 93 ab 07 	sts	0x07AB, r24	; 0x8007ab <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    1304:	80 91 a9 07 	lds	r24, 0x07A9	; 0x8007a9 <xBlockAllocatedBit>
    1308:	90 91 aa 07 	lds	r25, 0x07AA	; 0x8007aa <xBlockAllocatedBit+0x1>
    130c:	28 2b       	or	r18, r24
    130e:	39 2b       	or	r19, r25
    1310:	33 83       	std	Z+3, r19	; 0x03
    1312:	22 83       	std	Z+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    1314:	11 82       	std	Z+1, r1	; 0x01
    1316:	10 82       	st	Z, r1
    1318:	0e c0       	rjmp	.+28     	; 0x1336 <pvPortMalloc+0x204>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    131a:	c1 2c       	mov	r12, r1
    131c:	d1 2c       	mov	r13, r1
    131e:	0b c0       	rjmp	.+22     	; 0x1336 <pvPortMalloc+0x204>
    1320:	c1 2c       	mov	r12, r1
    1322:	d1 2c       	mov	r13, r1
    1324:	08 c0       	rjmp	.+16     	; 0x1336 <pvPortMalloc+0x204>
    1326:	c1 2c       	mov	r12, r1
    1328:	d1 2c       	mov	r13, r1
    132a:	05 c0       	rjmp	.+10     	; 0x1336 <pvPortMalloc+0x204>
    132c:	c1 2c       	mov	r12, r1
    132e:	d1 2c       	mov	r13, r1
    1330:	02 c0       	rjmp	.+4      	; 0x1336 <pvPortMalloc+0x204>
    1332:	c1 2c       	mov	r12, r1
    1334:	d1 2c       	mov	r13, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1336:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    133a:	c6 01       	movw	r24, r12
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	1f 91       	pop	r17
    1342:	0f 91       	pop	r16
    1344:	ff 90       	pop	r15
    1346:	ef 90       	pop	r14
    1348:	df 90       	pop	r13
    134a:	cf 90       	pop	r12
    134c:	08 95       	ret

0000134e <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    134e:	cf 93       	push	r28
    1350:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    1352:	00 97       	sbiw	r24, 0x00	; 0
    1354:	09 f4       	brne	.+2      	; 0x1358 <vPortFree+0xa>
    1356:	68 c0       	rjmp	.+208    	; 0x1428 <vPortFree+0xda>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    1358:	fc 01       	movw	r30, r24
    135a:	34 97       	sbiw	r30, 0x04	; 4
    135c:	22 81       	ldd	r18, Z+2	; 0x02
    135e:	33 81       	ldd	r19, Z+3	; 0x03
    1360:	40 91 a9 07 	lds	r20, 0x07A9	; 0x8007a9 <xBlockAllocatedBit>
    1364:	50 91 aa 07 	lds	r21, 0x07AA	; 0x8007aa <xBlockAllocatedBit+0x1>
    1368:	ba 01       	movw	r22, r20
    136a:	62 23       	and	r22, r18
    136c:	73 23       	and	r23, r19
    136e:	67 2b       	or	r22, r23
    1370:	09 f4       	brne	.+2      	; 0x1374 <vPortFree+0x26>
    1372:	5a c0       	rjmp	.+180    	; 0x1428 <vPortFree+0xda>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    1374:	60 81       	ld	r22, Z
    1376:	71 81       	ldd	r23, Z+1	; 0x01
    1378:	67 2b       	or	r22, r23
    137a:	09 f0       	breq	.+2      	; 0x137e <vPortFree+0x30>
    137c:	55 c0       	rjmp	.+170    	; 0x1428 <vPortFree+0xda>

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    137e:	ef 01       	movw	r28, r30
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    1380:	40 95       	com	r20
    1382:	50 95       	com	r21
    1384:	24 23       	and	r18, r20
    1386:	35 23       	and	r19, r21
    1388:	33 83       	std	Z+3, r19	; 0x03
    138a:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    138c:	0e 94 d9 27 	call	0x4fb2	; 0x4fb2 <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    1390:	2a 81       	ldd	r18, Y+2	; 0x02
    1392:	3b 81       	ldd	r19, Y+3	; 0x03
    1394:	80 91 ad 07 	lds	r24, 0x07AD	; 0x8007ad <xFreeBytesRemaining>
    1398:	90 91 ae 07 	lds	r25, 0x07AE	; 0x8007ae <xFreeBytesRemaining+0x1>
    139c:	82 0f       	add	r24, r18
    139e:	93 1f       	adc	r25, r19
    13a0:	90 93 ae 07 	sts	0x07AE, r25	; 0x8007ae <xFreeBytesRemaining+0x1>
    13a4:	80 93 ad 07 	sts	0x07AD, r24	; 0x8007ad <xFreeBytesRemaining>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    13a8:	e1 eb       	ldi	r30, 0xB1	; 177
    13aa:	f7 e0       	ldi	r31, 0x07	; 7
    13ac:	01 c0       	rjmp	.+2      	; 0x13b0 <vPortFree+0x62>
    13ae:	fc 01       	movw	r30, r24
    13b0:	80 81       	ld	r24, Z
    13b2:	91 81       	ldd	r25, Z+1	; 0x01
    13b4:	8c 17       	cp	r24, r28
    13b6:	9d 07       	cpc	r25, r29
    13b8:	d0 f3       	brcs	.-12     	; 0x13ae <vPortFree+0x60>
    13ba:	df 01       	movw	r26, r30
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    13bc:	42 81       	ldd	r20, Z+2	; 0x02
    13be:	53 81       	ldd	r21, Z+3	; 0x03
    13c0:	bf 01       	movw	r22, r30
    13c2:	64 0f       	add	r22, r20
    13c4:	75 1f       	adc	r23, r21
    13c6:	c6 17       	cp	r28, r22
    13c8:	d7 07       	cpc	r29, r23
    13ca:	29 f4       	brne	.+10     	; 0x13d6 <vPortFree+0x88>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    13cc:	24 0f       	add	r18, r20
    13ce:	35 1f       	adc	r19, r21
    13d0:	33 83       	std	Z+3, r19	; 0x03
    13d2:	22 83       	std	Z+2, r18	; 0x02
    13d4:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    13d6:	2a 81       	ldd	r18, Y+2	; 0x02
    13d8:	3b 81       	ldd	r19, Y+3	; 0x03
    13da:	fe 01       	movw	r30, r28
    13dc:	e2 0f       	add	r30, r18
    13de:	f3 1f       	adc	r31, r19
    13e0:	e8 17       	cp	r30, r24
    13e2:	f9 07       	cpc	r31, r25
    13e4:	c1 f4       	brne	.+48     	; 0x1416 <vPortFree+0xc8>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    13e6:	80 91 af 07 	lds	r24, 0x07AF	; 0x8007af <pxEnd>
    13ea:	90 91 b0 07 	lds	r25, 0x07B0	; 0x8007b0 <pxEnd+0x1>
    13ee:	e8 17       	cp	r30, r24
    13f0:	f9 07       	cpc	r31, r25
    13f2:	71 f0       	breq	.+28     	; 0x1410 <vPortFree+0xc2>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    13f4:	82 81       	ldd	r24, Z+2	; 0x02
    13f6:	93 81       	ldd	r25, Z+3	; 0x03
    13f8:	28 0f       	add	r18, r24
    13fa:	39 1f       	adc	r19, r25
    13fc:	3b 83       	std	Y+3, r19	; 0x03
    13fe:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1400:	ed 91       	ld	r30, X+
    1402:	fc 91       	ld	r31, X
    1404:	11 97       	sbiw	r26, 0x01	; 1
    1406:	80 81       	ld	r24, Z
    1408:	91 81       	ldd	r25, Z+1	; 0x01
    140a:	99 83       	std	Y+1, r25	; 0x01
    140c:	88 83       	st	Y, r24
    140e:	05 c0       	rjmp	.+10     	; 0x141a <vPortFree+0xcc>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    1410:	f9 83       	std	Y+1, r31	; 0x01
    1412:	e8 83       	st	Y, r30
    1414:	02 c0       	rjmp	.+4      	; 0x141a <vPortFree+0xcc>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    1416:	99 83       	std	Y+1, r25	; 0x01
    1418:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    141a:	ac 17       	cp	r26, r28
    141c:	bd 07       	cpc	r27, r29
    141e:	11 f0       	breq	.+4      	; 0x1424 <vPortFree+0xd6>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    1420:	cd 93       	st	X+, r28
    1422:	dc 93       	st	X, r29
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
    1424:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1428:	df 91       	pop	r29
    142a:	cf 91       	pop	r28
    142c:	08 95       	ret

0000142e <sIMU_readRegisterRegion>:
}
float fIMU_readFloatGyroY( void ){
    
    float output = fIMU_calcGyro(i16IMU_readRawGyroY());
    return output;
}
    142e:	ef 92       	push	r14
    1430:	ff 92       	push	r15
    1432:	0f 93       	push	r16
    1434:	1f 93       	push	r17
    1436:	cf 93       	push	r28
    1438:	df 93       	push	r29
    143a:	ec 01       	movw	r28, r24
    143c:	e4 2e       	mov	r14, r20
    143e:	28 98       	cbi	0x05, 0	; 5
    1440:	86 2f       	mov	r24, r22
    1442:	80 68       	ori	r24, 0x80	; 128
    1444:	0e 94 b2 22 	call	0x4564	; 0x4564 <ui8SPI_MasterTransmit>
    1448:	ee 20       	and	r14, r14
    144a:	b1 f0       	breq	.+44     	; 0x1478 <sIMU_readRegisterRegion+0x4a>
    144c:	0f ef       	ldi	r16, 0xFF	; 255
    144e:	0e 0d       	add	r16, r14
    1450:	10 e0       	ldi	r17, 0x00	; 0
    1452:	0f 5f       	subi	r16, 0xFF	; 255
    1454:	1f 4f       	sbci	r17, 0xFF	; 255
    1456:	0c 0f       	add	r16, r28
    1458:	1d 1f       	adc	r17, r29
    145a:	f1 2c       	mov	r15, r1
    145c:	80 e0       	ldi	r24, 0x00	; 0
    145e:	0e 94 b2 22 	call	0x4564	; 0x4564 <ui8SPI_MasterTransmit>
    1462:	8f 3f       	cpi	r24, 0xFF	; 255
    1464:	09 f4       	brne	.+2      	; 0x1468 <sIMU_readRegisterRegion+0x3a>
    1466:	f3 94       	inc	r15
    1468:	89 93       	st	Y+, r24
    146a:	c0 17       	cp	r28, r16
    146c:	d1 07       	cpc	r29, r17
    146e:	b1 f7       	brne	.-20     	; 0x145c <sIMU_readRegisterRegion+0x2e>
    1470:	ef 10       	cpse	r14, r15
    1472:	04 c0       	rjmp	.+8      	; 0x147c <sIMU_readRegisterRegion+0x4e>
    1474:	85 e0       	ldi	r24, 0x05	; 5
    1476:	03 c0       	rjmp	.+6      	; 0x147e <sIMU_readRegisterRegion+0x50>
    1478:	85 e0       	ldi	r24, 0x05	; 5
    147a:	01 c0       	rjmp	.+2      	; 0x147e <sIMU_readRegisterRegion+0x50>
    147c:	80 e0       	ldi	r24, 0x00	; 0
    147e:	28 9a       	sbi	0x05, 0	; 5
    1480:	df 91       	pop	r29
    1482:	cf 91       	pop	r28
    1484:	1f 91       	pop	r17
    1486:	0f 91       	pop	r16
    1488:	ff 90       	pop	r15
    148a:	ef 90       	pop	r14
    148c:	08 95       	ret

0000148e <sIMU_readRegister>:
    148e:	cf 93       	push	r28
    1490:	df 93       	push	r29
    1492:	ec 01       	movw	r28, r24
    1494:	28 98       	cbi	0x05, 0	; 5
    1496:	86 2f       	mov	r24, r22
    1498:	80 68       	ori	r24, 0x80	; 128
    149a:	0e 94 b2 22 	call	0x4564	; 0x4564 <ui8SPI_MasterTransmit>
    149e:	80 e0       	ldi	r24, 0x00	; 0
    14a0:	0e 94 b2 22 	call	0x4564	; 0x4564 <ui8SPI_MasterTransmit>
    14a4:	98 2f       	mov	r25, r24
    14a6:	28 9a       	sbi	0x05, 0	; 5
    14a8:	8f 3f       	cpi	r24, 0xFF	; 255
    14aa:	11 f4       	brne	.+4      	; 0x14b0 <sIMU_readRegister+0x22>
    14ac:	85 e0       	ldi	r24, 0x05	; 5
    14ae:	01 c0       	rjmp	.+2      	; 0x14b2 <sIMU_readRegister+0x24>
    14b0:	80 e0       	ldi	r24, 0x00	; 0
    14b2:	98 83       	st	Y, r25
    14b4:	df 91       	pop	r29
    14b6:	cf 91       	pop	r28
    14b8:	08 95       	ret

000014ba <sIMU_Init>:
    14ba:	cf 93       	push	r28
    14bc:	df 93       	push	r29
    14be:	1f 92       	push	r1
    14c0:	1f 92       	push	r1
    14c2:	cd b7       	in	r28, 0x3d	; 61
    14c4:	de b7       	in	r29, 0x3e	; 62
    14c6:	ef e0       	ldi	r30, 0x0F	; 15
    14c8:	fb e1       	ldi	r31, 0x1B	; 27
    14ca:	81 e0       	ldi	r24, 0x01	; 1
    14cc:	80 83       	st	Z, r24
    14ce:	24 ef       	ldi	r18, 0xF4	; 244
    14d0:	31 e0       	ldi	r19, 0x01	; 1
    14d2:	32 83       	std	Z+2, r19	; 0x02
    14d4:	21 83       	std	Z+1, r18	; 0x01
    14d6:	22 e8       	ldi	r18, 0x82	; 130
    14d8:	36 e0       	ldi	r19, 0x06	; 6
    14da:	34 83       	std	Z+4, r19	; 0x04
    14dc:	23 83       	std	Z+3, r18	; 0x03
    14de:	20 e9       	ldi	r18, 0x90	; 144
    14e0:	31 e0       	ldi	r19, 0x01	; 1
    14e2:	36 83       	std	Z+6, r19	; 0x06
    14e4:	25 83       	std	Z+5, r18	; 0x05
    14e6:	17 82       	std	Z+7, r1	; 0x07
    14e8:	10 86       	std	Z+8, r1	; 0x08
    14ea:	81 87       	std	Z+9, r24	; 0x09
    14ec:	82 87       	std	Z+10, r24	; 0x0a
    14ee:	20 e1       	ldi	r18, 0x10	; 16
    14f0:	30 e0       	ldi	r19, 0x00	; 0
    14f2:	34 87       	std	Z+12, r19	; 0x0c
    14f4:	23 87       	std	Z+11, r18	; 0x0b
    14f6:	2d e0       	ldi	r18, 0x0D	; 13
    14f8:	30 e0       	ldi	r19, 0x00	; 0
    14fa:	36 87       	std	Z+14, r19	; 0x0e
    14fc:	25 87       	std	Z+13, r18	; 0x0d
    14fe:	22 e3       	ldi	r18, 0x32	; 50
    1500:	30 e0       	ldi	r19, 0x00	; 0
    1502:	30 8b       	std	Z+16, r19	; 0x10
    1504:	27 87       	std	Z+15, r18	; 0x0f
    1506:	11 8a       	std	Z+17, r1	; 0x11
    1508:	12 8a       	std	Z+18, r1	; 0x12
    150a:	83 8b       	std	Z+19, r24	; 0x13
    150c:	84 8b       	std	Z+20, r24	; 0x14
    150e:	88 eb       	ldi	r24, 0xB8	; 184
    1510:	9b e0       	ldi	r25, 0x0B	; 11
    1512:	96 8b       	std	Z+22, r25	; 0x16
    1514:	85 8b       	std	Z+21, r24	; 0x15
    1516:	8a e0       	ldi	r24, 0x0A	; 10
    1518:	90 e0       	ldi	r25, 0x00	; 0
    151a:	90 8f       	std	Z+24, r25	; 0x18
    151c:	87 8b       	std	Z+23, r24	; 0x17
    151e:	11 8e       	std	Z+25, r1	; 0x19
    1520:	10 92 2a 1b 	sts	0x1B2A, r1	; 0x801b2a <allOnesCounter+0x1>
    1524:	10 92 29 1b 	sts	0x1B29, r1	; 0x801b29 <allOnesCounter>
    1528:	10 92 2c 1b 	sts	0x1B2C, r1	; 0x801b2c <nonSuccessCounter+0x1>
    152c:	10 92 2b 1b 	sts	0x1B2B, r1	; 0x801b2b <nonSuccessCounter>
    1530:	0e 94 a4 22 	call	0x4548	; 0x4548 <vSPI_MasterInit>
    1534:	20 9a       	sbi	0x04, 0	; 4
    1536:	28 9a       	sbi	0x05, 0	; 5
    1538:	19 82       	std	Y+1, r1	; 0x01
    153a:	20 e1       	ldi	r18, 0x10	; 16
    153c:	37 e2       	ldi	r19, 0x27	; 39
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	8f 5f       	subi	r24, 0xFF	; 255
    1542:	89 83       	std	Y+1, r24	; 0x01
    1544:	21 50       	subi	r18, 0x01	; 1
    1546:	31 09       	sbc	r19, r1
    1548:	d1 f7       	brne	.-12     	; 0x153e <sIMU_Init+0x84>
    154a:	6f e0       	ldi	r22, 0x0F	; 15
    154c:	ce 01       	movw	r24, r28
    154e:	02 96       	adiw	r24, 0x02	; 2
    1550:	9e df       	rcall	.-196    	; 0x148e <sIMU_readRegister>
    1552:	8a 81       	ldd	r24, Y+2	; 0x02
    1554:	89 36       	cpi	r24, 0x69	; 105
    1556:	c9 f7       	brne	.-14     	; 0x154a <sIMU_Init+0x90>
    1558:	80 e0       	ldi	r24, 0x00	; 0
    155a:	0f 90       	pop	r0
    155c:	0f 90       	pop	r0
    155e:	df 91       	pop	r29
    1560:	cf 91       	pop	r28
    1562:	08 95       	ret

00001564 <sIMU_readRegisterInt16>:
    1564:	0f 93       	push	r16
    1566:	1f 93       	push	r17
    1568:	cf 93       	push	r28
    156a:	df 93       	push	r29
    156c:	1f 92       	push	r1
    156e:	1f 92       	push	r1
    1570:	cd b7       	in	r28, 0x3d	; 61
    1572:	de b7       	in	r29, 0x3e	; 62
    1574:	8c 01       	movw	r16, r24
    1576:	42 e0       	ldi	r20, 0x02	; 2
    1578:	ce 01       	movw	r24, r28
    157a:	01 96       	adiw	r24, 0x01	; 1
    157c:	58 df       	rcall	.-336    	; 0x142e <sIMU_readRegisterRegion>
    157e:	2a 81       	ldd	r18, Y+2	; 0x02
    1580:	30 e0       	ldi	r19, 0x00	; 0
    1582:	32 2f       	mov	r19, r18
    1584:	22 27       	eor	r18, r18
    1586:	99 81       	ldd	r25, Y+1	; 0x01
    1588:	29 2b       	or	r18, r25
    158a:	f8 01       	movw	r30, r16
    158c:	31 83       	std	Z+1, r19	; 0x01
    158e:	20 83       	st	Z, r18
    1590:	0f 90       	pop	r0
    1592:	0f 90       	pop	r0
    1594:	df 91       	pop	r29
    1596:	cf 91       	pop	r28
    1598:	1f 91       	pop	r17
    159a:	0f 91       	pop	r16
    159c:	08 95       	ret

0000159e <sIMU_writeRegister>:
    159e:	cf 93       	push	r28
    15a0:	c6 2f       	mov	r28, r22
    15a2:	28 98       	cbi	0x05, 0	; 5
    15a4:	0e 94 b2 22 	call	0x4564	; 0x4564 <ui8SPI_MasterTransmit>
    15a8:	8c 2f       	mov	r24, r28
    15aa:	0e 94 b2 22 	call	0x4564	; 0x4564 <ui8SPI_MasterTransmit>
    15ae:	28 9a       	sbi	0x05, 0	; 5
    15b0:	80 e0       	ldi	r24, 0x00	; 0
    15b2:	cf 91       	pop	r28
    15b4:	08 95       	ret

000015b6 <sIMU_begin>:
    15b6:	1f 93       	push	r17
    15b8:	cf 93       	push	r28
    15ba:	df 93       	push	r29
    15bc:	1f 92       	push	r1
    15be:	1f 92       	push	r1
    15c0:	cd b7       	in	r28, 0x3d	; 61
    15c2:	de b7       	in	r29, 0x3e	; 62
    15c4:	19 82       	std	Y+1, r1	; 0x01
    15c6:	79 df       	rcall	.-270    	; 0x14ba <sIMU_Init>
    15c8:	18 2f       	mov	r17, r24
    15ca:	19 82       	std	Y+1, r1	; 0x01
    15cc:	80 91 18 1b 	lds	r24, 0x1B18	; 0x801b18 <settings+0x9>
    15d0:	81 30       	cpi	r24, 0x01	; 1
    15d2:	09 f0       	breq	.+2      	; 0x15d6 <sIMU_begin+0x20>
    15d4:	83 c0       	rjmp	.+262    	; 0x16dc <sIMU_begin+0x126>
    15d6:	80 91 1e 1b 	lds	r24, 0x1B1E	; 0x801b1e <settings+0xf>
    15da:	90 91 1f 1b 	lds	r25, 0x1B1F	; 0x801b1f <settings+0x10>
    15de:	84 36       	cpi	r24, 0x64	; 100
    15e0:	91 05       	cpc	r25, r1
    15e2:	41 f0       	breq	.+16     	; 0x15f4 <sIMU_begin+0x3e>
    15e4:	88 3c       	cpi	r24, 0xC8	; 200
    15e6:	91 05       	cpc	r25, r1
    15e8:	41 f0       	breq	.+16     	; 0x15fa <sIMU_begin+0x44>
    15ea:	c2 97       	sbiw	r24, 0x32	; 50
    15ec:	41 f4       	brne	.+16     	; 0x15fe <sIMU_begin+0x48>
    15ee:	83 e0       	ldi	r24, 0x03	; 3
    15f0:	89 83       	std	Y+1, r24	; 0x01
    15f2:	05 c0       	rjmp	.+10     	; 0x15fe <sIMU_begin+0x48>
    15f4:	82 e0       	ldi	r24, 0x02	; 2
    15f6:	89 83       	std	Y+1, r24	; 0x01
    15f8:	02 c0       	rjmp	.+4      	; 0x15fe <sIMU_begin+0x48>
    15fa:	81 e0       	ldi	r24, 0x01	; 1
    15fc:	89 83       	std	Y+1, r24	; 0x01
    15fe:	80 91 1a 1b 	lds	r24, 0x1B1A	; 0x801b1a <settings+0xb>
    1602:	90 91 1b 1b 	lds	r25, 0x1B1B	; 0x801b1b <settings+0xc>
    1606:	84 30       	cpi	r24, 0x04	; 4
    1608:	91 05       	cpc	r25, r1
    160a:	31 f0       	breq	.+12     	; 0x1618 <sIMU_begin+0x62>
    160c:	88 30       	cpi	r24, 0x08	; 8
    160e:	91 05       	cpc	r25, r1
    1610:	39 f0       	breq	.+14     	; 0x1620 <sIMU_begin+0x6a>
    1612:	02 97       	sbiw	r24, 0x02	; 2
    1614:	49 f4       	brne	.+18     	; 0x1628 <sIMU_begin+0x72>
    1616:	0b c0       	rjmp	.+22     	; 0x162e <sIMU_begin+0x78>
    1618:	89 81       	ldd	r24, Y+1	; 0x01
    161a:	88 60       	ori	r24, 0x08	; 8
    161c:	89 83       	std	Y+1, r24	; 0x01
    161e:	07 c0       	rjmp	.+14     	; 0x162e <sIMU_begin+0x78>
    1620:	89 81       	ldd	r24, Y+1	; 0x01
    1622:	8c 60       	ori	r24, 0x0C	; 12
    1624:	89 83       	std	Y+1, r24	; 0x01
    1626:	03 c0       	rjmp	.+6      	; 0x162e <sIMU_begin+0x78>
    1628:	89 81       	ldd	r24, Y+1	; 0x01
    162a:	84 60       	ori	r24, 0x04	; 4
    162c:	89 83       	std	Y+1, r24	; 0x01
    162e:	80 91 1c 1b 	lds	r24, 0x1B1C	; 0x801b1c <settings+0xd>
    1632:	90 91 1d 1b 	lds	r25, 0x1B1D	; 0x801b1d <settings+0xe>
    1636:	80 3a       	cpi	r24, 0xA0	; 160
    1638:	21 e0       	ldi	r18, 0x01	; 1
    163a:	92 07       	cpc	r25, r18
    163c:	c1 f1       	breq	.+112    	; 0x16ae <sIMU_begin+0xf8>
    163e:	70 f4       	brcc	.+28     	; 0x165c <sIMU_begin+0xa6>
    1640:	8a 31       	cpi	r24, 0x1A	; 26
    1642:	91 05       	cpc	r25, r1
    1644:	21 f1       	breq	.+72     	; 0x168e <sIMU_begin+0xd8>
    1646:	18 f4       	brcc	.+6      	; 0x164e <sIMU_begin+0x98>
    1648:	0d 97       	sbiw	r24, 0x0d	; 13
    164a:	e9 f0       	breq	.+58     	; 0x1686 <sIMU_begin+0xd0>
    164c:	28 c0       	rjmp	.+80     	; 0x169e <sIMU_begin+0xe8>
    164e:	84 33       	cpi	r24, 0x34	; 52
    1650:	91 05       	cpc	r25, r1
    1652:	09 f1       	breq	.+66     	; 0x1696 <sIMU_begin+0xe0>
    1654:	80 3d       	cpi	r24, 0xD0	; 208
    1656:	91 05       	cpc	r25, r1
    1658:	31 f1       	breq	.+76     	; 0x16a6 <sIMU_begin+0xf0>
    165a:	21 c0       	rjmp	.+66     	; 0x169e <sIMU_begin+0xe8>
    165c:	82 30       	cpi	r24, 0x02	; 2
    165e:	2d e0       	ldi	r18, 0x0D	; 13
    1660:	92 07       	cpc	r25, r18
    1662:	89 f1       	breq	.+98     	; 0x16c6 <sIMU_begin+0x110>
    1664:	40 f4       	brcc	.+16     	; 0x1676 <sIMU_begin+0xc0>
    1666:	81 34       	cpi	r24, 0x41	; 65
    1668:	23 e0       	ldi	r18, 0x03	; 3
    166a:	92 07       	cpc	r25, r18
    166c:	21 f1       	breq	.+72     	; 0x16b6 <sIMU_begin+0x100>
    166e:	8c 37       	cpi	r24, 0x7C	; 124
    1670:	96 40       	sbci	r25, 0x06	; 6
    1672:	29 f1       	breq	.+74     	; 0x16be <sIMU_begin+0x108>
    1674:	14 c0       	rjmp	.+40     	; 0x169e <sIMU_begin+0xe8>
    1676:	84 30       	cpi	r24, 0x04	; 4
    1678:	2a e1       	ldi	r18, 0x1A	; 26
    167a:	92 07       	cpc	r25, r18
    167c:	41 f1       	breq	.+80     	; 0x16ce <sIMU_begin+0x118>
    167e:	82 31       	cpi	r24, 0x12	; 18
    1680:	94 43       	sbci	r25, 0x34	; 52
    1682:	49 f1       	breq	.+82     	; 0x16d6 <sIMU_begin+0x120>
    1684:	0c c0       	rjmp	.+24     	; 0x169e <sIMU_begin+0xe8>
    1686:	89 81       	ldd	r24, Y+1	; 0x01
    1688:	80 61       	ori	r24, 0x10	; 16
    168a:	89 83       	std	Y+1, r24	; 0x01
    168c:	27 c0       	rjmp	.+78     	; 0x16dc <sIMU_begin+0x126>
    168e:	89 81       	ldd	r24, Y+1	; 0x01
    1690:	80 62       	ori	r24, 0x20	; 32
    1692:	89 83       	std	Y+1, r24	; 0x01
    1694:	23 c0       	rjmp	.+70     	; 0x16dc <sIMU_begin+0x126>
    1696:	89 81       	ldd	r24, Y+1	; 0x01
    1698:	80 63       	ori	r24, 0x30	; 48
    169a:	89 83       	std	Y+1, r24	; 0x01
    169c:	1f c0       	rjmp	.+62     	; 0x16dc <sIMU_begin+0x126>
    169e:	89 81       	ldd	r24, Y+1	; 0x01
    16a0:	80 64       	ori	r24, 0x40	; 64
    16a2:	89 83       	std	Y+1, r24	; 0x01
    16a4:	1b c0       	rjmp	.+54     	; 0x16dc <sIMU_begin+0x126>
    16a6:	89 81       	ldd	r24, Y+1	; 0x01
    16a8:	80 65       	ori	r24, 0x50	; 80
    16aa:	89 83       	std	Y+1, r24	; 0x01
    16ac:	17 c0       	rjmp	.+46     	; 0x16dc <sIMU_begin+0x126>
    16ae:	89 81       	ldd	r24, Y+1	; 0x01
    16b0:	80 66       	ori	r24, 0x60	; 96
    16b2:	89 83       	std	Y+1, r24	; 0x01
    16b4:	13 c0       	rjmp	.+38     	; 0x16dc <sIMU_begin+0x126>
    16b6:	89 81       	ldd	r24, Y+1	; 0x01
    16b8:	80 67       	ori	r24, 0x70	; 112
    16ba:	89 83       	std	Y+1, r24	; 0x01
    16bc:	0f c0       	rjmp	.+30     	; 0x16dc <sIMU_begin+0x126>
    16be:	89 81       	ldd	r24, Y+1	; 0x01
    16c0:	80 68       	ori	r24, 0x80	; 128
    16c2:	89 83       	std	Y+1, r24	; 0x01
    16c4:	0b c0       	rjmp	.+22     	; 0x16dc <sIMU_begin+0x126>
    16c6:	89 81       	ldd	r24, Y+1	; 0x01
    16c8:	80 69       	ori	r24, 0x90	; 144
    16ca:	89 83       	std	Y+1, r24	; 0x01
    16cc:	07 c0       	rjmp	.+14     	; 0x16dc <sIMU_begin+0x126>
    16ce:	89 81       	ldd	r24, Y+1	; 0x01
    16d0:	80 6a       	ori	r24, 0xA0	; 160
    16d2:	89 83       	std	Y+1, r24	; 0x01
    16d4:	03 c0       	rjmp	.+6      	; 0x16dc <sIMU_begin+0x126>
    16d6:	89 81       	ldd	r24, Y+1	; 0x01
    16d8:	80 6b       	ori	r24, 0xB0	; 176
    16da:	89 83       	std	Y+1, r24	; 0x01
    16dc:	69 81       	ldd	r22, Y+1	; 0x01
    16de:	80 e1       	ldi	r24, 0x10	; 16
    16e0:	5e df       	rcall	.-324    	; 0x159e <sIMU_writeRegister>
    16e2:	63 e1       	ldi	r22, 0x13	; 19
    16e4:	ce 01       	movw	r24, r28
    16e6:	01 96       	adiw	r24, 0x01	; 1
    16e8:	d2 de       	rcall	.-604    	; 0x148e <sIMU_readRegister>
    16ea:	99 81       	ldd	r25, Y+1	; 0x01
    16ec:	9f 77       	andi	r25, 0x7F	; 127
    16ee:	99 83       	std	Y+1, r25	; 0x01
    16f0:	80 91 19 1b 	lds	r24, 0x1B19	; 0x801b19 <settings+0xa>
    16f4:	81 30       	cpi	r24, 0x01	; 1
    16f6:	11 f4       	brne	.+4      	; 0x16fc <sIMU_begin+0x146>
    16f8:	90 68       	ori	r25, 0x80	; 128
    16fa:	99 83       	std	Y+1, r25	; 0x01
    16fc:	69 81       	ldd	r22, Y+1	; 0x01
    16fe:	83 e1       	ldi	r24, 0x13	; 19
    1700:	4e df       	rcall	.-356    	; 0x159e <sIMU_writeRegister>
    1702:	19 82       	std	Y+1, r1	; 0x01
    1704:	80 91 0f 1b 	lds	r24, 0x1B0F	; 0x801b0f <settings>
    1708:	81 30       	cpi	r24, 0x01	; 1
    170a:	09 f0       	breq	.+2      	; 0x170e <sIMU_begin+0x158>
    170c:	5b c0       	rjmp	.+182    	; 0x17c4 <sIMU_begin+0x20e>
    170e:	80 91 10 1b 	lds	r24, 0x1B10	; 0x801b10 <settings+0x1>
    1712:	90 91 11 1b 	lds	r25, 0x1B11	; 0x801b11 <settings+0x2>
    1716:	85 3f       	cpi	r24, 0xF5	; 245
    1718:	91 05       	cpc	r25, r1
    171a:	c1 f0       	breq	.+48     	; 0x174c <sIMU_begin+0x196>
    171c:	20 f4       	brcc	.+8      	; 0x1726 <sIMU_begin+0x170>
    171e:	8d 37       	cpi	r24, 0x7D	; 125
    1720:	91 05       	cpc	r25, r1
    1722:	49 f0       	breq	.+18     	; 0x1736 <sIMU_begin+0x180>
    1724:	11 c0       	rjmp	.+34     	; 0x1748 <sIMU_begin+0x192>
    1726:	84 3f       	cpi	r24, 0xF4	; 244
    1728:	21 e0       	ldi	r18, 0x01	; 1
    172a:	92 07       	cpc	r25, r18
    172c:	39 f0       	breq	.+14     	; 0x173c <sIMU_begin+0x186>
    172e:	88 3e       	cpi	r24, 0xE8	; 232
    1730:	93 40       	sbci	r25, 0x03	; 3
    1732:	39 f0       	breq	.+14     	; 0x1742 <sIMU_begin+0x18c>
    1734:	09 c0       	rjmp	.+18     	; 0x1748 <sIMU_begin+0x192>
    1736:	82 e0       	ldi	r24, 0x02	; 2
    1738:	89 83       	std	Y+1, r24	; 0x01
    173a:	08 c0       	rjmp	.+16     	; 0x174c <sIMU_begin+0x196>
    173c:	84 e0       	ldi	r24, 0x04	; 4
    173e:	89 83       	std	Y+1, r24	; 0x01
    1740:	05 c0       	rjmp	.+10     	; 0x174c <sIMU_begin+0x196>
    1742:	88 e0       	ldi	r24, 0x08	; 8
    1744:	89 83       	std	Y+1, r24	; 0x01
    1746:	02 c0       	rjmp	.+4      	; 0x174c <sIMU_begin+0x196>
    1748:	8c e0       	ldi	r24, 0x0C	; 12
    174a:	89 83       	std	Y+1, r24	; 0x01
    174c:	80 91 12 1b 	lds	r24, 0x1B12	; 0x801b12 <settings+0x3>
    1750:	90 91 13 1b 	lds	r25, 0x1B13	; 0x801b13 <settings+0x4>
    1754:	80 3d       	cpi	r24, 0xD0	; 208
    1756:	91 05       	cpc	r25, r1
    1758:	31 f1       	breq	.+76     	; 0x17a6 <sIMU_begin+0x1f0>
    175a:	48 f4       	brcc	.+18     	; 0x176e <sIMU_begin+0x1b8>
    175c:	8a 31       	cpi	r24, 0x1A	; 26
    175e:	91 05       	cpc	r25, r1
    1760:	b1 f0       	breq	.+44     	; 0x178e <sIMU_begin+0x1d8>
    1762:	84 33       	cpi	r24, 0x34	; 52
    1764:	91 05       	cpc	r25, r1
    1766:	b9 f0       	breq	.+46     	; 0x1796 <sIMU_begin+0x1e0>
    1768:	0d 97       	sbiw	r24, 0x0d	; 13
    176a:	c9 f4       	brne	.+50     	; 0x179e <sIMU_begin+0x1e8>
    176c:	0c c0       	rjmp	.+24     	; 0x1786 <sIMU_begin+0x1d0>
    176e:	81 34       	cpi	r24, 0x41	; 65
    1770:	23 e0       	ldi	r18, 0x03	; 3
    1772:	92 07       	cpc	r25, r18
    1774:	01 f1       	breq	.+64     	; 0x17b6 <sIMU_begin+0x200>
    1776:	8c 37       	cpi	r24, 0x7C	; 124
    1778:	26 e0       	ldi	r18, 0x06	; 6
    177a:	92 07       	cpc	r25, r18
    177c:	01 f1       	breq	.+64     	; 0x17be <sIMU_begin+0x208>
    177e:	80 3a       	cpi	r24, 0xA0	; 160
    1780:	91 40       	sbci	r25, 0x01	; 1
    1782:	69 f4       	brne	.+26     	; 0x179e <sIMU_begin+0x1e8>
    1784:	14 c0       	rjmp	.+40     	; 0x17ae <sIMU_begin+0x1f8>
    1786:	89 81       	ldd	r24, Y+1	; 0x01
    1788:	80 61       	ori	r24, 0x10	; 16
    178a:	89 83       	std	Y+1, r24	; 0x01
    178c:	1b c0       	rjmp	.+54     	; 0x17c4 <sIMU_begin+0x20e>
    178e:	89 81       	ldd	r24, Y+1	; 0x01
    1790:	80 62       	ori	r24, 0x20	; 32
    1792:	89 83       	std	Y+1, r24	; 0x01
    1794:	17 c0       	rjmp	.+46     	; 0x17c4 <sIMU_begin+0x20e>
    1796:	89 81       	ldd	r24, Y+1	; 0x01
    1798:	80 63       	ori	r24, 0x30	; 48
    179a:	89 83       	std	Y+1, r24	; 0x01
    179c:	13 c0       	rjmp	.+38     	; 0x17c4 <sIMU_begin+0x20e>
    179e:	89 81       	ldd	r24, Y+1	; 0x01
    17a0:	80 64       	ori	r24, 0x40	; 64
    17a2:	89 83       	std	Y+1, r24	; 0x01
    17a4:	0f c0       	rjmp	.+30     	; 0x17c4 <sIMU_begin+0x20e>
    17a6:	89 81       	ldd	r24, Y+1	; 0x01
    17a8:	80 65       	ori	r24, 0x50	; 80
    17aa:	89 83       	std	Y+1, r24	; 0x01
    17ac:	0b c0       	rjmp	.+22     	; 0x17c4 <sIMU_begin+0x20e>
    17ae:	89 81       	ldd	r24, Y+1	; 0x01
    17b0:	80 66       	ori	r24, 0x60	; 96
    17b2:	89 83       	std	Y+1, r24	; 0x01
    17b4:	07 c0       	rjmp	.+14     	; 0x17c4 <sIMU_begin+0x20e>
    17b6:	89 81       	ldd	r24, Y+1	; 0x01
    17b8:	80 67       	ori	r24, 0x70	; 112
    17ba:	89 83       	std	Y+1, r24	; 0x01
    17bc:	03 c0       	rjmp	.+6      	; 0x17c4 <sIMU_begin+0x20e>
    17be:	89 81       	ldd	r24, Y+1	; 0x01
    17c0:	80 68       	ori	r24, 0x80	; 128
    17c2:	89 83       	std	Y+1, r24	; 0x01
    17c4:	69 81       	ldd	r22, Y+1	; 0x01
    17c6:	81 e1       	ldi	r24, 0x11	; 17
    17c8:	ea de       	rcall	.-556    	; 0x159e <sIMU_writeRegister>
    17ca:	6f e0       	ldi	r22, 0x0F	; 15
    17cc:	ce 01       	movw	r24, r28
    17ce:	02 96       	adiw	r24, 0x02	; 2
    17d0:	5e de       	rcall	.-836    	; 0x148e <sIMU_readRegister>
    17d2:	81 2f       	mov	r24, r17
    17d4:	0f 90       	pop	r0
    17d6:	0f 90       	pop	r0
    17d8:	df 91       	pop	r29
    17da:	cf 91       	pop	r28
    17dc:	1f 91       	pop	r17
    17de:	08 95       	ret

000017e0 <i16IMU_readRawGyroZ>:
    17e0:	cf 93       	push	r28
    17e2:	df 93       	push	r29
    17e4:	1f 92       	push	r1
    17e6:	1f 92       	push	r1
    17e8:	cd b7       	in	r28, 0x3d	; 61
    17ea:	de b7       	in	r29, 0x3e	; 62
    17ec:	66 e2       	ldi	r22, 0x26	; 38
    17ee:	ce 01       	movw	r24, r28
    17f0:	01 96       	adiw	r24, 0x01	; 1
    17f2:	b8 de       	rcall	.-656    	; 0x1564 <sIMU_readRegisterInt16>
    17f4:	88 23       	and	r24, r24
    17f6:	a9 f0       	breq	.+42     	; 0x1822 <i16IMU_readRawGyroZ+0x42>
    17f8:	85 30       	cpi	r24, 0x05	; 5
    17fa:	51 f4       	brne	.+20     	; 0x1810 <i16IMU_readRawGyroZ+0x30>
    17fc:	80 91 29 1b 	lds	r24, 0x1B29	; 0x801b29 <allOnesCounter>
    1800:	90 91 2a 1b 	lds	r25, 0x1B2A	; 0x801b2a <allOnesCounter+0x1>
    1804:	01 96       	adiw	r24, 0x01	; 1
    1806:	90 93 2a 1b 	sts	0x1B2A, r25	; 0x801b2a <allOnesCounter+0x1>
    180a:	80 93 29 1b 	sts	0x1B29, r24	; 0x801b29 <allOnesCounter>
    180e:	09 c0       	rjmp	.+18     	; 0x1822 <i16IMU_readRawGyroZ+0x42>
    1810:	80 91 2b 1b 	lds	r24, 0x1B2B	; 0x801b2b <nonSuccessCounter>
    1814:	90 91 2c 1b 	lds	r25, 0x1B2C	; 0x801b2c <nonSuccessCounter+0x1>
    1818:	01 96       	adiw	r24, 0x01	; 1
    181a:	90 93 2c 1b 	sts	0x1B2C, r25	; 0x801b2c <nonSuccessCounter+0x1>
    181e:	80 93 2b 1b 	sts	0x1B2B, r24	; 0x801b2b <nonSuccessCounter>
    1822:	89 81       	ldd	r24, Y+1	; 0x01
    1824:	9a 81       	ldd	r25, Y+2	; 0x02
    1826:	0f 90       	pop	r0
    1828:	0f 90       	pop	r0
    182a:	df 91       	pop	r29
    182c:	cf 91       	pop	r28
    182e:	08 95       	ret

00001830 <fIMU_calcGyro>:
    1830:	cf 92       	push	r12
    1832:	df 92       	push	r13
    1834:	ef 92       	push	r14
    1836:	ff 92       	push	r15
    1838:	cf 93       	push	r28
    183a:	fc 01       	movw	r30, r24
    183c:	40 91 10 1b 	lds	r20, 0x1B10	; 0x801b10 <settings+0x1>
    1840:	50 91 11 1b 	lds	r21, 0x1B11	; 0x801b11 <settings+0x2>
    1844:	45 3f       	cpi	r20, 0xF5	; 245
    1846:	51 05       	cpc	r21, r1
    1848:	b1 f0       	breq	.+44     	; 0x1876 <fIMU_calcGyro+0x46>
    184a:	9a 01       	movw	r18, r20
    184c:	a5 e2       	ldi	r26, 0x25	; 37
    184e:	b6 e0       	ldi	r27, 0x06	; 6
    1850:	0e 94 45 37 	call	0x6e8a	; 0x6e8a <__umulhisi3>
    1854:	48 1b       	sub	r20, r24
    1856:	59 0b       	sbc	r21, r25
    1858:	56 95       	lsr	r21
    185a:	47 95       	ror	r20
    185c:	48 0f       	add	r20, r24
    185e:	59 1f       	adc	r21, r25
    1860:	00 24       	eor	r0, r0
    1862:	44 0f       	add	r20, r20
    1864:	55 1f       	adc	r21, r21
    1866:	00 1c       	adc	r0, r0
    1868:	44 0f       	add	r20, r20
    186a:	55 1f       	adc	r21, r21
    186c:	00 1c       	adc	r0, r0
    186e:	45 2f       	mov	r20, r21
    1870:	50 2d       	mov	r21, r0
    1872:	c4 2f       	mov	r28, r20
    1874:	01 c0       	rjmp	.+2      	; 0x1878 <fIMU_calcGyro+0x48>
    1876:	c2 e0       	ldi	r28, 0x02	; 2
    1878:	bf 01       	movw	r22, r30
    187a:	ff 0f       	add	r31, r31
    187c:	88 0b       	sbc	r24, r24
    187e:	99 0b       	sbc	r25, r25
    1880:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    1884:	20 e0       	ldi	r18, 0x00	; 0
    1886:	30 e0       	ldi	r19, 0x00	; 0
    1888:	4c e8       	ldi	r20, 0x8C	; 140
    188a:	50 e4       	ldi	r21, 0x40	; 64
    188c:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    1890:	6b 01       	movw	r12, r22
    1892:	7c 01       	movw	r14, r24
    1894:	6c 2f       	mov	r22, r28
    1896:	70 e0       	ldi	r23, 0x00	; 0
    1898:	80 e0       	ldi	r24, 0x00	; 0
    189a:	90 e0       	ldi	r25, 0x00	; 0
    189c:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    18a0:	9b 01       	movw	r18, r22
    18a2:	ac 01       	movw	r20, r24
    18a4:	c7 01       	movw	r24, r14
    18a6:	b6 01       	movw	r22, r12
    18a8:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    18ac:	20 e0       	ldi	r18, 0x00	; 0
    18ae:	30 e0       	ldi	r19, 0x00	; 0
    18b0:	4a e7       	ldi	r20, 0x7A	; 122
    18b2:	54 e4       	ldi	r21, 0x44	; 68
    18b4:	0e 94 22 31 	call	0x6244	; 0x6244 <__divsf3>
    18b8:	cf 91       	pop	r28
    18ba:	ff 90       	pop	r15
    18bc:	ef 90       	pop	r14
    18be:	df 90       	pop	r13
    18c0:	cf 90       	pop	r12
    18c2:	08 95       	ret

000018c4 <fIMU_readFloatGyroZ>:
    }
    
    return output;
}
float fIMU_readFloatGyroZ(){
    float output = fIMU_calcGyro(i16IMU_readRawGyroZ());
    18c4:	8d df       	rcall	.-230    	; 0x17e0 <i16IMU_readRawGyroZ>
    18c6:	b4 cf       	rjmp	.-152    	; 0x1830 <fIMU_calcGyro>
    
    return output;
}
    18c8:	08 95       	ret

000018ca <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    18ca:	ea e0       	ldi	r30, 0x0A	; 10
    18cc:	f1 e0       	ldi	r31, 0x01	; 1
    18ce:	80 81       	ld	r24, Z
    18d0:	87 60       	ori	r24, 0x07	; 7
    18d2:	80 83       	st	Z, r24
    18d4:	08 95       	ret

000018d6 <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
    18d6:	82 30       	cpi	r24, 0x02	; 2
    18d8:	91 05       	cpc	r25, r1
    18da:	31 f4       	brne	.+12     	; 0x18e8 <vLED_singleHigh+0x12>
    18dc:	eb e0       	ldi	r30, 0x0B	; 11
    18de:	f1 e0       	ldi	r31, 0x01	; 1
    18e0:	80 81       	ld	r24, Z
    18e2:	84 60       	ori	r24, 0x04	; 4
    18e4:	80 83       	st	Z, r24
    18e6:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
    18e8:	81 30       	cpi	r24, 0x01	; 1
    18ea:	91 05       	cpc	r25, r1
    18ec:	31 f4       	brne	.+12     	; 0x18fa <vLED_singleHigh+0x24>
    18ee:	eb e0       	ldi	r30, 0x0B	; 11
    18f0:	f1 e0       	ldi	r31, 0x01	; 1
    18f2:	80 81       	ld	r24, Z
    18f4:	82 60       	ori	r24, 0x02	; 2
    18f6:	80 83       	st	Z, r24
    18f8:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
    18fa:	89 2b       	or	r24, r25
    18fc:	29 f4       	brne	.+10     	; 0x1908 <vLED_singleHigh+0x32>
    18fe:	eb e0       	ldi	r30, 0x0B	; 11
    1900:	f1 e0       	ldi	r31, 0x01	; 1
    1902:	80 81       	ld	r24, Z
    1904:	81 60       	ori	r24, 0x01	; 1
    1906:	80 83       	st	Z, r24
    1908:	08 95       	ret

0000190a <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
    190a:	82 30       	cpi	r24, 0x02	; 2
    190c:	91 05       	cpc	r25, r1
    190e:	31 f4       	brne	.+12     	; 0x191c <vLED_singleLow+0x12>
    1910:	eb e0       	ldi	r30, 0x0B	; 11
    1912:	f1 e0       	ldi	r31, 0x01	; 1
    1914:	80 81       	ld	r24, Z
    1916:	8b 7f       	andi	r24, 0xFB	; 251
    1918:	80 83       	st	Z, r24
    191a:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
    191c:	81 30       	cpi	r24, 0x01	; 1
    191e:	91 05       	cpc	r25, r1
    1920:	31 f4       	brne	.+12     	; 0x192e <vLED_singleLow+0x24>
    1922:	eb e0       	ldi	r30, 0x0B	; 11
    1924:	f1 e0       	ldi	r31, 0x01	; 1
    1926:	80 81       	ld	r24, Z
    1928:	8d 7f       	andi	r24, 0xFD	; 253
    192a:	80 83       	st	Z, r24
    192c:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
    192e:	89 2b       	or	r24, r25
    1930:	29 f4       	brne	.+10     	; 0x193c <vLED_singleLow+0x32>
    1932:	eb e0       	ldi	r30, 0x0B	; 11
    1934:	f1 e0       	ldi	r31, 0x01	; 1
    1936:	80 81       	ld	r24, Z
    1938:	8e 7f       	andi	r24, 0xFE	; 254
    193a:	80 83       	st	Z, r24
    193c:	08 95       	ret

0000193e <vLED_toggle>:
}

/* Toggle a single LED */
void vLED_toggle(int ledCOLOR){
	if (ledCOLOR == ledGREEN)		ledPORT ^= (1<<ledGREEN);
    193e:	82 30       	cpi	r24, 0x02	; 2
    1940:	91 05       	cpc	r25, r1
    1942:	39 f4       	brne	.+14     	; 0x1952 <vLED_toggle+0x14>
    1944:	eb e0       	ldi	r30, 0x0B	; 11
    1946:	f1 e0       	ldi	r31, 0x01	; 1
    1948:	90 81       	ld	r25, Z
    194a:	84 e0       	ldi	r24, 0x04	; 4
    194c:	89 27       	eor	r24, r25
    194e:	80 83       	st	Z, r24
    1950:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)	ledPORT ^= (1<<ledYELLOW);
    1952:	81 30       	cpi	r24, 0x01	; 1
    1954:	91 05       	cpc	r25, r1
    1956:	39 f4       	brne	.+14     	; 0x1966 <vLED_toggle+0x28>
    1958:	eb e0       	ldi	r30, 0x0B	; 11
    195a:	f1 e0       	ldi	r31, 0x01	; 1
    195c:	90 81       	ld	r25, Z
    195e:	82 e0       	ldi	r24, 0x02	; 2
    1960:	89 27       	eor	r24, r25
    1962:	80 83       	st	Z, r24
    1964:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT ^= (1<<ledRED);
    1966:	89 2b       	or	r24, r25
    1968:	31 f4       	brne	.+12     	; 0x1976 <vLED_toggle+0x38>
    196a:	eb e0       	ldi	r30, 0x0B	; 11
    196c:	f1 e0       	ldi	r31, 0x01	; 1
    196e:	90 81       	ld	r25, Z
    1970:	81 e0       	ldi	r24, 0x01	; 1
    1972:	89 27       	eor	r24, r25
    1974:	80 83       	st	Z, r24
    1976:	08 95       	ret

00001978 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1978:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    197a:	03 96       	adiw	r24, 0x03	; 3
    197c:	92 83       	std	Z+2, r25	; 0x02
    197e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1980:	2f ef       	ldi	r18, 0xFF	; 255
    1982:	3f ef       	ldi	r19, 0xFF	; 255
    1984:	34 83       	std	Z+4, r19	; 0x04
    1986:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1988:	96 83       	std	Z+6, r25	; 0x06
    198a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    198c:	90 87       	std	Z+8, r25	; 0x08
    198e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1990:	10 82       	st	Z, r1
    1992:	08 95       	ret

00001994 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1994:	fc 01       	movw	r30, r24
    1996:	11 86       	std	Z+9, r1	; 0x09
    1998:	10 86       	std	Z+8, r1	; 0x08
    199a:	08 95       	ret

0000199c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    199c:	cf 93       	push	r28
    199e:	df 93       	push	r29
    19a0:	9c 01       	movw	r18, r24
    19a2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    19a4:	dc 01       	movw	r26, r24
    19a6:	11 96       	adiw	r26, 0x01	; 1
    19a8:	cd 91       	ld	r28, X+
    19aa:	dc 91       	ld	r29, X
    19ac:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    19ae:	d3 83       	std	Z+3, r29	; 0x03
    19b0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    19b2:	8c 81       	ldd	r24, Y+4	; 0x04
    19b4:	9d 81       	ldd	r25, Y+5	; 0x05
    19b6:	95 83       	std	Z+5, r25	; 0x05
    19b8:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    19ba:	8c 81       	ldd	r24, Y+4	; 0x04
    19bc:	9d 81       	ldd	r25, Y+5	; 0x05
    19be:	dc 01       	movw	r26, r24
    19c0:	13 96       	adiw	r26, 0x03	; 3
    19c2:	7c 93       	st	X, r23
    19c4:	6e 93       	st	-X, r22
    19c6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    19c8:	7d 83       	std	Y+5, r23	; 0x05
    19ca:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    19cc:	31 87       	std	Z+9, r19	; 0x09
    19ce:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    19d0:	f9 01       	movw	r30, r18
    19d2:	80 81       	ld	r24, Z
    19d4:	8f 5f       	subi	r24, 0xFF	; 255
    19d6:	80 83       	st	Z, r24
}
    19d8:	df 91       	pop	r29
    19da:	cf 91       	pop	r28
    19dc:	08 95       	ret

000019de <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    19de:	cf 93       	push	r28
    19e0:	df 93       	push	r29
    19e2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    19e4:	48 81       	ld	r20, Y
    19e6:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    19e8:	4f 3f       	cpi	r20, 0xFF	; 255
    19ea:	2f ef       	ldi	r18, 0xFF	; 255
    19ec:	52 07       	cpc	r21, r18
    19ee:	21 f4       	brne	.+8      	; 0x19f8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    19f0:	fc 01       	movw	r30, r24
    19f2:	a7 81       	ldd	r26, Z+7	; 0x07
    19f4:	b0 85       	ldd	r27, Z+8	; 0x08
    19f6:	0d c0       	rjmp	.+26     	; 0x1a12 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    19f8:	dc 01       	movw	r26, r24
    19fa:	13 96       	adiw	r26, 0x03	; 3
    19fc:	01 c0       	rjmp	.+2      	; 0x1a00 <vListInsert+0x22>
    19fe:	df 01       	movw	r26, r30
    1a00:	12 96       	adiw	r26, 0x02	; 2
    1a02:	ed 91       	ld	r30, X+
    1a04:	fc 91       	ld	r31, X
    1a06:	13 97       	sbiw	r26, 0x03	; 3
    1a08:	20 81       	ld	r18, Z
    1a0a:	31 81       	ldd	r19, Z+1	; 0x01
    1a0c:	42 17       	cp	r20, r18
    1a0e:	53 07       	cpc	r21, r19
    1a10:	b0 f7       	brcc	.-20     	; 0x19fe <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1a12:	12 96       	adiw	r26, 0x02	; 2
    1a14:	ed 91       	ld	r30, X+
    1a16:	fc 91       	ld	r31, X
    1a18:	13 97       	sbiw	r26, 0x03	; 3
    1a1a:	fb 83       	std	Y+3, r31	; 0x03
    1a1c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1a1e:	d5 83       	std	Z+5, r29	; 0x05
    1a20:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1a22:	bd 83       	std	Y+5, r27	; 0x05
    1a24:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1a26:	13 96       	adiw	r26, 0x03	; 3
    1a28:	dc 93       	st	X, r29
    1a2a:	ce 93       	st	-X, r28
    1a2c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1a2e:	99 87       	std	Y+9, r25	; 0x09
    1a30:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1a32:	fc 01       	movw	r30, r24
    1a34:	20 81       	ld	r18, Z
    1a36:	2f 5f       	subi	r18, 0xFF	; 255
    1a38:	20 83       	st	Z, r18
}
    1a3a:	df 91       	pop	r29
    1a3c:	cf 91       	pop	r28
    1a3e:	08 95       	ret

00001a40 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1a40:	cf 93       	push	r28
    1a42:	df 93       	push	r29
    1a44:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    1a46:	a0 85       	ldd	r26, Z+8	; 0x08
    1a48:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    1a4a:	c2 81       	ldd	r28, Z+2	; 0x02
    1a4c:	d3 81       	ldd	r29, Z+3	; 0x03
    1a4e:	84 81       	ldd	r24, Z+4	; 0x04
    1a50:	95 81       	ldd	r25, Z+5	; 0x05
    1a52:	9d 83       	std	Y+5, r25	; 0x05
    1a54:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1a56:	c4 81       	ldd	r28, Z+4	; 0x04
    1a58:	d5 81       	ldd	r29, Z+5	; 0x05
    1a5a:	82 81       	ldd	r24, Z+2	; 0x02
    1a5c:	93 81       	ldd	r25, Z+3	; 0x03
    1a5e:	9b 83       	std	Y+3, r25	; 0x03
    1a60:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1a62:	11 96       	adiw	r26, 0x01	; 1
    1a64:	cd 91       	ld	r28, X+
    1a66:	dc 91       	ld	r29, X
    1a68:	12 97       	sbiw	r26, 0x02	; 2
    1a6a:	ce 17       	cp	r28, r30
    1a6c:	df 07       	cpc	r29, r31
    1a6e:	31 f4       	brne	.+12     	; 0x1a7c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1a70:	8c 81       	ldd	r24, Y+4	; 0x04
    1a72:	9d 81       	ldd	r25, Y+5	; 0x05
    1a74:	12 96       	adiw	r26, 0x02	; 2
    1a76:	9c 93       	st	X, r25
    1a78:	8e 93       	st	-X, r24
    1a7a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1a7c:	11 86       	std	Z+9, r1	; 0x09
    1a7e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1a80:	8c 91       	ld	r24, X
    1a82:	81 50       	subi	r24, 0x01	; 1
    1a84:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    1a86:	df 91       	pop	r29
    1a88:	cf 91       	pop	r28
    1a8a:	08 95       	ret

00001a8c <vMainCommunicationTask>:
    #define toc PORTH &= ~(1<<PINH5)
#endif

/*  Communication task */
/*  Communication task */
void vMainCommunicationTask( void *pvParameters ){
    1a8c:	cf 93       	push	r28
    1a8e:	df 93       	push	r29
    1a90:	00 d0       	rcall	.+0      	; 0x1a92 <vMainCommunicationTask+0x6>
    1a92:	00 d0       	rcall	.+0      	; 0x1a94 <vMainCommunicationTask+0x8>
    1a94:	cd b7       	in	r28, 0x3d	; 61
    1a96:	de b7       	in	r29, 0x3e	; 62
	// Setup for the communication task
	struct sPolar Setpoint = {0}; // Struct for setpoints from server
    1a98:	fe 01       	movw	r30, r28
    1a9a:	31 96       	adiw	r30, 0x01	; 1
    1a9c:	86 e0       	ldi	r24, 0x06	; 6
    1a9e:	df 01       	movw	r26, r30
    1aa0:	1d 92       	st	X+, r1
    1aa2:	8a 95       	dec	r24
    1aa4:	e9 f7       	brne	.-6      	; 0x1aa0 <vMainCommunicationTask+0x14>

	message_t command_in; // Buffer for recieved messages

	server_communication_init();
    1aa6:	0e 94 3f 20 	call	0x407e	; 0x407e <server_communication_init>
	if(xTaskCreate(vARQTask, "ARQ", 200, NULL, 3, NULL) != pdPASS) {
    1aaa:	a1 2c       	mov	r10, r1
    1aac:	b1 2c       	mov	r11, r1
    1aae:	c1 2c       	mov	r12, r1
    1ab0:	d1 2c       	mov	r13, r1
    1ab2:	e1 2c       	mov	r14, r1
    1ab4:	f1 2c       	mov	r15, r1
    1ab6:	03 e0       	ldi	r16, 0x03	; 3
    1ab8:	20 e0       	ldi	r18, 0x00	; 0
    1aba:	30 e0       	ldi	r19, 0x00	; 0
    1abc:	48 ec       	ldi	r20, 0xC8	; 200
    1abe:	50 e0       	ldi	r21, 0x00	; 0
    1ac0:	6b e0       	ldi	r22, 0x0B	; 11
    1ac2:	76 e0       	ldi	r23, 0x06	; 6
    1ac4:	85 e2       	ldi	r24, 0x25	; 37
    1ac6:	95 e0       	ldi	r25, 0x05	; 5
    1ac8:	0e 94 b9 22 	call	0x4572	; 0x4572 <xTaskGenericCreate>
    1acc:	81 30       	cpi	r24, 0x01	; 1
    1ace:	19 f0       	breq	.+6      	; 0x1ad6 <vMainCommunicationTask+0x4a>
		vLED_singleHigh(ledRED);
    1ad0:	80 e0       	ldi	r24, 0x00	; 0
    1ad2:	90 e0       	ldi	r25, 0x00	; 0
    1ad4:	00 df       	rcall	.-512    	; 0x18d6 <vLED_singleHigh>
	}
	uint8_t success = 0;
	
	while(!success) {
		success = server_connect();
    1ad6:	0e 94 48 20 	call	0x4090	; 0x4090 <server_connect>
    1ada:	18 2f       	mov	r17, r24
		vTaskDelay(1000 / portTICK_PERIOD_MS);
    1adc:	88 ee       	ldi	r24, 0xE8	; 232
    1ade:	93 e0       	ldi	r25, 0x03	; 3
    1ae0:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <vTaskDelay>
		vLED_toggle(ledGREEN);
    1ae4:	82 e0       	ldi	r24, 0x02	; 2
    1ae6:	90 e0       	ldi	r25, 0x00	; 0
    1ae8:	2a df       	rcall	.-428    	; 0x193e <vLED_toggle>
	if(xTaskCreate(vARQTask, "ARQ", 200, NULL, 3, NULL) != pdPASS) {
		vLED_singleHigh(ledRED);
	}
	uint8_t success = 0;
	
	while(!success) {
    1aea:	11 23       	and	r17, r17
    1aec:	a1 f3       	breq	.-24     	; 0x1ad6 <vMainCommunicationTask+0x4a>
		success = server_connect();
		vTaskDelay(1000 / portTICK_PERIOD_MS);
		vLED_toggle(ledGREEN);
	}
	
	send_handshake();
    1aee:	0e 94 54 20 	call	0x40a8	; 0x40a8 <send_handshake>
	while(1){
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
			taskENTER_CRITICAL();
			command_in = message_in;
    1af2:	0f 2e       	mov	r0, r31
    1af4:	f9 e3       	ldi	r31, 0x39	; 57
    1af6:	ef 2e       	mov	r14, r31
    1af8:	fb e1       	ldi	r31, 0x1B	; 27
    1afa:	ff 2e       	mov	r15, r31
    1afc:	f0 2d       	mov	r31, r0
			taskEXIT_CRITICAL();
			xTaskResumeAll ();      // Enable context switching
			switch(command_in.type){
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
					gHandshook = TRUE; // Set start flag true
    1afe:	01 e0       	ldi	r16, 0x01	; 1
					// Ensure max values are not exceeded
					if (Setpoint.distance > 320){
						Setpoint.distance = 320;
					}
					else if (Setpoint.distance < -320){
						Setpoint.distance = -320;
    1b00:	0f 2e       	mov	r0, r31
    1b02:	f0 ec       	ldi	r31, 0xC0	; 192
    1b04:	6f 2e       	mov	r6, r31
    1b06:	fe ef       	ldi	r31, 0xFE	; 254
    1b08:	7f 2e       	mov	r7, r31
    1b0a:	f0 2d       	mov	r31, r0
				case TYPE_ORDER:
					Setpoint.heading = command_in.message.order.orientation;
					Setpoint.distance = command_in.message.order.distance;
					// Ensure max values are not exceeded
					if (Setpoint.distance > 320){
						Setpoint.distance = 320;
    1b0c:	68 94       	set
    1b0e:	88 24       	eor	r8, r8
    1b10:	86 f8       	bld	r8, 6
    1b12:	99 24       	eor	r9, r9
    1b14:	93 94       	inc	r9
	}
	
	send_handshake();
	
	while(1){
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
    1b16:	20 e0       	ldi	r18, 0x00	; 0
    1b18:	4f ef       	ldi	r20, 0xFF	; 255
    1b1a:	5f ef       	ldi	r21, 0xFF	; 255
    1b1c:	60 e0       	ldi	r22, 0x00	; 0
    1b1e:	70 e0       	ldi	r23, 0x00	; 0
    1b20:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xCommandReadyBSem>
    1b24:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xCommandReadyBSem+0x1>
    1b28:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
    1b2c:	81 30       	cpi	r24, 0x01	; 1
    1b2e:	99 f7       	brne	.-26     	; 0x1b16 <vMainCommunicationTask+0x8a>
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
    1b30:	0e 94 d9 27 	call	0x4fb2	; 0x4fb2 <vTaskSuspendAll>
			taskENTER_CRITICAL();
    1b34:	0f b6       	in	r0, 0x3f	; 63
    1b36:	f8 94       	cli
    1b38:	0f 92       	push	r0
			command_in = message_in;
    1b3a:	f7 01       	movw	r30, r14
    1b3c:	10 81       	ld	r17, Z
    1b3e:	c1 80       	ldd	r12, Z+1	; 0x01
    1b40:	d2 80       	ldd	r13, Z+2	; 0x02
    1b42:	a3 80       	ldd	r10, Z+3	; 0x03
    1b44:	b4 80       	ldd	r11, Z+4	; 0x04
			taskEXIT_CRITICAL();
    1b46:	0f 90       	pop	r0
    1b48:	0f be       	out	0x3f, r0	; 63
			xTaskResumeAll ();      // Enable context switching
    1b4a:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
			switch(command_in.type){
    1b4e:	15 30       	cpi	r17, 0x05	; 5
    1b50:	09 f4       	brne	.+2      	; 0x1b54 <vMainCommunicationTask+0xc8>
    1b52:	65 c0       	rjmp	.+202    	; 0x1c1e <vMainCommunicationTask+0x192>
    1b54:	30 f4       	brcc	.+12     	; 0x1b62 <vMainCommunicationTask+0xd6>
    1b56:	12 30       	cpi	r17, 0x02	; 2
    1b58:	b1 f0       	breq	.+44     	; 0x1b86 <vMainCommunicationTask+0xfa>
    1b5a:	14 30       	cpi	r17, 0x04	; 4
    1b5c:	09 f4       	brne	.+2      	; 0x1b60 <vMainCommunicationTask+0xd4>
    1b5e:	45 c0       	rjmp	.+138    	; 0x1bea <vMainCommunicationTask+0x15e>
    1b60:	da cf       	rjmp	.-76     	; 0x1b16 <vMainCommunicationTask+0x8a>
    1b62:	17 30       	cpi	r17, 0x07	; 7
    1b64:	09 f4       	brne	.+2      	; 0x1b68 <vMainCommunicationTask+0xdc>
    1b66:	63 c0       	rjmp	.+198    	; 0x1c2e <vMainCommunicationTask+0x1a2>
    1b68:	18 f0       	brcs	.+6      	; 0x1b70 <vMainCommunicationTask+0xe4>
    1b6a:	18 30       	cpi	r17, 0x08	; 8
    1b6c:	49 f0       	breq	.+18     	; 0x1b80 <vMainCommunicationTask+0xf4>
    1b6e:	d3 cf       	rjmp	.-90     	; 0x1b16 <vMainCommunicationTask+0x8a>
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
    1b70:	0f b6       	in	r0, 0x3f	; 63
    1b72:	f8 94       	cli
    1b74:	0f 92       	push	r0
					gHandshook = TRUE; // Set start flag true
    1b76:	00 93 c4 19 	sts	0x19C4, r16	; 0x8019c4 <gHandshook>
					taskEXIT_CRITICAL();
    1b7a:	0f 90       	pop	r0
    1b7c:	0f be       	out	0x3f, r0	; 63

					break;
    1b7e:	cb cf       	rjmp	.-106    	; 0x1b16 <vMainCommunicationTask+0x8a>
					case TYPE_PING:
					send_ping_response();
    1b80:	0e 94 60 21 	call	0x42c0	; 0x42c0 <send_ping_response>
					break;
    1b84:	c8 cf       	rjmp	.-112    	; 0x1b16 <vMainCommunicationTask+0x8a>
				case TYPE_ORDER:
					Setpoint.heading = command_in.message.order.orientation;
    1b86:	b6 01       	movw	r22, r12
    1b88:	dd 0c       	add	r13, r13
    1b8a:	88 0b       	sbc	r24, r24
    1b8c:	99 0b       	sbc	r25, r25
    1b8e:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
					Setpoint.distance = command_in.message.order.distance;
					// Ensure max values are not exceeded
					if (Setpoint.distance > 320){
    1b92:	f1 e4       	ldi	r31, 0x41	; 65
    1b94:	af 16       	cp	r10, r31
    1b96:	f1 e0       	ldi	r31, 0x01	; 1
    1b98:	bf 06       	cpc	r11, r31
    1b9a:	1c f0       	brlt	.+6      	; 0x1ba2 <vMainCommunicationTask+0x116>
						Setpoint.distance = 320;
    1b9c:	9e 82       	std	Y+6, r9	; 0x06
    1b9e:	8d 82       	std	Y+5, r8	; 0x05
    1ba0:	0a c0       	rjmp	.+20     	; 0x1bb6 <vMainCommunicationTask+0x12a>
					}
					else if (Setpoint.distance < -320){
    1ba2:	20 ec       	ldi	r18, 0xC0	; 192
    1ba4:	a2 16       	cp	r10, r18
    1ba6:	2e ef       	ldi	r18, 0xFE	; 254
    1ba8:	b2 06       	cpc	r11, r18
    1baa:	1c f0       	brlt	.+6      	; 0x1bb2 <vMainCommunicationTask+0x126>
					case TYPE_PING:
					send_ping_response();
					break;
				case TYPE_ORDER:
					Setpoint.heading = command_in.message.order.orientation;
					Setpoint.distance = command_in.message.order.distance;
    1bac:	be 82       	std	Y+6, r11	; 0x06
    1bae:	ad 82       	std	Y+5, r10	; 0x05
    1bb0:	02 c0       	rjmp	.+4      	; 0x1bb6 <vMainCommunicationTask+0x12a>
					// Ensure max values are not exceeded
					if (Setpoint.distance > 320){
						Setpoint.distance = 320;
					}
					else if (Setpoint.distance < -320){
						Setpoint.distance = -320;
    1bb2:	7e 82       	std	Y+6, r7	; 0x06
    1bb4:	6d 82       	std	Y+5, r6	; 0x05
					}
					Setpoint.heading *= DEG2RAD; // Convert received set point to radians
    1bb6:	25 e3       	ldi	r18, 0x35	; 53
    1bb8:	3a ef       	ldi	r19, 0xFA	; 250
    1bba:	4e e8       	ldi	r20, 0x8E	; 142
    1bbc:	5c e3       	ldi	r21, 0x3C	; 60
    1bbe:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    1bc2:	69 83       	std	Y+1, r22	; 0x01
    1bc4:	7a 83       	std	Y+2, r23	; 0x02
    1bc6:	8b 83       	std	Y+3, r24	; 0x03
    1bc8:	9c 83       	std	Y+4, r25	; 0x04
					vFunc_Inf2pi(&Setpoint.heading);
    1bca:	ce 01       	movw	r24, r28
    1bcc:	01 96       	adiw	r24, 0x01	; 1
    1bce:	62 da       	rcall	.-2876   	; 0x1094 <vFunc_Inf2pi>
				
					/* Relay new coordinates to position controller */
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1bd0:	20 e0       	ldi	r18, 0x00	; 0
    1bd2:	44 e6       	ldi	r20, 0x64	; 100
    1bd4:	50 e0       	ldi	r21, 0x00	; 0
    1bd6:	be 01       	movw	r22, r28
    1bd8:	6f 5f       	subi	r22, 0xFF	; 255
    1bda:	7f 4f       	sbci	r23, 0xFF	; 255
    1bdc:	80 91 cb 19 	lds	r24, 0x19CB	; 0x8019cb <poseControllerQ>
    1be0:	90 91 cc 19 	lds	r25, 0x19CC	; 0x8019cc <poseControllerQ+0x1>
    1be4:	0e 94 1f 1b 	call	0x363e	; 0x363e <xQueueGenericSend>
					break;
    1be8:	96 cf       	rjmp	.-212    	; 0x1b16 <vMainCommunicationTask+0x8a>
				case TYPE_PAUSE:
					// Stop sending update messages
					taskENTER_CRITICAL();
    1bea:	0f b6       	in	r0, 0x3f	; 63
    1bec:	f8 94       	cli
    1bee:	0f 92       	push	r0
					gPaused = TRUE;
    1bf0:	00 93 c3 19 	sts	0x19C3, r16	; 0x8019c3 <gPaused>
					taskEXIT_CRITICAL();
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63
					// Stop controller
					Setpoint.distance = 0;
    1bf8:	1e 82       	std	Y+6, r1	; 0x06
    1bfa:	1d 82       	std	Y+5, r1	; 0x05
					Setpoint.heading = 0;
    1bfc:	19 82       	std	Y+1, r1	; 0x01
    1bfe:	1a 82       	std	Y+2, r1	; 0x02
    1c00:	1b 82       	std	Y+3, r1	; 0x03
    1c02:	1c 82       	std	Y+4, r1	; 0x04
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1c04:	20 e0       	ldi	r18, 0x00	; 0
    1c06:	44 e6       	ldi	r20, 0x64	; 100
    1c08:	50 e0       	ldi	r21, 0x00	; 0
    1c0a:	be 01       	movw	r22, r28
    1c0c:	6f 5f       	subi	r22, 0xFF	; 255
    1c0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1c10:	80 91 cb 19 	lds	r24, 0x19CB	; 0x8019cb <poseControllerQ>
    1c14:	90 91 cc 19 	lds	r25, 0x19CC	; 0x8019cc <poseControllerQ+0x1>
    1c18:	0e 94 1f 1b 	call	0x363e	; 0x363e <xQueueGenericSend>
					break;
    1c1c:	7c cf       	rjmp	.-264    	; 0x1b16 <vMainCommunicationTask+0x8a>
				case TYPE_UNPAUSE:
					taskENTER_CRITICAL();
    1c1e:	0f b6       	in	r0, 0x3f	; 63
    1c20:	f8 94       	cli
    1c22:	0f 92       	push	r0
					gPaused = FALSE;
    1c24:	10 92 c3 19 	sts	0x19C3, r1	; 0x8019c3 <gPaused>
					taskEXIT_CRITICAL();
    1c28:	0f 90       	pop	r0
    1c2a:	0f be       	out	0x3f, r0	; 63
					break;
    1c2c:	74 cf       	rjmp	.-280    	; 0x1b16 <vMainCommunicationTask+0x8a>
				case TYPE_FINISH:
					taskENTER_CRITICAL();
    1c2e:	0f b6       	in	r0, 0x3f	; 63
    1c30:	f8 94       	cli
    1c32:	0f 92       	push	r0
					gHandshook = FALSE;
    1c34:	10 92 c4 19 	sts	0x19C4, r1	; 0x8019c4 <gHandshook>
					taskEXIT_CRITICAL();
    1c38:	0f 90       	pop	r0
    1c3a:	0f be       	out	0x3f, r0	; 63
					break;
    1c3c:	6c cf       	rjmp	.-296    	; 0x1b16 <vMainCommunicationTask+0x8a>

00001c3e <vMainMovementTask>:
    } // While(1) end
}

/* Handles request from position controller and sets motor pins. */
/* Frequency set by PERIOD_MOTOR_MS in defines.h */
void vMainMovementTask( void *pvParameters ){
    1c3e:	cf 93       	push	r28
    1c40:	df 93       	push	r29
    1c42:	1f 92       	push	r1
    1c44:	1f 92       	push	r1
    1c46:	cd b7       	in	r28, 0x3d	; 61
    1c48:	de b7       	in	r29, 0x3e	; 62
    
    
    
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    1c4a:	0e 94 1a 29 	call	0x5234	; 0x5234 <xTaskGetTickCount>
    1c4e:	9a 83       	std	Y+2, r25	; 0x02
    1c50:	89 83       	std	Y+1, r24	; 0x01
    const TickType_t xDelay = PERIOD_MOTOR_MS;
    
    while(1){
		
		
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    1c52:	64 e1       	ldi	r22, 0x14	; 20
    1c54:	70 e0       	ldi	r23, 0x00	; 0
    1c56:	ce 01       	movw	r24, r28
    1c58:	01 96       	adiw	r24, 0x01	; 1
    1c5a:	0e 94 cd 23 	call	0x479a	; 0x479a <vTaskDelayUntil>
            vMotorBrakeLeft();
            vMotorBrakeRight();
        }
    
	*/
	}// While(1) end
    1c5e:	f9 cf       	rjmp	.-14     	; 0x1c52 <vMainMovementTask+0x14>

00001c60 <vMainSensorTowerTask>:
		} // if (xCommandReady) end
	}// While(1) end
}// vMainComtask end

/*  Sensor tower task */
void vMainSensorTowerTask( void *pvParameters){
    1c60:	cf 93       	push	r28
    1c62:	df 93       	push	r29
    1c64:	cd b7       	in	r28, 0x3d	; 61
    1c66:	de b7       	in	r29, 0x3e	; 62
    1c68:	2f 97       	sbiw	r28, 0x0f	; 15
    1c6a:	0f b6       	in	r0, 0x3f	; 63
    1c6c:	f8 94       	cli
    1c6e:	de bf       	out	0x3e, r29	; 62
    1c70:	0f be       	out	0x3f, r0	; 63
    1c72:	cd bf       	out	0x3d, r28	; 61
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    uint8_t robotMovement = moveStop;
    1c74:	19 82       	std	Y+1, r1	; 0x01
    
    uint8_t idleCounter = 0;
    1c76:	f1 2c       	mov	r15, r1
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    1c78:	33 24       	eor	r3, r3
    1c7a:	33 94       	inc	r3
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    1c7c:	10 e0       	ldi	r17, 0x00	; 0
        
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    1c7e:	68 94       	set
    1c80:	dd 24       	eor	r13, r13
    1c82:	d2 f8       	bld	r13, 2
            vTaskDelay(200 / portTICK_PERIOD_MS);
        */
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1c84:	68 94       	set
    1c86:	22 24       	eor	r2, r2
    1c88:	22 f8       	bld	r2, 2
    1c8a:	13 c0       	rjmp	.+38     	; 0x1cb2 <vMainSensorTowerTask+0x52>
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
                rotationDirection = moveClockwise;
    1c8c:	0f 2e       	mov	r0, r31
    1c8e:	f3 e0       	ldi	r31, 0x03	; 3
    1c90:	df 2e       	mov	r13, r31
    1c92:	f0 2d       	mov	r31, r0
    1c94:	0e c0       	rjmp	.+28     	; 0x1cb2 <vMainSensorTowerTask+0x52>
    1c96:	0f 2e       	mov	r0, r31
    1c98:	f3 e0       	ldi	r31, 0x03	; 3
    1c9a:	df 2e       	mov	r13, r31
    1c9c:	f0 2d       	mov	r31, r0
    1c9e:	09 c0       	rjmp	.+18     	; 0x1cb2 <vMainSensorTowerTask+0x52>
    1ca0:	0f 2e       	mov	r0, r31
    1ca2:	f3 e0       	ldi	r31, 0x03	; 3
    1ca4:	df 2e       	mov	r13, r31
    1ca6:	f0 2d       	mov	r31, r0
    1ca8:	04 c0       	rjmp	.+8      	; 0x1cb2 <vMainSensorTowerTask+0x52>
    1caa:	0f 2e       	mov	r0, r31
    1cac:	f3 e0       	ldi	r31, 0x03	; 3
    1cae:	df 2e       	mov	r13, r31
    1cb0:	f0 2d       	mov	r31, r0
    // Initialize the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    
    while(1){
        // Loop
        if ((gHandshook == TRUE) && (gPaused == FALSE)){
    1cb2:	80 91 c4 19 	lds	r24, 0x19C4	; 0x8019c4 <gHandshook>
    1cb6:	81 30       	cpi	r24, 0x01	; 1
    1cb8:	09 f0       	breq	.+2      	; 0x1cbc <vMainSensorTowerTask+0x5c>
    1cba:	0b c1       	rjmp	.+534    	; 0x1ed2 <vMainSensorTowerTask+0x272>
    1cbc:	80 91 c3 19 	lds	r24, 0x19C3	; 0x8019c3 <gPaused>
    1cc0:	81 11       	cpse	r24, r1
    1cc2:	07 c1       	rjmp	.+526    	; 0x1ed2 <vMainSensorTowerTask+0x272>
            // xLastWakeTime variable with the current time.
            xLastWakeTime = xTaskGetTickCount();
    1cc4:	0e 94 1a 29 	call	0x5234	; 0x5234 <xTaskGetTickCount>
    1cc8:	9b 83       	std	Y+3, r25	; 0x03
    1cca:	8a 83       	std	Y+2, r24	; 0x02
            // Set scanning resolution depending on which movement the robot is executing.
            if (xQueueReceive(scanStatusQ, &robotMovement,150 / portTICK_PERIOD_MS) == pdTRUE){
    1ccc:	20 e0       	ldi	r18, 0x00	; 0
    1cce:	46 e9       	ldi	r20, 0x96	; 150
    1cd0:	50 e0       	ldi	r21, 0x00	; 0
    1cd2:	be 01       	movw	r22, r28
    1cd4:	6f 5f       	subi	r22, 0xFF	; 255
    1cd6:	7f 4f       	sbci	r23, 0xFF	; 255
    1cd8:	80 91 c9 19 	lds	r24, 0x19C9	; 0x8019c9 <scanStatusQ>
    1cdc:	90 91 ca 19 	lds	r25, 0x19CA	; 0x8019ca <scanStatusQ+0x1>
    1ce0:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
    1ce4:	81 30       	cpi	r24, 0x01	; 1
    1ce6:	d9 f4       	brne	.+54     	; 0x1d1e <vMainSensorTowerTask+0xbe>
                // Set servo step length according to movement, 
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
    1ce8:	89 81       	ldd	r24, Y+1	; 0x01
    1cea:	88 23       	and	r24, r24
    1cec:	19 f0       	breq	.+6      	; 0x1cf4 <vMainSensorTowerTask+0x94>
    1cee:	83 30       	cpi	r24, 0x03	; 3
    1cf0:	a8 f4       	brcc	.+42     	; 0x1d1c <vMainSensorTowerTask+0xbc>
    1cf2:	08 c0       	rjmp	.+16     	; 0x1d04 <vMainSensorTowerTask+0xa4>
                {
                    case moveStop:
                        servoStep *= servoResolution;
    1cf4:	13 9d       	mul	r17, r3
    1cf6:	10 2d       	mov	r17, r0
    1cf8:	11 24       	eor	r1, r1
                        servoResolution = 1;
                        idleCounter = 1;
    1cfa:	ff 24       	eor	r15, r15
    1cfc:	f3 94       	inc	r15
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
                {
                    case moveStop:
                        servoStep *= servoResolution;
                        servoResolution = 1;
    1cfe:	33 24       	eor	r3, r3
    1d00:	33 94       	inc	r3
                        idleCounter = 1;
                    break;
    1d02:	0d c0       	rjmp	.+26     	; 0x1d1e <vMainSensorTowerTask+0xbe>
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
                        servoStep /= servoResolution;
    1d04:	8d ec       	ldi	r24, 0xCD	; 205
    1d06:	18 9f       	mul	r17, r24
    1d08:	11 2d       	mov	r17, r1
    1d0a:	11 24       	eor	r1, r1
    1d0c:	16 95       	lsr	r17
    1d0e:	16 95       	lsr	r17
                        idleCounter = 0;
    1d10:	f1 2c       	mov	r15, r1
                        servoResolution = 1;
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
    1d12:	0f 2e       	mov	r0, r31
    1d14:	f5 e0       	ldi	r31, 0x05	; 5
    1d16:	3f 2e       	mov	r3, r31
    1d18:	f0 2d       	mov	r31, r0
                        servoStep /= servoResolution;
                        idleCounter = 0;
                    break;
    1d1a:	01 c0       	rjmp	.+2      	; 0x1d1e <vMainSensorTowerTask+0xbe>
                    case moveClockwise:
                    case moveCounterClockwise:
                        // Iterations are frozen while rotating, see further down
                        idleCounter = 0;
    1d1c:	f1 2c       	mov	r15, r1
                    default:
                        idleCounter = 0;
                    break;
                }
            }
            vServo_setAngle(servoStep*servoResolution);
    1d1e:	31 9e       	mul	r3, r17
    1d20:	80 2d       	mov	r24, r0
    1d22:	11 24       	eor	r1, r1
    1d24:	0e 94 84 21 	call	0x4308	; 0x4308 <vServo_setAngle>
            vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_PERIOD_MS); // Wait total of 200 ms for servo to reach set point
    1d28:	68 ec       	ldi	r22, 0xC8	; 200
    1d2a:	70 e0       	ldi	r23, 0x00	; 0
    1d2c:	ce 01       	movw	r24, r28
    1d2e:	02 96       	adiw	r24, 0x02	; 2
    1d30:	0e 94 cd 23 	call	0x479a	; 0x479a <vTaskDelayUntil>
            
            uint8_t forwardSensor = ui8DistSens_readCM(distSensFwd);
    1d34:	81 e0       	ldi	r24, 0x01	; 1
    1d36:	89 d9       	rcall	.-3310   	; 0x104a <ui8DistSens_readCM>
    1d38:	8e 87       	std	Y+14, r24	; 0x0e
            uint8_t leftSensor = ui8DistSens_readCM(distSensLeft);
    1d3a:	80 e0       	ldi	r24, 0x00	; 0
    1d3c:	86 d9       	rcall	.-3316   	; 0x104a <ui8DistSens_readCM>
    1d3e:	e8 2e       	mov	r14, r24
            uint8_t rearSensor = ui8DistSens_readCM(distSensRear);
    1d40:	83 e0       	ldi	r24, 0x03	; 3
    1d42:	83 d9       	rcall	.-3322   	; 0x104a <ui8DistSens_readCM>
    1d44:	c8 2e       	mov	r12, r24
            uint8_t rightSensor = ui8DistSens_readCM(distSensRight);
    1d46:	82 e0       	ldi	r24, 0x02	; 2
    1d48:	80 d9       	rcall	.-3328   	; 0x104a <ui8DistSens_readCM>
    1d4a:	8f 87       	std	Y+15, r24	; 0x0f
            
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
    1d4c:	20 e0       	ldi	r18, 0x00	; 0
    1d4e:	48 e2       	ldi	r20, 0x28	; 40
    1d50:	50 e0       	ldi	r21, 0x00	; 0
    1d52:	60 e0       	ldi	r22, 0x00	; 0
    1d54:	70 e0       	ldi	r23, 0x00	; 0
    1d56:	80 91 37 1b 	lds	r24, 0x1B37	; 0x801b37 <xPoseMutex>
    1d5a:	90 91 38 1b 	lds	r25, 0x1B38	; 0x801b38 <xPoseMutex+0x1>
    1d5e:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
                thetahat = gTheta_hat;
    1d62:	80 91 bf 19 	lds	r24, 0x19BF	; 0x8019bf <gTheta_hat>
    1d66:	90 91 c0 19 	lds	r25, 0x19C0	; 0x8019c0 <gTheta_hat+0x1>
    1d6a:	a0 91 c1 19 	lds	r26, 0x19C1	; 0x8019c1 <gTheta_hat+0x2>
    1d6e:	b0 91 c2 19 	lds	r27, 0x19C2	; 0x8019c2 <gTheta_hat+0x3>
    1d72:	8a 87       	std	Y+10, r24	; 0x0a
    1d74:	9b 87       	std	Y+11, r25	; 0x0b
    1d76:	ac 87       	std	Y+12, r26	; 0x0c
    1d78:	bd 87       	std	Y+13, r27	; 0x0d
                xhat = gX_hat;
    1d7a:	a0 90 bd 19 	lds	r10, 0x19BD	; 0x8019bd <gX_hat>
    1d7e:	b0 90 be 19 	lds	r11, 0x19BE	; 0x8019be <gX_hat+0x1>
                yhat = gY_hat;
    1d82:	60 90 bb 19 	lds	r6, 0x19BB	; 0x8019bb <gY_hat>
    1d86:	70 90 bc 19 	lds	r7, 0x19BC	; 0x8019bc <gY_hat+0x1>
            xSemaphoreGive(xPoseMutex);
    1d8a:	60 e0       	ldi	r22, 0x00	; 0
    1d8c:	70 e0       	ldi	r23, 0x00	; 0
    1d8e:	80 91 37 1b 	lds	r24, 0x1B37	; 0x801b37 <xPoseMutex>
    1d92:	90 91 38 1b 	lds	r25, 0x1B38	; 0x801b38 <xPoseMutex+0x1>
    1d96:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
            
            // Experimental
            if ((idleCounter > 10) && (robotMovement == moveStop)){
    1d9a:	9a e0       	ldi	r25, 0x0A	; 10
    1d9c:	9f 15       	cp	r25, r15
    1d9e:	40 f4       	brcc	.+16     	; 0x1db0 <vMainSensorTowerTask+0x150>
    1da0:	89 81       	ldd	r24, Y+1	; 0x01
    1da2:	81 11       	cpse	r24, r1
    1da4:	05 c0       	rjmp	.+10     	; 0x1db0 <vMainSensorTowerTask+0x150>
                // If the robot stands idle for 1 second, send 'status:idle' in case the server missed it.
                send_idle();
    1da6:	0e 94 ff 20 	call	0x41fe	; 0x41fe <send_idle>
                idleCounter = 1;
    1daa:	ff 24       	eor	r15, r15
    1dac:	f3 94       	inc	r15
    1dae:	06 c0       	rjmp	.+12     	; 0x1dbc <vMainSensorTowerTask+0x15c>
            }
            else if ((idleCounter >= 1) && (robotMovement == moveStop)){
    1db0:	ff 20       	and	r15, r15
    1db2:	21 f0       	breq	.+8      	; 0x1dbc <vMainSensorTowerTask+0x15c>
    1db4:	89 81       	ldd	r24, Y+1	; 0x01
    1db6:	81 11       	cpse	r24, r1
    1db8:	01 c0       	rjmp	.+2      	; 0x1dbc <vMainSensorTowerTask+0x15c>
                idleCounter++;
    1dba:	f3 94       	inc	r15
            }             

            // Send updates to server
			
			//[Commented out to decrease messages, ]
            send_update(xhat/10,yhat/10,thetahat*RAD2DEG,servoStep*servoResolution,forwardSensor,leftSensor,rearSensor,rightSensor);
    1dbc:	43 2c       	mov	r4, r3
    1dbe:	51 2c       	mov	r5, r1
    1dc0:	14 9d       	mul	r17, r4
    1dc2:	40 01       	movw	r8, r0
    1dc4:	15 9d       	mul	r17, r5
    1dc6:	90 0c       	add	r9, r0
    1dc8:	11 24       	eor	r1, r1
    1dca:	20 e0       	ldi	r18, 0x00	; 0
    1dcc:	30 e0       	ldi	r19, 0x00	; 0
    1dce:	44 e3       	ldi	r20, 0x34	; 52
    1dd0:	53 e4       	ldi	r21, 0x43	; 67
    1dd2:	6a 85       	ldd	r22, Y+10	; 0x0a
    1dd4:	7b 85       	ldd	r23, Y+11	; 0x0b
    1dd6:	8c 85       	ldd	r24, Y+12	; 0x0c
    1dd8:	9d 85       	ldd	r25, Y+13	; 0x0d
    1dda:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    1dde:	2b ed       	ldi	r18, 0xDB	; 219
    1de0:	3f e0       	ldi	r19, 0x0F	; 15
    1de2:	49 e4       	ldi	r20, 0x49	; 73
    1de4:	50 e4       	ldi	r21, 0x40	; 64
    1de6:	0e 94 22 31 	call	0x6244	; 0x6244 <__divsf3>
    1dea:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
    1dee:	6a 87       	std	Y+10, r22	; 0x0a
    1df0:	7b 87       	std	Y+11, r23	; 0x0b
    1df2:	8c 87       	std	Y+12, r24	; 0x0c
    1df4:	9d 87       	std	Y+13, r25	; 0x0d
    1df6:	c3 01       	movw	r24, r6
    1df8:	6a e0       	ldi	r22, 0x0A	; 10
    1dfa:	70 e0       	ldi	r23, 0x00	; 0
    1dfc:	0e 94 32 37 	call	0x6e64	; 0x6e64 <__divmodhi4>
    1e00:	fb 01       	movw	r30, r22
    1e02:	c5 01       	movw	r24, r10
    1e04:	6a e0       	ldi	r22, 0x0A	; 10
    1e06:	70 e0       	ldi	r23, 0x00	; 0
    1e08:	0e 94 32 37 	call	0x6e64	; 0x6e64 <__divmodhi4>
    1e0c:	cb 01       	movw	r24, r22
    1e0e:	af 84       	ldd	r10, Y+15	; 0x0f
    1e10:	0e 85       	ldd	r16, Y+14	; 0x0e
    1e12:	94 01       	movw	r18, r8
    1e14:	4a 85       	ldd	r20, Y+10	; 0x0a
    1e16:	5b 85       	ldd	r21, Y+11	; 0x0b
    1e18:	bf 01       	movw	r22, r30
    1e1a:	0e 94 bd 20 	call	0x417a	; 0x417a <send_update>
            
            
            // Low level anti collision
            uint8_t objectX;
            if ((servoStep*servoResolution) <= 30) objectX = forwardSensor;// * cos(servoStep*5);
    1e1e:	af e1       	ldi	r26, 0x1F	; 31
    1e20:	8a 16       	cp	r8, r26
    1e22:	91 04       	cpc	r9, r1
    1e24:	34 f0       	brlt	.+12     	; 0x1e32 <vMainSensorTowerTask+0x1d2>
            else if((servoStep*servoResolution) >= 60) objectX = rightSensor;// * cos(270 + servoStep*5);
    1e26:	bc e3       	ldi	r27, 0x3C	; 60
    1e28:	8b 16       	cp	r8, r27
    1e2a:	91 04       	cpc	r9, r1
    1e2c:	c4 f0       	brlt	.+48     	; 0x1e5e <vMainSensorTowerTask+0x1fe>
    1e2e:	af 84       	ldd	r10, Y+15	; 0x0f
    1e30:	ae 86       	std	Y+14, r10	; 0x0e
            else objectX = 0;
            

			
            if ((objectX > 0) && (objectX < 20)){
    1e32:	8e 85       	ldd	r24, Y+14	; 0x0e
    1e34:	81 50       	subi	r24, 0x01	; 1
    1e36:	83 31       	cpi	r24, 0x13	; 19
    1e38:	90 f4       	brcc	.+36     	; 0x1e5e <vMainSensorTowerTask+0x1fe>
                // Stop controller
                struct sPolar Setpoint = {0, 0};
    1e3a:	1c 82       	std	Y+4, r1	; 0x04
    1e3c:	1d 82       	std	Y+5, r1	; 0x05
    1e3e:	1e 82       	std	Y+6, r1	; 0x06
    1e40:	1f 82       	std	Y+7, r1	; 0x07
    1e42:	19 86       	std	Y+9, r1	; 0x09
    1e44:	18 86       	std	Y+8, r1	; 0x08
                xQueueSend(poseControllerQ, &Setpoint, 100);
    1e46:	20 e0       	ldi	r18, 0x00	; 0
    1e48:	44 e6       	ldi	r20, 0x64	; 100
    1e4a:	50 e0       	ldi	r21, 0x00	; 0
    1e4c:	be 01       	movw	r22, r28
    1e4e:	6c 5f       	subi	r22, 0xFC	; 252
    1e50:	7f 4f       	sbci	r23, 0xFF	; 255
    1e52:	80 91 cb 19 	lds	r24, 0x19CB	; 0x8019cb <poseControllerQ>
    1e56:	90 91 cc 19 	lds	r25, 0x19CC	; 0x8019cc <poseControllerQ+0x1>
    1e5a:	0e 94 1f 1b 	call	0x363e	; 0x363e <xQueueGenericSend>
				
				
            }
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
    1e5e:	8b e5       	ldi	r24, 0x5B	; 91
    1e60:	88 16       	cp	r8, r24
    1e62:	91 04       	cpc	r9, r1
    1e64:	94 f4       	brge	.+36     	; 0x1e8a <vMainSensorTowerTask+0x22a>
    1e66:	94 e0       	ldi	r25, 0x04	; 4
    1e68:	d9 12       	cpse	r13, r25
    1e6a:	0f c0       	rjmp	.+30     	; 0x1e8a <vMainSensorTowerTask+0x22a>
    1e6c:	89 81       	ldd	r24, Y+1	; 0x01
    1e6e:	83 30       	cpi	r24, 0x03	; 3
    1e70:	e8 f4       	brcc	.+58     	; 0x1eac <vMainSensorTowerTask+0x24c>
                servoStep++;
    1e72:	1f 5f       	subi	r17, 0xFF	; 255
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1e74:	14 9d       	mul	r17, r4
    1e76:	40 01       	movw	r8, r0
    1e78:	15 9d       	mul	r17, r5
    1e7a:	90 0c       	add	r9, r0
    1e7c:	11 24       	eor	r1, r1
    1e7e:	aa e5       	ldi	r26, 0x5A	; 90
    1e80:	8a 16       	cp	r8, r26
    1e82:	91 04       	cpc	r9, r1
    1e84:	0c f0       	brlt	.+2      	; 0x1e88 <vMainSensorTowerTask+0x228>
    1e86:	02 cf       	rjmp	.-508    	; 0x1c8c <vMainSensorTowerTask+0x2c>
    1e88:	1b c0       	rjmp	.+54     	; 0x1ec0 <vMainSensorTowerTask+0x260>
            
            // Iterate in a increasing/decreasing manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1e8a:	18 14       	cp	r1, r8
    1e8c:	19 04       	cpc	r1, r9
    1e8e:	8c f5       	brge	.+98     	; 0x1ef2 <vMainSensorTowerTask+0x292>
    1e90:	b3 e0       	ldi	r27, 0x03	; 3
    1e92:	db 12       	cpse	r13, r27
    1e94:	29 c0       	rjmp	.+82     	; 0x1ee8 <vMainSensorTowerTask+0x288>
    1e96:	89 81       	ldd	r24, Y+1	; 0x01
    1e98:	83 30       	cpi	r24, 0x03	; 3
    1e9a:	08 f0       	brcs	.+2      	; 0x1e9e <vMainSensorTowerTask+0x23e>
    1e9c:	0a cf       	rjmp	.-492    	; 0x1cb2 <vMainSensorTowerTask+0x52>
                servoStep --;
    1e9e:	11 50       	subi	r17, 0x01	; 1
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1ea0:	14 9d       	mul	r17, r4
    1ea2:	40 01       	movw	r8, r0
    1ea4:	15 9d       	mul	r17, r5
    1ea6:	90 0c       	add	r9, r0
    1ea8:	11 24       	eor	r1, r1
    1eaa:	0a c0       	rjmp	.+20     	; 0x1ec0 <vMainSensorTowerTask+0x260>
    1eac:	8a e5       	ldi	r24, 0x5A	; 90
    1eae:	88 16       	cp	r8, r24
    1eb0:	91 04       	cpc	r9, r1
    1eb2:	0c f0       	brlt	.+2      	; 0x1eb6 <vMainSensorTowerTask+0x256>
    1eb4:	f0 ce       	rjmp	.-544    	; 0x1c96 <vMainSensorTowerTask+0x36>
    1eb6:	04 c0       	rjmp	.+8      	; 0x1ec0 <vMainSensorTowerTask+0x260>
    1eb8:	94 e0       	ldi	r25, 0x04	; 4
    1eba:	d9 16       	cp	r13, r25
    1ebc:	09 f4       	brne	.+2      	; 0x1ec0 <vMainSensorTowerTask+0x260>
    1ebe:	f0 ce       	rjmp	.-544    	; 0x1ca0 <vMainSensorTowerTask+0x40>
                rotationDirection = moveClockwise;
            }
            else if ((servoStep*servoResolution <= 0) && (rotationDirection == moveClockwise)){
    1ec0:	18 14       	cp	r1, r8
    1ec2:	19 04       	cpc	r1, r9
    1ec4:	0c f4       	brge	.+2      	; 0x1ec8 <vMainSensorTowerTask+0x268>
    1ec6:	f5 ce       	rjmp	.-534    	; 0x1cb2 <vMainSensorTowerTask+0x52>
    1ec8:	a3 e0       	ldi	r26, 0x03	; 3
    1eca:	da 12       	cpse	r13, r26
    1ecc:	f2 ce       	rjmp	.-540    	; 0x1cb2 <vMainSensorTowerTask+0x52>
                rotationDirection = moveCounterClockwise;
    1ece:	d2 2c       	mov	r13, r2
    1ed0:	f0 ce       	rjmp	.-544    	; 0x1cb2 <vMainSensorTowerTask+0x52>
            }
            
            vTaskDelay(200 / portTICK_PERIOD_MS);
        */
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
    1ed2:	80 e0       	ldi	r24, 0x00	; 0
    1ed4:	0e 94 84 21 	call	0x4308	; 0x4308 <vServo_setAngle>
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
            vTaskDelay(100/portTICK_PERIOD_MS);
    1ed8:	84 e6       	ldi	r24, 0x64	; 100
    1eda:	90 e0       	ldi	r25, 0x00	; 0
    1edc:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <vTaskDelay>
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
    1ee0:	f1 2c       	mov	r15, r1
        */
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
    1ee2:	10 e0       	ldi	r17, 0x00	; 0
            vTaskDelay(200 / portTICK_PERIOD_MS);
        */
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1ee4:	d2 2c       	mov	r13, r2
    1ee6:	e5 ce       	rjmp	.-566    	; 0x1cb2 <vMainSensorTowerTask+0x52>
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1ee8:	ba e5       	ldi	r27, 0x5A	; 90
    1eea:	8b 16       	cp	r8, r27
    1eec:	91 04       	cpc	r9, r1
    1eee:	24 f7       	brge	.-56     	; 0x1eb8 <vMainSensorTowerTask+0x258>
    1ef0:	e0 ce       	rjmp	.-576    	; 0x1cb2 <vMainSensorTowerTask+0x52>
    1ef2:	8a e5       	ldi	r24, 0x5A	; 90
    1ef4:	88 16       	cp	r8, r24
    1ef6:	91 04       	cpc	r9, r1
    1ef8:	3c f3       	brlt	.-50     	; 0x1ec8 <vMainSensorTowerTask+0x268>
    1efa:	94 e0       	ldi	r25, 0x04	; 4
    1efc:	d9 12       	cpse	r13, r25
    1efe:	e4 cf       	rjmp	.-56     	; 0x1ec8 <vMainSensorTowerTask+0x268>
    1f00:	d4 ce       	rjmp	.-600    	; 0x1caa <vMainSensorTowerTask+0x4a>

00001f02 <vMainPoseControllerTask>:
        }
    }// While end
}

/*  Calculates new settings for the movement task */
void vMainPoseControllerTask( void *pvParameters ){
    1f02:	cf 93       	push	r28
    1f04:	df 93       	push	r29
    1f06:	cd b7       	in	r28, 0x3d	; 61
    1f08:	de b7       	in	r29, 0x3e	; 62
    1f0a:	ab 97       	sbiw	r28, 0x2b	; 43
    1f0c:	0f b6       	in	r0, 0x3f	; 63
    1f0e:	f8 94       	cli
    1f10:	de bf       	out	0x3e, r29	; 62
    1f12:	0f be       	out	0x3f, r0	; 63
    1f14:	cd bf       	out	0x3d, r28	; 61
    #ifdef DEBUG
        printf("PoseController OK\n");
        uint8_t tellar = 0;
    #endif
    /* Task init */    
    struct sPolar Setpoint = {0}; // Updates from server
    1f16:	fe 01       	movw	r30, r28
    1f18:	31 96       	adiw	r30, 0x01	; 1
    1f1a:	86 e0       	ldi	r24, 0x06	; 6
    1f1c:	df 01       	movw	r26, r30
    1f1e:	1d 92       	st	X+, r1
    1f20:	8a 95       	dec	r24
    1f22:	e9 f7       	brne	.-6      	; 0x1f1e <vMainPoseControllerTask+0x1c>
    struct sCartesian Error = {0}; // Error values
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
	float radiusEpsilon = 30; //[mm]The acceptable radius from goal for completion
	uint8_t lastMovement = 0;
    1f24:	1f 82       	std	Y+7, r1	; 0x07
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
	
	
	int16_t leftWheelTicks = 0;
    1f26:	19 86       	std	Y+9, r1	; 0x09
    1f28:	18 86       	std	Y+8, r1	; 0x08
	int16_t rightWheelTicks = 0;
    1f2a:	1b 86       	std	Y+11, r1	; 0x0b
    1f2c:	1a 86       	std	Y+10, r1	; 0x0a
	
	uint8_t leftEncoderVal = 0;
	uint8_t rightEncoderVal = 0;
	
	uint8_t gLeftWheelDirection = 0;
    1f2e:	1c 86       	std	Y+12, r1	; 0x0c
	uint8_t gRightWheelDirection = 0;
    1f30:	1d 86       	std	Y+13, r1	; 0x0d
	
	uint8_t idleSendt = FALSE;
    1f32:	1a 8e       	std	Y+26, r1	; 0x1a
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
    1f34:	b1 e0       	ldi	r27, 0x01	; 1
    1f36:	bb a7       	std	Y+43, r27	; 0x2b
	float yTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
    1f38:	1f a2       	std	Y+39, r1	; 0x27
    1f3a:	18 a6       	std	Y+40, r1	; 0x28
    1f3c:	19 a6       	std	Y+41, r1	; 0x29
    1f3e:	1a a6       	std	Y+42, r1	; 0x2a
	float xTargt = 0;
	float yTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
    1f40:	1b a2       	std	Y+35, r1	; 0x23
    1f42:	1c a2       	std	Y+36, r1	; 0x24
    1f44:	1d a2       	std	Y+37, r1	; 0x25
    1f46:	1e a2       	std	Y+38, r1	; 0x26
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
	float yTargt = 0;
    1f48:	1f 8e       	std	Y+31, r1	; 0x1f
    1f4a:	18 a2       	std	Y+32, r1	; 0x20
    1f4c:	19 a2       	std	Y+33, r1	; 0x21
    1f4e:	1a a2       	std	Y+34, r1	; 0x22
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
    1f50:	1b 8e       	std	Y+27, r1	; 0x1b
    1f52:	1c 8e       	std	Y+28, r1	; 0x1c
    1f54:	1d 8e       	std	Y+29, r1	; 0x1d
    1f56:	1e 8e       	std	Y+30, r1	; 0x1e
	
	
      
	while(1){
		// Checking if server is ready
		if (gHandshook){
    1f58:	80 91 c4 19 	lds	r24, 0x19C4	; 0x8019c4 <gHandshook>
    1f5c:	88 23       	and	r24, r24
    1f5e:	e1 f3       	breq	.-8      	; 0x1f58 <vMainPoseControllerTask+0x56>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1f60:	f8 94       	cli
			
			
			
			ATOMIC_BLOCK(ATOMIC_FORCEON){
				leftEncoderVal = gISR_leftWheelTicks;
    1f62:	40 91 c5 19 	lds	r20, 0x19C5	; 0x8019c5 <gISR_leftWheelTicks>
				gISR_leftWheelTicks = 0;
    1f66:	10 92 c5 19 	sts	0x19C5, r1	; 0x8019c5 <gISR_leftWheelTicks>
				rightEncoderVal = gISR_rightWheelTicks;
    1f6a:	10 91 c6 19 	lds	r17, 0x19C6	; 0x8019c6 <gISR_rightWheelTicks>
				gISR_rightWheelTicks = 0;
    1f6e:	10 92 c6 19 	sts	0x19C6, r1	; 0x8019c6 <gISR_rightWheelTicks>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1f72:	78 94       	sei
			
			
			
			
			
			vMotorEncoderLeftTickFromISR(gLeftWheelDirection, &leftWheelTicks, leftEncoderVal);
    1f74:	be 01       	movw	r22, r28
    1f76:	68 5f       	subi	r22, 0xF8	; 248
    1f78:	7f 4f       	sbci	r23, 0xFF	; 255
    1f7a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1f7c:	ef d6       	rcall	.+3550   	; 0x2d5c <vMotorEncoderLeftTickFromISR>
			vMotorEncoderRightTickFromISR(gRightWheelDirection, &rightWheelTicks, rightEncoderVal);
    1f7e:	41 2f       	mov	r20, r17
    1f80:	be 01       	movw	r22, r28
    1f82:	66 5f       	subi	r22, 0xF6	; 246
    1f84:	7f 4f       	sbci	r23, 0xFF	; 255
    1f86:	8d 85       	ldd	r24, Y+13	; 0x0d
    1f88:	00 d7       	rcall	.+3584   	; 0x2d8a <vMotorEncoderRightTickFromISR>
			
			xSemaphoreTake(xTickMutex,1 / portTICK_PERIOD_MS);
    1f8a:	20 e0       	ldi	r18, 0x00	; 0
    1f8c:	41 e0       	ldi	r20, 0x01	; 1
    1f8e:	50 e0       	ldi	r21, 0x00	; 0
    1f90:	60 e0       	ldi	r22, 0x00	; 0
    1f92:	70 e0       	ldi	r23, 0x00	; 0
    1f94:	80 91 31 1b 	lds	r24, 0x1B31	; 0x801b31 <xTickMutex>
    1f98:	90 91 32 1b 	lds	r25, 0x1B32	; 0x801b32 <xTickMutex+0x1>
    1f9c:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
			gLeftWheelTicks = leftWheelTicks;
    1fa0:	88 85       	ldd	r24, Y+8	; 0x08
    1fa2:	99 85       	ldd	r25, Y+9	; 0x09
    1fa4:	90 93 b8 19 	sts	0x19B8, r25	; 0x8019b8 <gLeftWheelTicks+0x1>
    1fa8:	80 93 b7 19 	sts	0x19B7, r24	; 0x8019b7 <gLeftWheelTicks>
			gRightWheelTicks = rightWheelTicks;
    1fac:	8a 85       	ldd	r24, Y+10	; 0x0a
    1fae:	9b 85       	ldd	r25, Y+11	; 0x0b
    1fb0:	90 93 ba 19 	sts	0x19BA, r25	; 0x8019ba <gRightWheelTicks+0x1>
    1fb4:	80 93 b9 19 	sts	0x19B9, r24	; 0x8019b9 <gRightWheelTicks>
			xSemaphoreGive(xTickMutex);
    1fb8:	60 e0       	ldi	r22, 0x00	; 0
    1fba:	70 e0       	ldi	r23, 0x00	; 0
    1fbc:	80 91 31 1b 	lds	r24, 0x1B31	; 0x801b31 <xTickMutex>
    1fc0:	90 91 32 1b 	lds	r25, 0x1B32	; 0x801b32 <xTickMutex+0x1>
    1fc4:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
			
			
			
			
			
			if (xSemaphoreTake(xControllerBSem, portMAX_DELAY) == pdTRUE){    // Wait for synchronization from estimator
    1fc8:	20 e0       	ldi	r18, 0x00	; 0
    1fca:	4f ef       	ldi	r20, 0xFF	; 255
    1fcc:	5f ef       	ldi	r21, 0xFF	; 255
    1fce:	60 e0       	ldi	r22, 0x00	; 0
    1fd0:	70 e0       	ldi	r23, 0x00	; 0
    1fd2:	80 91 2f 1b 	lds	r24, 0x1B2F	; 0x801b2f <xControllerBSem>
    1fd6:	90 91 30 1b 	lds	r25, 0x1B30	; 0x801b30 <xControllerBSem+0x1>
    1fda:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
    1fde:	81 30       	cpi	r24, 0x01	; 1
    1fe0:	09 f0       	breq	.+2      	; 0x1fe4 <vMainPoseControllerTask+0xe2>
    1fe2:	ba cf       	rjmp	.-140    	; 0x1f58 <vMainPoseControllerTask+0x56>
				// Get robot pose
				xSemaphoreTake(xPoseMutex,portMAX_DELAY);
    1fe4:	20 e0       	ldi	r18, 0x00	; 0
    1fe6:	4f ef       	ldi	r20, 0xFF	; 255
    1fe8:	5f ef       	ldi	r21, 0xFF	; 255
    1fea:	60 e0       	ldi	r22, 0x00	; 0
    1fec:	70 e0       	ldi	r23, 0x00	; 0
    1fee:	80 91 37 1b 	lds	r24, 0x1B37	; 0x801b37 <xPoseMutex>
    1ff2:	90 91 38 1b 	lds	r25, 0x1B38	; 0x801b38 <xPoseMutex+0x1>
    1ff6:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
					thetahat = gTheta_hat;
    1ffa:	40 90 bf 19 	lds	r4, 0x19BF	; 0x8019bf <gTheta_hat>
    1ffe:	50 90 c0 19 	lds	r5, 0x19C0	; 0x8019c0 <gTheta_hat+0x1>
    2002:	60 90 c1 19 	lds	r6, 0x19C1	; 0x8019c1 <gTheta_hat+0x2>
    2006:	70 90 c2 19 	lds	r7, 0x19C2	; 0x8019c2 <gTheta_hat+0x3>
					xhat = gX_hat;
    200a:	00 91 bd 19 	lds	r16, 0x19BD	; 0x8019bd <gX_hat>
    200e:	10 91 be 19 	lds	r17, 0x19BE	; 0x8019be <gX_hat+0x1>
					yhat = gY_hat;
    2012:	20 90 bb 19 	lds	r2, 0x19BB	; 0x8019bb <gY_hat>
    2016:	30 90 bc 19 	lds	r3, 0x19BC	; 0x8019bc <gY_hat+0x1>
				xSemaphoreGive(xPoseMutex);
    201a:	60 e0       	ldi	r22, 0x00	; 0
    201c:	70 e0       	ldi	r23, 0x00	; 0
    201e:	80 91 37 1b 	lds	r24, 0x1B37	; 0x801b37 <xPoseMutex>
    2022:	90 91 38 1b 	lds	r25, 0x1B38	; 0x801b38 <xPoseMutex+0x1>
    2026:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
				
				// Check if a new update is received
				if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
    202a:	20 e0       	ldi	r18, 0x00	; 0
    202c:	40 e0       	ldi	r20, 0x00	; 0
    202e:	50 e0       	ldi	r21, 0x00	; 0
    2030:	be 01       	movw	r22, r28
    2032:	6f 5f       	subi	r22, 0xFF	; 255
    2034:	7f 4f       	sbci	r23, 0xFF	; 255
    2036:	80 91 cb 19 	lds	r24, 0x19CB	; 0x8019cb <poseControllerQ>
    203a:	90 91 cc 19 	lds	r25, 0x19CC	; 0x8019cc <poseControllerQ+0x1>
    203e:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
    2042:	81 30       	cpi	r24, 0x01	; 1
    2044:	09 f0       	breq	.+2      	; 0x2048 <vMainPoseControllerTask+0x146>
    2046:	73 c0       	rjmp	.+230    	; 0x212e <vMainPoseControllerTask+0x22c>
					xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
    2048:	20 e0       	ldi	r18, 0x00	; 0
    204a:	44 e1       	ldi	r20, 0x14	; 20
    204c:	50 e0       	ldi	r21, 0x00	; 0
    204e:	be 01       	movw	r22, r28
    2050:	6f 5f       	subi	r22, 0xFF	; 255
    2052:	7f 4f       	sbci	r23, 0xFF	; 255
    2054:	80 91 cb 19 	lds	r24, 0x19CB	; 0x8019cb <poseControllerQ>
    2058:	90 91 cc 19 	lds	r25, 0x19CC	; 0x8019cc <poseControllerQ+0x1>
    205c:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
					Setpoint.distance = Setpoint.distance*10; //Distance is received in cm, convert to mm for continuity
    2060:	8d 81       	ldd	r24, Y+5	; 0x05
    2062:	9e 81       	ldd	r25, Y+6	; 0x06
    2064:	bc 01       	movw	r22, r24
    2066:	66 0f       	add	r22, r22
    2068:	77 1f       	adc	r23, r23
    206a:	88 0f       	add	r24, r24
    206c:	99 1f       	adc	r25, r25
    206e:	88 0f       	add	r24, r24
    2070:	99 1f       	adc	r25, r25
    2072:	88 0f       	add	r24, r24
    2074:	99 1f       	adc	r25, r25
    2076:	68 0f       	add	r22, r24
    2078:	79 1f       	adc	r23, r25
    207a:	7e 83       	std	Y+6, r23	; 0x06
    207c:	6d 83       	std	Y+5, r22	; 0x05
					
					
					
					xTargt = xhat + Setpoint.distance*cos(Setpoint.heading + thetahat);
    207e:	07 2e       	mov	r0, r23
    2080:	00 0c       	add	r0, r0
    2082:	88 0b       	sbc	r24, r24
    2084:	99 0b       	sbc	r25, r25
    2086:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    208a:	6a 8b       	std	Y+18, r22	; 0x12
    208c:	7b 8b       	std	Y+19, r23	; 0x13
    208e:	8c 8b       	std	Y+20, r24	; 0x14
    2090:	9d 8b       	std	Y+21, r25	; 0x15
    2092:	29 81       	ldd	r18, Y+1	; 0x01
    2094:	3a 81       	ldd	r19, Y+2	; 0x02
    2096:	4b 81       	ldd	r20, Y+3	; 0x03
    2098:	5c 81       	ldd	r21, Y+4	; 0x04
    209a:	c3 01       	movw	r24, r6
    209c:	b2 01       	movw	r22, r4
    209e:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    20a2:	6b 01       	movw	r12, r22
    20a4:	7c 01       	movw	r14, r24
    20a6:	0e 94 1f 31 	call	0x623e	; 0x623e <cos>
    20aa:	6e 8b       	std	Y+22, r22	; 0x16
    20ac:	7f 8b       	std	Y+23, r23	; 0x17
    20ae:	88 8f       	std	Y+24, r24	; 0x18
    20b0:	99 8f       	std	Y+25, r25	; 0x19
    20b2:	b8 01       	movw	r22, r16
    20b4:	01 2e       	mov	r0, r17
    20b6:	00 0c       	add	r0, r0
    20b8:	88 0b       	sbc	r24, r24
    20ba:	99 0b       	sbc	r25, r25
    20bc:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    20c0:	4b 01       	movw	r8, r22
    20c2:	5c 01       	movw	r10, r24
    20c4:	2e 89       	ldd	r18, Y+22	; 0x16
    20c6:	3f 89       	ldd	r19, Y+23	; 0x17
    20c8:	48 8d       	ldd	r20, Y+24	; 0x18
    20ca:	59 8d       	ldd	r21, Y+25	; 0x19
    20cc:	6a 89       	ldd	r22, Y+18	; 0x12
    20ce:	7b 89       	ldd	r23, Y+19	; 0x13
    20d0:	8c 89       	ldd	r24, Y+20	; 0x14
    20d2:	9d 89       	ldd	r25, Y+21	; 0x15
    20d4:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    20d8:	9b 01       	movw	r18, r22
    20da:	ac 01       	movw	r20, r24
    20dc:	c5 01       	movw	r24, r10
    20de:	b4 01       	movw	r22, r8
    20e0:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    20e4:	6b 8f       	std	Y+27, r22	; 0x1b
    20e6:	7c 8f       	std	Y+28, r23	; 0x1c
    20e8:	8d 8f       	std	Y+29, r24	; 0x1d
    20ea:	9e 8f       	std	Y+30, r25	; 0x1e
					yTargt = yhat + Setpoint.distance*sin(Setpoint.heading + thetahat);
    20ec:	c7 01       	movw	r24, r14
    20ee:	b6 01       	movw	r22, r12
    20f0:	0e 94 39 33 	call	0x6672	; 0x6672 <sin>
    20f4:	4b 01       	movw	r8, r22
    20f6:	5c 01       	movw	r10, r24
    20f8:	b1 01       	movw	r22, r2
    20fa:	03 2c       	mov	r0, r3
    20fc:	00 0c       	add	r0, r0
    20fe:	88 0b       	sbc	r24, r24
    2100:	99 0b       	sbc	r25, r25
    2102:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    2106:	6b 01       	movw	r12, r22
    2108:	7c 01       	movw	r14, r24
    210a:	a5 01       	movw	r20, r10
    210c:	94 01       	movw	r18, r8
    210e:	6a 89       	ldd	r22, Y+18	; 0x12
    2110:	7b 89       	ldd	r23, Y+19	; 0x13
    2112:	8c 89       	ldd	r24, Y+20	; 0x14
    2114:	9d 89       	ldd	r25, Y+21	; 0x15
    2116:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    211a:	9b 01       	movw	r18, r22
    211c:	ac 01       	movw	r20, r24
    211e:	c7 01       	movw	r24, r14
    2120:	b6 01       	movw	r22, r12
    2122:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    2126:	6f 8f       	std	Y+31, r22	; 0x1f
    2128:	78 a3       	std	Y+32, r23	; 0x20
    212a:	89 a3       	std	Y+33, r24	; 0x21
    212c:	9a a3       	std	Y+34, r25	; 0x22
					//Debug
					
				
				}
				
				distance = (float)sqrt((xTargt-xhat)*(xTargt-xhat) + (yTargt-yhat)*(yTargt-yhat));
    212e:	b8 01       	movw	r22, r16
    2130:	11 0f       	add	r17, r17
    2132:	88 0b       	sbc	r24, r24
    2134:	99 0b       	sbc	r25, r25
    2136:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    213a:	9b 01       	movw	r18, r22
    213c:	ac 01       	movw	r20, r24
    213e:	6b 8d       	ldd	r22, Y+27	; 0x1b
    2140:	7c 8d       	ldd	r23, Y+28	; 0x1c
    2142:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2144:	9e 8d       	ldd	r25, Y+30	; 0x1e
    2146:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    214a:	6a 8b       	std	Y+18, r22	; 0x12
    214c:	7b 8b       	std	Y+19, r23	; 0x13
    214e:	8c 8b       	std	Y+20, r24	; 0x14
    2150:	9d 8b       	std	Y+21, r25	; 0x15
    2152:	b1 01       	movw	r22, r2
    2154:	33 0c       	add	r3, r3
    2156:	88 0b       	sbc	r24, r24
    2158:	99 0b       	sbc	r25, r25
    215a:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    215e:	9b 01       	movw	r18, r22
    2160:	ac 01       	movw	r20, r24
    2162:	6f 8d       	ldd	r22, Y+31	; 0x1f
    2164:	78 a1       	ldd	r23, Y+32	; 0x20
    2166:	89 a1       	ldd	r24, Y+33	; 0x21
    2168:	9a a1       	ldd	r25, Y+34	; 0x22
    216a:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    216e:	6b 01       	movw	r12, r22
    2170:	7c 01       	movw	r14, r24
    2172:	2a 89       	ldd	r18, Y+18	; 0x12
    2174:	3b 89       	ldd	r19, Y+19	; 0x13
    2176:	4c 89       	ldd	r20, Y+20	; 0x14
    2178:	5d 89       	ldd	r21, Y+21	; 0x15
    217a:	ca 01       	movw	r24, r20
    217c:	b9 01       	movw	r22, r18
    217e:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2182:	4b 01       	movw	r8, r22
    2184:	5c 01       	movw	r10, r24
    2186:	a7 01       	movw	r20, r14
    2188:	96 01       	movw	r18, r12
    218a:	c7 01       	movw	r24, r14
    218c:	b6 01       	movw	r22, r12
    218e:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2192:	6e 8b       	std	Y+22, r22	; 0x16
    2194:	7f 8b       	std	Y+23, r23	; 0x17
    2196:	88 8f       	std	Y+24, r24	; 0x18
    2198:	99 8f       	std	Y+25, r25	; 0x19
    219a:	2e 89       	ldd	r18, Y+22	; 0x16
    219c:	3f 89       	ldd	r19, Y+23	; 0x17
    219e:	48 8d       	ldd	r20, Y+24	; 0x18
    21a0:	59 8d       	ldd	r21, Y+25	; 0x19
    21a2:	c5 01       	movw	r24, r10
    21a4:	b4 01       	movw	r22, r8
    21a6:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    21aa:	0e 94 43 33 	call	0x6686	; 0x6686 <sqrt>
    21ae:	4b 01       	movw	r8, r22
    21b0:	5c 01       	movw	r10, r24
				
				//Simple speed controller as the robot nears the target
				if (distance < speedDecreaseThreshold){
    21b2:	20 e0       	ldi	r18, 0x00	; 0
    21b4:	30 e0       	ldi	r19, 0x00	; 0
    21b6:	46 e1       	ldi	r20, 0x16	; 22
    21b8:	53 e4       	ldi	r21, 0x43	; 67
    21ba:	0e 94 1b 31 	call	0x6236	; 0x6236 <__cmpsf2>
    21be:	88 23       	and	r24, r24
    21c0:	c4 f4       	brge	.+48     	; 0x21f2 <vMainPoseControllerTask+0x2f0>
					currentDriveActuation = (maxDriveActuation - 0.15*maxDriveActuation)*distance/speedDecreaseThreshold + 0.15*maxDriveActuation; //Reverse proportional + a constant so it reaches. 
    21c2:	20 e0       	ldi	r18, 0x00	; 0
    21c4:	30 e0       	ldi	r19, 0x00	; 0
    21c6:	4a e2       	ldi	r20, 0x2A	; 42
    21c8:	53 e4       	ldi	r21, 0x43	; 67
    21ca:	c5 01       	movw	r24, r10
    21cc:	b4 01       	movw	r22, r8
    21ce:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    21d2:	20 e0       	ldi	r18, 0x00	; 0
    21d4:	30 e0       	ldi	r19, 0x00	; 0
    21d6:	46 e1       	ldi	r20, 0x16	; 22
    21d8:	53 e4       	ldi	r21, 0x43	; 67
    21da:	0e 94 22 31 	call	0x6244	; 0x6244 <__divsf3>
    21de:	21 e0       	ldi	r18, 0x01	; 1
    21e0:	30 e0       	ldi	r19, 0x00	; 0
    21e2:	40 ef       	ldi	r20, 0xF0	; 240
    21e4:	51 e4       	ldi	r21, 0x41	; 65
    21e6:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    21ea:	0e 94 8f 31 	call	0x631e	; 0x631e <__fixunssfsi>
    21ee:	06 2f       	mov	r16, r22
    21f0:	01 c0       	rjmp	.+2      	; 0x21f4 <vMainPoseControllerTask+0x2f2>
				}else{
					currentDriveActuation = maxDriveActuation;
    21f2:	08 ec       	ldi	r16, 0xC8	; 200
				}
				
				
				
				if(distance > radiusEpsilon){//Not close enough to target
    21f4:	20 e0       	ldi	r18, 0x00	; 0
    21f6:	30 e0       	ldi	r19, 0x00	; 0
    21f8:	40 ef       	ldi	r20, 0xF0	; 240
    21fa:	51 e4       	ldi	r21, 0x41	; 65
    21fc:	c5 01       	movw	r24, r10
    21fe:	b4 01       	movw	r22, r8
    2200:	0e 94 cb 32 	call	0x6596	; 0x6596 <__gesf2>
    2204:	18 16       	cp	r1, r24
    2206:	0c f0       	brlt	.+2      	; 0x220a <__stack+0xb>
    2208:	4e c1       	rjmp	.+668    	; 0x24a6 <__stack+0x2a7>
					
					idleSendt = FALSE;
					
					float xdiff = xTargt - xhat;
					float ydiff = yTargt - yhat;
					float thetaTargt = atan2(ydiff,xdiff); //atan() returns radians
    220a:	2a 89       	ldd	r18, Y+18	; 0x12
    220c:	3b 89       	ldd	r19, Y+19	; 0x13
    220e:	4c 89       	ldd	r20, Y+20	; 0x14
    2210:	5d 89       	ldd	r21, Y+21	; 0x15
    2212:	c7 01       	movw	r24, r14
    2214:	b6 01       	movw	r22, r12
    2216:	0e 94 c8 30 	call	0x6190	; 0x6190 <atan2>
					float thetaDiff = thetaTargt-thetahat; //Might be outside pi to -pi degrees
    221a:	a3 01       	movw	r20, r6
    221c:	92 01       	movw	r18, r4
    221e:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    2222:	6e 87       	std	Y+14, r22	; 0x0e
    2224:	7f 87       	std	Y+15, r23	; 0x0f
    2226:	88 8b       	std	Y+16, r24	; 0x10
    2228:	99 8b       	std	Y+17, r25	; 0x11
					vFunc_Inf2pi(&thetaDiff);
    222a:	ce 01       	movw	r24, r28
    222c:	0e 96       	adiw	r24, 0x0e	; 14
    222e:	0e 94 4a 08 	call	0x1094	; 0x1094 <vFunc_Inf2pi>
					
					
					
					//Hysteresis mechanics
					if (fabs(thetaDiff) > rotateThreshold){
    2232:	4e 84       	ldd	r4, Y+14	; 0x0e
    2234:	5f 84       	ldd	r5, Y+15	; 0x0f
    2236:	68 88       	ldd	r6, Y+16	; 0x10
    2238:	79 88       	ldd	r7, Y+17	; 0x11
    223a:	53 01       	movw	r10, r6
    223c:	42 01       	movw	r8, r4
    223e:	e8 94       	clt
    2240:	b7 f8       	bld	r11, 7
    2242:	29 e1       	ldi	r18, 0x19	; 25
    2244:	34 e0       	ldi	r19, 0x04	; 4
    2246:	46 e0       	ldi	r20, 0x06	; 6
    2248:	5f e3       	ldi	r21, 0x3F	; 63
    224a:	c5 01       	movw	r24, r10
    224c:	b4 01       	movw	r22, r8
    224e:	0e 94 cb 32 	call	0x6596	; 0x6596 <__gesf2>
    2252:	18 16       	cp	r1, r24
    2254:	0c f4       	brge	.+2      	; 0x2258 <__stack+0x59>
    2256:	ac c0       	rjmp	.+344    	; 0x23b0 <__stack+0x1b1>
						doneTurning = FALSE;
						
					}else if (fabs(thetaDiff) < driveThreshold){
    2258:	22 e7       	ldi	r18, 0x72	; 114
    225a:	3a e8       	ldi	r19, 0x8A	; 138
    225c:	4e e8       	ldi	r20, 0x8E	; 142
    225e:	5c e3       	ldi	r21, 0x3C	; 60
    2260:	c5 01       	movw	r24, r10
    2262:	b4 01       	movw	r22, r8
    2264:	0e 94 1b 31 	call	0x6236	; 0x6236 <__cmpsf2>
    2268:	88 23       	and	r24, r24
    226a:	24 f0       	brlt	.+8      	; 0x2274 <__stack+0x75>
					}
					
					int16_t LSpeed = 0;
					int16_t RSpeed = 0;
					
					if (doneTurning){//Start forward movement
    226c:	8b a5       	ldd	r24, Y+43	; 0x2b
    226e:	81 11       	cpse	r24, r1
    2270:	03 c0       	rjmp	.+6      	; 0x2278 <__stack+0x79>
    2272:	9e c0       	rjmp	.+316    	; 0x23b0 <__stack+0x1b1>
					//Hysteresis mechanics
					if (fabs(thetaDiff) > rotateThreshold){
						doneTurning = FALSE;
						
					}else if (fabs(thetaDiff) < driveThreshold){
						doneTurning = TRUE;
    2274:	a1 e0       	ldi	r26, 0x01	; 1
    2276:	ab a7       	std	Y+43, r26	; 0x2b
					
					int16_t LSpeed = 0;
					int16_t RSpeed = 0;
					
					if (doneTurning){//Start forward movement
						if (thetaDiff >= 0){//Moving left
    2278:	20 e0       	ldi	r18, 0x00	; 0
    227a:	30 e0       	ldi	r19, 0x00	; 0
    227c:	a9 01       	movw	r20, r18
    227e:	c3 01       	movw	r24, r6
    2280:	b2 01       	movw	r22, r4
    2282:	0e 94 cb 32 	call	0x6596	; 0x6596 <__gesf2>
    2286:	88 23       	and	r24, r24
    2288:	bc f1       	brlt	.+110    	; 0x22f8 <__stack+0xf9>
							LSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*leftIntError; //Simple PI controller for theta 
    228a:	10 e0       	ldi	r17, 0x00	; 0
    228c:	b8 01       	movw	r22, r16
    228e:	01 2e       	mov	r0, r17
    2290:	00 0c       	add	r0, r0
    2292:	88 0b       	sbc	r24, r24
    2294:	99 0b       	sbc	r25, r25
    2296:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    229a:	6b 01       	movw	r12, r22
    229c:	7c 01       	movw	r14, r24
    229e:	20 e0       	ldi	r18, 0x00	; 0
    22a0:	30 e0       	ldi	r19, 0x00	; 0
    22a2:	46 e1       	ldi	r20, 0x16	; 22
    22a4:	54 e4       	ldi	r21, 0x44	; 68
    22a6:	c5 01       	movw	r24, r10
    22a8:	b4 01       	movw	r22, r8
    22aa:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    22ae:	9b 01       	movw	r18, r22
    22b0:	ac 01       	movw	r20, r24
    22b2:	c7 01       	movw	r24, r14
    22b4:	b6 01       	movw	r22, r12
    22b6:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    22ba:	6b 01       	movw	r12, r22
    22bc:	7c 01       	movw	r14, r24
    22be:	20 e0       	ldi	r18, 0x00	; 0
    22c0:	30 e0       	ldi	r19, 0x00	; 0
    22c2:	40 e2       	ldi	r20, 0x20	; 32
    22c4:	51 e4       	ldi	r21, 0x41	; 65
    22c6:	6b a1       	ldd	r22, Y+35	; 0x23
    22c8:	7c a1       	ldd	r23, Y+36	; 0x24
    22ca:	8d a1       	ldd	r24, Y+37	; 0x25
    22cc:	9e a1       	ldd	r25, Y+38	; 0x26
    22ce:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    22d2:	9b 01       	movw	r18, r22
    22d4:	ac 01       	movw	r20, r24
    22d6:	c7 01       	movw	r24, r14
    22d8:	b6 01       	movw	r22, r12
    22da:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    22de:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
							
							//Saturation
							if (LSpeed > currentDriveActuation){
    22e2:	06 17       	cp	r16, r22
    22e4:	17 07       	cpc	r17, r23
    22e6:	0c f4       	brge	.+2      	; 0x22ea <__stack+0xeb>
    22e8:	41 c0       	rjmp	.+130    	; 0x236c <__stack+0x16d>
    22ea:	7b 01       	movw	r14, r22
    22ec:	77 23       	and	r23, r23
    22ee:	0c f0       	brlt	.+2      	; 0x22f2 <__stack+0xf3>
    22f0:	40 c0       	rjmp	.+128    	; 0x2372 <__stack+0x173>
    22f2:	e1 2c       	mov	r14, r1
    22f4:	f1 2c       	mov	r15, r1
    22f6:	3d c0       	rjmp	.+122    	; 0x2372 <__stack+0x173>
							
							RSpeed = currentDriveActuation;
							
							
						}else{//Moving right
							RSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*rightIntError; //Simple PI controller for theta
    22f8:	e0 2e       	mov	r14, r16
    22fa:	f1 2c       	mov	r15, r1
    22fc:	b7 01       	movw	r22, r14
    22fe:	0f 2c       	mov	r0, r15
    2300:	00 0c       	add	r0, r0
    2302:	88 0b       	sbc	r24, r24
    2304:	99 0b       	sbc	r25, r25
    2306:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    230a:	6a 8b       	std	Y+18, r22	; 0x12
    230c:	7b 8b       	std	Y+19, r23	; 0x13
    230e:	8c 8b       	std	Y+20, r24	; 0x14
    2310:	9d 8b       	std	Y+21, r25	; 0x15
    2312:	20 e0       	ldi	r18, 0x00	; 0
    2314:	30 e0       	ldi	r19, 0x00	; 0
    2316:	46 e1       	ldi	r20, 0x16	; 22
    2318:	54 e4       	ldi	r21, 0x44	; 68
    231a:	c5 01       	movw	r24, r10
    231c:	b4 01       	movw	r22, r8
    231e:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2322:	9b 01       	movw	r18, r22
    2324:	ac 01       	movw	r20, r24
    2326:	6a 89       	ldd	r22, Y+18	; 0x12
    2328:	7b 89       	ldd	r23, Y+19	; 0x13
    232a:	8c 89       	ldd	r24, Y+20	; 0x14
    232c:	9d 89       	ldd	r25, Y+21	; 0x15
    232e:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    2332:	4b 01       	movw	r8, r22
    2334:	5c 01       	movw	r10, r24
    2336:	20 e0       	ldi	r18, 0x00	; 0
    2338:	30 e0       	ldi	r19, 0x00	; 0
    233a:	40 e2       	ldi	r20, 0x20	; 32
    233c:	51 e4       	ldi	r21, 0x41	; 65
    233e:	6f a1       	ldd	r22, Y+39	; 0x27
    2340:	78 a5       	ldd	r23, Y+40	; 0x28
    2342:	89 a5       	ldd	r24, Y+41	; 0x29
    2344:	9a a5       	ldd	r25, Y+42	; 0x2a
    2346:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    234a:	9b 01       	movw	r18, r22
    234c:	ac 01       	movw	r20, r24
    234e:	c5 01       	movw	r24, r10
    2350:	b4 01       	movw	r22, r8
    2352:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    2356:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
							
							//Saturation
							if (RSpeed > currentDriveActuation){
    235a:	e6 16       	cp	r14, r22
    235c:	f7 06       	cpc	r15, r23
    235e:	44 f0       	brlt	.+16     	; 0x2370 <__stack+0x171>
    2360:	8b 01       	movw	r16, r22
    2362:	77 23       	and	r23, r23
    2364:	34 f4       	brge	.+12     	; 0x2372 <__stack+0x173>
    2366:	00 e0       	ldi	r16, 0x00	; 0
    2368:	10 e0       	ldi	r17, 0x00	; 0
    236a:	03 c0       	rjmp	.+6      	; 0x2372 <__stack+0x173>
						if (thetaDiff >= 0){//Moving left
							LSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*leftIntError; //Simple PI controller for theta 
							
							//Saturation
							if (LSpeed > currentDriveActuation){
								LSpeed = currentDriveActuation;
    236c:	78 01       	movw	r14, r16
    236e:	01 c0       	rjmp	.+2      	; 0x2372 <__stack+0x173>
						}else{//Moving right
							RSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*rightIntError; //Simple PI controller for theta
							
							//Saturation
							if (RSpeed > currentDriveActuation){
								RSpeed = currentDriveActuation;
    2370:	87 01       	movw	r16, r14
							
							
							
						}
						
						leftIntError += thetaDiff;
    2372:	a3 01       	movw	r20, r6
    2374:	92 01       	movw	r18, r4
    2376:	6b a1       	ldd	r22, Y+35	; 0x23
    2378:	7c a1       	ldd	r23, Y+36	; 0x24
    237a:	8d a1       	ldd	r24, Y+37	; 0x25
    237c:	9e a1       	ldd	r25, Y+38	; 0x26
    237e:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    2382:	6b a3       	std	Y+35, r22	; 0x23
    2384:	7c a3       	std	Y+36, r23	; 0x24
    2386:	8d a3       	std	Y+37, r24	; 0x25
    2388:	9e a3       	std	Y+38, r25	; 0x26
						rightIntError -= thetaDiff;
    238a:	a3 01       	movw	r20, r6
    238c:	92 01       	movw	r18, r4
    238e:	6f a1       	ldd	r22, Y+39	; 0x27
    2390:	78 a5       	ldd	r23, Y+40	; 0x28
    2392:	89 a5       	ldd	r24, Y+41	; 0x29
    2394:	9a a5       	ldd	r25, Y+42	; 0x2a
    2396:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    239a:	6f a3       	std	Y+39, r22	; 0x27
    239c:	78 a7       	std	Y+40, r23	; 0x28
    239e:	89 a7       	std	Y+41, r24	; 0x29
    23a0:	9a a7       	std	Y+42, r25	; 0x2a
						
						
						gRightWheelDirection = motorRightForward;
    23a2:	b2 e0       	ldi	r27, 0x02	; 2
    23a4:	bd 87       	std	Y+13, r27	; 0x0d
						gLeftWheelDirection = motorLeftForward;
    23a6:	85 e0       	ldi	r24, 0x05	; 5
    23a8:	8c 87       	std	Y+12, r24	; 0x0c
						lastMovement = moveForward;
    23aa:	a1 e0       	ldi	r26, 0x01	; 1
    23ac:	af 83       	std	Y+7, r26	; 0x07
    23ae:	70 c0       	rjmp	.+224    	; 0x2490 <__stack+0x291>
						
						
						
					}else{ //Turn within 1 degree of target
						if (thetaDiff >= 0){//Rotating left
    23b0:	20 e0       	ldi	r18, 0x00	; 0
    23b2:	30 e0       	ldi	r19, 0x00	; 0
    23b4:	a9 01       	movw	r20, r18
    23b6:	c3 01       	movw	r24, r6
    23b8:	b2 01       	movw	r22, r4
    23ba:	0e 94 cb 32 	call	0x6596	; 0x6596 <__gesf2>
    23be:	88 23       	and	r24, r24
    23c0:	a4 f1       	brlt	.+104    	; 0x242a <__stack+0x22b>
							LSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    23c2:	2e ea       	ldi	r18, 0xAE	; 174
    23c4:	37 e4       	ldi	r19, 0x47	; 71
    23c6:	41 e6       	ldi	r20, 0x61	; 97
    23c8:	5e e3       	ldi	r21, 0x3E	; 62
    23ca:	c5 01       	movw	r24, r10
    23cc:	b4 01       	movw	r22, r8
    23ce:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    23d2:	2a e9       	ldi	r18, 0x9A	; 154
    23d4:	39 e9       	ldi	r19, 0x99	; 153
    23d6:	49 e9       	ldi	r20, 0x99	; 153
    23d8:	5e e3       	ldi	r21, 0x3E	; 62
    23da:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    23de:	4b 01       	movw	r8, r22
    23e0:	5c 01       	movw	r10, r24
    23e2:	20 e0       	ldi	r18, 0x00	; 0
    23e4:	30 e0       	ldi	r19, 0x00	; 0
    23e6:	46 e1       	ldi	r20, 0x16	; 22
    23e8:	53 ec       	ldi	r21, 0xC3	; 195
    23ea:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    23ee:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
    23f2:	7b 01       	movw	r14, r22
							gLeftWheelDirection = motorLeftBackward;
    23f4:	b7 e0       	ldi	r27, 0x07	; 7
    23f6:	bc 87       	std	Y+12, r27	; 0x0c
							RSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    23f8:	20 e0       	ldi	r18, 0x00	; 0
    23fa:	30 e0       	ldi	r19, 0x00	; 0
    23fc:	46 e1       	ldi	r20, 0x16	; 22
    23fe:	53 e4       	ldi	r21, 0x43	; 67
    2400:	c5 01       	movw	r24, r10
    2402:	b4 01       	movw	r22, r8
    2404:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2408:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
    240c:	8b 01       	movw	r16, r22
							gRightWheelDirection = motorRightForward;
    240e:	82 e0       	ldi	r24, 0x02	; 2
    2410:	8d 87       	std	Y+13, r24	; 0x0d
							lastMovement = moveCounterClockwise;
    2412:	a4 e0       	ldi	r26, 0x04	; 4
    2414:	af 83       	std	Y+7, r26	; 0x07
    2416:	1b a6       	std	Y+43, r1	; 0x2b
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
						}
						
						leftIntError = 0;
						rightIntError = 0;
    2418:	1f a2       	std	Y+39, r1	; 0x27
    241a:	18 a6       	std	Y+40, r1	; 0x28
    241c:	19 a6       	std	Y+41, r1	; 0x29
    241e:	1a a6       	std	Y+42, r1	; 0x2a
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
						}
						
						leftIntError = 0;
    2420:	1b a2       	std	Y+35, r1	; 0x23
    2422:	1c a2       	std	Y+36, r1	; 0x24
    2424:	1d a2       	std	Y+37, r1	; 0x25
    2426:	1e a2       	std	Y+38, r1	; 0x26
    2428:	33 c0       	rjmp	.+102    	; 0x2490 <__stack+0x291>
							gLeftWheelDirection = motorLeftBackward;
							RSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightForward;
							lastMovement = moveCounterClockwise;
						}else{//Rotating right
							LSpeed = maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    242a:	2e ea       	ldi	r18, 0xAE	; 174
    242c:	37 e4       	ldi	r19, 0x47	; 71
    242e:	41 e6       	ldi	r20, 0x61	; 97
    2430:	5e e3       	ldi	r21, 0x3E	; 62
    2432:	c5 01       	movw	r24, r10
    2434:	b4 01       	movw	r22, r8
    2436:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    243a:	2a e9       	ldi	r18, 0x9A	; 154
    243c:	39 e9       	ldi	r19, 0x99	; 153
    243e:	49 e9       	ldi	r20, 0x99	; 153
    2440:	5e e3       	ldi	r21, 0x3E	; 62
    2442:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    2446:	4b 01       	movw	r8, r22
    2448:	5c 01       	movw	r10, r24
    244a:	20 e0       	ldi	r18, 0x00	; 0
    244c:	30 e0       	ldi	r19, 0x00	; 0
    244e:	46 e1       	ldi	r20, 0x16	; 22
    2450:	53 e4       	ldi	r21, 0x43	; 67
    2452:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2456:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
    245a:	7b 01       	movw	r14, r22
							gLeftWheelDirection = motorLeftForward;
    245c:	b5 e0       	ldi	r27, 0x05	; 5
    245e:	bc 87       	std	Y+12, r27	; 0x0c
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
    2460:	20 e0       	ldi	r18, 0x00	; 0
    2462:	30 e0       	ldi	r19, 0x00	; 0
    2464:	46 e1       	ldi	r20, 0x16	; 22
    2466:	53 ec       	ldi	r21, 0xC3	; 195
    2468:	c5 01       	movw	r24, r10
    246a:	b4 01       	movw	r22, r8
    246c:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2470:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
    2474:	8b 01       	movw	r16, r22
							gRightWheelDirection = motorRightBackward;
    2476:	84 e0       	ldi	r24, 0x04	; 4
    2478:	8d 87       	std	Y+13, r24	; 0x0d
							lastMovement = moveClockwise;
    247a:	a3 e0       	ldi	r26, 0x03	; 3
    247c:	af 83       	std	Y+7, r26	; 0x07
    247e:	1b a6       	std	Y+43, r1	; 0x2b
						}
						
						leftIntError = 0;
						rightIntError = 0;
    2480:	1f a2       	std	Y+39, r1	; 0x27
    2482:	18 a6       	std	Y+40, r1	; 0x28
    2484:	19 a6       	std	Y+41, r1	; 0x29
    2486:	1a a6       	std	Y+42, r1	; 0x2a
							RSpeed = -maxRotateActuation*(0.3 + 0.22*(fabs(thetaDiff)));
							gRightWheelDirection = motorRightBackward;
							lastMovement = moveClockwise;
						}
						
						leftIntError = 0;
    2488:	1b a2       	std	Y+35, r1	; 0x23
    248a:	1c a2       	std	Y+36, r1	; 0x24
    248c:	1d a2       	std	Y+37, r1	; 0x25
    248e:	1e a2       	std	Y+38, r1	; 0x26
					
					
					
					
					
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
    2490:	9e 01       	movw	r18, r28
    2492:	23 5f       	subi	r18, 0xF3	; 243
    2494:	3f 4f       	sbci	r19, 0xFF	; 255
    2496:	ae 01       	movw	r20, r28
    2498:	44 5f       	subi	r20, 0xF4	; 244
    249a:	5f 4f       	sbci	r21, 0xFF	; 255
    249c:	b8 01       	movw	r22, r16
    249e:	c7 01       	movw	r24, r14
    24a0:	36 d4       	rcall	.+2156   	; 0x2d0e <vMotorMovementSwitch>
				
				
				if(distance > radiusEpsilon){//Not close enough to target
					
					
					idleSendt = FALSE;
    24a2:	1a 8e       	std	Y+26, r1	; 0x1a
    24a4:	0a c0       	rjmp	.+20     	; 0x24ba <__stack+0x2bb>
					
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
			
				}else{
					
					if (idleSendt == FALSE){
    24a6:	ba 8d       	ldd	r27, Y+26	; 0x1a
    24a8:	b1 11       	cpse	r27, r1
    24aa:	04 c0       	rjmp	.+8      	; 0x24b4 <__stack+0x2b5>
						send_idle();
    24ac:	0e 94 ff 20 	call	0x41fe	; 0x41fe <send_idle>
						idleSendt = TRUE;
    24b0:	81 e0       	ldi	r24, 0x01	; 1
    24b2:	8a 8f       	std	Y+26, r24	; 0x1a
					}
					
					
					vMotorBrakeLeft();
    24b4:	22 d4       	rcall	.+2116   	; 0x2cfa <vMotorBrakeLeft>
					vMotorBrakeRight();
    24b6:	26 d4       	rcall	.+2124   	; 0x2d04 <vMotorBrakeRight>
					lastMovement = moveStop;
    24b8:	1f 82       	std	Y+7, r1	; 0x07
				}
				
				
				
				xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
    24ba:	20 e0       	ldi	r18, 0x00	; 0
    24bc:	40 e0       	ldi	r20, 0x00	; 0
    24be:	50 e0       	ldi	r21, 0x00	; 0
    24c0:	be 01       	movw	r22, r28
    24c2:	69 5f       	subi	r22, 0xF9	; 249
    24c4:	7f 4f       	sbci	r23, 0xFF	; 255
    24c6:	80 91 c9 19 	lds	r24, 0x19C9	; 0x8019c9 <scanStatusQ>
    24ca:	90 91 ca 19 	lds	r25, 0x19CA	; 0x8019ca <scanStatusQ+0x1>
    24ce:	0e 94 1f 1b 	call	0x363e	; 0x363e <xQueueGenericSend>
    24d2:	42 cd       	rjmp	.-1404   	; 0x1f58 <vMainPoseControllerTask+0x56>

000024d4 <vMainPoseEstimatorTask>:
	
	*/
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    24d4:	cf 93       	push	r28
    24d6:	df 93       	push	r29
    24d8:	cd b7       	in	r28, 0x3d	; 61
    24da:	de b7       	in	r29, 0x3e	; 62
    24dc:	e1 97       	sbiw	r28, 0x31	; 49
    24de:	0f b6       	in	r0, 0x3f	; 63
    24e0:	f8 94       	cli
    24e2:	de bf       	out	0x3e, r29	; 62
    24e4:	0f be       	out	0x3f, r0	; 63
    24e6:	cd bf       	out	0x3d, r28	; 61
    const TickType_t xDelay = PERIOD_ESTIMATOR_MS;
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    24e8:	19 82       	std	Y+1, r1	; 0x01
    24ea:	1a 82       	std	Y+2, r1	; 0x02
    24ec:	1b 82       	std	Y+3, r1	; 0x03
    24ee:	1c 82       	std	Y+4, r1	; 0x04
        uint8_t printerTellar = 0;     
    #endif
    
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    24f0:	0e 94 1a 29 	call	0x5234	; 0x5234 <xTaskGetTickCount>
    24f4:	9e 83       	std	Y+6, r25	; 0x06
    24f6:	8d 83       	std	Y+5, r24	; 0x05
    
    float variance_gyro = 0.0482f; // [rad] calculated offline, see report
    float variance_encoder = (2.0f * WHEEL_FACTOR_MM) / (WHEELBASE_MM / 2.0f); // approximation, 0.0257 [rad]
    
    float variance_gyro_encoder = (variance_gyro + variance_encoder) * period_in_S; // (Var gyro + var encoder) * timestep
    float covariance_filter_predicted = 0;
    24f8:	1d a6       	std	Y+45, r1	; 0x2d
    24fa:	1e a6       	std	Y+46, r1	; 0x2e
    24fc:	1f a6       	std	Y+47, r1	; 0x2f
    24fe:	18 aa       	std	Y+48, r1	; 0x30
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    float compassOffset = 0.0;
    2500:	19 a2       	std	Y+33, r1	; 0x21
    2502:	1a a2       	std	Y+34, r1	; 0x22
    2504:	1b a2       	std	Y+35, r1	; 0x23
    2506:	1c a2       	std	Y+36, r1	; 0x24
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    2508:	1d 8e       	std	Y+29, r1	; 0x1d
    250a:	1e 8e       	std	Y+30, r1	; 0x1e
    250c:	1f 8e       	std	Y+31, r1	; 0x1f
    250e:	18 a2       	std	Y+32, r1	; 0x20
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    2510:	19 8e       	std	Y+25, r1	; 0x19
    2512:	1a 8e       	std	Y+26, r1	; 0x1a
    2514:	1b 8e       	std	Y+27, r1	; 0x1b
    2516:	1c 8e       	std	Y+28, r1	; 0x1c
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;
    
    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    2518:	1d 8a       	std	Y+21, r1	; 0x15
    251a:	1e 8a       	std	Y+22, r1	; 0x16
    251c:	1f 8a       	std	Y+23, r1	; 0x17
    251e:	18 8e       	std	Y+24, r1	; 0x18
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    int16_t previous_ticksRight = 0;  
    2520:	61 2c       	mov	r6, r1
    2522:	71 2c       	mov	r7, r1
	*/
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    2524:	1a 8a       	std	Y+18, r1	; 0x12
    2526:	19 8a       	std	Y+17, r1	; 0x11
    2528:	41 2c       	mov	r4, r1
    252a:	31 2c       	mov	r3, r1
    252c:	21 2c       	mov	r2, r1
    252e:	51 2c       	mov	r5, r1
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    
    while(1){
        // Loop
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    2530:	68 e2       	ldi	r22, 0x28	; 40
    2532:	70 e0       	ldi	r23, 0x00	; 0
    2534:	ce 01       	movw	r24, r28
    2536:	05 96       	adiw	r24, 0x05	; 5
    2538:	0e 94 cd 23 	call	0x479a	; 0x479a <vTaskDelayUntil>
        if (gHandshook){ // Check if we are ready    
    253c:	80 91 c4 19 	lds	r24, 0x19C4	; 0x8019c4 <gHandshook>
    2540:	88 23       	and	r24, r24
    2542:	09 f4       	brne	.+2      	; 0x2546 <vMainPoseEstimatorTask+0x72>
    2544:	01 c2       	rjmp	.+1026   	; 0x2948 <vMainPoseEstimatorTask+0x474>
            int16_t leftWheelTicks = 0;
            int16_t rightWheelTicks = 0;
            
            // Get encoder data, protect the global tick variables
            xSemaphoreTake(xTickMutex, 15 / portTICK_PERIOD_MS);
    2546:	20 e0       	ldi	r18, 0x00	; 0
    2548:	4f e0       	ldi	r20, 0x0F	; 15
    254a:	50 e0       	ldi	r21, 0x00	; 0
    254c:	60 e0       	ldi	r22, 0x00	; 0
    254e:	70 e0       	ldi	r23, 0x00	; 0
    2550:	80 91 31 1b 	lds	r24, 0x1B31	; 0x801b31 <xTickMutex>
    2554:	90 91 32 1b 	lds	r25, 0x1B32	; 0x801b32 <xTickMutex+0x1>
    2558:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
                leftWheelTicks = gLeftWheelTicks;
    255c:	80 91 b7 19 	lds	r24, 0x19B7	; 0x8019b7 <gLeftWheelTicks>
    2560:	90 91 b8 19 	lds	r25, 0x19B8	; 0x8019b8 <gLeftWheelTicks+0x1>
    2564:	9e a3       	std	Y+38, r25	; 0x26
    2566:	8d a3       	std	Y+37, r24	; 0x25
                rightWheelTicks = gRightWheelTicks;
    2568:	80 91 b9 19 	lds	r24, 0x19B9	; 0x8019b9 <gRightWheelTicks>
    256c:	90 91 ba 19 	lds	r25, 0x19BA	; 0x8019ba <gRightWheelTicks+0x1>
    2570:	98 a7       	std	Y+40, r25	; 0x28
    2572:	8f a3       	std	Y+39, r24	; 0x27
            xSemaphoreGive(xTickMutex);
    2574:	60 e0       	ldi	r22, 0x00	; 0
    2576:	70 e0       	ldi	r23, 0x00	; 0
    2578:	80 91 31 1b 	lds	r24, 0x1B31	; 0x801b31 <xTickMutex>
    257c:	90 91 32 1b 	lds	r25, 0x1B32	; 0x801b32 <xTickMutex+0x1>
    2580:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
    2584:	6d a1       	ldd	r22, Y+37	; 0x25
    2586:	7e a1       	ldd	r23, Y+38	; 0x26
    2588:	89 89       	ldd	r24, Y+17	; 0x11
    258a:	9a 89       	ldd	r25, Y+18	; 0x12
    258c:	68 1b       	sub	r22, r24
    258e:	79 0b       	sbc	r23, r25
    2590:	07 2e       	mov	r0, r23
    2592:	00 0c       	add	r0, r0
    2594:	88 0b       	sbc	r24, r24
    2596:	99 0b       	sbc	r25, r25
    2598:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    259c:	2d e3       	ldi	r18, 0x3D	; 61
    259e:	3c e2       	ldi	r19, 0x2C	; 44
    25a0:	44 e5       	ldi	r20, 0x54	; 84
    25a2:	5e e3       	ldi	r21, 0x3E	; 62
    25a4:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    25a8:	4b 01       	movw	r8, r22
    25aa:	5c 01       	movw	r10, r24
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
    25ac:	6f a1       	ldd	r22, Y+39	; 0x27
    25ae:	78 a5       	ldd	r23, Y+40	; 0x28
    25b0:	66 19       	sub	r22, r6
    25b2:	77 09       	sbc	r23, r7
    25b4:	07 2e       	mov	r0, r23
    25b6:	00 0c       	add	r0, r0
    25b8:	88 0b       	sbc	r24, r24
    25ba:	99 0b       	sbc	r25, r25
    25bc:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    25c0:	2d e3       	ldi	r18, 0x3D	; 61
    25c2:	3c e2       	ldi	r19, 0x2C	; 44
    25c4:	44 e5       	ldi	r20, 0x54	; 84
    25c6:	5e e3       	ldi	r21, 0x3E	; 62
    25c8:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    25cc:	6b 01       	movw	r12, r22
    25ce:	7c 01       	movw	r14, r24
            
			
			
					   
					   
            float dRobot = (dLeft + dRight) / 2;           
    25d0:	9b 01       	movw	r18, r22
    25d2:	ac 01       	movw	r20, r24
    25d4:	c5 01       	movw	r24, r10
    25d6:	b4 01       	movw	r22, r8
    25d8:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    25dc:	20 e0       	ldi	r18, 0x00	; 0
    25de:	30 e0       	ldi	r19, 0x00	; 0
    25e0:	40 e0       	ldi	r20, 0x00	; 0
    25e2:	5f e3       	ldi	r21, 0x3F	; 63
    25e4:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    25e8:	69 8b       	std	Y+17, r22	; 0x11
    25ea:	7a 8b       	std	Y+18, r23	; 0x12
    25ec:	8b 8b       	std	Y+19, r24	; 0x13
    25ee:	9c 8b       	std	Y+20, r25	; 0x14
            float dTheta = (dRight - dLeft) / WHEELBASE_MM; // Get angle from encoders, dervied from arch of circles formula
    25f0:	a5 01       	movw	r20, r10
    25f2:	94 01       	movw	r18, r8
    25f4:	c7 01       	movw	r24, r14
    25f6:	b6 01       	movw	r22, r12
    25f8:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    25fc:	20 e0       	ldi	r18, 0x00	; 0
    25fe:	30 e0       	ldi	r19, 0x00	; 0
    2600:	47 e5       	ldi	r20, 0x57	; 87
    2602:	53 e4       	ldi	r21, 0x43	; 67
    2604:	0e 94 22 31 	call	0x6244	; 0x6244 <__divsf3>
    2608:	6b 01       	movw	r12, r22
    260a:	7c 01       	movw	r14, r24
			
			
            
            /* PREDICT */
            // Get gyro data:
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
    260c:	5b d9       	rcall	.-3402   	; 0x18c4 <fIMU_readFloatGyroZ>
    260e:	2d 8d       	ldd	r18, Y+29	; 0x1d
    2610:	3e 8d       	ldd	r19, Y+30	; 0x1e
    2612:	4f 8d       	ldd	r20, Y+31	; 0x1f
    2614:	58 a1       	ldd	r21, Y+32	; 0x20
    2616:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    261a:	4b 01       	movw	r8, r22
    261c:	5c 01       	movw	r10, r24
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
    261e:	9f 77       	andi	r25, 0x7F	; 127
    2620:	20 e0       	ldi	r18, 0x00	; 0
    2622:	30 e0       	ldi	r19, 0x00	; 0
    2624:	40 e2       	ldi	r20, 0x20	; 32
    2626:	51 e4       	ldi	r21, 0x41	; 65
    2628:	0e 94 1b 31 	call	0x6236	; 0x6236 <__cmpsf2>
    262c:	88 23       	and	r24, r24
    262e:	6c f0       	brlt	.+26     	; 0x264a <vMainPoseEstimatorTask+0x176>
                gyroWeight = 0; // Disregard gyro while driving in a straight line
                robot_is_turning = FALSE; // Don't update angle estimates
                }
            else {
                robot_is_turning = TRUE;
    2630:	91 e0       	ldi	r25, 0x01	; 1
    2632:	99 ab       	std	Y+49, r25	; 0x31
                gyroWeight = 0.85; // Found by experiment, after 20x90 degree turns, gyro seems 85% more accurate than encoders
    2634:	1a e9       	ldi	r17, 0x9A	; 154
    2636:	09 e9       	ldi	r16, 0x99	; 153
    2638:	0f 2e       	mov	r0, r31
    263a:	f9 e5       	ldi	r31, 0x59	; 89
    263c:	7f 2e       	mov	r7, r31
    263e:	f0 2d       	mov	r31, r0
    2640:	0f 2e       	mov	r0, r31
    2642:	ff e3       	ldi	r31, 0x3F	; 63
    2644:	6f 2e       	mov	r6, r31
    2646:	f0 2d       	mov	r31, r0
    2648:	05 c0       	rjmp	.+10     	; 0x2654 <vMainPoseEstimatorTask+0x180>
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
                gyroWeight = 0; // Disregard gyro while driving in a straight line
                robot_is_turning = FALSE; // Don't update angle estimates
    264a:	19 aa       	std	Y+49, r1	; 0x31
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
            //dTheta = gyrZ * period_in_S * DEG2RAD; [COMMENT]I believe this line is not supposed to be here. Residual from broken encoders?
            
            // If the robot is not really rotating we don't include the gyro measurements, to avoid the trouble with drift while driving in a straight line
            if(fabs(gyrZ) < 10){ 
                gyroWeight = 0; // Disregard gyro while driving in a straight line
    264c:	14 2d       	mov	r17, r4
    264e:	03 2d       	mov	r16, r3
    2650:	72 2c       	mov	r7, r2
    2652:	65 2c       	mov	r6, r5
			
			
			
			
            // Fuse heading from sensors to predict heading:
            dTheta =  (1 - gyroWeight) * dTheta + gyroWeight * gyrZ;
    2654:	21 2f       	mov	r18, r17
    2656:	30 2f       	mov	r19, r16
    2658:	47 2d       	mov	r20, r7
    265a:	56 2d       	mov	r21, r6
    265c:	60 e0       	ldi	r22, 0x00	; 0
    265e:	70 e0       	ldi	r23, 0x00	; 0
    2660:	80 e8       	ldi	r24, 0x80	; 128
    2662:	9f e3       	ldi	r25, 0x3F	; 63
    2664:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    2668:	a7 01       	movw	r20, r14
    266a:	96 01       	movw	r18, r12
    266c:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2670:	6b 01       	movw	r12, r22
    2672:	7c 01       	movw	r14, r24
                robot_is_turning = TRUE;
                gyroWeight = 0.85; // Found by experiment, after 20x90 degree turns, gyro seems 85% more accurate than encoders
                
            }
            
            gyrZ *= period_in_S * DEG2RAD; // Scale gyro measurement      
    2674:	24 ed       	ldi	r18, 0xD4	; 212
    2676:	32 e0       	ldi	r19, 0x02	; 2
    2678:	47 e3       	ldi	r20, 0x37	; 55
    267a:	5a e3       	ldi	r21, 0x3A	; 58
    267c:	c5 01       	movw	r24, r10
    267e:	b4 01       	movw	r22, r8
    2680:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2684:	9b 01       	movw	r18, r22
    2686:	ac 01       	movw	r20, r24
			
			
			
			
            // Fuse heading from sensors to predict heading:
            dTheta =  (1 - gyroWeight) * dTheta + gyroWeight * gyrZ;
    2688:	61 2f       	mov	r22, r17
    268a:	70 2f       	mov	r23, r16
    268c:	87 2d       	mov	r24, r7
    268e:	96 2d       	mov	r25, r6
    2690:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2694:	9b 01       	movw	r18, r22
    2696:	ac 01       	movw	r20, r24
    2698:	c7 01       	movw	r24, r14
    269a:	b6 01       	movw	r22, r12
    269c:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    26a0:	4b 01       	movw	r8, r22
    26a2:	5c 01       	movw	r10, r24
            
            
            // Estimate global X and Y pos
            // Todo; Include accelerator measurements to estimate position and handle wheel slippage
            predictedX = predictedX + (dRobot * cos(predictedTheta + 0.5 * dTheta)); 
    26a4:	c9 80       	ldd	r12, Y+1	; 0x01
    26a6:	da 80       	ldd	r13, Y+2	; 0x02
    26a8:	eb 80       	ldd	r14, Y+3	; 0x03
    26aa:	fc 80       	ldd	r15, Y+4	; 0x04
    26ac:	20 e0       	ldi	r18, 0x00	; 0
    26ae:	30 e0       	ldi	r19, 0x00	; 0
    26b0:	40 e0       	ldi	r20, 0x00	; 0
    26b2:	5f e3       	ldi	r21, 0x3F	; 63
    26b4:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    26b8:	a7 01       	movw	r20, r14
    26ba:	96 01       	movw	r18, r12
    26bc:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    26c0:	69 a7       	std	Y+41, r22	; 0x29
    26c2:	7a a7       	std	Y+42, r23	; 0x2a
    26c4:	8b a7       	std	Y+43, r24	; 0x2b
    26c6:	9c a7       	std	Y+44, r25	; 0x2c
    26c8:	0e 94 1f 31 	call	0x623e	; 0x623e <cos>
    26cc:	29 89       	ldd	r18, Y+17	; 0x11
    26ce:	3a 89       	ldd	r19, Y+18	; 0x12
    26d0:	4b 89       	ldd	r20, Y+19	; 0x13
    26d2:	5c 89       	ldd	r21, Y+20	; 0x14
    26d4:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    26d8:	9b 01       	movw	r18, r22
    26da:	ac 01       	movw	r20, r24
    26dc:	6d 89       	ldd	r22, Y+21	; 0x15
    26de:	7e 89       	ldd	r23, Y+22	; 0x16
    26e0:	8f 89       	ldd	r24, Y+23	; 0x17
    26e2:	98 8d       	ldd	r25, Y+24	; 0x18
    26e4:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    26e8:	6d 8b       	std	Y+21, r22	; 0x15
    26ea:	7e 8b       	std	Y+22, r23	; 0x16
    26ec:	8f 8b       	std	Y+23, r24	; 0x17
    26ee:	98 8f       	std	Y+24, r25	; 0x18
            predictedY = predictedY + (dRobot * sin(predictedTheta + 0.5 * dTheta));
    26f0:	69 a5       	ldd	r22, Y+41	; 0x29
    26f2:	7a a5       	ldd	r23, Y+42	; 0x2a
    26f4:	8b a5       	ldd	r24, Y+43	; 0x2b
    26f6:	9c a5       	ldd	r25, Y+44	; 0x2c
    26f8:	0e 94 39 33 	call	0x6672	; 0x6672 <sin>
    26fc:	29 89       	ldd	r18, Y+17	; 0x11
    26fe:	3a 89       	ldd	r19, Y+18	; 0x12
    2700:	4b 89       	ldd	r20, Y+19	; 0x13
    2702:	5c 89       	ldd	r21, Y+20	; 0x14
    2704:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    2708:	9b 01       	movw	r18, r22
    270a:	ac 01       	movw	r20, r24
    270c:	69 8d       	ldd	r22, Y+25	; 0x19
    270e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    2710:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2712:	9c 8d       	ldd	r25, Y+28	; 0x1c
    2714:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    2718:	69 8f       	std	Y+25, r22	; 0x19
    271a:	7a 8f       	std	Y+26, r23	; 0x1a
    271c:	8b 8f       	std	Y+27, r24	; 0x1b
    271e:	9c 8f       	std	Y+28, r25	; 0x1c

            // Predicted (a priori) state estimate for theta
            predictedTheta += dTheta;
    2720:	a7 01       	movw	r20, r14
    2722:	96 01       	movw	r18, r12
    2724:	c5 01       	movw	r24, r10
    2726:	b4 01       	movw	r22, r8
    2728:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    272c:	69 83       	std	Y+1, r22	; 0x01
    272e:	7a 83       	std	Y+2, r23	; 0x02
    2730:	8b 83       	std	Y+3, r24	; 0x03
    2732:	9c 83       	std	Y+4, r25	; 0x04
                  
            // Predicted (a priori) estimate covariance
            covariance_filter_predicted += variance_gyro_encoder;
    2734:	20 e7       	ldi	r18, 0x70	; 112
    2736:	35 e7       	ldi	r19, 0x75	; 117
    2738:	48 e0       	ldi	r20, 0x08	; 8
    273a:	5b e3       	ldi	r21, 0x3B	; 59
    273c:	6d a5       	ldd	r22, Y+45	; 0x2d
    273e:	7e a5       	ldd	r23, Y+46	; 0x2e
    2740:	8f a5       	ldd	r24, Y+47	; 0x2f
    2742:	98 a9       	ldd	r25, Y+48	; 0x30
    2744:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    2748:	4b 01       	movw	r8, r22
    274a:	5c 01       	movw	r10, r24
            
            /* UPDATE */
            // Get compass data: ( Request and recheck after 6 ms?)
            int16_t xCom, yCom, zCom;
            vCOM_getData(&xCom, &yCom, &zCom);
    274c:	ae 01       	movw	r20, r28
    274e:	45 5f       	subi	r20, 0xF5	; 245
    2750:	5f 4f       	sbci	r21, 0xFF	; 255
    2752:	be 01       	movw	r22, r28
    2754:	63 5f       	subi	r22, 0xF3	; 243
    2756:	7f 4f       	sbci	r23, 0xFF	; 255
    2758:	ce 01       	movw	r24, r28
    275a:	0f 96       	adiw	r24, 0x0f	; 15
    275c:	0e 94 b0 07 	call	0xf60	; 0xf60 <vCOM_getData>
            // Add calibrated bias
            xCom += xComOff;
    2760:	6f 85       	ldd	r22, Y+15	; 0x0f
    2762:	78 89       	ldd	r23, Y+16	; 0x10
    2764:	65 5f       	subi	r22, 0xF5	; 245
    2766:	7f 4f       	sbci	r23, 0xFF	; 255
    2768:	78 8b       	std	Y+16, r23	; 0x10
    276a:	6f 87       	std	Y+15, r22	; 0x0f
            yCom += yComOff;
    276c:	0d 85       	ldd	r16, Y+13	; 0x0d
    276e:	1e 85       	ldd	r17, Y+14	; 0x0e
    2770:	0e 54       	subi	r16, 0x4E	; 78
    2772:	11 09       	sbc	r17, r1
    2774:	1e 87       	std	Y+14, r17	; 0x0e
    2776:	0d 87       	std	Y+13, r16	; 0x0d
            // calculate heading
            float compassHeading;
            compassHeading = atan2(yCom, xCom) - compassOffset ; // returns -pi, pi
    2778:	07 2e       	mov	r0, r23
    277a:	00 0c       	add	r0, r0
    277c:	88 0b       	sbc	r24, r24
    277e:	99 0b       	sbc	r25, r25
    2780:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    2784:	6b 01       	movw	r12, r22
    2786:	7c 01       	movw	r14, r24
    2788:	b8 01       	movw	r22, r16
    278a:	11 0f       	add	r17, r17
    278c:	88 0b       	sbc	r24, r24
    278e:	99 0b       	sbc	r25, r25
    2790:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    2794:	a7 01       	movw	r20, r14
    2796:	96 01       	movw	r18, r12
    2798:	0e 94 c8 30 	call	0x6190	; 0x6190 <atan2>
    279c:	29 a1       	ldd	r18, Y+33	; 0x21
    279e:	3a a1       	ldd	r19, Y+34	; 0x22
    27a0:	4b a1       	ldd	r20, Y+35	; 0x23
    27a2:	5c a1       	ldd	r21, Y+36	; 0x24
    27a4:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
            // Update predicted state:    
            float error = (compassHeading - predictedTheta);
    27a8:	29 81       	ldd	r18, Y+1	; 0x01
    27aa:	3a 81       	ldd	r19, Y+2	; 0x02
    27ac:	4b 81       	ldd	r20, Y+3	; 0x03
    27ae:	5c 81       	ldd	r21, Y+4	; 0x04
    27b0:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    27b4:	6f 83       	std	Y+7, r22	; 0x07
    27b6:	78 87       	std	Y+8, r23	; 0x08
    27b8:	89 87       	std	Y+9, r24	; 0x09
    27ba:	9a 87       	std	Y+10, r25	; 0x0a
            vFunc_Inf2pi(&error);
    27bc:	ce 01       	movw	r24, r28
    27be:	07 96       	adiw	r24, 0x07	; 7
    27c0:	0e 94 4a 08 	call	0x1094	; 0x1094 <vFunc_Inf2pi>
            
            
            //kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
            ///* Commented back in due to fixed encoder
            if (fabs(error) > (0.8727*period_in_S)){ // 0.8727 rad/s is top speed while turning
    27c4:	8f 81       	ldd	r24, Y+7	; 0x07
    27c6:	98 85       	ldd	r25, Y+8	; 0x08
    27c8:	a9 85       	ldd	r26, Y+9	; 0x09
    27ca:	ba 85       	ldd	r27, Y+10	; 0x0a
    27cc:	bc 01       	movw	r22, r24
    27ce:	cd 01       	movw	r24, r26
    27d0:	9f 77       	andi	r25, 0x7F	; 127
    27d2:	20 eb       	ldi	r18, 0xB0	; 176
    27d4:	3b ef       	ldi	r19, 0xFB	; 251
    27d6:	4e e0       	ldi	r20, 0x0E	; 14
    27d8:	5d e3       	ldi	r21, 0x3D	; 61
    27da:	0e 94 cb 32 	call	0x6596	; 0x6596 <__gesf2>
    27de:	18 16       	cp	r1, r24
    27e0:	44 f4       	brge	.+16     	; 0x27f2 <vMainPoseEstimatorTask+0x31e>
                // If we have a reading over this, we can safely ignore the compass
                // Ignore compass while driving in a straight line
                kalmanGain = 0;
                vLED_singleLow(ledYELLOW);
    27e2:	81 e0       	ldi	r24, 0x01	; 1
    27e4:	90 e0       	ldi	r25, 0x00	; 0
    27e6:	91 d8       	rcall	.-3806   	; 0x190a <vLED_singleLow>
            //kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
            ///* Commented back in due to fixed encoder
            if (fabs(error) > (0.8727*period_in_S)){ // 0.8727 rad/s is top speed while turning
                // If we have a reading over this, we can safely ignore the compass
                // Ignore compass while driving in a straight line
                kalmanGain = 0;
    27e8:	14 2d       	mov	r17, r4
    27ea:	03 2d       	mov	r16, r3
    27ec:	f2 2c       	mov	r15, r2
    27ee:	e5 2c       	mov	r14, r5
    27f0:	2c c0       	rjmp	.+88     	; 0x284a <vMainPoseEstimatorTask+0x376>
                vLED_singleLow(ledYELLOW);
            }
            else if ((robot_is_turning == FALSE) && (dRobot == 0)){
    27f2:	89 a9       	ldd	r24, Y+49	; 0x31
    27f4:	81 11       	cpse	r24, r1
    27f6:	22 c0       	rjmp	.+68     	; 0x283c <vMainPoseEstimatorTask+0x368>
    27f8:	24 2d       	mov	r18, r4
    27fa:	33 2d       	mov	r19, r3
    27fc:	42 2d       	mov	r20, r2
    27fe:	55 2d       	mov	r21, r5
    2800:	69 89       	ldd	r22, Y+17	; 0x11
    2802:	7a 89       	ldd	r23, Y+18	; 0x12
    2804:	8b 89       	ldd	r24, Y+19	; 0x13
    2806:	9c 89       	ldd	r25, Y+20	; 0x14
    2808:	0e 94 1b 31 	call	0x6236	; 0x6236 <__cmpsf2>
    280c:	81 11       	cpse	r24, r1
    280e:	16 c0       	rjmp	.+44     	; 0x283c <vMainPoseEstimatorTask+0x368>
                // Updated (a posteriori) state estimate
                kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
    2810:	21 e2       	ldi	r18, 0x21	; 33
    2812:	30 eb       	ldi	r19, 0xB0	; 176
    2814:	42 eb       	ldi	r20, 0xB2	; 178
    2816:	5e e3       	ldi	r21, 0x3E	; 62
    2818:	c5 01       	movw	r24, r10
    281a:	b4 01       	movw	r22, r8
    281c:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    2820:	9b 01       	movw	r18, r22
    2822:	ac 01       	movw	r20, r24
    2824:	c5 01       	movw	r24, r10
    2826:	b4 01       	movw	r22, r8
    2828:	0e 94 22 31 	call	0x6244	; 0x6244 <__divsf3>
    282c:	16 2f       	mov	r17, r22
    282e:	07 2f       	mov	r16, r23
    2830:	f8 2e       	mov	r15, r24
    2832:	e9 2e       	mov	r14, r25
                vLED_singleHigh(ledYELLOW);
    2834:	81 e0       	ldi	r24, 0x01	; 1
    2836:	90 e0       	ldi	r25, 0x00	; 0
    2838:	4e d8       	rcall	.-3940   	; 0x18d6 <vLED_singleHigh>
    283a:	07 c0       	rjmp	.+14     	; 0x284a <vMainPoseEstimatorTask+0x376>
            }
            else{
                kalmanGain = 0;
                vLED_singleLow(ledYELLOW);
    283c:	81 e0       	ldi	r24, 0x01	; 1
    283e:	90 e0       	ldi	r25, 0x00	; 0
    2840:	64 d8       	rcall	.-3896   	; 0x190a <vLED_singleLow>
                // Updated (a posteriori) state estimate
                kalmanGain = covariance_filter_predicted / (covariance_filter_predicted + CONST_VARIANCE_COMPASS);
                vLED_singleHigh(ledYELLOW);
            }
            else{
                kalmanGain = 0;
    2842:	14 2d       	mov	r17, r4
    2844:	03 2d       	mov	r16, r3
    2846:	f2 2c       	mov	r15, r2
    2848:	e5 2c       	mov	r14, r5
                vLED_singleLow(ledYELLOW);
            }            
            //*/
           
            predictedTheta  += kalmanGain*(error);
    284a:	2f 81       	ldd	r18, Y+7	; 0x07
    284c:	38 85       	ldd	r19, Y+8	; 0x08
    284e:	49 85       	ldd	r20, Y+9	; 0x09
    2850:	5a 85       	ldd	r21, Y+10	; 0x0a
    2852:	61 2f       	mov	r22, r17
    2854:	70 2f       	mov	r23, r16
    2856:	8f 2d       	mov	r24, r15
    2858:	9e 2d       	mov	r25, r14
    285a:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    285e:	9b 01       	movw	r18, r22
    2860:	ac 01       	movw	r20, r24
    2862:	69 81       	ldd	r22, Y+1	; 0x01
    2864:	7a 81       	ldd	r23, Y+2	; 0x02
    2866:	8b 81       	ldd	r24, Y+3	; 0x03
    2868:	9c 81       	ldd	r25, Y+4	; 0x04
    286a:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    286e:	69 83       	std	Y+1, r22	; 0x01
    2870:	7a 83       	std	Y+2, r23	; 0x02
    2872:	8b 83       	std	Y+3, r24	; 0x03
    2874:	9c 83       	std	Y+4, r25	; 0x04
			vFunc_Inf2pi(&predictedTheta);            
    2876:	ce 01       	movw	r24, r28
    2878:	01 96       	adiw	r24, 0x01	; 1
    287a:	0e 94 4a 08 	call	0x1094	; 0x1094 <vFunc_Inf2pi>
            
            // Updated (a posteriori) estimate covariance
            covariance_filter_predicted = (1 - kalmanGain) * covariance_filter_predicted;  
    287e:	21 2f       	mov	r18, r17
    2880:	30 2f       	mov	r19, r16
    2882:	4f 2d       	mov	r20, r15
    2884:	5e 2d       	mov	r21, r14
    2886:	60 e0       	ldi	r22, 0x00	; 0
    2888:	70 e0       	ldi	r23, 0x00	; 0
    288a:	80 e8       	ldi	r24, 0x80	; 128
    288c:	9f e3       	ldi	r25, 0x3F	; 63
    288e:	0e 94 54 30 	call	0x60a8	; 0x60a8 <__subsf3>
    2892:	a5 01       	movw	r20, r10
    2894:	94 01       	movw	r18, r8
    2896:	0e 94 d6 32 	call	0x65ac	; 0x65ac <__mulsf3>
    289a:	6d a7       	std	Y+45, r22	; 0x2d
    289c:	7e a7       	std	Y+46, r23	; 0x2e
    289e:	8f a7       	std	Y+47, r24	; 0x2f
    28a0:	98 ab       	std	Y+48, r25	; 0x30

			//DEBUG START
			static int16_t messageCounter = 0;
			if (messageCounter == 2){
    28a2:	80 91 b5 19 	lds	r24, 0x19B5	; 0x8019b5 <messageCounter.3544>
    28a6:	90 91 b6 19 	lds	r25, 0x19B6	; 0x8019b6 <messageCounter.3544+0x1>
    28aa:	82 30       	cpi	r24, 0x02	; 2
    28ac:	91 05       	cpc	r25, r1
    28ae:	29 f4       	brne	.+10     	; 0x28ba <vMainPoseEstimatorTask+0x3e6>
				messageCounter = 0;
    28b0:	10 92 b6 19 	sts	0x19B6, r1	; 0x8019b6 <messageCounter.3544+0x1>
    28b4:	10 92 b5 19 	sts	0x19B5, r1	; 0x8019b5 <messageCounter.3544>
    28b8:	05 c0       	rjmp	.+10     	; 0x28c4 <vMainPoseEstimatorTask+0x3f0>
				//printf("%i\n",leftWheelTicks);
				
				}else{
				messageCounter = messageCounter + 1;
    28ba:	01 96       	adiw	r24, 0x01	; 1
    28bc:	90 93 b6 19 	sts	0x19B6, r25	; 0x8019b6 <messageCounter.3544+0x1>
    28c0:	80 93 b5 19 	sts	0x19B5, r24	; 0x8019b5 <messageCounter.3544>
			}
			//DEBUG END

            // Update pose
            xSemaphoreTake(xPoseMutex, 15 / portTICK_PERIOD_MS);
    28c4:	20 e0       	ldi	r18, 0x00	; 0
    28c6:	4f e0       	ldi	r20, 0x0F	; 15
    28c8:	50 e0       	ldi	r21, 0x00	; 0
    28ca:	60 e0       	ldi	r22, 0x00	; 0
    28cc:	70 e0       	ldi	r23, 0x00	; 0
    28ce:	80 91 37 1b 	lds	r24, 0x1B37	; 0x801b37 <xPoseMutex>
    28d2:	90 91 38 1b 	lds	r25, 0x1B38	; 0x801b38 <xPoseMutex+0x1>
    28d6:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
                gTheta_hat = predictedTheta;
    28da:	89 81       	ldd	r24, Y+1	; 0x01
    28dc:	9a 81       	ldd	r25, Y+2	; 0x02
    28de:	ab 81       	ldd	r26, Y+3	; 0x03
    28e0:	bc 81       	ldd	r27, Y+4	; 0x04
    28e2:	80 93 bf 19 	sts	0x19BF, r24	; 0x8019bf <gTheta_hat>
    28e6:	90 93 c0 19 	sts	0x19C0, r25	; 0x8019c0 <gTheta_hat+0x1>
    28ea:	a0 93 c1 19 	sts	0x19C1, r26	; 0x8019c1 <gTheta_hat+0x2>
    28ee:	b0 93 c2 19 	sts	0x19C2, r27	; 0x8019c2 <gTheta_hat+0x3>
                gX_hat = predictedX;
    28f2:	6d 89       	ldd	r22, Y+21	; 0x15
    28f4:	7e 89       	ldd	r23, Y+22	; 0x16
    28f6:	8f 89       	ldd	r24, Y+23	; 0x17
    28f8:	98 8d       	ldd	r25, Y+24	; 0x18
    28fa:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
    28fe:	70 93 be 19 	sts	0x19BE, r23	; 0x8019be <gX_hat+0x1>
    2902:	60 93 bd 19 	sts	0x19BD, r22	; 0x8019bd <gX_hat>
                gY_hat = predictedY;
    2906:	69 8d       	ldd	r22, Y+25	; 0x19
    2908:	7a 8d       	ldd	r23, Y+26	; 0x1a
    290a:	8b 8d       	ldd	r24, Y+27	; 0x1b
    290c:	9c 8d       	ldd	r25, Y+28	; 0x1c
    290e:	0e 94 8a 31 	call	0x6314	; 0x6314 <__fixsfsi>
    2912:	70 93 bc 19 	sts	0x19BC, r23	; 0x8019bc <gY_hat+0x1>
    2916:	60 93 bb 19 	sts	0x19BB, r22	; 0x8019bb <gY_hat>
            xSemaphoreGive(xPoseMutex);
    291a:	60 e0       	ldi	r22, 0x00	; 0
    291c:	70 e0       	ldi	r23, 0x00	; 0
    291e:	80 91 37 1b 	lds	r24, 0x1B37	; 0x801b37 <xPoseMutex>
    2922:	90 91 38 1b 	lds	r25, 0x1B38	; 0x801b38 <xPoseMutex+0x1>
    2926:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
            // Send semaphore to controller
            xSemaphoreGive(xControllerBSem);
    292a:	60 e0       	ldi	r22, 0x00	; 0
    292c:	70 e0       	ldi	r23, 0x00	; 0
    292e:	80 91 2f 1b 	lds	r24, 0x1B2F	; 0x801b2f <xControllerBSem>
    2932:	90 91 30 1b 	lds	r25, 0x1B30	; 0x801b30 <xControllerBSem+0x1>
    2936:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
            xSemaphoreGive(xTickMutex);
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
    293a:	6f a0       	ldd	r6, Y+39	; 0x27
    293c:	78 a4       	ldd	r7, Y+40	; 0x28
                rightWheelTicks = gRightWheelTicks;
            xSemaphoreGive(xTickMutex);
            
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
    293e:	8d a1       	ldd	r24, Y+37	; 0x25
    2940:	9e a1       	ldd	r25, Y+38	; 0x26
    2942:	9a 8b       	std	Y+18, r25	; 0x12
    2944:	89 8b       	std	Y+17, r24	; 0x11
    2946:	f4 cd       	rjmp	.-1048   	; 0x2530 <vMainPoseEstimatorTask+0x5c>
    2948:	05 e6       	ldi	r16, 0x65	; 101
    294a:	10 e0       	ldi	r17, 0x00	; 0
    294c:	c4 2c       	mov	r12, r4
    294e:	d3 2c       	mov	r13, r3
    2950:	e2 2c       	mov	r14, r2
    2952:	f5 2c       	mov	r15, r5
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
                gyro+= fIMU_readFloatGyroZ();
    2954:	0e 94 62 0c 	call	0x18c4	; 0x18c4 <fIMU_readFloatGyroZ>
    2958:	9b 01       	movw	r18, r22
    295a:	ac 01       	movw	r20, r24
    295c:	6c 2d       	mov	r22, r12
    295e:	7d 2d       	mov	r23, r13
    2960:	8e 2d       	mov	r24, r14
    2962:	9f 2d       	mov	r25, r15
    2964:	0e 94 55 30 	call	0x60aa	; 0x60aa <__addsf3>
    2968:	c6 2e       	mov	r12, r22
    296a:	d7 2e       	mov	r13, r23
    296c:	e8 2e       	mov	r14, r24
    296e:	f9 2e       	mov	r15, r25
    2970:	01 50       	subi	r16, 0x01	; 1
    2972:	11 09       	sbc	r17, r1
        else{
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
    2974:	79 f7       	brne	.-34     	; 0x2954 <vMainPoseEstimatorTask+0x480>
                gyro+= fIMU_readFloatGyroZ();
            }
            
            int16_t xCom, yCom, zCom;
            vCOM_getData(&xCom, &yCom, &zCom);
    2976:	ae 01       	movw	r20, r28
    2978:	49 5f       	subi	r20, 0xF9	; 249
    297a:	5f 4f       	sbci	r21, 0xFF	; 255
    297c:	be 01       	movw	r22, r28
    297e:	65 5f       	subi	r22, 0xF5	; 245
    2980:	7f 4f       	sbci	r23, 0xFF	; 255
    2982:	ce 01       	movw	r24, r28
    2984:	0d 96       	adiw	r24, 0x0d	; 13
    2986:	0e 94 b0 07 	call	0xf60	; 0xf60 <vCOM_getData>
            xCom += xComOff;
    298a:	6d 85       	ldd	r22, Y+13	; 0x0d
    298c:	7e 85       	ldd	r23, Y+14	; 0x0e
    298e:	65 5f       	subi	r22, 0xF5	; 245
    2990:	7f 4f       	sbci	r23, 0xFF	; 255
            yCom += yComOff;
    2992:	0b 85       	ldd	r16, Y+11	; 0x0b
    2994:	1c 85       	ldd	r17, Y+12	; 0x0c
    2996:	0e 54       	subi	r16, 0x4E	; 78
    2998:	11 09       	sbc	r17, r1
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
            predictedY = 0;
            predictedTheta = 0;
    299a:	84 2d       	mov	r24, r4
    299c:	93 2d       	mov	r25, r3
    299e:	a2 2d       	mov	r26, r2
    29a0:	b5 2d       	mov	r27, r5
    29a2:	89 83       	std	Y+1, r24	; 0x01
    29a4:	9a 83       	std	Y+2, r25	; 0x02
    29a6:	ab 83       	std	Y+3, r26	; 0x03
    29a8:	bc 83       	std	Y+4, r27	; 0x04
            
            compassOffset = atan2(yCom, xCom);    
    29aa:	07 2e       	mov	r0, r23
    29ac:	00 0c       	add	r0, r0
    29ae:	88 0b       	sbc	r24, r24
    29b0:	99 0b       	sbc	r25, r25
    29b2:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    29b6:	4b 01       	movw	r8, r22
    29b8:	5c 01       	movw	r10, r24
    29ba:	b8 01       	movw	r22, r16
    29bc:	11 0f       	add	r17, r17
    29be:	88 0b       	sbc	r24, r24
    29c0:	99 0b       	sbc	r25, r25
    29c2:	0e 94 bd 31 	call	0x637a	; 0x637a <__floatsisf>
    29c6:	a5 01       	movw	r20, r10
    29c8:	94 01       	movw	r18, r8
    29ca:	0e 94 c8 30 	call	0x6190	; 0x6190 <atan2>
    29ce:	69 a3       	std	Y+33, r22	; 0x21
    29d0:	7a a3       	std	Y+34, r23	; 0x22
    29d2:	8b a3       	std	Y+35, r24	; 0x23
    29d4:	9c a3       	std	Y+36, r25	; 0x24
            gyroOffset = gyro / (float)i;               
    29d6:	20 e0       	ldi	r18, 0x00	; 0
    29d8:	30 e0       	ldi	r19, 0x00	; 0
    29da:	4a ec       	ldi	r20, 0xCA	; 202
    29dc:	52 e4       	ldi	r21, 0x42	; 66
    29de:	6c 2d       	mov	r22, r12
    29e0:	7d 2d       	mov	r23, r13
    29e2:	8e 2d       	mov	r24, r14
    29e4:	9f 2d       	mov	r25, r15
    29e6:	0e 94 22 31 	call	0x6244	; 0x6244 <__divsf3>
    29ea:	6d 8f       	std	Y+29, r22	; 0x1d
    29ec:	7e 8f       	std	Y+30, r23	; 0x1e
    29ee:	8f 8f       	std	Y+31, r24	; 0x1f
    29f0:	98 a3       	std	Y+32, r25	; 0x20
            yCom += yComOff;
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
            predictedY = 0;
    29f2:	49 8e       	std	Y+25, r4	; 0x19
    29f4:	3a 8e       	std	Y+26, r3	; 0x1a
    29f6:	2b 8e       	std	Y+27, r2	; 0x1b
    29f8:	5c 8e       	std	Y+28, r5	; 0x1c
            xCom += xComOff;
            yCom += yComOff;
            
            
            // Initialize pose to 0 and reset offset variables
            predictedX = 0;
    29fa:	4d 8a       	std	Y+21, r4	; 0x15
    29fc:	3e 8a       	std	Y+22, r3	; 0x16
    29fe:	2f 8a       	std	Y+23, r2	; 0x17
    2a00:	58 8e       	std	Y+24, r5	; 0x18
    2a02:	96 cd       	rjmp	.-1236   	; 0x2530 <vMainPoseEstimatorTask+0x5c>

00002a04 <vApplicationStackOverflowHook>:
}
#endif

/*  In case of stack overflow, disable all interrupts and handle it  */
void vApplicationStackOverflowHook(TaskHandle_t *pxTask, signed char *pcTaskName){
    cli();
    2a04:	f8 94       	cli
    /*  Handle overflow */
    #ifdef DEBUG
       debug("Overflow\n");
    #endif
    while(1){
        vLED_toggle(ledRED);
    2a06:	80 e0       	ldi	r24, 0x00	; 0
    2a08:	90 e0       	ldi	r25, 0x00	; 0
    2a0a:	0e 94 9f 0c 	call	0x193e	; 0x193e <vLED_toggle>
        //ledPORT ^= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    }// While(1) end
    2a0e:	fb cf       	rjmp	.-10     	; 0x2a06 <vApplicationStackOverflowHook+0x2>

00002a10 <main>:

/*  Main function   */
int main(void){
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */
    vLED_init();
    2a10:	0e 94 65 0c 	call	0x18ca	; 0x18ca <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    2a14:	80 e0       	ldi	r24, 0x00	; 0
    2a16:	90 e0       	ldi	r25, 0x00	; 0
    2a18:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    2a1c:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <vUSART_init>
    network_init();
    2a20:	23 d2       	rcall	.+1094   	; 0x2e68 <network_init>
    arq_init();
    2a22:	0e 94 43 01 	call	0x286	; 0x286 <arq_init>
    simple_p_init(server_receiver);
    2a26:	8d e2       	ldi	r24, 0x2D	; 45
    2a28:	90 e2       	ldi	r25, 0x20	; 32
    2a2a:	0e 94 18 22 	call	0x4430	; 0x4430 <simple_p_init>
        debug("tictoc!\n");
        tic;
    #endif
    
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    2a2e:	80 e0       	ldi	r24, 0x00	; 0
    2a30:	0e 94 94 21 	call	0x4328	; 0x4328 <vServo_init>
    /* Initialize sensors */
    vDistSens_init();
    2a34:	0e 94 15 08 	call	0x102a	; 0x102a <vDistSens_init>
    /* Initialize motor controller */
    vMotor_init();
    2a38:	07 d1       	rcall	.+526    	; 0x2c48 <vMotor_init>
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        debug("IMU init..\n");
    #endif
    sIMU_begin(); 
    2a3a:	0e 94 db 0a 	call	0x15b6	; 0x15b6 <sIMU_begin>
    /* Connected with I2C, if the chip has no power, MCU will lock. */
    #ifdef DEBUG
            debug("Compass init..\n");
    #endif
    
    vCOM_init();
    2a3e:	0e 94 8c 07 	call	0xf18	; 0xf18 <vCOM_init>
    
    /* Initialize RTOS utilities  */
    movementQ = xQueueCreate(2,sizeof(uint8_t)); // For sending movements to vMainMovementTask
    2a42:	40 e0       	ldi	r20, 0x00	; 0
    2a44:	61 e0       	ldi	r22, 0x01	; 1
    2a46:	82 e0       	ldi	r24, 0x02	; 2
    2a48:	26 d4       	rcall	.+2124   	; 0x3296 <xQueueGenericCreate>
    2a4a:	90 93 ce 19 	sts	0x19CE, r25	; 0x8019ce <movementQ+0x1>
    2a4e:	80 93 cd 19 	sts	0x19CD, r24	; 0x8019cd <movementQ>
    poseControllerQ = xQueueCreate(1, sizeof(struct sPolar)); // For setpoints to controller
    2a52:	40 e0       	ldi	r20, 0x00	; 0
    2a54:	66 e0       	ldi	r22, 0x06	; 6
    2a56:	81 e0       	ldi	r24, 0x01	; 1
    2a58:	1e d4       	rcall	.+2108   	; 0x3296 <xQueueGenericCreate>
    2a5a:	90 93 cc 19 	sts	0x19CC, r25	; 0x8019cc <poseControllerQ+0x1>
    2a5e:	80 93 cb 19 	sts	0x19CB, r24	; 0x8019cb <poseControllerQ>
    scanStatusQ = xQueueCreate(1,sizeof(uint8_t)); // For robot status
    2a62:	40 e0       	ldi	r20, 0x00	; 0
    2a64:	61 e0       	ldi	r22, 0x01	; 1
    2a66:	81 e0       	ldi	r24, 0x01	; 1
    2a68:	16 d4       	rcall	.+2092   	; 0x3296 <xQueueGenericCreate>
    2a6a:	90 93 ca 19 	sts	0x19CA, r25	; 0x8019ca <scanStatusQ+0x1>
    2a6e:	80 93 c9 19 	sts	0x19C9, r24	; 0x8019c9 <scanStatusQ>
    actuationQ = xQueueCreate(2,sizeof(uint8_t)); // To send variable actuation to motors
    2a72:	40 e0       	ldi	r20, 0x00	; 0
    2a74:	61 e0       	ldi	r22, 0x01	; 1
    2a76:	82 e0       	ldi	r24, 0x02	; 2
    2a78:	0e d4       	rcall	.+2076   	; 0x3296 <xQueueGenericCreate>
    2a7a:	90 93 c8 19 	sts	0x19C8, r25	; 0x8019c8 <actuationQ+0x1>
    2a7e:	80 93 c7 19 	sts	0x19C7, r24	; 0x8019c7 <actuationQ>
    
    xPoseMutex = xSemaphoreCreateMutex(); // Global variables for robot pose. Only updated from estimator, accessed from many
    2a82:	81 e0       	ldi	r24, 0x01	; 1
    2a84:	5a d4       	rcall	.+2228   	; 0x333a <xQueueCreateMutex>
    2a86:	90 93 38 1b 	sts	0x1B38, r25	; 0x801b38 <xPoseMutex+0x1>
    2a8a:	80 93 37 1b 	sts	0x1B37, r24	; 0x801b37 <xPoseMutex>
    xUartMutex = xSemaphoreCreateMutex(); // Protected printf with a mutex, may cause fragmented bytes if higher priority task want to print as well
    2a8e:	81 e0       	ldi	r24, 0x01	; 1
    2a90:	54 d4       	rcall	.+2216   	; 0x333a <xQueueCreateMutex>
    2a92:	90 93 34 1b 	sts	0x1B34, r25	; 0x801b34 <xUartMutex+0x1>
    2a96:	80 93 33 1b 	sts	0x1B33, r24	; 0x801b33 <xUartMutex>
    xTickMutex = xSemaphoreCreateMutex(); // Global variable to hold robot tick values
    2a9a:	81 e0       	ldi	r24, 0x01	; 1
    2a9c:	4e d4       	rcall	.+2204   	; 0x333a <xQueueCreateMutex>
    2a9e:	90 93 32 1b 	sts	0x1B32, r25	; 0x801b32 <xTickMutex+0x1>
    2aa2:	80 93 31 1b 	sts	0x1B31, r24	; 0x801b31 <xTickMutex>
    
    xControllerBSem = xSemaphoreCreateBinary(); // Estimator to Controller synchronization
    2aa6:	43 e0       	ldi	r20, 0x03	; 3
    2aa8:	60 e0       	ldi	r22, 0x00	; 0
    2aaa:	81 e0       	ldi	r24, 0x01	; 1
    2aac:	f4 d3       	rcall	.+2024   	; 0x3296 <xQueueGenericCreate>
    2aae:	90 93 30 1b 	sts	0x1B30, r25	; 0x801b30 <xControllerBSem+0x1>
    2ab2:	80 93 2f 1b 	sts	0x1B2F, r24	; 0x801b2f <xControllerBSem>
    xCommandReadyBSem = xSemaphoreCreateBinary(); // uart ISR to comm task sync
    2ab6:	43 e0       	ldi	r20, 0x03	; 3
    2ab8:	60 e0       	ldi	r22, 0x00	; 0
    2aba:	81 e0       	ldi	r24, 0x01	; 1
    2abc:	ec d3       	rcall	.+2008   	; 0x3296 <xQueueGenericCreate>
    2abe:	90 93 36 1b 	sts	0x1B36, r25	; 0x801b36 <xCommandReadyBSem+0x1>
    2ac2:	80 93 35 1b 	sts	0x1B35, r24	; 0x801b35 <xCommandReadyBSem>
    
    // Todo: Check return variable to ensure RTOS utilities were successfully initialized before continue
    xTaskCreate(vMainMovementTask, "Movement", 300, NULL, 4, NULL); // Independent task, uses ticks from ISR
    2ac6:	a1 2c       	mov	r10, r1
    2ac8:	b1 2c       	mov	r11, r1
    2aca:	c1 2c       	mov	r12, r1
    2acc:	d1 2c       	mov	r13, r1
    2ace:	e1 2c       	mov	r14, r1
    2ad0:	f1 2c       	mov	r15, r1
    2ad2:	04 e0       	ldi	r16, 0x04	; 4
    2ad4:	20 e0       	ldi	r18, 0x00	; 0
    2ad6:	30 e0       	ldi	r19, 0x00	; 0
    2ad8:	4c e2       	ldi	r20, 0x2C	; 44
    2ada:	51 e0       	ldi	r21, 0x01	; 1
    2adc:	6f e0       	ldi	r22, 0x0F	; 15
    2ade:	76 e0       	ldi	r23, 0x06	; 6
    2ae0:	8f e1       	ldi	r24, 0x1F	; 31
    2ae2:	9e e0       	ldi	r25, 0x0E	; 14
    2ae4:	0e 94 b9 22 	call	0x4572	; 0x4572 <xTaskGenericCreate>
    xTaskCreate(vMainCommunicationTask, "Comm", 300, NULL, 3, NULL); // Dependant on ISR from UART, sends instructions to other tasks
    2ae8:	03 e0       	ldi	r16, 0x03	; 3
    2aea:	20 e0       	ldi	r18, 0x00	; 0
    2aec:	30 e0       	ldi	r19, 0x00	; 0
    2aee:	4c e2       	ldi	r20, 0x2C	; 44
    2af0:	51 e0       	ldi	r21, 0x01	; 1
    2af2:	68 e1       	ldi	r22, 0x18	; 24
    2af4:	76 e0       	ldi	r23, 0x06	; 6
    2af6:	86 e4       	ldi	r24, 0x46	; 70
    2af8:	9d e0       	ldi	r25, 0x0D	; 13
    2afa:	0e 94 b9 22 	call	0x4572	; 0x4572 <xTaskGenericCreate>
    
    #ifndef COMPASS_CALIBRATE // If compass calibration task is running dont use these tasks
        xTaskCreate(vMainPoseControllerTask, "PoseCon", 300, NULL, 2, NULL); // Dependant on estimator, sends instructions to movement task
    2afe:	02 e0       	ldi	r16, 0x02	; 2
    2b00:	20 e0       	ldi	r18, 0x00	; 0
    2b02:	30 e0       	ldi	r19, 0x00	; 0
    2b04:	4c e2       	ldi	r20, 0x2C	; 44
    2b06:	51 e0       	ldi	r21, 0x01	; 1
    2b08:	6d e1       	ldi	r22, 0x1D	; 29
    2b0a:	76 e0       	ldi	r23, 0x06	; 6
    2b0c:	81 e8       	ldi	r24, 0x81	; 129
    2b0e:	9f e0       	ldi	r25, 0x0F	; 15
    2b10:	0e 94 b9 22 	call	0x4572	; 0x4572 <xTaskGenericCreate>
        xTaskCreate(vMainPoseEstimatorTask, "PoseEst", 300, NULL, 5, NULL); // Independent task, uses ticks from ISR
    2b14:	05 e0       	ldi	r16, 0x05	; 5
    2b16:	20 e0       	ldi	r18, 0x00	; 0
    2b18:	30 e0       	ldi	r19, 0x00	; 0
    2b1a:	4c e2       	ldi	r20, 0x2C	; 44
    2b1c:	51 e0       	ldi	r21, 0x01	; 1
    2b1e:	65 e2       	ldi	r22, 0x25	; 37
    2b20:	76 e0       	ldi	r23, 0x06	; 6
    2b22:	8a e6       	ldi	r24, 0x6A	; 106
    2b24:	92 e1       	ldi	r25, 0x12	; 18
    2b26:	0e 94 b9 22 	call	0x4572	; 0x4572 <xTaskGenericCreate>
        xTaskCreate(vMainSensorTowerTask,"Tower",300, NULL, 1, NULL); // Independent task, but use pose updates from estimator
    2b2a:	01 e0       	ldi	r16, 0x01	; 1
    2b2c:	20 e0       	ldi	r18, 0x00	; 0
    2b2e:	30 e0       	ldi	r19, 0x00	; 0
    2b30:	4c e2       	ldi	r20, 0x2C	; 44
    2b32:	51 e0       	ldi	r21, 0x01	; 1
    2b34:	6d e2       	ldi	r22, 0x2D	; 45
    2b36:	76 e0       	ldi	r23, 0x06	; 6
    2b38:	80 e3       	ldi	r24, 0x30	; 48
    2b3a:	9e e0       	ldi	r25, 0x0E	; 14
    2b3c:	0e 94 b9 22 	call	0x4572	; 0x4572 <xTaskGenericCreate>
        xTaskCreate(compassTask, "compasscal", 3500, NULL, 3, NULL); // Task used for compass calibration, dependant on communication and movement task
    #endif
    
    

    sei();
    2b40:	78 94       	sei
    vLED_singleLow(ledRED);
    2b42:	80 e0       	ldi	r24, 0x00	; 0
    2b44:	90 e0       	ldi	r25, 0x00	; 0
    2b46:	0e 94 85 0c 	call	0x190a	; 0x190a <vLED_singleLow>
    #ifdef DEBUG
    debug("Starting scheduler ....\n");
    #endif
    /*  Start scheduler */
    vTaskStartScheduler();
    2b4a:	0e 94 f5 26 	call	0x4dea	; 0x4dea <vTaskStartScheduler>

    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
        debug("RAM fail\n");
    2b4e:	c3 e3       	ldi	r28, 0x33	; 51
    2b50:	d6 e0       	ldi	r29, 0x06	; 6
    /*  Start scheduler */
    vTaskStartScheduler();

    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
    2b52:	f8 94       	cli
        debug("RAM fail\n");
    2b54:	df 93       	push	r29
    2b56:	cf 93       	push	r28
    2b58:	0e 94 23 21 	call	0x4246	; 0x4246 <debug>
    }
    2b5c:	0f 90       	pop	r0
    2b5e:	0f 90       	pop	r0
    2b60:	f8 cf       	rjmp	.-16     	; 0x2b52 <main+0x142>

00002b62 <__vector_4>:

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    2b62:	1f 92       	push	r1
    2b64:	0f 92       	push	r0
    2b66:	0f b6       	in	r0, 0x3f	; 63
    2b68:	0f 92       	push	r0
    2b6a:	11 24       	eor	r1, r1
    2b6c:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    2b6e:	80 91 c5 19 	lds	r24, 0x19C5	; 0x8019c5 <gISR_leftWheelTicks>
    2b72:	8f 5f       	subi	r24, 0xFF	; 255
    2b74:	80 93 c5 19 	sts	0x19C5, r24	; 0x8019c5 <gISR_leftWheelTicks>
}
    2b78:	8f 91       	pop	r24
    2b7a:	0f 90       	pop	r0
    2b7c:	0f be       	out	0x3f, r0	; 63
    2b7e:	0f 90       	pop	r0
    2b80:	1f 90       	pop	r1
    2b82:	18 95       	reti

00002b84 <__vector_3>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    2b84:	1f 92       	push	r1
    2b86:	0f 92       	push	r0
    2b88:	0f b6       	in	r0, 0x3f	; 63
    2b8a:	0f 92       	push	r0
    2b8c:	11 24       	eor	r1, r1
    2b8e:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    2b90:	80 91 c6 19 	lds	r24, 0x19C6	; 0x8019c6 <gISR_rightWheelTicks>
    2b94:	8f 5f       	subi	r24, 0xFF	; 255
    2b96:	80 93 c6 19 	sts	0x19C6, r24	; 0x8019c6 <gISR_rightWheelTicks>
}
    2b9a:	8f 91       	pop	r24
    2b9c:	0f 90       	pop	r0
    2b9e:	0f be       	out	0x3f, r0	; 63
    2ba0:	0f 90       	pop	r0
    2ba2:	1f 90       	pop	r1
    2ba4:	18 95       	reti

00002ba6 <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    2ba6:	1f 92       	push	r1
    2ba8:	0f 92       	push	r0
    2baa:	0f b6       	in	r0, 0x3f	; 63
    2bac:	0f 92       	push	r0
    2bae:	11 24       	eor	r1, r1
    2bb0:	0b b6       	in	r0, 0x3b	; 59
    2bb2:	0f 92       	push	r0
    2bb4:	2f 93       	push	r18
    2bb6:	3f 93       	push	r19
    2bb8:	4f 93       	push	r20
    2bba:	5f 93       	push	r21
    2bbc:	6f 93       	push	r22
    2bbe:	7f 93       	push	r23
    2bc0:	8f 93       	push	r24
    2bc2:	9f 93       	push	r25
    2bc4:	af 93       	push	r26
    2bc6:	bf 93       	push	r27
    2bc8:	ef 93       	push	r30
    2bca:	ff 93       	push	r31
    if (nRFconnected){
    2bcc:	64 99       	sbic	0x0c, 4	; 12
    2bce:	09 c0       	rjmp	.+18     	; 0x2be2 <__vector_5+0x3c>
        // indicate we are connected
        vLED_singleHigh(ledGREEN);
    2bd0:	82 e0       	ldi	r24, 0x02	; 2
    2bd2:	90 e0       	ldi	r25, 0x00	; 0
    2bd4:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <vLED_singleHigh>
        vLED_singleHigh(ledYELLOW);
    2bd8:	81 e0       	ldi	r24, 0x01	; 1
    2bda:	90 e0       	ldi	r25, 0x00	; 0
    2bdc:	0e 94 6b 0c 	call	0x18d6	; 0x18d6 <vLED_singleHigh>
    2be0:	18 c0       	rjmp	.+48     	; 0x2c12 <__vector_5+0x6c>
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    2be2:	10 92 c4 19 	sts	0x19C4, r1	; 0x8019c4 <gHandshook>
        gPaused = FALSE;
    2be6:	10 92 c3 19 	sts	0x19C3, r1	; 0x8019c3 <gPaused>
        vLED_singleLow(ledGREEN);
    2bea:	82 e0       	ldi	r24, 0x02	; 2
    2bec:	90 e0       	ldi	r25, 0x00	; 0
    2bee:	0e 94 85 0c 	call	0x190a	; 0x190a <vLED_singleLow>
        vLED_singleLow(ledYELLOW);
    2bf2:	81 e0       	ldi	r24, 0x01	; 1
    2bf4:	90 e0       	ldi	r25, 0x00	; 0
    2bf6:	0e 94 85 0c 	call	0x190a	; 0x190a <vLED_singleLow>
        vLED_singleLow(ledRED);
    2bfa:	80 e0       	ldi	r24, 0x00	; 0
    2bfc:	90 e0       	ldi	r25, 0x00	; 0
    2bfe:	0e 94 85 0c 	call	0x190a	; 0x190a <vLED_singleLow>
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    2c02:	60 e0       	ldi	r22, 0x00	; 0
    2c04:	70 e0       	ldi	r23, 0x00	; 0
    2c06:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xCommandReadyBSem>
    2c0a:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xCommandReadyBSem+0x1>
    2c0e:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <xQueueGiveFromISR>
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    2c12:	60 e0       	ldi	r22, 0x00	; 0
    2c14:	70 e0       	ldi	r23, 0x00	; 0
    2c16:	80 91 2f 1b 	lds	r24, 0x1B2F	; 0x801b2f <xControllerBSem>
    2c1a:	90 91 30 1b 	lds	r25, 0x1B30	; 0x801b30 <xControllerBSem+0x1>
    2c1e:	0e 94 62 1e 	call	0x3cc4	; 0x3cc4 <xQueueGiveFromISR>
}
    2c22:	ff 91       	pop	r31
    2c24:	ef 91       	pop	r30
    2c26:	bf 91       	pop	r27
    2c28:	af 91       	pop	r26
    2c2a:	9f 91       	pop	r25
    2c2c:	8f 91       	pop	r24
    2c2e:	7f 91       	pop	r23
    2c30:	6f 91       	pop	r22
    2c32:	5f 91       	pop	r21
    2c34:	4f 91       	pop	r20
    2c36:	3f 91       	pop	r19
    2c38:	2f 91       	pop	r18
    2c3a:	0f 90       	pop	r0
    2c3c:	0b be       	out	0x3b, r0	; 59
    2c3e:	0f 90       	pop	r0
    2c40:	0f be       	out	0x3f, r0	; 63
    2c42:	0f 90       	pop	r0
    2c44:	1f 90       	pop	r1
    2c46:	18 95       	reti

00002c48 <vMotor_init>:

void vMotorGlideRight(){
    motorRightPWM = 0;
    //PORTH &= ~(1<<motorRightOn);
    PORTA &= ~(1<<motorRightForward);
    PORTA &= ~(1<<motorRightBackward);
    2c48:	87 b1       	in	r24, 0x07	; 7
    2c4a:	80 6a       	ori	r24, 0xA0	; 160
    2c4c:	87 b9       	out	0x07, r24	; 7
    2c4e:	e1 e0       	ldi	r30, 0x01	; 1
    2c50:	f1 e0       	ldi	r31, 0x01	; 1
    2c52:	80 81       	ld	r24, Z
    2c54:	80 68       	ori	r24, 0x80	; 128
    2c56:	80 83       	st	Z, r24
    2c58:	81 b1       	in	r24, 0x01	; 1
    2c5a:	84 61       	ori	r24, 0x14	; 20
    2c5c:	81 b9       	out	0x01, r24	; 1
    2c5e:	6d 9a       	sbi	0x0d, 5	; 13
    2c60:	e2 e0       	ldi	r30, 0x02	; 2
    2c62:	f1 e0       	ldi	r31, 0x01	; 1
    2c64:	80 81       	ld	r24, Z
    2c66:	8f 7d       	andi	r24, 0xDF	; 223
    2c68:	80 83       	st	Z, r24
    2c6a:	77 98       	cbi	0x0e, 7	; 14
    2c6c:	82 b1       	in	r24, 0x02	; 2
    2c6e:	8b 7e       	andi	r24, 0xEB	; 235
    2c70:	82 b9       	out	0x02, r24	; 2
    2c72:	88 b1       	in	r24, 0x08	; 8
    2c74:	8f 75       	andi	r24, 0x5F	; 95
    2c76:	88 b9       	out	0x08, r24	; 8
    2c78:	8a b1       	in	r24, 0x0a	; 10
    2c7a:	8a b9       	out	0x0a, r24	; 10
    2c7c:	8b b1       	in	r24, 0x0b	; 11
    2c7e:	8c 60       	ori	r24, 0x0C	; 12
    2c80:	8b b9       	out	0x0b, r24	; 11
    2c82:	6c 98       	cbi	0x0d, 4	; 13
    2c84:	8d b3       	in	r24, 0x1d	; 29
    2c86:	8d bb       	out	0x1d, r24	; 29
    2c88:	e9 e6       	ldi	r30, 0x69	; 105
    2c8a:	f0 e0       	ldi	r31, 0x00	; 0
    2c8c:	80 81       	ld	r24, Z
    2c8e:	80 6f       	ori	r24, 0xF0	; 240
    2c90:	80 83       	st	Z, r24
    2c92:	ea e6       	ldi	r30, 0x6A	; 106
    2c94:	f0 e0       	ldi	r31, 0x00	; 0
    2c96:	80 81       	ld	r24, Z
    2c98:	81 60       	ori	r24, 0x01	; 1
    2c9a:	80 83       	st	Z, r24
    2c9c:	8c e1       	ldi	r24, 0x1C	; 28
    2c9e:	8c bb       	out	0x1c, r24	; 28
    2ca0:	8d b3       	in	r24, 0x1d	; 29
    2ca2:	8c 61       	ori	r24, 0x1C	; 28
    2ca4:	8d bb       	out	0x1d, r24	; 29
    2ca6:	84 b5       	in	r24, 0x24	; 36
    2ca8:	80 6a       	ori	r24, 0xA0	; 160
    2caa:	84 bd       	out	0x24, r24	; 36
    2cac:	84 b5       	in	r24, 0x24	; 36
    2cae:	83 60       	ori	r24, 0x03	; 3
    2cb0:	84 bd       	out	0x24, r24	; 36
    2cb2:	85 b5       	in	r24, 0x25	; 37
    2cb4:	85 bd       	out	0x25, r24	; 37
    2cb6:	85 b5       	in	r24, 0x25	; 37
    2cb8:	85 60       	ori	r24, 0x05	; 5
    2cba:	85 bd       	out	0x25, r24	; 37
    2cbc:	27 9a       	sbi	0x04, 7	; 4
    2cbe:	9d 9a       	sbi	0x13, 5	; 19
    2cc0:	08 95       	ret

00002cc2 <vMotorMoveLeftForward>:
    2cc2:	88 bd       	out	0x28, r24	; 40
    2cc4:	45 9a       	sbi	0x08, 5	; 8
    2cc6:	47 98       	cbi	0x08, 7	; 8
    2cc8:	85 e0       	ldi	r24, 0x05	; 5
    2cca:	fb 01       	movw	r30, r22
    2ccc:	80 83       	st	Z, r24
    2cce:	08 95       	ret

00002cd0 <vMotorMoveRightForward>:
    2cd0:	87 bd       	out	0x27, r24	; 39
    2cd2:	12 9a       	sbi	0x02, 2	; 2
    2cd4:	14 98       	cbi	0x02, 4	; 2
    2cd6:	82 e0       	ldi	r24, 0x02	; 2
    2cd8:	fb 01       	movw	r30, r22
    2cda:	80 83       	st	Z, r24
    2cdc:	08 95       	ret

00002cde <vMotorMoveLeftBackward>:
    2cde:	88 bd       	out	0x28, r24	; 40
    2ce0:	45 98       	cbi	0x08, 5	; 8
    2ce2:	47 9a       	sbi	0x08, 7	; 8
    2ce4:	87 e0       	ldi	r24, 0x07	; 7
    2ce6:	fb 01       	movw	r30, r22
    2ce8:	80 83       	st	Z, r24
    2cea:	08 95       	ret

00002cec <vMotorMoveRightBackward>:
    2cec:	87 bd       	out	0x27, r24	; 39
    2cee:	12 98       	cbi	0x02, 2	; 2
    2cf0:	14 9a       	sbi	0x02, 4	; 2
    2cf2:	84 e0       	ldi	r24, 0x04	; 4
    2cf4:	fb 01       	movw	r30, r22
    2cf6:	80 83       	st	Z, r24
    2cf8:	08 95       	ret

00002cfa <vMotorBrakeLeft>:
    2cfa:	8f ef       	ldi	r24, 0xFF	; 255
    2cfc:	88 bd       	out	0x28, r24	; 40
    2cfe:	45 98       	cbi	0x08, 5	; 8
    2d00:	47 98       	cbi	0x08, 7	; 8
    2d02:	08 95       	ret

00002d04 <vMotorBrakeRight>:
    2d04:	8f ef       	ldi	r24, 0xFF	; 255
    2d06:	87 bd       	out	0x27, r24	; 39
    2d08:	12 98       	cbi	0x02, 2	; 2
    2d0a:	14 98       	cbi	0x02, 4	; 2
    2d0c:	08 95       	ret

00002d0e <vMotorMovementSwitch>:
}

/* Switch for robot movement to abstract the logic away from main */

void vMotorMovementSwitch(int16_t leftSpeed, int16_t rightSpeed, uint8_t *leftWheelDirection, uint8_t *rightWheelDirection){
    2d0e:	0f 93       	push	r16
    2d10:	1f 93       	push	r17
    2d12:	cf 93       	push	r28
    2d14:	df 93       	push	r29
    2d16:	eb 01       	movw	r28, r22
    2d18:	89 01       	movw	r16, r18
    if (leftSpeed > 0){
    2d1a:	18 16       	cp	r1, r24
    2d1c:	19 06       	cpc	r1, r25
    2d1e:	1c f4       	brge	.+6      	; 0x2d26 <vMotorMovementSwitch+0x18>
		vMotorMoveLeftForward(leftSpeed, leftWheelDirection);
    2d20:	ba 01       	movw	r22, r20
    2d22:	cf df       	rcall	.-98     	; 0x2cc2 <vMotorMoveLeftForward>
    2d24:	07 c0       	rjmp	.+14     	; 0x2d34 <vMotorMovementSwitch+0x26>
    }else if(leftSpeed < 0){
    2d26:	99 23       	and	r25, r25
    2d28:	24 f4       	brge	.+8      	; 0x2d32 <vMotorMovementSwitch+0x24>
		vMotorMoveLeftBackward(-leftSpeed,leftWheelDirection);
    2d2a:	ba 01       	movw	r22, r20
    2d2c:	81 95       	neg	r24
    2d2e:	d7 df       	rcall	.-82     	; 0x2cde <vMotorMoveLeftBackward>
    2d30:	01 c0       	rjmp	.+2      	; 0x2d34 <vMotorMovementSwitch+0x26>
    }else{
		vMotorBrakeLeft();
    2d32:	e3 df       	rcall	.-58     	; 0x2cfa <vMotorBrakeLeft>
	}
	
	if (rightSpeed > 0) {
    2d34:	1c 16       	cp	r1, r28
    2d36:	1d 06       	cpc	r1, r29
    2d38:	24 f4       	brge	.+8      	; 0x2d42 <vMotorMovementSwitch+0x34>
		vMotorMoveRightForward(rightSpeed,rightWheelDirection);
    2d3a:	b8 01       	movw	r22, r16
    2d3c:	8c 2f       	mov	r24, r28
    2d3e:	c8 df       	rcall	.-112    	; 0x2cd0 <vMotorMoveRightForward>
    2d40:	08 c0       	rjmp	.+16     	; 0x2d52 <vMotorMovementSwitch+0x44>
	}else if (rightSpeed < 0) {
    2d42:	dd 23       	and	r29, r29
    2d44:	2c f4       	brge	.+10     	; 0x2d50 <vMotorMovementSwitch+0x42>
		vMotorMoveRightBackward(-rightSpeed,rightWheelDirection);
    2d46:	b8 01       	movw	r22, r16
    2d48:	8c 2f       	mov	r24, r28
    2d4a:	81 95       	neg	r24
    2d4c:	cf df       	rcall	.-98     	; 0x2cec <vMotorMoveRightBackward>
    2d4e:	01 c0       	rjmp	.+2      	; 0x2d52 <vMotorMovementSwitch+0x44>
	}else {
		vMotorBrakeRight();
    2d50:	d9 df       	rcall	.-78     	; 0x2d04 <vMotorBrakeRight>
	
	
	
	

}
    2d52:	df 91       	pop	r29
    2d54:	cf 91       	pop	r28
    2d56:	1f 91       	pop	r17
    2d58:	0f 91       	pop	r16
    2d5a:	08 95       	ret

00002d5c <vMotorEncoderLeftTickFromISR>:

/* Handle ISR ticks from encoder, Please note that we are losing accuracy here due to division */
void vMotorEncoderLeftTickFromISR(uint8_t wheelDirection, int16_t *leftWheelTicks, uint8_t leftEncoderTicks){
    switch (wheelDirection){
    2d5c:	85 30       	cpi	r24, 0x05	; 5
    2d5e:	19 f0       	breq	.+6      	; 0x2d66 <vMotorEncoderLeftTickFromISR+0xa>
    2d60:	87 30       	cpi	r24, 0x07	; 7
    2d62:	51 f0       	breq	.+20     	; 0x2d78 <vMotorEncoderLeftTickFromISR+0x1c>
    2d64:	08 95       	ret
        case motorLeftForward:{
            *leftWheelTicks += leftEncoderTicks / 2;
    2d66:	46 95       	lsr	r20
    2d68:	fb 01       	movw	r30, r22
    2d6a:	80 81       	ld	r24, Z
    2d6c:	91 81       	ldd	r25, Z+1	; 0x01
    2d6e:	84 0f       	add	r24, r20
    2d70:	91 1d       	adc	r25, r1
    2d72:	91 83       	std	Z+1, r25	; 0x01
    2d74:	80 83       	st	Z, r24
            break;
    2d76:	08 95       	ret
        }
        case  motorLeftBackward:{
            *leftWheelTicks -= leftEncoderTicks / 2;
    2d78:	46 95       	lsr	r20
    2d7a:	fb 01       	movw	r30, r22
    2d7c:	80 81       	ld	r24, Z
    2d7e:	91 81       	ldd	r25, Z+1	; 0x01
    2d80:	84 1b       	sub	r24, r20
    2d82:	91 09       	sbc	r25, r1
    2d84:	91 83       	std	Z+1, r25	; 0x01
    2d86:	80 83       	st	Z, r24
    2d88:	08 95       	ret

00002d8a <vMotorEncoderRightTickFromISR>:
        // We have a count when the robot is supposedly not moving.
        break;
    }
}
void vMotorEncoderRightTickFromISR(uint8_t wheelDirection, int16_t *rightWheelTicks, uint8_t rightEncoderTicks){
    switch (wheelDirection){
    2d8a:	82 30       	cpi	r24, 0x02	; 2
    2d8c:	19 f0       	breq	.+6      	; 0x2d94 <vMotorEncoderRightTickFromISR+0xa>
    2d8e:	84 30       	cpi	r24, 0x04	; 4
    2d90:	51 f0       	breq	.+20     	; 0x2da6 <vMotorEncoderRightTickFromISR+0x1c>
    2d92:	08 95       	ret
        case motorRightForward:{
            *rightWheelTicks += rightEncoderTicks / 2;
    2d94:	46 95       	lsr	r20
    2d96:	fb 01       	movw	r30, r22
    2d98:	80 81       	ld	r24, Z
    2d9a:	91 81       	ldd	r25, Z+1	; 0x01
    2d9c:	84 0f       	add	r24, r20
    2d9e:	91 1d       	adc	r25, r1
    2da0:	91 83       	std	Z+1, r25	; 0x01
    2da2:	80 83       	st	Z, r24
            break;
    2da4:	08 95       	ret
        }
        case  motorRightBackward:{
            *rightWheelTicks -= rightEncoderTicks / 2;
    2da6:	46 95       	lsr	r20
    2da8:	fb 01       	movw	r30, r22
    2daa:	80 81       	ld	r24, Z
    2dac:	91 81       	ldd	r25, Z+1	; 0x01
    2dae:	84 1b       	sub	r24, r20
    2db0:	91 09       	sbc	r25, r1
    2db2:	91 83       	std	Z+1, r25	; 0x01
    2db4:	80 83       	st	Z, r24
    2db6:	08 95       	ret

00002db8 <network_receive>:

uint8_t network_get_address(void) {
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
    2db8:	ef 92       	push	r14
    2dba:	ff 92       	push	r15
    2dbc:	0f 93       	push	r16
    2dbe:	1f 93       	push	r17
    2dc0:	cf 93       	push	r28
    2dc2:	df 93       	push	r29
    2dc4:	7c 01       	movw	r14, r24
    2dc6:	8b 01       	movw	r16, r22
   uint8_t *decoded_data = pvPortMalloc(len);
    2dc8:	cb 01       	movw	r24, r22
    2dca:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    2dce:	ec 01       	movw	r28, r24
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    2dd0:	98 01       	movw	r18, r16
    2dd2:	21 50       	subi	r18, 0x01	; 1
    2dd4:	31 09       	sbc	r19, r1
    2dd6:	a7 01       	movw	r20, r14
    2dd8:	b8 01       	movw	r22, r16
    2dda:	0e 94 0e 07 	call	0xe1c	; 0xe1c <cobs_decode>
    2dde:	26 2f       	mov	r18, r22
    2de0:	37 2f       	mov	r19, r23
    2de2:	89 01       	movw	r16, r18
   static uint8_t cobs = 0;
   static uint8_t crc = 0;
   if(result.status != COBS_DECODE_OK) {
    2de4:	88 23       	and	r24, r24
    2de6:	49 f0       	breq	.+18     	; 0x2dfa <network_receive+0x42>
	   ++cobs;
    2de8:	80 91 d0 19 	lds	r24, 0x19D0	; 0x8019d0 <cobs.1905>
    2dec:	8f 5f       	subi	r24, 0xFF	; 255
    2dee:	80 93 d0 19 	sts	0x19D0, r24	; 0x8019d0 <cobs.1905>
	   vPortFree(decoded_data);
    2df2:	ce 01       	movw	r24, r28
    2df4:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
	   return;
    2df8:	30 c0       	rjmp	.+96     	; 0x2e5a <network_receive+0xa2>
   }
   if(decoded_data[result.out_len-1] != calculate_crc(decoded_data, result.out_len-1) ) {
    2dfa:	fe 01       	movw	r30, r28
    2dfc:	e2 0f       	add	r30, r18
    2dfe:	f3 1f       	adc	r31, r19
    2e00:	31 97       	sbiw	r30, 0x01	; 1
    2e02:	f0 80       	ld	r15, Z
    2e04:	6f ef       	ldi	r22, 0xFF	; 255
    2e06:	62 0f       	add	r22, r18
    2e08:	ce 01       	movw	r24, r28
    2e0a:	0e 94 fe 07 	call	0xffc	; 0xffc <calculate_crc>
    2e0e:	f8 16       	cp	r15, r24
    2e10:	49 f0       	breq	.+18     	; 0x2e24 <network_receive+0x6c>
	   ++crc;
    2e12:	80 91 cf 19 	lds	r24, 0x19CF	; 0x8019cf <crc.1906>
    2e16:	8f 5f       	subi	r24, 0xFF	; 255
    2e18:	80 93 cf 19 	sts	0x19CF, r24	; 0x8019cf <crc.1906>
	   vPortFree(decoded_data);
    2e1c:	ce 01       	movw	r24, r28
    2e1e:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
	   return;
    2e22:	1b c0       	rjmp	.+54     	; 0x2e5a <network_receive+0xa2>
   }
   uint8_t receiver = decoded_data[0];
   uint8_t sender = decoded_data[1];
    2e24:	89 81       	ldd	r24, Y+1	; 0x01
   uint8_t protocol = decoded_data[2];
    2e26:	ea 81       	ldd	r30, Y+2	; 0x02
   if(receiver != ADDRESS) {
    2e28:	98 81       	ld	r25, Y
    2e2a:	93 30       	cpi	r25, 0x03	; 3
    2e2c:	21 f0       	breq	.+8      	; 0x2e36 <network_receive+0x7e>
	   vPortFree(decoded_data);
    2e2e:	ce 01       	movw	r24, r28
    2e30:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
	   return;
    2e34:	12 c0       	rjmp	.+36     	; 0x2e5a <network_receive+0xa2>
   }
   receive_callbacks[protocol](sender, decoded_data+3, result.out_len-4);
    2e36:	f0 e0       	ldi	r31, 0x00	; 0
    2e38:	ee 0f       	add	r30, r30
    2e3a:	ff 1f       	adc	r31, r31
    2e3c:	e9 5a       	subi	r30, 0xA9	; 169
    2e3e:	f4 4e       	sbci	r31, 0xE4	; 228
    2e40:	a8 01       	movw	r20, r16
    2e42:	44 50       	subi	r20, 0x04	; 4
    2e44:	51 09       	sbc	r21, r1
    2e46:	be 01       	movw	r22, r28
    2e48:	6d 5f       	subi	r22, 0xFD	; 253
    2e4a:	7f 4f       	sbci	r23, 0xFF	; 255
    2e4c:	01 90       	ld	r0, Z+
    2e4e:	f0 81       	ld	r31, Z
    2e50:	e0 2d       	mov	r30, r0
    2e52:	19 95       	eicall
   vPortFree(decoded_data);
    2e54:	ce 01       	movw	r24, r28
    2e56:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
}
    2e5a:	df 91       	pop	r29
    2e5c:	cf 91       	pop	r28
    2e5e:	1f 91       	pop	r17
    2e60:	0f 91       	pop	r16
    2e62:	ff 90       	pop	r15
    2e64:	ef 90       	pop	r14
    2e66:	08 95       	ret

00002e68 <network_init>:
void network_receive(uint8_t *frame, uint16_t len);

void (*receive_callbacks[10])(uint8_t, uint8_t*, uint16_t);

void network_init(void) {
  vUSART_set_receive_callback(network_receive);
    2e68:	8c ed       	ldi	r24, 0xDC	; 220
    2e6a:	96 e1       	ldi	r25, 0x16	; 22
    2e6c:	0c 94 df 2f 	jmp	0x5fbe	; 0x5fbe <vUSART_set_receive_callback>
    2e70:	08 95       	ret

00002e72 <network_set_callback>:
}

void network_set_callback(uint8_t protocol, void (*cb)(uint8_t, uint8_t*, uint16_t)) {
  if(protocol == PROTOCOL_ARQ || protocol == PROTOCOL_SIMPLE) receive_callbacks[protocol] = cb;
    2e72:	82 30       	cpi	r24, 0x02	; 2
    2e74:	40 f4       	brcc	.+16     	; 0x2e86 <network_set_callback+0x14>
    2e76:	e8 2f       	mov	r30, r24
    2e78:	f0 e0       	ldi	r31, 0x00	; 0
    2e7a:	ee 0f       	add	r30, r30
    2e7c:	ff 1f       	adc	r31, r31
    2e7e:	e9 5a       	subi	r30, 0xA9	; 169
    2e80:	f4 4e       	sbci	r31, 0xE4	; 228
    2e82:	71 83       	std	Z+1, r23	; 0x01
    2e84:	60 83       	st	Z, r22
    2e86:	08 95       	ret

00002e88 <network_send>:
}
    
uint8_t network_send(uint8_t remote_address, uint8_t protocol, uint8_t *data, uint16_t len) {
    2e88:	8f 92       	push	r8
    2e8a:	9f 92       	push	r9
    2e8c:	af 92       	push	r10
    2e8e:	bf 92       	push	r11
    2e90:	cf 92       	push	r12
    2e92:	df 92       	push	r13
    2e94:	ef 92       	push	r14
    2e96:	ff 92       	push	r15
    2e98:	0f 93       	push	r16
    2e9a:	1f 93       	push	r17
    2e9c:	cf 93       	push	r28
    2e9e:	df 93       	push	r29
    2ea0:	88 2e       	mov	r8, r24
    2ea2:	96 2e       	mov	r9, r22
    2ea4:	5a 01       	movw	r10, r20
    2ea6:	89 01       	movw	r16, r18
  uint8_t *packet = pvPortMalloc(len+4);
    2ea8:	69 01       	movw	r12, r18
    2eaa:	84 e0       	ldi	r24, 0x04	; 4
    2eac:	c8 0e       	add	r12, r24
    2eae:	d1 1c       	adc	r13, r1
    2eb0:	c6 01       	movw	r24, r12
    2eb2:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    2eb6:	ec 01       	movw	r28, r24
  uint8_t *encoded_data = pvPortMalloc(len+6);
    2eb8:	c8 01       	movw	r24, r16
    2eba:	06 96       	adiw	r24, 0x06	; 6
    2ebc:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    2ec0:	7c 01       	movw	r14, r24
  if(packet == NULL || encoded_data == NULL) {
    2ec2:	20 97       	sbiw	r28, 0x00	; 0
    2ec4:	11 f0       	breq	.+4      	; 0x2eca <network_send+0x42>
    2ec6:	89 2b       	or	r24, r25
    2ec8:	41 f4       	brne	.+16     	; 0x2eda <network_send+0x52>
    vPortFree(packet);
    2eca:	ce 01       	movw	r24, r28
    2ecc:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
    vPortFree(encoded_data);
    2ed0:	c7 01       	movw	r24, r14
    2ed2:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
    return 0;
    2ed6:	80 e0       	ldi	r24, 0x00	; 0
    2ed8:	3c c0       	rjmp	.+120    	; 0x2f52 <network_send+0xca>
  }
  packet[0] = remote_address;
    2eda:	88 82       	st	Y, r8
  packet[1] = ADDRESS;
    2edc:	83 e0       	ldi	r24, 0x03	; 3
    2ede:	89 83       	std	Y+1, r24	; 0x01
  packet[2] = protocol;
    2ee0:	9a 82       	std	Y+2, r9	; 0x02
  memcpy(packet+3, data, len);
    2ee2:	a8 01       	movw	r20, r16
    2ee4:	b5 01       	movw	r22, r10
    2ee6:	ce 01       	movw	r24, r28
    2ee8:	03 96       	adiw	r24, 0x03	; 3
    2eea:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
  packet[3+len] = calculate_crc(packet, 3+len);
    2eee:	58 01       	movw	r10, r16
    2ef0:	e3 e0       	ldi	r30, 0x03	; 3
    2ef2:	ae 0e       	add	r10, r30
    2ef4:	b1 1c       	adc	r11, r1
    2ef6:	ac 0e       	add	r10, r28
    2ef8:	bd 1e       	adc	r11, r29
    2efa:	63 e0       	ldi	r22, 0x03	; 3
    2efc:	60 0f       	add	r22, r16
    2efe:	ce 01       	movw	r24, r28
    2f00:	0e 94 fe 07 	call	0xffc	; 0xffc <calculate_crc>
    2f04:	f5 01       	movw	r30, r10
    2f06:	80 83       	st	Z, r24
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    2f08:	b8 01       	movw	r22, r16
    2f0a:	6b 5f       	subi	r22, 0xFB	; 251
    2f0c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f0e:	96 01       	movw	r18, r12
    2f10:	ae 01       	movw	r20, r28
    2f12:	c7 01       	movw	r24, r14
    2f14:	0e 94 a3 06 	call	0xd46	; 0xd46 <cobs_encode>
    2f18:	26 2f       	mov	r18, r22
    2f1a:	37 2f       	mov	r19, r23
  if(result.status != COBS_ENCODE_OK) {
    2f1c:	88 23       	and	r24, r24
    2f1e:	41 f0       	breq	.+16     	; 0x2f30 <network_send+0xa8>
    vPortFree(packet);
    2f20:	ce 01       	movw	r24, r28
    2f22:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
    vPortFree(encoded_data);
    2f26:	c7 01       	movw	r24, r14
    2f28:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
    return 0;
    2f2c:	80 e0       	ldi	r24, 0x00	; 0
    2f2e:	11 c0       	rjmp	.+34     	; 0x2f52 <network_send+0xca>
  }
  encoded_data[result.out_len] = 0x00;
    2f30:	f7 01       	movw	r30, r14
    2f32:	e2 0f       	add	r30, r18
    2f34:	f3 1f       	adc	r31, r19
    2f36:	10 82       	st	Z, r1
  vUSART_send(encoded_data, result.out_len+1);
    2f38:	b9 01       	movw	r22, r18
    2f3a:	6f 5f       	subi	r22, 0xFF	; 255
    2f3c:	7f 4f       	sbci	r23, 0xFF	; 255
    2f3e:	c7 01       	movw	r24, r14
    2f40:	0e 94 bb 2f 	call	0x5f76	; 0x5f76 <vUSART_send>
  vPortFree(packet);
    2f44:	ce 01       	movw	r24, r28
    2f46:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
  vPortFree(encoded_data);
    2f4a:	c7 01       	movw	r24, r14
    2f4c:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
  return 1;
    2f50:	81 e0       	ldi	r24, 0x01	; 1
}
    2f52:	df 91       	pop	r29
    2f54:	cf 91       	pop	r28
    2f56:	1f 91       	pop	r17
    2f58:	0f 91       	pop	r16
    2f5a:	ff 90       	pop	r15
    2f5c:	ef 90       	pop	r14
    2f5e:	df 90       	pop	r13
    2f60:	cf 90       	pop	r12
    2f62:	bf 90       	pop	r11
    2f64:	af 90       	pop	r10
    2f66:	9f 90       	pop	r9
    2f68:	8f 90       	pop	r8
    2f6a:	08 95       	ret

00002f6c <pxPortInitialiseStack>:
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    2f6c:	31 e1       	ldi	r19, 0x11	; 17
    2f6e:	fc 01       	movw	r30, r24
    2f70:	30 83       	st	Z, r19
    2f72:	31 97       	sbiw	r30, 0x01	; 1
    2f74:	22 e2       	ldi	r18, 0x22	; 34
    2f76:	20 83       	st	Z, r18
    2f78:	31 97       	sbiw	r30, 0x01	; 1
    2f7a:	a3 e3       	ldi	r26, 0x33	; 51
    2f7c:	a0 83       	st	Z, r26
    2f7e:	31 97       	sbiw	r30, 0x01	; 1
    2f80:	60 83       	st	Z, r22
    2f82:	31 97       	sbiw	r30, 0x01	; 1
    2f84:	70 83       	st	Z, r23
    2f86:	31 97       	sbiw	r30, 0x01	; 1
    2f88:	10 82       	st	Z, r1
    2f8a:	31 97       	sbiw	r30, 0x01	; 1
    2f8c:	10 82       	st	Z, r1
    2f8e:	31 97       	sbiw	r30, 0x01	; 1
    2f90:	60 e8       	ldi	r22, 0x80	; 128
    2f92:	60 83       	st	Z, r22
    2f94:	31 97       	sbiw	r30, 0x01	; 1
    2f96:	10 82       	st	Z, r1
    2f98:	31 97       	sbiw	r30, 0x01	; 1
    2f9a:	10 82       	st	Z, r1
    2f9c:	31 97       	sbiw	r30, 0x01	; 1
    2f9e:	10 82       	st	Z, r1
    2fa0:	31 97       	sbiw	r30, 0x01	; 1
    2fa2:	62 e0       	ldi	r22, 0x02	; 2
    2fa4:	60 83       	st	Z, r22
    2fa6:	31 97       	sbiw	r30, 0x01	; 1
    2fa8:	63 e0       	ldi	r22, 0x03	; 3
    2faa:	60 83       	st	Z, r22
    2fac:	31 97       	sbiw	r30, 0x01	; 1
    2fae:	64 e0       	ldi	r22, 0x04	; 4
    2fb0:	60 83       	st	Z, r22
    2fb2:	31 97       	sbiw	r30, 0x01	; 1
    2fb4:	65 e0       	ldi	r22, 0x05	; 5
    2fb6:	60 83       	st	Z, r22
    2fb8:	31 97       	sbiw	r30, 0x01	; 1
    2fba:	66 e0       	ldi	r22, 0x06	; 6
    2fbc:	60 83       	st	Z, r22
    2fbe:	31 97       	sbiw	r30, 0x01	; 1
    2fc0:	67 e0       	ldi	r22, 0x07	; 7
    2fc2:	60 83       	st	Z, r22
    2fc4:	31 97       	sbiw	r30, 0x01	; 1
    2fc6:	68 e0       	ldi	r22, 0x08	; 8
    2fc8:	60 83       	st	Z, r22
    2fca:	31 97       	sbiw	r30, 0x01	; 1
    2fcc:	69 e0       	ldi	r22, 0x09	; 9
    2fce:	60 83       	st	Z, r22
    2fd0:	31 97       	sbiw	r30, 0x01	; 1
    2fd2:	60 e1       	ldi	r22, 0x10	; 16
    2fd4:	60 83       	st	Z, r22
    2fd6:	31 97       	sbiw	r30, 0x01	; 1
    2fd8:	30 83       	st	Z, r19
    2fda:	31 97       	sbiw	r30, 0x01	; 1
    2fdc:	32 e1       	ldi	r19, 0x12	; 18
    2fde:	30 83       	st	Z, r19
    2fe0:	31 97       	sbiw	r30, 0x01	; 1
    2fe2:	33 e1       	ldi	r19, 0x13	; 19
    2fe4:	30 83       	st	Z, r19
    2fe6:	31 97       	sbiw	r30, 0x01	; 1
    2fe8:	34 e1       	ldi	r19, 0x14	; 20
    2fea:	30 83       	st	Z, r19
    2fec:	31 97       	sbiw	r30, 0x01	; 1
    2fee:	35 e1       	ldi	r19, 0x15	; 21
    2ff0:	30 83       	st	Z, r19
    2ff2:	31 97       	sbiw	r30, 0x01	; 1
    2ff4:	36 e1       	ldi	r19, 0x16	; 22
    2ff6:	30 83       	st	Z, r19
    2ff8:	31 97       	sbiw	r30, 0x01	; 1
    2ffa:	37 e1       	ldi	r19, 0x17	; 23
    2ffc:	30 83       	st	Z, r19
    2ffe:	31 97       	sbiw	r30, 0x01	; 1
    3000:	38 e1       	ldi	r19, 0x18	; 24
    3002:	30 83       	st	Z, r19
    3004:	31 97       	sbiw	r30, 0x01	; 1
    3006:	39 e1       	ldi	r19, 0x19	; 25
    3008:	30 83       	st	Z, r19
    300a:	31 97       	sbiw	r30, 0x01	; 1
    300c:	30 e2       	ldi	r19, 0x20	; 32
    300e:	30 83       	st	Z, r19
    3010:	31 97       	sbiw	r30, 0x01	; 1
    3012:	31 e2       	ldi	r19, 0x21	; 33
    3014:	30 83       	st	Z, r19
    3016:	31 97       	sbiw	r30, 0x01	; 1
    3018:	20 83       	st	Z, r18
    301a:	31 97       	sbiw	r30, 0x01	; 1
    301c:	23 e2       	ldi	r18, 0x23	; 35
    301e:	20 83       	st	Z, r18
    3020:	31 97       	sbiw	r30, 0x01	; 1
    3022:	40 83       	st	Z, r20
    3024:	31 97       	sbiw	r30, 0x01	; 1
    3026:	50 83       	st	Z, r21
    3028:	31 97       	sbiw	r30, 0x01	; 1
    302a:	26 e2       	ldi	r18, 0x26	; 38
    302c:	20 83       	st	Z, r18
    302e:	31 97       	sbiw	r30, 0x01	; 1
    3030:	27 e2       	ldi	r18, 0x27	; 39
    3032:	20 83       	st	Z, r18
    3034:	31 97       	sbiw	r30, 0x01	; 1
    3036:	28 e2       	ldi	r18, 0x28	; 40
    3038:	20 83       	st	Z, r18
    303a:	31 97       	sbiw	r30, 0x01	; 1
    303c:	29 e2       	ldi	r18, 0x29	; 41
    303e:	20 83       	st	Z, r18
    3040:	31 97       	sbiw	r30, 0x01	; 1
    3042:	20 e3       	ldi	r18, 0x30	; 48
    3044:	20 83       	st	Z, r18
    3046:	31 97       	sbiw	r30, 0x01	; 1
    3048:	21 e3       	ldi	r18, 0x31	; 49
    304a:	20 83       	st	Z, r18
    304c:	89 97       	sbiw	r24, 0x29	; 41
    304e:	08 95       	ret

00003050 <xPortStartScheduler>:
    3050:	88 ee       	ldi	r24, 0xE8	; 232
    3052:	93 e0       	ldi	r25, 0x03	; 3
    3054:	90 93 6c 1b 	sts	0x1B6C, r25	; 0x801b6c <portTickRateHz+0x1>
    3058:	80 93 6b 1b 	sts	0x1B6B, r24	; 0x801b6b <portTickRateHz>
    305c:	90 93 6e 1b 	sts	0x1B6E, r25	; 0x801b6e <ticksRemainingInSec+0x1>
    3060:	80 93 6d 1b 	sts	0x1B6D, r24	; 0x801b6d <ticksRemainingInSec>
    3064:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    3068:	89 ef       	ldi	r24, 0xF9	; 249
    306a:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
    306e:	8b e0       	ldi	r24, 0x0B	; 11
    3070:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    3074:	e1 e7       	ldi	r30, 0x71	; 113
    3076:	f0 e0       	ldi	r31, 0x00	; 0
    3078:	80 81       	ld	r24, Z
    307a:	82 60       	ori	r24, 0x02	; 2
    307c:	80 83       	st	Z, r24
    307e:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    3082:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    3086:	cd 91       	ld	r28, X+
    3088:	cd bf       	out	0x3d, r28	; 61
    308a:	dd 91       	ld	r29, X+
    308c:	de bf       	out	0x3e, r29	; 62
    308e:	ff 91       	pop	r31
    3090:	ef 91       	pop	r30
    3092:	df 91       	pop	r29
    3094:	cf 91       	pop	r28
    3096:	bf 91       	pop	r27
    3098:	af 91       	pop	r26
    309a:	9f 91       	pop	r25
    309c:	8f 91       	pop	r24
    309e:	7f 91       	pop	r23
    30a0:	6f 91       	pop	r22
    30a2:	5f 91       	pop	r21
    30a4:	4f 91       	pop	r20
    30a6:	3f 91       	pop	r19
    30a8:	2f 91       	pop	r18
    30aa:	1f 91       	pop	r17
    30ac:	0f 91       	pop	r16
    30ae:	ff 90       	pop	r15
    30b0:	ef 90       	pop	r14
    30b2:	df 90       	pop	r13
    30b4:	cf 90       	pop	r12
    30b6:	bf 90       	pop	r11
    30b8:	af 90       	pop	r10
    30ba:	9f 90       	pop	r9
    30bc:	8f 90       	pop	r8
    30be:	7f 90       	pop	r7
    30c0:	6f 90       	pop	r6
    30c2:	5f 90       	pop	r5
    30c4:	4f 90       	pop	r4
    30c6:	3f 90       	pop	r3
    30c8:	2f 90       	pop	r2
    30ca:	1f 90       	pop	r1
    30cc:	0f 90       	pop	r0
    30ce:	0c be       	out	0x3c, r0	; 60
    30d0:	0f 90       	pop	r0
    30d2:	0b be       	out	0x3b, r0	; 59
    30d4:	0f 90       	pop	r0
    30d6:	0f be       	out	0x3f, r0	; 63
    30d8:	0f 90       	pop	r0
    30da:	08 95       	ret
    30dc:	81 e0       	ldi	r24, 0x01	; 1
    30de:	08 95       	ret

000030e0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    30e0:	0f 92       	push	r0
    30e2:	0f b6       	in	r0, 0x3f	; 63
    30e4:	f8 94       	cli
    30e6:	0f 92       	push	r0
    30e8:	0b b6       	in	r0, 0x3b	; 59
    30ea:	0f 92       	push	r0
    30ec:	0c b6       	in	r0, 0x3c	; 60
    30ee:	0f 92       	push	r0
    30f0:	1f 92       	push	r1
    30f2:	11 24       	eor	r1, r1
    30f4:	2f 92       	push	r2
    30f6:	3f 92       	push	r3
    30f8:	4f 92       	push	r4
    30fa:	5f 92       	push	r5
    30fc:	6f 92       	push	r6
    30fe:	7f 92       	push	r7
    3100:	8f 92       	push	r8
    3102:	9f 92       	push	r9
    3104:	af 92       	push	r10
    3106:	bf 92       	push	r11
    3108:	cf 92       	push	r12
    310a:	df 92       	push	r13
    310c:	ef 92       	push	r14
    310e:	ff 92       	push	r15
    3110:	0f 93       	push	r16
    3112:	1f 93       	push	r17
    3114:	2f 93       	push	r18
    3116:	3f 93       	push	r19
    3118:	4f 93       	push	r20
    311a:	5f 93       	push	r21
    311c:	6f 93       	push	r22
    311e:	7f 93       	push	r23
    3120:	8f 93       	push	r24
    3122:	9f 93       	push	r25
    3124:	af 93       	push	r26
    3126:	bf 93       	push	r27
    3128:	cf 93       	push	r28
    312a:	df 93       	push	r29
    312c:	ef 93       	push	r30
    312e:	ff 93       	push	r31
    3130:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    3134:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    3138:	0d b6       	in	r0, 0x3d	; 61
    313a:	0d 92       	st	X+, r0
    313c:	0e b6       	in	r0, 0x3e	; 62
    313e:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3140:	0e 94 e5 29 	call	0x53ca	; 0x53ca <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    3144:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    3148:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    314c:	cd 91       	ld	r28, X+
    314e:	cd bf       	out	0x3d, r28	; 61
    3150:	dd 91       	ld	r29, X+
    3152:	de bf       	out	0x3e, r29	; 62
    3154:	ff 91       	pop	r31
    3156:	ef 91       	pop	r30
    3158:	df 91       	pop	r29
    315a:	cf 91       	pop	r28
    315c:	bf 91       	pop	r27
    315e:	af 91       	pop	r26
    3160:	9f 91       	pop	r25
    3162:	8f 91       	pop	r24
    3164:	7f 91       	pop	r23
    3166:	6f 91       	pop	r22
    3168:	5f 91       	pop	r21
    316a:	4f 91       	pop	r20
    316c:	3f 91       	pop	r19
    316e:	2f 91       	pop	r18
    3170:	1f 91       	pop	r17
    3172:	0f 91       	pop	r16
    3174:	ff 90       	pop	r15
    3176:	ef 90       	pop	r14
    3178:	df 90       	pop	r13
    317a:	cf 90       	pop	r12
    317c:	bf 90       	pop	r11
    317e:	af 90       	pop	r10
    3180:	9f 90       	pop	r9
    3182:	8f 90       	pop	r8
    3184:	7f 90       	pop	r7
    3186:	6f 90       	pop	r6
    3188:	5f 90       	pop	r5
    318a:	4f 90       	pop	r4
    318c:	3f 90       	pop	r3
    318e:	2f 90       	pop	r2
    3190:	1f 90       	pop	r1
    3192:	0f 90       	pop	r0
    3194:	0c be       	out	0x3c, r0	; 60
    3196:	0f 90       	pop	r0
    3198:	0b be       	out	0x3b, r0	; 59
    319a:	0f 90       	pop	r0
    319c:	0f be       	out	0x3f, r0	; 63
    319e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    31a0:	08 95       	ret

000031a2 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    31a2:	0f 92       	push	r0
    31a4:	0f b6       	in	r0, 0x3f	; 63
    31a6:	f8 94       	cli
    31a8:	0f 92       	push	r0
    31aa:	0b b6       	in	r0, 0x3b	; 59
    31ac:	0f 92       	push	r0
    31ae:	0c b6       	in	r0, 0x3c	; 60
    31b0:	0f 92       	push	r0
    31b2:	1f 92       	push	r1
    31b4:	11 24       	eor	r1, r1
    31b6:	2f 92       	push	r2
    31b8:	3f 92       	push	r3
    31ba:	4f 92       	push	r4
    31bc:	5f 92       	push	r5
    31be:	6f 92       	push	r6
    31c0:	7f 92       	push	r7
    31c2:	8f 92       	push	r8
    31c4:	9f 92       	push	r9
    31c6:	af 92       	push	r10
    31c8:	bf 92       	push	r11
    31ca:	cf 92       	push	r12
    31cc:	df 92       	push	r13
    31ce:	ef 92       	push	r14
    31d0:	ff 92       	push	r15
    31d2:	0f 93       	push	r16
    31d4:	1f 93       	push	r17
    31d6:	2f 93       	push	r18
    31d8:	3f 93       	push	r19
    31da:	4f 93       	push	r20
    31dc:	5f 93       	push	r21
    31de:	6f 93       	push	r22
    31e0:	7f 93       	push	r23
    31e2:	8f 93       	push	r24
    31e4:	9f 93       	push	r25
    31e6:	af 93       	push	r26
    31e8:	bf 93       	push	r27
    31ea:	cf 93       	push	r28
    31ec:	df 93       	push	r29
    31ee:	ef 93       	push	r30
    31f0:	ff 93       	push	r31
    31f2:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    31f6:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    31fa:	0d b6       	in	r0, 0x3d	; 61
    31fc:	0d 92       	st	X+, r0
    31fe:	0e b6       	in	r0, 0x3e	; 62
    3200:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    3202:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    3204:	80 91 6d 1b 	lds	r24, 0x1B6D	; 0x801b6d <ticksRemainingInSec>
    3208:	90 91 6e 1b 	lds	r25, 0x1B6E	; 0x801b6e <ticksRemainingInSec+0x1>
    320c:	01 97       	sbiw	r24, 0x01	; 1
    320e:	90 93 6e 1b 	sts	0x1B6E, r25	; 0x801b6e <ticksRemainingInSec+0x1>
    3212:	80 93 6d 1b 	sts	0x1B6D, r24	; 0x801b6d <ticksRemainingInSec>
    3216:	89 2b       	or	r24, r25
    3218:	41 f4       	brne	.+16     	; 0x322a <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    321a:	80 91 6b 1b 	lds	r24, 0x1B6B	; 0x801b6b <portTickRateHz>
    321e:	90 91 6c 1b 	lds	r25, 0x1B6C	; 0x801b6c <portTickRateHz+0x1>
    3222:	90 93 6e 1b 	sts	0x1B6E, r25	; 0x801b6e <ticksRemainingInSec+0x1>
    3226:	80 93 6d 1b 	sts	0x1B6D, r24	; 0x801b6d <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    322a:	0e 94 24 29 	call	0x5248	; 0x5248 <xTaskIncrementTick>
    322e:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    3230:	0e 94 e5 29 	call	0x53ca	; 0x53ca <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    3234:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    3238:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    323c:	cd 91       	ld	r28, X+
    323e:	cd bf       	out	0x3d, r28	; 61
    3240:	dd 91       	ld	r29, X+
    3242:	de bf       	out	0x3e, r29	; 62
    3244:	ff 91       	pop	r31
    3246:	ef 91       	pop	r30
    3248:	df 91       	pop	r29
    324a:	cf 91       	pop	r28
    324c:	bf 91       	pop	r27
    324e:	af 91       	pop	r26
    3250:	9f 91       	pop	r25
    3252:	8f 91       	pop	r24
    3254:	7f 91       	pop	r23
    3256:	6f 91       	pop	r22
    3258:	5f 91       	pop	r21
    325a:	4f 91       	pop	r20
    325c:	3f 91       	pop	r19
    325e:	2f 91       	pop	r18
    3260:	1f 91       	pop	r17
    3262:	0f 91       	pop	r16
    3264:	ff 90       	pop	r15
    3266:	ef 90       	pop	r14
    3268:	df 90       	pop	r13
    326a:	cf 90       	pop	r12
    326c:	bf 90       	pop	r11
    326e:	af 90       	pop	r10
    3270:	9f 90       	pop	r9
    3272:	8f 90       	pop	r8
    3274:	7f 90       	pop	r7
    3276:	6f 90       	pop	r6
    3278:	5f 90       	pop	r5
    327a:	4f 90       	pop	r4
    327c:	3f 90       	pop	r3
    327e:	2f 90       	pop	r2
    3280:	1f 90       	pop	r1
    3282:	0f 90       	pop	r0
    3284:	0c be       	out	0x3c, r0	; 60
    3286:	0f 90       	pop	r0
    3288:	0b be       	out	0x3b, r0	; 59
    328a:	0f 90       	pop	r0
    328c:	0f be       	out	0x3f, r0	; 63
    328e:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3290:	08 95       	ret

00003292 <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    3292:	87 df       	rcall	.-242    	; 0x31a2 <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    3294:	18 95       	reti

00003296 <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3296:	0f 93       	push	r16
    3298:	1f 93       	push	r17
    329a:	cf 93       	push	r28
    329c:	df 93       	push	r29
    329e:	08 2f       	mov	r16, r24
    32a0:	16 2f       	mov	r17, r22
    32a2:	66 23       	and	r22, r22
    32a4:	09 f4       	brne	.+2      	; 0x32a8 <xQueueGenericCreate+0x12>
    32a6:	3b c0       	rjmp	.+118    	; 0x331e <xQueueGenericCreate+0x88>
    32a8:	86 9f       	mul	r24, r22
    32aa:	c0 01       	movw	r24, r0
    32ac:	11 24       	eor	r1, r1
    32ae:	80 96       	adiw	r24, 0x20	; 32
    32b0:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    32b4:	ec 01       	movw	r28, r24
    32b6:	00 97       	sbiw	r24, 0x00	; 0
    32b8:	21 f4       	brne	.+8      	; 0x32c2 <xQueueGenericCreate+0x2c>
    32ba:	39 c0       	rjmp	.+114    	; 0x332e <xQueueGenericCreate+0x98>
    32bc:	d9 83       	std	Y+1, r29	; 0x01
    32be:	c8 83       	st	Y, r28
    32c0:	03 c0       	rjmp	.+6      	; 0x32c8 <xQueueGenericCreate+0x32>
    32c2:	4f 96       	adiw	r24, 0x1f	; 31
    32c4:	99 83       	std	Y+1, r25	; 0x01
    32c6:	88 83       	st	Y, r24
    32c8:	0b 8f       	std	Y+27, r16	; 0x1b
    32ca:	1c 8f       	std	Y+28, r17	; 0x1c
    32cc:	0f b6       	in	r0, 0x3f	; 63
    32ce:	f8 94       	cli
    32d0:	0f 92       	push	r0
    32d2:	48 81       	ld	r20, Y
    32d4:	59 81       	ldd	r21, Y+1	; 0x01
    32d6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    32d8:	30 e0       	ldi	r19, 0x00	; 0
    32da:	6b 8d       	ldd	r22, Y+27	; 0x1b
    32dc:	62 9f       	mul	r22, r18
    32de:	c0 01       	movw	r24, r0
    32e0:	63 9f       	mul	r22, r19
    32e2:	90 0d       	add	r25, r0
    32e4:	11 24       	eor	r1, r1
    32e6:	ba 01       	movw	r22, r20
    32e8:	68 0f       	add	r22, r24
    32ea:	79 1f       	adc	r23, r25
    32ec:	7b 83       	std	Y+3, r23	; 0x03
    32ee:	6a 83       	std	Y+2, r22	; 0x02
    32f0:	1a 8e       	std	Y+26, r1	; 0x1a
    32f2:	5d 83       	std	Y+5, r21	; 0x05
    32f4:	4c 83       	std	Y+4, r20	; 0x04
    32f6:	82 1b       	sub	r24, r18
    32f8:	93 0b       	sbc	r25, r19
    32fa:	84 0f       	add	r24, r20
    32fc:	95 1f       	adc	r25, r21
    32fe:	9f 83       	std	Y+7, r25	; 0x07
    3300:	8e 83       	std	Y+6, r24	; 0x06
    3302:	8f ef       	ldi	r24, 0xFF	; 255
    3304:	8d 8f       	std	Y+29, r24	; 0x1d
    3306:	8e 8f       	std	Y+30, r24	; 0x1e
    3308:	ce 01       	movw	r24, r28
    330a:	08 96       	adiw	r24, 0x08	; 8
    330c:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    3310:	ce 01       	movw	r24, r28
    3312:	41 96       	adiw	r24, 0x11	; 17
    3314:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    3318:	0f 90       	pop	r0
    331a:	0f be       	out	0x3f, r0	; 63
    331c:	08 c0       	rjmp	.+16     	; 0x332e <xQueueGenericCreate+0x98>
    331e:	8f e1       	ldi	r24, 0x1F	; 31
    3320:	90 e0       	ldi	r25, 0x00	; 0
    3322:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    3326:	ec 01       	movw	r28, r24
    3328:	89 2b       	or	r24, r25
    332a:	09 f0       	breq	.+2      	; 0x332e <xQueueGenericCreate+0x98>
    332c:	c7 cf       	rjmp	.-114    	; 0x32bc <xQueueGenericCreate+0x26>
    332e:	ce 01       	movw	r24, r28
    3330:	df 91       	pop	r29
    3332:	cf 91       	pop	r28
    3334:	1f 91       	pop	r17
    3336:	0f 91       	pop	r16
    3338:	08 95       	ret

0000333a <xQueueCreateMutex>:
    333a:	9f 92       	push	r9
    333c:	af 92       	push	r10
    333e:	bf 92       	push	r11
    3340:	cf 92       	push	r12
    3342:	df 92       	push	r13
    3344:	ef 92       	push	r14
    3346:	ff 92       	push	r15
    3348:	0f 93       	push	r16
    334a:	1f 93       	push	r17
    334c:	cf 93       	push	r28
    334e:	df 93       	push	r29
    3350:	00 d0       	rcall	.+0      	; 0x3352 <xQueueCreateMutex+0x18>
    3352:	1f 92       	push	r1
    3354:	1f 92       	push	r1
    3356:	cd b7       	in	r28, 0x3d	; 61
    3358:	de b7       	in	r29, 0x3e	; 62
    335a:	8f e1       	ldi	r24, 0x1F	; 31
    335c:	90 e0       	ldi	r25, 0x00	; 0
    335e:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    3362:	8c 01       	movw	r16, r24
    3364:	00 97       	sbiw	r24, 0x00	; 0
    3366:	09 f4       	brne	.+2      	; 0x336a <xQueueCreateMutex+0x30>
    3368:	58 c1       	rjmp	.+688    	; 0x361a <xQueueCreateMutex+0x2e0>
    336a:	fc 01       	movw	r30, r24
    336c:	13 82       	std	Z+3, r1	; 0x03
    336e:	12 82       	std	Z+2, r1	; 0x02
    3370:	11 82       	std	Z+1, r1	; 0x01
    3372:	10 82       	st	Z, r1
    3374:	15 82       	std	Z+5, r1	; 0x05
    3376:	14 82       	std	Z+4, r1	; 0x04
    3378:	17 82       	std	Z+7, r1	; 0x07
    337a:	16 82       	std	Z+6, r1	; 0x06
    337c:	12 8e       	std	Z+26, r1	; 0x1a
    337e:	81 e0       	ldi	r24, 0x01	; 1
    3380:	83 8f       	std	Z+27, r24	; 0x1b
    3382:	14 8e       	std	Z+28, r1	; 0x1c
    3384:	8f ef       	ldi	r24, 0xFF	; 255
    3386:	85 8f       	std	Z+29, r24	; 0x1d
    3388:	86 8f       	std	Z+30, r24	; 0x1e
    338a:	78 01       	movw	r14, r16
    338c:	f8 e0       	ldi	r31, 0x08	; 8
    338e:	ef 0e       	add	r14, r31
    3390:	f1 1c       	adc	r15, r1
    3392:	c7 01       	movw	r24, r14
    3394:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    3398:	68 01       	movw	r12, r16
    339a:	81 e1       	ldi	r24, 0x11	; 17
    339c:	c8 0e       	add	r12, r24
    339e:	d1 1c       	adc	r13, r1
    33a0:	c6 01       	movw	r24, r12
    33a2:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    33a6:	1d 82       	std	Y+5, r1	; 0x05
    33a8:	1c 82       	std	Y+4, r1	; 0x04
    33aa:	a1 2c       	mov	r10, r1
    33ac:	99 24       	eor	r9, r9
    33ae:	93 94       	inc	r9
    33b0:	bb 24       	eor	r11, r11
    33b2:	ba 94       	dec	r11
    33b4:	0f b6       	in	r0, 0x3f	; 63
    33b6:	f8 94       	cli
    33b8:	0f 92       	push	r0
    33ba:	f8 01       	movw	r30, r16
    33bc:	92 8d       	ldd	r25, Z+26	; 0x1a
    33be:	83 8d       	ldd	r24, Z+27	; 0x1b
    33c0:	98 17       	cp	r25, r24
    33c2:	f0 f4       	brcc	.+60     	; 0x3400 <xQueueCreateMutex+0xc6>
    33c4:	80 81       	ld	r24, Z
    33c6:	91 81       	ldd	r25, Z+1	; 0x01
    33c8:	89 2b       	or	r24, r25
    33ca:	09 f0       	breq	.+2      	; 0x33ce <xQueueCreateMutex+0x94>
    33cc:	1d c1       	rjmp	.+570    	; 0x3608 <xQueueCreateMutex+0x2ce>
    33ce:	82 81       	ldd	r24, Z+2	; 0x02
    33d0:	93 81       	ldd	r25, Z+3	; 0x03
    33d2:	0e 94 c2 2b 	call	0x5784	; 0x5784 <xTaskPriorityDisinherit>
    33d6:	f8 01       	movw	r30, r16
    33d8:	13 82       	std	Z+3, r1	; 0x03
    33da:	12 82       	std	Z+2, r1	; 0x02
    33dc:	92 8d       	ldd	r25, Z+26	; 0x1a
    33de:	9f 5f       	subi	r25, 0xFF	; 255
    33e0:	92 8f       	std	Z+26, r25	; 0x1a
    33e2:	91 89       	ldd	r25, Z+17	; 0x11
    33e4:	99 23       	and	r25, r25
    33e6:	39 f0       	breq	.+14     	; 0x33f6 <xQueueCreateMutex+0xbc>
    33e8:	c6 01       	movw	r24, r12
    33ea:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    33ee:	81 30       	cpi	r24, 0x01	; 1
    33f0:	21 f4       	brne	.+8      	; 0x33fa <xQueueCreateMutex+0xc0>
    33f2:	76 de       	rcall	.-788    	; 0x30e0 <vPortYield>
    33f4:	02 c0       	rjmp	.+4      	; 0x33fa <xQueueCreateMutex+0xc0>
    33f6:	81 11       	cpse	r24, r1
    33f8:	73 de       	rcall	.-794    	; 0x30e0 <vPortYield>
    33fa:	0f 90       	pop	r0
    33fc:	0f be       	out	0x3f, r0	; 63
    33fe:	0d c1       	rjmp	.+538    	; 0x361a <xQueueCreateMutex+0x2e0>
    3400:	8c 81       	ldd	r24, Y+4	; 0x04
    3402:	9d 81       	ldd	r25, Y+5	; 0x05
    3404:	89 2b       	or	r24, r25
    3406:	19 f4       	brne	.+6      	; 0x340e <xQueueCreateMutex+0xd4>
    3408:	0f 90       	pop	r0
    340a:	0f be       	out	0x3f, r0	; 63
    340c:	06 c1       	rjmp	.+524    	; 0x361a <xQueueCreateMutex+0x2e0>
    340e:	a1 10       	cpse	r10, r1
    3410:	05 c0       	rjmp	.+10     	; 0x341c <xQueueCreateMutex+0xe2>
    3412:	ce 01       	movw	r24, r28
    3414:	01 96       	adiw	r24, 0x01	; 1
    3416:	0e 94 11 2b 	call	0x5622	; 0x5622 <vTaskSetTimeOutState>
    341a:	a9 2c       	mov	r10, r9
    341c:	0f 90       	pop	r0
    341e:	0f be       	out	0x3f, r0	; 63
    3420:	0e 94 d9 27 	call	0x4fb2	; 0x4fb2 <vTaskSuspendAll>
    3424:	0f b6       	in	r0, 0x3f	; 63
    3426:	f8 94       	cli
    3428:	0f 92       	push	r0
    342a:	f8 01       	movw	r30, r16
    342c:	85 8d       	ldd	r24, Z+29	; 0x1d
    342e:	8f 3f       	cpi	r24, 0xFF	; 255
    3430:	09 f4       	brne	.+2      	; 0x3434 <xQueueCreateMutex+0xfa>
    3432:	15 8e       	std	Z+29, r1	; 0x1d
    3434:	f8 01       	movw	r30, r16
    3436:	86 8d       	ldd	r24, Z+30	; 0x1e
    3438:	8f 3f       	cpi	r24, 0xFF	; 255
    343a:	09 f4       	brne	.+2      	; 0x343e <xQueueCreateMutex+0x104>
    343c:	16 8e       	std	Z+30, r1	; 0x1e
    343e:	0f 90       	pop	r0
    3440:	0f be       	out	0x3f, r0	; 63
    3442:	be 01       	movw	r22, r28
    3444:	6c 5f       	subi	r22, 0xFC	; 252
    3446:	7f 4f       	sbci	r23, 0xFF	; 255
    3448:	ce 01       	movw	r24, r28
    344a:	01 96       	adiw	r24, 0x01	; 1
    344c:	0e 94 1c 2b 	call	0x5638	; 0x5638 <xTaskCheckForTimeOut>
    3450:	81 11       	cpse	r24, r1
    3452:	96 c0       	rjmp	.+300    	; 0x3580 <xQueueCreateMutex+0x246>
    3454:	0f b6       	in	r0, 0x3f	; 63
    3456:	f8 94       	cli
    3458:	0f 92       	push	r0
    345a:	f8 01       	movw	r30, r16
    345c:	92 8d       	ldd	r25, Z+26	; 0x1a
    345e:	83 8d       	ldd	r24, Z+27	; 0x1b
    3460:	0f 90       	pop	r0
    3462:	0f be       	out	0x3f, r0	; 63
    3464:	98 13       	cpse	r25, r24
    3466:	4a c0       	rjmp	.+148    	; 0x34fc <xQueueCreateMutex+0x1c2>
    3468:	6c 81       	ldd	r22, Y+4	; 0x04
    346a:	7d 81       	ldd	r23, Y+5	; 0x05
    346c:	c7 01       	movw	r24, r14
    346e:	0e 94 6d 2a 	call	0x54da	; 0x54da <vTaskPlaceOnEventList>
    3472:	0f b6       	in	r0, 0x3f	; 63
    3474:	f8 94       	cli
    3476:	0f 92       	push	r0
    3478:	f8 01       	movw	r30, r16
    347a:	86 8d       	ldd	r24, Z+30	; 0x1e
    347c:	18 16       	cp	r1, r24
    347e:	ac f4       	brge	.+42     	; 0x34aa <xQueueCreateMutex+0x170>
    3480:	81 89       	ldd	r24, Z+17	; 0x11
    3482:	81 11       	cpse	r24, r1
    3484:	05 c0       	rjmp	.+10     	; 0x3490 <xQueueCreateMutex+0x156>
    3486:	11 c0       	rjmp	.+34     	; 0x34aa <xQueueCreateMutex+0x170>
    3488:	f8 01       	movw	r30, r16
    348a:	81 89       	ldd	r24, Z+17	; 0x11
    348c:	88 23       	and	r24, r24
    348e:	69 f0       	breq	.+26     	; 0x34aa <xQueueCreateMutex+0x170>
    3490:	c6 01       	movw	r24, r12
    3492:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3496:	81 11       	cpse	r24, r1
    3498:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    349c:	f8 01       	movw	r30, r16
    349e:	86 8d       	ldd	r24, Z+30	; 0x1e
    34a0:	81 50       	subi	r24, 0x01	; 1
    34a2:	86 8f       	std	Z+30, r24	; 0x1e
    34a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    34a6:	18 16       	cp	r1, r24
    34a8:	7c f3       	brlt	.-34     	; 0x3488 <xQueueCreateMutex+0x14e>
    34aa:	f8 01       	movw	r30, r16
    34ac:	b6 8e       	std	Z+30, r11	; 0x1e
    34ae:	0f 90       	pop	r0
    34b0:	0f be       	out	0x3f, r0	; 63
    34b2:	0f b6       	in	r0, 0x3f	; 63
    34b4:	f8 94       	cli
    34b6:	0f 92       	push	r0
    34b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    34ba:	18 16       	cp	r1, r24
    34bc:	ac f4       	brge	.+42     	; 0x34e8 <xQueueCreateMutex+0x1ae>
    34be:	80 85       	ldd	r24, Z+8	; 0x08
    34c0:	81 11       	cpse	r24, r1
    34c2:	05 c0       	rjmp	.+10     	; 0x34ce <xQueueCreateMutex+0x194>
    34c4:	11 c0       	rjmp	.+34     	; 0x34e8 <xQueueCreateMutex+0x1ae>
    34c6:	f8 01       	movw	r30, r16
    34c8:	80 85       	ldd	r24, Z+8	; 0x08
    34ca:	88 23       	and	r24, r24
    34cc:	69 f0       	breq	.+26     	; 0x34e8 <xQueueCreateMutex+0x1ae>
    34ce:	c7 01       	movw	r24, r14
    34d0:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    34d4:	81 11       	cpse	r24, r1
    34d6:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    34da:	f8 01       	movw	r30, r16
    34dc:	85 8d       	ldd	r24, Z+29	; 0x1d
    34de:	81 50       	subi	r24, 0x01	; 1
    34e0:	85 8f       	std	Z+29, r24	; 0x1d
    34e2:	85 8d       	ldd	r24, Z+29	; 0x1d
    34e4:	18 16       	cp	r1, r24
    34e6:	7c f3       	brlt	.-34     	; 0x34c6 <xQueueCreateMutex+0x18c>
    34e8:	f8 01       	movw	r30, r16
    34ea:	b5 8e       	std	Z+29, r11	; 0x1d
    34ec:	0f 90       	pop	r0
    34ee:	0f be       	out	0x3f, r0	; 63
    34f0:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    34f4:	81 11       	cpse	r24, r1
    34f6:	5e cf       	rjmp	.-324    	; 0x33b4 <xQueueCreateMutex+0x7a>
    34f8:	f3 dd       	rcall	.-1050   	; 0x30e0 <vPortYield>
    34fa:	5c cf       	rjmp	.-328    	; 0x33b4 <xQueueCreateMutex+0x7a>
    34fc:	0f b6       	in	r0, 0x3f	; 63
    34fe:	f8 94       	cli
    3500:	0f 92       	push	r0
    3502:	f8 01       	movw	r30, r16
    3504:	86 8d       	ldd	r24, Z+30	; 0x1e
    3506:	18 16       	cp	r1, r24
    3508:	ac f4       	brge	.+42     	; 0x3534 <xQueueCreateMutex+0x1fa>
    350a:	81 89       	ldd	r24, Z+17	; 0x11
    350c:	81 11       	cpse	r24, r1
    350e:	05 c0       	rjmp	.+10     	; 0x351a <xQueueCreateMutex+0x1e0>
    3510:	11 c0       	rjmp	.+34     	; 0x3534 <xQueueCreateMutex+0x1fa>
    3512:	f8 01       	movw	r30, r16
    3514:	81 89       	ldd	r24, Z+17	; 0x11
    3516:	88 23       	and	r24, r24
    3518:	69 f0       	breq	.+26     	; 0x3534 <xQueueCreateMutex+0x1fa>
    351a:	c6 01       	movw	r24, r12
    351c:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3520:	81 11       	cpse	r24, r1
    3522:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3526:	f8 01       	movw	r30, r16
    3528:	96 8d       	ldd	r25, Z+30	; 0x1e
    352a:	91 50       	subi	r25, 0x01	; 1
    352c:	96 8f       	std	Z+30, r25	; 0x1e
    352e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3530:	18 16       	cp	r1, r24
    3532:	7c f3       	brlt	.-34     	; 0x3512 <xQueueCreateMutex+0x1d8>
    3534:	f8 01       	movw	r30, r16
    3536:	b6 8e       	std	Z+30, r11	; 0x1e
    3538:	0f 90       	pop	r0
    353a:	0f be       	out	0x3f, r0	; 63
    353c:	0f b6       	in	r0, 0x3f	; 63
    353e:	f8 94       	cli
    3540:	0f 92       	push	r0
    3542:	85 8d       	ldd	r24, Z+29	; 0x1d
    3544:	18 16       	cp	r1, r24
    3546:	ac f4       	brge	.+42     	; 0x3572 <xQueueCreateMutex+0x238>
    3548:	80 85       	ldd	r24, Z+8	; 0x08
    354a:	81 11       	cpse	r24, r1
    354c:	05 c0       	rjmp	.+10     	; 0x3558 <xQueueCreateMutex+0x21e>
    354e:	11 c0       	rjmp	.+34     	; 0x3572 <xQueueCreateMutex+0x238>
    3550:	f8 01       	movw	r30, r16
    3552:	80 85       	ldd	r24, Z+8	; 0x08
    3554:	88 23       	and	r24, r24
    3556:	69 f0       	breq	.+26     	; 0x3572 <xQueueCreateMutex+0x238>
    3558:	c7 01       	movw	r24, r14
    355a:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    355e:	81 11       	cpse	r24, r1
    3560:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3564:	f8 01       	movw	r30, r16
    3566:	95 8d       	ldd	r25, Z+29	; 0x1d
    3568:	91 50       	subi	r25, 0x01	; 1
    356a:	95 8f       	std	Z+29, r25	; 0x1d
    356c:	85 8d       	ldd	r24, Z+29	; 0x1d
    356e:	18 16       	cp	r1, r24
    3570:	7c f3       	brlt	.-34     	; 0x3550 <xQueueCreateMutex+0x216>
    3572:	f8 01       	movw	r30, r16
    3574:	b5 8e       	std	Z+29, r11	; 0x1d
    3576:	0f 90       	pop	r0
    3578:	0f be       	out	0x3f, r0	; 63
    357a:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    357e:	1a cf       	rjmp	.-460    	; 0x33b4 <xQueueCreateMutex+0x7a>
    3580:	0f b6       	in	r0, 0x3f	; 63
    3582:	f8 94       	cli
    3584:	0f 92       	push	r0
    3586:	f8 01       	movw	r30, r16
    3588:	86 8d       	ldd	r24, Z+30	; 0x1e
    358a:	18 16       	cp	r1, r24
    358c:	ac f4       	brge	.+42     	; 0x35b8 <xQueueCreateMutex+0x27e>
    358e:	81 89       	ldd	r24, Z+17	; 0x11
    3590:	81 11       	cpse	r24, r1
    3592:	05 c0       	rjmp	.+10     	; 0x359e <xQueueCreateMutex+0x264>
    3594:	11 c0       	rjmp	.+34     	; 0x35b8 <xQueueCreateMutex+0x27e>
    3596:	f8 01       	movw	r30, r16
    3598:	81 89       	ldd	r24, Z+17	; 0x11
    359a:	88 23       	and	r24, r24
    359c:	69 f0       	breq	.+26     	; 0x35b8 <xQueueCreateMutex+0x27e>
    359e:	c6 01       	movw	r24, r12
    35a0:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    35a4:	81 11       	cpse	r24, r1
    35a6:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    35aa:	f8 01       	movw	r30, r16
    35ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    35ae:	81 50       	subi	r24, 0x01	; 1
    35b0:	86 8f       	std	Z+30, r24	; 0x1e
    35b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    35b4:	18 16       	cp	r1, r24
    35b6:	7c f3       	brlt	.-34     	; 0x3596 <xQueueCreateMutex+0x25c>
    35b8:	8f ef       	ldi	r24, 0xFF	; 255
    35ba:	f8 01       	movw	r30, r16
    35bc:	86 8f       	std	Z+30, r24	; 0x1e
    35be:	0f 90       	pop	r0
    35c0:	0f be       	out	0x3f, r0	; 63
    35c2:	0f b6       	in	r0, 0x3f	; 63
    35c4:	f8 94       	cli
    35c6:	0f 92       	push	r0
    35c8:	85 8d       	ldd	r24, Z+29	; 0x1d
    35ca:	18 16       	cp	r1, r24
    35cc:	ac f4       	brge	.+42     	; 0x35f8 <xQueueCreateMutex+0x2be>
    35ce:	80 85       	ldd	r24, Z+8	; 0x08
    35d0:	81 11       	cpse	r24, r1
    35d2:	05 c0       	rjmp	.+10     	; 0x35de <xQueueCreateMutex+0x2a4>
    35d4:	11 c0       	rjmp	.+34     	; 0x35f8 <xQueueCreateMutex+0x2be>
    35d6:	f8 01       	movw	r30, r16
    35d8:	80 85       	ldd	r24, Z+8	; 0x08
    35da:	88 23       	and	r24, r24
    35dc:	69 f0       	breq	.+26     	; 0x35f8 <xQueueCreateMutex+0x2be>
    35de:	c7 01       	movw	r24, r14
    35e0:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    35e4:	81 11       	cpse	r24, r1
    35e6:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    35ea:	f8 01       	movw	r30, r16
    35ec:	85 8d       	ldd	r24, Z+29	; 0x1d
    35ee:	81 50       	subi	r24, 0x01	; 1
    35f0:	85 8f       	std	Z+29, r24	; 0x1d
    35f2:	85 8d       	ldd	r24, Z+29	; 0x1d
    35f4:	18 16       	cp	r1, r24
    35f6:	7c f3       	brlt	.-34     	; 0x35d6 <xQueueCreateMutex+0x29c>
    35f8:	8f ef       	ldi	r24, 0xFF	; 255
    35fa:	f8 01       	movw	r30, r16
    35fc:	85 8f       	std	Z+29, r24	; 0x1d
    35fe:	0f 90       	pop	r0
    3600:	0f be       	out	0x3f, r0	; 63
    3602:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    3606:	09 c0       	rjmp	.+18     	; 0x361a <xQueueCreateMutex+0x2e0>
    3608:	f8 01       	movw	r30, r16
    360a:	82 8d       	ldd	r24, Z+26	; 0x1a
    360c:	8f 5f       	subi	r24, 0xFF	; 255
    360e:	82 8f       	std	Z+26, r24	; 0x1a
    3610:	81 89       	ldd	r24, Z+17	; 0x11
    3612:	88 23       	and	r24, r24
    3614:	09 f4       	brne	.+2      	; 0x3618 <xQueueCreateMutex+0x2de>
    3616:	f1 ce       	rjmp	.-542    	; 0x33fa <xQueueCreateMutex+0xc0>
    3618:	e7 ce       	rjmp	.-562    	; 0x33e8 <xQueueCreateMutex+0xae>
    361a:	c8 01       	movw	r24, r16
    361c:	0f 90       	pop	r0
    361e:	0f 90       	pop	r0
    3620:	0f 90       	pop	r0
    3622:	0f 90       	pop	r0
    3624:	0f 90       	pop	r0
    3626:	df 91       	pop	r29
    3628:	cf 91       	pop	r28
    362a:	1f 91       	pop	r17
    362c:	0f 91       	pop	r16
    362e:	ff 90       	pop	r15
    3630:	ef 90       	pop	r14
    3632:	df 90       	pop	r13
    3634:	cf 90       	pop	r12
    3636:	bf 90       	pop	r11
    3638:	af 90       	pop	r10
    363a:	9f 90       	pop	r9
    363c:	08 95       	ret

0000363e <xQueueGenericSend>:
    363e:	6f 92       	push	r6
    3640:	7f 92       	push	r7
    3642:	8f 92       	push	r8
    3644:	9f 92       	push	r9
    3646:	af 92       	push	r10
    3648:	bf 92       	push	r11
    364a:	cf 92       	push	r12
    364c:	df 92       	push	r13
    364e:	ef 92       	push	r14
    3650:	ff 92       	push	r15
    3652:	0f 93       	push	r16
    3654:	1f 93       	push	r17
    3656:	cf 93       	push	r28
    3658:	df 93       	push	r29
    365a:	00 d0       	rcall	.+0      	; 0x365c <xQueueGenericSend+0x1e>
    365c:	1f 92       	push	r1
    365e:	1f 92       	push	r1
    3660:	cd b7       	in	r28, 0x3d	; 61
    3662:	de b7       	in	r29, 0x3e	; 62
    3664:	8c 01       	movw	r16, r24
    3666:	5b 01       	movw	r10, r22
    3668:	5d 83       	std	Y+5, r21	; 0x05
    366a:	4c 83       	std	Y+4, r20	; 0x04
    366c:	72 2e       	mov	r7, r18
    366e:	81 2c       	mov	r8, r1
    3670:	66 24       	eor	r6, r6
    3672:	63 94       	inc	r6
    3674:	99 24       	eor	r9, r9
    3676:	9a 94       	dec	r9
    3678:	7c 01       	movw	r14, r24
    367a:	88 e0       	ldi	r24, 0x08	; 8
    367c:	e8 0e       	add	r14, r24
    367e:	f1 1c       	adc	r15, r1
    3680:	68 01       	movw	r12, r16
    3682:	e1 e1       	ldi	r30, 0x11	; 17
    3684:	ce 0e       	add	r12, r30
    3686:	d1 1c       	adc	r13, r1
    3688:	0f b6       	in	r0, 0x3f	; 63
    368a:	f8 94       	cli
    368c:	0f 92       	push	r0
    368e:	f8 01       	movw	r30, r16
    3690:	92 8d       	ldd	r25, Z+26	; 0x1a
    3692:	83 8d       	ldd	r24, Z+27	; 0x1b
    3694:	98 17       	cp	r25, r24
    3696:	20 f0       	brcs	.+8      	; 0x36a0 <xQueueGenericSend+0x62>
    3698:	f2 e0       	ldi	r31, 0x02	; 2
    369a:	7f 12       	cpse	r7, r31
    369c:	6e c0       	rjmp	.+220    	; 0x377a <xQueueGenericSend+0x13c>
    369e:	7d c1       	rjmp	.+762    	; 0x399a <xQueueGenericSend+0x35c>
    36a0:	f8 01       	movw	r30, r16
    36a2:	44 8d       	ldd	r20, Z+28	; 0x1c
    36a4:	41 11       	cpse	r20, r1
    36a6:	15 c0       	rjmp	.+42     	; 0x36d2 <xQueueGenericSend+0x94>
    36a8:	f8 01       	movw	r30, r16
    36aa:	80 81       	ld	r24, Z
    36ac:	91 81       	ldd	r25, Z+1	; 0x01
    36ae:	89 2b       	or	r24, r25
    36b0:	09 f0       	breq	.+2      	; 0x36b4 <xQueueGenericSend+0x76>
    36b2:	79 c1       	rjmp	.+754    	; 0x39a6 <xQueueGenericSend+0x368>
    36b4:	82 81       	ldd	r24, Z+2	; 0x02
    36b6:	93 81       	ldd	r25, Z+3	; 0x03
    36b8:	0e 94 c2 2b 	call	0x5784	; 0x5784 <xTaskPriorityDisinherit>
    36bc:	f8 01       	movw	r30, r16
    36be:	13 82       	std	Z+3, r1	; 0x03
    36c0:	12 82       	std	Z+2, r1	; 0x02
    36c2:	92 8d       	ldd	r25, Z+26	; 0x1a
    36c4:	9f 5f       	subi	r25, 0xFF	; 255
    36c6:	92 8f       	std	Z+26, r25	; 0x1a
    36c8:	91 89       	ldd	r25, Z+17	; 0x11
    36ca:	99 23       	and	r25, r25
    36cc:	09 f4       	brne	.+2      	; 0x36d0 <xQueueGenericSend+0x92>
    36ce:	4f c0       	rjmp	.+158    	; 0x376e <xQueueGenericSend+0x130>
    36d0:	46 c0       	rjmp	.+140    	; 0x375e <xQueueGenericSend+0x120>
    36d2:	71 10       	cpse	r7, r1
    36d4:	1a c0       	rjmp	.+52     	; 0x370a <xQueueGenericSend+0xcc>
    36d6:	50 e0       	ldi	r21, 0x00	; 0
    36d8:	b5 01       	movw	r22, r10
    36da:	f8 01       	movw	r30, r16
    36dc:	84 81       	ldd	r24, Z+4	; 0x04
    36de:	95 81       	ldd	r25, Z+5	; 0x05
    36e0:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    36e4:	f8 01       	movw	r30, r16
    36e6:	24 8d       	ldd	r18, Z+28	; 0x1c
    36e8:	84 81       	ldd	r24, Z+4	; 0x04
    36ea:	95 81       	ldd	r25, Z+5	; 0x05
    36ec:	82 0f       	add	r24, r18
    36ee:	91 1d       	adc	r25, r1
    36f0:	95 83       	std	Z+5, r25	; 0x05
    36f2:	84 83       	std	Z+4, r24	; 0x04
    36f4:	22 81       	ldd	r18, Z+2	; 0x02
    36f6:	33 81       	ldd	r19, Z+3	; 0x03
    36f8:	82 17       	cp	r24, r18
    36fa:	93 07       	cpc	r25, r19
    36fc:	08 f4       	brcc	.+2      	; 0x3700 <xQueueGenericSend+0xc2>
    36fe:	53 c1       	rjmp	.+678    	; 0x39a6 <xQueueGenericSend+0x368>
    3700:	80 81       	ld	r24, Z
    3702:	91 81       	ldd	r25, Z+1	; 0x01
    3704:	95 83       	std	Z+5, r25	; 0x05
    3706:	84 83       	std	Z+4, r24	; 0x04
    3708:	4e c1       	rjmp	.+668    	; 0x39a6 <xQueueGenericSend+0x368>
    370a:	50 e0       	ldi	r21, 0x00	; 0
    370c:	b5 01       	movw	r22, r10
    370e:	f8 01       	movw	r30, r16
    3710:	86 81       	ldd	r24, Z+6	; 0x06
    3712:	97 81       	ldd	r25, Z+7	; 0x07
    3714:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    3718:	f8 01       	movw	r30, r16
    371a:	84 8d       	ldd	r24, Z+28	; 0x1c
    371c:	90 e0       	ldi	r25, 0x00	; 0
    371e:	91 95       	neg	r25
    3720:	81 95       	neg	r24
    3722:	91 09       	sbc	r25, r1
    3724:	26 81       	ldd	r18, Z+6	; 0x06
    3726:	37 81       	ldd	r19, Z+7	; 0x07
    3728:	28 0f       	add	r18, r24
    372a:	39 1f       	adc	r19, r25
    372c:	37 83       	std	Z+7, r19	; 0x07
    372e:	26 83       	std	Z+6, r18	; 0x06
    3730:	40 81       	ld	r20, Z
    3732:	51 81       	ldd	r21, Z+1	; 0x01
    3734:	24 17       	cp	r18, r20
    3736:	35 07       	cpc	r19, r21
    3738:	30 f4       	brcc	.+12     	; 0x3746 <xQueueGenericSend+0x108>
    373a:	22 81       	ldd	r18, Z+2	; 0x02
    373c:	33 81       	ldd	r19, Z+3	; 0x03
    373e:	82 0f       	add	r24, r18
    3740:	93 1f       	adc	r25, r19
    3742:	97 83       	std	Z+7, r25	; 0x07
    3744:	86 83       	std	Z+6, r24	; 0x06
    3746:	f2 e0       	ldi	r31, 0x02	; 2
    3748:	7f 12       	cpse	r7, r31
    374a:	2d c1       	rjmp	.+602    	; 0x39a6 <xQueueGenericSend+0x368>
    374c:	f8 01       	movw	r30, r16
    374e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3750:	88 23       	and	r24, r24
    3752:	09 f4       	brne	.+2      	; 0x3756 <xQueueGenericSend+0x118>
    3754:	28 c1       	rjmp	.+592    	; 0x39a6 <xQueueGenericSend+0x368>
    3756:	82 8d       	ldd	r24, Z+26	; 0x1a
    3758:	81 50       	subi	r24, 0x01	; 1
    375a:	82 8f       	std	Z+26, r24	; 0x1a
    375c:	24 c1       	rjmp	.+584    	; 0x39a6 <xQueueGenericSend+0x368>
    375e:	c8 01       	movw	r24, r16
    3760:	41 96       	adiw	r24, 0x11	; 17
    3762:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3766:	81 30       	cpi	r24, 0x01	; 1
    3768:	21 f4       	brne	.+8      	; 0x3772 <xQueueGenericSend+0x134>
    376a:	ba dc       	rcall	.-1676   	; 0x30e0 <vPortYield>
    376c:	02 c0       	rjmp	.+4      	; 0x3772 <xQueueGenericSend+0x134>
    376e:	81 11       	cpse	r24, r1
    3770:	b7 dc       	rcall	.-1682   	; 0x30e0 <vPortYield>
    3772:	0f 90       	pop	r0
    3774:	0f be       	out	0x3f, r0	; 63
    3776:	81 e0       	ldi	r24, 0x01	; 1
    3778:	1f c1       	rjmp	.+574    	; 0x39b8 <xQueueGenericSend+0x37a>
    377a:	8c 81       	ldd	r24, Y+4	; 0x04
    377c:	9d 81       	ldd	r25, Y+5	; 0x05
    377e:	89 2b       	or	r24, r25
    3780:	21 f4       	brne	.+8      	; 0x378a <xQueueGenericSend+0x14c>
    3782:	0f 90       	pop	r0
    3784:	0f be       	out	0x3f, r0	; 63
    3786:	80 e0       	ldi	r24, 0x00	; 0
    3788:	17 c1       	rjmp	.+558    	; 0x39b8 <xQueueGenericSend+0x37a>
    378a:	81 10       	cpse	r8, r1
    378c:	05 c0       	rjmp	.+10     	; 0x3798 <xQueueGenericSend+0x15a>
    378e:	ce 01       	movw	r24, r28
    3790:	01 96       	adiw	r24, 0x01	; 1
    3792:	0e 94 11 2b 	call	0x5622	; 0x5622 <vTaskSetTimeOutState>
    3796:	86 2c       	mov	r8, r6
    3798:	0f 90       	pop	r0
    379a:	0f be       	out	0x3f, r0	; 63
    379c:	0e 94 d9 27 	call	0x4fb2	; 0x4fb2 <vTaskSuspendAll>
    37a0:	0f b6       	in	r0, 0x3f	; 63
    37a2:	f8 94       	cli
    37a4:	0f 92       	push	r0
    37a6:	f8 01       	movw	r30, r16
    37a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    37aa:	8f 3f       	cpi	r24, 0xFF	; 255
    37ac:	09 f4       	brne	.+2      	; 0x37b0 <xQueueGenericSend+0x172>
    37ae:	15 8e       	std	Z+29, r1	; 0x1d
    37b0:	f8 01       	movw	r30, r16
    37b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    37b4:	8f 3f       	cpi	r24, 0xFF	; 255
    37b6:	09 f4       	brne	.+2      	; 0x37ba <xQueueGenericSend+0x17c>
    37b8:	16 8e       	std	Z+30, r1	; 0x1e
    37ba:	0f 90       	pop	r0
    37bc:	0f be       	out	0x3f, r0	; 63
    37be:	be 01       	movw	r22, r28
    37c0:	6c 5f       	subi	r22, 0xFC	; 252
    37c2:	7f 4f       	sbci	r23, 0xFF	; 255
    37c4:	ce 01       	movw	r24, r28
    37c6:	01 96       	adiw	r24, 0x01	; 1
    37c8:	0e 94 1c 2b 	call	0x5638	; 0x5638 <xTaskCheckForTimeOut>
    37cc:	81 11       	cpse	r24, r1
    37ce:	96 c0       	rjmp	.+300    	; 0x38fc <xQueueGenericSend+0x2be>
    37d0:	0f b6       	in	r0, 0x3f	; 63
    37d2:	f8 94       	cli
    37d4:	0f 92       	push	r0
    37d6:	f8 01       	movw	r30, r16
    37d8:	92 8d       	ldd	r25, Z+26	; 0x1a
    37da:	83 8d       	ldd	r24, Z+27	; 0x1b
    37dc:	0f 90       	pop	r0
    37de:	0f be       	out	0x3f, r0	; 63
    37e0:	98 13       	cpse	r25, r24
    37e2:	4a c0       	rjmp	.+148    	; 0x3878 <xQueueGenericSend+0x23a>
    37e4:	6c 81       	ldd	r22, Y+4	; 0x04
    37e6:	7d 81       	ldd	r23, Y+5	; 0x05
    37e8:	c7 01       	movw	r24, r14
    37ea:	0e 94 6d 2a 	call	0x54da	; 0x54da <vTaskPlaceOnEventList>
    37ee:	0f b6       	in	r0, 0x3f	; 63
    37f0:	f8 94       	cli
    37f2:	0f 92       	push	r0
    37f4:	f8 01       	movw	r30, r16
    37f6:	86 8d       	ldd	r24, Z+30	; 0x1e
    37f8:	18 16       	cp	r1, r24
    37fa:	ac f4       	brge	.+42     	; 0x3826 <xQueueGenericSend+0x1e8>
    37fc:	81 89       	ldd	r24, Z+17	; 0x11
    37fe:	81 11       	cpse	r24, r1
    3800:	05 c0       	rjmp	.+10     	; 0x380c <xQueueGenericSend+0x1ce>
    3802:	11 c0       	rjmp	.+34     	; 0x3826 <xQueueGenericSend+0x1e8>
    3804:	f8 01       	movw	r30, r16
    3806:	81 89       	ldd	r24, Z+17	; 0x11
    3808:	88 23       	and	r24, r24
    380a:	69 f0       	breq	.+26     	; 0x3826 <xQueueGenericSend+0x1e8>
    380c:	c6 01       	movw	r24, r12
    380e:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3812:	81 11       	cpse	r24, r1
    3814:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3818:	f8 01       	movw	r30, r16
    381a:	86 8d       	ldd	r24, Z+30	; 0x1e
    381c:	81 50       	subi	r24, 0x01	; 1
    381e:	86 8f       	std	Z+30, r24	; 0x1e
    3820:	86 8d       	ldd	r24, Z+30	; 0x1e
    3822:	18 16       	cp	r1, r24
    3824:	7c f3       	brlt	.-34     	; 0x3804 <xQueueGenericSend+0x1c6>
    3826:	f8 01       	movw	r30, r16
    3828:	96 8e       	std	Z+30, r9	; 0x1e
    382a:	0f 90       	pop	r0
    382c:	0f be       	out	0x3f, r0	; 63
    382e:	0f b6       	in	r0, 0x3f	; 63
    3830:	f8 94       	cli
    3832:	0f 92       	push	r0
    3834:	85 8d       	ldd	r24, Z+29	; 0x1d
    3836:	18 16       	cp	r1, r24
    3838:	ac f4       	brge	.+42     	; 0x3864 <xQueueGenericSend+0x226>
    383a:	80 85       	ldd	r24, Z+8	; 0x08
    383c:	81 11       	cpse	r24, r1
    383e:	05 c0       	rjmp	.+10     	; 0x384a <xQueueGenericSend+0x20c>
    3840:	11 c0       	rjmp	.+34     	; 0x3864 <xQueueGenericSend+0x226>
    3842:	f8 01       	movw	r30, r16
    3844:	80 85       	ldd	r24, Z+8	; 0x08
    3846:	88 23       	and	r24, r24
    3848:	69 f0       	breq	.+26     	; 0x3864 <xQueueGenericSend+0x226>
    384a:	c7 01       	movw	r24, r14
    384c:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3850:	81 11       	cpse	r24, r1
    3852:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3856:	f8 01       	movw	r30, r16
    3858:	85 8d       	ldd	r24, Z+29	; 0x1d
    385a:	81 50       	subi	r24, 0x01	; 1
    385c:	85 8f       	std	Z+29, r24	; 0x1d
    385e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3860:	18 16       	cp	r1, r24
    3862:	7c f3       	brlt	.-34     	; 0x3842 <xQueueGenericSend+0x204>
    3864:	f8 01       	movw	r30, r16
    3866:	95 8e       	std	Z+29, r9	; 0x1d
    3868:	0f 90       	pop	r0
    386a:	0f be       	out	0x3f, r0	; 63
    386c:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    3870:	81 11       	cpse	r24, r1
    3872:	0a cf       	rjmp	.-492    	; 0x3688 <xQueueGenericSend+0x4a>
    3874:	35 dc       	rcall	.-1942   	; 0x30e0 <vPortYield>
    3876:	08 cf       	rjmp	.-496    	; 0x3688 <xQueueGenericSend+0x4a>
    3878:	0f b6       	in	r0, 0x3f	; 63
    387a:	f8 94       	cli
    387c:	0f 92       	push	r0
    387e:	f8 01       	movw	r30, r16
    3880:	86 8d       	ldd	r24, Z+30	; 0x1e
    3882:	18 16       	cp	r1, r24
    3884:	ac f4       	brge	.+42     	; 0x38b0 <xQueueGenericSend+0x272>
    3886:	81 89       	ldd	r24, Z+17	; 0x11
    3888:	81 11       	cpse	r24, r1
    388a:	05 c0       	rjmp	.+10     	; 0x3896 <xQueueGenericSend+0x258>
    388c:	11 c0       	rjmp	.+34     	; 0x38b0 <xQueueGenericSend+0x272>
    388e:	f8 01       	movw	r30, r16
    3890:	81 89       	ldd	r24, Z+17	; 0x11
    3892:	88 23       	and	r24, r24
    3894:	69 f0       	breq	.+26     	; 0x38b0 <xQueueGenericSend+0x272>
    3896:	c6 01       	movw	r24, r12
    3898:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    389c:	81 11       	cpse	r24, r1
    389e:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    38a2:	f8 01       	movw	r30, r16
    38a4:	86 8d       	ldd	r24, Z+30	; 0x1e
    38a6:	81 50       	subi	r24, 0x01	; 1
    38a8:	86 8f       	std	Z+30, r24	; 0x1e
    38aa:	86 8d       	ldd	r24, Z+30	; 0x1e
    38ac:	18 16       	cp	r1, r24
    38ae:	7c f3       	brlt	.-34     	; 0x388e <xQueueGenericSend+0x250>
    38b0:	f8 01       	movw	r30, r16
    38b2:	96 8e       	std	Z+30, r9	; 0x1e
    38b4:	0f 90       	pop	r0
    38b6:	0f be       	out	0x3f, r0	; 63
    38b8:	0f b6       	in	r0, 0x3f	; 63
    38ba:	f8 94       	cli
    38bc:	0f 92       	push	r0
    38be:	85 8d       	ldd	r24, Z+29	; 0x1d
    38c0:	18 16       	cp	r1, r24
    38c2:	ac f4       	brge	.+42     	; 0x38ee <xQueueGenericSend+0x2b0>
    38c4:	80 85       	ldd	r24, Z+8	; 0x08
    38c6:	81 11       	cpse	r24, r1
    38c8:	05 c0       	rjmp	.+10     	; 0x38d4 <xQueueGenericSend+0x296>
    38ca:	11 c0       	rjmp	.+34     	; 0x38ee <xQueueGenericSend+0x2b0>
    38cc:	f8 01       	movw	r30, r16
    38ce:	80 85       	ldd	r24, Z+8	; 0x08
    38d0:	88 23       	and	r24, r24
    38d2:	69 f0       	breq	.+26     	; 0x38ee <xQueueGenericSend+0x2b0>
    38d4:	c7 01       	movw	r24, r14
    38d6:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    38da:	81 11       	cpse	r24, r1
    38dc:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    38e0:	f8 01       	movw	r30, r16
    38e2:	95 8d       	ldd	r25, Z+29	; 0x1d
    38e4:	91 50       	subi	r25, 0x01	; 1
    38e6:	95 8f       	std	Z+29, r25	; 0x1d
    38e8:	85 8d       	ldd	r24, Z+29	; 0x1d
    38ea:	18 16       	cp	r1, r24
    38ec:	7c f3       	brlt	.-34     	; 0x38cc <xQueueGenericSend+0x28e>
    38ee:	f8 01       	movw	r30, r16
    38f0:	95 8e       	std	Z+29, r9	; 0x1d
    38f2:	0f 90       	pop	r0
    38f4:	0f be       	out	0x3f, r0	; 63
    38f6:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    38fa:	c6 ce       	rjmp	.-628    	; 0x3688 <xQueueGenericSend+0x4a>
    38fc:	0f b6       	in	r0, 0x3f	; 63
    38fe:	f8 94       	cli
    3900:	0f 92       	push	r0
    3902:	f8 01       	movw	r30, r16
    3904:	86 8d       	ldd	r24, Z+30	; 0x1e
    3906:	18 16       	cp	r1, r24
    3908:	d4 f4       	brge	.+52     	; 0x393e <xQueueGenericSend+0x300>
    390a:	81 89       	ldd	r24, Z+17	; 0x11
    390c:	81 11       	cpse	r24, r1
    390e:	06 c0       	rjmp	.+12     	; 0x391c <xQueueGenericSend+0x2de>
    3910:	16 c0       	rjmp	.+44     	; 0x393e <xQueueGenericSend+0x300>
    3912:	f8 01       	movw	r30, r16
    3914:	91 89       	ldd	r25, Z+17	; 0x11
    3916:	91 11       	cpse	r25, r1
    3918:	05 c0       	rjmp	.+10     	; 0x3924 <xQueueGenericSend+0x2e6>
    391a:	11 c0       	rjmp	.+34     	; 0x393e <xQueueGenericSend+0x300>
    391c:	78 01       	movw	r14, r16
    391e:	f1 e1       	ldi	r31, 0x11	; 17
    3920:	ef 0e       	add	r14, r31
    3922:	f1 1c       	adc	r15, r1
    3924:	c7 01       	movw	r24, r14
    3926:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    392a:	81 11       	cpse	r24, r1
    392c:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3930:	f8 01       	movw	r30, r16
    3932:	96 8d       	ldd	r25, Z+30	; 0x1e
    3934:	91 50       	subi	r25, 0x01	; 1
    3936:	96 8f       	std	Z+30, r25	; 0x1e
    3938:	96 8d       	ldd	r25, Z+30	; 0x1e
    393a:	19 16       	cp	r1, r25
    393c:	54 f3       	brlt	.-44     	; 0x3912 <xQueueGenericSend+0x2d4>
    393e:	8f ef       	ldi	r24, 0xFF	; 255
    3940:	f8 01       	movw	r30, r16
    3942:	86 8f       	std	Z+30, r24	; 0x1e
    3944:	0f 90       	pop	r0
    3946:	0f be       	out	0x3f, r0	; 63
    3948:	0f b6       	in	r0, 0x3f	; 63
    394a:	f8 94       	cli
    394c:	0f 92       	push	r0
    394e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3950:	18 16       	cp	r1, r24
    3952:	d4 f4       	brge	.+52     	; 0x3988 <xQueueGenericSend+0x34a>
    3954:	80 85       	ldd	r24, Z+8	; 0x08
    3956:	81 11       	cpse	r24, r1
    3958:	06 c0       	rjmp	.+12     	; 0x3966 <xQueueGenericSend+0x328>
    395a:	16 c0       	rjmp	.+44     	; 0x3988 <xQueueGenericSend+0x34a>
    395c:	f8 01       	movw	r30, r16
    395e:	90 85       	ldd	r25, Z+8	; 0x08
    3960:	91 11       	cpse	r25, r1
    3962:	05 c0       	rjmp	.+10     	; 0x396e <xQueueGenericSend+0x330>
    3964:	11 c0       	rjmp	.+34     	; 0x3988 <xQueueGenericSend+0x34a>
    3966:	78 01       	movw	r14, r16
    3968:	f8 e0       	ldi	r31, 0x08	; 8
    396a:	ef 0e       	add	r14, r31
    396c:	f1 1c       	adc	r15, r1
    396e:	c7 01       	movw	r24, r14
    3970:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3974:	81 11       	cpse	r24, r1
    3976:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    397a:	f8 01       	movw	r30, r16
    397c:	95 8d       	ldd	r25, Z+29	; 0x1d
    397e:	91 50       	subi	r25, 0x01	; 1
    3980:	95 8f       	std	Z+29, r25	; 0x1d
    3982:	95 8d       	ldd	r25, Z+29	; 0x1d
    3984:	19 16       	cp	r1, r25
    3986:	54 f3       	brlt	.-44     	; 0x395c <xQueueGenericSend+0x31e>
    3988:	8f ef       	ldi	r24, 0xFF	; 255
    398a:	f8 01       	movw	r30, r16
    398c:	85 8f       	std	Z+29, r24	; 0x1d
    398e:	0f 90       	pop	r0
    3990:	0f be       	out	0x3f, r0	; 63
    3992:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    3996:	80 e0       	ldi	r24, 0x00	; 0
    3998:	0f c0       	rjmp	.+30     	; 0x39b8 <xQueueGenericSend+0x37a>
    399a:	f8 01       	movw	r30, r16
    399c:	44 8d       	ldd	r20, Z+28	; 0x1c
    399e:	44 23       	and	r20, r20
    39a0:	09 f4       	brne	.+2      	; 0x39a4 <xQueueGenericSend+0x366>
    39a2:	82 ce       	rjmp	.-764    	; 0x36a8 <xQueueGenericSend+0x6a>
    39a4:	b2 ce       	rjmp	.-668    	; 0x370a <xQueueGenericSend+0xcc>
    39a6:	f8 01       	movw	r30, r16
    39a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    39aa:	8f 5f       	subi	r24, 0xFF	; 255
    39ac:	82 8f       	std	Z+26, r24	; 0x1a
    39ae:	81 89       	ldd	r24, Z+17	; 0x11
    39b0:	88 23       	and	r24, r24
    39b2:	09 f4       	brne	.+2      	; 0x39b6 <xQueueGenericSend+0x378>
    39b4:	de ce       	rjmp	.-580    	; 0x3772 <xQueueGenericSend+0x134>
    39b6:	d3 ce       	rjmp	.-602    	; 0x375e <xQueueGenericSend+0x120>
    39b8:	0f 90       	pop	r0
    39ba:	0f 90       	pop	r0
    39bc:	0f 90       	pop	r0
    39be:	0f 90       	pop	r0
    39c0:	0f 90       	pop	r0
    39c2:	df 91       	pop	r29
    39c4:	cf 91       	pop	r28
    39c6:	1f 91       	pop	r17
    39c8:	0f 91       	pop	r16
    39ca:	ff 90       	pop	r15
    39cc:	ef 90       	pop	r14
    39ce:	df 90       	pop	r13
    39d0:	cf 90       	pop	r12
    39d2:	bf 90       	pop	r11
    39d4:	af 90       	pop	r10
    39d6:	9f 90       	pop	r9
    39d8:	8f 90       	pop	r8
    39da:	7f 90       	pop	r7
    39dc:	6f 90       	pop	r6
    39de:	08 95       	ret

000039e0 <xQueueGive>:
    39e0:	9f 92       	push	r9
    39e2:	af 92       	push	r10
    39e4:	bf 92       	push	r11
    39e6:	cf 92       	push	r12
    39e8:	df 92       	push	r13
    39ea:	ef 92       	push	r14
    39ec:	ff 92       	push	r15
    39ee:	0f 93       	push	r16
    39f0:	1f 93       	push	r17
    39f2:	cf 93       	push	r28
    39f4:	df 93       	push	r29
    39f6:	00 d0       	rcall	.+0      	; 0x39f8 <xQueueGive+0x18>
    39f8:	1f 92       	push	r1
    39fa:	1f 92       	push	r1
    39fc:	cd b7       	in	r28, 0x3d	; 61
    39fe:	de b7       	in	r29, 0x3e	; 62
    3a00:	8c 01       	movw	r16, r24
    3a02:	7d 83       	std	Y+5, r23	; 0x05
    3a04:	6c 83       	std	Y+4, r22	; 0x04
    3a06:	a1 2c       	mov	r10, r1
    3a08:	99 24       	eor	r9, r9
    3a0a:	93 94       	inc	r9
    3a0c:	bb 24       	eor	r11, r11
    3a0e:	ba 94       	dec	r11
    3a10:	7c 01       	movw	r14, r24
    3a12:	88 e0       	ldi	r24, 0x08	; 8
    3a14:	e8 0e       	add	r14, r24
    3a16:	f1 1c       	adc	r15, r1
    3a18:	68 01       	movw	r12, r16
    3a1a:	e1 e1       	ldi	r30, 0x11	; 17
    3a1c:	ce 0e       	add	r12, r30
    3a1e:	d1 1c       	adc	r13, r1
    3a20:	0f b6       	in	r0, 0x3f	; 63
    3a22:	f8 94       	cli
    3a24:	0f 92       	push	r0
    3a26:	f8 01       	movw	r30, r16
    3a28:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a2a:	83 8d       	ldd	r24, Z+27	; 0x1b
    3a2c:	98 17       	cp	r25, r24
    3a2e:	00 f5       	brcc	.+64     	; 0x3a70 <xQueueGive+0x90>
    3a30:	80 81       	ld	r24, Z
    3a32:	91 81       	ldd	r25, Z+1	; 0x01
    3a34:	89 2b       	or	r24, r25
    3a36:	09 f0       	breq	.+2      	; 0x3a3a <xQueueGive+0x5a>
    3a38:	2b c1       	rjmp	.+598    	; 0x3c90 <xQueueGive+0x2b0>
    3a3a:	82 81       	ldd	r24, Z+2	; 0x02
    3a3c:	93 81       	ldd	r25, Z+3	; 0x03
    3a3e:	0e 94 c2 2b 	call	0x5784	; 0x5784 <xTaskPriorityDisinherit>
    3a42:	f8 01       	movw	r30, r16
    3a44:	13 82       	std	Z+3, r1	; 0x03
    3a46:	12 82       	std	Z+2, r1	; 0x02
    3a48:	92 8d       	ldd	r25, Z+26	; 0x1a
    3a4a:	9f 5f       	subi	r25, 0xFF	; 255
    3a4c:	92 8f       	std	Z+26, r25	; 0x1a
    3a4e:	91 89       	ldd	r25, Z+17	; 0x11
    3a50:	99 23       	and	r25, r25
    3a52:	41 f0       	breq	.+16     	; 0x3a64 <xQueueGive+0x84>
    3a54:	c8 01       	movw	r24, r16
    3a56:	41 96       	adiw	r24, 0x11	; 17
    3a58:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3a5c:	81 30       	cpi	r24, 0x01	; 1
    3a5e:	21 f4       	brne	.+8      	; 0x3a68 <xQueueGive+0x88>
    3a60:	3f db       	rcall	.-2434   	; 0x30e0 <vPortYield>
    3a62:	02 c0       	rjmp	.+4      	; 0x3a68 <xQueueGive+0x88>
    3a64:	81 11       	cpse	r24, r1
    3a66:	3c db       	rcall	.-2440   	; 0x30e0 <vPortYield>
    3a68:	0f 90       	pop	r0
    3a6a:	0f be       	out	0x3f, r0	; 63
    3a6c:	81 e0       	ldi	r24, 0x01	; 1
    3a6e:	19 c1       	rjmp	.+562    	; 0x3ca2 <xQueueGive+0x2c2>
    3a70:	8c 81       	ldd	r24, Y+4	; 0x04
    3a72:	9d 81       	ldd	r25, Y+5	; 0x05
    3a74:	89 2b       	or	r24, r25
    3a76:	21 f4       	brne	.+8      	; 0x3a80 <xQueueGive+0xa0>
    3a78:	0f 90       	pop	r0
    3a7a:	0f be       	out	0x3f, r0	; 63
    3a7c:	80 e0       	ldi	r24, 0x00	; 0
    3a7e:	11 c1       	rjmp	.+546    	; 0x3ca2 <xQueueGive+0x2c2>
    3a80:	a1 10       	cpse	r10, r1
    3a82:	05 c0       	rjmp	.+10     	; 0x3a8e <xQueueGive+0xae>
    3a84:	ce 01       	movw	r24, r28
    3a86:	01 96       	adiw	r24, 0x01	; 1
    3a88:	0e 94 11 2b 	call	0x5622	; 0x5622 <vTaskSetTimeOutState>
    3a8c:	a9 2c       	mov	r10, r9
    3a8e:	0f 90       	pop	r0
    3a90:	0f be       	out	0x3f, r0	; 63
    3a92:	0e 94 d9 27 	call	0x4fb2	; 0x4fb2 <vTaskSuspendAll>
    3a96:	0f b6       	in	r0, 0x3f	; 63
    3a98:	f8 94       	cli
    3a9a:	0f 92       	push	r0
    3a9c:	f8 01       	movw	r30, r16
    3a9e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3aa0:	8f 3f       	cpi	r24, 0xFF	; 255
    3aa2:	09 f4       	brne	.+2      	; 0x3aa6 <xQueueGive+0xc6>
    3aa4:	15 8e       	std	Z+29, r1	; 0x1d
    3aa6:	f8 01       	movw	r30, r16
    3aa8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3aaa:	8f 3f       	cpi	r24, 0xFF	; 255
    3aac:	09 f4       	brne	.+2      	; 0x3ab0 <xQueueGive+0xd0>
    3aae:	16 8e       	std	Z+30, r1	; 0x1e
    3ab0:	0f 90       	pop	r0
    3ab2:	0f be       	out	0x3f, r0	; 63
    3ab4:	be 01       	movw	r22, r28
    3ab6:	6c 5f       	subi	r22, 0xFC	; 252
    3ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    3aba:	ce 01       	movw	r24, r28
    3abc:	01 96       	adiw	r24, 0x01	; 1
    3abe:	0e 94 1c 2b 	call	0x5638	; 0x5638 <xTaskCheckForTimeOut>
    3ac2:	81 11       	cpse	r24, r1
    3ac4:	96 c0       	rjmp	.+300    	; 0x3bf2 <xQueueGive+0x212>
    3ac6:	0f b6       	in	r0, 0x3f	; 63
    3ac8:	f8 94       	cli
    3aca:	0f 92       	push	r0
    3acc:	f8 01       	movw	r30, r16
    3ace:	92 8d       	ldd	r25, Z+26	; 0x1a
    3ad0:	83 8d       	ldd	r24, Z+27	; 0x1b
    3ad2:	0f 90       	pop	r0
    3ad4:	0f be       	out	0x3f, r0	; 63
    3ad6:	98 13       	cpse	r25, r24
    3ad8:	4a c0       	rjmp	.+148    	; 0x3b6e <xQueueGive+0x18e>
    3ada:	6c 81       	ldd	r22, Y+4	; 0x04
    3adc:	7d 81       	ldd	r23, Y+5	; 0x05
    3ade:	c7 01       	movw	r24, r14
    3ae0:	0e 94 6d 2a 	call	0x54da	; 0x54da <vTaskPlaceOnEventList>
    3ae4:	0f b6       	in	r0, 0x3f	; 63
    3ae6:	f8 94       	cli
    3ae8:	0f 92       	push	r0
    3aea:	f8 01       	movw	r30, r16
    3aec:	86 8d       	ldd	r24, Z+30	; 0x1e
    3aee:	18 16       	cp	r1, r24
    3af0:	ac f4       	brge	.+42     	; 0x3b1c <xQueueGive+0x13c>
    3af2:	81 89       	ldd	r24, Z+17	; 0x11
    3af4:	81 11       	cpse	r24, r1
    3af6:	05 c0       	rjmp	.+10     	; 0x3b02 <xQueueGive+0x122>
    3af8:	11 c0       	rjmp	.+34     	; 0x3b1c <xQueueGive+0x13c>
    3afa:	f8 01       	movw	r30, r16
    3afc:	81 89       	ldd	r24, Z+17	; 0x11
    3afe:	88 23       	and	r24, r24
    3b00:	69 f0       	breq	.+26     	; 0x3b1c <xQueueGive+0x13c>
    3b02:	c6 01       	movw	r24, r12
    3b04:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3b08:	81 11       	cpse	r24, r1
    3b0a:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3b0e:	f8 01       	movw	r30, r16
    3b10:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b12:	81 50       	subi	r24, 0x01	; 1
    3b14:	86 8f       	std	Z+30, r24	; 0x1e
    3b16:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b18:	18 16       	cp	r1, r24
    3b1a:	7c f3       	brlt	.-34     	; 0x3afa <xQueueGive+0x11a>
    3b1c:	f8 01       	movw	r30, r16
    3b1e:	b6 8e       	std	Z+30, r11	; 0x1e
    3b20:	0f 90       	pop	r0
    3b22:	0f be       	out	0x3f, r0	; 63
    3b24:	0f b6       	in	r0, 0x3f	; 63
    3b26:	f8 94       	cli
    3b28:	0f 92       	push	r0
    3b2a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b2c:	18 16       	cp	r1, r24
    3b2e:	ac f4       	brge	.+42     	; 0x3b5a <xQueueGive+0x17a>
    3b30:	80 85       	ldd	r24, Z+8	; 0x08
    3b32:	81 11       	cpse	r24, r1
    3b34:	05 c0       	rjmp	.+10     	; 0x3b40 <xQueueGive+0x160>
    3b36:	11 c0       	rjmp	.+34     	; 0x3b5a <xQueueGive+0x17a>
    3b38:	f8 01       	movw	r30, r16
    3b3a:	80 85       	ldd	r24, Z+8	; 0x08
    3b3c:	88 23       	and	r24, r24
    3b3e:	69 f0       	breq	.+26     	; 0x3b5a <xQueueGive+0x17a>
    3b40:	c7 01       	movw	r24, r14
    3b42:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3b46:	81 11       	cpse	r24, r1
    3b48:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3b4c:	f8 01       	movw	r30, r16
    3b4e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b50:	81 50       	subi	r24, 0x01	; 1
    3b52:	85 8f       	std	Z+29, r24	; 0x1d
    3b54:	85 8d       	ldd	r24, Z+29	; 0x1d
    3b56:	18 16       	cp	r1, r24
    3b58:	7c f3       	brlt	.-34     	; 0x3b38 <xQueueGive+0x158>
    3b5a:	f8 01       	movw	r30, r16
    3b5c:	b5 8e       	std	Z+29, r11	; 0x1d
    3b5e:	0f 90       	pop	r0
    3b60:	0f be       	out	0x3f, r0	; 63
    3b62:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    3b66:	81 11       	cpse	r24, r1
    3b68:	5b cf       	rjmp	.-330    	; 0x3a20 <xQueueGive+0x40>
    3b6a:	ba da       	rcall	.-2700   	; 0x30e0 <vPortYield>
    3b6c:	59 cf       	rjmp	.-334    	; 0x3a20 <xQueueGive+0x40>
    3b6e:	0f b6       	in	r0, 0x3f	; 63
    3b70:	f8 94       	cli
    3b72:	0f 92       	push	r0
    3b74:	f8 01       	movw	r30, r16
    3b76:	86 8d       	ldd	r24, Z+30	; 0x1e
    3b78:	18 16       	cp	r1, r24
    3b7a:	ac f4       	brge	.+42     	; 0x3ba6 <xQueueGive+0x1c6>
    3b7c:	81 89       	ldd	r24, Z+17	; 0x11
    3b7e:	81 11       	cpse	r24, r1
    3b80:	05 c0       	rjmp	.+10     	; 0x3b8c <xQueueGive+0x1ac>
    3b82:	11 c0       	rjmp	.+34     	; 0x3ba6 <xQueueGive+0x1c6>
    3b84:	f8 01       	movw	r30, r16
    3b86:	81 89       	ldd	r24, Z+17	; 0x11
    3b88:	88 23       	and	r24, r24
    3b8a:	69 f0       	breq	.+26     	; 0x3ba6 <xQueueGive+0x1c6>
    3b8c:	c6 01       	movw	r24, r12
    3b8e:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3b92:	81 11       	cpse	r24, r1
    3b94:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3b98:	f8 01       	movw	r30, r16
    3b9a:	96 8d       	ldd	r25, Z+30	; 0x1e
    3b9c:	91 50       	subi	r25, 0x01	; 1
    3b9e:	96 8f       	std	Z+30, r25	; 0x1e
    3ba0:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ba2:	18 16       	cp	r1, r24
    3ba4:	7c f3       	brlt	.-34     	; 0x3b84 <xQueueGive+0x1a4>
    3ba6:	f8 01       	movw	r30, r16
    3ba8:	b6 8e       	std	Z+30, r11	; 0x1e
    3baa:	0f 90       	pop	r0
    3bac:	0f be       	out	0x3f, r0	; 63
    3bae:	0f b6       	in	r0, 0x3f	; 63
    3bb0:	f8 94       	cli
    3bb2:	0f 92       	push	r0
    3bb4:	85 8d       	ldd	r24, Z+29	; 0x1d
    3bb6:	18 16       	cp	r1, r24
    3bb8:	ac f4       	brge	.+42     	; 0x3be4 <xQueueGive+0x204>
    3bba:	80 85       	ldd	r24, Z+8	; 0x08
    3bbc:	81 11       	cpse	r24, r1
    3bbe:	05 c0       	rjmp	.+10     	; 0x3bca <xQueueGive+0x1ea>
    3bc0:	11 c0       	rjmp	.+34     	; 0x3be4 <xQueueGive+0x204>
    3bc2:	f8 01       	movw	r30, r16
    3bc4:	80 85       	ldd	r24, Z+8	; 0x08
    3bc6:	88 23       	and	r24, r24
    3bc8:	69 f0       	breq	.+26     	; 0x3be4 <xQueueGive+0x204>
    3bca:	c7 01       	movw	r24, r14
    3bcc:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3bd0:	81 11       	cpse	r24, r1
    3bd2:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3bd6:	f8 01       	movw	r30, r16
    3bd8:	95 8d       	ldd	r25, Z+29	; 0x1d
    3bda:	91 50       	subi	r25, 0x01	; 1
    3bdc:	95 8f       	std	Z+29, r25	; 0x1d
    3bde:	85 8d       	ldd	r24, Z+29	; 0x1d
    3be0:	18 16       	cp	r1, r24
    3be2:	7c f3       	brlt	.-34     	; 0x3bc2 <xQueueGive+0x1e2>
    3be4:	f8 01       	movw	r30, r16
    3be6:	b5 8e       	std	Z+29, r11	; 0x1d
    3be8:	0f 90       	pop	r0
    3bea:	0f be       	out	0x3f, r0	; 63
    3bec:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    3bf0:	17 cf       	rjmp	.-466    	; 0x3a20 <xQueueGive+0x40>
    3bf2:	0f b6       	in	r0, 0x3f	; 63
    3bf4:	f8 94       	cli
    3bf6:	0f 92       	push	r0
    3bf8:	f8 01       	movw	r30, r16
    3bfa:	86 8d       	ldd	r24, Z+30	; 0x1e
    3bfc:	18 16       	cp	r1, r24
    3bfe:	d4 f4       	brge	.+52     	; 0x3c34 <xQueueGive+0x254>
    3c00:	81 89       	ldd	r24, Z+17	; 0x11
    3c02:	81 11       	cpse	r24, r1
    3c04:	06 c0       	rjmp	.+12     	; 0x3c12 <xQueueGive+0x232>
    3c06:	16 c0       	rjmp	.+44     	; 0x3c34 <xQueueGive+0x254>
    3c08:	f8 01       	movw	r30, r16
    3c0a:	91 89       	ldd	r25, Z+17	; 0x11
    3c0c:	91 11       	cpse	r25, r1
    3c0e:	05 c0       	rjmp	.+10     	; 0x3c1a <xQueueGive+0x23a>
    3c10:	11 c0       	rjmp	.+34     	; 0x3c34 <xQueueGive+0x254>
    3c12:	78 01       	movw	r14, r16
    3c14:	f1 e1       	ldi	r31, 0x11	; 17
    3c16:	ef 0e       	add	r14, r31
    3c18:	f1 1c       	adc	r15, r1
    3c1a:	c7 01       	movw	r24, r14
    3c1c:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3c20:	81 11       	cpse	r24, r1
    3c22:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3c26:	f8 01       	movw	r30, r16
    3c28:	96 8d       	ldd	r25, Z+30	; 0x1e
    3c2a:	91 50       	subi	r25, 0x01	; 1
    3c2c:	96 8f       	std	Z+30, r25	; 0x1e
    3c2e:	96 8d       	ldd	r25, Z+30	; 0x1e
    3c30:	19 16       	cp	r1, r25
    3c32:	54 f3       	brlt	.-44     	; 0x3c08 <xQueueGive+0x228>
    3c34:	8f ef       	ldi	r24, 0xFF	; 255
    3c36:	f8 01       	movw	r30, r16
    3c38:	86 8f       	std	Z+30, r24	; 0x1e
    3c3a:	0f 90       	pop	r0
    3c3c:	0f be       	out	0x3f, r0	; 63
    3c3e:	0f b6       	in	r0, 0x3f	; 63
    3c40:	f8 94       	cli
    3c42:	0f 92       	push	r0
    3c44:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c46:	18 16       	cp	r1, r24
    3c48:	d4 f4       	brge	.+52     	; 0x3c7e <xQueueGive+0x29e>
    3c4a:	80 85       	ldd	r24, Z+8	; 0x08
    3c4c:	81 11       	cpse	r24, r1
    3c4e:	06 c0       	rjmp	.+12     	; 0x3c5c <xQueueGive+0x27c>
    3c50:	16 c0       	rjmp	.+44     	; 0x3c7e <xQueueGive+0x29e>
    3c52:	f8 01       	movw	r30, r16
    3c54:	90 85       	ldd	r25, Z+8	; 0x08
    3c56:	91 11       	cpse	r25, r1
    3c58:	05 c0       	rjmp	.+10     	; 0x3c64 <xQueueGive+0x284>
    3c5a:	11 c0       	rjmp	.+34     	; 0x3c7e <xQueueGive+0x29e>
    3c5c:	78 01       	movw	r14, r16
    3c5e:	f8 e0       	ldi	r31, 0x08	; 8
    3c60:	ef 0e       	add	r14, r31
    3c62:	f1 1c       	adc	r15, r1
    3c64:	c7 01       	movw	r24, r14
    3c66:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3c6a:	81 11       	cpse	r24, r1
    3c6c:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
    3c70:	f8 01       	movw	r30, r16
    3c72:	95 8d       	ldd	r25, Z+29	; 0x1d
    3c74:	91 50       	subi	r25, 0x01	; 1
    3c76:	95 8f       	std	Z+29, r25	; 0x1d
    3c78:	95 8d       	ldd	r25, Z+29	; 0x1d
    3c7a:	19 16       	cp	r1, r25
    3c7c:	54 f3       	brlt	.-44     	; 0x3c52 <xQueueGive+0x272>
    3c7e:	8f ef       	ldi	r24, 0xFF	; 255
    3c80:	f8 01       	movw	r30, r16
    3c82:	85 8f       	std	Z+29, r24	; 0x1d
    3c84:	0f 90       	pop	r0
    3c86:	0f be       	out	0x3f, r0	; 63
    3c88:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    3c8c:	80 e0       	ldi	r24, 0x00	; 0
    3c8e:	09 c0       	rjmp	.+18     	; 0x3ca2 <xQueueGive+0x2c2>
    3c90:	f8 01       	movw	r30, r16
    3c92:	82 8d       	ldd	r24, Z+26	; 0x1a
    3c94:	8f 5f       	subi	r24, 0xFF	; 255
    3c96:	82 8f       	std	Z+26, r24	; 0x1a
    3c98:	81 89       	ldd	r24, Z+17	; 0x11
    3c9a:	88 23       	and	r24, r24
    3c9c:	09 f4       	brne	.+2      	; 0x3ca0 <xQueueGive+0x2c0>
    3c9e:	e4 ce       	rjmp	.-568    	; 0x3a68 <xQueueGive+0x88>
    3ca0:	d9 ce       	rjmp	.-590    	; 0x3a54 <xQueueGive+0x74>
    3ca2:	0f 90       	pop	r0
    3ca4:	0f 90       	pop	r0
    3ca6:	0f 90       	pop	r0
    3ca8:	0f 90       	pop	r0
    3caa:	0f 90       	pop	r0
    3cac:	df 91       	pop	r29
    3cae:	cf 91       	pop	r28
    3cb0:	1f 91       	pop	r17
    3cb2:	0f 91       	pop	r16
    3cb4:	ff 90       	pop	r15
    3cb6:	ef 90       	pop	r14
    3cb8:	df 90       	pop	r13
    3cba:	cf 90       	pop	r12
    3cbc:	bf 90       	pop	r11
    3cbe:	af 90       	pop	r10
    3cc0:	9f 90       	pop	r9
    3cc2:	08 95       	ret

00003cc4 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    3cc4:	cf 93       	push	r28
    3cc6:	df 93       	push	r29
    3cc8:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    3cca:	92 8d       	ldd	r25, Z+26	; 0x1a
    3ccc:	83 8d       	ldd	r24, Z+27	; 0x1b
    3cce:	98 17       	cp	r25, r24
    3cd0:	d0 f4       	brcc	.+52     	; 0x3d06 <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    3cd2:	82 8d       	ldd	r24, Z+26	; 0x1a
    3cd4:	8f 5f       	subi	r24, 0xFF	; 255
    3cd6:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    3cd8:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cda:	8f 3f       	cpi	r24, 0xFF	; 255
    3cdc:	79 f4       	brne	.+30     	; 0x3cfc <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3cde:	81 89       	ldd	r24, Z+17	; 0x11
    3ce0:	88 23       	and	r24, r24
    3ce2:	99 f0       	breq	.+38     	; 0x3d0a <xQueueGiveFromISR+0x46>
    3ce4:	eb 01       	movw	r28, r22
    3ce6:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ce8:	41 96       	adiw	r24, 0x11	; 17
    3cea:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3cee:	88 23       	and	r24, r24
    3cf0:	71 f0       	breq	.+28     	; 0x3d0e <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    3cf2:	20 97       	sbiw	r28, 0x00	; 0
    3cf4:	71 f0       	breq	.+28     	; 0x3d12 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    3cf6:	81 e0       	ldi	r24, 0x01	; 1
    3cf8:	88 83       	st	Y, r24
    3cfa:	0c c0       	rjmp	.+24     	; 0x3d14 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    3cfc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cfe:	8f 5f       	subi	r24, 0xFF	; 255
    3d00:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    3d02:	81 e0       	ldi	r24, 0x01	; 1
    3d04:	07 c0       	rjmp	.+14     	; 0x3d14 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    3d06:	80 e0       	ldi	r24, 0x00	; 0
    3d08:	05 c0       	rjmp	.+10     	; 0x3d14 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    3d0a:	81 e0       	ldi	r24, 0x01	; 1
    3d0c:	03 c0       	rjmp	.+6      	; 0x3d14 <xQueueGiveFromISR+0x50>
    3d0e:	81 e0       	ldi	r24, 0x01	; 1
    3d10:	01 c0       	rjmp	.+2      	; 0x3d14 <xQueueGiveFromISR+0x50>
    3d12:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3d14:	df 91       	pop	r29
    3d16:	cf 91       	pop	r28
    3d18:	08 95       	ret

00003d1a <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    3d1a:	6f 92       	push	r6
    3d1c:	7f 92       	push	r7
    3d1e:	8f 92       	push	r8
    3d20:	9f 92       	push	r9
    3d22:	af 92       	push	r10
    3d24:	bf 92       	push	r11
    3d26:	cf 92       	push	r12
    3d28:	df 92       	push	r13
    3d2a:	ef 92       	push	r14
    3d2c:	ff 92       	push	r15
    3d2e:	0f 93       	push	r16
    3d30:	1f 93       	push	r17
    3d32:	cf 93       	push	r28
    3d34:	df 93       	push	r29
    3d36:	00 d0       	rcall	.+0      	; 0x3d38 <xQueueGenericReceive+0x1e>
    3d38:	1f 92       	push	r1
    3d3a:	1f 92       	push	r1
    3d3c:	cd b7       	in	r28, 0x3d	; 61
    3d3e:	de b7       	in	r29, 0x3e	; 62
    3d40:	8c 01       	movw	r16, r24
    3d42:	5b 01       	movw	r10, r22
    3d44:	5d 83       	std	Y+5, r21	; 0x05
    3d46:	4c 83       	std	Y+4, r20	; 0x04
    3d48:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    3d4a:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    3d4c:	77 24       	eor	r7, r7
    3d4e:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3d50:	99 24       	eor	r9, r9
    3d52:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3d54:	6c 01       	movw	r12, r24
    3d56:	88 e0       	ldi	r24, 0x08	; 8
    3d58:	c8 0e       	add	r12, r24
    3d5a:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3d5c:	78 01       	movw	r14, r16
    3d5e:	e1 e1       	ldi	r30, 0x11	; 17
    3d60:	ee 0e       	add	r14, r30
    3d62:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    3d64:	0f b6       	in	r0, 0x3f	; 63
    3d66:	f8 94       	cli
    3d68:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    3d6a:	f8 01       	movw	r30, r16
    3d6c:	82 8d       	ldd	r24, Z+26	; 0x1a
    3d6e:	88 23       	and	r24, r24
    3d70:	09 f4       	brne	.+2      	; 0x3d74 <xQueueGenericReceive+0x5a>
    3d72:	45 c0       	rjmp	.+138    	; 0x3dfe <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    3d74:	e6 80       	ldd	r14, Z+6	; 0x06
    3d76:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    3d78:	44 8d       	ldd	r20, Z+28	; 0x1c
    3d7a:	44 23       	and	r20, r20
    3d7c:	a9 f0       	breq	.+42     	; 0x3da8 <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    3d7e:	50 e0       	ldi	r21, 0x00	; 0
    3d80:	c7 01       	movw	r24, r14
    3d82:	84 0f       	add	r24, r20
    3d84:	95 1f       	adc	r25, r21
    3d86:	97 83       	std	Z+7, r25	; 0x07
    3d88:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    3d8a:	22 81       	ldd	r18, Z+2	; 0x02
    3d8c:	33 81       	ldd	r19, Z+3	; 0x03
    3d8e:	82 17       	cp	r24, r18
    3d90:	93 07       	cpc	r25, r19
    3d92:	20 f0       	brcs	.+8      	; 0x3d9c <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    3d94:	80 81       	ld	r24, Z
    3d96:	91 81       	ldd	r25, Z+1	; 0x01
    3d98:	97 83       	std	Z+7, r25	; 0x07
    3d9a:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    3d9c:	f8 01       	movw	r30, r16
    3d9e:	66 81       	ldd	r22, Z+6	; 0x06
    3da0:	77 81       	ldd	r23, Z+7	; 0x07
    3da2:	c5 01       	movw	r24, r10
    3da4:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    3da8:	61 10       	cpse	r6, r1
    3daa:	19 c0       	rjmp	.+50     	; 0x3dde <xQueueGenericReceive+0xc4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    3dac:	f8 01       	movw	r30, r16
    3dae:	82 8d       	ldd	r24, Z+26	; 0x1a
    3db0:	81 50       	subi	r24, 0x01	; 1
    3db2:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3db4:	80 81       	ld	r24, Z
    3db6:	91 81       	ldd	r25, Z+1	; 0x01
    3db8:	89 2b       	or	r24, r25
    3dba:	29 f4       	brne	.+10     	; 0x3dc6 <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    3dbc:	0e 94 02 2c 	call	0x5804	; 0x5804 <pvTaskIncrementMutexHeldCount>
    3dc0:	f8 01       	movw	r30, r16
    3dc2:	93 83       	std	Z+3, r25	; 0x03
    3dc4:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3dc6:	f8 01       	movw	r30, r16
    3dc8:	80 85       	ldd	r24, Z+8	; 0x08
    3dca:	88 23       	and	r24, r24
    3dcc:	a1 f0       	breq	.+40     	; 0x3df6 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    3dce:	c8 01       	movw	r24, r16
    3dd0:	08 96       	adiw	r24, 0x08	; 8
    3dd2:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3dd6:	81 30       	cpi	r24, 0x01	; 1
    3dd8:	71 f4       	brne	.+28     	; 0x3df6 <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
    3dda:	82 d9       	rcall	.-3324   	; 0x30e0 <vPortYield>
    3ddc:	0c c0       	rjmp	.+24     	; 0x3df6 <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    3dde:	f8 01       	movw	r30, r16
    3de0:	f7 82       	std	Z+7, r15	; 0x07
    3de2:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3de4:	81 89       	ldd	r24, Z+17	; 0x11
    3de6:	88 23       	and	r24, r24
    3de8:	31 f0       	breq	.+12     	; 0x3df6 <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3dea:	c8 01       	movw	r24, r16
    3dec:	41 96       	adiw	r24, 0x11	; 17
    3dee:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3df2:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    3df4:	75 d9       	rcall	.-3350   	; 0x30e0 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    3df6:	0f 90       	pop	r0
    3df8:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    3dfa:	81 e0       	ldi	r24, 0x01	; 1
    3dfc:	1a c1       	rjmp	.+564    	; 0x4032 <xQueueGenericReceive+0x318>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    3dfe:	8c 81       	ldd	r24, Y+4	; 0x04
    3e00:	9d 81       	ldd	r25, Y+5	; 0x05
    3e02:	89 2b       	or	r24, r25
    3e04:	21 f4       	brne	.+8      	; 0x3e0e <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    3e06:	0f 90       	pop	r0
    3e08:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    3e0a:	80 e0       	ldi	r24, 0x00	; 0
    3e0c:	12 c1       	rjmp	.+548    	; 0x4032 <xQueueGenericReceive+0x318>
				}
				else if( xEntryTimeSet == pdFALSE )
    3e0e:	81 10       	cpse	r8, r1
    3e10:	05 c0       	rjmp	.+10     	; 0x3e1c <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    3e12:	ce 01       	movw	r24, r28
    3e14:	01 96       	adiw	r24, 0x01	; 1
    3e16:	0e 94 11 2b 	call	0x5622	; 0x5622 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    3e1a:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    3e1c:	0f 90       	pop	r0
    3e1e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    3e20:	0e 94 d9 27 	call	0x4fb2	; 0x4fb2 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    3e24:	0f b6       	in	r0, 0x3f	; 63
    3e26:	f8 94       	cli
    3e28:	0f 92       	push	r0
    3e2a:	f8 01       	movw	r30, r16
    3e2c:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e2e:	8f 3f       	cpi	r24, 0xFF	; 255
    3e30:	09 f4       	brne	.+2      	; 0x3e34 <xQueueGenericReceive+0x11a>
    3e32:	15 8e       	std	Z+29, r1	; 0x1d
    3e34:	f8 01       	movw	r30, r16
    3e36:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e38:	8f 3f       	cpi	r24, 0xFF	; 255
    3e3a:	09 f4       	brne	.+2      	; 0x3e3e <xQueueGenericReceive+0x124>
    3e3c:	16 8e       	std	Z+30, r1	; 0x1e
    3e3e:	0f 90       	pop	r0
    3e40:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    3e42:	be 01       	movw	r22, r28
    3e44:	6c 5f       	subi	r22, 0xFC	; 252
    3e46:	7f 4f       	sbci	r23, 0xFF	; 255
    3e48:	ce 01       	movw	r24, r28
    3e4a:	01 96       	adiw	r24, 0x01	; 1
    3e4c:	0e 94 1c 2b 	call	0x5638	; 0x5638 <xTaskCheckForTimeOut>
    3e50:	81 11       	cpse	r24, r1
    3e52:	a2 c0       	rjmp	.+324    	; 0x3f98 <xQueueGenericReceive+0x27e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    3e54:	0f b6       	in	r0, 0x3f	; 63
    3e56:	f8 94       	cli
    3e58:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    3e5a:	f8 01       	movw	r30, r16
    3e5c:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    3e5e:	0f 90       	pop	r0
    3e60:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    3e62:	81 11       	cpse	r24, r1
    3e64:	57 c0       	rjmp	.+174    	; 0x3f14 <xQueueGenericReceive+0x1fa>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    3e66:	80 81       	ld	r24, Z
    3e68:	91 81       	ldd	r25, Z+1	; 0x01
    3e6a:	89 2b       	or	r24, r25
    3e6c:	49 f4       	brne	.+18     	; 0x3e80 <xQueueGenericReceive+0x166>
					{
						taskENTER_CRITICAL();
    3e6e:	0f b6       	in	r0, 0x3f	; 63
    3e70:	f8 94       	cli
    3e72:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    3e74:	82 81       	ldd	r24, Z+2	; 0x02
    3e76:	93 81       	ldd	r25, Z+3	; 0x03
    3e78:	0e 94 60 2b 	call	0x56c0	; 0x56c0 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    3e7c:	0f 90       	pop	r0
    3e7e:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    3e80:	6c 81       	ldd	r22, Y+4	; 0x04
    3e82:	7d 81       	ldd	r23, Y+5	; 0x05
    3e84:	c7 01       	movw	r24, r14
    3e86:	0e 94 6d 2a 	call	0x54da	; 0x54da <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3e8a:	0f b6       	in	r0, 0x3f	; 63
    3e8c:	f8 94       	cli
    3e8e:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3e90:	f8 01       	movw	r30, r16
    3e92:	86 8d       	ldd	r24, Z+30	; 0x1e
    3e94:	18 16       	cp	r1, r24
    3e96:	ac f4       	brge	.+42     	; 0x3ec2 <xQueueGenericReceive+0x1a8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3e98:	81 89       	ldd	r24, Z+17	; 0x11
    3e9a:	81 11       	cpse	r24, r1
    3e9c:	05 c0       	rjmp	.+10     	; 0x3ea8 <xQueueGenericReceive+0x18e>
    3e9e:	11 c0       	rjmp	.+34     	; 0x3ec2 <xQueueGenericReceive+0x1a8>
    3ea0:	f8 01       	movw	r30, r16
    3ea2:	81 89       	ldd	r24, Z+17	; 0x11
    3ea4:	88 23       	and	r24, r24
    3ea6:	69 f0       	breq	.+26     	; 0x3ec2 <xQueueGenericReceive+0x1a8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3ea8:	c7 01       	movw	r24, r14
    3eaa:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3eae:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3eb0:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3eb4:	f8 01       	movw	r30, r16
    3eb6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3eb8:	81 50       	subi	r24, 0x01	; 1
    3eba:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3ebc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3ebe:	18 16       	cp	r1, r24
    3ec0:	7c f3       	brlt	.-34     	; 0x3ea0 <xQueueGenericReceive+0x186>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3ec2:	f8 01       	movw	r30, r16
    3ec4:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    3ec6:	0f 90       	pop	r0
    3ec8:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3eca:	0f b6       	in	r0, 0x3f	; 63
    3ecc:	f8 94       	cli
    3ece:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3ed0:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ed2:	18 16       	cp	r1, r24
    3ed4:	ac f4       	brge	.+42     	; 0x3f00 <xQueueGenericReceive+0x1e6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3ed6:	80 85       	ldd	r24, Z+8	; 0x08
    3ed8:	81 11       	cpse	r24, r1
    3eda:	05 c0       	rjmp	.+10     	; 0x3ee6 <xQueueGenericReceive+0x1cc>
    3edc:	11 c0       	rjmp	.+34     	; 0x3f00 <xQueueGenericReceive+0x1e6>
    3ede:	f8 01       	movw	r30, r16
    3ee0:	80 85       	ldd	r24, Z+8	; 0x08
    3ee2:	88 23       	and	r24, r24
    3ee4:	69 f0       	breq	.+26     	; 0x3f00 <xQueueGenericReceive+0x1e6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3ee6:	c6 01       	movw	r24, r12
    3ee8:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3eec:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    3eee:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3ef2:	f8 01       	movw	r30, r16
    3ef4:	85 8d       	ldd	r24, Z+29	; 0x1d
    3ef6:	81 50       	subi	r24, 0x01	; 1
    3ef8:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3efa:	85 8d       	ldd	r24, Z+29	; 0x1d
    3efc:	18 16       	cp	r1, r24
    3efe:	7c f3       	brlt	.-34     	; 0x3ede <xQueueGenericReceive+0x1c4>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3f00:	f8 01       	movw	r30, r16
    3f02:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    3f04:	0f 90       	pop	r0
    3f06:	0f be       	out	0x3f, r0	; 63
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    3f08:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    3f0c:	81 11       	cpse	r24, r1
    3f0e:	2a cf       	rjmp	.-428    	; 0x3d64 <xQueueGenericReceive+0x4a>
				{
					portYIELD_WITHIN_API();
    3f10:	e7 d8       	rcall	.-3634   	; 0x30e0 <vPortYield>
    3f12:	28 cf       	rjmp	.-432    	; 0x3d64 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3f14:	0f b6       	in	r0, 0x3f	; 63
    3f16:	f8 94       	cli
    3f18:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3f1a:	f8 01       	movw	r30, r16
    3f1c:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f1e:	18 16       	cp	r1, r24
    3f20:	ac f4       	brge	.+42     	; 0x3f4c <xQueueGenericReceive+0x232>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3f22:	81 89       	ldd	r24, Z+17	; 0x11
    3f24:	81 11       	cpse	r24, r1
    3f26:	05 c0       	rjmp	.+10     	; 0x3f32 <xQueueGenericReceive+0x218>
    3f28:	11 c0       	rjmp	.+34     	; 0x3f4c <xQueueGenericReceive+0x232>
    3f2a:	f8 01       	movw	r30, r16
    3f2c:	81 89       	ldd	r24, Z+17	; 0x11
    3f2e:	88 23       	and	r24, r24
    3f30:	69 f0       	breq	.+26     	; 0x3f4c <xQueueGenericReceive+0x232>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3f32:	c7 01       	movw	r24, r14
    3f34:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3f38:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3f3a:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3f3e:	f8 01       	movw	r30, r16
    3f40:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f42:	81 50       	subi	r24, 0x01	; 1
    3f44:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3f46:	86 8d       	ldd	r24, Z+30	; 0x1e
    3f48:	18 16       	cp	r1, r24
    3f4a:	7c f3       	brlt	.-34     	; 0x3f2a <xQueueGenericReceive+0x210>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3f4c:	f8 01       	movw	r30, r16
    3f4e:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    3f50:	0f 90       	pop	r0
    3f52:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3f54:	0f b6       	in	r0, 0x3f	; 63
    3f56:	f8 94       	cli
    3f58:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3f5a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f5c:	18 16       	cp	r1, r24
    3f5e:	ac f4       	brge	.+42     	; 0x3f8a <xQueueGenericReceive+0x270>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3f60:	80 85       	ldd	r24, Z+8	; 0x08
    3f62:	81 11       	cpse	r24, r1
    3f64:	05 c0       	rjmp	.+10     	; 0x3f70 <xQueueGenericReceive+0x256>
    3f66:	11 c0       	rjmp	.+34     	; 0x3f8a <xQueueGenericReceive+0x270>
    3f68:	f8 01       	movw	r30, r16
    3f6a:	80 85       	ldd	r24, Z+8	; 0x08
    3f6c:	88 23       	and	r24, r24
    3f6e:	69 f0       	breq	.+26     	; 0x3f8a <xQueueGenericReceive+0x270>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    3f70:	c6 01       	movw	r24, r12
    3f72:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3f76:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    3f78:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    3f7c:	f8 01       	movw	r30, r16
    3f7e:	95 8d       	ldd	r25, Z+29	; 0x1d
    3f80:	91 50       	subi	r25, 0x01	; 1
    3f82:	95 8f       	std	Z+29, r25	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3f84:	85 8d       	ldd	r24, Z+29	; 0x1d
    3f86:	18 16       	cp	r1, r24
    3f88:	7c f3       	brlt	.-34     	; 0x3f68 <xQueueGenericReceive+0x24e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    3f8a:	f8 01       	movw	r30, r16
    3f8c:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    3f8e:	0f 90       	pop	r0
    3f90:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    3f92:	0e 94 df 27 	call	0x4fbe	; 0x4fbe <xTaskResumeAll>
    3f96:	e6 ce       	rjmp	.-564    	; 0x3d64 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    3f98:	0f b6       	in	r0, 0x3f	; 63
    3f9a:	f8 94       	cli
    3f9c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3f9e:	f8 01       	movw	r30, r16
    3fa0:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fa2:	18 16       	cp	r1, r24
    3fa4:	d4 f4       	brge	.+52     	; 0x3fda <xQueueGenericReceive+0x2c0>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    3fa6:	81 89       	ldd	r24, Z+17	; 0x11
    3fa8:	81 11       	cpse	r24, r1
    3faa:	06 c0       	rjmp	.+12     	; 0x3fb8 <xQueueGenericReceive+0x29e>
    3fac:	16 c0       	rjmp	.+44     	; 0x3fda <xQueueGenericReceive+0x2c0>
    3fae:	f8 01       	movw	r30, r16
    3fb0:	91 89       	ldd	r25, Z+17	; 0x11
    3fb2:	91 11       	cpse	r25, r1
    3fb4:	05 c0       	rjmp	.+10     	; 0x3fc0 <xQueueGenericReceive+0x2a6>
    3fb6:	11 c0       	rjmp	.+34     	; 0x3fda <xQueueGenericReceive+0x2c0>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    3fb8:	78 01       	movw	r14, r16
    3fba:	f1 e1       	ldi	r31, 0x11	; 17
    3fbc:	ef 0e       	add	r14, r31
    3fbe:	f1 1c       	adc	r15, r1
    3fc0:	c7 01       	movw	r24, r14
    3fc2:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    3fc6:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    3fc8:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    3fcc:	f8 01       	movw	r30, r16
    3fce:	96 8d       	ldd	r25, Z+30	; 0x1e
    3fd0:	91 50       	subi	r25, 0x01	; 1
    3fd2:	96 8f       	std	Z+30, r25	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    3fd4:	96 8d       	ldd	r25, Z+30	; 0x1e
    3fd6:	19 16       	cp	r1, r25
    3fd8:	54 f3       	brlt	.-44     	; 0x3fae <xQueueGenericReceive+0x294>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    3fda:	8f ef       	ldi	r24, 0xFF	; 255
    3fdc:	f8 01       	movw	r30, r16
    3fde:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    3fe0:	0f 90       	pop	r0
    3fe2:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    3fe4:	0f b6       	in	r0, 0x3f	; 63
    3fe6:	f8 94       	cli
    3fe8:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    3fea:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fec:	18 16       	cp	r1, r24
    3fee:	d4 f4       	brge	.+52     	; 0x4024 <xQueueGenericReceive+0x30a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    3ff0:	80 85       	ldd	r24, Z+8	; 0x08
    3ff2:	81 11       	cpse	r24, r1
    3ff4:	06 c0       	rjmp	.+12     	; 0x4002 <xQueueGenericReceive+0x2e8>
    3ff6:	16 c0       	rjmp	.+44     	; 0x4024 <xQueueGenericReceive+0x30a>
    3ff8:	f8 01       	movw	r30, r16
    3ffa:	90 85       	ldd	r25, Z+8	; 0x08
    3ffc:	91 11       	cpse	r25, r1
    3ffe:	05 c0       	rjmp	.+10     	; 0x400a <xQueueGenericReceive+0x2f0>
    4000:	11 c0       	rjmp	.+34     	; 0x4024 <xQueueGenericReceive+0x30a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4002:	78 01       	movw	r14, r16
    4004:	f8 e0       	ldi	r31, 0x08	; 8
    4006:	ef 0e       	add	r14, r31
    4008:	f1 1c       	adc	r15, r1
    400a:	c7 01       	movw	r24, r14
    400c:	0e 94 c9 2a 	call	0x5592	; 0x5592 <xTaskRemoveFromEventList>
    4010:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    4012:	0e 94 57 2b 	call	0x56ae	; 0x56ae <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    4016:	f8 01       	movw	r30, r16
    4018:	95 8d       	ldd	r25, Z+29	; 0x1d
    401a:	91 50       	subi	r25, 0x01	; 1
    401c:	95 8f       	std	Z+29, r25	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    401e:	95 8d       	ldd	r25, Z+29	; 0x1d
    4020:	19 16       	cp	r1, r25
    4022:	54 f3       	brlt	.-44     	; 0x3ff8 <xQueueGenericReceive+0x2de>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4024:	8f ef       	ldi	r24, 0xFF	; 255
    4026:	f8 01       	movw	r30, r16
    4028:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    402a:	0f 90       	pop	r0
    402c:	0f be       	out	0x3f, r0	; 63
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    402e:	c7 d7       	rcall	.+3982   	; 0x4fbe <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    4030:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    4032:	0f 90       	pop	r0
    4034:	0f 90       	pop	r0
    4036:	0f 90       	pop	r0
    4038:	0f 90       	pop	r0
    403a:	0f 90       	pop	r0
    403c:	df 91       	pop	r29
    403e:	cf 91       	pop	r28
    4040:	1f 91       	pop	r17
    4042:	0f 91       	pop	r16
    4044:	ff 90       	pop	r15
    4046:	ef 90       	pop	r14
    4048:	df 90       	pop	r13
    404a:	cf 90       	pop	r12
    404c:	bf 90       	pop	r11
    404e:	af 90       	pop	r10
    4050:	9f 90       	pop	r9
    4052:	8f 90       	pop	r8
    4054:	7f 90       	pop	r7
    4056:	6f 90       	pop	r6
    4058:	08 95       	ret

0000405a <server_receiver>:
  uint8_t status = TYPE_PING_RESPONSE;
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
  else simple_p_send(SERVER_ADDRESS, &status, 1);
}

void server_receiver(uint8_t *data, uint16_t len) {
    405a:	ab 01       	movw	r20, r22
  if(data == NULL) { // ARQ passes NULL to the callback when connection is lost
    405c:	00 97       	sbiw	r24, 0x00	; 0
    405e:	11 f4       	brne	.+4      	; 0x4064 <server_receiver+0xa>
      gHandshook = 0;
    4060:	10 92 c4 19 	sts	0x19C4, r1	; 0x8019c4 <gHandshook>
  }
  memcpy(&message_in, data, len);
    4064:	bc 01       	movw	r22, r24
    4066:	89 e3       	ldi	r24, 0x39	; 57
    4068:	9b e1       	ldi	r25, 0x1B	; 27
    406a:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
  xSemaphoreGive(xCommandReadyBSem);
    406e:	60 e0       	ldi	r22, 0x00	; 0
    4070:	70 e0       	ldi	r23, 0x00	; 0
    4072:	80 91 35 1b 	lds	r24, 0x1B35	; 0x801b35 <xCommandReadyBSem>
    4076:	90 91 36 1b 	lds	r25, 0x1B36	; 0x801b36 <xCommandReadyBSem+0x1>
    407a:	b2 cc       	rjmp	.-1692   	; 0x39e0 <xQueueGive>
    407c:	08 95       	ret

0000407e <server_communication_init>:
#define TYPE_PING           8
#define TYPE_PING_RESPONSE  9
#define TYPE_DEBUG          10

void server_communication_init(void) {
  if(connected) return;
    407e:	80 91 d1 19 	lds	r24, 0x19D1	; 0x8019d1 <connected>
    4082:	81 11       	cpse	r24, r1
    4084:	04 c0       	rjmp	.+8      	; 0x408e <server_communication_init+0x10>
  server_connection = arq_new_connection();
    4086:	0e 94 60 01 	call	0x2c0	; 0x2c0 <arq_new_connection>
    408a:	80 93 6f 1b 	sts	0x1B6F, r24	; 0x801b6f <server_connection>
    408e:	08 95       	ret

00004090 <server_connect>:
}

uint8_t server_connect(void) {
  connected = arq_connect(server_connection, SERVER_ADDRESS, server_receiver, 1000);
    4090:	28 ee       	ldi	r18, 0xE8	; 232
    4092:	33 e0       	ldi	r19, 0x03	; 3
    4094:	4d e2       	ldi	r20, 0x2D	; 45
    4096:	50 e2       	ldi	r21, 0x20	; 32
    4098:	60 e0       	ldi	r22, 0x00	; 0
    409a:	80 91 6f 1b 	lds	r24, 0x1B6F	; 0x801b6f <server_connection>
    409e:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <arq_connect>
    40a2:	80 93 d1 19 	sts	0x19D1, r24	; 0x8019d1 <connected>
  return connected;
}
    40a6:	08 95       	ret

000040a8 <send_handshake>:

uint8_t send_handshake(void) {
    40a8:	cf 93       	push	r28
    40aa:	df 93       	push	r29
    40ac:	cd b7       	in	r28, 0x3d	; 61
    40ae:	de b7       	in	r29, 0x3e	; 62
    40b0:	ec 97       	sbiw	r28, 0x3c	; 60
    40b2:	0f b6       	in	r0, 0x3f	; 63
    40b4:	f8 94       	cli
    40b6:	de bf       	out	0x3e, r29	; 62
    40b8:	0f be       	out	0x3f, r0	; 63
    40ba:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return 0;
    40bc:	80 91 d1 19 	lds	r24, 0x19D1	; 0x8019d1 <connected>
    40c0:	88 23       	and	r24, r24
    40c2:	09 f4       	brne	.+2      	; 0x40c6 <send_handshake+0x1e>
    40c4:	51 c0       	rjmp	.+162    	; 0x4168 <send_handshake+0xc0>
  message_t msg;
  msg.type = TYPE_HANDSHAKE;
    40c6:	19 82       	std	Y+1, r1	; 0x01
  msg.message.handshake.name_length = ROBOT_NAME_LENGTH;
    40c8:	87 e0       	ldi	r24, 0x07	; 7
    40ca:	8a 83       	std	Y+2, r24	; 0x02
  strcpy((char*)msg.message.handshake.name, ROBOT_NAME);
    40cc:	88 e0       	ldi	r24, 0x08	; 8
    40ce:	ed e3       	ldi	r30, 0x3D	; 61
    40d0:	f6 e0       	ldi	r31, 0x06	; 6
    40d2:	de 01       	movw	r26, r28
    40d4:	13 96       	adiw	r26, 0x03	; 3
    40d6:	01 90       	ld	r0, Z+
    40d8:	0d 92       	st	X+, r0
    40da:	8a 95       	dec	r24
    40dc:	e1 f7       	brne	.-8      	; 0x40d6 <send_handshake+0x2e>
  msg.message.handshake.width = ROBOT_TOTAL_WIDTH_MM;
    40de:	82 ed       	ldi	r24, 0xD2	; 210
    40e0:	90 e0       	ldi	r25, 0x00	; 0
    40e2:	9b 87       	std	Y+11, r25	; 0x0b
    40e4:	8a 87       	std	Y+10, r24	; 0x0a
  msg.message.handshake.length = ROBOT_TOTAL_LENGTH_MM;
    40e6:	8c ed       	ldi	r24, 0xDC	; 220
    40e8:	90 e0       	ldi	r25, 0x00	; 0
    40ea:	9d 87       	std	Y+13, r25	; 0x0d
    40ec:	8c 87       	std	Y+12, r24	; 0x0c
  msg.message.handshake.axel_offset = ROBOT_AXEL_OFFSET_MM;
    40ee:	87 e2       	ldi	r24, 0x27	; 39
    40f0:	88 8b       	std	Y+16, r24	; 0x10
  msg.message.handshake.tower_offset_x = SENSOR_TOWER_OFFSET_X_MM;
    40f2:	8e e1       	ldi	r24, 0x1E	; 30
    40f4:	8e 87       	std	Y+14, r24	; 0x0e
  msg.message.handshake.tower_offset_y = SENSOR_TOWER_OFFSET_Y_MM;
    40f6:	1f 86       	std	Y+15, r1	; 0x0f
  msg.message.handshake.sensor_offset1 = SENSOR_OFFSET_RADIUS_MM;
    40f8:	86 e1       	ldi	r24, 0x16	; 22
    40fa:	89 8b       	std	Y+17, r24	; 0x11
  msg.message.handshake.sensor_offset2 = SENSOR_OFFSET_RADIUS_MM;
    40fc:	8a 8b       	std	Y+18, r24	; 0x12
  msg.message.handshake.sensor_offset3 = SENSOR_OFFSET_RADIUS_MM;
    40fe:	8b 8b       	std	Y+19, r24	; 0x13
  msg.message.handshake.sensor_offset4 = SENSOR_OFFSET_RADIUS_MM;
    4100:	8c 8b       	std	Y+20, r24	; 0x14
  msg.message.handshake.sensor_heading1 = SENSOR1_HEADING_DEG;
    4102:	1e 8a       	std	Y+22, r1	; 0x16
    4104:	1d 8a       	std	Y+21, r1	; 0x15
  msg.message.handshake.sensor_heading2 = SENSOR2_HEADING_DEG;
    4106:	8a e5       	ldi	r24, 0x5A	; 90
    4108:	90 e0       	ldi	r25, 0x00	; 0
    410a:	98 8f       	std	Y+24, r25	; 0x18
    410c:	8f 8b       	std	Y+23, r24	; 0x17
  msg.message.handshake.sensor_heading3 = SENSOR3_HEADING_DEG;
    410e:	84 eb       	ldi	r24, 0xB4	; 180
    4110:	90 e0       	ldi	r25, 0x00	; 0
    4112:	9a 8f       	std	Y+26, r25	; 0x1a
    4114:	89 8f       	std	Y+25, r24	; 0x19
  msg.message.handshake.sensor_heading4 = SENSOR4_HEADING_DEG;
    4116:	8e e0       	ldi	r24, 0x0E	; 14
    4118:	91 e0       	ldi	r25, 0x01	; 1
    411a:	9c 8f       	std	Y+28, r25	; 0x1c
    411c:	8b 8f       	std	Y+27, r24	; 0x1b
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
    411e:	88 ec       	ldi	r24, 0xC8	; 200
    4120:	90 e0       	ldi	r25, 0x00	; 0
    4122:	9e 8f       	std	Y+30, r25	; 0x1e
    4124:	8d 8f       	std	Y+29, r24	; 0x1d
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    4126:	8e e1       	ldi	r24, 0x1E	; 30
    4128:	fe 01       	movw	r30, r28
    412a:	31 96       	adiw	r30, 0x01	; 1
    412c:	de 01       	movw	r26, r28
    412e:	5f 96       	adiw	r26, 0x1f	; 31
    4130:	01 90       	ld	r0, Z+
    4132:	0d 92       	st	X+, r0
    4134:	8a 95       	dec	r24
    4136:	e1 f7       	brne	.-8      	; 0x4130 <send_handshake+0x88>
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
    4138:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <use_arq>
    413c:	88 23       	and	r24, r24
    413e:	59 f0       	breq	.+22     	; 0x4156 <send_handshake+0xae>
    4140:	4e e1       	ldi	r20, 0x1E	; 30
    4142:	50 e0       	ldi	r21, 0x00	; 0
    4144:	be 01       	movw	r22, r28
    4146:	61 5e       	subi	r22, 0xE1	; 225
    4148:	7f 4f       	sbci	r23, 0xFF	; 255
    414a:	80 91 6f 1b 	lds	r24, 0x1B6F	; 0x801b6f <server_connection>
    414e:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
  else simple_p_send(server_connection, data, sizeof(data));
  return 1;
    4152:	81 e0       	ldi	r24, 0x01	; 1
    4154:	09 c0       	rjmp	.+18     	; 0x4168 <send_handshake+0xc0>
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
  else simple_p_send(server_connection, data, sizeof(data));
    4156:	4e e1       	ldi	r20, 0x1E	; 30
    4158:	50 e0       	ldi	r21, 0x00	; 0
    415a:	be 01       	movw	r22, r28
    415c:	61 5e       	subi	r22, 0xE1	; 225
    415e:	7f 4f       	sbci	r23, 0xFF	; 255
    4160:	80 91 6f 1b 	lds	r24, 0x1B6F	; 0x801b6f <server_connection>
    4164:	72 d1       	rcall	.+740    	; 0x444a <simple_p_send>
  return 1;
    4166:	81 e0       	ldi	r24, 0x01	; 1
}
    4168:	ec 96       	adiw	r28, 0x3c	; 60
    416a:	0f b6       	in	r0, 0x3f	; 63
    416c:	f8 94       	cli
    416e:	de bf       	out	0x3e, r29	; 62
    4170:	0f be       	out	0x3f, r0	; 63
    4172:	cd bf       	out	0x3d, r28	; 61
    4174:	df 91       	pop	r29
    4176:	cf 91       	pop	r28
    4178:	08 95       	ret

0000417a <send_update>:

void send_update(int16_t x_cm, int16_t y_cm, int16_t heading_deg, int16_t towerAngle_deg, uint8_t S1_cm, uint8_t S2_cm, uint8_t S3_cm, uint8_t S4_cm){
    417a:	af 92       	push	r10
    417c:	cf 92       	push	r12
    417e:	ef 92       	push	r14
    4180:	0f 93       	push	r16
    4182:	cf 93       	push	r28
    4184:	df 93       	push	r29
    4186:	cd b7       	in	r28, 0x3d	; 61
    4188:	de b7       	in	r29, 0x3e	; 62
    418a:	2d 97       	sbiw	r28, 0x0d	; 13
    418c:	0f b6       	in	r0, 0x3f	; 63
    418e:	f8 94       	cli
    4190:	de bf       	out	0x3e, r29	; 62
    4192:	0f be       	out	0x3f, r0	; 63
    4194:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return;
    4196:	e0 91 d1 19 	lds	r30, 0x19D1	; 0x8019d1 <connected>
    419a:	ee 23       	and	r30, r30
    419c:	19 f1       	breq	.+70     	; 0x41e4 <send_update+0x6a>
  msg.message.update.sensor1 = S1_cm;
  msg.message.update.sensor2 = S2_cm;
  msg.message.update.sensor3 = S3_cm;
  msg.message.update.sensor4 = S4_cm;
  uint8_t data[sizeof(update_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    419e:	e1 e0       	ldi	r30, 0x01	; 1
    41a0:	e9 83       	std	Y+1, r30	; 0x01
    41a2:	9b 83       	std	Y+3, r25	; 0x03
    41a4:	8a 83       	std	Y+2, r24	; 0x02
    41a6:	7d 83       	std	Y+5, r23	; 0x05
    41a8:	6c 83       	std	Y+4, r22	; 0x04
    41aa:	5f 83       	std	Y+7, r21	; 0x07
    41ac:	4e 83       	std	Y+6, r20	; 0x06
    41ae:	39 87       	std	Y+9, r19	; 0x09
    41b0:	28 87       	std	Y+8, r18	; 0x08
    41b2:	0a 87       	std	Y+10, r16	; 0x0a
    41b4:	eb 86       	std	Y+11, r14	; 0x0b
    41b6:	cc 86       	std	Y+12, r12	; 0x0c
    41b8:	ad 86       	std	Y+13, r10	; 0x0d
  if(use_arq[TYPE_UPDATE]) arq_send(server_connection, data, sizeof(data));
    41ba:	80 91 01 06 	lds	r24, 0x0601	; 0x800601 <use_arq+0x1>
    41be:	88 23       	and	r24, r24
    41c0:	51 f0       	breq	.+20     	; 0x41d6 <send_update+0x5c>
    41c2:	4d e0       	ldi	r20, 0x0D	; 13
    41c4:	50 e0       	ldi	r21, 0x00	; 0
    41c6:	be 01       	movw	r22, r28
    41c8:	6f 5f       	subi	r22, 0xFF	; 255
    41ca:	7f 4f       	sbci	r23, 0xFF	; 255
    41cc:	80 91 6f 1b 	lds	r24, 0x1B6F	; 0x801b6f <server_connection>
    41d0:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    41d4:	07 c0       	rjmp	.+14     	; 0x41e4 <send_update+0x6a>
  else simple_p_send(SERVER_ADDRESS, data, sizeof(data));
    41d6:	4d e0       	ldi	r20, 0x0D	; 13
    41d8:	50 e0       	ldi	r21, 0x00	; 0
    41da:	be 01       	movw	r22, r28
    41dc:	6f 5f       	subi	r22, 0xFF	; 255
    41de:	7f 4f       	sbci	r23, 0xFF	; 255
    41e0:	80 e0       	ldi	r24, 0x00	; 0
    41e2:	33 d1       	rcall	.+614    	; 0x444a <simple_p_send>
}
    41e4:	2d 96       	adiw	r28, 0x0d	; 13
    41e6:	0f b6       	in	r0, 0x3f	; 63
    41e8:	f8 94       	cli
    41ea:	de bf       	out	0x3e, r29	; 62
    41ec:	0f be       	out	0x3f, r0	; 63
    41ee:	cd bf       	out	0x3d, r28	; 61
    41f0:	df 91       	pop	r29
    41f2:	cf 91       	pop	r28
    41f4:	0f 91       	pop	r16
    41f6:	ef 90       	pop	r14
    41f8:	cf 90       	pop	r12
    41fa:	af 90       	pop	r10
    41fc:	08 95       	ret

000041fe <send_idle>:

void send_idle(void) {
    41fe:	cf 93       	push	r28
    4200:	df 93       	push	r29
    4202:	1f 92       	push	r1
    4204:	cd b7       	in	r28, 0x3d	; 61
    4206:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    4208:	80 91 d1 19 	lds	r24, 0x19D1	; 0x8019d1 <connected>
    420c:	88 23       	and	r24, r24
    420e:	b9 f0       	breq	.+46     	; 0x423e <send_idle+0x40>
  uint8_t status = TYPE_IDLE;
    4210:	83 e0       	ldi	r24, 0x03	; 3
    4212:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_IDLE]) arq_send(server_connection, &status, 1);
    4214:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <use_arq+0x3>
    4218:	88 23       	and	r24, r24
    421a:	51 f0       	breq	.+20     	; 0x4230 <send_idle+0x32>
    421c:	41 e0       	ldi	r20, 0x01	; 1
    421e:	50 e0       	ldi	r21, 0x00	; 0
    4220:	be 01       	movw	r22, r28
    4222:	6f 5f       	subi	r22, 0xFF	; 255
    4224:	7f 4f       	sbci	r23, 0xFF	; 255
    4226:	80 91 6f 1b 	lds	r24, 0x1B6F	; 0x801b6f <server_connection>
    422a:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    422e:	07 c0       	rjmp	.+14     	; 0x423e <send_idle+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    4230:	41 e0       	ldi	r20, 0x01	; 1
    4232:	50 e0       	ldi	r21, 0x00	; 0
    4234:	be 01       	movw	r22, r28
    4236:	6f 5f       	subi	r22, 0xFF	; 255
    4238:	7f 4f       	sbci	r23, 0xFF	; 255
    423a:	80 e0       	ldi	r24, 0x00	; 0
    423c:	06 d1       	rcall	.+524    	; 0x444a <simple_p_send>
}
    423e:	0f 90       	pop	r0
    4240:	df 91       	pop	r29
    4242:	cf 91       	pop	r28
    4244:	08 95       	ret

00004246 <debug>:
void debug(const char *fmt, ...) {
    4246:	cf 93       	push	r28
    4248:	df 93       	push	r29
    424a:	cd b7       	in	r28, 0x3d	; 61
    424c:	de b7       	in	r29, 0x3e	; 62
    424e:	c4 56       	subi	r28, 0x64	; 100
    4250:	d1 09       	sbc	r29, r1
    4252:	0f b6       	in	r0, 0x3f	; 63
    4254:	f8 94       	cli
    4256:	de bf       	out	0x3e, r29	; 62
    4258:	0f be       	out	0x3f, r0	; 63
    425a:	cd bf       	out	0x3d, r28	; 61
    425c:	ae 01       	movw	r20, r28
    425e:	46 59       	subi	r20, 0x96	; 150
    4260:	5f 4f       	sbci	r21, 0xFF	; 255
    4262:	fa 01       	movw	r30, r20
    4264:	61 91       	ld	r22, Z+
    4266:	71 91       	ld	r23, Z+
    4268:	af 01       	movw	r20, r30
	uint8_t buf[100];
	va_list ap;
	buf[0] = TYPE_DEBUG;
    426a:	8a e0       	ldi	r24, 0x0A	; 10
    426c:	89 83       	std	Y+1, r24	; 0x01
	va_start(ap, fmt);
	uint8_t ret = vsprintf((char*)buf+1, fmt, ap);
    426e:	ce 01       	movw	r24, r28
    4270:	02 96       	adiw	r24, 0x02	; 2
    4272:	0e 94 97 38 	call	0x712e	; 0x712e <vsprintf>
	va_end(ap);
	if (ret > 0) {
    4276:	88 23       	and	r24, r24
    4278:	c9 f0       	breq	.+50     	; 0x42ac <debug+0x66>
		if(use_arq[TYPE_DEBUG]) arq_send(server_connection, buf, ret+1);
    427a:	20 91 0a 06 	lds	r18, 0x060A	; 0x80060a <use_arq+0xa>
    427e:	22 23       	and	r18, r18
    4280:	61 f0       	breq	.+24     	; 0x429a <debug+0x54>
    4282:	99 27       	eor	r25, r25
    4284:	ac 01       	movw	r20, r24
    4286:	4f 5f       	subi	r20, 0xFF	; 255
    4288:	5f 4f       	sbci	r21, 0xFF	; 255
    428a:	be 01       	movw	r22, r28
    428c:	6f 5f       	subi	r22, 0xFF	; 255
    428e:	7f 4f       	sbci	r23, 0xFF	; 255
    4290:	80 91 6f 1b 	lds	r24, 0x1B6F	; 0x801b6f <server_connection>
    4294:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4298:	09 c0       	rjmp	.+18     	; 0x42ac <debug+0x66>
		else simple_p_send(SERVER_ADDRESS, buf, ret+1);
    429a:	99 27       	eor	r25, r25
    429c:	ac 01       	movw	r20, r24
    429e:	4f 5f       	subi	r20, 0xFF	; 255
    42a0:	5f 4f       	sbci	r21, 0xFF	; 255
    42a2:	be 01       	movw	r22, r28
    42a4:	6f 5f       	subi	r22, 0xFF	; 255
    42a6:	7f 4f       	sbci	r23, 0xFF	; 255
    42a8:	80 e0       	ldi	r24, 0x00	; 0
    42aa:	cf d0       	rcall	.+414    	; 0x444a <simple_p_send>
	}
}
    42ac:	cc 59       	subi	r28, 0x9C	; 156
    42ae:	df 4f       	sbci	r29, 0xFF	; 255
    42b0:	0f b6       	in	r0, 0x3f	; 63
    42b2:	f8 94       	cli
    42b4:	de bf       	out	0x3e, r29	; 62
    42b6:	0f be       	out	0x3f, r0	; 63
    42b8:	cd bf       	out	0x3d, r28	; 61
    42ba:	df 91       	pop	r29
    42bc:	cf 91       	pop	r28
    42be:	08 95       	ret

000042c0 <send_ping_response>:

void send_ping_response(void) {
    42c0:	cf 93       	push	r28
    42c2:	df 93       	push	r29
    42c4:	1f 92       	push	r1
    42c6:	cd b7       	in	r28, 0x3d	; 61
    42c8:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    42ca:	80 91 d1 19 	lds	r24, 0x19D1	; 0x8019d1 <connected>
    42ce:	88 23       	and	r24, r24
    42d0:	b9 f0       	breq	.+46     	; 0x4300 <send_ping_response+0x40>
  uint8_t status = TYPE_PING_RESPONSE;
    42d2:	89 e0       	ldi	r24, 0x09	; 9
    42d4:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
    42d6:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <use_arq+0x9>
    42da:	88 23       	and	r24, r24
    42dc:	51 f0       	breq	.+20     	; 0x42f2 <send_ping_response+0x32>
    42de:	41 e0       	ldi	r20, 0x01	; 1
    42e0:	50 e0       	ldi	r21, 0x00	; 0
    42e2:	be 01       	movw	r22, r28
    42e4:	6f 5f       	subi	r22, 0xFF	; 255
    42e6:	7f 4f       	sbci	r23, 0xFF	; 255
    42e8:	80 91 6f 1b 	lds	r24, 0x1B6F	; 0x801b6f <server_connection>
    42ec:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    42f0:	07 c0       	rjmp	.+14     	; 0x4300 <send_ping_response+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    42f2:	41 e0       	ldi	r20, 0x01	; 1
    42f4:	50 e0       	ldi	r21, 0x00	; 0
    42f6:	be 01       	movw	r22, r28
    42f8:	6f 5f       	subi	r22, 0xFF	; 255
    42fa:	7f 4f       	sbci	r23, 0xFF	; 255
    42fc:	80 e0       	ldi	r24, 0x00	; 0
    42fe:	a5 d0       	rcall	.+330    	; 0x444a <simple_p_send>
}
    4300:	0f 90       	pop	r0
    4302:	df 91       	pop	r29
    4304:	cf 91       	pop	r28
    4306:	08 95       	ret

00004308 <vServo_setAngle>:
}

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
    /* Ensure feasible values */
    if (ServoAngleDeg >= 90){
    4308:	8a 35       	cpi	r24, 0x5A	; 90
    430a:	08 f0       	brcs	.+2      	; 0x430e <vServo_setAngle+0x6>
        ServoAngleDeg = 90;
    430c:	8a e5       	ldi	r24, 0x5A	; 90
    }
    else if(ServoAngleDeg <= 0){
        ServoAngleDeg = 0;
    }
    /* Fetch pulse width from array and set to output */
    servoOCR = DEG_TO_PWM[ServoAngleDeg];
    430e:	e8 2f       	mov	r30, r24
    4310:	f0 e0       	ldi	r31, 0x00	; 0
    4312:	ee 0f       	add	r30, r30
    4314:	ff 1f       	adc	r31, r31
    4316:	eb 5b       	subi	r30, 0xBB	; 187
    4318:	f9 4f       	sbci	r31, 0xF9	; 249
    431a:	80 81       	ld	r24, Z
    431c:	91 81       	ldd	r25, Z+1	; 0x01
    431e:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__TEXT_REGION_LENGTH__+0x700089>
    4322:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__TEXT_REGION_LENGTH__+0x700088>
    4326:	08 95       	ret

00004328 <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
    /* Clear OCnA/OCnB on Compare Match, set */
    /* OCnA/OCnB at BOTTOM (non-inverting mode) */
    /* Datasheet p.132 Table 14-3 */
    TCCR1A |= (1<<COM1A1) | (0<<COM0A0);
    4328:	a0 e8       	ldi	r26, 0x80	; 128
    432a:	b0 e0       	ldi	r27, 0x00	; 0
    432c:	9c 91       	ld	r25, X
    432e:	90 68       	ori	r25, 0x80	; 128
    4330:	9c 93       	st	X, r25
    
    /* Waveform generation mode 14: Fast PWM */
    /* top: ICRn, Update bottom, flag set on top */
    /* Datasheet p.133 Table 14-5 */
    TCCR1B |= (1<<WGM13) | (1<<WGM12);
    4332:	e1 e8       	ldi	r30, 0x81	; 129
    4334:	f0 e0       	ldi	r31, 0x00	; 0
    4336:	90 81       	ld	r25, Z
    4338:	98 61       	ori	r25, 0x18	; 24
    433a:	90 83       	st	Z, r25
    TCCR1A |= (1<<WGM11) | (0<<WGM10);
    433c:	9c 91       	ld	r25, X
    433e:	92 60       	ori	r25, 0x02	; 2
    4340:	9c 93       	st	X, r25

    /* Clock select bit description: */
    /* clkI/O/8 (From prescaler) - Datasheet p.134 Table 14-6*/
    TCCR1B |= (0<<CS12) | (1<<CS11) | (0<<CS10);
    4342:	90 81       	ld	r25, Z
    4344:	92 60       	ori	r25, 0x02	; 2
    4346:	90 83       	st	Z, r25
    
    /* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
    /* Datasheet p.125 */
    ICR1 = 39999; // 49999 for 20mhz, 39 999 for 16mhz
    4348:	2f e3       	ldi	r18, 0x3F	; 63
    434a:	3c e9       	ldi	r19, 0x9C	; 156
    434c:	30 93 87 00 	sts	0x0087, r19	; 0x800087 <__TEXT_REGION_LENGTH__+0x700087>
    4350:	20 93 86 00 	sts	0x0086, r18	; 0x800086 <__TEXT_REGION_LENGTH__+0x700086>
    
    /*PortB Pin 5 as servo PWM Output (OC1A)*/
    servoReg |= (1<<servoPin);
    4354:	25 9a       	sbi	0x04, 5	; 4
    
    /*  Set angle to desired start angle (usually 0)*/
    vServo_setAngle(servoAngleDeg);
    4356:	d8 cf       	rjmp	.-80     	; 0x4308 <vServo_setAngle>
    4358:	08 95       	ret

0000435a <simple_p_reassembly>:
  vPortFree(part);
  return 1;
}


void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length) {
    435a:	ef 92       	push	r14
    435c:	ff 92       	push	r15
    435e:	0f 93       	push	r16
    4360:	1f 93       	push	r17
    4362:	cf 93       	push	r28
    4364:	df 93       	push	r29
  uint8_t i;
  uint8_t id = 0xFF;
  uint8_t free = 0xFF;
  for(i=0;i<MAX_MESSAGES;i++) {
    if(messages[i].address == 0xFF && free == 0xFF) free = i;
    4366:	90 91 d3 19 	lds	r25, 0x19D3	; 0x8019d3 <messages+0x1>
    436a:	9f 3f       	cpi	r25, 0xFF	; 255
    436c:	11 f0       	breq	.+4      	; 0x4372 <simple_p_reassembly+0x18>
    else if(messages[i].address == sender) {
    436e:	98 13       	cpse	r25, r24
    4370:	58 c0       	rjmp	.+176    	; 0x4422 <simple_p_reassembly+0xc8>
  if(id == 0xFF && free == 0xFF) return; // Not room for any more messages, and none is stored for this address
  else if(id == 0xFF && free != 0xFF) { // Did not find any part messages from this sender, but there is room to store a new one
    id = free; 
  }
    
  if(data[0] == 0) { // First part of a new message
    4372:	fb 01       	movw	r30, r22
    4374:	80 81       	ld	r24, Z
    4376:	81 11       	cpse	r24, r1
    4378:	05 c0       	rjmp	.+10     	; 0x4384 <simple_p_reassembly+0x2a>
    messages[id].num_received_bytes = 0;
    437a:	10 92 d5 19 	sts	0x19D5, r1	; 0x8019d5 <messages+0x3>
    437e:	10 92 d4 19 	sts	0x19D4, r1	; 0x8019d4 <messages+0x2>
    4382:	0c c0       	rjmp	.+24     	; 0x439c <simple_p_reassembly+0x42>
  } else if(data[0] != messages[id].next_part) {
    4384:	90 91 d6 19 	lds	r25, 0x19D6	; 0x8019d6 <messages+0x4>
    4388:	89 17       	cp	r24, r25
    438a:	41 f0       	breq	.+16     	; 0x439c <simple_p_reassembly+0x42>
    messages[id].next_part = 0;
    438c:	e2 ed       	ldi	r30, 0xD2	; 210
    438e:	f9 e1       	ldi	r31, 0x19	; 25
    4390:	14 82       	std	Z+4, r1	; 0x04
    messages[id].num_received_bytes = 0;
    4392:	13 82       	std	Z+3, r1	; 0x03
    4394:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    4396:	8f ef       	ldi	r24, 0xFF	; 255
    4398:	81 83       	std	Z+1, r24	; 0x01
    return;
    439a:	43 c0       	rjmp	.+134    	; 0x4422 <simple_p_reassembly+0xc8>
    439c:	80 91 d4 19 	lds	r24, 0x19D4	; 0x8019d4 <messages+0x2>
    43a0:	90 91 d5 19 	lds	r25, 0x19D5	; 0x8019d5 <messages+0x3>
    43a4:	02 97       	sbiw	r24, 0x02	; 2
  }

  if(messages[id].num_received_bytes + (length-2) > MAX_MESSAGE_SIZE) { // Message is larger than what can be handled, discard it
    43a6:	84 0f       	add	r24, r20
    43a8:	95 1f       	adc	r25, r21
    43aa:	85 36       	cpi	r24, 0x65	; 101
    43ac:	91 05       	cpc	r25, r1
    43ae:	40 f0       	brcs	.+16     	; 0x43c0 <simple_p_reassembly+0x66>
    messages[id].num_received_bytes = 0;
    43b0:	e2 ed       	ldi	r30, 0xD2	; 210
    43b2:	f9 e1       	ldi	r31, 0x19	; 25
    43b4:	13 82       	std	Z+3, r1	; 0x03
    43b6:	12 82       	std	Z+2, r1	; 0x02
    messages[id].next_part = 0;
    43b8:	14 82       	std	Z+4, r1	; 0x04
    messages[id].address = 0xFF;
    43ba:	8f ef       	ldi	r24, 0xFF	; 255
    43bc:	81 83       	std	Z+1, r24	; 0x01
    return;
    43be:	31 c0       	rjmp	.+98     	; 0x4422 <simple_p_reassembly+0xc8>
    43c0:	8a 01       	movw	r16, r20
    43c2:	eb 01       	movw	r28, r22
  }
  
  messages[id].next_part++;
    43c4:	0f 2e       	mov	r0, r31
    43c6:	f2 ed       	ldi	r31, 0xD2	; 210
    43c8:	ef 2e       	mov	r14, r31
    43ca:	f9 e1       	ldi	r31, 0x19	; 25
    43cc:	ff 2e       	mov	r15, r31
    43ce:	f0 2d       	mov	r31, r0
    43d0:	f7 01       	movw	r30, r14
    43d2:	84 81       	ldd	r24, Z+4	; 0x04
    43d4:	8f 5f       	subi	r24, 0xFF	; 255
    43d6:	84 83       	std	Z+4, r24	; 0x04
  memcpy(messages[id].message+messages[id].num_received_bytes, data+2, length-2);
    43d8:	82 81       	ldd	r24, Z+2	; 0x02
    43da:	93 81       	ldd	r25, Z+3	; 0x03
    43dc:	42 50       	subi	r20, 0x02	; 2
    43de:	51 09       	sbc	r21, r1
    43e0:	6e 5f       	subi	r22, 0xFE	; 254
    43e2:	7f 4f       	sbci	r23, 0xFF	; 255
    43e4:	89 52       	subi	r24, 0x29	; 41
    43e6:	96 4e       	sbci	r25, 0xE6	; 230
    43e8:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    43ec:	f7 01       	movw	r30, r14
    43ee:	42 81       	ldd	r20, Z+2	; 0x02
    43f0:	53 81       	ldd	r21, Z+3	; 0x03
    43f2:	42 50       	subi	r20, 0x02	; 2
    43f4:	51 09       	sbc	r21, r1
  messages[id].num_received_bytes += (length-2);
    43f6:	ba 01       	movw	r22, r20
    43f8:	60 0f       	add	r22, r16
    43fa:	71 1f       	adc	r23, r17
    43fc:	73 83       	std	Z+3, r23	; 0x03
    43fe:	62 83       	std	Z+2, r22	; 0x02
  
  if(data[0] == data[1]) {
    4400:	98 81       	ld	r25, Y
    4402:	89 81       	ldd	r24, Y+1	; 0x01
    4404:	98 13       	cpse	r25, r24
    4406:	0d c0       	rjmp	.+26     	; 0x4422 <simple_p_reassembly+0xc8>
    callback_data_received(messages[id].message, messages[id].num_received_bytes);
    4408:	e0 91 70 1b 	lds	r30, 0x1B70	; 0x801b70 <callback_data_received>
    440c:	f0 91 71 1b 	lds	r31, 0x1B71	; 0x801b71 <callback_data_received+0x1>
    4410:	87 ed       	ldi	r24, 0xD7	; 215
    4412:	99 e1       	ldi	r25, 0x19	; 25
    4414:	19 95       	eicall
    messages[id].num_received_bytes = messages[id].next_part = 0;
    4416:	f7 01       	movw	r30, r14
    4418:	14 82       	std	Z+4, r1	; 0x04
    441a:	13 82       	std	Z+3, r1	; 0x03
    441c:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    441e:	8f ef       	ldi	r24, 0xFF	; 255
    4420:	81 83       	std	Z+1, r24	; 0x01
  }
    4422:	df 91       	pop	r29
    4424:	cf 91       	pop	r28
    4426:	1f 91       	pop	r17
    4428:	0f 91       	pop	r16
    442a:	ff 90       	pop	r15
    442c:	ef 90       	pop	r14
    442e:	08 95       	ret

00004430 <simple_p_init>:
void (*callback_data_received)(uint8_t*, uint16_t); 

void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length);

void simple_p_init(void (*cb)(uint8_t*, uint16_t)) {
  callback_data_received = cb;
    4430:	90 93 71 1b 	sts	0x1B71, r25	; 0x801b71 <callback_data_received+0x1>
    4434:	80 93 70 1b 	sts	0x1B70, r24	; 0x801b70 <callback_data_received>
  uint8_t i;
  network_set_callback(PROTOCOL_SIMPLE, simple_p_reassembly);
    4438:	6d ea       	ldi	r22, 0xAD	; 173
    443a:	71 e2       	ldi	r23, 0x21	; 33
    443c:	80 e0       	ldi	r24, 0x00	; 0
    443e:	0e 94 39 17 	call	0x2e72	; 0x2e72 <network_set_callback>
  for(i=0;i<MAX_MESSAGES;i++) {
    messages[i].address = 0xFF;
    4442:	8f ef       	ldi	r24, 0xFF	; 255
    4444:	80 93 d3 19 	sts	0x19D3, r24	; 0x8019d3 <messages+0x1>
    4448:	08 95       	ret

0000444a <simple_p_send>:
  }
}

uint8_t simple_p_send(uint8_t address, uint8_t *data, uint16_t length) {  
    444a:	5f 92       	push	r5
    444c:	6f 92       	push	r6
    444e:	7f 92       	push	r7
    4450:	8f 92       	push	r8
    4452:	9f 92       	push	r9
    4454:	af 92       	push	r10
    4456:	bf 92       	push	r11
    4458:	cf 92       	push	r12
    445a:	df 92       	push	r13
    445c:	ef 92       	push	r14
    445e:	ff 92       	push	r15
    4460:	0f 93       	push	r16
    4462:	1f 93       	push	r17
    4464:	cf 93       	push	r28
    4466:	df 93       	push	r29
    4468:	58 2e       	mov	r5, r24
    446a:	5b 01       	movw	r10, r22
    446c:	8a 01       	movw	r16, r20
  uint16_t tmp;
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
    446e:	8c e2       	ldi	r24, 0x2C	; 44
    4470:	90 e0       	ldi	r25, 0x00	; 0
    4472:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    4476:	7c 01       	movw	r14, r24
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
    4478:	98 01       	movw	r18, r16
    447a:	36 95       	lsr	r19
    447c:	27 95       	ror	r18
    447e:	ad e0       	ldi	r26, 0x0D	; 13
    4480:	b3 ec       	ldi	r27, 0xC3	; 195
    4482:	0e 94 45 37 	call	0x6e8a	; 0x6e8a <__umulhisi3>
    4486:	92 95       	swap	r25
    4488:	82 95       	swap	r24
    448a:	8f 70       	andi	r24, 0x0F	; 15
    448c:	89 27       	eor	r24, r25
    448e:	9f 70       	andi	r25, 0x0F	; 15
    4490:	89 27       	eor	r24, r25
    4492:	4a e2       	ldi	r20, 0x2A	; 42
    4494:	48 9f       	mul	r20, r24
    4496:	90 01       	movw	r18, r0
    4498:	49 9f       	mul	r20, r25
    449a:	30 0d       	add	r19, r0
    449c:	11 24       	eor	r1, r1
    449e:	41 e0       	ldi	r20, 0x01	; 1
    44a0:	02 17       	cp	r16, r18
    44a2:	13 07       	cpc	r17, r19
    44a4:	09 f4       	brne	.+2      	; 0x44a8 <simple_p_send+0x5e>
    44a6:	40 e0       	ldi	r20, 0x00	; 0
    44a8:	98 01       	movw	r18, r16
    44aa:	36 95       	lsr	r19
    44ac:	27 95       	ror	r18
    44ae:	ad e0       	ldi	r26, 0x0D	; 13
    44b0:	b3 ec       	ldi	r27, 0xC3	; 195
    44b2:	0e 94 45 37 	call	0x6e8a	; 0x6e8a <__umulhisi3>
    44b6:	92 95       	swap	r25
    44b8:	82 95       	swap	r24
    44ba:	8f 70       	andi	r24, 0x0F	; 15
    44bc:	89 27       	eor	r24, r25
    44be:	9f 70       	andi	r25, 0x0F	; 15
    44c0:	89 27       	eor	r24, r25
    44c2:	84 0f       	add	r24, r20
  while(remaining > 0) {
    44c4:	01 15       	cp	r16, r1
    44c6:	11 05       	cpc	r17, r1
    44c8:	59 f1       	breq	.+86     	; 0x4520 <simple_p_send+0xd6>
    44ca:	90 e0       	ldi	r25, 0x00	; 0
    44cc:	c1 2c       	mov	r12, r1
    44ce:	d1 2c       	mov	r13, r1
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    part[1] = number_of_parts-1;
    44d0:	66 24       	eor	r6, r6
    44d2:	6a 94       	dec	r6
    44d4:	68 0e       	add	r6, r24
    memcpy(part+2, data+offset, tmp);
    44d6:	47 01       	movw	r8, r14
    44d8:	82 e0       	ldi	r24, 0x02	; 2
    44da:	88 0e       	add	r8, r24
    44dc:	91 1c       	adc	r9, r1
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    44de:	e8 01       	movw	r28, r16
    44e0:	0b 32       	cpi	r16, 0x2B	; 43
    44e2:	11 05       	cpc	r17, r1
    44e4:	10 f0       	brcs	.+4      	; 0x44ea <simple_p_send+0xa0>
    44e6:	ca e2       	ldi	r28, 0x2A	; 42
    44e8:	d0 e0       	ldi	r29, 0x00	; 0
    part[0] = part_number++;
    44ea:	77 24       	eor	r7, r7
    44ec:	73 94       	inc	r7
    44ee:	79 0e       	add	r7, r25
    44f0:	f7 01       	movw	r30, r14
    44f2:	90 83       	st	Z, r25
    part[1] = number_of_parts-1;
    44f4:	61 82       	std	Z+1, r6	; 0x01
    memcpy(part+2, data+offset, tmp);
    44f6:	b5 01       	movw	r22, r10
    44f8:	6c 0d       	add	r22, r12
    44fa:	7d 1d       	adc	r23, r13
    44fc:	ae 01       	movw	r20, r28
    44fe:	c4 01       	movw	r24, r8
    4500:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    4504:	9e 01       	movw	r18, r28
    4506:	2e 5f       	subi	r18, 0xFE	; 254
    4508:	3f 4f       	sbci	r19, 0xFF	; 255
    450a:	a7 01       	movw	r20, r14
    450c:	60 e0       	ldi	r22, 0x00	; 0
    450e:	85 2d       	mov	r24, r5
    4510:	0e 94 44 17 	call	0x2e88	; 0x2e88 <network_send>
    offset += tmp;
    4514:	cc 0e       	add	r12, r28
    4516:	dd 1e       	adc	r13, r29
    remaining -= tmp;
    4518:	0c 1b       	sub	r16, r28
    451a:	1d 0b       	sbc	r17, r29
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    451c:	97 2d       	mov	r25, r7
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    451e:	f9 f6       	brne	.-66     	; 0x44de <simple_p_send+0x94>
    memcpy(part+2, data+offset, tmp);
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    offset += tmp;
    remaining -= tmp;
  }
  vPortFree(part);
    4520:	c7 01       	movw	r24, r14
    4522:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
  return 1;
}
    4526:	81 e0       	ldi	r24, 0x01	; 1
    4528:	df 91       	pop	r29
    452a:	cf 91       	pop	r28
    452c:	1f 91       	pop	r17
    452e:	0f 91       	pop	r16
    4530:	ff 90       	pop	r15
    4532:	ef 90       	pop	r14
    4534:	df 90       	pop	r13
    4536:	cf 90       	pop	r12
    4538:	bf 90       	pop	r11
    453a:	af 90       	pop	r10
    453c:	9f 90       	pop	r9
    453e:	8f 90       	pop	r8
    4540:	7f 90       	pop	r7
    4542:	6f 90       	pop	r6
    4544:	5f 90       	pop	r5
    4546:	08 95       	ret

00004548 <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    4548:	84 b1       	in	r24, 0x04	; 4
    454a:	87 60       	ori	r24, 0x07	; 7
    454c:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    454e:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    4550:	8c b5       	in	r24, 0x2c	; 44
    4552:	81 60       	ori	r24, 0x01	; 1
    4554:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    4556:	8c b5       	in	r24, 0x2c	; 44
    4558:	8c 65       	ori	r24, 0x5C	; 92
    455a:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    455c:	8c b5       	in	r24, 0x2c	; 44
    455e:	8f 7d       	andi	r24, 0xDF	; 223
    4560:	8c bd       	out	0x2c, r24	; 44
    4562:	08 95       	ret

00004564 <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    4564:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    4566:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    4568:	0d b4       	in	r0, 0x2d	; 45
    456a:	07 fe       	sbrs	r0, 7
    456c:	fd cf       	rjmp	.-6      	; 0x4568 <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    456e:	8e b5       	in	r24, 0x2e	; 46
}
    4570:	08 95       	ret

00004572 <xTaskGenericCreate>:
    4572:	4f 92       	push	r4
    4574:	5f 92       	push	r5
    4576:	6f 92       	push	r6
    4578:	7f 92       	push	r7
    457a:	8f 92       	push	r8
    457c:	9f 92       	push	r9
    457e:	af 92       	push	r10
    4580:	bf 92       	push	r11
    4582:	cf 92       	push	r12
    4584:	df 92       	push	r13
    4586:	ef 92       	push	r14
    4588:	ff 92       	push	r15
    458a:	0f 93       	push	r16
    458c:	1f 93       	push	r17
    458e:	cf 93       	push	r28
    4590:	df 93       	push	r29
    4592:	4c 01       	movw	r8, r24
    4594:	eb 01       	movw	r28, r22
    4596:	5a 01       	movw	r10, r20
    4598:	29 01       	movw	r4, r18
    459a:	c1 14       	cp	r12, r1
    459c:	d1 04       	cpc	r13, r1
    459e:	39 f4       	brne	.+14     	; 0x45ae <xTaskGenericCreate+0x3c>
    45a0:	ca 01       	movw	r24, r20
    45a2:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    45a6:	6c 01       	movw	r12, r24
    45a8:	89 2b       	or	r24, r25
    45aa:	09 f4       	brne	.+2      	; 0x45ae <xTaskGenericCreate+0x3c>
    45ac:	e4 c0       	rjmp	.+456    	; 0x4776 <xTaskGenericCreate+0x204>
    45ae:	88 e2       	ldi	r24, 0x28	; 40
    45b0:	90 e0       	ldi	r25, 0x00	; 0
    45b2:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    45b6:	3c 01       	movw	r6, r24
    45b8:	00 97       	sbiw	r24, 0x00	; 0
    45ba:	79 f0       	breq	.+30     	; 0x45da <xTaskGenericCreate+0x68>
    45bc:	fc 01       	movw	r30, r24
    45be:	d0 8e       	std	Z+24, r13	; 0x18
    45c0:	c7 8a       	std	Z+23, r12	; 0x17
    45c2:	f1 e0       	ldi	r31, 0x01	; 1
    45c4:	af 1a       	sub	r10, r31
    45c6:	b1 08       	sbc	r11, r1
    45c8:	ca 0c       	add	r12, r10
    45ca:	db 1c       	adc	r13, r11
    45cc:	88 81       	ld	r24, Y
    45ce:	f3 01       	movw	r30, r6
    45d0:	81 8f       	std	Z+25, r24	; 0x19
    45d2:	88 81       	ld	r24, Y
    45d4:	81 11       	cpse	r24, r1
    45d6:	05 c0       	rjmp	.+10     	; 0x45e2 <xTaskGenericCreate+0x70>
    45d8:	14 c0       	rjmp	.+40     	; 0x4602 <xTaskGenericCreate+0x90>
    45da:	c6 01       	movw	r24, r12
    45dc:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
    45e0:	ca c0       	rjmp	.+404    	; 0x4776 <xTaskGenericCreate+0x204>
    45e2:	d3 01       	movw	r26, r6
    45e4:	5a 96       	adiw	r26, 0x1a	; 26
    45e6:	fe 01       	movw	r30, r28
    45e8:	31 96       	adiw	r30, 0x01	; 1
    45ea:	9e 01       	movw	r18, r28
    45ec:	28 5f       	subi	r18, 0xF8	; 248
    45ee:	3f 4f       	sbci	r19, 0xFF	; 255
    45f0:	ef 01       	movw	r28, r30
    45f2:	81 91       	ld	r24, Z+
    45f4:	8d 93       	st	X+, r24
    45f6:	88 81       	ld	r24, Y
    45f8:	88 23       	and	r24, r24
    45fa:	19 f0       	breq	.+6      	; 0x4602 <xTaskGenericCreate+0x90>
    45fc:	e2 17       	cp	r30, r18
    45fe:	f3 07       	cpc	r31, r19
    4600:	b9 f7       	brne	.-18     	; 0x45f0 <xTaskGenericCreate+0x7e>
    4602:	f3 01       	movw	r30, r6
    4604:	10 a2       	std	Z+32, r1	; 0x20
    4606:	10 2f       	mov	r17, r16
    4608:	06 30       	cpi	r16, 0x06	; 6
    460a:	08 f0       	brcs	.+2      	; 0x460e <xTaskGenericCreate+0x9c>
    460c:	15 e0       	ldi	r17, 0x05	; 5
    460e:	f3 01       	movw	r30, r6
    4610:	16 8b       	std	Z+22, r17	; 0x16
    4612:	11 a3       	std	Z+33, r17	; 0x21
    4614:	12 a2       	std	Z+34, r1	; 0x22
    4616:	e3 01       	movw	r28, r6
    4618:	22 96       	adiw	r28, 0x02	; 2
    461a:	ce 01       	movw	r24, r28
    461c:	0e 94 ca 0c 	call	0x1994	; 0x1994 <vListInitialiseItem>
    4620:	c3 01       	movw	r24, r6
    4622:	0c 96       	adiw	r24, 0x0c	; 12
    4624:	0e 94 ca 0c 	call	0x1994	; 0x1994 <vListInitialiseItem>
    4628:	f3 01       	movw	r30, r6
    462a:	71 86       	std	Z+9, r7	; 0x09
    462c:	60 86       	std	Z+8, r6	; 0x08
    462e:	86 e0       	ldi	r24, 0x06	; 6
    4630:	90 e0       	ldi	r25, 0x00	; 0
    4632:	81 1b       	sub	r24, r17
    4634:	91 09       	sbc	r25, r1
    4636:	95 87       	std	Z+13, r25	; 0x0d
    4638:	84 87       	std	Z+12, r24	; 0x0c
    463a:	73 8a       	std	Z+19, r7	; 0x13
    463c:	62 8a       	std	Z+18, r6	; 0x12
    463e:	13 a2       	std	Z+35, r1	; 0x23
    4640:	14 a2       	std	Z+36, r1	; 0x24
    4642:	15 a2       	std	Z+37, r1	; 0x25
    4644:	16 a2       	std	Z+38, r1	; 0x26
    4646:	17 a2       	std	Z+39, r1	; 0x27
    4648:	a2 01       	movw	r20, r4
    464a:	b4 01       	movw	r22, r8
    464c:	c6 01       	movw	r24, r12
    464e:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <pxPortInitialiseStack>
    4652:	f3 01       	movw	r30, r6
    4654:	91 83       	std	Z+1, r25	; 0x01
    4656:	80 83       	st	Z, r24
    4658:	e1 14       	cp	r14, r1
    465a:	f1 04       	cpc	r15, r1
    465c:	19 f0       	breq	.+6      	; 0x4664 <xTaskGenericCreate+0xf2>
    465e:	f7 01       	movw	r30, r14
    4660:	71 82       	std	Z+1, r7	; 0x01
    4662:	60 82       	st	Z, r6
    4664:	0f b6       	in	r0, 0x3f	; 63
    4666:	f8 94       	cli
    4668:	0f 92       	push	r0
    466a:	80 91 46 1a 	lds	r24, 0x1A46	; 0x801a46 <uxCurrentNumberOfTasks>
    466e:	8f 5f       	subi	r24, 0xFF	; 255
    4670:	80 93 46 1a 	sts	0x1A46, r24	; 0x801a46 <uxCurrentNumberOfTasks>
    4674:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4678:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    467c:	89 2b       	or	r24, r25
    467e:	d9 f5       	brne	.+118    	; 0x46f6 <xTaskGenericCreate+0x184>
    4680:	70 92 a6 1a 	sts	0x1AA6, r7	; 0x801aa6 <pxCurrentTCB+0x1>
    4684:	60 92 a5 1a 	sts	0x1AA5, r6	; 0x801aa5 <pxCurrentTCB>
    4688:	80 91 46 1a 	lds	r24, 0x1A46	; 0x801a46 <uxCurrentNumberOfTasks>
    468c:	81 30       	cpi	r24, 0x01	; 1
    468e:	09 f0       	breq	.+2      	; 0x4692 <xTaskGenericCreate+0x120>
    4690:	41 c0       	rjmp	.+130    	; 0x4714 <xTaskGenericCreate+0x1a2>
    4692:	0f 2e       	mov	r0, r31
    4694:	ff e6       	ldi	r31, 0x6F	; 111
    4696:	ef 2e       	mov	r14, r31
    4698:	fa e1       	ldi	r31, 0x1A	; 26
    469a:	ff 2e       	mov	r15, r31
    469c:	f0 2d       	mov	r31, r0
    469e:	0f 2e       	mov	r0, r31
    46a0:	f5 ea       	ldi	r31, 0xA5	; 165
    46a2:	cf 2e       	mov	r12, r31
    46a4:	fa e1       	ldi	r31, 0x1A	; 26
    46a6:	df 2e       	mov	r13, r31
    46a8:	f0 2d       	mov	r31, r0
    46aa:	c7 01       	movw	r24, r14
    46ac:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    46b0:	f9 e0       	ldi	r31, 0x09	; 9
    46b2:	ef 0e       	add	r14, r31
    46b4:	f1 1c       	adc	r15, r1
    46b6:	ec 14       	cp	r14, r12
    46b8:	fd 04       	cpc	r15, r13
    46ba:	b9 f7       	brne	.-18     	; 0x46aa <xTaskGenericCreate+0x138>
    46bc:	86 e6       	ldi	r24, 0x66	; 102
    46be:	9a e1       	ldi	r25, 0x1A	; 26
    46c0:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    46c4:	8d e5       	ldi	r24, 0x5D	; 93
    46c6:	9a e1       	ldi	r25, 0x1A	; 26
    46c8:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    46cc:	80 e5       	ldi	r24, 0x50	; 80
    46ce:	9a e1       	ldi	r25, 0x1A	; 26
    46d0:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    46d4:	87 e4       	ldi	r24, 0x47	; 71
    46d6:	9a e1       	ldi	r25, 0x1A	; 26
    46d8:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    46dc:	86 e6       	ldi	r24, 0x66	; 102
    46de:	9a e1       	ldi	r25, 0x1A	; 26
    46e0:	90 93 5c 1a 	sts	0x1A5C, r25	; 0x801a5c <pxDelayedTaskList+0x1>
    46e4:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <pxDelayedTaskList>
    46e8:	8d e5       	ldi	r24, 0x5D	; 93
    46ea:	9a e1       	ldi	r25, 0x1A	; 26
    46ec:	90 93 5a 1a 	sts	0x1A5A, r25	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    46f0:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <pxOverflowDelayedTaskList>
    46f4:	0f c0       	rjmp	.+30     	; 0x4714 <xTaskGenericCreate+0x1a2>
    46f6:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xSchedulerRunning>
    46fa:	81 11       	cpse	r24, r1
    46fc:	0b c0       	rjmp	.+22     	; 0x4714 <xTaskGenericCreate+0x1a2>
    46fe:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4702:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4706:	86 89       	ldd	r24, Z+22	; 0x16
    4708:	08 17       	cp	r16, r24
    470a:	20 f0       	brcs	.+8      	; 0x4714 <xTaskGenericCreate+0x1a2>
    470c:	70 92 a6 1a 	sts	0x1AA6, r7	; 0x801aa6 <pxCurrentTCB+0x1>
    4710:	60 92 a5 1a 	sts	0x1AA5, r6	; 0x801aa5 <pxCurrentTCB>
    4714:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <uxTaskNumber>
    4718:	8f 5f       	subi	r24, 0xFF	; 255
    471a:	80 93 3e 1a 	sts	0x1A3E, r24	; 0x801a3e <uxTaskNumber>
    471e:	f3 01       	movw	r30, r6
    4720:	86 89       	ldd	r24, Z+22	; 0x16
    4722:	90 91 43 1a 	lds	r25, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    4726:	98 17       	cp	r25, r24
    4728:	10 f4       	brcc	.+4      	; 0x472e <xTaskGenericCreate+0x1bc>
    472a:	80 93 43 1a 	sts	0x1A43, r24	; 0x801a43 <uxTopReadyPriority>
    472e:	90 e0       	ldi	r25, 0x00	; 0
    4730:	9c 01       	movw	r18, r24
    4732:	22 0f       	add	r18, r18
    4734:	33 1f       	adc	r19, r19
    4736:	22 0f       	add	r18, r18
    4738:	33 1f       	adc	r19, r19
    473a:	22 0f       	add	r18, r18
    473c:	33 1f       	adc	r19, r19
    473e:	82 0f       	add	r24, r18
    4740:	93 1f       	adc	r25, r19
    4742:	be 01       	movw	r22, r28
    4744:	81 59       	subi	r24, 0x91	; 145
    4746:	95 4e       	sbci	r25, 0xE5	; 229
    4748:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    474c:	0f 90       	pop	r0
    474e:	0f be       	out	0x3f, r0	; 63
    4750:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xSchedulerRunning>
    4754:	88 23       	and	r24, r24
    4756:	59 f0       	breq	.+22     	; 0x476e <xTaskGenericCreate+0x1fc>
    4758:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    475c:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4760:	86 89       	ldd	r24, Z+22	; 0x16
    4762:	80 17       	cp	r24, r16
    4764:	30 f4       	brcc	.+12     	; 0x4772 <xTaskGenericCreate+0x200>
    4766:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    476a:	81 e0       	ldi	r24, 0x01	; 1
    476c:	05 c0       	rjmp	.+10     	; 0x4778 <xTaskGenericCreate+0x206>
    476e:	81 e0       	ldi	r24, 0x01	; 1
    4770:	03 c0       	rjmp	.+6      	; 0x4778 <xTaskGenericCreate+0x206>
    4772:	81 e0       	ldi	r24, 0x01	; 1
    4774:	01 c0       	rjmp	.+2      	; 0x4778 <xTaskGenericCreate+0x206>
    4776:	8f ef       	ldi	r24, 0xFF	; 255
    4778:	df 91       	pop	r29
    477a:	cf 91       	pop	r28
    477c:	1f 91       	pop	r17
    477e:	0f 91       	pop	r16
    4780:	ff 90       	pop	r15
    4782:	ef 90       	pop	r14
    4784:	df 90       	pop	r13
    4786:	cf 90       	pop	r12
    4788:	bf 90       	pop	r11
    478a:	af 90       	pop	r10
    478c:	9f 90       	pop	r9
    478e:	8f 90       	pop	r8
    4790:	7f 90       	pop	r7
    4792:	6f 90       	pop	r6
    4794:	5f 90       	pop	r5
    4796:	4f 90       	pop	r4
    4798:	08 95       	ret

0000479a <vTaskDelayUntil>:
    479a:	9f 92       	push	r9
    479c:	af 92       	push	r10
    479e:	bf 92       	push	r11
    47a0:	cf 92       	push	r12
    47a2:	df 92       	push	r13
    47a4:	ef 92       	push	r14
    47a6:	ff 92       	push	r15
    47a8:	0f 93       	push	r16
    47aa:	1f 93       	push	r17
    47ac:	cf 93       	push	r28
    47ae:	df 93       	push	r29
    47b0:	fc 01       	movw	r30, r24
    47b2:	90 91 3b 1a 	lds	r25, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    47b6:	9f 5f       	subi	r25, 0xFF	; 255
    47b8:	90 93 3b 1a 	sts	0x1A3B, r25	; 0x801a3b <uxSchedulerSuspended>
    47bc:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    47c0:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    47c4:	20 81       	ld	r18, Z
    47c6:	31 81       	ldd	r19, Z+1	; 0x01
    47c8:	e9 01       	movw	r28, r18
    47ca:	c6 0f       	add	r28, r22
    47cc:	d7 1f       	adc	r29, r23
    47ce:	82 17       	cp	r24, r18
    47d0:	93 07       	cpc	r25, r19
    47d2:	58 f4       	brcc	.+22     	; 0x47ea <vTaskDelayUntil+0x50>
    47d4:	c2 17       	cp	r28, r18
    47d6:	d3 07       	cpc	r29, r19
    47d8:	08 f0       	brcs	.+2      	; 0x47dc <vTaskDelayUntil+0x42>
    47da:	6e c1       	rjmp	.+732    	; 0x4ab8 <vTaskDelayUntil+0x31e>
    47dc:	d1 83       	std	Z+1, r29	; 0x01
    47de:	c0 83       	st	Z, r28
    47e0:	8c 17       	cp	r24, r28
    47e2:	9d 07       	cpc	r25, r29
    47e4:	08 f0       	brcs	.+2      	; 0x47e8 <vTaskDelayUntil+0x4e>
    47e6:	42 c0       	rjmp	.+132    	; 0x486c <vTaskDelayUntil+0xd2>
    47e8:	09 c0       	rjmp	.+18     	; 0x47fc <vTaskDelayUntil+0x62>
    47ea:	c2 17       	cp	r28, r18
    47ec:	d3 07       	cpc	r29, r19
    47ee:	08 f4       	brcc	.+2      	; 0x47f2 <vTaskDelayUntil+0x58>
    47f0:	60 c1       	rjmp	.+704    	; 0x4ab2 <vTaskDelayUntil+0x318>
    47f2:	8c 17       	cp	r24, r28
    47f4:	9d 07       	cpc	r25, r29
    47f6:	08 f4       	brcc	.+2      	; 0x47fa <vTaskDelayUntil+0x60>
    47f8:	5c c1       	rjmp	.+696    	; 0x4ab2 <vTaskDelayUntil+0x318>
    47fa:	5e c1       	rjmp	.+700    	; 0x4ab8 <vTaskDelayUntil+0x31e>
    47fc:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4800:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4804:	02 96       	adiw	r24, 0x02	; 2
    4806:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    480a:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    480e:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4812:	d3 83       	std	Z+3, r29	; 0x03
    4814:	c2 83       	std	Z+2, r28	; 0x02
    4816:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    481a:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    481e:	c8 17       	cp	r28, r24
    4820:	d9 07       	cpc	r29, r25
    4822:	68 f4       	brcc	.+26     	; 0x483e <vTaskDelayUntil+0xa4>
    4824:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4828:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    482c:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    4830:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    4834:	6e 5f       	subi	r22, 0xFE	; 254
    4836:	7f 4f       	sbci	r23, 0xFF	; 255
    4838:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    483c:	17 c0       	rjmp	.+46     	; 0x486c <vTaskDelayUntil+0xd2>
    483e:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4842:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4846:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    484a:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    484e:	6e 5f       	subi	r22, 0xFE	; 254
    4850:	7f 4f       	sbci	r23, 0xFF	; 255
    4852:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    4856:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    485a:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    485e:	c8 17       	cp	r28, r24
    4860:	d9 07       	cpc	r29, r25
    4862:	20 f4       	brcc	.+8      	; 0x486c <vTaskDelayUntil+0xd2>
    4864:	d0 93 3d 1a 	sts	0x1A3D, r29	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4868:	c0 93 3c 1a 	sts	0x1A3C, r28	; 0x801a3c <xNextTaskUnblockTime>
    486c:	0f b6       	in	r0, 0x3f	; 63
    486e:	f8 94       	cli
    4870:	0f 92       	push	r0
    4872:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4876:	81 50       	subi	r24, 0x01	; 1
    4878:	80 93 3b 1a 	sts	0x1A3B, r24	; 0x801a3b <uxSchedulerSuspended>
    487c:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4880:	81 11       	cpse	r24, r1
    4882:	0d c1       	rjmp	.+538    	; 0x4a9e <vTaskDelayUntil+0x304>
    4884:	80 91 46 1a 	lds	r24, 0x1A46	; 0x801a46 <uxCurrentNumberOfTasks>
    4888:	81 11       	cpse	r24, r1
    488a:	33 c0       	rjmp	.+102    	; 0x48f2 <vTaskDelayUntil+0x158>
    488c:	0b c1       	rjmp	.+534    	; 0x4aa4 <vTaskDelayUntil+0x30a>
    488e:	d7 01       	movw	r26, r14
    4890:	15 96       	adiw	r26, 0x05	; 5
    4892:	ed 91       	ld	r30, X+
    4894:	fc 91       	ld	r31, X
    4896:	16 97       	sbiw	r26, 0x06	; 6
    4898:	c6 81       	ldd	r28, Z+6	; 0x06
    489a:	d7 81       	ldd	r29, Z+7	; 0x07
    489c:	ce 01       	movw	r24, r28
    489e:	0c 96       	adiw	r24, 0x0c	; 12
    48a0:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    48a4:	8e 01       	movw	r16, r28
    48a6:	0e 5f       	subi	r16, 0xFE	; 254
    48a8:	1f 4f       	sbci	r17, 0xFF	; 255
    48aa:	c8 01       	movw	r24, r16
    48ac:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    48b0:	2e 89       	ldd	r18, Y+22	; 0x16
    48b2:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    48b6:	82 17       	cp	r24, r18
    48b8:	10 f4       	brcc	.+4      	; 0x48be <vTaskDelayUntil+0x124>
    48ba:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    48be:	30 e0       	ldi	r19, 0x00	; 0
    48c0:	c9 01       	movw	r24, r18
    48c2:	88 0f       	add	r24, r24
    48c4:	99 1f       	adc	r25, r25
    48c6:	88 0f       	add	r24, r24
    48c8:	99 1f       	adc	r25, r25
    48ca:	88 0f       	add	r24, r24
    48cc:	99 1f       	adc	r25, r25
    48ce:	82 0f       	add	r24, r18
    48d0:	93 1f       	adc	r25, r19
    48d2:	b8 01       	movw	r22, r16
    48d4:	81 59       	subi	r24, 0x91	; 145
    48d6:	95 4e       	sbci	r25, 0xE5	; 229
    48d8:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    48dc:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    48e0:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    48e4:	9e 89       	ldd	r25, Y+22	; 0x16
    48e6:	86 89       	ldd	r24, Z+22	; 0x16
    48e8:	98 17       	cp	r25, r24
    48ea:	58 f0       	brcs	.+22     	; 0x4902 <vTaskDelayUntil+0x168>
    48ec:	d0 92 40 1a 	sts	0x1A40, r13	; 0x801a40 <xYieldPending>
    48f0:	08 c0       	rjmp	.+16     	; 0x4902 <vTaskDelayUntil+0x168>
    48f2:	0f 2e       	mov	r0, r31
    48f4:	f0 e5       	ldi	r31, 0x50	; 80
    48f6:	ef 2e       	mov	r14, r31
    48f8:	fa e1       	ldi	r31, 0x1A	; 26
    48fa:	ff 2e       	mov	r15, r31
    48fc:	f0 2d       	mov	r31, r0
    48fe:	dd 24       	eor	r13, r13
    4900:	d3 94       	inc	r13
    4902:	f7 01       	movw	r30, r14
    4904:	80 81       	ld	r24, Z
    4906:	81 11       	cpse	r24, r1
    4908:	c2 cf       	rjmp	.-124    	; 0x488e <vTaskDelayUntil+0xf4>
    490a:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    490e:	88 23       	and	r24, r24
    4910:	09 f4       	brne	.+2      	; 0x4914 <vTaskDelayUntil+0x17a>
    4912:	bd c0       	rjmp	.+378    	; 0x4a8e <vTaskDelayUntil+0x2f4>
    4914:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4918:	88 23       	and	r24, r24
    491a:	09 f4       	brne	.+2      	; 0x491e <vTaskDelayUntil+0x184>
    491c:	b8 c0       	rjmp	.+368    	; 0x4a8e <vTaskDelayUntil+0x2f4>
    491e:	91 2c       	mov	r9, r1
    4920:	aa 24       	eor	r10, r10
    4922:	a3 94       	inc	r10
    4924:	cc 24       	eor	r12, r12
    4926:	ca 94       	dec	r12
    4928:	dc 2c       	mov	r13, r12
    492a:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    492e:	81 11       	cpse	r24, r1
    4930:	98 c0       	rjmp	.+304    	; 0x4a62 <vTaskDelayUntil+0x2c8>
    4932:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    4936:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    493a:	01 96       	adiw	r24, 0x01	; 1
    493c:	90 93 45 1a 	sts	0x1A45, r25	; 0x801a45 <xTickCount+0x1>
    4940:	80 93 44 1a 	sts	0x1A44, r24	; 0x801a44 <xTickCount>
    4944:	e0 90 44 1a 	lds	r14, 0x1A44	; 0x801a44 <xTickCount>
    4948:	f0 90 45 1a 	lds	r15, 0x1A45	; 0x801a45 <xTickCount+0x1>
    494c:	e1 14       	cp	r14, r1
    494e:	f1 04       	cpc	r15, r1
    4950:	89 f5       	brne	.+98     	; 0x49b4 <vTaskDelayUntil+0x21a>
    4952:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4956:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    495a:	20 91 59 1a 	lds	r18, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    495e:	30 91 5a 1a 	lds	r19, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    4962:	30 93 5c 1a 	sts	0x1A5C, r19	; 0x801a5c <pxDelayedTaskList+0x1>
    4966:	20 93 5b 1a 	sts	0x1A5B, r18	; 0x801a5b <pxDelayedTaskList>
    496a:	90 93 5a 1a 	sts	0x1A5A, r25	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    496e:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <pxOverflowDelayedTaskList>
    4972:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <xNumOfOverflows>
    4976:	8f 5f       	subi	r24, 0xFF	; 255
    4978:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <xNumOfOverflows>
    497c:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4980:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    4984:	80 81       	ld	r24, Z
    4986:	81 11       	cpse	r24, r1
    4988:	05 c0       	rjmp	.+10     	; 0x4994 <vTaskDelayUntil+0x1fa>
    498a:	d0 92 3d 1a 	sts	0x1A3D, r13	; 0x801a3d <xNextTaskUnblockTime+0x1>
    498e:	c0 92 3c 1a 	sts	0x1A3C, r12	; 0x801a3c <xNextTaskUnblockTime>
    4992:	10 c0       	rjmp	.+32     	; 0x49b4 <vTaskDelayUntil+0x21a>
    4994:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4998:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    499c:	05 80       	ldd	r0, Z+5	; 0x05
    499e:	f6 81       	ldd	r31, Z+6	; 0x06
    49a0:	e0 2d       	mov	r30, r0
    49a2:	06 80       	ldd	r0, Z+6	; 0x06
    49a4:	f7 81       	ldd	r31, Z+7	; 0x07
    49a6:	e0 2d       	mov	r30, r0
    49a8:	82 81       	ldd	r24, Z+2	; 0x02
    49aa:	93 81       	ldd	r25, Z+3	; 0x03
    49ac:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    49b0:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    49b4:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    49b8:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    49bc:	e8 16       	cp	r14, r24
    49be:	f9 06       	cpc	r15, r25
    49c0:	08 f4       	brcc	.+2      	; 0x49c4 <vTaskDelayUntil+0x22a>
    49c2:	7d c0       	rjmp	.+250    	; 0x4abe <vTaskDelayUntil+0x324>
    49c4:	b9 2c       	mov	r11, r9
    49c6:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    49ca:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    49ce:	80 81       	ld	r24, Z
    49d0:	81 11       	cpse	r24, r1
    49d2:	05 c0       	rjmp	.+10     	; 0x49de <vTaskDelayUntil+0x244>
    49d4:	d0 92 3d 1a 	sts	0x1A3D, r13	; 0x801a3d <xNextTaskUnblockTime+0x1>
    49d8:	c0 92 3c 1a 	sts	0x1A3C, r12	; 0x801a3c <xNextTaskUnblockTime>
    49dc:	48 c0       	rjmp	.+144    	; 0x4a6e <vTaskDelayUntil+0x2d4>
    49de:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    49e2:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    49e6:	05 80       	ldd	r0, Z+5	; 0x05
    49e8:	f6 81       	ldd	r31, Z+6	; 0x06
    49ea:	e0 2d       	mov	r30, r0
    49ec:	c6 81       	ldd	r28, Z+6	; 0x06
    49ee:	d7 81       	ldd	r29, Z+7	; 0x07
    49f0:	8a 81       	ldd	r24, Y+2	; 0x02
    49f2:	9b 81       	ldd	r25, Y+3	; 0x03
    49f4:	e8 16       	cp	r14, r24
    49f6:	f9 06       	cpc	r15, r25
    49f8:	28 f4       	brcc	.+10     	; 0x4a04 <vTaskDelayUntil+0x26a>
    49fa:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    49fe:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    4a02:	35 c0       	rjmp	.+106    	; 0x4a6e <vTaskDelayUntil+0x2d4>
    4a04:	8e 01       	movw	r16, r28
    4a06:	0e 5f       	subi	r16, 0xFE	; 254
    4a08:	1f 4f       	sbci	r17, 0xFF	; 255
    4a0a:	c8 01       	movw	r24, r16
    4a0c:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    4a10:	8c 89       	ldd	r24, Y+20	; 0x14
    4a12:	9d 89       	ldd	r25, Y+21	; 0x15
    4a14:	89 2b       	or	r24, r25
    4a16:	21 f0       	breq	.+8      	; 0x4a20 <vTaskDelayUntil+0x286>
    4a18:	ce 01       	movw	r24, r28
    4a1a:	0c 96       	adiw	r24, 0x0c	; 12
    4a1c:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    4a20:	2e 89       	ldd	r18, Y+22	; 0x16
    4a22:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    4a26:	82 17       	cp	r24, r18
    4a28:	10 f4       	brcc	.+4      	; 0x4a2e <vTaskDelayUntil+0x294>
    4a2a:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    4a2e:	30 e0       	ldi	r19, 0x00	; 0
    4a30:	c9 01       	movw	r24, r18
    4a32:	88 0f       	add	r24, r24
    4a34:	99 1f       	adc	r25, r25
    4a36:	88 0f       	add	r24, r24
    4a38:	99 1f       	adc	r25, r25
    4a3a:	88 0f       	add	r24, r24
    4a3c:	99 1f       	adc	r25, r25
    4a3e:	82 0f       	add	r24, r18
    4a40:	93 1f       	adc	r25, r19
    4a42:	b8 01       	movw	r22, r16
    4a44:	81 59       	subi	r24, 0x91	; 145
    4a46:	95 4e       	sbci	r25, 0xE5	; 229
    4a48:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    4a4c:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4a50:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4a54:	9e 89       	ldd	r25, Y+22	; 0x16
    4a56:	86 89       	ldd	r24, Z+22	; 0x16
    4a58:	98 17       	cp	r25, r24
    4a5a:	08 f4       	brcc	.+2      	; 0x4a5e <vTaskDelayUntil+0x2c4>
    4a5c:	b4 cf       	rjmp	.-152    	; 0x49c6 <vTaskDelayUntil+0x22c>
    4a5e:	ba 2c       	mov	r11, r10
    4a60:	b2 cf       	rjmp	.-156    	; 0x49c6 <vTaskDelayUntil+0x22c>
    4a62:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4a66:	8f 5f       	subi	r24, 0xFF	; 255
    4a68:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxPendedTicks>
    4a6c:	28 c0       	rjmp	.+80     	; 0x4abe <vTaskDelayUntil+0x324>
    4a6e:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    4a72:	81 11       	cpse	r24, r1
    4a74:	01 c0       	rjmp	.+2      	; 0x4a78 <vTaskDelayUntil+0x2de>
    4a76:	b1 10       	cpse	r11, r1
    4a78:	a0 92 40 1a 	sts	0x1A40, r10	; 0x801a40 <xYieldPending>
    4a7c:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4a80:	81 50       	subi	r24, 0x01	; 1
    4a82:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxPendedTicks>
    4a86:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4a8a:	81 11       	cpse	r24, r1
    4a8c:	4e cf       	rjmp	.-356    	; 0x492a <vTaskDelayUntil+0x190>
    4a8e:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    4a92:	81 30       	cpi	r24, 0x01	; 1
    4a94:	31 f4       	brne	.+12     	; 0x4aa2 <vTaskDelayUntil+0x308>
    4a96:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    4a9a:	81 e0       	ldi	r24, 0x01	; 1
    4a9c:	03 c0       	rjmp	.+6      	; 0x4aa4 <vTaskDelayUntil+0x30a>
    4a9e:	80 e0       	ldi	r24, 0x00	; 0
    4aa0:	01 c0       	rjmp	.+2      	; 0x4aa4 <vTaskDelayUntil+0x30a>
    4aa2:	80 e0       	ldi	r24, 0x00	; 0
    4aa4:	0f 90       	pop	r0
    4aa6:	0f be       	out	0x3f, r0	; 63
    4aa8:	81 11       	cpse	r24, r1
    4aaa:	0e c0       	rjmp	.+28     	; 0x4ac8 <vTaskDelayUntil+0x32e>
    4aac:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    4ab0:	0b c0       	rjmp	.+22     	; 0x4ac8 <vTaskDelayUntil+0x32e>
    4ab2:	d1 83       	std	Z+1, r29	; 0x01
    4ab4:	c0 83       	st	Z, r28
    4ab6:	a2 ce       	rjmp	.-700    	; 0x47fc <vTaskDelayUntil+0x62>
    4ab8:	d1 83       	std	Z+1, r29	; 0x01
    4aba:	c0 83       	st	Z, r28
    4abc:	d7 ce       	rjmp	.-594    	; 0x486c <vTaskDelayUntil+0xd2>
    4abe:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    4ac2:	88 23       	and	r24, r24
    4ac4:	d9 f2       	breq	.-74     	; 0x4a7c <vTaskDelayUntil+0x2e2>
    4ac6:	d8 cf       	rjmp	.-80     	; 0x4a78 <vTaskDelayUntil+0x2de>
    4ac8:	df 91       	pop	r29
    4aca:	cf 91       	pop	r28
    4acc:	1f 91       	pop	r17
    4ace:	0f 91       	pop	r16
    4ad0:	ff 90       	pop	r15
    4ad2:	ef 90       	pop	r14
    4ad4:	df 90       	pop	r13
    4ad6:	cf 90       	pop	r12
    4ad8:	bf 90       	pop	r11
    4ada:	af 90       	pop	r10
    4adc:	9f 90       	pop	r9
    4ade:	08 95       	ret

00004ae0 <vTaskDelay>:
    4ae0:	9f 92       	push	r9
    4ae2:	af 92       	push	r10
    4ae4:	bf 92       	push	r11
    4ae6:	cf 92       	push	r12
    4ae8:	df 92       	push	r13
    4aea:	ef 92       	push	r14
    4aec:	ff 92       	push	r15
    4aee:	0f 93       	push	r16
    4af0:	1f 93       	push	r17
    4af2:	cf 93       	push	r28
    4af4:	df 93       	push	r29
    4af6:	00 97       	sbiw	r24, 0x00	; 0
    4af8:	09 f4       	brne	.+2      	; 0x4afc <vTaskDelay+0x1c>
    4afa:	63 c1       	rjmp	.+710    	; 0x4dc2 <vTaskDelay+0x2e2>
    4afc:	20 91 3b 1a 	lds	r18, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4b00:	2f 5f       	subi	r18, 0xFF	; 255
    4b02:	20 93 3b 1a 	sts	0x1A3B, r18	; 0x801a3b <uxSchedulerSuspended>
    4b06:	c0 91 44 1a 	lds	r28, 0x1A44	; 0x801a44 <xTickCount>
    4b0a:	d0 91 45 1a 	lds	r29, 0x1A45	; 0x801a45 <xTickCount+0x1>
    4b0e:	c8 0f       	add	r28, r24
    4b10:	d9 1f       	adc	r29, r25
    4b12:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4b16:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4b1a:	02 96       	adiw	r24, 0x02	; 2
    4b1c:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    4b20:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4b24:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4b28:	d3 83       	std	Z+3, r29	; 0x03
    4b2a:	c2 83       	std	Z+2, r28	; 0x02
    4b2c:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    4b30:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    4b34:	c8 17       	cp	r28, r24
    4b36:	d9 07       	cpc	r29, r25
    4b38:	68 f4       	brcc	.+26     	; 0x4b54 <vTaskDelay+0x74>
    4b3a:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4b3e:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4b42:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    4b46:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    4b4a:	6e 5f       	subi	r22, 0xFE	; 254
    4b4c:	7f 4f       	sbci	r23, 0xFF	; 255
    4b4e:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    4b52:	17 c0       	rjmp	.+46     	; 0x4b82 <vTaskDelay+0xa2>
    4b54:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4b58:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4b5c:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4b60:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    4b64:	6e 5f       	subi	r22, 0xFE	; 254
    4b66:	7f 4f       	sbci	r23, 0xFF	; 255
    4b68:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    4b6c:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    4b70:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4b74:	c8 17       	cp	r28, r24
    4b76:	d9 07       	cpc	r29, r25
    4b78:	20 f4       	brcc	.+8      	; 0x4b82 <vTaskDelay+0xa2>
    4b7a:	d0 93 3d 1a 	sts	0x1A3D, r29	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4b7e:	c0 93 3c 1a 	sts	0x1A3C, r28	; 0x801a3c <xNextTaskUnblockTime>
    4b82:	0f b6       	in	r0, 0x3f	; 63
    4b84:	f8 94       	cli
    4b86:	0f 92       	push	r0
    4b88:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4b8c:	81 50       	subi	r24, 0x01	; 1
    4b8e:	80 93 3b 1a 	sts	0x1A3B, r24	; 0x801a3b <uxSchedulerSuspended>
    4b92:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4b96:	81 11       	cpse	r24, r1
    4b98:	0d c1       	rjmp	.+538    	; 0x4db4 <vTaskDelay+0x2d4>
    4b9a:	80 91 46 1a 	lds	r24, 0x1A46	; 0x801a46 <uxCurrentNumberOfTasks>
    4b9e:	81 11       	cpse	r24, r1
    4ba0:	33 c0       	rjmp	.+102    	; 0x4c08 <vTaskDelay+0x128>
    4ba2:	0b c1       	rjmp	.+534    	; 0x4dba <vTaskDelay+0x2da>
    4ba4:	d7 01       	movw	r26, r14
    4ba6:	15 96       	adiw	r26, 0x05	; 5
    4ba8:	ed 91       	ld	r30, X+
    4baa:	fc 91       	ld	r31, X
    4bac:	16 97       	sbiw	r26, 0x06	; 6
    4bae:	c6 81       	ldd	r28, Z+6	; 0x06
    4bb0:	d7 81       	ldd	r29, Z+7	; 0x07
    4bb2:	ce 01       	movw	r24, r28
    4bb4:	0c 96       	adiw	r24, 0x0c	; 12
    4bb6:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    4bba:	8e 01       	movw	r16, r28
    4bbc:	0e 5f       	subi	r16, 0xFE	; 254
    4bbe:	1f 4f       	sbci	r17, 0xFF	; 255
    4bc0:	c8 01       	movw	r24, r16
    4bc2:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    4bc6:	2e 89       	ldd	r18, Y+22	; 0x16
    4bc8:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    4bcc:	82 17       	cp	r24, r18
    4bce:	10 f4       	brcc	.+4      	; 0x4bd4 <vTaskDelay+0xf4>
    4bd0:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    4bd4:	30 e0       	ldi	r19, 0x00	; 0
    4bd6:	c9 01       	movw	r24, r18
    4bd8:	88 0f       	add	r24, r24
    4bda:	99 1f       	adc	r25, r25
    4bdc:	88 0f       	add	r24, r24
    4bde:	99 1f       	adc	r25, r25
    4be0:	88 0f       	add	r24, r24
    4be2:	99 1f       	adc	r25, r25
    4be4:	82 0f       	add	r24, r18
    4be6:	93 1f       	adc	r25, r19
    4be8:	b8 01       	movw	r22, r16
    4bea:	81 59       	subi	r24, 0x91	; 145
    4bec:	95 4e       	sbci	r25, 0xE5	; 229
    4bee:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    4bf2:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4bf6:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4bfa:	9e 89       	ldd	r25, Y+22	; 0x16
    4bfc:	86 89       	ldd	r24, Z+22	; 0x16
    4bfe:	98 17       	cp	r25, r24
    4c00:	58 f0       	brcs	.+22     	; 0x4c18 <vTaskDelay+0x138>
    4c02:	d0 92 40 1a 	sts	0x1A40, r13	; 0x801a40 <xYieldPending>
    4c06:	08 c0       	rjmp	.+16     	; 0x4c18 <vTaskDelay+0x138>
    4c08:	0f 2e       	mov	r0, r31
    4c0a:	f0 e5       	ldi	r31, 0x50	; 80
    4c0c:	ef 2e       	mov	r14, r31
    4c0e:	fa e1       	ldi	r31, 0x1A	; 26
    4c10:	ff 2e       	mov	r15, r31
    4c12:	f0 2d       	mov	r31, r0
    4c14:	dd 24       	eor	r13, r13
    4c16:	d3 94       	inc	r13
    4c18:	f7 01       	movw	r30, r14
    4c1a:	80 81       	ld	r24, Z
    4c1c:	81 11       	cpse	r24, r1
    4c1e:	c2 cf       	rjmp	.-124    	; 0x4ba4 <vTaskDelay+0xc4>
    4c20:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4c24:	88 23       	and	r24, r24
    4c26:	09 f4       	brne	.+2      	; 0x4c2a <vTaskDelay+0x14a>
    4c28:	bd c0       	rjmp	.+378    	; 0x4da4 <vTaskDelay+0x2c4>
    4c2a:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4c2e:	88 23       	and	r24, r24
    4c30:	09 f4       	brne	.+2      	; 0x4c34 <vTaskDelay+0x154>
    4c32:	b8 c0       	rjmp	.+368    	; 0x4da4 <vTaskDelay+0x2c4>
    4c34:	91 2c       	mov	r9, r1
    4c36:	aa 24       	eor	r10, r10
    4c38:	a3 94       	inc	r10
    4c3a:	cc 24       	eor	r12, r12
    4c3c:	ca 94       	dec	r12
    4c3e:	dc 2c       	mov	r13, r12
    4c40:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4c44:	81 11       	cpse	r24, r1
    4c46:	98 c0       	rjmp	.+304    	; 0x4d78 <vTaskDelay+0x298>
    4c48:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    4c4c:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    4c50:	01 96       	adiw	r24, 0x01	; 1
    4c52:	90 93 45 1a 	sts	0x1A45, r25	; 0x801a45 <xTickCount+0x1>
    4c56:	80 93 44 1a 	sts	0x1A44, r24	; 0x801a44 <xTickCount>
    4c5a:	e0 90 44 1a 	lds	r14, 0x1A44	; 0x801a44 <xTickCount>
    4c5e:	f0 90 45 1a 	lds	r15, 0x1A45	; 0x801a45 <xTickCount+0x1>
    4c62:	e1 14       	cp	r14, r1
    4c64:	f1 04       	cpc	r15, r1
    4c66:	89 f5       	brne	.+98     	; 0x4cca <vTaskDelay+0x1ea>
    4c68:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4c6c:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    4c70:	20 91 59 1a 	lds	r18, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    4c74:	30 91 5a 1a 	lds	r19, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    4c78:	30 93 5c 1a 	sts	0x1A5C, r19	; 0x801a5c <pxDelayedTaskList+0x1>
    4c7c:	20 93 5b 1a 	sts	0x1A5B, r18	; 0x801a5b <pxDelayedTaskList>
    4c80:	90 93 5a 1a 	sts	0x1A5A, r25	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    4c84:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <pxOverflowDelayedTaskList>
    4c88:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <xNumOfOverflows>
    4c8c:	8f 5f       	subi	r24, 0xFF	; 255
    4c8e:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <xNumOfOverflows>
    4c92:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4c96:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    4c9a:	80 81       	ld	r24, Z
    4c9c:	81 11       	cpse	r24, r1
    4c9e:	05 c0       	rjmp	.+10     	; 0x4caa <vTaskDelay+0x1ca>
    4ca0:	d0 92 3d 1a 	sts	0x1A3D, r13	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4ca4:	c0 92 3c 1a 	sts	0x1A3C, r12	; 0x801a3c <xNextTaskUnblockTime>
    4ca8:	10 c0       	rjmp	.+32     	; 0x4cca <vTaskDelay+0x1ea>
    4caa:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4cae:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    4cb2:	05 80       	ldd	r0, Z+5	; 0x05
    4cb4:	f6 81       	ldd	r31, Z+6	; 0x06
    4cb6:	e0 2d       	mov	r30, r0
    4cb8:	06 80       	ldd	r0, Z+6	; 0x06
    4cba:	f7 81       	ldd	r31, Z+7	; 0x07
    4cbc:	e0 2d       	mov	r30, r0
    4cbe:	82 81       	ldd	r24, Z+2	; 0x02
    4cc0:	93 81       	ldd	r25, Z+3	; 0x03
    4cc2:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4cc6:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    4cca:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    4cce:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4cd2:	e8 16       	cp	r14, r24
    4cd4:	f9 06       	cpc	r15, r25
    4cd6:	08 f4       	brcc	.+2      	; 0x4cda <vTaskDelay+0x1fa>
    4cd8:	77 c0       	rjmp	.+238    	; 0x4dc8 <vTaskDelay+0x2e8>
    4cda:	b9 2c       	mov	r11, r9
    4cdc:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4ce0:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    4ce4:	80 81       	ld	r24, Z
    4ce6:	81 11       	cpse	r24, r1
    4ce8:	05 c0       	rjmp	.+10     	; 0x4cf4 <vTaskDelay+0x214>
    4cea:	d0 92 3d 1a 	sts	0x1A3D, r13	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4cee:	c0 92 3c 1a 	sts	0x1A3C, r12	; 0x801a3c <xNextTaskUnblockTime>
    4cf2:	48 c0       	rjmp	.+144    	; 0x4d84 <vTaskDelay+0x2a4>
    4cf4:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    4cf8:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    4cfc:	05 80       	ldd	r0, Z+5	; 0x05
    4cfe:	f6 81       	ldd	r31, Z+6	; 0x06
    4d00:	e0 2d       	mov	r30, r0
    4d02:	c6 81       	ldd	r28, Z+6	; 0x06
    4d04:	d7 81       	ldd	r29, Z+7	; 0x07
    4d06:	8a 81       	ldd	r24, Y+2	; 0x02
    4d08:	9b 81       	ldd	r25, Y+3	; 0x03
    4d0a:	e8 16       	cp	r14, r24
    4d0c:	f9 06       	cpc	r15, r25
    4d0e:	28 f4       	brcc	.+10     	; 0x4d1a <vTaskDelay+0x23a>
    4d10:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4d14:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    4d18:	35 c0       	rjmp	.+106    	; 0x4d84 <vTaskDelay+0x2a4>
    4d1a:	8e 01       	movw	r16, r28
    4d1c:	0e 5f       	subi	r16, 0xFE	; 254
    4d1e:	1f 4f       	sbci	r17, 0xFF	; 255
    4d20:	c8 01       	movw	r24, r16
    4d22:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    4d26:	8c 89       	ldd	r24, Y+20	; 0x14
    4d28:	9d 89       	ldd	r25, Y+21	; 0x15
    4d2a:	89 2b       	or	r24, r25
    4d2c:	21 f0       	breq	.+8      	; 0x4d36 <vTaskDelay+0x256>
    4d2e:	ce 01       	movw	r24, r28
    4d30:	0c 96       	adiw	r24, 0x0c	; 12
    4d32:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    4d36:	2e 89       	ldd	r18, Y+22	; 0x16
    4d38:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    4d3c:	82 17       	cp	r24, r18
    4d3e:	10 f4       	brcc	.+4      	; 0x4d44 <vTaskDelay+0x264>
    4d40:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    4d44:	30 e0       	ldi	r19, 0x00	; 0
    4d46:	c9 01       	movw	r24, r18
    4d48:	88 0f       	add	r24, r24
    4d4a:	99 1f       	adc	r25, r25
    4d4c:	88 0f       	add	r24, r24
    4d4e:	99 1f       	adc	r25, r25
    4d50:	88 0f       	add	r24, r24
    4d52:	99 1f       	adc	r25, r25
    4d54:	82 0f       	add	r24, r18
    4d56:	93 1f       	adc	r25, r19
    4d58:	b8 01       	movw	r22, r16
    4d5a:	81 59       	subi	r24, 0x91	; 145
    4d5c:	95 4e       	sbci	r25, 0xE5	; 229
    4d5e:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    4d62:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4d66:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4d6a:	9e 89       	ldd	r25, Y+22	; 0x16
    4d6c:	86 89       	ldd	r24, Z+22	; 0x16
    4d6e:	98 17       	cp	r25, r24
    4d70:	08 f4       	brcc	.+2      	; 0x4d74 <vTaskDelay+0x294>
    4d72:	b4 cf       	rjmp	.-152    	; 0x4cdc <vTaskDelay+0x1fc>
    4d74:	ba 2c       	mov	r11, r10
    4d76:	b2 cf       	rjmp	.-156    	; 0x4cdc <vTaskDelay+0x1fc>
    4d78:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4d7c:	8f 5f       	subi	r24, 0xFF	; 255
    4d7e:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxPendedTicks>
    4d82:	22 c0       	rjmp	.+68     	; 0x4dc8 <vTaskDelay+0x2e8>
    4d84:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    4d88:	81 11       	cpse	r24, r1
    4d8a:	01 c0       	rjmp	.+2      	; 0x4d8e <vTaskDelay+0x2ae>
    4d8c:	b1 10       	cpse	r11, r1
    4d8e:	a0 92 40 1a 	sts	0x1A40, r10	; 0x801a40 <xYieldPending>
    4d92:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4d96:	81 50       	subi	r24, 0x01	; 1
    4d98:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxPendedTicks>
    4d9c:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    4da0:	81 11       	cpse	r24, r1
    4da2:	4e cf       	rjmp	.-356    	; 0x4c40 <vTaskDelay+0x160>
    4da4:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    4da8:	81 30       	cpi	r24, 0x01	; 1
    4daa:	31 f4       	brne	.+12     	; 0x4db8 <vTaskDelay+0x2d8>
    4dac:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    4db0:	81 e0       	ldi	r24, 0x01	; 1
    4db2:	03 c0       	rjmp	.+6      	; 0x4dba <vTaskDelay+0x2da>
    4db4:	80 e0       	ldi	r24, 0x00	; 0
    4db6:	01 c0       	rjmp	.+2      	; 0x4dba <vTaskDelay+0x2da>
    4db8:	80 e0       	ldi	r24, 0x00	; 0
    4dba:	0f 90       	pop	r0
    4dbc:	0f be       	out	0x3f, r0	; 63
    4dbe:	81 11       	cpse	r24, r1
    4dc0:	08 c0       	rjmp	.+16     	; 0x4dd2 <vTaskDelay+0x2f2>
    4dc2:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    4dc6:	05 c0       	rjmp	.+10     	; 0x4dd2 <vTaskDelay+0x2f2>
    4dc8:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    4dcc:	88 23       	and	r24, r24
    4dce:	09 f3       	breq	.-62     	; 0x4d92 <vTaskDelay+0x2b2>
    4dd0:	de cf       	rjmp	.-68     	; 0x4d8e <vTaskDelay+0x2ae>
    4dd2:	df 91       	pop	r29
    4dd4:	cf 91       	pop	r28
    4dd6:	1f 91       	pop	r17
    4dd8:	0f 91       	pop	r16
    4dda:	ff 90       	pop	r15
    4ddc:	ef 90       	pop	r14
    4dde:	df 90       	pop	r13
    4de0:	cf 90       	pop	r12
    4de2:	bf 90       	pop	r11
    4de4:	af 90       	pop	r10
    4de6:	9f 90       	pop	r9
    4de8:	08 95       	ret

00004dea <vTaskStartScheduler>:
    4dea:	cf 92       	push	r12
    4dec:	df 92       	push	r13
    4dee:	ef 92       	push	r14
    4df0:	ff 92       	push	r15
    4df2:	0f 93       	push	r16
    4df4:	1f 93       	push	r17
    4df6:	cf 93       	push	r28
    4df8:	df 93       	push	r29
    4dfa:	85 e5       	ldi	r24, 0x55	; 85
    4dfc:	90 e0       	ldi	r25, 0x00	; 0
    4dfe:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    4e02:	8c 01       	movw	r16, r24
    4e04:	89 2b       	or	r24, r25
    4e06:	09 f4       	brne	.+2      	; 0x4e0a <vTaskStartScheduler+0x20>
    4e08:	cb c0       	rjmp	.+406    	; 0x4fa0 <vTaskStartScheduler+0x1b6>
    4e0a:	88 e2       	ldi	r24, 0x28	; 40
    4e0c:	90 e0       	ldi	r25, 0x00	; 0
    4e0e:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
    4e12:	ec 01       	movw	r28, r24
    4e14:	89 2b       	or	r24, r25
    4e16:	69 f0       	breq	.+26     	; 0x4e32 <vTaskStartScheduler+0x48>
    4e18:	18 8f       	std	Y+24, r17	; 0x18
    4e1a:	0f 8b       	std	Y+23, r16	; 0x17
    4e1c:	0c 5a       	subi	r16, 0xAC	; 172
    4e1e:	1f 4f       	sbci	r17, 0xFF	; 255
    4e20:	89 e4       	ldi	r24, 0x49	; 73
    4e22:	89 8f       	std	Y+25, r24	; 0x19
    4e24:	ec ef       	ldi	r30, 0xFC	; 252
    4e26:	f6 e0       	ldi	r31, 0x06	; 6
    4e28:	de 01       	movw	r26, r28
    4e2a:	5a 96       	adiw	r26, 0x1a	; 26
    4e2c:	23 e0       	ldi	r18, 0x03	; 3
    4e2e:	37 e0       	ldi	r19, 0x07	; 7
    4e30:	04 c0       	rjmp	.+8      	; 0x4e3a <vTaskStartScheduler+0x50>
    4e32:	c8 01       	movw	r24, r16
    4e34:	0e 94 a7 09 	call	0x134e	; 0x134e <vPortFree>
    4e38:	b3 c0       	rjmp	.+358    	; 0x4fa0 <vTaskStartScheduler+0x1b6>
    4e3a:	91 91       	ld	r25, Z+
    4e3c:	9d 93       	st	X+, r25
    4e3e:	99 23       	and	r25, r25
    4e40:	19 f0       	breq	.+6      	; 0x4e48 <vTaskStartScheduler+0x5e>
    4e42:	e2 17       	cp	r30, r18
    4e44:	f3 07       	cpc	r31, r19
    4e46:	c9 f7       	brne	.-14     	; 0x4e3a <vTaskStartScheduler+0x50>
    4e48:	18 a2       	std	Y+32, r1	; 0x20
    4e4a:	1e 8a       	std	Y+22, r1	; 0x16
    4e4c:	19 a2       	std	Y+33, r1	; 0x21
    4e4e:	1a a2       	std	Y+34, r1	; 0x22
    4e50:	7e 01       	movw	r14, r28
    4e52:	82 e0       	ldi	r24, 0x02	; 2
    4e54:	e8 0e       	add	r14, r24
    4e56:	f1 1c       	adc	r15, r1
    4e58:	c7 01       	movw	r24, r14
    4e5a:	0e 94 ca 0c 	call	0x1994	; 0x1994 <vListInitialiseItem>
    4e5e:	ce 01       	movw	r24, r28
    4e60:	0c 96       	adiw	r24, 0x0c	; 12
    4e62:	0e 94 ca 0c 	call	0x1994	; 0x1994 <vListInitialiseItem>
    4e66:	d9 87       	std	Y+9, r29	; 0x09
    4e68:	c8 87       	std	Y+8, r28	; 0x08
    4e6a:	86 e0       	ldi	r24, 0x06	; 6
    4e6c:	90 e0       	ldi	r25, 0x00	; 0
    4e6e:	9d 87       	std	Y+13, r25	; 0x0d
    4e70:	8c 87       	std	Y+12, r24	; 0x0c
    4e72:	db 8b       	std	Y+19, r29	; 0x13
    4e74:	ca 8b       	std	Y+18, r28	; 0x12
    4e76:	1b a2       	std	Y+35, r1	; 0x23
    4e78:	1c a2       	std	Y+36, r1	; 0x24
    4e7a:	1d a2       	std	Y+37, r1	; 0x25
    4e7c:	1e a2       	std	Y+38, r1	; 0x26
    4e7e:	1f a2       	std	Y+39, r1	; 0x27
    4e80:	40 e0       	ldi	r20, 0x00	; 0
    4e82:	50 e0       	ldi	r21, 0x00	; 0
    4e84:	69 e1       	ldi	r22, 0x19	; 25
    4e86:	71 e0       	ldi	r23, 0x01	; 1
    4e88:	c8 01       	movw	r24, r16
    4e8a:	0e 94 b6 17 	call	0x2f6c	; 0x2f6c <pxPortInitialiseStack>
    4e8e:	99 83       	std	Y+1, r25	; 0x01
    4e90:	88 83       	st	Y, r24
    4e92:	0f b6       	in	r0, 0x3f	; 63
    4e94:	f8 94       	cli
    4e96:	0f 92       	push	r0
    4e98:	80 91 46 1a 	lds	r24, 0x1A46	; 0x801a46 <uxCurrentNumberOfTasks>
    4e9c:	8f 5f       	subi	r24, 0xFF	; 255
    4e9e:	80 93 46 1a 	sts	0x1A46, r24	; 0x801a46 <uxCurrentNumberOfTasks>
    4ea2:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4ea6:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4eaa:	89 2b       	or	r24, r25
    4eac:	a9 f5       	brne	.+106    	; 0x4f18 <vTaskStartScheduler+0x12e>
    4eae:	d0 93 a6 1a 	sts	0x1AA6, r29	; 0x801aa6 <pxCurrentTCB+0x1>
    4eb2:	c0 93 a5 1a 	sts	0x1AA5, r28	; 0x801aa5 <pxCurrentTCB>
    4eb6:	80 91 46 1a 	lds	r24, 0x1A46	; 0x801a46 <uxCurrentNumberOfTasks>
    4eba:	81 30       	cpi	r24, 0x01	; 1
    4ebc:	e1 f5       	brne	.+120    	; 0x4f36 <vTaskStartScheduler+0x14c>
    4ebe:	0f e6       	ldi	r16, 0x6F	; 111
    4ec0:	1a e1       	ldi	r17, 0x1A	; 26
    4ec2:	0f 2e       	mov	r0, r31
    4ec4:	f5 ea       	ldi	r31, 0xA5	; 165
    4ec6:	cf 2e       	mov	r12, r31
    4ec8:	fa e1       	ldi	r31, 0x1A	; 26
    4eca:	df 2e       	mov	r13, r31
    4ecc:	f0 2d       	mov	r31, r0
    4ece:	c8 01       	movw	r24, r16
    4ed0:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    4ed4:	07 5f       	subi	r16, 0xF7	; 247
    4ed6:	1f 4f       	sbci	r17, 0xFF	; 255
    4ed8:	0c 15       	cp	r16, r12
    4eda:	1d 05       	cpc	r17, r13
    4edc:	c1 f7       	brne	.-16     	; 0x4ece <vTaskStartScheduler+0xe4>
    4ede:	86 e6       	ldi	r24, 0x66	; 102
    4ee0:	9a e1       	ldi	r25, 0x1A	; 26
    4ee2:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    4ee6:	8d e5       	ldi	r24, 0x5D	; 93
    4ee8:	9a e1       	ldi	r25, 0x1A	; 26
    4eea:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    4eee:	80 e5       	ldi	r24, 0x50	; 80
    4ef0:	9a e1       	ldi	r25, 0x1A	; 26
    4ef2:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    4ef6:	87 e4       	ldi	r24, 0x47	; 71
    4ef8:	9a e1       	ldi	r25, 0x1A	; 26
    4efa:	0e 94 bc 0c 	call	0x1978	; 0x1978 <vListInitialise>
    4efe:	86 e6       	ldi	r24, 0x66	; 102
    4f00:	9a e1       	ldi	r25, 0x1A	; 26
    4f02:	90 93 5c 1a 	sts	0x1A5C, r25	; 0x801a5c <pxDelayedTaskList+0x1>
    4f06:	80 93 5b 1a 	sts	0x1A5B, r24	; 0x801a5b <pxDelayedTaskList>
    4f0a:	8d e5       	ldi	r24, 0x5D	; 93
    4f0c:	9a e1       	ldi	r25, 0x1A	; 26
    4f0e:	90 93 5a 1a 	sts	0x1A5A, r25	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    4f12:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <pxOverflowDelayedTaskList>
    4f16:	0f c0       	rjmp	.+30     	; 0x4f36 <vTaskStartScheduler+0x14c>
    4f18:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xSchedulerRunning>
    4f1c:	81 11       	cpse	r24, r1
    4f1e:	0b c0       	rjmp	.+22     	; 0x4f36 <vTaskStartScheduler+0x14c>
    4f20:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4f24:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4f28:	86 89       	ldd	r24, Z+22	; 0x16
    4f2a:	81 11       	cpse	r24, r1
    4f2c:	04 c0       	rjmp	.+8      	; 0x4f36 <vTaskStartScheduler+0x14c>
    4f2e:	d0 93 a6 1a 	sts	0x1AA6, r29	; 0x801aa6 <pxCurrentTCB+0x1>
    4f32:	c0 93 a5 1a 	sts	0x1AA5, r28	; 0x801aa5 <pxCurrentTCB>
    4f36:	80 91 3e 1a 	lds	r24, 0x1A3E	; 0x801a3e <uxTaskNumber>
    4f3a:	8f 5f       	subi	r24, 0xFF	; 255
    4f3c:	80 93 3e 1a 	sts	0x1A3E, r24	; 0x801a3e <uxTaskNumber>
    4f40:	2e 89       	ldd	r18, Y+22	; 0x16
    4f42:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    4f46:	82 17       	cp	r24, r18
    4f48:	10 f4       	brcc	.+4      	; 0x4f4e <vTaskStartScheduler+0x164>
    4f4a:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    4f4e:	30 e0       	ldi	r19, 0x00	; 0
    4f50:	c9 01       	movw	r24, r18
    4f52:	88 0f       	add	r24, r24
    4f54:	99 1f       	adc	r25, r25
    4f56:	88 0f       	add	r24, r24
    4f58:	99 1f       	adc	r25, r25
    4f5a:	88 0f       	add	r24, r24
    4f5c:	99 1f       	adc	r25, r25
    4f5e:	82 0f       	add	r24, r18
    4f60:	93 1f       	adc	r25, r19
    4f62:	b7 01       	movw	r22, r14
    4f64:	81 59       	subi	r24, 0x91	; 145
    4f66:	95 4e       	sbci	r25, 0xE5	; 229
    4f68:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    4f6c:	0f 90       	pop	r0
    4f6e:	0f be       	out	0x3f, r0	; 63
    4f70:	80 91 42 1a 	lds	r24, 0x1A42	; 0x801a42 <xSchedulerRunning>
    4f74:	88 23       	and	r24, r24
    4f76:	21 f0       	breq	.+8      	; 0x4f80 <vTaskStartScheduler+0x196>
    4f78:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    4f7c:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    4f80:	f8 94       	cli
    4f82:	8f ef       	ldi	r24, 0xFF	; 255
    4f84:	9f ef       	ldi	r25, 0xFF	; 255
    4f86:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    4f8a:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    4f8e:	81 e0       	ldi	r24, 0x01	; 1
    4f90:	80 93 42 1a 	sts	0x1A42, r24	; 0x801a42 <xSchedulerRunning>
    4f94:	10 92 45 1a 	sts	0x1A45, r1	; 0x801a45 <xTickCount+0x1>
    4f98:	10 92 44 1a 	sts	0x1A44, r1	; 0x801a44 <xTickCount>
    4f9c:	0e 94 28 18 	call	0x3050	; 0x3050 <xPortStartScheduler>
    4fa0:	df 91       	pop	r29
    4fa2:	cf 91       	pop	r28
    4fa4:	1f 91       	pop	r17
    4fa6:	0f 91       	pop	r16
    4fa8:	ff 90       	pop	r15
    4faa:	ef 90       	pop	r14
    4fac:	df 90       	pop	r13
    4fae:	cf 90       	pop	r12
    4fb0:	08 95       	ret

00004fb2 <vTaskSuspendAll>:
    4fb2:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4fb6:	8f 5f       	subi	r24, 0xFF	; 255
    4fb8:	80 93 3b 1a 	sts	0x1A3B, r24	; 0x801a3b <uxSchedulerSuspended>
    4fbc:	08 95       	ret

00004fbe <xTaskResumeAll>:
    4fbe:	9f 92       	push	r9
    4fc0:	af 92       	push	r10
    4fc2:	bf 92       	push	r11
    4fc4:	cf 92       	push	r12
    4fc6:	df 92       	push	r13
    4fc8:	ef 92       	push	r14
    4fca:	ff 92       	push	r15
    4fcc:	0f 93       	push	r16
    4fce:	1f 93       	push	r17
    4fd0:	cf 93       	push	r28
    4fd2:	df 93       	push	r29
    4fd4:	0f b6       	in	r0, 0x3f	; 63
    4fd6:	f8 94       	cli
    4fd8:	0f 92       	push	r0
    4fda:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4fde:	81 50       	subi	r24, 0x01	; 1
    4fe0:	80 93 3b 1a 	sts	0x1A3B, r24	; 0x801a3b <uxSchedulerSuspended>
    4fe4:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    4fe8:	81 11       	cpse	r24, r1
    4fea:	0d c1       	rjmp	.+538    	; 0x5206 <xTaskResumeAll+0x248>
    4fec:	80 91 46 1a 	lds	r24, 0x1A46	; 0x801a46 <uxCurrentNumberOfTasks>
    4ff0:	81 11       	cpse	r24, r1
    4ff2:	33 c0       	rjmp	.+102    	; 0x505a <xTaskResumeAll+0x9c>
    4ff4:	0b c1       	rjmp	.+534    	; 0x520c <xTaskResumeAll+0x24e>
    4ff6:	d7 01       	movw	r26, r14
    4ff8:	15 96       	adiw	r26, 0x05	; 5
    4ffa:	ed 91       	ld	r30, X+
    4ffc:	fc 91       	ld	r31, X
    4ffe:	16 97       	sbiw	r26, 0x06	; 6
    5000:	c6 81       	ldd	r28, Z+6	; 0x06
    5002:	d7 81       	ldd	r29, Z+7	; 0x07
    5004:	ce 01       	movw	r24, r28
    5006:	0c 96       	adiw	r24, 0x0c	; 12
    5008:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    500c:	8e 01       	movw	r16, r28
    500e:	0e 5f       	subi	r16, 0xFE	; 254
    5010:	1f 4f       	sbci	r17, 0xFF	; 255
    5012:	c8 01       	movw	r24, r16
    5014:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    5018:	2e 89       	ldd	r18, Y+22	; 0x16
    501a:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    501e:	82 17       	cp	r24, r18
    5020:	10 f4       	brcc	.+4      	; 0x5026 <xTaskResumeAll+0x68>
    5022:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    5026:	30 e0       	ldi	r19, 0x00	; 0
    5028:	c9 01       	movw	r24, r18
    502a:	88 0f       	add	r24, r24
    502c:	99 1f       	adc	r25, r25
    502e:	88 0f       	add	r24, r24
    5030:	99 1f       	adc	r25, r25
    5032:	88 0f       	add	r24, r24
    5034:	99 1f       	adc	r25, r25
    5036:	82 0f       	add	r24, r18
    5038:	93 1f       	adc	r25, r19
    503a:	b8 01       	movw	r22, r16
    503c:	81 59       	subi	r24, 0x91	; 145
    503e:	95 4e       	sbci	r25, 0xE5	; 229
    5040:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    5044:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5048:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    504c:	9e 89       	ldd	r25, Y+22	; 0x16
    504e:	86 89       	ldd	r24, Z+22	; 0x16
    5050:	98 17       	cp	r25, r24
    5052:	58 f0       	brcs	.+22     	; 0x506a <xTaskResumeAll+0xac>
    5054:	d0 92 40 1a 	sts	0x1A40, r13	; 0x801a40 <xYieldPending>
    5058:	08 c0       	rjmp	.+16     	; 0x506a <xTaskResumeAll+0xac>
    505a:	0f 2e       	mov	r0, r31
    505c:	f0 e5       	ldi	r31, 0x50	; 80
    505e:	ef 2e       	mov	r14, r31
    5060:	fa e1       	ldi	r31, 0x1A	; 26
    5062:	ff 2e       	mov	r15, r31
    5064:	f0 2d       	mov	r31, r0
    5066:	dd 24       	eor	r13, r13
    5068:	d3 94       	inc	r13
    506a:	f7 01       	movw	r30, r14
    506c:	80 81       	ld	r24, Z
    506e:	81 11       	cpse	r24, r1
    5070:	c2 cf       	rjmp	.-124    	; 0x4ff6 <xTaskResumeAll+0x38>
    5072:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    5076:	88 23       	and	r24, r24
    5078:	09 f4       	brne	.+2      	; 0x507c <xTaskResumeAll+0xbe>
    507a:	bd c0       	rjmp	.+378    	; 0x51f6 <xTaskResumeAll+0x238>
    507c:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    5080:	88 23       	and	r24, r24
    5082:	09 f4       	brne	.+2      	; 0x5086 <xTaskResumeAll+0xc8>
    5084:	b8 c0       	rjmp	.+368    	; 0x51f6 <xTaskResumeAll+0x238>
    5086:	91 2c       	mov	r9, r1
    5088:	aa 24       	eor	r10, r10
    508a:	a3 94       	inc	r10
    508c:	cc 24       	eor	r12, r12
    508e:	ca 94       	dec	r12
    5090:	dc 2c       	mov	r13, r12
    5092:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    5096:	81 11       	cpse	r24, r1
    5098:	98 c0       	rjmp	.+304    	; 0x51ca <xTaskResumeAll+0x20c>
    509a:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    509e:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    50a2:	01 96       	adiw	r24, 0x01	; 1
    50a4:	90 93 45 1a 	sts	0x1A45, r25	; 0x801a45 <xTickCount+0x1>
    50a8:	80 93 44 1a 	sts	0x1A44, r24	; 0x801a44 <xTickCount>
    50ac:	e0 90 44 1a 	lds	r14, 0x1A44	; 0x801a44 <xTickCount>
    50b0:	f0 90 45 1a 	lds	r15, 0x1A45	; 0x801a45 <xTickCount+0x1>
    50b4:	e1 14       	cp	r14, r1
    50b6:	f1 04       	cpc	r15, r1
    50b8:	89 f5       	brne	.+98     	; 0x511c <xTaskResumeAll+0x15e>
    50ba:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    50be:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    50c2:	20 91 59 1a 	lds	r18, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    50c6:	30 91 5a 1a 	lds	r19, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    50ca:	30 93 5c 1a 	sts	0x1A5C, r19	; 0x801a5c <pxDelayedTaskList+0x1>
    50ce:	20 93 5b 1a 	sts	0x1A5B, r18	; 0x801a5b <pxDelayedTaskList>
    50d2:	90 93 5a 1a 	sts	0x1A5A, r25	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    50d6:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <pxOverflowDelayedTaskList>
    50da:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <xNumOfOverflows>
    50de:	8f 5f       	subi	r24, 0xFF	; 255
    50e0:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <xNumOfOverflows>
    50e4:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    50e8:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    50ec:	80 81       	ld	r24, Z
    50ee:	81 11       	cpse	r24, r1
    50f0:	05 c0       	rjmp	.+10     	; 0x50fc <xTaskResumeAll+0x13e>
    50f2:	d0 92 3d 1a 	sts	0x1A3D, r13	; 0x801a3d <xNextTaskUnblockTime+0x1>
    50f6:	c0 92 3c 1a 	sts	0x1A3C, r12	; 0x801a3c <xNextTaskUnblockTime>
    50fa:	10 c0       	rjmp	.+32     	; 0x511c <xTaskResumeAll+0x15e>
    50fc:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    5100:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    5104:	05 80       	ldd	r0, Z+5	; 0x05
    5106:	f6 81       	ldd	r31, Z+6	; 0x06
    5108:	e0 2d       	mov	r30, r0
    510a:	06 80       	ldd	r0, Z+6	; 0x06
    510c:	f7 81       	ldd	r31, Z+7	; 0x07
    510e:	e0 2d       	mov	r30, r0
    5110:	82 81       	ldd	r24, Z+2	; 0x02
    5112:	93 81       	ldd	r25, Z+3	; 0x03
    5114:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    5118:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    511c:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    5120:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    5124:	e8 16       	cp	r14, r24
    5126:	f9 06       	cpc	r15, r25
    5128:	08 f4       	brcc	.+2      	; 0x512c <xTaskResumeAll+0x16e>
    512a:	73 c0       	rjmp	.+230    	; 0x5212 <xTaskResumeAll+0x254>
    512c:	b9 2c       	mov	r11, r9
    512e:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    5132:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    5136:	80 81       	ld	r24, Z
    5138:	81 11       	cpse	r24, r1
    513a:	05 c0       	rjmp	.+10     	; 0x5146 <xTaskResumeAll+0x188>
    513c:	d0 92 3d 1a 	sts	0x1A3D, r13	; 0x801a3d <xNextTaskUnblockTime+0x1>
    5140:	c0 92 3c 1a 	sts	0x1A3C, r12	; 0x801a3c <xNextTaskUnblockTime>
    5144:	48 c0       	rjmp	.+144    	; 0x51d6 <xTaskResumeAll+0x218>
    5146:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    514a:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    514e:	05 80       	ldd	r0, Z+5	; 0x05
    5150:	f6 81       	ldd	r31, Z+6	; 0x06
    5152:	e0 2d       	mov	r30, r0
    5154:	c6 81       	ldd	r28, Z+6	; 0x06
    5156:	d7 81       	ldd	r29, Z+7	; 0x07
    5158:	8a 81       	ldd	r24, Y+2	; 0x02
    515a:	9b 81       	ldd	r25, Y+3	; 0x03
    515c:	e8 16       	cp	r14, r24
    515e:	f9 06       	cpc	r15, r25
    5160:	28 f4       	brcc	.+10     	; 0x516c <xTaskResumeAll+0x1ae>
    5162:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    5166:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    516a:	35 c0       	rjmp	.+106    	; 0x51d6 <xTaskResumeAll+0x218>
    516c:	8e 01       	movw	r16, r28
    516e:	0e 5f       	subi	r16, 0xFE	; 254
    5170:	1f 4f       	sbci	r17, 0xFF	; 255
    5172:	c8 01       	movw	r24, r16
    5174:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    5178:	8c 89       	ldd	r24, Y+20	; 0x14
    517a:	9d 89       	ldd	r25, Y+21	; 0x15
    517c:	89 2b       	or	r24, r25
    517e:	21 f0       	breq	.+8      	; 0x5188 <xTaskResumeAll+0x1ca>
    5180:	ce 01       	movw	r24, r28
    5182:	0c 96       	adiw	r24, 0x0c	; 12
    5184:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    5188:	2e 89       	ldd	r18, Y+22	; 0x16
    518a:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    518e:	82 17       	cp	r24, r18
    5190:	10 f4       	brcc	.+4      	; 0x5196 <xTaskResumeAll+0x1d8>
    5192:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    5196:	30 e0       	ldi	r19, 0x00	; 0
    5198:	c9 01       	movw	r24, r18
    519a:	88 0f       	add	r24, r24
    519c:	99 1f       	adc	r25, r25
    519e:	88 0f       	add	r24, r24
    51a0:	99 1f       	adc	r25, r25
    51a2:	88 0f       	add	r24, r24
    51a4:	99 1f       	adc	r25, r25
    51a6:	82 0f       	add	r24, r18
    51a8:	93 1f       	adc	r25, r19
    51aa:	b8 01       	movw	r22, r16
    51ac:	81 59       	subi	r24, 0x91	; 145
    51ae:	95 4e       	sbci	r25, 0xE5	; 229
    51b0:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    51b4:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    51b8:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    51bc:	9e 89       	ldd	r25, Y+22	; 0x16
    51be:	86 89       	ldd	r24, Z+22	; 0x16
    51c0:	98 17       	cp	r25, r24
    51c2:	08 f4       	brcc	.+2      	; 0x51c6 <xTaskResumeAll+0x208>
    51c4:	b4 cf       	rjmp	.-152    	; 0x512e <xTaskResumeAll+0x170>
    51c6:	ba 2c       	mov	r11, r10
    51c8:	b2 cf       	rjmp	.-156    	; 0x512e <xTaskResumeAll+0x170>
    51ca:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    51ce:	8f 5f       	subi	r24, 0xFF	; 255
    51d0:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxPendedTicks>
    51d4:	1e c0       	rjmp	.+60     	; 0x5212 <xTaskResumeAll+0x254>
    51d6:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    51da:	81 11       	cpse	r24, r1
    51dc:	01 c0       	rjmp	.+2      	; 0x51e0 <xTaskResumeAll+0x222>
    51de:	b1 10       	cpse	r11, r1
    51e0:	a0 92 40 1a 	sts	0x1A40, r10	; 0x801a40 <xYieldPending>
    51e4:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    51e8:	81 50       	subi	r24, 0x01	; 1
    51ea:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxPendedTicks>
    51ee:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    51f2:	81 11       	cpse	r24, r1
    51f4:	4e cf       	rjmp	.-356    	; 0x5092 <xTaskResumeAll+0xd4>
    51f6:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    51fa:	81 30       	cpi	r24, 0x01	; 1
    51fc:	31 f4       	brne	.+12     	; 0x520a <xTaskResumeAll+0x24c>
    51fe:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    5202:	81 e0       	ldi	r24, 0x01	; 1
    5204:	03 c0       	rjmp	.+6      	; 0x520c <xTaskResumeAll+0x24e>
    5206:	80 e0       	ldi	r24, 0x00	; 0
    5208:	01 c0       	rjmp	.+2      	; 0x520c <xTaskResumeAll+0x24e>
    520a:	80 e0       	ldi	r24, 0x00	; 0
    520c:	0f 90       	pop	r0
    520e:	0f be       	out	0x3f, r0	; 63
    5210:	05 c0       	rjmp	.+10     	; 0x521c <xTaskResumeAll+0x25e>
    5212:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    5216:	88 23       	and	r24, r24
    5218:	29 f3       	breq	.-54     	; 0x51e4 <xTaskResumeAll+0x226>
    521a:	e2 cf       	rjmp	.-60     	; 0x51e0 <xTaskResumeAll+0x222>
    521c:	df 91       	pop	r29
    521e:	cf 91       	pop	r28
    5220:	1f 91       	pop	r17
    5222:	0f 91       	pop	r16
    5224:	ff 90       	pop	r15
    5226:	ef 90       	pop	r14
    5228:	df 90       	pop	r13
    522a:	cf 90       	pop	r12
    522c:	bf 90       	pop	r11
    522e:	af 90       	pop	r10
    5230:	9f 90       	pop	r9
    5232:	08 95       	ret

00005234 <xTaskGetTickCount>:
    5234:	0f b6       	in	r0, 0x3f	; 63
    5236:	f8 94       	cli
    5238:	0f 92       	push	r0
    523a:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    523e:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    5242:	0f 90       	pop	r0
    5244:	0f be       	out	0x3f, r0	; 63
    5246:	08 95       	ret

00005248 <xTaskIncrementTick>:
    5248:	cf 92       	push	r12
    524a:	df 92       	push	r13
    524c:	ef 92       	push	r14
    524e:	ff 92       	push	r15
    5250:	0f 93       	push	r16
    5252:	1f 93       	push	r17
    5254:	cf 93       	push	r28
    5256:	df 93       	push	r29
    5258:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    525c:	81 11       	cpse	r24, r1
    525e:	9f c0       	rjmp	.+318    	; 0x539e <xTaskIncrementTick+0x156>
    5260:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    5264:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    5268:	01 96       	adiw	r24, 0x01	; 1
    526a:	90 93 45 1a 	sts	0x1A45, r25	; 0x801a45 <xTickCount+0x1>
    526e:	80 93 44 1a 	sts	0x1A44, r24	; 0x801a44 <xTickCount>
    5272:	e0 90 44 1a 	lds	r14, 0x1A44	; 0x801a44 <xTickCount>
    5276:	f0 90 45 1a 	lds	r15, 0x1A45	; 0x801a45 <xTickCount+0x1>
    527a:	e1 14       	cp	r14, r1
    527c:	f1 04       	cpc	r15, r1
    527e:	99 f5       	brne	.+102    	; 0x52e6 <xTaskIncrementTick+0x9e>
    5280:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    5284:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    5288:	20 91 59 1a 	lds	r18, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    528c:	30 91 5a 1a 	lds	r19, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    5290:	30 93 5c 1a 	sts	0x1A5C, r19	; 0x801a5c <pxDelayedTaskList+0x1>
    5294:	20 93 5b 1a 	sts	0x1A5B, r18	; 0x801a5b <pxDelayedTaskList>
    5298:	90 93 5a 1a 	sts	0x1A5A, r25	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    529c:	80 93 59 1a 	sts	0x1A59, r24	; 0x801a59 <pxOverflowDelayedTaskList>
    52a0:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <xNumOfOverflows>
    52a4:	8f 5f       	subi	r24, 0xFF	; 255
    52a6:	80 93 3f 1a 	sts	0x1A3F, r24	; 0x801a3f <xNumOfOverflows>
    52aa:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    52ae:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    52b2:	80 81       	ld	r24, Z
    52b4:	81 11       	cpse	r24, r1
    52b6:	07 c0       	rjmp	.+14     	; 0x52c6 <xTaskIncrementTick+0x7e>
    52b8:	8f ef       	ldi	r24, 0xFF	; 255
    52ba:	9f ef       	ldi	r25, 0xFF	; 255
    52bc:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    52c0:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    52c4:	10 c0       	rjmp	.+32     	; 0x52e6 <xTaskIncrementTick+0x9e>
    52c6:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    52ca:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    52ce:	05 80       	ldd	r0, Z+5	; 0x05
    52d0:	f6 81       	ldd	r31, Z+6	; 0x06
    52d2:	e0 2d       	mov	r30, r0
    52d4:	06 80       	ldd	r0, Z+6	; 0x06
    52d6:	f7 81       	ldd	r31, Z+7	; 0x07
    52d8:	e0 2d       	mov	r30, r0
    52da:	82 81       	ldd	r24, Z+2	; 0x02
    52dc:	93 81       	ldd	r25, Z+3	; 0x03
    52de:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    52e2:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    52e6:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    52ea:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    52ee:	e8 16       	cp	r14, r24
    52f0:	f9 06       	cpc	r15, r25
    52f2:	10 f4       	brcc	.+4      	; 0x52f8 <xTaskIncrementTick+0xb0>
    52f4:	d1 2c       	mov	r13, r1
    52f6:	59 c0       	rjmp	.+178    	; 0x53aa <xTaskIncrementTick+0x162>
    52f8:	d1 2c       	mov	r13, r1
    52fa:	cc 24       	eor	r12, r12
    52fc:	c3 94       	inc	r12
    52fe:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    5302:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    5306:	90 81       	ld	r25, Z
    5308:	91 11       	cpse	r25, r1
    530a:	07 c0       	rjmp	.+14     	; 0x531a <xTaskIncrementTick+0xd2>
    530c:	8f ef       	ldi	r24, 0xFF	; 255
    530e:	9f ef       	ldi	r25, 0xFF	; 255
    5310:	90 93 3d 1a 	sts	0x1A3D, r25	; 0x801a3d <xNextTaskUnblockTime+0x1>
    5314:	80 93 3c 1a 	sts	0x1A3C, r24	; 0x801a3c <xNextTaskUnblockTime>
    5318:	48 c0       	rjmp	.+144    	; 0x53aa <xTaskIncrementTick+0x162>
    531a:	e0 91 5b 1a 	lds	r30, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    531e:	f0 91 5c 1a 	lds	r31, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    5322:	05 80       	ldd	r0, Z+5	; 0x05
    5324:	f6 81       	ldd	r31, Z+6	; 0x06
    5326:	e0 2d       	mov	r30, r0
    5328:	c6 81       	ldd	r28, Z+6	; 0x06
    532a:	d7 81       	ldd	r29, Z+7	; 0x07
    532c:	2a 81       	ldd	r18, Y+2	; 0x02
    532e:	3b 81       	ldd	r19, Y+3	; 0x03
    5330:	e2 16       	cp	r14, r18
    5332:	f3 06       	cpc	r15, r19
    5334:	28 f4       	brcc	.+10     	; 0x5340 <xTaskIncrementTick+0xf8>
    5336:	30 93 3d 1a 	sts	0x1A3D, r19	; 0x801a3d <xNextTaskUnblockTime+0x1>
    533a:	20 93 3c 1a 	sts	0x1A3C, r18	; 0x801a3c <xNextTaskUnblockTime>
    533e:	35 c0       	rjmp	.+106    	; 0x53aa <xTaskIncrementTick+0x162>
    5340:	8e 01       	movw	r16, r28
    5342:	0e 5f       	subi	r16, 0xFE	; 254
    5344:	1f 4f       	sbci	r17, 0xFF	; 255
    5346:	c8 01       	movw	r24, r16
    5348:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    534c:	8c 89       	ldd	r24, Y+20	; 0x14
    534e:	9d 89       	ldd	r25, Y+21	; 0x15
    5350:	89 2b       	or	r24, r25
    5352:	21 f0       	breq	.+8      	; 0x535c <xTaskIncrementTick+0x114>
    5354:	ce 01       	movw	r24, r28
    5356:	0c 96       	adiw	r24, 0x0c	; 12
    5358:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    535c:	2e 89       	ldd	r18, Y+22	; 0x16
    535e:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    5362:	82 17       	cp	r24, r18
    5364:	10 f4       	brcc	.+4      	; 0x536a <xTaskIncrementTick+0x122>
    5366:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    536a:	30 e0       	ldi	r19, 0x00	; 0
    536c:	c9 01       	movw	r24, r18
    536e:	88 0f       	add	r24, r24
    5370:	99 1f       	adc	r25, r25
    5372:	88 0f       	add	r24, r24
    5374:	99 1f       	adc	r25, r25
    5376:	88 0f       	add	r24, r24
    5378:	99 1f       	adc	r25, r25
    537a:	82 0f       	add	r24, r18
    537c:	93 1f       	adc	r25, r19
    537e:	b8 01       	movw	r22, r16
    5380:	81 59       	subi	r24, 0x91	; 145
    5382:	95 4e       	sbci	r25, 0xE5	; 229
    5384:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    5388:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    538c:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5390:	9e 89       	ldd	r25, Y+22	; 0x16
    5392:	86 89       	ldd	r24, Z+22	; 0x16
    5394:	98 17       	cp	r25, r24
    5396:	08 f4       	brcc	.+2      	; 0x539a <xTaskIncrementTick+0x152>
    5398:	b2 cf       	rjmp	.-156    	; 0x52fe <xTaskIncrementTick+0xb6>
    539a:	dc 2c       	mov	r13, r12
    539c:	b0 cf       	rjmp	.-160    	; 0x52fe <xTaskIncrementTick+0xb6>
    539e:	80 91 41 1a 	lds	r24, 0x1A41	; 0x801a41 <uxPendedTicks>
    53a2:	8f 5f       	subi	r24, 0xFF	; 255
    53a4:	80 93 41 1a 	sts	0x1A41, r24	; 0x801a41 <uxPendedTicks>
    53a8:	d1 2c       	mov	r13, r1
    53aa:	80 91 40 1a 	lds	r24, 0x1A40	; 0x801a40 <xYieldPending>
    53ae:	88 23       	and	r24, r24
    53b0:	11 f0       	breq	.+4      	; 0x53b6 <xTaskIncrementTick+0x16e>
    53b2:	dd 24       	eor	r13, r13
    53b4:	d3 94       	inc	r13
    53b6:	8d 2d       	mov	r24, r13
    53b8:	df 91       	pop	r29
    53ba:	cf 91       	pop	r28
    53bc:	1f 91       	pop	r17
    53be:	0f 91       	pop	r16
    53c0:	ff 90       	pop	r15
    53c2:	ef 90       	pop	r14
    53c4:	df 90       	pop	r13
    53c6:	cf 90       	pop	r12
    53c8:	08 95       	ret

000053ca <vTaskSwitchContext>:
    53ca:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    53ce:	88 23       	and	r24, r24
    53d0:	21 f0       	breq	.+8      	; 0x53da <vTaskSwitchContext+0x10>
    53d2:	81 e0       	ldi	r24, 0x01	; 1
    53d4:	80 93 40 1a 	sts	0x1A40, r24	; 0x801a40 <xYieldPending>
    53d8:	08 95       	ret
    53da:	10 92 40 1a 	sts	0x1A40, r1	; 0x801a40 <xYieldPending>
    53de:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    53e2:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    53e6:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    53ea:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    53ee:	2d 91       	ld	r18, X+
    53f0:	3c 91       	ld	r19, X
    53f2:	87 89       	ldd	r24, Z+23	; 0x17
    53f4:	90 8d       	ldd	r25, Z+24	; 0x18
    53f6:	82 17       	cp	r24, r18
    53f8:	93 07       	cpc	r25, r19
    53fa:	60 f0       	brcs	.+24     	; 0x5414 <vTaskSwitchContext+0x4a>
    53fc:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5400:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5404:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5408:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    540c:	67 5e       	subi	r22, 0xE7	; 231
    540e:	7f 4f       	sbci	r23, 0xFF	; 255
    5410:	0e 94 02 15 	call	0x2a04	; 0x2a04 <vApplicationStackOverflowHook>
    5414:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    5418:	90 e0       	ldi	r25, 0x00	; 0
    541a:	fc 01       	movw	r30, r24
    541c:	ee 0f       	add	r30, r30
    541e:	ff 1f       	adc	r31, r31
    5420:	ee 0f       	add	r30, r30
    5422:	ff 1f       	adc	r31, r31
    5424:	ee 0f       	add	r30, r30
    5426:	ff 1f       	adc	r31, r31
    5428:	8e 0f       	add	r24, r30
    542a:	9f 1f       	adc	r25, r31
    542c:	fc 01       	movw	r30, r24
    542e:	e1 59       	subi	r30, 0x91	; 145
    5430:	f5 4e       	sbci	r31, 0xE5	; 229
    5432:	80 81       	ld	r24, Z
    5434:	81 11       	cpse	r24, r1
    5436:	17 c0       	rjmp	.+46     	; 0x5466 <vTaskSwitchContext+0x9c>
    5438:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    543c:	81 50       	subi	r24, 0x01	; 1
    543e:	80 93 43 1a 	sts	0x1A43, r24	; 0x801a43 <uxTopReadyPriority>
    5442:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    5446:	90 e0       	ldi	r25, 0x00	; 0
    5448:	fc 01       	movw	r30, r24
    544a:	ee 0f       	add	r30, r30
    544c:	ff 1f       	adc	r31, r31
    544e:	ee 0f       	add	r30, r30
    5450:	ff 1f       	adc	r31, r31
    5452:	ee 0f       	add	r30, r30
    5454:	ff 1f       	adc	r31, r31
    5456:	8e 0f       	add	r24, r30
    5458:	9f 1f       	adc	r25, r31
    545a:	fc 01       	movw	r30, r24
    545c:	e1 59       	subi	r30, 0x91	; 145
    545e:	f5 4e       	sbci	r31, 0xE5	; 229
    5460:	80 81       	ld	r24, Z
    5462:	88 23       	and	r24, r24
    5464:	49 f3       	breq	.-46     	; 0x5438 <vTaskSwitchContext+0x6e>
    5466:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    546a:	90 e0       	ldi	r25, 0x00	; 0
    546c:	9c 01       	movw	r18, r24
    546e:	22 0f       	add	r18, r18
    5470:	33 1f       	adc	r19, r19
    5472:	22 0f       	add	r18, r18
    5474:	33 1f       	adc	r19, r19
    5476:	22 0f       	add	r18, r18
    5478:	33 1f       	adc	r19, r19
    547a:	28 0f       	add	r18, r24
    547c:	39 1f       	adc	r19, r25
    547e:	d9 01       	movw	r26, r18
    5480:	a1 59       	subi	r26, 0x91	; 145
    5482:	b5 4e       	sbci	r27, 0xE5	; 229
    5484:	11 96       	adiw	r26, 0x01	; 1
    5486:	ed 91       	ld	r30, X+
    5488:	fc 91       	ld	r31, X
    548a:	12 97       	sbiw	r26, 0x02	; 2
    548c:	02 80       	ldd	r0, Z+2	; 0x02
    548e:	f3 81       	ldd	r31, Z+3	; 0x03
    5490:	e0 2d       	mov	r30, r0
    5492:	12 96       	adiw	r26, 0x02	; 2
    5494:	fc 93       	st	X, r31
    5496:	ee 93       	st	-X, r30
    5498:	11 97       	sbiw	r26, 0x01	; 1
    549a:	2e 58       	subi	r18, 0x8E	; 142
    549c:	35 4e       	sbci	r19, 0xE5	; 229
    549e:	e2 17       	cp	r30, r18
    54a0:	f3 07       	cpc	r31, r19
    54a2:	29 f4       	brne	.+10     	; 0x54ae <vTaskSwitchContext+0xe4>
    54a4:	22 81       	ldd	r18, Z+2	; 0x02
    54a6:	33 81       	ldd	r19, Z+3	; 0x03
    54a8:	fd 01       	movw	r30, r26
    54aa:	32 83       	std	Z+2, r19	; 0x02
    54ac:	21 83       	std	Z+1, r18	; 0x01
    54ae:	fc 01       	movw	r30, r24
    54b0:	ee 0f       	add	r30, r30
    54b2:	ff 1f       	adc	r31, r31
    54b4:	ee 0f       	add	r30, r30
    54b6:	ff 1f       	adc	r31, r31
    54b8:	ee 0f       	add	r30, r30
    54ba:	ff 1f       	adc	r31, r31
    54bc:	8e 0f       	add	r24, r30
    54be:	9f 1f       	adc	r25, r31
    54c0:	fc 01       	movw	r30, r24
    54c2:	e1 59       	subi	r30, 0x91	; 145
    54c4:	f5 4e       	sbci	r31, 0xE5	; 229
    54c6:	01 80       	ldd	r0, Z+1	; 0x01
    54c8:	f2 81       	ldd	r31, Z+2	; 0x02
    54ca:	e0 2d       	mov	r30, r0
    54cc:	86 81       	ldd	r24, Z+6	; 0x06
    54ce:	97 81       	ldd	r25, Z+7	; 0x07
    54d0:	90 93 a6 1a 	sts	0x1AA6, r25	; 0x801aa6 <pxCurrentTCB+0x1>
    54d4:	80 93 a5 1a 	sts	0x1AA5, r24	; 0x801aa5 <pxCurrentTCB>
    54d8:	08 95       	ret

000054da <vTaskPlaceOnEventList>:
    54da:	cf 93       	push	r28
    54dc:	df 93       	push	r29
    54de:	eb 01       	movw	r28, r22
    54e0:	20 91 a5 1a 	lds	r18, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    54e4:	30 91 a6 1a 	lds	r19, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    54e8:	b9 01       	movw	r22, r18
    54ea:	64 5f       	subi	r22, 0xF4	; 244
    54ec:	7f 4f       	sbci	r23, 0xFF	; 255
    54ee:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    54f2:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    54f6:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    54fa:	02 96       	adiw	r24, 0x02	; 2
    54fc:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    5500:	cf 3f       	cpi	r28, 0xFF	; 255
    5502:	8f ef       	ldi	r24, 0xFF	; 255
    5504:	d8 07       	cpc	r29, r24
    5506:	59 f4       	brne	.+22     	; 0x551e <vTaskPlaceOnEventList+0x44>
    5508:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    550c:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5510:	6e 5f       	subi	r22, 0xFE	; 254
    5512:	7f 4f       	sbci	r23, 0xFF	; 255
    5514:	87 e4       	ldi	r24, 0x47	; 71
    5516:	9a e1       	ldi	r25, 0x1A	; 26
    5518:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    551c:	37 c0       	rjmp	.+110    	; 0x558c <vTaskPlaceOnEventList+0xb2>
    551e:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    5522:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    5526:	c8 0f       	add	r28, r24
    5528:	d9 1f       	adc	r29, r25
    552a:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    552e:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5532:	d3 83       	std	Z+3, r29	; 0x03
    5534:	c2 83       	std	Z+2, r28	; 0x02
    5536:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    553a:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    553e:	c8 17       	cp	r28, r24
    5540:	d9 07       	cpc	r29, r25
    5542:	68 f4       	brcc	.+26     	; 0x555e <vTaskPlaceOnEventList+0x84>
    5544:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5548:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    554c:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    5550:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    5554:	6e 5f       	subi	r22, 0xFE	; 254
    5556:	7f 4f       	sbci	r23, 0xFF	; 255
    5558:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    555c:	17 c0       	rjmp	.+46     	; 0x558c <vTaskPlaceOnEventList+0xb2>
    555e:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5562:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5566:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    556a:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    556e:	6e 5f       	subi	r22, 0xFE	; 254
    5570:	7f 4f       	sbci	r23, 0xFF	; 255
    5572:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    5576:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    557a:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    557e:	c8 17       	cp	r28, r24
    5580:	d9 07       	cpc	r29, r25
    5582:	20 f4       	brcc	.+8      	; 0x558c <vTaskPlaceOnEventList+0xb2>
    5584:	d0 93 3d 1a 	sts	0x1A3D, r29	; 0x801a3d <xNextTaskUnblockTime+0x1>
    5588:	c0 93 3c 1a 	sts	0x1A3C, r28	; 0x801a3c <xNextTaskUnblockTime>
    558c:	df 91       	pop	r29
    558e:	cf 91       	pop	r28
    5590:	08 95       	ret

00005592 <xTaskRemoveFromEventList>:
    5592:	0f 93       	push	r16
    5594:	1f 93       	push	r17
    5596:	cf 93       	push	r28
    5598:	df 93       	push	r29
    559a:	dc 01       	movw	r26, r24
    559c:	15 96       	adiw	r26, 0x05	; 5
    559e:	ed 91       	ld	r30, X+
    55a0:	fc 91       	ld	r31, X
    55a2:	16 97       	sbiw	r26, 0x06	; 6
    55a4:	c6 81       	ldd	r28, Z+6	; 0x06
    55a6:	d7 81       	ldd	r29, Z+7	; 0x07
    55a8:	8e 01       	movw	r16, r28
    55aa:	04 5f       	subi	r16, 0xF4	; 244
    55ac:	1f 4f       	sbci	r17, 0xFF	; 255
    55ae:	c8 01       	movw	r24, r16
    55b0:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    55b4:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    55b8:	81 11       	cpse	r24, r1
    55ba:	1c c0       	rjmp	.+56     	; 0x55f4 <xTaskRemoveFromEventList+0x62>
    55bc:	0a 50       	subi	r16, 0x0A	; 10
    55be:	11 09       	sbc	r17, r1
    55c0:	c8 01       	movw	r24, r16
    55c2:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    55c6:	2e 89       	ldd	r18, Y+22	; 0x16
    55c8:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    55cc:	82 17       	cp	r24, r18
    55ce:	10 f4       	brcc	.+4      	; 0x55d4 <xTaskRemoveFromEventList+0x42>
    55d0:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    55d4:	30 e0       	ldi	r19, 0x00	; 0
    55d6:	c9 01       	movw	r24, r18
    55d8:	88 0f       	add	r24, r24
    55da:	99 1f       	adc	r25, r25
    55dc:	88 0f       	add	r24, r24
    55de:	99 1f       	adc	r25, r25
    55e0:	88 0f       	add	r24, r24
    55e2:	99 1f       	adc	r25, r25
    55e4:	82 0f       	add	r24, r18
    55e6:	93 1f       	adc	r25, r19
    55e8:	b8 01       	movw	r22, r16
    55ea:	81 59       	subi	r24, 0x91	; 145
    55ec:	95 4e       	sbci	r25, 0xE5	; 229
    55ee:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    55f2:	05 c0       	rjmp	.+10     	; 0x55fe <xTaskRemoveFromEventList+0x6c>
    55f4:	b8 01       	movw	r22, r16
    55f6:	80 e5       	ldi	r24, 0x50	; 80
    55f8:	9a e1       	ldi	r25, 0x1A	; 26
    55fa:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    55fe:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5602:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5606:	9e 89       	ldd	r25, Y+22	; 0x16
    5608:	86 89       	ldd	r24, Z+22	; 0x16
    560a:	89 17       	cp	r24, r25
    560c:	20 f4       	brcc	.+8      	; 0x5616 <xTaskRemoveFromEventList+0x84>
    560e:	81 e0       	ldi	r24, 0x01	; 1
    5610:	80 93 40 1a 	sts	0x1A40, r24	; 0x801a40 <xYieldPending>
    5614:	01 c0       	rjmp	.+2      	; 0x5618 <xTaskRemoveFromEventList+0x86>
    5616:	80 e0       	ldi	r24, 0x00	; 0
    5618:	df 91       	pop	r29
    561a:	cf 91       	pop	r28
    561c:	1f 91       	pop	r17
    561e:	0f 91       	pop	r16
    5620:	08 95       	ret

00005622 <vTaskSetTimeOutState>:
    5622:	20 91 3f 1a 	lds	r18, 0x1A3F	; 0x801a3f <xNumOfOverflows>
    5626:	fc 01       	movw	r30, r24
    5628:	20 83       	st	Z, r18
    562a:	20 91 44 1a 	lds	r18, 0x1A44	; 0x801a44 <xTickCount>
    562e:	30 91 45 1a 	lds	r19, 0x1A45	; 0x801a45 <xTickCount+0x1>
    5632:	32 83       	std	Z+2, r19	; 0x02
    5634:	21 83       	std	Z+1, r18	; 0x01
    5636:	08 95       	ret

00005638 <xTaskCheckForTimeOut>:
    5638:	fc 01       	movw	r30, r24
    563a:	0f b6       	in	r0, 0x3f	; 63
    563c:	f8 94       	cli
    563e:	0f 92       	push	r0
    5640:	20 91 44 1a 	lds	r18, 0x1A44	; 0x801a44 <xTickCount>
    5644:	30 91 45 1a 	lds	r19, 0x1A45	; 0x801a45 <xTickCount+0x1>
    5648:	db 01       	movw	r26, r22
    564a:	8d 91       	ld	r24, X+
    564c:	9c 91       	ld	r25, X
    564e:	8f 3f       	cpi	r24, 0xFF	; 255
    5650:	bf ef       	ldi	r27, 0xFF	; 255
    5652:	9b 07       	cpc	r25, r27
    5654:	21 f1       	breq	.+72     	; 0x569e <xTaskCheckForTimeOut+0x66>
    5656:	40 91 3f 1a 	lds	r20, 0x1A3F	; 0x801a3f <xNumOfOverflows>
    565a:	50 81       	ld	r21, Z
    565c:	54 17       	cp	r21, r20
    565e:	29 f0       	breq	.+10     	; 0x566a <xTaskCheckForTimeOut+0x32>
    5660:	41 81       	ldd	r20, Z+1	; 0x01
    5662:	52 81       	ldd	r21, Z+2	; 0x02
    5664:	24 17       	cp	r18, r20
    5666:	35 07       	cpc	r19, r21
    5668:	e0 f4       	brcc	.+56     	; 0x56a2 <xTaskCheckForTimeOut+0x6a>
    566a:	41 81       	ldd	r20, Z+1	; 0x01
    566c:	52 81       	ldd	r21, Z+2	; 0x02
    566e:	d9 01       	movw	r26, r18
    5670:	a4 1b       	sub	r26, r20
    5672:	b5 0b       	sbc	r27, r21
    5674:	a8 17       	cp	r26, r24
    5676:	b9 07       	cpc	r27, r25
    5678:	b0 f4       	brcc	.+44     	; 0x56a6 <xTaskCheckForTimeOut+0x6e>
    567a:	42 1b       	sub	r20, r18
    567c:	53 0b       	sbc	r21, r19
    567e:	84 0f       	add	r24, r20
    5680:	95 1f       	adc	r25, r21
    5682:	db 01       	movw	r26, r22
    5684:	8d 93       	st	X+, r24
    5686:	9c 93       	st	X, r25
    5688:	80 91 3f 1a 	lds	r24, 0x1A3F	; 0x801a3f <xNumOfOverflows>
    568c:	80 83       	st	Z, r24
    568e:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    5692:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    5696:	92 83       	std	Z+2, r25	; 0x02
    5698:	81 83       	std	Z+1, r24	; 0x01
    569a:	80 e0       	ldi	r24, 0x00	; 0
    569c:	05 c0       	rjmp	.+10     	; 0x56a8 <xTaskCheckForTimeOut+0x70>
    569e:	80 e0       	ldi	r24, 0x00	; 0
    56a0:	03 c0       	rjmp	.+6      	; 0x56a8 <xTaskCheckForTimeOut+0x70>
    56a2:	81 e0       	ldi	r24, 0x01	; 1
    56a4:	01 c0       	rjmp	.+2      	; 0x56a8 <xTaskCheckForTimeOut+0x70>
    56a6:	81 e0       	ldi	r24, 0x01	; 1
    56a8:	0f 90       	pop	r0
    56aa:	0f be       	out	0x3f, r0	; 63
    56ac:	08 95       	ret

000056ae <vTaskMissedYield>:
    56ae:	81 e0       	ldi	r24, 0x01	; 1
    56b0:	80 93 40 1a 	sts	0x1A40, r24	; 0x801a40 <xYieldPending>
    56b4:	08 95       	ret

000056b6 <xTaskGetCurrentTaskHandle>:
    56b6:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    56ba:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    56be:	08 95       	ret

000056c0 <vTaskPriorityInherit>:
    56c0:	0f 93       	push	r16
    56c2:	1f 93       	push	r17
    56c4:	cf 93       	push	r28
    56c6:	df 93       	push	r29
    56c8:	fc 01       	movw	r30, r24
    56ca:	89 2b       	or	r24, r25
    56cc:	09 f4       	brne	.+2      	; 0x56d0 <vTaskPriorityInherit+0x10>
    56ce:	55 c0       	rjmp	.+170    	; 0x577a <vTaskPriorityInherit+0xba>
    56d0:	26 89       	ldd	r18, Z+22	; 0x16
    56d2:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    56d6:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    56da:	56 96       	adiw	r26, 0x16	; 22
    56dc:	8c 91       	ld	r24, X
    56de:	28 17       	cp	r18, r24
    56e0:	08 f0       	brcs	.+2      	; 0x56e4 <vTaskPriorityInherit+0x24>
    56e2:	4b c0       	rjmp	.+150    	; 0x577a <vTaskPriorityInherit+0xba>
    56e4:	84 85       	ldd	r24, Z+12	; 0x0c
    56e6:	95 85       	ldd	r25, Z+13	; 0x0d
    56e8:	99 23       	and	r25, r25
    56ea:	64 f0       	brlt	.+24     	; 0x5704 <vTaskPriorityInherit+0x44>
    56ec:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    56f0:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    56f4:	56 96       	adiw	r26, 0x16	; 22
    56f6:	3c 91       	ld	r19, X
    56f8:	86 e0       	ldi	r24, 0x06	; 6
    56fa:	90 e0       	ldi	r25, 0x00	; 0
    56fc:	83 1b       	sub	r24, r19
    56fe:	91 09       	sbc	r25, r1
    5700:	95 87       	std	Z+13, r25	; 0x0d
    5702:	84 87       	std	Z+12, r24	; 0x0c
    5704:	30 e0       	ldi	r19, 0x00	; 0
    5706:	c9 01       	movw	r24, r18
    5708:	88 0f       	add	r24, r24
    570a:	99 1f       	adc	r25, r25
    570c:	88 0f       	add	r24, r24
    570e:	99 1f       	adc	r25, r25
    5710:	88 0f       	add	r24, r24
    5712:	99 1f       	adc	r25, r25
    5714:	28 0f       	add	r18, r24
    5716:	39 1f       	adc	r19, r25
    5718:	21 59       	subi	r18, 0x91	; 145
    571a:	35 4e       	sbci	r19, 0xE5	; 229
    571c:	82 85       	ldd	r24, Z+10	; 0x0a
    571e:	93 85       	ldd	r25, Z+11	; 0x0b
    5720:	82 17       	cp	r24, r18
    5722:	93 07       	cpc	r25, r19
    5724:	19 f5       	brne	.+70     	; 0x576c <vTaskPriorityInherit+0xac>
    5726:	8f 01       	movw	r16, r30
    5728:	ef 01       	movw	r28, r30
    572a:	22 96       	adiw	r28, 0x02	; 2
    572c:	ce 01       	movw	r24, r28
    572e:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    5732:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5736:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    573a:	26 89       	ldd	r18, Z+22	; 0x16
    573c:	f8 01       	movw	r30, r16
    573e:	26 8b       	std	Z+22, r18	; 0x16
    5740:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    5744:	82 17       	cp	r24, r18
    5746:	10 f4       	brcc	.+4      	; 0x574c <vTaskPriorityInherit+0x8c>
    5748:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    574c:	30 e0       	ldi	r19, 0x00	; 0
    574e:	c9 01       	movw	r24, r18
    5750:	88 0f       	add	r24, r24
    5752:	99 1f       	adc	r25, r25
    5754:	88 0f       	add	r24, r24
    5756:	99 1f       	adc	r25, r25
    5758:	88 0f       	add	r24, r24
    575a:	99 1f       	adc	r25, r25
    575c:	82 0f       	add	r24, r18
    575e:	93 1f       	adc	r25, r19
    5760:	be 01       	movw	r22, r28
    5762:	81 59       	subi	r24, 0x91	; 145
    5764:	95 4e       	sbci	r25, 0xE5	; 229
    5766:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    576a:	07 c0       	rjmp	.+14     	; 0x577a <vTaskPriorityInherit+0xba>
    576c:	a0 91 a5 1a 	lds	r26, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5770:	b0 91 a6 1a 	lds	r27, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5774:	56 96       	adiw	r26, 0x16	; 22
    5776:	8c 91       	ld	r24, X
    5778:	86 8b       	std	Z+22, r24	; 0x16
    577a:	df 91       	pop	r29
    577c:	cf 91       	pop	r28
    577e:	1f 91       	pop	r17
    5780:	0f 91       	pop	r16
    5782:	08 95       	ret

00005784 <xTaskPriorityDisinherit>:
    5784:	0f 93       	push	r16
    5786:	1f 93       	push	r17
    5788:	cf 93       	push	r28
    578a:	df 93       	push	r29
    578c:	fc 01       	movw	r30, r24
    578e:	89 2b       	or	r24, r25
    5790:	79 f1       	breq	.+94     	; 0x57f0 <xTaskPriorityDisinherit+0x6c>
    5792:	82 a1       	ldd	r24, Z+34	; 0x22
    5794:	81 50       	subi	r24, 0x01	; 1
    5796:	82 a3       	std	Z+34, r24	; 0x22
    5798:	26 89       	ldd	r18, Z+22	; 0x16
    579a:	91 a1       	ldd	r25, Z+33	; 0x21
    579c:	29 17       	cp	r18, r25
    579e:	51 f1       	breq	.+84     	; 0x57f4 <xTaskPriorityDisinherit+0x70>
    57a0:	81 11       	cpse	r24, r1
    57a2:	2a c0       	rjmp	.+84     	; 0x57f8 <xTaskPriorityDisinherit+0x74>
    57a4:	ef 01       	movw	r28, r30
    57a6:	8f 01       	movw	r16, r30
    57a8:	0e 5f       	subi	r16, 0xFE	; 254
    57aa:	1f 4f       	sbci	r17, 0xFF	; 255
    57ac:	c8 01       	movw	r24, r16
    57ae:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    57b2:	29 a1       	ldd	r18, Y+33	; 0x21
    57b4:	2e 8b       	std	Y+22, r18	; 0x16
    57b6:	46 e0       	ldi	r20, 0x06	; 6
    57b8:	50 e0       	ldi	r21, 0x00	; 0
    57ba:	42 1b       	sub	r20, r18
    57bc:	51 09       	sbc	r21, r1
    57be:	5d 87       	std	Y+13, r21	; 0x0d
    57c0:	4c 87       	std	Y+12, r20	; 0x0c
    57c2:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    57c6:	82 17       	cp	r24, r18
    57c8:	10 f4       	brcc	.+4      	; 0x57ce <xTaskPriorityDisinherit+0x4a>
    57ca:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    57ce:	30 e0       	ldi	r19, 0x00	; 0
    57d0:	c9 01       	movw	r24, r18
    57d2:	88 0f       	add	r24, r24
    57d4:	99 1f       	adc	r25, r25
    57d6:	88 0f       	add	r24, r24
    57d8:	99 1f       	adc	r25, r25
    57da:	88 0f       	add	r24, r24
    57dc:	99 1f       	adc	r25, r25
    57de:	82 0f       	add	r24, r18
    57e0:	93 1f       	adc	r25, r19
    57e2:	b8 01       	movw	r22, r16
    57e4:	81 59       	subi	r24, 0x91	; 145
    57e6:	95 4e       	sbci	r25, 0xE5	; 229
    57e8:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    57ec:	81 e0       	ldi	r24, 0x01	; 1
    57ee:	05 c0       	rjmp	.+10     	; 0x57fa <xTaskPriorityDisinherit+0x76>
    57f0:	80 e0       	ldi	r24, 0x00	; 0
    57f2:	03 c0       	rjmp	.+6      	; 0x57fa <xTaskPriorityDisinherit+0x76>
    57f4:	80 e0       	ldi	r24, 0x00	; 0
    57f6:	01 c0       	rjmp	.+2      	; 0x57fa <xTaskPriorityDisinherit+0x76>
    57f8:	80 e0       	ldi	r24, 0x00	; 0
    57fa:	df 91       	pop	r29
    57fc:	cf 91       	pop	r28
    57fe:	1f 91       	pop	r17
    5800:	0f 91       	pop	r16
    5802:	08 95       	ret

00005804 <pvTaskIncrementMutexHeldCount>:
    5804:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5808:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    580c:	89 2b       	or	r24, r25
    580e:	39 f0       	breq	.+14     	; 0x581e <pvTaskIncrementMutexHeldCount+0x1a>
    5810:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5814:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5818:	82 a1       	ldd	r24, Z+34	; 0x22
    581a:	8f 5f       	subi	r24, 0xFF	; 255
    581c:	82 a3       	std	Z+34, r24	; 0x22
    581e:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5822:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5826:	08 95       	ret

00005828 <ulTaskNotifyTake>:
    5828:	0f 93       	push	r16
    582a:	1f 93       	push	r17
    582c:	cf 93       	push	r28
    582e:	df 93       	push	r29
    5830:	18 2f       	mov	r17, r24
    5832:	eb 01       	movw	r28, r22
    5834:	0f b6       	in	r0, 0x3f	; 63
    5836:	f8 94       	cli
    5838:	0f 92       	push	r0
    583a:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    583e:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5842:	43 a1       	ldd	r20, Z+35	; 0x23
    5844:	54 a1       	ldd	r21, Z+36	; 0x24
    5846:	65 a1       	ldd	r22, Z+37	; 0x25
    5848:	76 a1       	ldd	r23, Z+38	; 0x26
    584a:	45 2b       	or	r20, r21
    584c:	46 2b       	or	r20, r22
    584e:	47 2b       	or	r20, r23
    5850:	09 f0       	breq	.+2      	; 0x5854 <ulTaskNotifyTake+0x2c>
    5852:	58 c0       	rjmp	.+176    	; 0x5904 <ulTaskNotifyTake+0xdc>
    5854:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5858:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    585c:	81 e0       	ldi	r24, 0x01	; 1
    585e:	87 a3       	std	Z+39, r24	; 0x27
    5860:	20 97       	sbiw	r28, 0x00	; 0
    5862:	09 f4       	brne	.+2      	; 0x5866 <ulTaskNotifyTake+0x3e>
    5864:	4f c0       	rjmp	.+158    	; 0x5904 <ulTaskNotifyTake+0xdc>
    5866:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    586a:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    586e:	02 96       	adiw	r24, 0x02	; 2
    5870:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    5874:	cf 3f       	cpi	r28, 0xFF	; 255
    5876:	8f ef       	ldi	r24, 0xFF	; 255
    5878:	d8 07       	cpc	r29, r24
    587a:	59 f4       	brne	.+22     	; 0x5892 <ulTaskNotifyTake+0x6a>
    587c:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5880:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5884:	6e 5f       	subi	r22, 0xFE	; 254
    5886:	7f 4f       	sbci	r23, 0xFF	; 255
    5888:	87 e4       	ldi	r24, 0x47	; 71
    588a:	9a e1       	ldi	r25, 0x1A	; 26
    588c:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    5890:	37 c0       	rjmp	.+110    	; 0x5900 <ulTaskNotifyTake+0xd8>
    5892:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    5896:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    589a:	c8 0f       	add	r28, r24
    589c:	d9 1f       	adc	r29, r25
    589e:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    58a2:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    58a6:	d3 83       	std	Z+3, r29	; 0x03
    58a8:	c2 83       	std	Z+2, r28	; 0x02
    58aa:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    58ae:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    58b2:	c8 17       	cp	r28, r24
    58b4:	d9 07       	cpc	r29, r25
    58b6:	68 f4       	brcc	.+26     	; 0x58d2 <ulTaskNotifyTake+0xaa>
    58b8:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    58bc:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    58c0:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    58c4:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    58c8:	6e 5f       	subi	r22, 0xFE	; 254
    58ca:	7f 4f       	sbci	r23, 0xFF	; 255
    58cc:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    58d0:	17 c0       	rjmp	.+46     	; 0x5900 <ulTaskNotifyTake+0xd8>
    58d2:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    58d6:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    58da:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    58de:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    58e2:	6e 5f       	subi	r22, 0xFE	; 254
    58e4:	7f 4f       	sbci	r23, 0xFF	; 255
    58e6:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    58ea:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    58ee:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    58f2:	c8 17       	cp	r28, r24
    58f4:	d9 07       	cpc	r29, r25
    58f6:	20 f4       	brcc	.+8      	; 0x5900 <ulTaskNotifyTake+0xd8>
    58f8:	d0 93 3d 1a 	sts	0x1A3D, r29	; 0x801a3d <xNextTaskUnblockTime+0x1>
    58fc:	c0 93 3c 1a 	sts	0x1A3C, r28	; 0x801a3c <xNextTaskUnblockTime>
    5900:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    5904:	0f 90       	pop	r0
    5906:	0f be       	out	0x3f, r0	; 63
    5908:	0f b6       	in	r0, 0x3f	; 63
    590a:	f8 94       	cli
    590c:	0f 92       	push	r0
    590e:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5912:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5916:	63 a1       	ldd	r22, Z+35	; 0x23
    5918:	74 a1       	ldd	r23, Z+36	; 0x24
    591a:	85 a1       	ldd	r24, Z+37	; 0x25
    591c:	96 a1       	ldd	r25, Z+38	; 0x26
    591e:	61 15       	cp	r22, r1
    5920:	71 05       	cpc	r23, r1
    5922:	81 05       	cpc	r24, r1
    5924:	91 05       	cpc	r25, r1
    5926:	d9 f0       	breq	.+54     	; 0x595e <ulTaskNotifyTake+0x136>
    5928:	11 23       	and	r17, r17
    592a:	49 f0       	breq	.+18     	; 0x593e <ulTaskNotifyTake+0x116>
    592c:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5930:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5934:	13 a2       	std	Z+35, r1	; 0x23
    5936:	14 a2       	std	Z+36, r1	; 0x24
    5938:	15 a2       	std	Z+37, r1	; 0x25
    593a:	16 a2       	std	Z+38, r1	; 0x26
    593c:	10 c0       	rjmp	.+32     	; 0x595e <ulTaskNotifyTake+0x136>
    593e:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5942:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5946:	03 a1       	ldd	r16, Z+35	; 0x23
    5948:	14 a1       	ldd	r17, Z+36	; 0x24
    594a:	25 a1       	ldd	r18, Z+37	; 0x25
    594c:	36 a1       	ldd	r19, Z+38	; 0x26
    594e:	01 50       	subi	r16, 0x01	; 1
    5950:	11 09       	sbc	r17, r1
    5952:	21 09       	sbc	r18, r1
    5954:	31 09       	sbc	r19, r1
    5956:	03 a3       	std	Z+35, r16	; 0x23
    5958:	14 a3       	std	Z+36, r17	; 0x24
    595a:	25 a3       	std	Z+37, r18	; 0x25
    595c:	36 a3       	std	Z+38, r19	; 0x26
    595e:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5962:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5966:	17 a2       	std	Z+39, r1	; 0x27
    5968:	0f 90       	pop	r0
    596a:	0f be       	out	0x3f, r0	; 63
    596c:	df 91       	pop	r29
    596e:	cf 91       	pop	r28
    5970:	1f 91       	pop	r17
    5972:	0f 91       	pop	r16
    5974:	08 95       	ret

00005976 <xTaskNotifyWait>:
    5976:	4f 92       	push	r4
    5978:	5f 92       	push	r5
    597a:	6f 92       	push	r6
    597c:	7f 92       	push	r7
    597e:	8f 92       	push	r8
    5980:	9f 92       	push	r9
    5982:	af 92       	push	r10
    5984:	bf 92       	push	r11
    5986:	ef 92       	push	r14
    5988:	ff 92       	push	r15
    598a:	0f 93       	push	r16
    598c:	1f 93       	push	r17
    598e:	49 01       	movw	r8, r18
    5990:	5a 01       	movw	r10, r20
    5992:	0f b6       	in	r0, 0x3f	; 63
    5994:	f8 94       	cli
    5996:	0f 92       	push	r0
    5998:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    599c:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    59a0:	27 a1       	ldd	r18, Z+39	; 0x27
    59a2:	22 30       	cpi	r18, 0x02	; 2
    59a4:	09 f4       	brne	.+2      	; 0x59a8 <xTaskNotifyWait+0x32>
    59a6:	6f c0       	rjmp	.+222    	; 0x5a86 <xTaskNotifyWait+0x110>
    59a8:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    59ac:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    59b0:	43 a0       	ldd	r4, Z+35	; 0x23
    59b2:	54 a0       	ldd	r5, Z+36	; 0x24
    59b4:	65 a0       	ldd	r6, Z+37	; 0x25
    59b6:	76 a0       	ldd	r7, Z+38	; 0x26
    59b8:	dc 01       	movw	r26, r24
    59ba:	cb 01       	movw	r24, r22
    59bc:	80 95       	com	r24
    59be:	90 95       	com	r25
    59c0:	a0 95       	com	r26
    59c2:	b0 95       	com	r27
    59c4:	84 21       	and	r24, r4
    59c6:	95 21       	and	r25, r5
    59c8:	a6 21       	and	r26, r6
    59ca:	b7 21       	and	r27, r7
    59cc:	83 a3       	std	Z+35, r24	; 0x23
    59ce:	94 a3       	std	Z+36, r25	; 0x24
    59d0:	a5 a3       	std	Z+37, r26	; 0x25
    59d2:	b6 a3       	std	Z+38, r27	; 0x26
    59d4:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    59d8:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    59dc:	81 e0       	ldi	r24, 0x01	; 1
    59de:	87 a3       	std	Z+39, r24	; 0x27
    59e0:	e1 14       	cp	r14, r1
    59e2:	f1 04       	cpc	r15, r1
    59e4:	09 f4       	brne	.+2      	; 0x59e8 <xTaskNotifyWait+0x72>
    59e6:	4f c0       	rjmp	.+158    	; 0x5a86 <xTaskNotifyWait+0x110>
    59e8:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    59ec:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    59f0:	02 96       	adiw	r24, 0x02	; 2
    59f2:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    59f6:	8f ef       	ldi	r24, 0xFF	; 255
    59f8:	e8 16       	cp	r14, r24
    59fa:	f8 06       	cpc	r15, r24
    59fc:	59 f4       	brne	.+22     	; 0x5a14 <xTaskNotifyWait+0x9e>
    59fe:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5a02:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5a06:	6e 5f       	subi	r22, 0xFE	; 254
    5a08:	7f 4f       	sbci	r23, 0xFF	; 255
    5a0a:	87 e4       	ldi	r24, 0x47	; 71
    5a0c:	9a e1       	ldi	r25, 0x1A	; 26
    5a0e:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    5a12:	37 c0       	rjmp	.+110    	; 0x5a82 <xTaskNotifyWait+0x10c>
    5a14:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    5a18:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    5a1c:	e8 0e       	add	r14, r24
    5a1e:	f9 1e       	adc	r15, r25
    5a20:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5a24:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5a28:	f3 82       	std	Z+3, r15	; 0x03
    5a2a:	e2 82       	std	Z+2, r14	; 0x02
    5a2c:	80 91 44 1a 	lds	r24, 0x1A44	; 0x801a44 <xTickCount>
    5a30:	90 91 45 1a 	lds	r25, 0x1A45	; 0x801a45 <xTickCount+0x1>
    5a34:	e8 16       	cp	r14, r24
    5a36:	f9 06       	cpc	r15, r25
    5a38:	68 f4       	brcc	.+26     	; 0x5a54 <xTaskNotifyWait+0xde>
    5a3a:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5a3e:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5a42:	80 91 59 1a 	lds	r24, 0x1A59	; 0x801a59 <pxOverflowDelayedTaskList>
    5a46:	90 91 5a 1a 	lds	r25, 0x1A5A	; 0x801a5a <pxOverflowDelayedTaskList+0x1>
    5a4a:	6e 5f       	subi	r22, 0xFE	; 254
    5a4c:	7f 4f       	sbci	r23, 0xFF	; 255
    5a4e:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    5a52:	17 c0       	rjmp	.+46     	; 0x5a82 <xTaskNotifyWait+0x10c>
    5a54:	60 91 a5 1a 	lds	r22, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5a58:	70 91 a6 1a 	lds	r23, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5a5c:	80 91 5b 1a 	lds	r24, 0x1A5B	; 0x801a5b <pxDelayedTaskList>
    5a60:	90 91 5c 1a 	lds	r25, 0x1A5C	; 0x801a5c <pxDelayedTaskList+0x1>
    5a64:	6e 5f       	subi	r22, 0xFE	; 254
    5a66:	7f 4f       	sbci	r23, 0xFF	; 255
    5a68:	0e 94 ef 0c 	call	0x19de	; 0x19de <vListInsert>
    5a6c:	80 91 3c 1a 	lds	r24, 0x1A3C	; 0x801a3c <xNextTaskUnblockTime>
    5a70:	90 91 3d 1a 	lds	r25, 0x1A3D	; 0x801a3d <xNextTaskUnblockTime+0x1>
    5a74:	e8 16       	cp	r14, r24
    5a76:	f9 06       	cpc	r15, r25
    5a78:	20 f4       	brcc	.+8      	; 0x5a82 <xTaskNotifyWait+0x10c>
    5a7a:	f0 92 3d 1a 	sts	0x1A3D, r15	; 0x801a3d <xNextTaskUnblockTime+0x1>
    5a7e:	e0 92 3c 1a 	sts	0x1A3C, r14	; 0x801a3c <xNextTaskUnblockTime>
    5a82:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    5a86:	0f 90       	pop	r0
    5a88:	0f be       	out	0x3f, r0	; 63
    5a8a:	0f b6       	in	r0, 0x3f	; 63
    5a8c:	f8 94       	cli
    5a8e:	0f 92       	push	r0
    5a90:	01 15       	cp	r16, r1
    5a92:	11 05       	cpc	r17, r1
    5a94:	69 f0       	breq	.+26     	; 0x5ab0 <xTaskNotifyWait+0x13a>
    5a96:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5a9a:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5a9e:	83 a1       	ldd	r24, Z+35	; 0x23
    5aa0:	94 a1       	ldd	r25, Z+36	; 0x24
    5aa2:	a5 a1       	ldd	r26, Z+37	; 0x25
    5aa4:	b6 a1       	ldd	r27, Z+38	; 0x26
    5aa6:	f8 01       	movw	r30, r16
    5aa8:	80 83       	st	Z, r24
    5aaa:	91 83       	std	Z+1, r25	; 0x01
    5aac:	a2 83       	std	Z+2, r26	; 0x02
    5aae:	b3 83       	std	Z+3, r27	; 0x03
    5ab0:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5ab4:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5ab8:	87 a1       	ldd	r24, Z+39	; 0x27
    5aba:	81 30       	cpi	r24, 0x01	; 1
    5abc:	b1 f0       	breq	.+44     	; 0x5aea <xTaskNotifyWait+0x174>
    5abe:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5ac2:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5ac6:	83 a1       	ldd	r24, Z+35	; 0x23
    5ac8:	94 a1       	ldd	r25, Z+36	; 0x24
    5aca:	a5 a1       	ldd	r26, Z+37	; 0x25
    5acc:	b6 a1       	ldd	r27, Z+38	; 0x26
    5ace:	80 94       	com	r8
    5ad0:	90 94       	com	r9
    5ad2:	a0 94       	com	r10
    5ad4:	b0 94       	com	r11
    5ad6:	88 22       	and	r8, r24
    5ad8:	99 22       	and	r9, r25
    5ada:	aa 22       	and	r10, r26
    5adc:	bb 22       	and	r11, r27
    5ade:	83 a2       	std	Z+35, r8	; 0x23
    5ae0:	94 a2       	std	Z+36, r9	; 0x24
    5ae2:	a5 a2       	std	Z+37, r10	; 0x25
    5ae4:	b6 a2       	std	Z+38, r11	; 0x26
    5ae6:	81 e0       	ldi	r24, 0x01	; 1
    5ae8:	01 c0       	rjmp	.+2      	; 0x5aec <xTaskNotifyWait+0x176>
    5aea:	80 e0       	ldi	r24, 0x00	; 0
    5aec:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5af0:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5af4:	17 a2       	std	Z+39, r1	; 0x27
    5af6:	0f 90       	pop	r0
    5af8:	0f be       	out	0x3f, r0	; 63
    5afa:	1f 91       	pop	r17
    5afc:	0f 91       	pop	r16
    5afe:	ff 90       	pop	r15
    5b00:	ef 90       	pop	r14
    5b02:	bf 90       	pop	r11
    5b04:	af 90       	pop	r10
    5b06:	9f 90       	pop	r9
    5b08:	8f 90       	pop	r8
    5b0a:	7f 90       	pop	r7
    5b0c:	6f 90       	pop	r6
    5b0e:	5f 90       	pop	r5
    5b10:	4f 90       	pop	r4
    5b12:	08 95       	ret

00005b14 <xTaskGenericNotify>:
    5b14:	0f 93       	push	r16
    5b16:	1f 93       	push	r17
    5b18:	cf 93       	push	r28
    5b1a:	df 93       	push	r29
    5b1c:	fc 01       	movw	r30, r24
    5b1e:	0f b6       	in	r0, 0x3f	; 63
    5b20:	f8 94       	cli
    5b22:	0f 92       	push	r0
    5b24:	01 15       	cp	r16, r1
    5b26:	11 05       	cpc	r17, r1
    5b28:	49 f0       	breq	.+18     	; 0x5b3c <xTaskGenericNotify+0x28>
    5b2a:	83 a1       	ldd	r24, Z+35	; 0x23
    5b2c:	94 a1       	ldd	r25, Z+36	; 0x24
    5b2e:	a5 a1       	ldd	r26, Z+37	; 0x25
    5b30:	b6 a1       	ldd	r27, Z+38	; 0x26
    5b32:	e8 01       	movw	r28, r16
    5b34:	88 83       	st	Y, r24
    5b36:	99 83       	std	Y+1, r25	; 0x01
    5b38:	aa 83       	std	Y+2, r26	; 0x02
    5b3a:	bb 83       	std	Y+3, r27	; 0x03
    5b3c:	87 a1       	ldd	r24, Z+39	; 0x27
    5b3e:	92 e0       	ldi	r25, 0x02	; 2
    5b40:	97 a3       	std	Z+39, r25	; 0x27
    5b42:	22 30       	cpi	r18, 0x02	; 2
    5b44:	b1 f0       	breq	.+44     	; 0x5b72 <xTaskGenericNotify+0x5e>
    5b46:	18 f4       	brcc	.+6      	; 0x5b4e <xTaskGenericNotify+0x3a>
    5b48:	21 30       	cpi	r18, 0x01	; 1
    5b4a:	31 f0       	breq	.+12     	; 0x5b58 <xTaskGenericNotify+0x44>
    5b4c:	2a c0       	rjmp	.+84     	; 0x5ba2 <xTaskGenericNotify+0x8e>
    5b4e:	23 30       	cpi	r18, 0x03	; 3
    5b50:	e9 f0       	breq	.+58     	; 0x5b8c <xTaskGenericNotify+0x78>
    5b52:	24 30       	cpi	r18, 0x04	; 4
    5b54:	01 f1       	breq	.+64     	; 0x5b96 <xTaskGenericNotify+0x82>
    5b56:	25 c0       	rjmp	.+74     	; 0x5ba2 <xTaskGenericNotify+0x8e>
    5b58:	03 a1       	ldd	r16, Z+35	; 0x23
    5b5a:	14 a1       	ldd	r17, Z+36	; 0x24
    5b5c:	25 a1       	ldd	r18, Z+37	; 0x25
    5b5e:	36 a1       	ldd	r19, Z+38	; 0x26
    5b60:	40 2b       	or	r20, r16
    5b62:	51 2b       	or	r21, r17
    5b64:	62 2b       	or	r22, r18
    5b66:	73 2b       	or	r23, r19
    5b68:	43 a3       	std	Z+35, r20	; 0x23
    5b6a:	54 a3       	std	Z+36, r21	; 0x24
    5b6c:	65 a3       	std	Z+37, r22	; 0x25
    5b6e:	76 a3       	std	Z+38, r23	; 0x26
    5b70:	18 c0       	rjmp	.+48     	; 0x5ba2 <xTaskGenericNotify+0x8e>
    5b72:	43 a1       	ldd	r20, Z+35	; 0x23
    5b74:	54 a1       	ldd	r21, Z+36	; 0x24
    5b76:	65 a1       	ldd	r22, Z+37	; 0x25
    5b78:	76 a1       	ldd	r23, Z+38	; 0x26
    5b7a:	4f 5f       	subi	r20, 0xFF	; 255
    5b7c:	5f 4f       	sbci	r21, 0xFF	; 255
    5b7e:	6f 4f       	sbci	r22, 0xFF	; 255
    5b80:	7f 4f       	sbci	r23, 0xFF	; 255
    5b82:	43 a3       	std	Z+35, r20	; 0x23
    5b84:	54 a3       	std	Z+36, r21	; 0x24
    5b86:	65 a3       	std	Z+37, r22	; 0x25
    5b88:	76 a3       	std	Z+38, r23	; 0x26
    5b8a:	0b c0       	rjmp	.+22     	; 0x5ba2 <xTaskGenericNotify+0x8e>
    5b8c:	43 a3       	std	Z+35, r20	; 0x23
    5b8e:	54 a3       	std	Z+36, r21	; 0x24
    5b90:	65 a3       	std	Z+37, r22	; 0x25
    5b92:	76 a3       	std	Z+38, r23	; 0x26
    5b94:	06 c0       	rjmp	.+12     	; 0x5ba2 <xTaskGenericNotify+0x8e>
    5b96:	82 30       	cpi	r24, 0x02	; 2
    5b98:	79 f1       	breq	.+94     	; 0x5bf8 <xTaskGenericNotify+0xe4>
    5b9a:	43 a3       	std	Z+35, r20	; 0x23
    5b9c:	54 a3       	std	Z+36, r21	; 0x24
    5b9e:	65 a3       	std	Z+37, r22	; 0x25
    5ba0:	76 a3       	std	Z+38, r23	; 0x26
    5ba2:	81 30       	cpi	r24, 0x01	; 1
    5ba4:	59 f5       	brne	.+86     	; 0x5bfc <xTaskGenericNotify+0xe8>
    5ba6:	ef 01       	movw	r28, r30
    5ba8:	8f 01       	movw	r16, r30
    5baa:	0e 5f       	subi	r16, 0xFE	; 254
    5bac:	1f 4f       	sbci	r17, 0xFF	; 255
    5bae:	c8 01       	movw	r24, r16
    5bb0:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    5bb4:	2e 89       	ldd	r18, Y+22	; 0x16
    5bb6:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    5bba:	82 17       	cp	r24, r18
    5bbc:	10 f4       	brcc	.+4      	; 0x5bc2 <xTaskGenericNotify+0xae>
    5bbe:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    5bc2:	30 e0       	ldi	r19, 0x00	; 0
    5bc4:	c9 01       	movw	r24, r18
    5bc6:	88 0f       	add	r24, r24
    5bc8:	99 1f       	adc	r25, r25
    5bca:	88 0f       	add	r24, r24
    5bcc:	99 1f       	adc	r25, r25
    5bce:	88 0f       	add	r24, r24
    5bd0:	99 1f       	adc	r25, r25
    5bd2:	82 0f       	add	r24, r18
    5bd4:	93 1f       	adc	r25, r19
    5bd6:	b8 01       	movw	r22, r16
    5bd8:	81 59       	subi	r24, 0x91	; 145
    5bda:	95 4e       	sbci	r25, 0xE5	; 229
    5bdc:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    5be0:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5be4:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5be8:	9e 89       	ldd	r25, Y+22	; 0x16
    5bea:	86 89       	ldd	r24, Z+22	; 0x16
    5bec:	89 17       	cp	r24, r25
    5bee:	40 f4       	brcc	.+16     	; 0x5c00 <xTaskGenericNotify+0xec>
    5bf0:	0e 94 70 18 	call	0x30e0	; 0x30e0 <vPortYield>
    5bf4:	81 e0       	ldi	r24, 0x01	; 1
    5bf6:	05 c0       	rjmp	.+10     	; 0x5c02 <xTaskGenericNotify+0xee>
    5bf8:	80 e0       	ldi	r24, 0x00	; 0
    5bfa:	03 c0       	rjmp	.+6      	; 0x5c02 <xTaskGenericNotify+0xee>
    5bfc:	81 e0       	ldi	r24, 0x01	; 1
    5bfe:	01 c0       	rjmp	.+2      	; 0x5c02 <xTaskGenericNotify+0xee>
    5c00:	81 e0       	ldi	r24, 0x01	; 1
    5c02:	0f 90       	pop	r0
    5c04:	0f be       	out	0x3f, r0	; 63
    5c06:	df 91       	pop	r29
    5c08:	cf 91       	pop	r28
    5c0a:	1f 91       	pop	r17
    5c0c:	0f 91       	pop	r16
    5c0e:	08 95       	ret

00005c10 <xTaskGenericNotifyFromISR>:
    5c10:	ef 92       	push	r14
    5c12:	ff 92       	push	r15
    5c14:	0f 93       	push	r16
    5c16:	1f 93       	push	r17
    5c18:	cf 93       	push	r28
    5c1a:	df 93       	push	r29
    5c1c:	fc 01       	movw	r30, r24
    5c1e:	01 15       	cp	r16, r1
    5c20:	11 05       	cpc	r17, r1
    5c22:	49 f0       	breq	.+18     	; 0x5c36 <xTaskGenericNotifyFromISR+0x26>
    5c24:	83 a1       	ldd	r24, Z+35	; 0x23
    5c26:	94 a1       	ldd	r25, Z+36	; 0x24
    5c28:	a5 a1       	ldd	r26, Z+37	; 0x25
    5c2a:	b6 a1       	ldd	r27, Z+38	; 0x26
    5c2c:	e8 01       	movw	r28, r16
    5c2e:	88 83       	st	Y, r24
    5c30:	99 83       	std	Y+1, r25	; 0x01
    5c32:	aa 83       	std	Y+2, r26	; 0x02
    5c34:	bb 83       	std	Y+3, r27	; 0x03
    5c36:	87 a1       	ldd	r24, Z+39	; 0x27
    5c38:	92 e0       	ldi	r25, 0x02	; 2
    5c3a:	97 a3       	std	Z+39, r25	; 0x27
    5c3c:	22 30       	cpi	r18, 0x02	; 2
    5c3e:	b1 f0       	breq	.+44     	; 0x5c6c <xTaskGenericNotifyFromISR+0x5c>
    5c40:	18 f4       	brcc	.+6      	; 0x5c48 <xTaskGenericNotifyFromISR+0x38>
    5c42:	21 30       	cpi	r18, 0x01	; 1
    5c44:	31 f0       	breq	.+12     	; 0x5c52 <xTaskGenericNotifyFromISR+0x42>
    5c46:	2a c0       	rjmp	.+84     	; 0x5c9c <xTaskGenericNotifyFromISR+0x8c>
    5c48:	23 30       	cpi	r18, 0x03	; 3
    5c4a:	e9 f0       	breq	.+58     	; 0x5c86 <xTaskGenericNotifyFromISR+0x76>
    5c4c:	24 30       	cpi	r18, 0x04	; 4
    5c4e:	01 f1       	breq	.+64     	; 0x5c90 <xTaskGenericNotifyFromISR+0x80>
    5c50:	25 c0       	rjmp	.+74     	; 0x5c9c <xTaskGenericNotifyFromISR+0x8c>
    5c52:	03 a1       	ldd	r16, Z+35	; 0x23
    5c54:	14 a1       	ldd	r17, Z+36	; 0x24
    5c56:	25 a1       	ldd	r18, Z+37	; 0x25
    5c58:	36 a1       	ldd	r19, Z+38	; 0x26
    5c5a:	40 2b       	or	r20, r16
    5c5c:	51 2b       	or	r21, r17
    5c5e:	62 2b       	or	r22, r18
    5c60:	73 2b       	or	r23, r19
    5c62:	43 a3       	std	Z+35, r20	; 0x23
    5c64:	54 a3       	std	Z+36, r21	; 0x24
    5c66:	65 a3       	std	Z+37, r22	; 0x25
    5c68:	76 a3       	std	Z+38, r23	; 0x26
    5c6a:	18 c0       	rjmp	.+48     	; 0x5c9c <xTaskGenericNotifyFromISR+0x8c>
    5c6c:	43 a1       	ldd	r20, Z+35	; 0x23
    5c6e:	54 a1       	ldd	r21, Z+36	; 0x24
    5c70:	65 a1       	ldd	r22, Z+37	; 0x25
    5c72:	76 a1       	ldd	r23, Z+38	; 0x26
    5c74:	4f 5f       	subi	r20, 0xFF	; 255
    5c76:	5f 4f       	sbci	r21, 0xFF	; 255
    5c78:	6f 4f       	sbci	r22, 0xFF	; 255
    5c7a:	7f 4f       	sbci	r23, 0xFF	; 255
    5c7c:	43 a3       	std	Z+35, r20	; 0x23
    5c7e:	54 a3       	std	Z+36, r21	; 0x24
    5c80:	65 a3       	std	Z+37, r22	; 0x25
    5c82:	76 a3       	std	Z+38, r23	; 0x26
    5c84:	0b c0       	rjmp	.+22     	; 0x5c9c <xTaskGenericNotifyFromISR+0x8c>
    5c86:	43 a3       	std	Z+35, r20	; 0x23
    5c88:	54 a3       	std	Z+36, r21	; 0x24
    5c8a:	65 a3       	std	Z+37, r22	; 0x25
    5c8c:	76 a3       	std	Z+38, r23	; 0x26
    5c8e:	06 c0       	rjmp	.+12     	; 0x5c9c <xTaskGenericNotifyFromISR+0x8c>
    5c90:	82 30       	cpi	r24, 0x02	; 2
    5c92:	f1 f1       	breq	.+124    	; 0x5d10 <xTaskGenericNotifyFromISR+0x100>
    5c94:	43 a3       	std	Z+35, r20	; 0x23
    5c96:	54 a3       	std	Z+36, r21	; 0x24
    5c98:	65 a3       	std	Z+37, r22	; 0x25
    5c9a:	76 a3       	std	Z+38, r23	; 0x26
    5c9c:	81 30       	cpi	r24, 0x01	; 1
    5c9e:	d1 f5       	brne	.+116    	; 0x5d14 <xTaskGenericNotifyFromISR+0x104>
    5ca0:	ef 01       	movw	r28, r30
    5ca2:	80 91 3b 1a 	lds	r24, 0x1A3B	; 0x801a3b <uxSchedulerSuspended>
    5ca6:	81 11       	cpse	r24, r1
    5ca8:	1d c0       	rjmp	.+58     	; 0x5ce4 <xTaskGenericNotifyFromISR+0xd4>
    5caa:	8f 01       	movw	r16, r30
    5cac:	0e 5f       	subi	r16, 0xFE	; 254
    5cae:	1f 4f       	sbci	r17, 0xFF	; 255
    5cb0:	c8 01       	movw	r24, r16
    5cb2:	0e 94 20 0d 	call	0x1a40	; 0x1a40 <uxListRemove>
    5cb6:	2e 89       	ldd	r18, Y+22	; 0x16
    5cb8:	80 91 43 1a 	lds	r24, 0x1A43	; 0x801a43 <uxTopReadyPriority>
    5cbc:	82 17       	cp	r24, r18
    5cbe:	10 f4       	brcc	.+4      	; 0x5cc4 <xTaskGenericNotifyFromISR+0xb4>
    5cc0:	20 93 43 1a 	sts	0x1A43, r18	; 0x801a43 <uxTopReadyPriority>
    5cc4:	30 e0       	ldi	r19, 0x00	; 0
    5cc6:	c9 01       	movw	r24, r18
    5cc8:	88 0f       	add	r24, r24
    5cca:	99 1f       	adc	r25, r25
    5ccc:	88 0f       	add	r24, r24
    5cce:	99 1f       	adc	r25, r25
    5cd0:	88 0f       	add	r24, r24
    5cd2:	99 1f       	adc	r25, r25
    5cd4:	82 0f       	add	r24, r18
    5cd6:	93 1f       	adc	r25, r19
    5cd8:	b8 01       	movw	r22, r16
    5cda:	81 59       	subi	r24, 0x91	; 145
    5cdc:	95 4e       	sbci	r25, 0xE5	; 229
    5cde:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    5ce2:	07 c0       	rjmp	.+14     	; 0x5cf2 <xTaskGenericNotifyFromISR+0xe2>
    5ce4:	bf 01       	movw	r22, r30
    5ce6:	64 5f       	subi	r22, 0xF4	; 244
    5ce8:	7f 4f       	sbci	r23, 0xFF	; 255
    5cea:	80 e5       	ldi	r24, 0x50	; 80
    5cec:	9a e1       	ldi	r25, 0x1A	; 26
    5cee:	0e 94 ce 0c 	call	0x199c	; 0x199c <vListInsertEnd>
    5cf2:	e0 91 a5 1a 	lds	r30, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5cf6:	f0 91 a6 1a 	lds	r31, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>
    5cfa:	9e 89       	ldd	r25, Y+22	; 0x16
    5cfc:	86 89       	ldd	r24, Z+22	; 0x16
    5cfe:	89 17       	cp	r24, r25
    5d00:	58 f4       	brcc	.+22     	; 0x5d18 <xTaskGenericNotifyFromISR+0x108>
    5d02:	e1 14       	cp	r14, r1
    5d04:	f1 04       	cpc	r15, r1
    5d06:	51 f0       	breq	.+20     	; 0x5d1c <xTaskGenericNotifyFromISR+0x10c>
    5d08:	81 e0       	ldi	r24, 0x01	; 1
    5d0a:	f7 01       	movw	r30, r14
    5d0c:	80 83       	st	Z, r24
    5d0e:	07 c0       	rjmp	.+14     	; 0x5d1e <xTaskGenericNotifyFromISR+0x10e>
    5d10:	80 e0       	ldi	r24, 0x00	; 0
    5d12:	05 c0       	rjmp	.+10     	; 0x5d1e <xTaskGenericNotifyFromISR+0x10e>
    5d14:	81 e0       	ldi	r24, 0x01	; 1
    5d16:	03 c0       	rjmp	.+6      	; 0x5d1e <xTaskGenericNotifyFromISR+0x10e>
    5d18:	81 e0       	ldi	r24, 0x01	; 1
    5d1a:	01 c0       	rjmp	.+2      	; 0x5d1e <xTaskGenericNotifyFromISR+0x10e>
    5d1c:	81 e0       	ldi	r24, 0x01	; 1
    5d1e:	df 91       	pop	r29
    5d20:	cf 91       	pop	r28
    5d22:	1f 91       	pop	r17
    5d24:	0f 91       	pop	r16
    5d26:	ff 90       	pop	r15
    5d28:	ef 90       	pop	r14
    5d2a:	08 95       	ret

00005d2c <xTaskNotifyStateClear>:

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    5d2c:	00 97       	sbiw	r24, 0x00	; 0
    5d2e:	21 f4       	brne	.+8      	; 0x5d38 <xTaskNotifyStateClear+0xc>
    5d30:	80 91 a5 1a 	lds	r24, 0x1AA5	; 0x801aa5 <pxCurrentTCB>
    5d34:	90 91 a6 1a 	lds	r25, 0x1AA6	; 0x801aa6 <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    5d38:	0f b6       	in	r0, 0x3f	; 63
    5d3a:	f8 94       	cli
    5d3c:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    5d3e:	fc 01       	movw	r30, r24
    5d40:	27 a1       	ldd	r18, Z+39	; 0x27
    5d42:	22 30       	cpi	r18, 0x02	; 2
    5d44:	19 f4       	brne	.+6      	; 0x5d4c <xTaskNotifyStateClear+0x20>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    5d46:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    5d48:	81 e0       	ldi	r24, 0x01	; 1
    5d4a:	01 c0       	rjmp	.+2      	; 0x5d4e <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    5d4c:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    5d4e:	0f 90       	pop	r0
    5d50:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    5d52:	08 95       	ret

00005d54 <vTWI_init>:
    data[(length-1)] = ui8TWI_read_nack();

    vTWI_stop();

    return 0;
}
    5d54:	88 e4       	ldi	r24, 0x48	; 72
    5d56:	80 93 b8 00 	sts	0x00B8, r24	; 0x8000b8 <__TEXT_REGION_LENGTH__+0x7000b8>
    5d5a:	08 95       	ret

00005d5c <ui8TWI_start>:
    5d5c:	ec eb       	ldi	r30, 0xBC	; 188
    5d5e:	f0 e0       	ldi	r31, 0x00	; 0
    5d60:	10 82       	st	Z, r1
    5d62:	94 ea       	ldi	r25, 0xA4	; 164
    5d64:	90 83       	st	Z, r25
    5d66:	90 81       	ld	r25, Z
    5d68:	99 23       	and	r25, r25
    5d6a:	ec f7       	brge	.-6      	; 0x5d66 <ui8TWI_start+0xa>
    5d6c:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    5d70:	98 7f       	andi	r25, 0xF8	; 248
    5d72:	98 30       	cpi	r25, 0x08	; 8
    5d74:	a1 f4       	brne	.+40     	; 0x5d9e <ui8TWI_start+0x42>
    5d76:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5d7a:	84 e8       	ldi	r24, 0x84	; 132
    5d7c:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5d80:	ec eb       	ldi	r30, 0xBC	; 188
    5d82:	f0 e0       	ldi	r31, 0x00	; 0
    5d84:	80 81       	ld	r24, Z
    5d86:	88 23       	and	r24, r24
    5d88:	ec f7       	brge	.-6      	; 0x5d84 <ui8TWI_start+0x28>
    5d8a:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    5d8e:	98 7f       	andi	r25, 0xF8	; 248
    5d90:	98 31       	cpi	r25, 0x18	; 24
    5d92:	39 f0       	breq	.+14     	; 0x5da2 <ui8TWI_start+0x46>
    5d94:	81 e0       	ldi	r24, 0x01	; 1
    5d96:	90 34       	cpi	r25, 0x40	; 64
    5d98:	29 f4       	brne	.+10     	; 0x5da4 <ui8TWI_start+0x48>
    5d9a:	80 e0       	ldi	r24, 0x00	; 0
    5d9c:	08 95       	ret
    5d9e:	81 e0       	ldi	r24, 0x01	; 1
    5da0:	08 95       	ret
    5da2:	80 e0       	ldi	r24, 0x00	; 0
    5da4:	08 95       	ret

00005da6 <ui8TWI_write>:
    5da6:	80 93 bb 00 	sts	0x00BB, r24	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5daa:	84 e8       	ldi	r24, 0x84	; 132
    5dac:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5db0:	ec eb       	ldi	r30, 0xBC	; 188
    5db2:	f0 e0       	ldi	r31, 0x00	; 0
    5db4:	80 81       	ld	r24, Z
    5db6:	88 23       	and	r24, r24
    5db8:	ec f7       	brge	.-6      	; 0x5db4 <ui8TWI_write+0xe>
    5dba:	90 91 b9 00 	lds	r25, 0x00B9	; 0x8000b9 <__TEXT_REGION_LENGTH__+0x7000b9>
    5dbe:	98 7f       	andi	r25, 0xF8	; 248
    5dc0:	81 e0       	ldi	r24, 0x01	; 1
    5dc2:	98 32       	cpi	r25, 0x28	; 40
    5dc4:	09 f4       	brne	.+2      	; 0x5dc8 <ui8TWI_write+0x22>
    5dc6:	80 e0       	ldi	r24, 0x00	; 0
    5dc8:	08 95       	ret

00005dca <ui8TWI_read_ack>:
    5dca:	84 ec       	ldi	r24, 0xC4	; 196
    5dcc:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5dd0:	ec eb       	ldi	r30, 0xBC	; 188
    5dd2:	f0 e0       	ldi	r31, 0x00	; 0
    5dd4:	80 81       	ld	r24, Z
    5dd6:	88 23       	and	r24, r24
    5dd8:	ec f7       	brge	.-6      	; 0x5dd4 <ui8TWI_read_ack+0xa>
    5dda:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5dde:	08 95       	ret

00005de0 <ui8TWI_read_nack>:
    5de0:	84 e8       	ldi	r24, 0x84	; 132
    5de2:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5de6:	ec eb       	ldi	r30, 0xBC	; 188
    5de8:	f0 e0       	ldi	r31, 0x00	; 0
    5dea:	80 81       	ld	r24, Z
    5dec:	88 23       	and	r24, r24
    5dee:	ec f7       	brge	.-6      	; 0x5dea <ui8TWI_read_nack+0xa>
    5df0:	80 91 bb 00 	lds	r24, 0x00BB	; 0x8000bb <__TEXT_REGION_LENGTH__+0x7000bb>
    5df4:	08 95       	ret

00005df6 <vTWI_stop>:

void vTWI_stop(void){
    // transmit STOP condition
    TWCR = (1<<TWINT) | (1<<TWEN) | (1<<TWSTO);
    5df6:	84 e9       	ldi	r24, 0x94	; 148
    5df8:	80 93 bc 00 	sts	0x00BC, r24	; 0x8000bc <__TEXT_REGION_LENGTH__+0x7000bc>
    5dfc:	08 95       	ret

00005dfe <vFrameReaderTask>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
}

void vFrameReaderTask( void *pvParameters ){
    5dfe:	cf 93       	push	r28
    5e00:	df 93       	push	r29
    5e02:	00 d0       	rcall	.+0      	; 0x5e04 <vFrameReaderTask+0x6>
    5e04:	1f 92       	push	r1
    5e06:	cd b7       	in	r28, 0x3d	; 61
    5e08:	de b7       	in	r29, 0x3e	; 62
	frame_receiver = xTaskGetCurrentTaskHandle();
    5e0a:	55 dc       	rcall	.-1878   	; 0x56b6 <xTaskGetCurrentTaskHandle>
    5e0c:	90 93 0e 1b 	sts	0x1B0E, r25	; 0x801b0e <frame_receiver+0x1>
    5e10:	80 93 0d 1b 	sts	0x1B0D, r24	; 0x801b0d <frame_receiver>
	uint32_t notification_value = 0;
    5e14:	19 82       	std	Y+1, r1	; 0x01
    5e16:	1a 82       	std	Y+2, r1	; 0x02
    5e18:	1b 82       	std	Y+3, r1	; 0x03
    5e1a:	1c 82       	std	Y+4, r1	; 0x04
	while(1){
		xTaskNotifyWait(0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);
    5e1c:	ee 24       	eor	r14, r14
    5e1e:	ea 94       	dec	r14
    5e20:	fe 2c       	mov	r15, r14
    5e22:	8e 01       	movw	r16, r28
    5e24:	0f 5f       	subi	r16, 0xFF	; 255
    5e26:	1f 4f       	sbci	r17, 0xFF	; 255
    5e28:	2f ef       	ldi	r18, 0xFF	; 255
    5e2a:	3f ef       	ldi	r19, 0xFF	; 255
    5e2c:	a9 01       	movw	r20, r18
    5e2e:	6f ef       	ldi	r22, 0xFF	; 255
    5e30:	7f ef       	ldi	r23, 0xFF	; 255
    5e32:	cb 01       	movw	r24, r22
    5e34:	a0 dd       	rcall	.-1216   	; 0x5976 <xTaskNotifyWait>
		if(receive_callback != NULL) receive_callback(receive_buffer, (uint16_t)notification_value);
    5e36:	e0 91 72 1b 	lds	r30, 0x1B72	; 0x801b72 <receive_callback>
    5e3a:	f0 91 73 1b 	lds	r31, 0x1B73	; 0x801b73 <receive_callback+0x1>
    5e3e:	30 97       	sbiw	r30, 0x00	; 0
    5e40:	69 f3       	breq	.-38     	; 0x5e1c <vFrameReaderTask+0x1e>
    5e42:	69 81       	ldd	r22, Y+1	; 0x01
    5e44:	7a 81       	ldd	r23, Y+2	; 0x02
    5e46:	84 e7       	ldi	r24, 0x74	; 116
    5e48:	9b e1       	ldi	r25, 0x1B	; 27
    5e4a:	19 95       	eicall
    5e4c:	e7 cf       	rjmp	.-50     	; 0x5e1c <vFrameReaderTask+0x1e>

00005e4e <vUartSendTask>:
	}
}

void vUartSendTask(void *pvParamters) {
    5e4e:	cf 93       	push	r28
    5e50:	df 93       	push	r29
    5e52:	cd b7       	in	r28, 0x3d	; 61
    5e54:	de b7       	in	r29, 0x3e	; 62
    5e56:	c4 56       	subi	r28, 0x64	; 100
    5e58:	d1 09       	sbc	r29, r1
    5e5a:	0f b6       	in	r0, 0x3f	; 63
    5e5c:	f8 94       	cli
    5e5e:	de bf       	out	0x3e, r29	; 62
    5e60:	0f be       	out	0x3f, r0	; 63
    5e62:	cd bf       	out	0x3d, r28	; 61
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    5e64:	00 ed       	ldi	r16, 0xD0	; 208
    5e66:	10 e0       	ldi	r17, 0x00	; 0
				UDR2 = data[i];
    5e68:	0f 2e       	mov	r0, r31
    5e6a:	f6 ed       	ldi	r31, 0xD6	; 214
    5e6c:	ef 2e       	mov	r14, r31
    5e6e:	f1 2c       	mov	r15, r1
    5e70:	f0 2d       	mov	r31, r0
void vUartSendTask(void *pvParamters) {
	uint8_t data[100];
	uint16_t num;
	uint16_t i;
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
    5e72:	20 e0       	ldi	r18, 0x00	; 0
    5e74:	4f ef       	ldi	r20, 0xFF	; 255
    5e76:	5f ef       	ldi	r21, 0xFF	; 255
    5e78:	60 e0       	ldi	r22, 0x00	; 0
    5e7a:	70 e0       	ldi	r23, 0x00	; 0
    5e7c:	80 91 33 1b 	lds	r24, 0x1B33	; 0x801b33 <xUartMutex>
    5e80:	90 91 34 1b 	lds	r25, 0x1B34	; 0x801b34 <xUartMutex+0x1>
    5e84:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
    5e88:	24 e6       	ldi	r18, 0x64	; 100
    5e8a:	30 e0       	ldi	r19, 0x00	; 0
    5e8c:	40 e0       	ldi	r20, 0x00	; 0
    5e8e:	be 01       	movw	r22, r28
    5e90:	6f 5f       	subi	r22, 0xFF	; 255
    5e92:	7f 4f       	sbci	r23, 0xFF	; 255
    5e94:	88 ed       	ldi	r24, 0xD8	; 216
    5e96:	9b e1       	ldi	r25, 0x1B	; 27
    5e98:	0e 94 a2 05 	call	0xb44	; 0xb44 <buffer_remove_token>
    5e9c:	6c 01       	movw	r12, r24
		xSemaphoreGive(xUartMutex);
    5e9e:	60 e0       	ldi	r22, 0x00	; 0
    5ea0:	70 e0       	ldi	r23, 0x00	; 0
    5ea2:	80 91 33 1b 	lds	r24, 0x1B33	; 0x801b33 <xUartMutex>
    5ea6:	90 91 34 1b 	lds	r25, 0x1B34	; 0x801b34 <xUartMutex+0x1>
    5eaa:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
		if(num>0) {
    5eae:	c1 14       	cp	r12, r1
    5eb0:	d1 04       	cpc	r13, r1
    5eb2:	79 f0       	breq	.+30     	; 0x5ed2 <vUartSendTask+0x84>
    5eb4:	fe 01       	movw	r30, r28
    5eb6:	31 96       	adiw	r30, 0x01	; 1
    5eb8:	9f 01       	movw	r18, r30
    5eba:	2c 0d       	add	r18, r12
    5ebc:	3d 1d       	adc	r19, r13
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    5ebe:	d8 01       	movw	r26, r16
    5ec0:	8c 91       	ld	r24, X
    5ec2:	85 ff       	sbrs	r24, 5
    5ec4:	fc cf       	rjmp	.-8      	; 0x5ebe <vUartSendTask+0x70>
				UDR2 = data[i];
    5ec6:	81 91       	ld	r24, Z+
    5ec8:	d7 01       	movw	r26, r14
    5eca:	8c 93       	st	X, r24
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
    5ecc:	e2 17       	cp	r30, r18
    5ece:	f3 07       	cpc	r31, r19
    5ed0:	b1 f7       	brne	.-20     	; 0x5ebe <vUartSendTask+0x70>
				while ( !( UCSR2A & (1<<UDRE2)) );
				UDR2 = data[i];
			}
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
    5ed2:	8a e0       	ldi	r24, 0x0A	; 10
    5ed4:	90 e0       	ldi	r25, 0x00	; 0
    5ed6:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <vTaskDelay>
	}
    5eda:	cb cf       	rjmp	.-106    	; 0x5e72 <vUartSendTask+0x24>

00005edc <vUSART_init>:
/************************************************************************/
//Initialize USART driver, note that RXD0/TXD0 (PD0/PD1) is used
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    5edc:	af 92       	push	r10
    5ede:	bf 92       	push	r11
    5ee0:	cf 92       	push	r12
    5ee2:	df 92       	push	r13
    5ee4:	ef 92       	push	r14
    5ee6:	ff 92       	push	r15
    5ee8:	0f 93       	push	r16
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    5eea:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    5eee:	89 e1       	ldi	r24, 0x19	; 25
    5ef0:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    5ef4:	80 ee       	ldi	r24, 0xE0	; 224
    5ef6:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    5efa:	88 e9       	ldi	r24, 0x98	; 152
    5efc:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    5f00:	e2 ed       	ldi	r30, 0xD2	; 210
    5f02:	f0 e0       	ldi	r31, 0x00	; 0
    5f04:	86 e0       	ldi	r24, 0x06	; 6
    5f06:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    5f08:	80 81       	ld	r24, Z
    5f0a:	80 83       	st	Z, r24

	uint8_t *buf = pvPortMalloc(100);
    5f0c:	84 e6       	ldi	r24, 0x64	; 100
    5f0e:	90 e0       	ldi	r25, 0x00	; 0
    5f10:	0e 94 99 08 	call	0x1132	; 0x1132 <pvPortMalloc>
	buffer_init(&send_buffer, buf, 100);
    5f14:	44 e6       	ldi	r20, 0x64	; 100
    5f16:	50 e0       	ldi	r21, 0x00	; 0
    5f18:	bc 01       	movw	r22, r24
    5f1a:	88 ed       	ldi	r24, 0xD8	; 216
    5f1c:	9b e1       	ldi	r25, 0x1B	; 27
    5f1e:	0e 94 2c 05 	call	0xa58	; 0xa58 <buffer_init>
	xTaskCreate(vFrameReaderTask, "FrameReader", 300, NULL, 4, NULL);
    5f22:	a1 2c       	mov	r10, r1
    5f24:	b1 2c       	mov	r11, r1
    5f26:	c1 2c       	mov	r12, r1
    5f28:	d1 2c       	mov	r13, r1
    5f2a:	e1 2c       	mov	r14, r1
    5f2c:	f1 2c       	mov	r15, r1
    5f2e:	04 e0       	ldi	r16, 0x04	; 4
    5f30:	20 e0       	ldi	r18, 0x00	; 0
    5f32:	30 e0       	ldi	r19, 0x00	; 0
    5f34:	4c e2       	ldi	r20, 0x2C	; 44
    5f36:	51 e0       	ldi	r21, 0x01	; 1
    5f38:	60 e0       	ldi	r22, 0x00	; 0
    5f3a:	77 e0       	ldi	r23, 0x07	; 7
    5f3c:	8f ef       	ldi	r24, 0xFF	; 255
    5f3e:	9e e2       	ldi	r25, 0x2E	; 46
    5f40:	0e 94 b9 22 	call	0x4572	; 0x4572 <xTaskGenericCreate>
	xTaskCreate(vUartSendTask, "UartSendTask", 300, NULL, 4, NULL);
    5f44:	20 e0       	ldi	r18, 0x00	; 0
    5f46:	30 e0       	ldi	r19, 0x00	; 0
    5f48:	4c e2       	ldi	r20, 0x2C	; 44
    5f4a:	51 e0       	ldi	r21, 0x01	; 1
    5f4c:	6c e0       	ldi	r22, 0x0C	; 12
    5f4e:	77 e0       	ldi	r23, 0x07	; 7
    5f50:	87 e2       	ldi	r24, 0x27	; 39
    5f52:	9f e2       	ldi	r25, 0x2F	; 47
    5f54:	0e 94 b9 22 	call	0x4572	; 0x4572 <xTaskGenericCreate>
	
	xUartMutex = xSemaphoreCreateMutex();
    5f58:	81 e0       	ldi	r24, 0x01	; 1
    5f5a:	0e 94 9d 19 	call	0x333a	; 0x333a <xQueueCreateMutex>
    5f5e:	90 93 34 1b 	sts	0x1B34, r25	; 0x801b34 <xUartMutex+0x1>
    5f62:	80 93 33 1b 	sts	0x1B33, r24	; 0x801b33 <xUartMutex>
}
    5f66:	0f 91       	pop	r16
    5f68:	ff 90       	pop	r15
    5f6a:	ef 90       	pop	r14
    5f6c:	df 90       	pop	r13
    5f6e:	cf 90       	pop	r12
    5f70:	bf 90       	pop	r11
    5f72:	af 90       	pop	r10
    5f74:	08 95       	ret

00005f76 <vUSART_send>:

void vUSART_send(uint8_t *data, uint16_t len) {
    5f76:	0f 93       	push	r16
    5f78:	1f 93       	push	r17
    5f7a:	cf 93       	push	r28
    5f7c:	df 93       	push	r29
    5f7e:	ec 01       	movw	r28, r24
    5f80:	8b 01       	movw	r16, r22
	xSemaphoreTake(xUartMutex, portMAX_DELAY);
    5f82:	20 e0       	ldi	r18, 0x00	; 0
    5f84:	4f ef       	ldi	r20, 0xFF	; 255
    5f86:	5f ef       	ldi	r21, 0xFF	; 255
    5f88:	60 e0       	ldi	r22, 0x00	; 0
    5f8a:	70 e0       	ldi	r23, 0x00	; 0
    5f8c:	80 91 33 1b 	lds	r24, 0x1B33	; 0x801b33 <xUartMutex>
    5f90:	90 91 34 1b 	lds	r25, 0x1B34	; 0x801b34 <xUartMutex+0x1>
    5f94:	0e 94 8d 1e 	call	0x3d1a	; 0x3d1a <xQueueGenericReceive>
	buffer_append(&send_buffer, data, len);
    5f98:	a8 01       	movw	r20, r16
    5f9a:	be 01       	movw	r22, r28
    5f9c:	88 ed       	ldi	r24, 0xD8	; 216
    5f9e:	9b e1       	ldi	r25, 0x1B	; 27
    5fa0:	0e 94 3e 05 	call	0xa7c	; 0xa7c <buffer_append>
	xSemaphoreGive(xUartMutex);
    5fa4:	60 e0       	ldi	r22, 0x00	; 0
    5fa6:	70 e0       	ldi	r23, 0x00	; 0
    5fa8:	80 91 33 1b 	lds	r24, 0x1B33	; 0x801b33 <xUartMutex>
    5fac:	90 91 34 1b 	lds	r25, 0x1B34	; 0x801b34 <xUartMutex+0x1>
    5fb0:	0e 94 f0 1c 	call	0x39e0	; 0x39e0 <xQueueGive>
}
    5fb4:	df 91       	pop	r29
    5fb6:	cf 91       	pop	r28
    5fb8:	1f 91       	pop	r17
    5fba:	0f 91       	pop	r16
    5fbc:	08 95       	ret

00005fbe <vUSART_set_receive_callback>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
    5fbe:	90 93 73 1b 	sts	0x1B73, r25	; 0x801b73 <receive_callback+0x1>
    5fc2:	80 93 72 1b 	sts	0x1B72, r24	; 0x801b72 <receive_callback>
    5fc6:	08 95       	ret

00005fc8 <__vector_51>:
		vTaskDelay(10*portTICK_PERIOD_MS);
	}
}


ISR(USART2_RX_vect){
    5fc8:	1f 92       	push	r1
    5fca:	0f 92       	push	r0
    5fcc:	0f b6       	in	r0, 0x3f	; 63
    5fce:	0f 92       	push	r0
    5fd0:	11 24       	eor	r1, r1
    5fd2:	0b b6       	in	r0, 0x3b	; 59
    5fd4:	0f 92       	push	r0
    5fd6:	cf 92       	push	r12
    5fd8:	df 92       	push	r13
    5fda:	ef 92       	push	r14
    5fdc:	ff 92       	push	r15
    5fde:	0f 93       	push	r16
    5fe0:	1f 93       	push	r17
    5fe2:	2f 93       	push	r18
    5fe4:	3f 93       	push	r19
    5fe6:	4f 93       	push	r20
    5fe8:	5f 93       	push	r21
    5fea:	6f 93       	push	r22
    5fec:	7f 93       	push	r23
    5fee:	8f 93       	push	r24
    5ff0:	9f 93       	push	r25
    5ff2:	af 93       	push	r26
    5ff4:	bf 93       	push	r27
    5ff6:	cf 93       	push	r28
    5ff8:	df 93       	push	r29
    5ffa:	ef 93       	push	r30
    5ffc:	ff 93       	push	r31
	static uint8_t input_buffer[100];
	static uint16_t input_index = 0;
	input_buffer[input_index++] = UDR2;
    5ffe:	80 91 0b 1b 	lds	r24, 0x1B0B	; 0x801b0b <input_index.2279>
    6002:	90 91 0c 1b 	lds	r25, 0x1B0C	; 0x801b0c <input_index.2279+0x1>
    6006:	ec 01       	movw	r28, r24
    6008:	21 96       	adiw	r28, 0x01	; 1
    600a:	d0 93 0c 1b 	sts	0x1B0C, r29	; 0x801b0c <input_index.2279+0x1>
    600e:	c0 93 0b 1b 	sts	0x1B0B, r28	; 0x801b0b <input_index.2279>
    6012:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    6016:	fc 01       	movw	r30, r24
    6018:	e9 55       	subi	r30, 0x59	; 89
    601a:	f5 4e       	sbci	r31, 0xE5	; 229
    601c:	20 83       	st	Z, r18
	if(input_buffer[input_index-1] == 0x00) {
    601e:	21 11       	cpse	r18, r1
    6020:	1d c0       	rjmp	.+58     	; 0x605c <__vector_51+0x94>
		if(frame_receiver != NULL) {
    6022:	c0 90 0d 1b 	lds	r12, 0x1B0D	; 0x801b0d <frame_receiver>
    6026:	d0 90 0e 1b 	lds	r13, 0x1B0E	; 0x801b0e <frame_receiver+0x1>
    602a:	c1 14       	cp	r12, r1
    602c:	d1 04       	cpc	r13, r1
    602e:	89 f0       	breq	.+34     	; 0x6052 <__vector_51+0x8a>
			memcpy(receive_buffer, input_buffer, input_index);
    6030:	ae 01       	movw	r20, r28
    6032:	67 ea       	ldi	r22, 0xA7	; 167
    6034:	7a e1       	ldi	r23, 0x1A	; 26
    6036:	84 e7       	ldi	r24, 0x74	; 116
    6038:	9b e1       	ldi	r25, 0x1B	; 27
    603a:	0e 94 4b 38 	call	0x7096	; 0x7096 <memcpy>
			xTaskNotifyFromISR(frame_receiver, input_index, eSetValueWithoutOverwrite, NULL);
    603e:	ae 01       	movw	r20, r28
    6040:	60 e0       	ldi	r22, 0x00	; 0
    6042:	70 e0       	ldi	r23, 0x00	; 0
    6044:	e1 2c       	mov	r14, r1
    6046:	f1 2c       	mov	r15, r1
    6048:	00 e0       	ldi	r16, 0x00	; 0
    604a:	10 e0       	ldi	r17, 0x00	; 0
    604c:	24 e0       	ldi	r18, 0x04	; 4
    604e:	c6 01       	movw	r24, r12
    6050:	df dd       	rcall	.-1090   	; 0x5c10 <xTaskGenericNotifyFromISR>
		}
		input_index = 0;
    6052:	10 92 0c 1b 	sts	0x1B0C, r1	; 0x801b0c <input_index.2279+0x1>
    6056:	10 92 0b 1b 	sts	0x1B0B, r1	; 0x801b0b <input_index.2279>
    605a:	0b c0       	rjmp	.+22     	; 0x6072 <__vector_51+0xaa>
	}
	if(input_index > 100) input_index = 0; // Something went wrong, received too many bytes
    605c:	80 91 0b 1b 	lds	r24, 0x1B0B	; 0x801b0b <input_index.2279>
    6060:	90 91 0c 1b 	lds	r25, 0x1B0C	; 0x801b0c <input_index.2279+0x1>
    6064:	85 36       	cpi	r24, 0x65	; 101
    6066:	91 05       	cpc	r25, r1
    6068:	20 f0       	brcs	.+8      	; 0x6072 <__vector_51+0xaa>
    606a:	10 92 0c 1b 	sts	0x1B0C, r1	; 0x801b0c <input_index.2279+0x1>
    606e:	10 92 0b 1b 	sts	0x1B0B, r1	; 0x801b0b <input_index.2279>
    6072:	ff 91       	pop	r31
    6074:	ef 91       	pop	r30
    6076:	df 91       	pop	r29
    6078:	cf 91       	pop	r28
    607a:	bf 91       	pop	r27
    607c:	af 91       	pop	r26
    607e:	9f 91       	pop	r25
    6080:	8f 91       	pop	r24
    6082:	7f 91       	pop	r23
    6084:	6f 91       	pop	r22
    6086:	5f 91       	pop	r21
    6088:	4f 91       	pop	r20
    608a:	3f 91       	pop	r19
    608c:	2f 91       	pop	r18
    608e:	1f 91       	pop	r17
    6090:	0f 91       	pop	r16
    6092:	ff 90       	pop	r15
    6094:	ef 90       	pop	r14
    6096:	df 90       	pop	r13
    6098:	cf 90       	pop	r12
    609a:	0f 90       	pop	r0
    609c:	0b be       	out	0x3b, r0	; 59
    609e:	0f 90       	pop	r0
    60a0:	0f be       	out	0x3f, r0	; 63
    60a2:	0f 90       	pop	r0
    60a4:	1f 90       	pop	r1
    60a6:	18 95       	reti

000060a8 <__subsf3>:
    60a8:	50 58       	subi	r21, 0x80	; 128

000060aa <__addsf3>:
    60aa:	bb 27       	eor	r27, r27
    60ac:	aa 27       	eor	r26, r26
    60ae:	0e d0       	rcall	.+28     	; 0x60cc <__addsf3x>
    60b0:	27 c2       	rjmp	.+1102   	; 0x6500 <__fp_round>
    60b2:	f0 d1       	rcall	.+992    	; 0x6494 <__fp_pscA>
    60b4:	30 f0       	brcs	.+12     	; 0x60c2 <__addsf3+0x18>
    60b6:	f5 d1       	rcall	.+1002   	; 0x64a2 <__fp_pscB>
    60b8:	20 f0       	brcs	.+8      	; 0x60c2 <__addsf3+0x18>
    60ba:	31 f4       	brne	.+12     	; 0x60c8 <__addsf3+0x1e>
    60bc:	9f 3f       	cpi	r25, 0xFF	; 255
    60be:	11 f4       	brne	.+4      	; 0x60c4 <__addsf3+0x1a>
    60c0:	1e f4       	brtc	.+6      	; 0x60c8 <__addsf3+0x1e>
    60c2:	c0 c1       	rjmp	.+896    	; 0x6444 <__fp_nan>
    60c4:	0e f4       	brtc	.+2      	; 0x60c8 <__addsf3+0x1e>
    60c6:	e0 95       	com	r30
    60c8:	e7 fb       	bst	r30, 7
    60ca:	b6 c1       	rjmp	.+876    	; 0x6438 <__fp_inf>

000060cc <__addsf3x>:
    60cc:	e9 2f       	mov	r30, r25
    60ce:	3a d2       	rcall	.+1140   	; 0x6544 <__fp_split3>
    60d0:	80 f3       	brcs	.-32     	; 0x60b2 <__addsf3+0x8>
    60d2:	ba 17       	cp	r27, r26
    60d4:	62 07       	cpc	r22, r18
    60d6:	73 07       	cpc	r23, r19
    60d8:	84 07       	cpc	r24, r20
    60da:	95 07       	cpc	r25, r21
    60dc:	18 f0       	brcs	.+6      	; 0x60e4 <__addsf3x+0x18>
    60de:	71 f4       	brne	.+28     	; 0x60fc <__addsf3x+0x30>
    60e0:	9e f5       	brtc	.+102    	; 0x6148 <__addsf3x+0x7c>
    60e2:	52 c2       	rjmp	.+1188   	; 0x6588 <__fp_zero>
    60e4:	0e f4       	brtc	.+2      	; 0x60e8 <__addsf3x+0x1c>
    60e6:	e0 95       	com	r30
    60e8:	0b 2e       	mov	r0, r27
    60ea:	ba 2f       	mov	r27, r26
    60ec:	a0 2d       	mov	r26, r0
    60ee:	0b 01       	movw	r0, r22
    60f0:	b9 01       	movw	r22, r18
    60f2:	90 01       	movw	r18, r0
    60f4:	0c 01       	movw	r0, r24
    60f6:	ca 01       	movw	r24, r20
    60f8:	a0 01       	movw	r20, r0
    60fa:	11 24       	eor	r1, r1
    60fc:	ff 27       	eor	r31, r31
    60fe:	59 1b       	sub	r21, r25
    6100:	99 f0       	breq	.+38     	; 0x6128 <__addsf3x+0x5c>
    6102:	59 3f       	cpi	r21, 0xF9	; 249
    6104:	50 f4       	brcc	.+20     	; 0x611a <__addsf3x+0x4e>
    6106:	50 3e       	cpi	r21, 0xE0	; 224
    6108:	68 f1       	brcs	.+90     	; 0x6164 <__addsf3x+0x98>
    610a:	1a 16       	cp	r1, r26
    610c:	f0 40       	sbci	r31, 0x00	; 0
    610e:	a2 2f       	mov	r26, r18
    6110:	23 2f       	mov	r18, r19
    6112:	34 2f       	mov	r19, r20
    6114:	44 27       	eor	r20, r20
    6116:	58 5f       	subi	r21, 0xF8	; 248
    6118:	f3 cf       	rjmp	.-26     	; 0x6100 <__addsf3x+0x34>
    611a:	46 95       	lsr	r20
    611c:	37 95       	ror	r19
    611e:	27 95       	ror	r18
    6120:	a7 95       	ror	r26
    6122:	f0 40       	sbci	r31, 0x00	; 0
    6124:	53 95       	inc	r21
    6126:	c9 f7       	brne	.-14     	; 0x611a <__addsf3x+0x4e>
    6128:	7e f4       	brtc	.+30     	; 0x6148 <__addsf3x+0x7c>
    612a:	1f 16       	cp	r1, r31
    612c:	ba 0b       	sbc	r27, r26
    612e:	62 0b       	sbc	r22, r18
    6130:	73 0b       	sbc	r23, r19
    6132:	84 0b       	sbc	r24, r20
    6134:	ba f0       	brmi	.+46     	; 0x6164 <__addsf3x+0x98>
    6136:	91 50       	subi	r25, 0x01	; 1
    6138:	a1 f0       	breq	.+40     	; 0x6162 <__addsf3x+0x96>
    613a:	ff 0f       	add	r31, r31
    613c:	bb 1f       	adc	r27, r27
    613e:	66 1f       	adc	r22, r22
    6140:	77 1f       	adc	r23, r23
    6142:	88 1f       	adc	r24, r24
    6144:	c2 f7       	brpl	.-16     	; 0x6136 <__addsf3x+0x6a>
    6146:	0e c0       	rjmp	.+28     	; 0x6164 <__addsf3x+0x98>
    6148:	ba 0f       	add	r27, r26
    614a:	62 1f       	adc	r22, r18
    614c:	73 1f       	adc	r23, r19
    614e:	84 1f       	adc	r24, r20
    6150:	48 f4       	brcc	.+18     	; 0x6164 <__addsf3x+0x98>
    6152:	87 95       	ror	r24
    6154:	77 95       	ror	r23
    6156:	67 95       	ror	r22
    6158:	b7 95       	ror	r27
    615a:	f7 95       	ror	r31
    615c:	9e 3f       	cpi	r25, 0xFE	; 254
    615e:	08 f0       	brcs	.+2      	; 0x6162 <__addsf3x+0x96>
    6160:	b3 cf       	rjmp	.-154    	; 0x60c8 <__addsf3+0x1e>
    6162:	93 95       	inc	r25
    6164:	88 0f       	add	r24, r24
    6166:	08 f0       	brcs	.+2      	; 0x616a <__addsf3x+0x9e>
    6168:	99 27       	eor	r25, r25
    616a:	ee 0f       	add	r30, r30
    616c:	97 95       	ror	r25
    616e:	87 95       	ror	r24
    6170:	08 95       	ret
    6172:	90 d1       	rcall	.+800    	; 0x6494 <__fp_pscA>
    6174:	58 f0       	brcs	.+22     	; 0x618c <__addsf3x+0xc0>
    6176:	80 e8       	ldi	r24, 0x80	; 128
    6178:	91 e0       	ldi	r25, 0x01	; 1
    617a:	09 f4       	brne	.+2      	; 0x617e <__addsf3x+0xb2>
    617c:	9e ef       	ldi	r25, 0xFE	; 254
    617e:	91 d1       	rcall	.+802    	; 0x64a2 <__fp_pscB>
    6180:	28 f0       	brcs	.+10     	; 0x618c <__addsf3x+0xc0>
    6182:	40 e8       	ldi	r20, 0x80	; 128
    6184:	51 e0       	ldi	r21, 0x01	; 1
    6186:	59 f4       	brne	.+22     	; 0x619e <atan2+0xe>
    6188:	5e ef       	ldi	r21, 0xFE	; 254
    618a:	09 c0       	rjmp	.+18     	; 0x619e <atan2+0xe>
    618c:	5b c1       	rjmp	.+694    	; 0x6444 <__fp_nan>
    618e:	fc c1       	rjmp	.+1016   	; 0x6588 <__fp_zero>

00006190 <atan2>:
    6190:	e9 2f       	mov	r30, r25
    6192:	e0 78       	andi	r30, 0x80	; 128
    6194:	d7 d1       	rcall	.+942    	; 0x6544 <__fp_split3>
    6196:	68 f3       	brcs	.-38     	; 0x6172 <__addsf3x+0xa6>
    6198:	09 2e       	mov	r0, r25
    619a:	05 2a       	or	r0, r21
    619c:	c1 f3       	breq	.-16     	; 0x618e <__addsf3x+0xc2>
    619e:	26 17       	cp	r18, r22
    61a0:	37 07       	cpc	r19, r23
    61a2:	48 07       	cpc	r20, r24
    61a4:	59 07       	cpc	r21, r25
    61a6:	38 f0       	brcs	.+14     	; 0x61b6 <atan2+0x26>
    61a8:	0e 2e       	mov	r0, r30
    61aa:	07 f8       	bld	r0, 7
    61ac:	e0 25       	eor	r30, r0
    61ae:	69 f0       	breq	.+26     	; 0x61ca <atan2+0x3a>
    61b0:	e0 25       	eor	r30, r0
    61b2:	e0 64       	ori	r30, 0x40	; 64
    61b4:	0a c0       	rjmp	.+20     	; 0x61ca <atan2+0x3a>
    61b6:	ef 63       	ori	r30, 0x3F	; 63
    61b8:	07 f8       	bld	r0, 7
    61ba:	00 94       	com	r0
    61bc:	07 fa       	bst	r0, 7
    61be:	db 01       	movw	r26, r22
    61c0:	b9 01       	movw	r22, r18
    61c2:	9d 01       	movw	r18, r26
    61c4:	dc 01       	movw	r26, r24
    61c6:	ca 01       	movw	r24, r20
    61c8:	ad 01       	movw	r20, r26
    61ca:	ef 93       	push	r30
    61cc:	4a d0       	rcall	.+148    	; 0x6262 <__divsf3_pse>
    61ce:	98 d1       	rcall	.+816    	; 0x6500 <__fp_round>
    61d0:	0a d0       	rcall	.+20     	; 0x61e6 <atan>
    61d2:	5f 91       	pop	r21
    61d4:	55 23       	and	r21, r21
    61d6:	31 f0       	breq	.+12     	; 0x61e4 <atan2+0x54>
    61d8:	2b ed       	ldi	r18, 0xDB	; 219
    61da:	3f e0       	ldi	r19, 0x0F	; 15
    61dc:	49 e4       	ldi	r20, 0x49	; 73
    61de:	50 fd       	sbrc	r21, 0
    61e0:	49 ec       	ldi	r20, 0xC9	; 201
    61e2:	63 cf       	rjmp	.-314    	; 0x60aa <__addsf3>
    61e4:	08 95       	ret

000061e6 <atan>:
    61e6:	df 93       	push	r29
    61e8:	dd 27       	eor	r29, r29
    61ea:	b9 2f       	mov	r27, r25
    61ec:	bf 77       	andi	r27, 0x7F	; 127
    61ee:	40 e8       	ldi	r20, 0x80	; 128
    61f0:	5f e3       	ldi	r21, 0x3F	; 63
    61f2:	16 16       	cp	r1, r22
    61f4:	17 06       	cpc	r1, r23
    61f6:	48 07       	cpc	r20, r24
    61f8:	5b 07       	cpc	r21, r27
    61fa:	10 f4       	brcc	.+4      	; 0x6200 <atan+0x1a>
    61fc:	d9 2f       	mov	r29, r25
    61fe:	cf d1       	rcall	.+926    	; 0x659e <inverse>
    6200:	9f 93       	push	r25
    6202:	8f 93       	push	r24
    6204:	7f 93       	push	r23
    6206:	6f 93       	push	r22
    6208:	7c d2       	rcall	.+1272   	; 0x6702 <square>
    620a:	e4 ee       	ldi	r30, 0xE4	; 228
    620c:	f0 e0       	ldi	r31, 0x00	; 0
    620e:	1d d1       	rcall	.+570    	; 0x644a <__fp_powser>
    6210:	77 d1       	rcall	.+750    	; 0x6500 <__fp_round>
    6212:	2f 91       	pop	r18
    6214:	3f 91       	pop	r19
    6216:	4f 91       	pop	r20
    6218:	5f 91       	pop	r21
    621a:	d4 d1       	rcall	.+936    	; 0x65c4 <__mulsf3x>
    621c:	dd 23       	and	r29, r29
    621e:	49 f0       	breq	.+18     	; 0x6232 <atan+0x4c>
    6220:	90 58       	subi	r25, 0x80	; 128
    6222:	a2 ea       	ldi	r26, 0xA2	; 162
    6224:	2a ed       	ldi	r18, 0xDA	; 218
    6226:	3f e0       	ldi	r19, 0x0F	; 15
    6228:	49 ec       	ldi	r20, 0xC9	; 201
    622a:	5f e3       	ldi	r21, 0x3F	; 63
    622c:	d0 78       	andi	r29, 0x80	; 128
    622e:	5d 27       	eor	r21, r29
    6230:	4d df       	rcall	.-358    	; 0x60cc <__addsf3x>
    6232:	df 91       	pop	r29
    6234:	65 c1       	rjmp	.+714    	; 0x6500 <__fp_round>

00006236 <__cmpsf2>:
    6236:	dc d0       	rcall	.+440    	; 0x63f0 <__fp_cmp>
    6238:	08 f4       	brcc	.+2      	; 0x623c <__cmpsf2+0x6>
    623a:	81 e0       	ldi	r24, 0x01	; 1
    623c:	08 95       	ret

0000623e <cos>:
    623e:	39 d1       	rcall	.+626    	; 0x64b2 <__fp_rempio2>
    6240:	e3 95       	inc	r30
    6242:	6f c1       	rjmp	.+734    	; 0x6522 <__fp_sinus>

00006244 <__divsf3>:
    6244:	0c d0       	rcall	.+24     	; 0x625e <__divsf3x>
    6246:	5c c1       	rjmp	.+696    	; 0x6500 <__fp_round>
    6248:	2c d1       	rcall	.+600    	; 0x64a2 <__fp_pscB>
    624a:	40 f0       	brcs	.+16     	; 0x625c <__divsf3+0x18>
    624c:	23 d1       	rcall	.+582    	; 0x6494 <__fp_pscA>
    624e:	30 f0       	brcs	.+12     	; 0x625c <__divsf3+0x18>
    6250:	21 f4       	brne	.+8      	; 0x625a <__divsf3+0x16>
    6252:	5f 3f       	cpi	r21, 0xFF	; 255
    6254:	19 f0       	breq	.+6      	; 0x625c <__divsf3+0x18>
    6256:	f0 c0       	rjmp	.+480    	; 0x6438 <__fp_inf>
    6258:	51 11       	cpse	r21, r1
    625a:	97 c1       	rjmp	.+814    	; 0x658a <__fp_szero>
    625c:	f3 c0       	rjmp	.+486    	; 0x6444 <__fp_nan>

0000625e <__divsf3x>:
    625e:	72 d1       	rcall	.+740    	; 0x6544 <__fp_split3>
    6260:	98 f3       	brcs	.-26     	; 0x6248 <__divsf3+0x4>

00006262 <__divsf3_pse>:
    6262:	99 23       	and	r25, r25
    6264:	c9 f3       	breq	.-14     	; 0x6258 <__divsf3+0x14>
    6266:	55 23       	and	r21, r21
    6268:	b1 f3       	breq	.-20     	; 0x6256 <__divsf3+0x12>
    626a:	95 1b       	sub	r25, r21
    626c:	55 0b       	sbc	r21, r21
    626e:	bb 27       	eor	r27, r27
    6270:	aa 27       	eor	r26, r26
    6272:	62 17       	cp	r22, r18
    6274:	73 07       	cpc	r23, r19
    6276:	84 07       	cpc	r24, r20
    6278:	38 f0       	brcs	.+14     	; 0x6288 <__divsf3_pse+0x26>
    627a:	9f 5f       	subi	r25, 0xFF	; 255
    627c:	5f 4f       	sbci	r21, 0xFF	; 255
    627e:	22 0f       	add	r18, r18
    6280:	33 1f       	adc	r19, r19
    6282:	44 1f       	adc	r20, r20
    6284:	aa 1f       	adc	r26, r26
    6286:	a9 f3       	breq	.-22     	; 0x6272 <__divsf3_pse+0x10>
    6288:	33 d0       	rcall	.+102    	; 0x62f0 <__divsf3_pse+0x8e>
    628a:	0e 2e       	mov	r0, r30
    628c:	3a f0       	brmi	.+14     	; 0x629c <__divsf3_pse+0x3a>
    628e:	e0 e8       	ldi	r30, 0x80	; 128
    6290:	30 d0       	rcall	.+96     	; 0x62f2 <__divsf3_pse+0x90>
    6292:	91 50       	subi	r25, 0x01	; 1
    6294:	50 40       	sbci	r21, 0x00	; 0
    6296:	e6 95       	lsr	r30
    6298:	00 1c       	adc	r0, r0
    629a:	ca f7       	brpl	.-14     	; 0x628e <__divsf3_pse+0x2c>
    629c:	29 d0       	rcall	.+82     	; 0x62f0 <__divsf3_pse+0x8e>
    629e:	fe 2f       	mov	r31, r30
    62a0:	27 d0       	rcall	.+78     	; 0x62f0 <__divsf3_pse+0x8e>
    62a2:	66 0f       	add	r22, r22
    62a4:	77 1f       	adc	r23, r23
    62a6:	88 1f       	adc	r24, r24
    62a8:	bb 1f       	adc	r27, r27
    62aa:	26 17       	cp	r18, r22
    62ac:	37 07       	cpc	r19, r23
    62ae:	48 07       	cpc	r20, r24
    62b0:	ab 07       	cpc	r26, r27
    62b2:	b0 e8       	ldi	r27, 0x80	; 128
    62b4:	09 f0       	breq	.+2      	; 0x62b8 <__divsf3_pse+0x56>
    62b6:	bb 0b       	sbc	r27, r27
    62b8:	80 2d       	mov	r24, r0
    62ba:	bf 01       	movw	r22, r30
    62bc:	ff 27       	eor	r31, r31
    62be:	93 58       	subi	r25, 0x83	; 131
    62c0:	5f 4f       	sbci	r21, 0xFF	; 255
    62c2:	2a f0       	brmi	.+10     	; 0x62ce <__divsf3_pse+0x6c>
    62c4:	9e 3f       	cpi	r25, 0xFE	; 254
    62c6:	51 05       	cpc	r21, r1
    62c8:	68 f0       	brcs	.+26     	; 0x62e4 <__divsf3_pse+0x82>
    62ca:	b6 c0       	rjmp	.+364    	; 0x6438 <__fp_inf>
    62cc:	5e c1       	rjmp	.+700    	; 0x658a <__fp_szero>
    62ce:	5f 3f       	cpi	r21, 0xFF	; 255
    62d0:	ec f3       	brlt	.-6      	; 0x62cc <__divsf3_pse+0x6a>
    62d2:	98 3e       	cpi	r25, 0xE8	; 232
    62d4:	dc f3       	brlt	.-10     	; 0x62cc <__divsf3_pse+0x6a>
    62d6:	86 95       	lsr	r24
    62d8:	77 95       	ror	r23
    62da:	67 95       	ror	r22
    62dc:	b7 95       	ror	r27
    62de:	f7 95       	ror	r31
    62e0:	9f 5f       	subi	r25, 0xFF	; 255
    62e2:	c9 f7       	brne	.-14     	; 0x62d6 <__divsf3_pse+0x74>
    62e4:	88 0f       	add	r24, r24
    62e6:	91 1d       	adc	r25, r1
    62e8:	96 95       	lsr	r25
    62ea:	87 95       	ror	r24
    62ec:	97 f9       	bld	r25, 7
    62ee:	08 95       	ret
    62f0:	e1 e0       	ldi	r30, 0x01	; 1
    62f2:	66 0f       	add	r22, r22
    62f4:	77 1f       	adc	r23, r23
    62f6:	88 1f       	adc	r24, r24
    62f8:	bb 1f       	adc	r27, r27
    62fa:	62 17       	cp	r22, r18
    62fc:	73 07       	cpc	r23, r19
    62fe:	84 07       	cpc	r24, r20
    6300:	ba 07       	cpc	r27, r26
    6302:	20 f0       	brcs	.+8      	; 0x630c <__divsf3_pse+0xaa>
    6304:	62 1b       	sub	r22, r18
    6306:	73 0b       	sbc	r23, r19
    6308:	84 0b       	sbc	r24, r20
    630a:	ba 0b       	sbc	r27, r26
    630c:	ee 1f       	adc	r30, r30
    630e:	88 f7       	brcc	.-30     	; 0x62f2 <__divsf3_pse+0x90>
    6310:	e0 95       	com	r30
    6312:	08 95       	ret

00006314 <__fixsfsi>:
    6314:	04 d0       	rcall	.+8      	; 0x631e <__fixunssfsi>
    6316:	68 94       	set
    6318:	b1 11       	cpse	r27, r1
    631a:	37 c1       	rjmp	.+622    	; 0x658a <__fp_szero>
    631c:	08 95       	ret

0000631e <__fixunssfsi>:
    631e:	1a d1       	rcall	.+564    	; 0x6554 <__fp_splitA>
    6320:	88 f0       	brcs	.+34     	; 0x6344 <__fixunssfsi+0x26>
    6322:	9f 57       	subi	r25, 0x7F	; 127
    6324:	90 f0       	brcs	.+36     	; 0x634a <__fixunssfsi+0x2c>
    6326:	b9 2f       	mov	r27, r25
    6328:	99 27       	eor	r25, r25
    632a:	b7 51       	subi	r27, 0x17	; 23
    632c:	a0 f0       	brcs	.+40     	; 0x6356 <__fixunssfsi+0x38>
    632e:	d1 f0       	breq	.+52     	; 0x6364 <__fixunssfsi+0x46>
    6330:	66 0f       	add	r22, r22
    6332:	77 1f       	adc	r23, r23
    6334:	88 1f       	adc	r24, r24
    6336:	99 1f       	adc	r25, r25
    6338:	1a f0       	brmi	.+6      	; 0x6340 <__fixunssfsi+0x22>
    633a:	ba 95       	dec	r27
    633c:	c9 f7       	brne	.-14     	; 0x6330 <__fixunssfsi+0x12>
    633e:	12 c0       	rjmp	.+36     	; 0x6364 <__fixunssfsi+0x46>
    6340:	b1 30       	cpi	r27, 0x01	; 1
    6342:	81 f0       	breq	.+32     	; 0x6364 <__fixunssfsi+0x46>
    6344:	21 d1       	rcall	.+578    	; 0x6588 <__fp_zero>
    6346:	b1 e0       	ldi	r27, 0x01	; 1
    6348:	08 95       	ret
    634a:	1e c1       	rjmp	.+572    	; 0x6588 <__fp_zero>
    634c:	67 2f       	mov	r22, r23
    634e:	78 2f       	mov	r23, r24
    6350:	88 27       	eor	r24, r24
    6352:	b8 5f       	subi	r27, 0xF8	; 248
    6354:	39 f0       	breq	.+14     	; 0x6364 <__fixunssfsi+0x46>
    6356:	b9 3f       	cpi	r27, 0xF9	; 249
    6358:	cc f3       	brlt	.-14     	; 0x634c <__fixunssfsi+0x2e>
    635a:	86 95       	lsr	r24
    635c:	77 95       	ror	r23
    635e:	67 95       	ror	r22
    6360:	b3 95       	inc	r27
    6362:	d9 f7       	brne	.-10     	; 0x635a <__fixunssfsi+0x3c>
    6364:	3e f4       	brtc	.+14     	; 0x6374 <__fixunssfsi+0x56>
    6366:	90 95       	com	r25
    6368:	80 95       	com	r24
    636a:	70 95       	com	r23
    636c:	61 95       	neg	r22
    636e:	7f 4f       	sbci	r23, 0xFF	; 255
    6370:	8f 4f       	sbci	r24, 0xFF	; 255
    6372:	9f 4f       	sbci	r25, 0xFF	; 255
    6374:	08 95       	ret

00006376 <__floatunsisf>:
    6376:	e8 94       	clt
    6378:	09 c0       	rjmp	.+18     	; 0x638c <__floatsisf+0x12>

0000637a <__floatsisf>:
    637a:	97 fb       	bst	r25, 7
    637c:	3e f4       	brtc	.+14     	; 0x638c <__floatsisf+0x12>
    637e:	90 95       	com	r25
    6380:	80 95       	com	r24
    6382:	70 95       	com	r23
    6384:	61 95       	neg	r22
    6386:	7f 4f       	sbci	r23, 0xFF	; 255
    6388:	8f 4f       	sbci	r24, 0xFF	; 255
    638a:	9f 4f       	sbci	r25, 0xFF	; 255
    638c:	99 23       	and	r25, r25
    638e:	a9 f0       	breq	.+42     	; 0x63ba <__floatsisf+0x40>
    6390:	f9 2f       	mov	r31, r25
    6392:	96 e9       	ldi	r25, 0x96	; 150
    6394:	bb 27       	eor	r27, r27
    6396:	93 95       	inc	r25
    6398:	f6 95       	lsr	r31
    639a:	87 95       	ror	r24
    639c:	77 95       	ror	r23
    639e:	67 95       	ror	r22
    63a0:	b7 95       	ror	r27
    63a2:	f1 11       	cpse	r31, r1
    63a4:	f8 cf       	rjmp	.-16     	; 0x6396 <__floatsisf+0x1c>
    63a6:	fa f4       	brpl	.+62     	; 0x63e6 <__floatsisf+0x6c>
    63a8:	bb 0f       	add	r27, r27
    63aa:	11 f4       	brne	.+4      	; 0x63b0 <__floatsisf+0x36>
    63ac:	60 ff       	sbrs	r22, 0
    63ae:	1b c0       	rjmp	.+54     	; 0x63e6 <__floatsisf+0x6c>
    63b0:	6f 5f       	subi	r22, 0xFF	; 255
    63b2:	7f 4f       	sbci	r23, 0xFF	; 255
    63b4:	8f 4f       	sbci	r24, 0xFF	; 255
    63b6:	9f 4f       	sbci	r25, 0xFF	; 255
    63b8:	16 c0       	rjmp	.+44     	; 0x63e6 <__floatsisf+0x6c>
    63ba:	88 23       	and	r24, r24
    63bc:	11 f0       	breq	.+4      	; 0x63c2 <__floatsisf+0x48>
    63be:	96 e9       	ldi	r25, 0x96	; 150
    63c0:	11 c0       	rjmp	.+34     	; 0x63e4 <__floatsisf+0x6a>
    63c2:	77 23       	and	r23, r23
    63c4:	21 f0       	breq	.+8      	; 0x63ce <__floatsisf+0x54>
    63c6:	9e e8       	ldi	r25, 0x8E	; 142
    63c8:	87 2f       	mov	r24, r23
    63ca:	76 2f       	mov	r23, r22
    63cc:	05 c0       	rjmp	.+10     	; 0x63d8 <__floatsisf+0x5e>
    63ce:	66 23       	and	r22, r22
    63d0:	71 f0       	breq	.+28     	; 0x63ee <__floatsisf+0x74>
    63d2:	96 e8       	ldi	r25, 0x86	; 134
    63d4:	86 2f       	mov	r24, r22
    63d6:	70 e0       	ldi	r23, 0x00	; 0
    63d8:	60 e0       	ldi	r22, 0x00	; 0
    63da:	2a f0       	brmi	.+10     	; 0x63e6 <__floatsisf+0x6c>
    63dc:	9a 95       	dec	r25
    63de:	66 0f       	add	r22, r22
    63e0:	77 1f       	adc	r23, r23
    63e2:	88 1f       	adc	r24, r24
    63e4:	da f7       	brpl	.-10     	; 0x63dc <__floatsisf+0x62>
    63e6:	88 0f       	add	r24, r24
    63e8:	96 95       	lsr	r25
    63ea:	87 95       	ror	r24
    63ec:	97 f9       	bld	r25, 7
    63ee:	08 95       	ret

000063f0 <__fp_cmp>:
    63f0:	99 0f       	add	r25, r25
    63f2:	00 08       	sbc	r0, r0
    63f4:	55 0f       	add	r21, r21
    63f6:	aa 0b       	sbc	r26, r26
    63f8:	e0 e8       	ldi	r30, 0x80	; 128
    63fa:	fe ef       	ldi	r31, 0xFE	; 254
    63fc:	16 16       	cp	r1, r22
    63fe:	17 06       	cpc	r1, r23
    6400:	e8 07       	cpc	r30, r24
    6402:	f9 07       	cpc	r31, r25
    6404:	c0 f0       	brcs	.+48     	; 0x6436 <__fp_cmp+0x46>
    6406:	12 16       	cp	r1, r18
    6408:	13 06       	cpc	r1, r19
    640a:	e4 07       	cpc	r30, r20
    640c:	f5 07       	cpc	r31, r21
    640e:	98 f0       	brcs	.+38     	; 0x6436 <__fp_cmp+0x46>
    6410:	62 1b       	sub	r22, r18
    6412:	73 0b       	sbc	r23, r19
    6414:	84 0b       	sbc	r24, r20
    6416:	95 0b       	sbc	r25, r21
    6418:	39 f4       	brne	.+14     	; 0x6428 <__fp_cmp+0x38>
    641a:	0a 26       	eor	r0, r26
    641c:	61 f0       	breq	.+24     	; 0x6436 <__fp_cmp+0x46>
    641e:	23 2b       	or	r18, r19
    6420:	24 2b       	or	r18, r20
    6422:	25 2b       	or	r18, r21
    6424:	21 f4       	brne	.+8      	; 0x642e <__fp_cmp+0x3e>
    6426:	08 95       	ret
    6428:	0a 26       	eor	r0, r26
    642a:	09 f4       	brne	.+2      	; 0x642e <__fp_cmp+0x3e>
    642c:	a1 40       	sbci	r26, 0x01	; 1
    642e:	a6 95       	lsr	r26
    6430:	8f ef       	ldi	r24, 0xFF	; 255
    6432:	81 1d       	adc	r24, r1
    6434:	81 1d       	adc	r24, r1
    6436:	08 95       	ret

00006438 <__fp_inf>:
    6438:	97 f9       	bld	r25, 7
    643a:	9f 67       	ori	r25, 0x7F	; 127
    643c:	80 e8       	ldi	r24, 0x80	; 128
    643e:	70 e0       	ldi	r23, 0x00	; 0
    6440:	60 e0       	ldi	r22, 0x00	; 0
    6442:	08 95       	ret

00006444 <__fp_nan>:
    6444:	9f ef       	ldi	r25, 0xFF	; 255
    6446:	80 ec       	ldi	r24, 0xC0	; 192
    6448:	08 95       	ret

0000644a <__fp_powser>:
    644a:	df 93       	push	r29
    644c:	cf 93       	push	r28
    644e:	1f 93       	push	r17
    6450:	0f 93       	push	r16
    6452:	ff 92       	push	r15
    6454:	ef 92       	push	r14
    6456:	df 92       	push	r13
    6458:	7b 01       	movw	r14, r22
    645a:	8c 01       	movw	r16, r24
    645c:	68 94       	set
    645e:	05 c0       	rjmp	.+10     	; 0x646a <__fp_powser+0x20>
    6460:	da 2e       	mov	r13, r26
    6462:	ef 01       	movw	r28, r30
    6464:	af d0       	rcall	.+350    	; 0x65c4 <__mulsf3x>
    6466:	fe 01       	movw	r30, r28
    6468:	e8 94       	clt
    646a:	a5 91       	lpm	r26, Z+
    646c:	25 91       	lpm	r18, Z+
    646e:	35 91       	lpm	r19, Z+
    6470:	45 91       	lpm	r20, Z+
    6472:	55 91       	lpm	r21, Z+
    6474:	ae f3       	brts	.-22     	; 0x6460 <__fp_powser+0x16>
    6476:	ef 01       	movw	r28, r30
    6478:	29 de       	rcall	.-942    	; 0x60cc <__addsf3x>
    647a:	fe 01       	movw	r30, r28
    647c:	97 01       	movw	r18, r14
    647e:	a8 01       	movw	r20, r16
    6480:	da 94       	dec	r13
    6482:	79 f7       	brne	.-34     	; 0x6462 <__fp_powser+0x18>
    6484:	df 90       	pop	r13
    6486:	ef 90       	pop	r14
    6488:	ff 90       	pop	r15
    648a:	0f 91       	pop	r16
    648c:	1f 91       	pop	r17
    648e:	cf 91       	pop	r28
    6490:	df 91       	pop	r29
    6492:	08 95       	ret

00006494 <__fp_pscA>:
    6494:	00 24       	eor	r0, r0
    6496:	0a 94       	dec	r0
    6498:	16 16       	cp	r1, r22
    649a:	17 06       	cpc	r1, r23
    649c:	18 06       	cpc	r1, r24
    649e:	09 06       	cpc	r0, r25
    64a0:	08 95       	ret

000064a2 <__fp_pscB>:
    64a2:	00 24       	eor	r0, r0
    64a4:	0a 94       	dec	r0
    64a6:	12 16       	cp	r1, r18
    64a8:	13 06       	cpc	r1, r19
    64aa:	14 06       	cpc	r1, r20
    64ac:	05 06       	cpc	r0, r21
    64ae:	08 95       	ret
    64b0:	c9 cf       	rjmp	.-110    	; 0x6444 <__fp_nan>

000064b2 <__fp_rempio2>:
    64b2:	50 d0       	rcall	.+160    	; 0x6554 <__fp_splitA>
    64b4:	e8 f3       	brcs	.-6      	; 0x64b0 <__fp_pscB+0xe>
    64b6:	e8 94       	clt
    64b8:	e0 e0       	ldi	r30, 0x00	; 0
    64ba:	bb 27       	eor	r27, r27
    64bc:	9f 57       	subi	r25, 0x7F	; 127
    64be:	f0 f0       	brcs	.+60     	; 0x64fc <__fp_rempio2+0x4a>
    64c0:	2a ed       	ldi	r18, 0xDA	; 218
    64c2:	3f e0       	ldi	r19, 0x0F	; 15
    64c4:	49 ec       	ldi	r20, 0xC9	; 201
    64c6:	06 c0       	rjmp	.+12     	; 0x64d4 <__fp_rempio2+0x22>
    64c8:	ee 0f       	add	r30, r30
    64ca:	bb 0f       	add	r27, r27
    64cc:	66 1f       	adc	r22, r22
    64ce:	77 1f       	adc	r23, r23
    64d0:	88 1f       	adc	r24, r24
    64d2:	28 f0       	brcs	.+10     	; 0x64de <__fp_rempio2+0x2c>
    64d4:	b2 3a       	cpi	r27, 0xA2	; 162
    64d6:	62 07       	cpc	r22, r18
    64d8:	73 07       	cpc	r23, r19
    64da:	84 07       	cpc	r24, r20
    64dc:	28 f0       	brcs	.+10     	; 0x64e8 <__fp_rempio2+0x36>
    64de:	b2 5a       	subi	r27, 0xA2	; 162
    64e0:	62 0b       	sbc	r22, r18
    64e2:	73 0b       	sbc	r23, r19
    64e4:	84 0b       	sbc	r24, r20
    64e6:	e3 95       	inc	r30
    64e8:	9a 95       	dec	r25
    64ea:	72 f7       	brpl	.-36     	; 0x64c8 <__fp_rempio2+0x16>
    64ec:	80 38       	cpi	r24, 0x80	; 128
    64ee:	30 f4       	brcc	.+12     	; 0x64fc <__fp_rempio2+0x4a>
    64f0:	9a 95       	dec	r25
    64f2:	bb 0f       	add	r27, r27
    64f4:	66 1f       	adc	r22, r22
    64f6:	77 1f       	adc	r23, r23
    64f8:	88 1f       	adc	r24, r24
    64fa:	d2 f7       	brpl	.-12     	; 0x64f0 <__fp_rempio2+0x3e>
    64fc:	90 48       	sbci	r25, 0x80	; 128
    64fe:	06 c1       	rjmp	.+524    	; 0x670c <__fp_mpack_finite>

00006500 <__fp_round>:
    6500:	09 2e       	mov	r0, r25
    6502:	03 94       	inc	r0
    6504:	00 0c       	add	r0, r0
    6506:	11 f4       	brne	.+4      	; 0x650c <__fp_round+0xc>
    6508:	88 23       	and	r24, r24
    650a:	52 f0       	brmi	.+20     	; 0x6520 <__fp_round+0x20>
    650c:	bb 0f       	add	r27, r27
    650e:	40 f4       	brcc	.+16     	; 0x6520 <__fp_round+0x20>
    6510:	bf 2b       	or	r27, r31
    6512:	11 f4       	brne	.+4      	; 0x6518 <__fp_round+0x18>
    6514:	60 ff       	sbrs	r22, 0
    6516:	04 c0       	rjmp	.+8      	; 0x6520 <__fp_round+0x20>
    6518:	6f 5f       	subi	r22, 0xFF	; 255
    651a:	7f 4f       	sbci	r23, 0xFF	; 255
    651c:	8f 4f       	sbci	r24, 0xFF	; 255
    651e:	9f 4f       	sbci	r25, 0xFF	; 255
    6520:	08 95       	ret

00006522 <__fp_sinus>:
    6522:	ef 93       	push	r30
    6524:	e0 ff       	sbrs	r30, 0
    6526:	06 c0       	rjmp	.+12     	; 0x6534 <__fp_sinus+0x12>
    6528:	a2 ea       	ldi	r26, 0xA2	; 162
    652a:	2a ed       	ldi	r18, 0xDA	; 218
    652c:	3f e0       	ldi	r19, 0x0F	; 15
    652e:	49 ec       	ldi	r20, 0xC9	; 201
    6530:	5f eb       	ldi	r21, 0xBF	; 191
    6532:	cc dd       	rcall	.-1128   	; 0x60cc <__addsf3x>
    6534:	e5 df       	rcall	.-54     	; 0x6500 <__fp_round>
    6536:	0f 90       	pop	r0
    6538:	03 94       	inc	r0
    653a:	01 fc       	sbrc	r0, 1
    653c:	90 58       	subi	r25, 0x80	; 128
    653e:	e1 e1       	ldi	r30, 0x11	; 17
    6540:	f1 e0       	ldi	r31, 0x01	; 1
    6542:	f7 c0       	rjmp	.+494    	; 0x6732 <__fp_powsodd>

00006544 <__fp_split3>:
    6544:	57 fd       	sbrc	r21, 7
    6546:	90 58       	subi	r25, 0x80	; 128
    6548:	44 0f       	add	r20, r20
    654a:	55 1f       	adc	r21, r21
    654c:	59 f0       	breq	.+22     	; 0x6564 <__fp_splitA+0x10>
    654e:	5f 3f       	cpi	r21, 0xFF	; 255
    6550:	71 f0       	breq	.+28     	; 0x656e <__fp_splitA+0x1a>
    6552:	47 95       	ror	r20

00006554 <__fp_splitA>:
    6554:	88 0f       	add	r24, r24
    6556:	97 fb       	bst	r25, 7
    6558:	99 1f       	adc	r25, r25
    655a:	61 f0       	breq	.+24     	; 0x6574 <__fp_splitA+0x20>
    655c:	9f 3f       	cpi	r25, 0xFF	; 255
    655e:	79 f0       	breq	.+30     	; 0x657e <__fp_splitA+0x2a>
    6560:	87 95       	ror	r24
    6562:	08 95       	ret
    6564:	12 16       	cp	r1, r18
    6566:	13 06       	cpc	r1, r19
    6568:	14 06       	cpc	r1, r20
    656a:	55 1f       	adc	r21, r21
    656c:	f2 cf       	rjmp	.-28     	; 0x6552 <__fp_split3+0xe>
    656e:	46 95       	lsr	r20
    6570:	f1 df       	rcall	.-30     	; 0x6554 <__fp_splitA>
    6572:	08 c0       	rjmp	.+16     	; 0x6584 <__fp_splitA+0x30>
    6574:	16 16       	cp	r1, r22
    6576:	17 06       	cpc	r1, r23
    6578:	18 06       	cpc	r1, r24
    657a:	99 1f       	adc	r25, r25
    657c:	f1 cf       	rjmp	.-30     	; 0x6560 <__fp_splitA+0xc>
    657e:	86 95       	lsr	r24
    6580:	71 05       	cpc	r23, r1
    6582:	61 05       	cpc	r22, r1
    6584:	08 94       	sec
    6586:	08 95       	ret

00006588 <__fp_zero>:
    6588:	e8 94       	clt

0000658a <__fp_szero>:
    658a:	bb 27       	eor	r27, r27
    658c:	66 27       	eor	r22, r22
    658e:	77 27       	eor	r23, r23
    6590:	cb 01       	movw	r24, r22
    6592:	97 f9       	bld	r25, 7
    6594:	08 95       	ret

00006596 <__gesf2>:
    6596:	2c df       	rcall	.-424    	; 0x63f0 <__fp_cmp>
    6598:	08 f4       	brcc	.+2      	; 0x659c <__gesf2+0x6>
    659a:	8f ef       	ldi	r24, 0xFF	; 255
    659c:	08 95       	ret

0000659e <inverse>:
    659e:	9b 01       	movw	r18, r22
    65a0:	ac 01       	movw	r20, r24
    65a2:	60 e0       	ldi	r22, 0x00	; 0
    65a4:	70 e0       	ldi	r23, 0x00	; 0
    65a6:	80 e8       	ldi	r24, 0x80	; 128
    65a8:	9f e3       	ldi	r25, 0x3F	; 63
    65aa:	4c ce       	rjmp	.-872    	; 0x6244 <__divsf3>

000065ac <__mulsf3>:
    65ac:	0b d0       	rcall	.+22     	; 0x65c4 <__mulsf3x>
    65ae:	a8 cf       	rjmp	.-176    	; 0x6500 <__fp_round>
    65b0:	71 df       	rcall	.-286    	; 0x6494 <__fp_pscA>
    65b2:	28 f0       	brcs	.+10     	; 0x65be <__mulsf3+0x12>
    65b4:	76 df       	rcall	.-276    	; 0x64a2 <__fp_pscB>
    65b6:	18 f0       	brcs	.+6      	; 0x65be <__mulsf3+0x12>
    65b8:	95 23       	and	r25, r21
    65ba:	09 f0       	breq	.+2      	; 0x65be <__mulsf3+0x12>
    65bc:	3d cf       	rjmp	.-390    	; 0x6438 <__fp_inf>
    65be:	42 cf       	rjmp	.-380    	; 0x6444 <__fp_nan>
    65c0:	11 24       	eor	r1, r1
    65c2:	e3 cf       	rjmp	.-58     	; 0x658a <__fp_szero>

000065c4 <__mulsf3x>:
    65c4:	bf df       	rcall	.-130    	; 0x6544 <__fp_split3>
    65c6:	a0 f3       	brcs	.-24     	; 0x65b0 <__mulsf3+0x4>

000065c8 <__mulsf3_pse>:
    65c8:	95 9f       	mul	r25, r21
    65ca:	d1 f3       	breq	.-12     	; 0x65c0 <__mulsf3+0x14>
    65cc:	95 0f       	add	r25, r21
    65ce:	50 e0       	ldi	r21, 0x00	; 0
    65d0:	55 1f       	adc	r21, r21
    65d2:	62 9f       	mul	r22, r18
    65d4:	f0 01       	movw	r30, r0
    65d6:	72 9f       	mul	r23, r18
    65d8:	bb 27       	eor	r27, r27
    65da:	f0 0d       	add	r31, r0
    65dc:	b1 1d       	adc	r27, r1
    65de:	63 9f       	mul	r22, r19
    65e0:	aa 27       	eor	r26, r26
    65e2:	f0 0d       	add	r31, r0
    65e4:	b1 1d       	adc	r27, r1
    65e6:	aa 1f       	adc	r26, r26
    65e8:	64 9f       	mul	r22, r20
    65ea:	66 27       	eor	r22, r22
    65ec:	b0 0d       	add	r27, r0
    65ee:	a1 1d       	adc	r26, r1
    65f0:	66 1f       	adc	r22, r22
    65f2:	82 9f       	mul	r24, r18
    65f4:	22 27       	eor	r18, r18
    65f6:	b0 0d       	add	r27, r0
    65f8:	a1 1d       	adc	r26, r1
    65fa:	62 1f       	adc	r22, r18
    65fc:	73 9f       	mul	r23, r19
    65fe:	b0 0d       	add	r27, r0
    6600:	a1 1d       	adc	r26, r1
    6602:	62 1f       	adc	r22, r18
    6604:	83 9f       	mul	r24, r19
    6606:	a0 0d       	add	r26, r0
    6608:	61 1d       	adc	r22, r1
    660a:	22 1f       	adc	r18, r18
    660c:	74 9f       	mul	r23, r20
    660e:	33 27       	eor	r19, r19
    6610:	a0 0d       	add	r26, r0
    6612:	61 1d       	adc	r22, r1
    6614:	23 1f       	adc	r18, r19
    6616:	84 9f       	mul	r24, r20
    6618:	60 0d       	add	r22, r0
    661a:	21 1d       	adc	r18, r1
    661c:	82 2f       	mov	r24, r18
    661e:	76 2f       	mov	r23, r22
    6620:	6a 2f       	mov	r22, r26
    6622:	11 24       	eor	r1, r1
    6624:	9f 57       	subi	r25, 0x7F	; 127
    6626:	50 40       	sbci	r21, 0x00	; 0
    6628:	8a f0       	brmi	.+34     	; 0x664c <__mulsf3_pse+0x84>
    662a:	e1 f0       	breq	.+56     	; 0x6664 <__mulsf3_pse+0x9c>
    662c:	88 23       	and	r24, r24
    662e:	4a f0       	brmi	.+18     	; 0x6642 <__mulsf3_pse+0x7a>
    6630:	ee 0f       	add	r30, r30
    6632:	ff 1f       	adc	r31, r31
    6634:	bb 1f       	adc	r27, r27
    6636:	66 1f       	adc	r22, r22
    6638:	77 1f       	adc	r23, r23
    663a:	88 1f       	adc	r24, r24
    663c:	91 50       	subi	r25, 0x01	; 1
    663e:	50 40       	sbci	r21, 0x00	; 0
    6640:	a9 f7       	brne	.-22     	; 0x662c <__mulsf3_pse+0x64>
    6642:	9e 3f       	cpi	r25, 0xFE	; 254
    6644:	51 05       	cpc	r21, r1
    6646:	70 f0       	brcs	.+28     	; 0x6664 <__mulsf3_pse+0x9c>
    6648:	f7 ce       	rjmp	.-530    	; 0x6438 <__fp_inf>
    664a:	9f cf       	rjmp	.-194    	; 0x658a <__fp_szero>
    664c:	5f 3f       	cpi	r21, 0xFF	; 255
    664e:	ec f3       	brlt	.-6      	; 0x664a <__mulsf3_pse+0x82>
    6650:	98 3e       	cpi	r25, 0xE8	; 232
    6652:	dc f3       	brlt	.-10     	; 0x664a <__mulsf3_pse+0x82>
    6654:	86 95       	lsr	r24
    6656:	77 95       	ror	r23
    6658:	67 95       	ror	r22
    665a:	b7 95       	ror	r27
    665c:	f7 95       	ror	r31
    665e:	e7 95       	ror	r30
    6660:	9f 5f       	subi	r25, 0xFF	; 255
    6662:	c1 f7       	brne	.-16     	; 0x6654 <__mulsf3_pse+0x8c>
    6664:	fe 2b       	or	r31, r30
    6666:	88 0f       	add	r24, r24
    6668:	91 1d       	adc	r25, r1
    666a:	96 95       	lsr	r25
    666c:	87 95       	ror	r24
    666e:	97 f9       	bld	r25, 7
    6670:	08 95       	ret

00006672 <sin>:
    6672:	9f 93       	push	r25
    6674:	1e df       	rcall	.-452    	; 0x64b2 <__fp_rempio2>
    6676:	0f 90       	pop	r0
    6678:	07 fc       	sbrc	r0, 7
    667a:	ee 5f       	subi	r30, 0xFE	; 254
    667c:	52 cf       	rjmp	.-348    	; 0x6522 <__fp_sinus>
    667e:	11 f4       	brne	.+4      	; 0x6684 <sin+0x12>
    6680:	0e f4       	brtc	.+2      	; 0x6684 <sin+0x12>
    6682:	e0 ce       	rjmp	.-576    	; 0x6444 <__fp_nan>
    6684:	41 c0       	rjmp	.+130    	; 0x6708 <__fp_mpack>

00006686 <sqrt>:
    6686:	66 df       	rcall	.-308    	; 0x6554 <__fp_splitA>
    6688:	d0 f3       	brcs	.-12     	; 0x667e <sin+0xc>
    668a:	99 23       	and	r25, r25
    668c:	d9 f3       	breq	.-10     	; 0x6684 <sin+0x12>
    668e:	ce f3       	brts	.-14     	; 0x6682 <sin+0x10>
    6690:	9f 57       	subi	r25, 0x7F	; 127
    6692:	55 0b       	sbc	r21, r21
    6694:	87 ff       	sbrs	r24, 7
    6696:	46 d0       	rcall	.+140    	; 0x6724 <__fp_norm2>
    6698:	00 24       	eor	r0, r0
    669a:	a0 e6       	ldi	r26, 0x60	; 96
    669c:	40 ea       	ldi	r20, 0xA0	; 160
    669e:	90 01       	movw	r18, r0
    66a0:	80 58       	subi	r24, 0x80	; 128
    66a2:	56 95       	lsr	r21
    66a4:	97 95       	ror	r25
    66a6:	28 f4       	brcc	.+10     	; 0x66b2 <sqrt+0x2c>
    66a8:	80 5c       	subi	r24, 0xC0	; 192
    66aa:	66 0f       	add	r22, r22
    66ac:	77 1f       	adc	r23, r23
    66ae:	88 1f       	adc	r24, r24
    66b0:	20 f0       	brcs	.+8      	; 0x66ba <sqrt+0x34>
    66b2:	26 17       	cp	r18, r22
    66b4:	37 07       	cpc	r19, r23
    66b6:	48 07       	cpc	r20, r24
    66b8:	30 f4       	brcc	.+12     	; 0x66c6 <sqrt+0x40>
    66ba:	62 1b       	sub	r22, r18
    66bc:	73 0b       	sbc	r23, r19
    66be:	84 0b       	sbc	r24, r20
    66c0:	20 29       	or	r18, r0
    66c2:	31 29       	or	r19, r1
    66c4:	4a 2b       	or	r20, r26
    66c6:	a6 95       	lsr	r26
    66c8:	17 94       	ror	r1
    66ca:	07 94       	ror	r0
    66cc:	20 25       	eor	r18, r0
    66ce:	31 25       	eor	r19, r1
    66d0:	4a 27       	eor	r20, r26
    66d2:	58 f7       	brcc	.-42     	; 0x66aa <sqrt+0x24>
    66d4:	66 0f       	add	r22, r22
    66d6:	77 1f       	adc	r23, r23
    66d8:	88 1f       	adc	r24, r24
    66da:	20 f0       	brcs	.+8      	; 0x66e4 <sqrt+0x5e>
    66dc:	26 17       	cp	r18, r22
    66de:	37 07       	cpc	r19, r23
    66e0:	48 07       	cpc	r20, r24
    66e2:	30 f4       	brcc	.+12     	; 0x66f0 <sqrt+0x6a>
    66e4:	62 0b       	sbc	r22, r18
    66e6:	73 0b       	sbc	r23, r19
    66e8:	84 0b       	sbc	r24, r20
    66ea:	20 0d       	add	r18, r0
    66ec:	31 1d       	adc	r19, r1
    66ee:	41 1d       	adc	r20, r1
    66f0:	a0 95       	com	r26
    66f2:	81 f7       	brne	.-32     	; 0x66d4 <sqrt+0x4e>
    66f4:	b9 01       	movw	r22, r18
    66f6:	84 2f       	mov	r24, r20
    66f8:	91 58       	subi	r25, 0x81	; 129
    66fa:	88 0f       	add	r24, r24
    66fc:	96 95       	lsr	r25
    66fe:	87 95       	ror	r24
    6700:	08 95       	ret

00006702 <square>:
    6702:	9b 01       	movw	r18, r22
    6704:	ac 01       	movw	r20, r24
    6706:	52 cf       	rjmp	.-348    	; 0x65ac <__mulsf3>

00006708 <__fp_mpack>:
    6708:	9f 3f       	cpi	r25, 0xFF	; 255
    670a:	31 f0       	breq	.+12     	; 0x6718 <__fp_mpack_finite+0xc>

0000670c <__fp_mpack_finite>:
    670c:	91 50       	subi	r25, 0x01	; 1
    670e:	20 f4       	brcc	.+8      	; 0x6718 <__fp_mpack_finite+0xc>
    6710:	87 95       	ror	r24
    6712:	77 95       	ror	r23
    6714:	67 95       	ror	r22
    6716:	b7 95       	ror	r27
    6718:	88 0f       	add	r24, r24
    671a:	91 1d       	adc	r25, r1
    671c:	96 95       	lsr	r25
    671e:	87 95       	ror	r24
    6720:	97 f9       	bld	r25, 7
    6722:	08 95       	ret

00006724 <__fp_norm2>:
    6724:	91 50       	subi	r25, 0x01	; 1
    6726:	50 40       	sbci	r21, 0x00	; 0
    6728:	66 0f       	add	r22, r22
    672a:	77 1f       	adc	r23, r23
    672c:	88 1f       	adc	r24, r24
    672e:	d2 f7       	brpl	.-12     	; 0x6724 <__fp_norm2>
    6730:	08 95       	ret

00006732 <__fp_powsodd>:
    6732:	9f 93       	push	r25
    6734:	8f 93       	push	r24
    6736:	7f 93       	push	r23
    6738:	6f 93       	push	r22
    673a:	ff 93       	push	r31
    673c:	ef 93       	push	r30
    673e:	9b 01       	movw	r18, r22
    6740:	ac 01       	movw	r20, r24
    6742:	34 df       	rcall	.-408    	; 0x65ac <__mulsf3>
    6744:	ef 91       	pop	r30
    6746:	ff 91       	pop	r31
    6748:	80 de       	rcall	.-768    	; 0x644a <__fp_powser>
    674a:	2f 91       	pop	r18
    674c:	3f 91       	pop	r19
    674e:	4f 91       	pop	r20
    6750:	5f 91       	pop	r21
    6752:	2c cf       	rjmp	.-424    	; 0x65ac <__mulsf3>

00006754 <vfprintf>:
    6754:	2f 92       	push	r2
    6756:	3f 92       	push	r3
    6758:	4f 92       	push	r4
    675a:	5f 92       	push	r5
    675c:	6f 92       	push	r6
    675e:	7f 92       	push	r7
    6760:	8f 92       	push	r8
    6762:	9f 92       	push	r9
    6764:	af 92       	push	r10
    6766:	bf 92       	push	r11
    6768:	cf 92       	push	r12
    676a:	df 92       	push	r13
    676c:	ef 92       	push	r14
    676e:	ff 92       	push	r15
    6770:	0f 93       	push	r16
    6772:	1f 93       	push	r17
    6774:	cf 93       	push	r28
    6776:	df 93       	push	r29
    6778:	cd b7       	in	r28, 0x3d	; 61
    677a:	de b7       	in	r29, 0x3e	; 62
    677c:	63 97       	sbiw	r28, 0x13	; 19
    677e:	0f b6       	in	r0, 0x3f	; 63
    6780:	f8 94       	cli
    6782:	de bf       	out	0x3e, r29	; 62
    6784:	0f be       	out	0x3f, r0	; 63
    6786:	cd bf       	out	0x3d, r28	; 61
    6788:	6c 01       	movw	r12, r24
    678a:	4b 01       	movw	r8, r22
    678c:	2a 01       	movw	r4, r20
    678e:	fc 01       	movw	r30, r24
    6790:	17 82       	std	Z+7, r1	; 0x07
    6792:	16 82       	std	Z+6, r1	; 0x06
    6794:	83 81       	ldd	r24, Z+3	; 0x03
    6796:	81 ff       	sbrs	r24, 1
    6798:	29 c3       	rjmp	.+1618   	; 0x6dec <vfprintf+0x698>
    679a:	ae 01       	movw	r20, r28
    679c:	4f 5f       	subi	r20, 0xFF	; 255
    679e:	5f 4f       	sbci	r21, 0xFF	; 255
    67a0:	3a 01       	movw	r6, r20
    67a2:	f6 01       	movw	r30, r12
    67a4:	93 81       	ldd	r25, Z+3	; 0x03
    67a6:	f4 01       	movw	r30, r8
    67a8:	93 fd       	sbrc	r25, 3
    67aa:	85 91       	lpm	r24, Z+
    67ac:	93 ff       	sbrs	r25, 3
    67ae:	81 91       	ld	r24, Z+
    67b0:	4f 01       	movw	r8, r30
    67b2:	88 23       	and	r24, r24
    67b4:	09 f4       	brne	.+2      	; 0x67b8 <vfprintf+0x64>
    67b6:	16 c3       	rjmp	.+1580   	; 0x6de4 <vfprintf+0x690>
    67b8:	85 32       	cpi	r24, 0x25	; 37
    67ba:	39 f4       	brne	.+14     	; 0x67ca <vfprintf+0x76>
    67bc:	93 fd       	sbrc	r25, 3
    67be:	85 91       	lpm	r24, Z+
    67c0:	93 ff       	sbrs	r25, 3
    67c2:	81 91       	ld	r24, Z+
    67c4:	4f 01       	movw	r8, r30
    67c6:	85 32       	cpi	r24, 0x25	; 37
    67c8:	31 f4       	brne	.+12     	; 0x67d6 <vfprintf+0x82>
    67ca:	b6 01       	movw	r22, r12
    67cc:	90 e0       	ldi	r25, 0x00	; 0
    67ce:	77 d4       	rcall	.+2286   	; 0x70be <fputc>
    67d0:	52 01       	movw	r10, r4
    67d2:	25 01       	movw	r4, r10
    67d4:	e6 cf       	rjmp	.-52     	; 0x67a2 <vfprintf+0x4e>
    67d6:	10 e0       	ldi	r17, 0x00	; 0
    67d8:	f1 2c       	mov	r15, r1
    67da:	20 e0       	ldi	r18, 0x00	; 0
    67dc:	20 32       	cpi	r18, 0x20	; 32
    67de:	a0 f4       	brcc	.+40     	; 0x6808 <vfprintf+0xb4>
    67e0:	8b 32       	cpi	r24, 0x2B	; 43
    67e2:	69 f0       	breq	.+26     	; 0x67fe <vfprintf+0xaa>
    67e4:	30 f4       	brcc	.+12     	; 0x67f2 <vfprintf+0x9e>
    67e6:	80 32       	cpi	r24, 0x20	; 32
    67e8:	59 f0       	breq	.+22     	; 0x6800 <vfprintf+0xac>
    67ea:	83 32       	cpi	r24, 0x23	; 35
    67ec:	69 f4       	brne	.+26     	; 0x6808 <vfprintf+0xb4>
    67ee:	20 61       	ori	r18, 0x10	; 16
    67f0:	2c c0       	rjmp	.+88     	; 0x684a <vfprintf+0xf6>
    67f2:	8d 32       	cpi	r24, 0x2D	; 45
    67f4:	39 f0       	breq	.+14     	; 0x6804 <vfprintf+0xb0>
    67f6:	80 33       	cpi	r24, 0x30	; 48
    67f8:	39 f4       	brne	.+14     	; 0x6808 <vfprintf+0xb4>
    67fa:	21 60       	ori	r18, 0x01	; 1
    67fc:	26 c0       	rjmp	.+76     	; 0x684a <vfprintf+0xf6>
    67fe:	22 60       	ori	r18, 0x02	; 2
    6800:	24 60       	ori	r18, 0x04	; 4
    6802:	23 c0       	rjmp	.+70     	; 0x684a <vfprintf+0xf6>
    6804:	28 60       	ori	r18, 0x08	; 8
    6806:	21 c0       	rjmp	.+66     	; 0x684a <vfprintf+0xf6>
    6808:	27 fd       	sbrc	r18, 7
    680a:	27 c0       	rjmp	.+78     	; 0x685a <vfprintf+0x106>
    680c:	30 ed       	ldi	r19, 0xD0	; 208
    680e:	38 0f       	add	r19, r24
    6810:	3a 30       	cpi	r19, 0x0A	; 10
    6812:	78 f4       	brcc	.+30     	; 0x6832 <vfprintf+0xde>
    6814:	26 ff       	sbrs	r18, 6
    6816:	06 c0       	rjmp	.+12     	; 0x6824 <vfprintf+0xd0>
    6818:	fa e0       	ldi	r31, 0x0A	; 10
    681a:	1f 9f       	mul	r17, r31
    681c:	30 0d       	add	r19, r0
    681e:	11 24       	eor	r1, r1
    6820:	13 2f       	mov	r17, r19
    6822:	13 c0       	rjmp	.+38     	; 0x684a <vfprintf+0xf6>
    6824:	4a e0       	ldi	r20, 0x0A	; 10
    6826:	f4 9e       	mul	r15, r20
    6828:	30 0d       	add	r19, r0
    682a:	11 24       	eor	r1, r1
    682c:	f3 2e       	mov	r15, r19
    682e:	20 62       	ori	r18, 0x20	; 32
    6830:	0c c0       	rjmp	.+24     	; 0x684a <vfprintf+0xf6>
    6832:	8e 32       	cpi	r24, 0x2E	; 46
    6834:	21 f4       	brne	.+8      	; 0x683e <vfprintf+0xea>
    6836:	26 fd       	sbrc	r18, 6
    6838:	d5 c2       	rjmp	.+1450   	; 0x6de4 <vfprintf+0x690>
    683a:	20 64       	ori	r18, 0x40	; 64
    683c:	06 c0       	rjmp	.+12     	; 0x684a <vfprintf+0xf6>
    683e:	8c 36       	cpi	r24, 0x6C	; 108
    6840:	11 f4       	brne	.+4      	; 0x6846 <vfprintf+0xf2>
    6842:	20 68       	ori	r18, 0x80	; 128
    6844:	02 c0       	rjmp	.+4      	; 0x684a <vfprintf+0xf6>
    6846:	88 36       	cpi	r24, 0x68	; 104
    6848:	41 f4       	brne	.+16     	; 0x685a <vfprintf+0x106>
    684a:	f4 01       	movw	r30, r8
    684c:	93 fd       	sbrc	r25, 3
    684e:	85 91       	lpm	r24, Z+
    6850:	93 ff       	sbrs	r25, 3
    6852:	81 91       	ld	r24, Z+
    6854:	4f 01       	movw	r8, r30
    6856:	81 11       	cpse	r24, r1
    6858:	c1 cf       	rjmp	.-126    	; 0x67dc <vfprintf+0x88>
    685a:	9b eb       	ldi	r25, 0xBB	; 187
    685c:	98 0f       	add	r25, r24
    685e:	93 30       	cpi	r25, 0x03	; 3
    6860:	18 f4       	brcc	.+6      	; 0x6868 <vfprintf+0x114>
    6862:	20 61       	ori	r18, 0x10	; 16
    6864:	80 5e       	subi	r24, 0xE0	; 224
    6866:	06 c0       	rjmp	.+12     	; 0x6874 <vfprintf+0x120>
    6868:	9b e9       	ldi	r25, 0x9B	; 155
    686a:	98 0f       	add	r25, r24
    686c:	93 30       	cpi	r25, 0x03	; 3
    686e:	08 f0       	brcs	.+2      	; 0x6872 <vfprintf+0x11e>
    6870:	64 c1       	rjmp	.+712    	; 0x6b3a <vfprintf+0x3e6>
    6872:	2f 7e       	andi	r18, 0xEF	; 239
    6874:	26 ff       	sbrs	r18, 6
    6876:	16 e0       	ldi	r17, 0x06	; 6
    6878:	2f 73       	andi	r18, 0x3F	; 63
    687a:	32 2e       	mov	r3, r18
    687c:	85 36       	cpi	r24, 0x65	; 101
    687e:	19 f4       	brne	.+6      	; 0x6886 <vfprintf+0x132>
    6880:	20 64       	ori	r18, 0x40	; 64
    6882:	32 2e       	mov	r3, r18
    6884:	08 c0       	rjmp	.+16     	; 0x6896 <vfprintf+0x142>
    6886:	86 36       	cpi	r24, 0x66	; 102
    6888:	21 f4       	brne	.+8      	; 0x6892 <vfprintf+0x13e>
    688a:	f2 2f       	mov	r31, r18
    688c:	f0 68       	ori	r31, 0x80	; 128
    688e:	3f 2e       	mov	r3, r31
    6890:	02 c0       	rjmp	.+4      	; 0x6896 <vfprintf+0x142>
    6892:	11 11       	cpse	r17, r1
    6894:	11 50       	subi	r17, 0x01	; 1
    6896:	37 fe       	sbrs	r3, 7
    6898:	07 c0       	rjmp	.+14     	; 0x68a8 <vfprintf+0x154>
    689a:	1c 33       	cpi	r17, 0x3C	; 60
    689c:	50 f4       	brcc	.+20     	; 0x68b2 <vfprintf+0x15e>
    689e:	ee 24       	eor	r14, r14
    68a0:	e3 94       	inc	r14
    68a2:	e1 0e       	add	r14, r17
    68a4:	27 e0       	ldi	r18, 0x07	; 7
    68a6:	0b c0       	rjmp	.+22     	; 0x68be <vfprintf+0x16a>
    68a8:	18 30       	cpi	r17, 0x08	; 8
    68aa:	38 f0       	brcs	.+14     	; 0x68ba <vfprintf+0x166>
    68ac:	27 e0       	ldi	r18, 0x07	; 7
    68ae:	17 e0       	ldi	r17, 0x07	; 7
    68b0:	05 c0       	rjmp	.+10     	; 0x68bc <vfprintf+0x168>
    68b2:	27 e0       	ldi	r18, 0x07	; 7
    68b4:	4c e3       	ldi	r20, 0x3C	; 60
    68b6:	e4 2e       	mov	r14, r20
    68b8:	02 c0       	rjmp	.+4      	; 0x68be <vfprintf+0x16a>
    68ba:	21 2f       	mov	r18, r17
    68bc:	e1 2c       	mov	r14, r1
    68be:	52 01       	movw	r10, r4
    68c0:	44 e0       	ldi	r20, 0x04	; 4
    68c2:	a4 0e       	add	r10, r20
    68c4:	b1 1c       	adc	r11, r1
    68c6:	f2 01       	movw	r30, r4
    68c8:	60 81       	ld	r22, Z
    68ca:	71 81       	ldd	r23, Z+1	; 0x01
    68cc:	82 81       	ldd	r24, Z+2	; 0x02
    68ce:	93 81       	ldd	r25, Z+3	; 0x03
    68d0:	0e 2d       	mov	r16, r14
    68d2:	a3 01       	movw	r20, r6
    68d4:	fd d2       	rcall	.+1530   	; 0x6ed0 <__ftoa_engine>
    68d6:	2c 01       	movw	r4, r24
    68d8:	09 81       	ldd	r16, Y+1	; 0x01
    68da:	00 ff       	sbrs	r16, 0
    68dc:	02 c0       	rjmp	.+4      	; 0x68e2 <vfprintf+0x18e>
    68de:	03 ff       	sbrs	r16, 3
    68e0:	07 c0       	rjmp	.+14     	; 0x68f0 <vfprintf+0x19c>
    68e2:	31 fc       	sbrc	r3, 1
    68e4:	08 c0       	rjmp	.+16     	; 0x68f6 <vfprintf+0x1a2>
    68e6:	32 fe       	sbrs	r3, 2
    68e8:	09 c0       	rjmp	.+18     	; 0x68fc <vfprintf+0x1a8>
    68ea:	30 e2       	ldi	r19, 0x20	; 32
    68ec:	23 2e       	mov	r2, r19
    68ee:	07 c0       	rjmp	.+14     	; 0x68fe <vfprintf+0x1aa>
    68f0:	2d e2       	ldi	r18, 0x2D	; 45
    68f2:	22 2e       	mov	r2, r18
    68f4:	04 c0       	rjmp	.+8      	; 0x68fe <vfprintf+0x1aa>
    68f6:	9b e2       	ldi	r25, 0x2B	; 43
    68f8:	29 2e       	mov	r2, r25
    68fa:	01 c0       	rjmp	.+2      	; 0x68fe <vfprintf+0x1aa>
    68fc:	21 2c       	mov	r2, r1
    68fe:	80 2f       	mov	r24, r16
    6900:	8c 70       	andi	r24, 0x0C	; 12
    6902:	19 f0       	breq	.+6      	; 0x690a <vfprintf+0x1b6>
    6904:	21 10       	cpse	r2, r1
    6906:	51 c2       	rjmp	.+1186   	; 0x6daa <vfprintf+0x656>
    6908:	8d c2       	rjmp	.+1306   	; 0x6e24 <vfprintf+0x6d0>
    690a:	37 fe       	sbrs	r3, 7
    690c:	0f c0       	rjmp	.+30     	; 0x692c <vfprintf+0x1d8>
    690e:	e4 0c       	add	r14, r4
    6910:	04 ff       	sbrs	r16, 4
    6912:	04 c0       	rjmp	.+8      	; 0x691c <vfprintf+0x1c8>
    6914:	8a 81       	ldd	r24, Y+2	; 0x02
    6916:	81 33       	cpi	r24, 0x31	; 49
    6918:	09 f4       	brne	.+2      	; 0x691c <vfprintf+0x1c8>
    691a:	ea 94       	dec	r14
    691c:	1e 14       	cp	r1, r14
    691e:	74 f5       	brge	.+92     	; 0x697c <vfprintf+0x228>
    6920:	f8 e0       	ldi	r31, 0x08	; 8
    6922:	fe 15       	cp	r31, r14
    6924:	78 f5       	brcc	.+94     	; 0x6984 <vfprintf+0x230>
    6926:	88 e0       	ldi	r24, 0x08	; 8
    6928:	e8 2e       	mov	r14, r24
    692a:	2c c0       	rjmp	.+88     	; 0x6984 <vfprintf+0x230>
    692c:	36 fc       	sbrc	r3, 6
    692e:	2a c0       	rjmp	.+84     	; 0x6984 <vfprintf+0x230>
    6930:	81 2f       	mov	r24, r17
    6932:	90 e0       	ldi	r25, 0x00	; 0
    6934:	84 15       	cp	r24, r4
    6936:	95 05       	cpc	r25, r5
    6938:	9c f0       	brlt	.+38     	; 0x6960 <vfprintf+0x20c>
    693a:	2c ef       	ldi	r18, 0xFC	; 252
    693c:	42 16       	cp	r4, r18
    693e:	2f ef       	ldi	r18, 0xFF	; 255
    6940:	52 06       	cpc	r5, r18
    6942:	74 f0       	brlt	.+28     	; 0x6960 <vfprintf+0x20c>
    6944:	43 2d       	mov	r20, r3
    6946:	40 68       	ori	r20, 0x80	; 128
    6948:	34 2e       	mov	r3, r20
    694a:	0a c0       	rjmp	.+20     	; 0x6960 <vfprintf+0x20c>
    694c:	e2 e0       	ldi	r30, 0x02	; 2
    694e:	f0 e0       	ldi	r31, 0x00	; 0
    6950:	ec 0f       	add	r30, r28
    6952:	fd 1f       	adc	r31, r29
    6954:	e1 0f       	add	r30, r17
    6956:	f1 1d       	adc	r31, r1
    6958:	80 81       	ld	r24, Z
    695a:	80 33       	cpi	r24, 0x30	; 48
    695c:	19 f4       	brne	.+6      	; 0x6964 <vfprintf+0x210>
    695e:	11 50       	subi	r17, 0x01	; 1
    6960:	11 11       	cpse	r17, r1
    6962:	f4 cf       	rjmp	.-24     	; 0x694c <vfprintf+0x1f8>
    6964:	37 fe       	sbrs	r3, 7
    6966:	0e c0       	rjmp	.+28     	; 0x6984 <vfprintf+0x230>
    6968:	ee 24       	eor	r14, r14
    696a:	e3 94       	inc	r14
    696c:	e1 0e       	add	r14, r17
    696e:	81 2f       	mov	r24, r17
    6970:	90 e0       	ldi	r25, 0x00	; 0
    6972:	48 16       	cp	r4, r24
    6974:	59 06       	cpc	r5, r25
    6976:	2c f4       	brge	.+10     	; 0x6982 <vfprintf+0x22e>
    6978:	14 19       	sub	r17, r4
    697a:	04 c0       	rjmp	.+8      	; 0x6984 <vfprintf+0x230>
    697c:	ee 24       	eor	r14, r14
    697e:	e3 94       	inc	r14
    6980:	01 c0       	rjmp	.+2      	; 0x6984 <vfprintf+0x230>
    6982:	10 e0       	ldi	r17, 0x00	; 0
    6984:	37 fe       	sbrs	r3, 7
    6986:	06 c0       	rjmp	.+12     	; 0x6994 <vfprintf+0x240>
    6988:	14 14       	cp	r1, r4
    698a:	15 04       	cpc	r1, r5
    698c:	34 f4       	brge	.+12     	; 0x699a <vfprintf+0x246>
    698e:	c2 01       	movw	r24, r4
    6990:	01 96       	adiw	r24, 0x01	; 1
    6992:	05 c0       	rjmp	.+10     	; 0x699e <vfprintf+0x24a>
    6994:	85 e0       	ldi	r24, 0x05	; 5
    6996:	90 e0       	ldi	r25, 0x00	; 0
    6998:	02 c0       	rjmp	.+4      	; 0x699e <vfprintf+0x24a>
    699a:	81 e0       	ldi	r24, 0x01	; 1
    699c:	90 e0       	ldi	r25, 0x00	; 0
    699e:	21 10       	cpse	r2, r1
    69a0:	01 96       	adiw	r24, 0x01	; 1
    69a2:	11 23       	and	r17, r17
    69a4:	31 f0       	breq	.+12     	; 0x69b2 <vfprintf+0x25e>
    69a6:	21 2f       	mov	r18, r17
    69a8:	30 e0       	ldi	r19, 0x00	; 0
    69aa:	2f 5f       	subi	r18, 0xFF	; 255
    69ac:	3f 4f       	sbci	r19, 0xFF	; 255
    69ae:	82 0f       	add	r24, r18
    69b0:	93 1f       	adc	r25, r19
    69b2:	2f 2d       	mov	r18, r15
    69b4:	30 e0       	ldi	r19, 0x00	; 0
    69b6:	82 17       	cp	r24, r18
    69b8:	93 07       	cpc	r25, r19
    69ba:	14 f4       	brge	.+4      	; 0x69c0 <vfprintf+0x26c>
    69bc:	f8 1a       	sub	r15, r24
    69be:	01 c0       	rjmp	.+2      	; 0x69c2 <vfprintf+0x26e>
    69c0:	f1 2c       	mov	r15, r1
    69c2:	83 2d       	mov	r24, r3
    69c4:	89 70       	andi	r24, 0x09	; 9
    69c6:	41 f4       	brne	.+16     	; 0x69d8 <vfprintf+0x284>
    69c8:	ff 20       	and	r15, r15
    69ca:	31 f0       	breq	.+12     	; 0x69d8 <vfprintf+0x284>
    69cc:	b6 01       	movw	r22, r12
    69ce:	80 e2       	ldi	r24, 0x20	; 32
    69d0:	90 e0       	ldi	r25, 0x00	; 0
    69d2:	75 d3       	rcall	.+1770   	; 0x70be <fputc>
    69d4:	fa 94       	dec	r15
    69d6:	f8 cf       	rjmp	.-16     	; 0x69c8 <vfprintf+0x274>
    69d8:	22 20       	and	r2, r2
    69da:	21 f0       	breq	.+8      	; 0x69e4 <vfprintf+0x290>
    69dc:	b6 01       	movw	r22, r12
    69de:	82 2d       	mov	r24, r2
    69e0:	90 e0       	ldi	r25, 0x00	; 0
    69e2:	6d d3       	rcall	.+1754   	; 0x70be <fputc>
    69e4:	33 fc       	sbrc	r3, 3
    69e6:	08 c0       	rjmp	.+16     	; 0x69f8 <vfprintf+0x2a4>
    69e8:	ff 20       	and	r15, r15
    69ea:	31 f0       	breq	.+12     	; 0x69f8 <vfprintf+0x2a4>
    69ec:	b6 01       	movw	r22, r12
    69ee:	80 e3       	ldi	r24, 0x30	; 48
    69f0:	90 e0       	ldi	r25, 0x00	; 0
    69f2:	65 d3       	rcall	.+1738   	; 0x70be <fputc>
    69f4:	fa 94       	dec	r15
    69f6:	f8 cf       	rjmp	.-16     	; 0x69e8 <vfprintf+0x294>
    69f8:	37 fe       	sbrs	r3, 7
    69fa:	58 c0       	rjmp	.+176    	; 0x6aac <vfprintf+0x358>
    69fc:	94 2d       	mov	r25, r4
    69fe:	85 2d       	mov	r24, r5
    6a00:	57 fe       	sbrs	r5, 7
    6a02:	02 c0       	rjmp	.+4      	; 0x6a08 <vfprintf+0x2b4>
    6a04:	90 e0       	ldi	r25, 0x00	; 0
    6a06:	80 e0       	ldi	r24, 0x00	; 0
    6a08:	29 2e       	mov	r2, r25
    6a0a:	38 2e       	mov	r3, r24
    6a0c:	20 e0       	ldi	r18, 0x00	; 0
    6a0e:	30 e0       	ldi	r19, 0x00	; 0
    6a10:	a2 01       	movw	r20, r4
    6a12:	4e 19       	sub	r20, r14
    6a14:	51 09       	sbc	r21, r1
    6a16:	5d 87       	std	Y+13, r21	; 0x0d
    6a18:	4c 87       	std	Y+12, r20	; 0x0c
    6a1a:	a2 01       	movw	r20, r4
    6a1c:	42 19       	sub	r20, r2
    6a1e:	53 09       	sbc	r21, r3
    6a20:	5f 87       	std	Y+15, r21	; 0x0f
    6a22:	4e 87       	std	Y+14, r20	; 0x0e
    6a24:	61 2f       	mov	r22, r17
    6a26:	70 e0       	ldi	r23, 0x00	; 0
    6a28:	44 27       	eor	r20, r20
    6a2a:	55 27       	eor	r21, r21
    6a2c:	46 1b       	sub	r20, r22
    6a2e:	57 0b       	sbc	r21, r23
    6a30:	59 8b       	std	Y+17, r21	; 0x11
    6a32:	48 8b       	std	Y+16, r20	; 0x10
    6a34:	5f ef       	ldi	r21, 0xFF	; 255
    6a36:	25 16       	cp	r2, r21
    6a38:	35 06       	cpc	r3, r21
    6a3a:	41 f4       	brne	.+16     	; 0x6a4c <vfprintf+0x2f8>
    6a3c:	b6 01       	movw	r22, r12
    6a3e:	8e e2       	ldi	r24, 0x2E	; 46
    6a40:	90 e0       	ldi	r25, 0x00	; 0
    6a42:	2a 8b       	std	Y+18, r18	; 0x12
    6a44:	3b 8b       	std	Y+19, r19	; 0x13
    6a46:	3b d3       	rcall	.+1654   	; 0x70be <fputc>
    6a48:	3b 89       	ldd	r19, Y+19	; 0x13
    6a4a:	2a 89       	ldd	r18, Y+18	; 0x12
    6a4c:	42 14       	cp	r4, r2
    6a4e:	53 04       	cpc	r5, r3
    6a50:	6c f0       	brlt	.+26     	; 0x6a6c <vfprintf+0x318>
    6a52:	4c 85       	ldd	r20, Y+12	; 0x0c
    6a54:	5d 85       	ldd	r21, Y+13	; 0x0d
    6a56:	42 15       	cp	r20, r2
    6a58:	53 05       	cpc	r21, r3
    6a5a:	44 f4       	brge	.+16     	; 0x6a6c <vfprintf+0x318>
    6a5c:	ee 85       	ldd	r30, Y+14	; 0x0e
    6a5e:	ff 85       	ldd	r31, Y+15	; 0x0f
    6a60:	e2 0f       	add	r30, r18
    6a62:	f3 1f       	adc	r31, r19
    6a64:	e6 0d       	add	r30, r6
    6a66:	f7 1d       	adc	r31, r7
    6a68:	81 81       	ldd	r24, Z+1	; 0x01
    6a6a:	01 c0       	rjmp	.+2      	; 0x6a6e <vfprintf+0x31a>
    6a6c:	80 e3       	ldi	r24, 0x30	; 48
    6a6e:	51 e0       	ldi	r21, 0x01	; 1
    6a70:	25 1a       	sub	r2, r21
    6a72:	31 08       	sbc	r3, r1
    6a74:	2f 5f       	subi	r18, 0xFF	; 255
    6a76:	3f 4f       	sbci	r19, 0xFF	; 255
    6a78:	48 89       	ldd	r20, Y+16	; 0x10
    6a7a:	59 89       	ldd	r21, Y+17	; 0x11
    6a7c:	24 16       	cp	r2, r20
    6a7e:	35 06       	cpc	r3, r21
    6a80:	44 f0       	brlt	.+16     	; 0x6a92 <vfprintf+0x33e>
    6a82:	b6 01       	movw	r22, r12
    6a84:	90 e0       	ldi	r25, 0x00	; 0
    6a86:	2a 8b       	std	Y+18, r18	; 0x12
    6a88:	3b 8b       	std	Y+19, r19	; 0x13
    6a8a:	19 d3       	rcall	.+1586   	; 0x70be <fputc>
    6a8c:	2a 89       	ldd	r18, Y+18	; 0x12
    6a8e:	3b 89       	ldd	r19, Y+19	; 0x13
    6a90:	d1 cf       	rjmp	.-94     	; 0x6a34 <vfprintf+0x2e0>
    6a92:	24 14       	cp	r2, r4
    6a94:	35 04       	cpc	r3, r5
    6a96:	39 f4       	brne	.+14     	; 0x6aa6 <vfprintf+0x352>
    6a98:	9a 81       	ldd	r25, Y+2	; 0x02
    6a9a:	96 33       	cpi	r25, 0x36	; 54
    6a9c:	18 f4       	brcc	.+6      	; 0x6aa4 <vfprintf+0x350>
    6a9e:	95 33       	cpi	r25, 0x35	; 53
    6aa0:	11 f4       	brne	.+4      	; 0x6aa6 <vfprintf+0x352>
    6aa2:	04 ff       	sbrs	r16, 4
    6aa4:	81 e3       	ldi	r24, 0x31	; 49
    6aa6:	b6 01       	movw	r22, r12
    6aa8:	90 e0       	ldi	r25, 0x00	; 0
    6aaa:	45 c0       	rjmp	.+138    	; 0x6b36 <vfprintf+0x3e2>
    6aac:	8a 81       	ldd	r24, Y+2	; 0x02
    6aae:	81 33       	cpi	r24, 0x31	; 49
    6ab0:	09 f0       	breq	.+2      	; 0x6ab4 <vfprintf+0x360>
    6ab2:	0f 7e       	andi	r16, 0xEF	; 239
    6ab4:	b6 01       	movw	r22, r12
    6ab6:	90 e0       	ldi	r25, 0x00	; 0
    6ab8:	02 d3       	rcall	.+1540   	; 0x70be <fputc>
    6aba:	11 11       	cpse	r17, r1
    6abc:	05 c0       	rjmp	.+10     	; 0x6ac8 <vfprintf+0x374>
    6abe:	34 fc       	sbrc	r3, 4
    6ac0:	16 c0       	rjmp	.+44     	; 0x6aee <vfprintf+0x39a>
    6ac2:	85 e6       	ldi	r24, 0x65	; 101
    6ac4:	90 e0       	ldi	r25, 0x00	; 0
    6ac6:	15 c0       	rjmp	.+42     	; 0x6af2 <vfprintf+0x39e>
    6ac8:	b6 01       	movw	r22, r12
    6aca:	8e e2       	ldi	r24, 0x2E	; 46
    6acc:	90 e0       	ldi	r25, 0x00	; 0
    6ace:	f7 d2       	rcall	.+1518   	; 0x70be <fputc>
    6ad0:	82 e0       	ldi	r24, 0x02	; 2
    6ad2:	ee 24       	eor	r14, r14
    6ad4:	e3 94       	inc	r14
    6ad6:	e8 0e       	add	r14, r24
    6ad8:	f3 01       	movw	r30, r6
    6ada:	e8 0f       	add	r30, r24
    6adc:	f1 1d       	adc	r31, r1
    6ade:	80 81       	ld	r24, Z
    6ae0:	b6 01       	movw	r22, r12
    6ae2:	90 e0       	ldi	r25, 0x00	; 0
    6ae4:	ec d2       	rcall	.+1496   	; 0x70be <fputc>
    6ae6:	11 50       	subi	r17, 0x01	; 1
    6ae8:	8e 2d       	mov	r24, r14
    6aea:	99 f7       	brne	.-26     	; 0x6ad2 <vfprintf+0x37e>
    6aec:	e8 cf       	rjmp	.-48     	; 0x6abe <vfprintf+0x36a>
    6aee:	85 e4       	ldi	r24, 0x45	; 69
    6af0:	90 e0       	ldi	r25, 0x00	; 0
    6af2:	b6 01       	movw	r22, r12
    6af4:	e4 d2       	rcall	.+1480   	; 0x70be <fputc>
    6af6:	57 fc       	sbrc	r5, 7
    6af8:	05 c0       	rjmp	.+10     	; 0x6b04 <vfprintf+0x3b0>
    6afa:	41 14       	cp	r4, r1
    6afc:	51 04       	cpc	r5, r1
    6afe:	39 f4       	brne	.+14     	; 0x6b0e <vfprintf+0x3ba>
    6b00:	04 ff       	sbrs	r16, 4
    6b02:	05 c0       	rjmp	.+10     	; 0x6b0e <vfprintf+0x3ba>
    6b04:	51 94       	neg	r5
    6b06:	41 94       	neg	r4
    6b08:	51 08       	sbc	r5, r1
    6b0a:	8d e2       	ldi	r24, 0x2D	; 45
    6b0c:	01 c0       	rjmp	.+2      	; 0x6b10 <vfprintf+0x3bc>
    6b0e:	8b e2       	ldi	r24, 0x2B	; 43
    6b10:	b6 01       	movw	r22, r12
    6b12:	90 e0       	ldi	r25, 0x00	; 0
    6b14:	d4 d2       	rcall	.+1448   	; 0x70be <fputc>
    6b16:	80 e3       	ldi	r24, 0x30	; 48
    6b18:	9a e0       	ldi	r25, 0x0A	; 10
    6b1a:	49 16       	cp	r4, r25
    6b1c:	51 04       	cpc	r5, r1
    6b1e:	2c f0       	brlt	.+10     	; 0x6b2a <vfprintf+0x3d6>
    6b20:	8f 5f       	subi	r24, 0xFF	; 255
    6b22:	5a e0       	ldi	r21, 0x0A	; 10
    6b24:	45 1a       	sub	r4, r21
    6b26:	51 08       	sbc	r5, r1
    6b28:	f7 cf       	rjmp	.-18     	; 0x6b18 <vfprintf+0x3c4>
    6b2a:	b6 01       	movw	r22, r12
    6b2c:	90 e0       	ldi	r25, 0x00	; 0
    6b2e:	c7 d2       	rcall	.+1422   	; 0x70be <fputc>
    6b30:	b6 01       	movw	r22, r12
    6b32:	c2 01       	movw	r24, r4
    6b34:	c0 96       	adiw	r24, 0x30	; 48
    6b36:	c3 d2       	rcall	.+1414   	; 0x70be <fputc>
    6b38:	4c c1       	rjmp	.+664    	; 0x6dd2 <vfprintf+0x67e>
    6b3a:	83 36       	cpi	r24, 0x63	; 99
    6b3c:	31 f0       	breq	.+12     	; 0x6b4a <vfprintf+0x3f6>
    6b3e:	83 37       	cpi	r24, 0x73	; 115
    6b40:	79 f0       	breq	.+30     	; 0x6b60 <vfprintf+0x40c>
    6b42:	83 35       	cpi	r24, 0x53	; 83
    6b44:	09 f0       	breq	.+2      	; 0x6b48 <vfprintf+0x3f4>
    6b46:	54 c0       	rjmp	.+168    	; 0x6bf0 <vfprintf+0x49c>
    6b48:	20 c0       	rjmp	.+64     	; 0x6b8a <vfprintf+0x436>
    6b4a:	52 01       	movw	r10, r4
    6b4c:	e2 e0       	ldi	r30, 0x02	; 2
    6b4e:	ae 0e       	add	r10, r30
    6b50:	b1 1c       	adc	r11, r1
    6b52:	f2 01       	movw	r30, r4
    6b54:	80 81       	ld	r24, Z
    6b56:	89 83       	std	Y+1, r24	; 0x01
    6b58:	01 e0       	ldi	r16, 0x01	; 1
    6b5a:	10 e0       	ldi	r17, 0x00	; 0
    6b5c:	23 01       	movw	r4, r6
    6b5e:	13 c0       	rjmp	.+38     	; 0x6b86 <vfprintf+0x432>
    6b60:	52 01       	movw	r10, r4
    6b62:	f2 e0       	ldi	r31, 0x02	; 2
    6b64:	af 0e       	add	r10, r31
    6b66:	b1 1c       	adc	r11, r1
    6b68:	f2 01       	movw	r30, r4
    6b6a:	40 80       	ld	r4, Z
    6b6c:	51 80       	ldd	r5, Z+1	; 0x01
    6b6e:	26 ff       	sbrs	r18, 6
    6b70:	03 c0       	rjmp	.+6      	; 0x6b78 <vfprintf+0x424>
    6b72:	61 2f       	mov	r22, r17
    6b74:	70 e0       	ldi	r23, 0x00	; 0
    6b76:	02 c0       	rjmp	.+4      	; 0x6b7c <vfprintf+0x428>
    6b78:	6f ef       	ldi	r22, 0xFF	; 255
    6b7a:	7f ef       	ldi	r23, 0xFF	; 255
    6b7c:	c2 01       	movw	r24, r4
    6b7e:	2a 8b       	std	Y+18, r18	; 0x12
    6b80:	93 d2       	rcall	.+1318   	; 0x70a8 <strnlen>
    6b82:	8c 01       	movw	r16, r24
    6b84:	2a 89       	ldd	r18, Y+18	; 0x12
    6b86:	2f 77       	andi	r18, 0x7F	; 127
    6b88:	14 c0       	rjmp	.+40     	; 0x6bb2 <vfprintf+0x45e>
    6b8a:	52 01       	movw	r10, r4
    6b8c:	f2 e0       	ldi	r31, 0x02	; 2
    6b8e:	af 0e       	add	r10, r31
    6b90:	b1 1c       	adc	r11, r1
    6b92:	f2 01       	movw	r30, r4
    6b94:	40 80       	ld	r4, Z
    6b96:	51 80       	ldd	r5, Z+1	; 0x01
    6b98:	26 ff       	sbrs	r18, 6
    6b9a:	03 c0       	rjmp	.+6      	; 0x6ba2 <vfprintf+0x44e>
    6b9c:	61 2f       	mov	r22, r17
    6b9e:	70 e0       	ldi	r23, 0x00	; 0
    6ba0:	02 c0       	rjmp	.+4      	; 0x6ba6 <vfprintf+0x452>
    6ba2:	6f ef       	ldi	r22, 0xFF	; 255
    6ba4:	7f ef       	ldi	r23, 0xFF	; 255
    6ba6:	c2 01       	movw	r24, r4
    6ba8:	2a 8b       	std	Y+18, r18	; 0x12
    6baa:	6a d2       	rcall	.+1236   	; 0x7080 <strnlen_P>
    6bac:	8c 01       	movw	r16, r24
    6bae:	2a 89       	ldd	r18, Y+18	; 0x12
    6bb0:	20 68       	ori	r18, 0x80	; 128
    6bb2:	32 2e       	mov	r3, r18
    6bb4:	23 fd       	sbrc	r18, 3
    6bb6:	18 c0       	rjmp	.+48     	; 0x6be8 <vfprintf+0x494>
    6bb8:	8f 2d       	mov	r24, r15
    6bba:	90 e0       	ldi	r25, 0x00	; 0
    6bbc:	08 17       	cp	r16, r24
    6bbe:	19 07       	cpc	r17, r25
    6bc0:	98 f4       	brcc	.+38     	; 0x6be8 <vfprintf+0x494>
    6bc2:	b6 01       	movw	r22, r12
    6bc4:	80 e2       	ldi	r24, 0x20	; 32
    6bc6:	90 e0       	ldi	r25, 0x00	; 0
    6bc8:	7a d2       	rcall	.+1268   	; 0x70be <fputc>
    6bca:	fa 94       	dec	r15
    6bcc:	f5 cf       	rjmp	.-22     	; 0x6bb8 <vfprintf+0x464>
    6bce:	f2 01       	movw	r30, r4
    6bd0:	37 fc       	sbrc	r3, 7
    6bd2:	85 91       	lpm	r24, Z+
    6bd4:	37 fe       	sbrs	r3, 7
    6bd6:	81 91       	ld	r24, Z+
    6bd8:	2f 01       	movw	r4, r30
    6bda:	b6 01       	movw	r22, r12
    6bdc:	90 e0       	ldi	r25, 0x00	; 0
    6bde:	6f d2       	rcall	.+1246   	; 0x70be <fputc>
    6be0:	f1 10       	cpse	r15, r1
    6be2:	fa 94       	dec	r15
    6be4:	01 50       	subi	r16, 0x01	; 1
    6be6:	11 09       	sbc	r17, r1
    6be8:	01 15       	cp	r16, r1
    6bea:	11 05       	cpc	r17, r1
    6bec:	81 f7       	brne	.-32     	; 0x6bce <vfprintf+0x47a>
    6bee:	f1 c0       	rjmp	.+482    	; 0x6dd2 <vfprintf+0x67e>
    6bf0:	84 36       	cpi	r24, 0x64	; 100
    6bf2:	11 f0       	breq	.+4      	; 0x6bf8 <vfprintf+0x4a4>
    6bf4:	89 36       	cpi	r24, 0x69	; 105
    6bf6:	51 f5       	brne	.+84     	; 0x6c4c <vfprintf+0x4f8>
    6bf8:	52 01       	movw	r10, r4
    6bfa:	27 ff       	sbrs	r18, 7
    6bfc:	09 c0       	rjmp	.+18     	; 0x6c10 <vfprintf+0x4bc>
    6bfe:	f4 e0       	ldi	r31, 0x04	; 4
    6c00:	af 0e       	add	r10, r31
    6c02:	b1 1c       	adc	r11, r1
    6c04:	f2 01       	movw	r30, r4
    6c06:	60 81       	ld	r22, Z
    6c08:	71 81       	ldd	r23, Z+1	; 0x01
    6c0a:	82 81       	ldd	r24, Z+2	; 0x02
    6c0c:	93 81       	ldd	r25, Z+3	; 0x03
    6c0e:	0a c0       	rjmp	.+20     	; 0x6c24 <vfprintf+0x4d0>
    6c10:	f2 e0       	ldi	r31, 0x02	; 2
    6c12:	af 0e       	add	r10, r31
    6c14:	b1 1c       	adc	r11, r1
    6c16:	f2 01       	movw	r30, r4
    6c18:	60 81       	ld	r22, Z
    6c1a:	71 81       	ldd	r23, Z+1	; 0x01
    6c1c:	07 2e       	mov	r0, r23
    6c1e:	00 0c       	add	r0, r0
    6c20:	88 0b       	sbc	r24, r24
    6c22:	99 0b       	sbc	r25, r25
    6c24:	2f 76       	andi	r18, 0x6F	; 111
    6c26:	32 2e       	mov	r3, r18
    6c28:	97 ff       	sbrs	r25, 7
    6c2a:	09 c0       	rjmp	.+18     	; 0x6c3e <vfprintf+0x4ea>
    6c2c:	90 95       	com	r25
    6c2e:	80 95       	com	r24
    6c30:	70 95       	com	r23
    6c32:	61 95       	neg	r22
    6c34:	7f 4f       	sbci	r23, 0xFF	; 255
    6c36:	8f 4f       	sbci	r24, 0xFF	; 255
    6c38:	9f 4f       	sbci	r25, 0xFF	; 255
    6c3a:	20 68       	ori	r18, 0x80	; 128
    6c3c:	32 2e       	mov	r3, r18
    6c3e:	2a e0       	ldi	r18, 0x0A	; 10
    6c40:	30 e0       	ldi	r19, 0x00	; 0
    6c42:	a3 01       	movw	r20, r6
    6c44:	9d d2       	rcall	.+1338   	; 0x7180 <__ultoa_invert>
    6c46:	e8 2e       	mov	r14, r24
    6c48:	e6 18       	sub	r14, r6
    6c4a:	3e c0       	rjmp	.+124    	; 0x6cc8 <vfprintf+0x574>
    6c4c:	02 2f       	mov	r16, r18
    6c4e:	85 37       	cpi	r24, 0x75	; 117
    6c50:	21 f4       	brne	.+8      	; 0x6c5a <vfprintf+0x506>
    6c52:	0f 7e       	andi	r16, 0xEF	; 239
    6c54:	2a e0       	ldi	r18, 0x0A	; 10
    6c56:	30 e0       	ldi	r19, 0x00	; 0
    6c58:	1d c0       	rjmp	.+58     	; 0x6c94 <vfprintf+0x540>
    6c5a:	09 7f       	andi	r16, 0xF9	; 249
    6c5c:	8f 36       	cpi	r24, 0x6F	; 111
    6c5e:	91 f0       	breq	.+36     	; 0x6c84 <vfprintf+0x530>
    6c60:	18 f4       	brcc	.+6      	; 0x6c68 <vfprintf+0x514>
    6c62:	88 35       	cpi	r24, 0x58	; 88
    6c64:	59 f0       	breq	.+22     	; 0x6c7c <vfprintf+0x528>
    6c66:	be c0       	rjmp	.+380    	; 0x6de4 <vfprintf+0x690>
    6c68:	80 37       	cpi	r24, 0x70	; 112
    6c6a:	19 f0       	breq	.+6      	; 0x6c72 <vfprintf+0x51e>
    6c6c:	88 37       	cpi	r24, 0x78	; 120
    6c6e:	11 f0       	breq	.+4      	; 0x6c74 <vfprintf+0x520>
    6c70:	b9 c0       	rjmp	.+370    	; 0x6de4 <vfprintf+0x690>
    6c72:	00 61       	ori	r16, 0x10	; 16
    6c74:	04 ff       	sbrs	r16, 4
    6c76:	09 c0       	rjmp	.+18     	; 0x6c8a <vfprintf+0x536>
    6c78:	04 60       	ori	r16, 0x04	; 4
    6c7a:	07 c0       	rjmp	.+14     	; 0x6c8a <vfprintf+0x536>
    6c7c:	24 ff       	sbrs	r18, 4
    6c7e:	08 c0       	rjmp	.+16     	; 0x6c90 <vfprintf+0x53c>
    6c80:	06 60       	ori	r16, 0x06	; 6
    6c82:	06 c0       	rjmp	.+12     	; 0x6c90 <vfprintf+0x53c>
    6c84:	28 e0       	ldi	r18, 0x08	; 8
    6c86:	30 e0       	ldi	r19, 0x00	; 0
    6c88:	05 c0       	rjmp	.+10     	; 0x6c94 <vfprintf+0x540>
    6c8a:	20 e1       	ldi	r18, 0x10	; 16
    6c8c:	30 e0       	ldi	r19, 0x00	; 0
    6c8e:	02 c0       	rjmp	.+4      	; 0x6c94 <vfprintf+0x540>
    6c90:	20 e1       	ldi	r18, 0x10	; 16
    6c92:	32 e0       	ldi	r19, 0x02	; 2
    6c94:	52 01       	movw	r10, r4
    6c96:	07 ff       	sbrs	r16, 7
    6c98:	09 c0       	rjmp	.+18     	; 0x6cac <vfprintf+0x558>
    6c9a:	f4 e0       	ldi	r31, 0x04	; 4
    6c9c:	af 0e       	add	r10, r31
    6c9e:	b1 1c       	adc	r11, r1
    6ca0:	f2 01       	movw	r30, r4
    6ca2:	60 81       	ld	r22, Z
    6ca4:	71 81       	ldd	r23, Z+1	; 0x01
    6ca6:	82 81       	ldd	r24, Z+2	; 0x02
    6ca8:	93 81       	ldd	r25, Z+3	; 0x03
    6caa:	08 c0       	rjmp	.+16     	; 0x6cbc <vfprintf+0x568>
    6cac:	f2 e0       	ldi	r31, 0x02	; 2
    6cae:	af 0e       	add	r10, r31
    6cb0:	b1 1c       	adc	r11, r1
    6cb2:	f2 01       	movw	r30, r4
    6cb4:	60 81       	ld	r22, Z
    6cb6:	71 81       	ldd	r23, Z+1	; 0x01
    6cb8:	80 e0       	ldi	r24, 0x00	; 0
    6cba:	90 e0       	ldi	r25, 0x00	; 0
    6cbc:	a3 01       	movw	r20, r6
    6cbe:	60 d2       	rcall	.+1216   	; 0x7180 <__ultoa_invert>
    6cc0:	e8 2e       	mov	r14, r24
    6cc2:	e6 18       	sub	r14, r6
    6cc4:	0f 77       	andi	r16, 0x7F	; 127
    6cc6:	30 2e       	mov	r3, r16
    6cc8:	36 fe       	sbrs	r3, 6
    6cca:	0b c0       	rjmp	.+22     	; 0x6ce2 <vfprintf+0x58e>
    6ccc:	33 2d       	mov	r19, r3
    6cce:	3e 7f       	andi	r19, 0xFE	; 254
    6cd0:	e1 16       	cp	r14, r17
    6cd2:	50 f4       	brcc	.+20     	; 0x6ce8 <vfprintf+0x594>
    6cd4:	34 fe       	sbrs	r3, 4
    6cd6:	0a c0       	rjmp	.+20     	; 0x6cec <vfprintf+0x598>
    6cd8:	32 fc       	sbrc	r3, 2
    6cda:	08 c0       	rjmp	.+16     	; 0x6cec <vfprintf+0x598>
    6cdc:	33 2d       	mov	r19, r3
    6cde:	3e 7e       	andi	r19, 0xEE	; 238
    6ce0:	05 c0       	rjmp	.+10     	; 0x6cec <vfprintf+0x598>
    6ce2:	0e 2d       	mov	r16, r14
    6ce4:	33 2d       	mov	r19, r3
    6ce6:	03 c0       	rjmp	.+6      	; 0x6cee <vfprintf+0x59a>
    6ce8:	0e 2d       	mov	r16, r14
    6cea:	01 c0       	rjmp	.+2      	; 0x6cee <vfprintf+0x59a>
    6cec:	01 2f       	mov	r16, r17
    6cee:	34 ff       	sbrs	r19, 4
    6cf0:	0c c0       	rjmp	.+24     	; 0x6d0a <vfprintf+0x5b6>
    6cf2:	fe 01       	movw	r30, r28
    6cf4:	ee 0d       	add	r30, r14
    6cf6:	f1 1d       	adc	r31, r1
    6cf8:	80 81       	ld	r24, Z
    6cfa:	80 33       	cpi	r24, 0x30	; 48
    6cfc:	11 f4       	brne	.+4      	; 0x6d02 <vfprintf+0x5ae>
    6cfe:	39 7e       	andi	r19, 0xE9	; 233
    6d00:	08 c0       	rjmp	.+16     	; 0x6d12 <vfprintf+0x5be>
    6d02:	32 ff       	sbrs	r19, 2
    6d04:	05 c0       	rjmp	.+10     	; 0x6d10 <vfprintf+0x5bc>
    6d06:	0e 5f       	subi	r16, 0xFE	; 254
    6d08:	04 c0       	rjmp	.+8      	; 0x6d12 <vfprintf+0x5be>
    6d0a:	83 2f       	mov	r24, r19
    6d0c:	86 78       	andi	r24, 0x86	; 134
    6d0e:	09 f0       	breq	.+2      	; 0x6d12 <vfprintf+0x5be>
    6d10:	0f 5f       	subi	r16, 0xFF	; 255
    6d12:	33 fd       	sbrc	r19, 3
    6d14:	12 c0       	rjmp	.+36     	; 0x6d3a <vfprintf+0x5e6>
    6d16:	30 ff       	sbrs	r19, 0
    6d18:	06 c0       	rjmp	.+12     	; 0x6d26 <vfprintf+0x5d2>
    6d1a:	1e 2d       	mov	r17, r14
    6d1c:	0f 15       	cp	r16, r15
    6d1e:	18 f4       	brcc	.+6      	; 0x6d26 <vfprintf+0x5d2>
    6d20:	1f 0d       	add	r17, r15
    6d22:	10 1b       	sub	r17, r16
    6d24:	0f 2d       	mov	r16, r15
    6d26:	0f 15       	cp	r16, r15
    6d28:	60 f4       	brcc	.+24     	; 0x6d42 <vfprintf+0x5ee>
    6d2a:	b6 01       	movw	r22, r12
    6d2c:	80 e2       	ldi	r24, 0x20	; 32
    6d2e:	90 e0       	ldi	r25, 0x00	; 0
    6d30:	3b 8b       	std	Y+19, r19	; 0x13
    6d32:	c5 d1       	rcall	.+906    	; 0x70be <fputc>
    6d34:	0f 5f       	subi	r16, 0xFF	; 255
    6d36:	3b 89       	ldd	r19, Y+19	; 0x13
    6d38:	f6 cf       	rjmp	.-20     	; 0x6d26 <vfprintf+0x5d2>
    6d3a:	0f 15       	cp	r16, r15
    6d3c:	10 f4       	brcc	.+4      	; 0x6d42 <vfprintf+0x5ee>
    6d3e:	f0 1a       	sub	r15, r16
    6d40:	01 c0       	rjmp	.+2      	; 0x6d44 <vfprintf+0x5f0>
    6d42:	f1 2c       	mov	r15, r1
    6d44:	34 ff       	sbrs	r19, 4
    6d46:	11 c0       	rjmp	.+34     	; 0x6d6a <vfprintf+0x616>
    6d48:	b6 01       	movw	r22, r12
    6d4a:	80 e3       	ldi	r24, 0x30	; 48
    6d4c:	90 e0       	ldi	r25, 0x00	; 0
    6d4e:	3b 8b       	std	Y+19, r19	; 0x13
    6d50:	b6 d1       	rcall	.+876    	; 0x70be <fputc>
    6d52:	3b 89       	ldd	r19, Y+19	; 0x13
    6d54:	32 ff       	sbrs	r19, 2
    6d56:	16 c0       	rjmp	.+44     	; 0x6d84 <vfprintf+0x630>
    6d58:	31 fd       	sbrc	r19, 1
    6d5a:	03 c0       	rjmp	.+6      	; 0x6d62 <vfprintf+0x60e>
    6d5c:	88 e7       	ldi	r24, 0x78	; 120
    6d5e:	90 e0       	ldi	r25, 0x00	; 0
    6d60:	02 c0       	rjmp	.+4      	; 0x6d66 <vfprintf+0x612>
    6d62:	88 e5       	ldi	r24, 0x58	; 88
    6d64:	90 e0       	ldi	r25, 0x00	; 0
    6d66:	b6 01       	movw	r22, r12
    6d68:	0c c0       	rjmp	.+24     	; 0x6d82 <vfprintf+0x62e>
    6d6a:	83 2f       	mov	r24, r19
    6d6c:	86 78       	andi	r24, 0x86	; 134
    6d6e:	51 f0       	breq	.+20     	; 0x6d84 <vfprintf+0x630>
    6d70:	31 ff       	sbrs	r19, 1
    6d72:	02 c0       	rjmp	.+4      	; 0x6d78 <vfprintf+0x624>
    6d74:	8b e2       	ldi	r24, 0x2B	; 43
    6d76:	01 c0       	rjmp	.+2      	; 0x6d7a <vfprintf+0x626>
    6d78:	80 e2       	ldi	r24, 0x20	; 32
    6d7a:	37 fd       	sbrc	r19, 7
    6d7c:	8d e2       	ldi	r24, 0x2D	; 45
    6d7e:	b6 01       	movw	r22, r12
    6d80:	90 e0       	ldi	r25, 0x00	; 0
    6d82:	9d d1       	rcall	.+826    	; 0x70be <fputc>
    6d84:	e1 16       	cp	r14, r17
    6d86:	30 f4       	brcc	.+12     	; 0x6d94 <vfprintf+0x640>
    6d88:	b6 01       	movw	r22, r12
    6d8a:	80 e3       	ldi	r24, 0x30	; 48
    6d8c:	90 e0       	ldi	r25, 0x00	; 0
    6d8e:	97 d1       	rcall	.+814    	; 0x70be <fputc>
    6d90:	11 50       	subi	r17, 0x01	; 1
    6d92:	f8 cf       	rjmp	.-16     	; 0x6d84 <vfprintf+0x630>
    6d94:	ea 94       	dec	r14
    6d96:	f3 01       	movw	r30, r6
    6d98:	ee 0d       	add	r30, r14
    6d9a:	f1 1d       	adc	r31, r1
    6d9c:	80 81       	ld	r24, Z
    6d9e:	b6 01       	movw	r22, r12
    6da0:	90 e0       	ldi	r25, 0x00	; 0
    6da2:	8d d1       	rcall	.+794    	; 0x70be <fputc>
    6da4:	e1 10       	cpse	r14, r1
    6da6:	f6 cf       	rjmp	.-20     	; 0x6d94 <vfprintf+0x640>
    6da8:	14 c0       	rjmp	.+40     	; 0x6dd2 <vfprintf+0x67e>
    6daa:	f4 e0       	ldi	r31, 0x04	; 4
    6dac:	ff 15       	cp	r31, r15
    6dae:	48 f5       	brcc	.+82     	; 0x6e02 <vfprintf+0x6ae>
    6db0:	84 e0       	ldi	r24, 0x04	; 4
    6db2:	f8 1a       	sub	r15, r24
    6db4:	33 fe       	sbrs	r3, 3
    6db6:	1d c0       	rjmp	.+58     	; 0x6df2 <vfprintf+0x69e>
    6db8:	21 10       	cpse	r2, r1
    6dba:	24 c0       	rjmp	.+72     	; 0x6e04 <vfprintf+0x6b0>
    6dbc:	03 ff       	sbrs	r16, 3
    6dbe:	27 c0       	rjmp	.+78     	; 0x6e0e <vfprintf+0x6ba>
    6dc0:	00 e3       	ldi	r16, 0x30	; 48
    6dc2:	11 e0       	ldi	r17, 0x01	; 1
    6dc4:	f3 2d       	mov	r31, r3
    6dc6:	f0 71       	andi	r31, 0x10	; 16
    6dc8:	3f 2e       	mov	r3, r31
    6dca:	f8 01       	movw	r30, r16
    6dcc:	84 91       	lpm	r24, Z
    6dce:	81 11       	cpse	r24, r1
    6dd0:	21 c0       	rjmp	.+66     	; 0x6e14 <vfprintf+0x6c0>
    6dd2:	ff 20       	and	r15, r15
    6dd4:	09 f4       	brne	.+2      	; 0x6dd8 <vfprintf+0x684>
    6dd6:	fd cc       	rjmp	.-1542   	; 0x67d2 <vfprintf+0x7e>
    6dd8:	b6 01       	movw	r22, r12
    6dda:	80 e2       	ldi	r24, 0x20	; 32
    6ddc:	90 e0       	ldi	r25, 0x00	; 0
    6dde:	6f d1       	rcall	.+734    	; 0x70be <fputc>
    6de0:	fa 94       	dec	r15
    6de2:	f7 cf       	rjmp	.-18     	; 0x6dd2 <vfprintf+0x67e>
    6de4:	f6 01       	movw	r30, r12
    6de6:	86 81       	ldd	r24, Z+6	; 0x06
    6de8:	97 81       	ldd	r25, Z+7	; 0x07
    6dea:	23 c0       	rjmp	.+70     	; 0x6e32 <vfprintf+0x6de>
    6dec:	8f ef       	ldi	r24, 0xFF	; 255
    6dee:	9f ef       	ldi	r25, 0xFF	; 255
    6df0:	20 c0       	rjmp	.+64     	; 0x6e32 <vfprintf+0x6de>
    6df2:	b6 01       	movw	r22, r12
    6df4:	80 e2       	ldi	r24, 0x20	; 32
    6df6:	90 e0       	ldi	r25, 0x00	; 0
    6df8:	62 d1       	rcall	.+708    	; 0x70be <fputc>
    6dfa:	fa 94       	dec	r15
    6dfc:	f1 10       	cpse	r15, r1
    6dfe:	f9 cf       	rjmp	.-14     	; 0x6df2 <vfprintf+0x69e>
    6e00:	db cf       	rjmp	.-74     	; 0x6db8 <vfprintf+0x664>
    6e02:	f1 2c       	mov	r15, r1
    6e04:	b6 01       	movw	r22, r12
    6e06:	82 2d       	mov	r24, r2
    6e08:	90 e0       	ldi	r25, 0x00	; 0
    6e0a:	59 d1       	rcall	.+690    	; 0x70be <fputc>
    6e0c:	d7 cf       	rjmp	.-82     	; 0x6dbc <vfprintf+0x668>
    6e0e:	04 e3       	ldi	r16, 0x34	; 52
    6e10:	11 e0       	ldi	r17, 0x01	; 1
    6e12:	d8 cf       	rjmp	.-80     	; 0x6dc4 <vfprintf+0x670>
    6e14:	31 10       	cpse	r3, r1
    6e16:	80 52       	subi	r24, 0x20	; 32
    6e18:	b6 01       	movw	r22, r12
    6e1a:	90 e0       	ldi	r25, 0x00	; 0
    6e1c:	50 d1       	rcall	.+672    	; 0x70be <fputc>
    6e1e:	0f 5f       	subi	r16, 0xFF	; 255
    6e20:	1f 4f       	sbci	r17, 0xFF	; 255
    6e22:	d3 cf       	rjmp	.-90     	; 0x6dca <vfprintf+0x676>
    6e24:	23 e0       	ldi	r18, 0x03	; 3
    6e26:	2f 15       	cp	r18, r15
    6e28:	10 f4       	brcc	.+4      	; 0x6e2e <vfprintf+0x6da>
    6e2a:	83 e0       	ldi	r24, 0x03	; 3
    6e2c:	c2 cf       	rjmp	.-124    	; 0x6db2 <vfprintf+0x65e>
    6e2e:	f1 2c       	mov	r15, r1
    6e30:	c5 cf       	rjmp	.-118    	; 0x6dbc <vfprintf+0x668>
    6e32:	63 96       	adiw	r28, 0x13	; 19
    6e34:	0f b6       	in	r0, 0x3f	; 63
    6e36:	f8 94       	cli
    6e38:	de bf       	out	0x3e, r29	; 62
    6e3a:	0f be       	out	0x3f, r0	; 63
    6e3c:	cd bf       	out	0x3d, r28	; 61
    6e3e:	df 91       	pop	r29
    6e40:	cf 91       	pop	r28
    6e42:	1f 91       	pop	r17
    6e44:	0f 91       	pop	r16
    6e46:	ff 90       	pop	r15
    6e48:	ef 90       	pop	r14
    6e4a:	df 90       	pop	r13
    6e4c:	cf 90       	pop	r12
    6e4e:	bf 90       	pop	r11
    6e50:	af 90       	pop	r10
    6e52:	9f 90       	pop	r9
    6e54:	8f 90       	pop	r8
    6e56:	7f 90       	pop	r7
    6e58:	6f 90       	pop	r6
    6e5a:	5f 90       	pop	r5
    6e5c:	4f 90       	pop	r4
    6e5e:	3f 90       	pop	r3
    6e60:	2f 90       	pop	r2
    6e62:	08 95       	ret

00006e64 <__divmodhi4>:
    6e64:	97 fb       	bst	r25, 7
    6e66:	07 2e       	mov	r0, r23
    6e68:	16 f4       	brtc	.+4      	; 0x6e6e <__divmodhi4+0xa>
    6e6a:	00 94       	com	r0
    6e6c:	06 d0       	rcall	.+12     	; 0x6e7a <__divmodhi4_neg1>
    6e6e:	77 fd       	sbrc	r23, 7
    6e70:	08 d0       	rcall	.+16     	; 0x6e82 <__divmodhi4_neg2>
    6e72:	1a d0       	rcall	.+52     	; 0x6ea8 <__udivmodhi4>
    6e74:	07 fc       	sbrc	r0, 7
    6e76:	05 d0       	rcall	.+10     	; 0x6e82 <__divmodhi4_neg2>
    6e78:	3e f4       	brtc	.+14     	; 0x6e88 <__divmodhi4_exit>

00006e7a <__divmodhi4_neg1>:
    6e7a:	90 95       	com	r25
    6e7c:	81 95       	neg	r24
    6e7e:	9f 4f       	sbci	r25, 0xFF	; 255
    6e80:	08 95       	ret

00006e82 <__divmodhi4_neg2>:
    6e82:	70 95       	com	r23
    6e84:	61 95       	neg	r22
    6e86:	7f 4f       	sbci	r23, 0xFF	; 255

00006e88 <__divmodhi4_exit>:
    6e88:	08 95       	ret

00006e8a <__umulhisi3>:
    6e8a:	a2 9f       	mul	r26, r18
    6e8c:	b0 01       	movw	r22, r0
    6e8e:	b3 9f       	mul	r27, r19
    6e90:	c0 01       	movw	r24, r0
    6e92:	a3 9f       	mul	r26, r19
    6e94:	70 0d       	add	r23, r0
    6e96:	81 1d       	adc	r24, r1
    6e98:	11 24       	eor	r1, r1
    6e9a:	91 1d       	adc	r25, r1
    6e9c:	b2 9f       	mul	r27, r18
    6e9e:	70 0d       	add	r23, r0
    6ea0:	81 1d       	adc	r24, r1
    6ea2:	11 24       	eor	r1, r1
    6ea4:	91 1d       	adc	r25, r1
    6ea6:	08 95       	ret

00006ea8 <__udivmodhi4>:
    6ea8:	aa 1b       	sub	r26, r26
    6eaa:	bb 1b       	sub	r27, r27
    6eac:	51 e1       	ldi	r21, 0x11	; 17
    6eae:	07 c0       	rjmp	.+14     	; 0x6ebe <__udivmodhi4_ep>

00006eb0 <__udivmodhi4_loop>:
    6eb0:	aa 1f       	adc	r26, r26
    6eb2:	bb 1f       	adc	r27, r27
    6eb4:	a6 17       	cp	r26, r22
    6eb6:	b7 07       	cpc	r27, r23
    6eb8:	10 f0       	brcs	.+4      	; 0x6ebe <__udivmodhi4_ep>
    6eba:	a6 1b       	sub	r26, r22
    6ebc:	b7 0b       	sbc	r27, r23

00006ebe <__udivmodhi4_ep>:
    6ebe:	88 1f       	adc	r24, r24
    6ec0:	99 1f       	adc	r25, r25
    6ec2:	5a 95       	dec	r21
    6ec4:	a9 f7       	brne	.-22     	; 0x6eb0 <__udivmodhi4_loop>
    6ec6:	80 95       	com	r24
    6ec8:	90 95       	com	r25
    6eca:	bc 01       	movw	r22, r24
    6ecc:	cd 01       	movw	r24, r26
    6ece:	08 95       	ret

00006ed0 <__ftoa_engine>:
    6ed0:	28 30       	cpi	r18, 0x08	; 8
    6ed2:	08 f0       	brcs	.+2      	; 0x6ed6 <__ftoa_engine+0x6>
    6ed4:	27 e0       	ldi	r18, 0x07	; 7
    6ed6:	33 27       	eor	r19, r19
    6ed8:	da 01       	movw	r26, r20
    6eda:	99 0f       	add	r25, r25
    6edc:	31 1d       	adc	r19, r1
    6ede:	87 fd       	sbrc	r24, 7
    6ee0:	91 60       	ori	r25, 0x01	; 1
    6ee2:	00 96       	adiw	r24, 0x00	; 0
    6ee4:	61 05       	cpc	r22, r1
    6ee6:	71 05       	cpc	r23, r1
    6ee8:	39 f4       	brne	.+14     	; 0x6ef8 <__ftoa_engine+0x28>
    6eea:	32 60       	ori	r19, 0x02	; 2
    6eec:	2e 5f       	subi	r18, 0xFE	; 254
    6eee:	3d 93       	st	X+, r19
    6ef0:	30 e3       	ldi	r19, 0x30	; 48
    6ef2:	2a 95       	dec	r18
    6ef4:	e1 f7       	brne	.-8      	; 0x6eee <__ftoa_engine+0x1e>
    6ef6:	08 95       	ret
    6ef8:	9f 3f       	cpi	r25, 0xFF	; 255
    6efa:	30 f0       	brcs	.+12     	; 0x6f08 <__ftoa_engine+0x38>
    6efc:	80 38       	cpi	r24, 0x80	; 128
    6efe:	71 05       	cpc	r23, r1
    6f00:	61 05       	cpc	r22, r1
    6f02:	09 f0       	breq	.+2      	; 0x6f06 <__ftoa_engine+0x36>
    6f04:	3c 5f       	subi	r19, 0xFC	; 252
    6f06:	3c 5f       	subi	r19, 0xFC	; 252
    6f08:	3d 93       	st	X+, r19
    6f0a:	91 30       	cpi	r25, 0x01	; 1
    6f0c:	08 f0       	brcs	.+2      	; 0x6f10 <__ftoa_engine+0x40>
    6f0e:	80 68       	ori	r24, 0x80	; 128
    6f10:	91 1d       	adc	r25, r1
    6f12:	df 93       	push	r29
    6f14:	cf 93       	push	r28
    6f16:	1f 93       	push	r17
    6f18:	0f 93       	push	r16
    6f1a:	ff 92       	push	r15
    6f1c:	ef 92       	push	r14
    6f1e:	19 2f       	mov	r17, r25
    6f20:	98 7f       	andi	r25, 0xF8	; 248
    6f22:	96 95       	lsr	r25
    6f24:	e9 2f       	mov	r30, r25
    6f26:	96 95       	lsr	r25
    6f28:	96 95       	lsr	r25
    6f2a:	e9 0f       	add	r30, r25
    6f2c:	ff 27       	eor	r31, r31
    6f2e:	ee 56       	subi	r30, 0x6E	; 110
    6f30:	fe 4f       	sbci	r31, 0xFE	; 254
    6f32:	99 27       	eor	r25, r25
    6f34:	33 27       	eor	r19, r19
    6f36:	ee 24       	eor	r14, r14
    6f38:	ff 24       	eor	r15, r15
    6f3a:	a7 01       	movw	r20, r14
    6f3c:	e7 01       	movw	r28, r14
    6f3e:	05 90       	lpm	r0, Z+
    6f40:	08 94       	sec
    6f42:	07 94       	ror	r0
    6f44:	28 f4       	brcc	.+10     	; 0x6f50 <__ftoa_engine+0x80>
    6f46:	36 0f       	add	r19, r22
    6f48:	e7 1e       	adc	r14, r23
    6f4a:	f8 1e       	adc	r15, r24
    6f4c:	49 1f       	adc	r20, r25
    6f4e:	51 1d       	adc	r21, r1
    6f50:	66 0f       	add	r22, r22
    6f52:	77 1f       	adc	r23, r23
    6f54:	88 1f       	adc	r24, r24
    6f56:	99 1f       	adc	r25, r25
    6f58:	06 94       	lsr	r0
    6f5a:	a1 f7       	brne	.-24     	; 0x6f44 <__ftoa_engine+0x74>
    6f5c:	05 90       	lpm	r0, Z+
    6f5e:	07 94       	ror	r0
    6f60:	28 f4       	brcc	.+10     	; 0x6f6c <__ftoa_engine+0x9c>
    6f62:	e7 0e       	add	r14, r23
    6f64:	f8 1e       	adc	r15, r24
    6f66:	49 1f       	adc	r20, r25
    6f68:	56 1f       	adc	r21, r22
    6f6a:	c1 1d       	adc	r28, r1
    6f6c:	77 0f       	add	r23, r23
    6f6e:	88 1f       	adc	r24, r24
    6f70:	99 1f       	adc	r25, r25
    6f72:	66 1f       	adc	r22, r22
    6f74:	06 94       	lsr	r0
    6f76:	a1 f7       	brne	.-24     	; 0x6f60 <__ftoa_engine+0x90>
    6f78:	05 90       	lpm	r0, Z+
    6f7a:	07 94       	ror	r0
    6f7c:	28 f4       	brcc	.+10     	; 0x6f88 <__ftoa_engine+0xb8>
    6f7e:	f8 0e       	add	r15, r24
    6f80:	49 1f       	adc	r20, r25
    6f82:	56 1f       	adc	r21, r22
    6f84:	c7 1f       	adc	r28, r23
    6f86:	d1 1d       	adc	r29, r1
    6f88:	88 0f       	add	r24, r24
    6f8a:	99 1f       	adc	r25, r25
    6f8c:	66 1f       	adc	r22, r22
    6f8e:	77 1f       	adc	r23, r23
    6f90:	06 94       	lsr	r0
    6f92:	a1 f7       	brne	.-24     	; 0x6f7c <__ftoa_engine+0xac>
    6f94:	05 90       	lpm	r0, Z+
    6f96:	07 94       	ror	r0
    6f98:	20 f4       	brcc	.+8      	; 0x6fa2 <__ftoa_engine+0xd2>
    6f9a:	49 0f       	add	r20, r25
    6f9c:	56 1f       	adc	r21, r22
    6f9e:	c7 1f       	adc	r28, r23
    6fa0:	d8 1f       	adc	r29, r24
    6fa2:	99 0f       	add	r25, r25
    6fa4:	66 1f       	adc	r22, r22
    6fa6:	77 1f       	adc	r23, r23
    6fa8:	88 1f       	adc	r24, r24
    6faa:	06 94       	lsr	r0
    6fac:	a9 f7       	brne	.-22     	; 0x6f98 <__ftoa_engine+0xc8>
    6fae:	84 91       	lpm	r24, Z
    6fb0:	10 95       	com	r17
    6fb2:	17 70       	andi	r17, 0x07	; 7
    6fb4:	41 f0       	breq	.+16     	; 0x6fc6 <__ftoa_engine+0xf6>
    6fb6:	d6 95       	lsr	r29
    6fb8:	c7 95       	ror	r28
    6fba:	57 95       	ror	r21
    6fbc:	47 95       	ror	r20
    6fbe:	f7 94       	ror	r15
    6fc0:	e7 94       	ror	r14
    6fc2:	1a 95       	dec	r17
    6fc4:	c1 f7       	brne	.-16     	; 0x6fb6 <__ftoa_engine+0xe6>
    6fc6:	e8 e3       	ldi	r30, 0x38	; 56
    6fc8:	f1 e0       	ldi	r31, 0x01	; 1
    6fca:	68 94       	set
    6fcc:	15 90       	lpm	r1, Z+
    6fce:	15 91       	lpm	r17, Z+
    6fd0:	35 91       	lpm	r19, Z+
    6fd2:	65 91       	lpm	r22, Z+
    6fd4:	95 91       	lpm	r25, Z+
    6fd6:	05 90       	lpm	r0, Z+
    6fd8:	7f e2       	ldi	r23, 0x2F	; 47
    6fda:	73 95       	inc	r23
    6fdc:	e1 18       	sub	r14, r1
    6fde:	f1 0a       	sbc	r15, r17
    6fe0:	43 0b       	sbc	r20, r19
    6fe2:	56 0b       	sbc	r21, r22
    6fe4:	c9 0b       	sbc	r28, r25
    6fe6:	d0 09       	sbc	r29, r0
    6fe8:	c0 f7       	brcc	.-16     	; 0x6fda <__ftoa_engine+0x10a>
    6fea:	e1 0c       	add	r14, r1
    6fec:	f1 1e       	adc	r15, r17
    6fee:	43 1f       	adc	r20, r19
    6ff0:	56 1f       	adc	r21, r22
    6ff2:	c9 1f       	adc	r28, r25
    6ff4:	d0 1d       	adc	r29, r0
    6ff6:	7e f4       	brtc	.+30     	; 0x7016 <__ftoa_engine+0x146>
    6ff8:	70 33       	cpi	r23, 0x30	; 48
    6ffa:	11 f4       	brne	.+4      	; 0x7000 <__ftoa_engine+0x130>
    6ffc:	8a 95       	dec	r24
    6ffe:	e6 cf       	rjmp	.-52     	; 0x6fcc <__ftoa_engine+0xfc>
    7000:	e8 94       	clt
    7002:	01 50       	subi	r16, 0x01	; 1
    7004:	30 f0       	brcs	.+12     	; 0x7012 <__ftoa_engine+0x142>
    7006:	08 0f       	add	r16, r24
    7008:	0a f4       	brpl	.+2      	; 0x700c <__ftoa_engine+0x13c>
    700a:	00 27       	eor	r16, r16
    700c:	02 17       	cp	r16, r18
    700e:	08 f4       	brcc	.+2      	; 0x7012 <__ftoa_engine+0x142>
    7010:	20 2f       	mov	r18, r16
    7012:	23 95       	inc	r18
    7014:	02 2f       	mov	r16, r18
    7016:	7a 33       	cpi	r23, 0x3A	; 58
    7018:	28 f0       	brcs	.+10     	; 0x7024 <__ftoa_engine+0x154>
    701a:	79 e3       	ldi	r23, 0x39	; 57
    701c:	7d 93       	st	X+, r23
    701e:	2a 95       	dec	r18
    7020:	e9 f7       	brne	.-6      	; 0x701c <__ftoa_engine+0x14c>
    7022:	10 c0       	rjmp	.+32     	; 0x7044 <__ftoa_engine+0x174>
    7024:	7d 93       	st	X+, r23
    7026:	2a 95       	dec	r18
    7028:	89 f6       	brne	.-94     	; 0x6fcc <__ftoa_engine+0xfc>
    702a:	06 94       	lsr	r0
    702c:	97 95       	ror	r25
    702e:	67 95       	ror	r22
    7030:	37 95       	ror	r19
    7032:	17 95       	ror	r17
    7034:	17 94       	ror	r1
    7036:	e1 18       	sub	r14, r1
    7038:	f1 0a       	sbc	r15, r17
    703a:	43 0b       	sbc	r20, r19
    703c:	56 0b       	sbc	r21, r22
    703e:	c9 0b       	sbc	r28, r25
    7040:	d0 09       	sbc	r29, r0
    7042:	98 f0       	brcs	.+38     	; 0x706a <__ftoa_engine+0x19a>
    7044:	23 95       	inc	r18
    7046:	7e 91       	ld	r23, -X
    7048:	73 95       	inc	r23
    704a:	7a 33       	cpi	r23, 0x3A	; 58
    704c:	08 f0       	brcs	.+2      	; 0x7050 <__ftoa_engine+0x180>
    704e:	70 e3       	ldi	r23, 0x30	; 48
    7050:	7c 93       	st	X, r23
    7052:	20 13       	cpse	r18, r16
    7054:	b8 f7       	brcc	.-18     	; 0x7044 <__ftoa_engine+0x174>
    7056:	7e 91       	ld	r23, -X
    7058:	70 61       	ori	r23, 0x10	; 16
    705a:	7d 93       	st	X+, r23
    705c:	30 f0       	brcs	.+12     	; 0x706a <__ftoa_engine+0x19a>
    705e:	83 95       	inc	r24
    7060:	71 e3       	ldi	r23, 0x31	; 49
    7062:	7d 93       	st	X+, r23
    7064:	70 e3       	ldi	r23, 0x30	; 48
    7066:	2a 95       	dec	r18
    7068:	e1 f7       	brne	.-8      	; 0x7062 <__ftoa_engine+0x192>
    706a:	11 24       	eor	r1, r1
    706c:	ef 90       	pop	r14
    706e:	ff 90       	pop	r15
    7070:	0f 91       	pop	r16
    7072:	1f 91       	pop	r17
    7074:	cf 91       	pop	r28
    7076:	df 91       	pop	r29
    7078:	99 27       	eor	r25, r25
    707a:	87 fd       	sbrc	r24, 7
    707c:	90 95       	com	r25
    707e:	08 95       	ret

00007080 <strnlen_P>:
    7080:	fc 01       	movw	r30, r24
    7082:	05 90       	lpm	r0, Z+
    7084:	61 50       	subi	r22, 0x01	; 1
    7086:	70 40       	sbci	r23, 0x00	; 0
    7088:	01 10       	cpse	r0, r1
    708a:	d8 f7       	brcc	.-10     	; 0x7082 <strnlen_P+0x2>
    708c:	80 95       	com	r24
    708e:	90 95       	com	r25
    7090:	8e 0f       	add	r24, r30
    7092:	9f 1f       	adc	r25, r31
    7094:	08 95       	ret

00007096 <memcpy>:
    7096:	fb 01       	movw	r30, r22
    7098:	dc 01       	movw	r26, r24
    709a:	02 c0       	rjmp	.+4      	; 0x70a0 <memcpy+0xa>
    709c:	01 90       	ld	r0, Z+
    709e:	0d 92       	st	X+, r0
    70a0:	41 50       	subi	r20, 0x01	; 1
    70a2:	50 40       	sbci	r21, 0x00	; 0
    70a4:	d8 f7       	brcc	.-10     	; 0x709c <memcpy+0x6>
    70a6:	08 95       	ret

000070a8 <strnlen>:
    70a8:	fc 01       	movw	r30, r24
    70aa:	61 50       	subi	r22, 0x01	; 1
    70ac:	70 40       	sbci	r23, 0x00	; 0
    70ae:	01 90       	ld	r0, Z+
    70b0:	01 10       	cpse	r0, r1
    70b2:	d8 f7       	brcc	.-10     	; 0x70aa <strnlen+0x2>
    70b4:	80 95       	com	r24
    70b6:	90 95       	com	r25
    70b8:	8e 0f       	add	r24, r30
    70ba:	9f 1f       	adc	r25, r31
    70bc:	08 95       	ret

000070be <fputc>:
    70be:	0f 93       	push	r16
    70c0:	1f 93       	push	r17
    70c2:	cf 93       	push	r28
    70c4:	df 93       	push	r29
    70c6:	fb 01       	movw	r30, r22
    70c8:	23 81       	ldd	r18, Z+3	; 0x03
    70ca:	21 fd       	sbrc	r18, 1
    70cc:	03 c0       	rjmp	.+6      	; 0x70d4 <fputc+0x16>
    70ce:	8f ef       	ldi	r24, 0xFF	; 255
    70d0:	9f ef       	ldi	r25, 0xFF	; 255
    70d2:	28 c0       	rjmp	.+80     	; 0x7124 <fputc+0x66>
    70d4:	22 ff       	sbrs	r18, 2
    70d6:	16 c0       	rjmp	.+44     	; 0x7104 <fputc+0x46>
    70d8:	46 81       	ldd	r20, Z+6	; 0x06
    70da:	57 81       	ldd	r21, Z+7	; 0x07
    70dc:	24 81       	ldd	r18, Z+4	; 0x04
    70de:	35 81       	ldd	r19, Z+5	; 0x05
    70e0:	42 17       	cp	r20, r18
    70e2:	53 07       	cpc	r21, r19
    70e4:	44 f4       	brge	.+16     	; 0x70f6 <fputc+0x38>
    70e6:	a0 81       	ld	r26, Z
    70e8:	b1 81       	ldd	r27, Z+1	; 0x01
    70ea:	9d 01       	movw	r18, r26
    70ec:	2f 5f       	subi	r18, 0xFF	; 255
    70ee:	3f 4f       	sbci	r19, 0xFF	; 255
    70f0:	31 83       	std	Z+1, r19	; 0x01
    70f2:	20 83       	st	Z, r18
    70f4:	8c 93       	st	X, r24
    70f6:	26 81       	ldd	r18, Z+6	; 0x06
    70f8:	37 81       	ldd	r19, Z+7	; 0x07
    70fa:	2f 5f       	subi	r18, 0xFF	; 255
    70fc:	3f 4f       	sbci	r19, 0xFF	; 255
    70fe:	37 83       	std	Z+7, r19	; 0x07
    7100:	26 83       	std	Z+6, r18	; 0x06
    7102:	10 c0       	rjmp	.+32     	; 0x7124 <fputc+0x66>
    7104:	eb 01       	movw	r28, r22
    7106:	09 2f       	mov	r16, r25
    7108:	18 2f       	mov	r17, r24
    710a:	00 84       	ldd	r0, Z+8	; 0x08
    710c:	f1 85       	ldd	r31, Z+9	; 0x09
    710e:	e0 2d       	mov	r30, r0
    7110:	19 95       	eicall
    7112:	89 2b       	or	r24, r25
    7114:	e1 f6       	brne	.-72     	; 0x70ce <fputc+0x10>
    7116:	8e 81       	ldd	r24, Y+6	; 0x06
    7118:	9f 81       	ldd	r25, Y+7	; 0x07
    711a:	01 96       	adiw	r24, 0x01	; 1
    711c:	9f 83       	std	Y+7, r25	; 0x07
    711e:	8e 83       	std	Y+6, r24	; 0x06
    7120:	81 2f       	mov	r24, r17
    7122:	90 2f       	mov	r25, r16
    7124:	df 91       	pop	r29
    7126:	cf 91       	pop	r28
    7128:	1f 91       	pop	r17
    712a:	0f 91       	pop	r16
    712c:	08 95       	ret

0000712e <vsprintf>:
    712e:	0f 93       	push	r16
    7130:	1f 93       	push	r17
    7132:	cf 93       	push	r28
    7134:	df 93       	push	r29
    7136:	cd b7       	in	r28, 0x3d	; 61
    7138:	de b7       	in	r29, 0x3e	; 62
    713a:	2e 97       	sbiw	r28, 0x0e	; 14
    713c:	0f b6       	in	r0, 0x3f	; 63
    713e:	f8 94       	cli
    7140:	de bf       	out	0x3e, r29	; 62
    7142:	0f be       	out	0x3f, r0	; 63
    7144:	cd bf       	out	0x3d, r28	; 61
    7146:	8c 01       	movw	r16, r24
    7148:	86 e0       	ldi	r24, 0x06	; 6
    714a:	8c 83       	std	Y+4, r24	; 0x04
    714c:	1a 83       	std	Y+2, r17	; 0x02
    714e:	09 83       	std	Y+1, r16	; 0x01
    7150:	8f ef       	ldi	r24, 0xFF	; 255
    7152:	9f e7       	ldi	r25, 0x7F	; 127
    7154:	9e 83       	std	Y+6, r25	; 0x06
    7156:	8d 83       	std	Y+5, r24	; 0x05
    7158:	ce 01       	movw	r24, r28
    715a:	01 96       	adiw	r24, 0x01	; 1
    715c:	fb da       	rcall	.-2570   	; 0x6754 <vfprintf>
    715e:	2f 81       	ldd	r18, Y+7	; 0x07
    7160:	38 85       	ldd	r19, Y+8	; 0x08
    7162:	f8 01       	movw	r30, r16
    7164:	e2 0f       	add	r30, r18
    7166:	f3 1f       	adc	r31, r19
    7168:	10 82       	st	Z, r1
    716a:	2e 96       	adiw	r28, 0x0e	; 14
    716c:	0f b6       	in	r0, 0x3f	; 63
    716e:	f8 94       	cli
    7170:	de bf       	out	0x3e, r29	; 62
    7172:	0f be       	out	0x3f, r0	; 63
    7174:	cd bf       	out	0x3d, r28	; 61
    7176:	df 91       	pop	r29
    7178:	cf 91       	pop	r28
    717a:	1f 91       	pop	r17
    717c:	0f 91       	pop	r16
    717e:	08 95       	ret

00007180 <__ultoa_invert>:
    7180:	fa 01       	movw	r30, r20
    7182:	aa 27       	eor	r26, r26
    7184:	28 30       	cpi	r18, 0x08	; 8
    7186:	51 f1       	breq	.+84     	; 0x71dc <__ultoa_invert+0x5c>
    7188:	20 31       	cpi	r18, 0x10	; 16
    718a:	81 f1       	breq	.+96     	; 0x71ec <__ultoa_invert+0x6c>
    718c:	e8 94       	clt
    718e:	6f 93       	push	r22
    7190:	6e 7f       	andi	r22, 0xFE	; 254
    7192:	6e 5f       	subi	r22, 0xFE	; 254
    7194:	7f 4f       	sbci	r23, 0xFF	; 255
    7196:	8f 4f       	sbci	r24, 0xFF	; 255
    7198:	9f 4f       	sbci	r25, 0xFF	; 255
    719a:	af 4f       	sbci	r26, 0xFF	; 255
    719c:	b1 e0       	ldi	r27, 0x01	; 1
    719e:	3e d0       	rcall	.+124    	; 0x721c <__ultoa_invert+0x9c>
    71a0:	b4 e0       	ldi	r27, 0x04	; 4
    71a2:	3c d0       	rcall	.+120    	; 0x721c <__ultoa_invert+0x9c>
    71a4:	67 0f       	add	r22, r23
    71a6:	78 1f       	adc	r23, r24
    71a8:	89 1f       	adc	r24, r25
    71aa:	9a 1f       	adc	r25, r26
    71ac:	a1 1d       	adc	r26, r1
    71ae:	68 0f       	add	r22, r24
    71b0:	79 1f       	adc	r23, r25
    71b2:	8a 1f       	adc	r24, r26
    71b4:	91 1d       	adc	r25, r1
    71b6:	a1 1d       	adc	r26, r1
    71b8:	6a 0f       	add	r22, r26
    71ba:	71 1d       	adc	r23, r1
    71bc:	81 1d       	adc	r24, r1
    71be:	91 1d       	adc	r25, r1
    71c0:	a1 1d       	adc	r26, r1
    71c2:	20 d0       	rcall	.+64     	; 0x7204 <__ultoa_invert+0x84>
    71c4:	09 f4       	brne	.+2      	; 0x71c8 <__ultoa_invert+0x48>
    71c6:	68 94       	set
    71c8:	3f 91       	pop	r19
    71ca:	2a e0       	ldi	r18, 0x0A	; 10
    71cc:	26 9f       	mul	r18, r22
    71ce:	11 24       	eor	r1, r1
    71d0:	30 19       	sub	r19, r0
    71d2:	30 5d       	subi	r19, 0xD0	; 208
    71d4:	31 93       	st	Z+, r19
    71d6:	de f6       	brtc	.-74     	; 0x718e <__ultoa_invert+0xe>
    71d8:	cf 01       	movw	r24, r30
    71da:	08 95       	ret
    71dc:	46 2f       	mov	r20, r22
    71de:	47 70       	andi	r20, 0x07	; 7
    71e0:	40 5d       	subi	r20, 0xD0	; 208
    71e2:	41 93       	st	Z+, r20
    71e4:	b3 e0       	ldi	r27, 0x03	; 3
    71e6:	0f d0       	rcall	.+30     	; 0x7206 <__ultoa_invert+0x86>
    71e8:	c9 f7       	brne	.-14     	; 0x71dc <__ultoa_invert+0x5c>
    71ea:	f6 cf       	rjmp	.-20     	; 0x71d8 <__ultoa_invert+0x58>
    71ec:	46 2f       	mov	r20, r22
    71ee:	4f 70       	andi	r20, 0x0F	; 15
    71f0:	40 5d       	subi	r20, 0xD0	; 208
    71f2:	4a 33       	cpi	r20, 0x3A	; 58
    71f4:	18 f0       	brcs	.+6      	; 0x71fc <__ultoa_invert+0x7c>
    71f6:	49 5d       	subi	r20, 0xD9	; 217
    71f8:	31 fd       	sbrc	r19, 1
    71fa:	40 52       	subi	r20, 0x20	; 32
    71fc:	41 93       	st	Z+, r20
    71fe:	02 d0       	rcall	.+4      	; 0x7204 <__ultoa_invert+0x84>
    7200:	a9 f7       	brne	.-22     	; 0x71ec <__ultoa_invert+0x6c>
    7202:	ea cf       	rjmp	.-44     	; 0x71d8 <__ultoa_invert+0x58>
    7204:	b4 e0       	ldi	r27, 0x04	; 4
    7206:	a6 95       	lsr	r26
    7208:	97 95       	ror	r25
    720a:	87 95       	ror	r24
    720c:	77 95       	ror	r23
    720e:	67 95       	ror	r22
    7210:	ba 95       	dec	r27
    7212:	c9 f7       	brne	.-14     	; 0x7206 <__ultoa_invert+0x86>
    7214:	00 97       	sbiw	r24, 0x00	; 0
    7216:	61 05       	cpc	r22, r1
    7218:	71 05       	cpc	r23, r1
    721a:	08 95       	ret
    721c:	9b 01       	movw	r18, r22
    721e:	ac 01       	movw	r20, r24
    7220:	0a 2e       	mov	r0, r26
    7222:	06 94       	lsr	r0
    7224:	57 95       	ror	r21
    7226:	47 95       	ror	r20
    7228:	37 95       	ror	r19
    722a:	27 95       	ror	r18
    722c:	ba 95       	dec	r27
    722e:	c9 f7       	brne	.-14     	; 0x7222 <__ultoa_invert+0xa2>
    7230:	62 0f       	add	r22, r18
    7232:	73 1f       	adc	r23, r19
    7234:	84 1f       	adc	r24, r20
    7236:	95 1f       	adc	r25, r21
    7238:	a0 1d       	adc	r26, r0
    723a:	08 95       	ret

0000723c <_exit>:
    723c:	f8 94       	cli

0000723e <__stop_program>:
    723e:	ff cf       	rjmp	.-2      	; 0x723e <__stop_program>
