
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000056c  00800200  00007a1c  00007ab0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00007a1c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000014c6  0080076c  0080076c  0000801c  2**0
                  ALLOC
  3 .comment      0000005c  00000000  00000000  0000801c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00008078  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000788  00000000  00000000  000080b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a983  00000000  00000000  00008840  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002166  00000000  00000000  000131c3  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000064c3  00000000  00000000  00015329  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001930  00000000  00000000  0001b7ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    0000312b  00000000  00000000  0001d11c  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000b90a  00000000  00000000  00020247  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000008a0  00000000  00000000  0002bb51  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	20 c1       	rjmp	.+576    	; 0x242 <__ctors_end>
       2:	00 00       	nop
       4:	3f c1       	rjmp	.+638    	; 0x284 <__bad_interrupt>
       6:	00 00       	nop
       8:	3d c1       	rjmp	.+634    	; 0x284 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 ba 19 	jmp	0x3374	; 0x3374 <__vector_3>
      10:	0c 94 cb 19 	jmp	0x3396	; 0x3396 <__vector_4>
      14:	0c 94 dc 19 	jmp	0x33b8	; 0x33b8 <__vector_5>
      18:	35 c1       	rjmp	.+618    	; 0x284 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	33 c1       	rjmp	.+614    	; 0x284 <__bad_interrupt>
      1e:	00 00       	nop
      20:	31 c1       	rjmp	.+610    	; 0x284 <__bad_interrupt>
      22:	00 00       	nop
      24:	2f c1       	rjmp	.+606    	; 0x284 <__bad_interrupt>
      26:	00 00       	nop
      28:	2d c1       	rjmp	.+602    	; 0x284 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	2b c1       	rjmp	.+598    	; 0x284 <__bad_interrupt>
      2e:	00 00       	nop
      30:	29 c1       	rjmp	.+594    	; 0x284 <__bad_interrupt>
      32:	00 00       	nop
      34:	27 c1       	rjmp	.+590    	; 0x284 <__bad_interrupt>
      36:	00 00       	nop
      38:	25 c1       	rjmp	.+586    	; 0x284 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	23 c1       	rjmp	.+582    	; 0x284 <__bad_interrupt>
      3e:	00 00       	nop
      40:	21 c1       	rjmp	.+578    	; 0x284 <__bad_interrupt>
      42:	00 00       	nop
      44:	1f c1       	rjmp	.+574    	; 0x284 <__bad_interrupt>
      46:	00 00       	nop
      48:	1d c1       	rjmp	.+570    	; 0x284 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	1b c1       	rjmp	.+566    	; 0x284 <__bad_interrupt>
      4e:	00 00       	nop
      50:	19 c1       	rjmp	.+562    	; 0x284 <__bad_interrupt>
      52:	00 00       	nop
      54:	17 c1       	rjmp	.+558    	; 0x284 <__bad_interrupt>
      56:	00 00       	nop
      58:	15 c1       	rjmp	.+554    	; 0x284 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	13 c1       	rjmp	.+550    	; 0x284 <__bad_interrupt>
      5e:	00 00       	nop
      60:	11 c1       	rjmp	.+546    	; 0x284 <__bad_interrupt>
      62:	00 00       	nop
      64:	0f c1       	rjmp	.+542    	; 0x284 <__bad_interrupt>
      66:	00 00       	nop
      68:	0d c1       	rjmp	.+538    	; 0x284 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	0b c1       	rjmp	.+534    	; 0x284 <__bad_interrupt>
      6e:	00 00       	nop
      70:	09 c1       	rjmp	.+530    	; 0x284 <__bad_interrupt>
      72:	00 00       	nop
      74:	07 c1       	rjmp	.+526    	; 0x284 <__bad_interrupt>
      76:	00 00       	nop
      78:	05 c1       	rjmp	.+522    	; 0x284 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	03 c1       	rjmp	.+518    	; 0x284 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 65 1d 	jmp	0x3aca	; 0x3aca <__vector_32>
      84:	ff c0       	rjmp	.+510    	; 0x284 <__bad_interrupt>
      86:	00 00       	nop
      88:	fd c0       	rjmp	.+506    	; 0x284 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	fb c0       	rjmp	.+502    	; 0x284 <__bad_interrupt>
      8e:	00 00       	nop
      90:	f9 c0       	rjmp	.+498    	; 0x284 <__bad_interrupt>
      92:	00 00       	nop
      94:	f7 c0       	rjmp	.+494    	; 0x284 <__bad_interrupt>
      96:	00 00       	nop
      98:	f5 c0       	rjmp	.+490    	; 0x284 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	f3 c0       	rjmp	.+486    	; 0x284 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	f1 c0       	rjmp	.+482    	; 0x284 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	ef c0       	rjmp	.+478    	; 0x284 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	ed c0       	rjmp	.+474    	; 0x284 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	eb c0       	rjmp	.+470    	; 0x284 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	e9 c0       	rjmp	.+466    	; 0x284 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	e7 c0       	rjmp	.+462    	; 0x284 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	e5 c0       	rjmp	.+458    	; 0x284 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	e3 c0       	rjmp	.+454    	; 0x284 <__bad_interrupt>
      be:	00 00       	nop
      c0:	e1 c0       	rjmp	.+450    	; 0x284 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	df c0       	rjmp	.+446    	; 0x284 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	dd c0       	rjmp	.+442    	; 0x284 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 cb 33 	jmp	0x6796	; 0x6796 <__vector_51>
      d0:	d9 c0       	rjmp	.+434    	; 0x284 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	d7 c0       	rjmp	.+430    	; 0x284 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	d5 c0       	rjmp	.+426    	; 0x284 <__bad_interrupt>
      da:	00 00       	nop
      dc:	d3 c0       	rjmp	.+422    	; 0x284 <__bad_interrupt>
      de:	00 00       	nop
      e0:	d1 c0       	rjmp	.+418    	; 0x284 <__bad_interrupt>
      e2:	00 00       	nop
      e4:	08 4a       	sbci	r16, 0xA8	; 168
      e6:	d7 3b       	cpi	r29, 0xB7	; 183
      e8:	3b ce       	rjmp	.-906    	; 0xfffffd60 <__eeprom_end+0xff7efd60>
      ea:	01 6e       	ori	r16, 0xE1	; 225
      ec:	84 bc       	out	0x24, r8	; 36
      ee:	bf fd       	.word	0xfdbf	; ????
      f0:	c1 2f       	mov	r28, r17
      f2:	3d 6c       	ori	r19, 0xCD	; 205
      f4:	74 31       	cpi	r23, 0x14	; 20
      f6:	9a bd       	out	0x2a, r25	; 42
      f8:	56 83       	std	Z+6, r21	; 0x06
      fa:	3d da       	rcall	.-2950   	; 0xfffff576 <__eeprom_end+0xff7ef576>
      fc:	3d 00       	.word	0x003d	; ????
      fe:	c7 7f       	andi	r28, 0xF7	; 247
     100:	11 be       	out	0x31, r1	; 49
     102:	d9 e4       	ldi	r29, 0x49	; 73
     104:	bb 4c       	sbci	r27, 0xCB	; 203
     106:	3e 91       	ld	r19, -X
     108:	6b aa       	std	Y+51, r6	; 0x33
     10a:	aa be       	out	0x3a, r10	; 58
     10c:	00 00       	nop
     10e:	00 80       	ld	r0, Z
     110:	3f 05       	cpc	r19, r15
     112:	a8 4c       	sbci	r26, 0xC8	; 200
     114:	cd b2       	in	r12, 0x1d	; 29
     116:	d4 4e       	sbci	r29, 0xE4	; 228
     118:	b9 38       	cpi	r27, 0x89	; 137
     11a:	36 a9       	ldd	r19, Z+54	; 0x36
     11c:	02 0c       	add	r0, r2
     11e:	50 b9       	out	0x00, r21	; 0
     120:	91 86       	std	Z+9, r9	; 0x09
     122:	88 08       	sbc	r8, r8
     124:	3c a6       	std	Y+44, r3	; 0x2c
     126:	aa aa       	std	Y+50, r10	; 0x32
     128:	2a be       	out	0x3a, r2	; 58
     12a:	00 00       	nop
     12c:	00 80       	ld	r0, Z
     12e:	3f 00       	.word	0x003f	; ????

00000130 <__trampolines_end>:
     130:	6e 61       	ori	r22, 0x1E	; 30
     132:	6e 00       	.word	0x006e	; ????

00000134 <__c.2332>:
     134:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
     144:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     154:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     164:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     174:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     184:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     194:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     1a4:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     1b4:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     1c4:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     1d4:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     1e4:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1f4:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     204:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     214:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     224:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

00000232 <prvIdleTask>:
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
	}
     232:	c3 ec       	ldi	r28, 0xC3	; 195
     234:	da e1       	ldi	r29, 0x1A	; 26
     236:	88 81       	ld	r24, Y
     238:	82 30       	cpi	r24, 0x02	; 2
     23a:	f0 f3       	brcs	.-4      	; 0x238 <prvIdleTask+0x6>
     23c:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
     240:	fa cf       	rjmp	.-12     	; 0x236 <prvIdleTask+0x4>

00000242 <__ctors_end>:
     242:	11 24       	eor	r1, r1
     244:	1f be       	out	0x3f, r1	; 63
     246:	cf ef       	ldi	r28, 0xFF	; 255
     248:	d1 e2       	ldi	r29, 0x21	; 33
     24a:	de bf       	out	0x3e, r29	; 62
     24c:	cd bf       	out	0x3d, r28	; 61
     24e:	00 e0       	ldi	r16, 0x00	; 0
     250:	0c bf       	out	0x3c, r16	; 60

00000252 <__do_copy_data>:
     252:	17 e0       	ldi	r17, 0x07	; 7
     254:	a0 e0       	ldi	r26, 0x00	; 0
     256:	b2 e0       	ldi	r27, 0x02	; 2
     258:	ec e1       	ldi	r30, 0x1C	; 28
     25a:	fa e7       	ldi	r31, 0x7A	; 122
     25c:	00 e0       	ldi	r16, 0x00	; 0
     25e:	0b bf       	out	0x3b, r16	; 59
     260:	02 c0       	rjmp	.+4      	; 0x266 <__do_copy_data+0x14>
     262:	07 90       	elpm	r0, Z+
     264:	0d 92       	st	X+, r0
     266:	ac 36       	cpi	r26, 0x6C	; 108
     268:	b1 07       	cpc	r27, r17
     26a:	d9 f7       	brne	.-10     	; 0x262 <__do_copy_data+0x10>

0000026c <__do_clear_bss>:
     26c:	2c e1       	ldi	r18, 0x1C	; 28
     26e:	ac e6       	ldi	r26, 0x6C	; 108
     270:	b7 e0       	ldi	r27, 0x07	; 7
     272:	01 c0       	rjmp	.+2      	; 0x276 <.do_clear_bss_start>

00000274 <.do_clear_bss_loop>:
     274:	1d 92       	st	X+, r1

00000276 <.do_clear_bss_start>:
     276:	a2 33       	cpi	r26, 0x32	; 50
     278:	b2 07       	cpc	r27, r18
     27a:	e1 f7       	brne	.-8      	; 0x274 <.do_clear_bss_loop>
     27c:	0e 94 0d 19 	call	0x321a	; 0x321a <main>
     280:	0c 94 0c 3d 	jmp	0x7a18	; 0x7a18 <_exit>

00000284 <__bad_interrupt>:
     284:	bd ce       	rjmp	.-646    	; 0x0 <__vectors>

00000286 <arq_init>:
  return len;
}

uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}
     286:	cf 93       	push	r28
     288:	df 93       	push	r29
     28a:	6b e3       	ldi	r22, 0x3B	; 59
     28c:	74 e0       	ldi	r23, 0x04	; 4
     28e:	81 e0       	ldi	r24, 0x01	; 1
     290:	0e 94 55 1b 	call	0x36aa	; 0x36aa <network_set_callback>
     294:	10 92 6d 07 	sts	0x076D, r1	; 0x80076d <__data_end+0x1>
     298:	10 92 6c 07 	sts	0x076C, r1	; 0x80076c <__data_end>
     29c:	ce e6       	ldi	r28, 0x6E	; 110
     29e:	d7 e0       	ldi	r29, 0x07	; 7
     2a0:	8d e8       	ldi	r24, 0x8D	; 141
     2a2:	fe 01       	movw	r30, r28
     2a4:	11 92       	st	Z+, r1
     2a6:	8a 95       	dec	r24
     2a8:	e9 f7       	brne	.-6      	; 0x2a4 <arq_init+0x1e>
     2aa:	81 e0       	ldi	r24, 0x01	; 1
     2ac:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <xQueueCreateMutex>
     2b0:	90 93 f8 07 	sts	0x07F8, r25	; 0x8007f8 <connections+0x8a>
     2b4:	80 93 f7 07 	sts	0x07F7, r24	; 0x8007f7 <connections+0x89>
     2b8:	18 82       	st	Y, r1
     2ba:	df 91       	pop	r29
     2bc:	cf 91       	pop	r28
     2be:	08 95       	ret

000002c0 <arq_new_connection>:
     2c0:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     2c4:	81 11       	cpse	r24, r1
     2c6:	16 c0       	rjmp	.+44     	; 0x2f4 <arq_new_connection+0x34>
     2c8:	ee e6       	ldi	r30, 0x6E	; 110
     2ca:	f7 e0       	ldi	r31, 0x07	; 7
     2cc:	16 8e       	std	Z+30, r1	; 0x1e
     2ce:	15 8e       	std	Z+29, r1	; 0x1d
     2d0:	16 8a       	std	Z+22, r1	; 0x16
     2d2:	15 8a       	std	Z+21, r1	; 0x15
     2d4:	14 a2       	std	Z+36, r1	; 0x24
     2d6:	13 a2       	std	Z+35, r1	; 0x23
     2d8:	12 a2       	std	Z+34, r1	; 0x22
     2da:	11 a2       	std	Z+33, r1	; 0x21
     2dc:	17 8e       	std	Z+31, r1	; 0x1f
     2de:	14 8e       	std	Z+28, r1	; 0x1c
     2e0:	12 8e       	std	Z+26, r1	; 0x1a
     2e2:	11 8e       	std	Z+25, r1	; 0x19
     2e4:	13 8e       	std	Z+27, r1	; 0x1b
     2e6:	10 92 fa 07 	sts	0x07FA, r1	; 0x8007fa <connections+0x8c>
     2ea:	10 92 f9 07 	sts	0x07F9, r1	; 0x8007f9 <connections+0x8b>
     2ee:	91 e0       	ldi	r25, 0x01	; 1
     2f0:	90 83       	st	Z, r25
     2f2:	08 95       	ret
     2f4:	8f ef       	ldi	r24, 0xFF	; 255
     2f6:	08 95       	ret

000002f8 <arq_connect>:
     2f8:	cf 92       	push	r12
     2fa:	df 92       	push	r13
     2fc:	ef 92       	push	r14
     2fe:	ff 92       	push	r15
     300:	0f 93       	push	r16
     302:	1f 93       	push	r17
     304:	cf 93       	push	r28
     306:	df 93       	push	r29
     308:	1f 92       	push	r1
     30a:	cd b7       	in	r28, 0x3d	; 61
     30c:	de b7       	in	r29, 0x3e	; 62
     30e:	69 01       	movw	r12, r18
     310:	e8 2e       	mov	r14, r24
     312:	f1 2c       	mov	r15, r1
     314:	9d e8       	ldi	r25, 0x8D	; 141
     316:	89 9f       	mul	r24, r25
     318:	80 01       	movw	r16, r0
     31a:	11 24       	eor	r1, r1
     31c:	02 59       	subi	r16, 0x92	; 146
     31e:	18 4f       	sbci	r17, 0xF8	; 248
     320:	83 e0       	ldi	r24, 0x03	; 3
     322:	f8 01       	movw	r30, r16
     324:	80 83       	st	Z, r24
     326:	50 8f       	std	Z+24, r21	; 0x18
     328:	47 8b       	std	Z+23, r20	; 0x17
     32a:	60 a3       	std	Z+32, r22	; 0x20
     32c:	82 e0       	ldi	r24, 0x02	; 2
     32e:	89 83       	std	Y+1, r24	; 0x01
     330:	0e 94 98 2f 	call	0x5f30	; 0x5f30 <xTaskGetCurrentTaskHandle>
     334:	f8 01       	movw	r30, r16
     336:	e5 57       	subi	r30, 0x75	; 117
     338:	ff 4f       	sbci	r31, 0xFF	; 255
     33a:	91 83       	std	Z+1, r25	; 0x01
     33c:	80 83       	st	Z, r24
     33e:	0e 94 d3 32 	call	0x65a6	; 0x65a6 <xTaskNotifyStateClear>
     342:	21 e0       	ldi	r18, 0x01	; 1
     344:	30 e0       	ldi	r19, 0x00	; 0
     346:	ae 01       	movw	r20, r28
     348:	4f 5f       	subi	r20, 0xFF	; 255
     34a:	5f 4f       	sbci	r21, 0xFF	; 255
     34c:	61 e0       	ldi	r22, 0x01	; 1
     34e:	f8 01       	movw	r30, r16
     350:	80 a1       	ldd	r24, Z+32	; 0x20
     352:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <network_send>
     356:	b6 01       	movw	r22, r12
     358:	81 e0       	ldi	r24, 0x01	; 1
     35a:	0e 94 51 30 	call	0x60a2	; 0x60a2 <ulTaskNotifyTake>
     35e:	67 2b       	or	r22, r23
     360:	68 2b       	or	r22, r24
     362:	69 2b       	or	r22, r25
     364:	61 f4       	brne	.+24     	; 0x37e <arq_connect+0x86>
     366:	8d e8       	ldi	r24, 0x8D	; 141
     368:	8e 9d       	mul	r24, r14
     36a:	f0 01       	movw	r30, r0
     36c:	8f 9d       	mul	r24, r15
     36e:	f0 0d       	add	r31, r0
     370:	11 24       	eor	r1, r1
     372:	e2 59       	subi	r30, 0x92	; 146
     374:	f8 4f       	sbci	r31, 0xF8	; 248
     376:	81 e0       	ldi	r24, 0x01	; 1
     378:	80 83       	st	Z, r24
     37a:	80 e0       	ldi	r24, 0x00	; 0
     37c:	2e c0       	rjmp	.+92     	; 0x3da <arq_connect+0xe2>
     37e:	80 e0       	ldi	r24, 0x00	; 0
     380:	91 e0       	ldi	r25, 0x01	; 1
     382:	65 d6       	rcall	.+3274   	; 0x104e <pvPortMalloc>
     384:	00 97       	sbiw	r24, 0x00	; 0
     386:	31 f1       	breq	.+76     	; 0x3d4 <arq_connect+0xdc>
     388:	4d e8       	ldi	r20, 0x8D	; 141
     38a:	4e 9d       	mul	r20, r14
     38c:	90 01       	movw	r18, r0
     38e:	4f 9d       	mul	r20, r15
     390:	30 0d       	add	r19, r0
     392:	11 24       	eor	r1, r1
     394:	40 e0       	ldi	r20, 0x00	; 0
     396:	51 e0       	ldi	r21, 0x01	; 1
     398:	bc 01       	movw	r22, r24
     39a:	c9 01       	movw	r24, r18
     39c:	81 59       	subi	r24, 0x91	; 145
     39e:	98 4f       	sbci	r25, 0xF8	; 248
     3a0:	5b d3       	rcall	.+1718   	; 0xa58 <buffer_init>
     3a2:	84 e1       	ldi	r24, 0x14	; 20
     3a4:	90 e0       	ldi	r25, 0x00	; 0
     3a6:	53 d6       	rcall	.+3238   	; 0x104e <pvPortMalloc>
     3a8:	00 97       	sbiw	r24, 0x00	; 0
     3aa:	b1 f0       	breq	.+44     	; 0x3d8 <arq_connect+0xe0>
     3ac:	2d e8       	ldi	r18, 0x8D	; 141
     3ae:	2e 9d       	mul	r18, r14
     3b0:	80 01       	movw	r16, r0
     3b2:	2f 9d       	mul	r18, r15
     3b4:	10 0d       	add	r17, r0
     3b6:	11 24       	eor	r1, r1
     3b8:	44 e1       	ldi	r20, 0x14	; 20
     3ba:	50 e0       	ldi	r21, 0x00	; 0
     3bc:	bc 01       	movw	r22, r24
     3be:	c8 01       	movw	r24, r16
     3c0:	87 58       	subi	r24, 0x87	; 135
     3c2:	98 4f       	sbci	r25, 0xF8	; 248
     3c4:	49 d3       	rcall	.+1682   	; 0xa58 <buffer_init>
     3c6:	f8 01       	movw	r30, r16
     3c8:	e2 59       	subi	r30, 0x92	; 146
     3ca:	f8 4f       	sbci	r31, 0xF8	; 248
     3cc:	82 e0       	ldi	r24, 0x02	; 2
     3ce:	80 83       	st	Z, r24
     3d0:	81 e0       	ldi	r24, 0x01	; 1
     3d2:	03 c0       	rjmp	.+6      	; 0x3da <arq_connect+0xe2>
     3d4:	8f ef       	ldi	r24, 0xFF	; 255
     3d6:	01 c0       	rjmp	.+2      	; 0x3da <arq_connect+0xe2>
     3d8:	8f ef       	ldi	r24, 0xFF	; 255
     3da:	0f 90       	pop	r0
     3dc:	df 91       	pop	r29
     3de:	cf 91       	pop	r28
     3e0:	1f 91       	pop	r17
     3e2:	0f 91       	pop	r16
     3e4:	ff 90       	pop	r15
     3e6:	ef 90       	pop	r14
     3e8:	df 90       	pop	r13
     3ea:	cf 90       	pop	r12
     3ec:	08 95       	ret

000003ee <arq_close_connection>:
     3ee:	cf 93       	push	r28
     3f0:	df 93       	push	r29
     3f2:	81 11       	cpse	r24, r1
     3f4:	34 c0       	rjmp	.+104    	; 0x45e <__FUSE_REGION_LENGTH__+0x5e>
     3f6:	20 e0       	ldi	r18, 0x00	; 0
     3f8:	4f ef       	ldi	r20, 0xFF	; 255
     3fa:	5f ef       	ldi	r21, 0xFF	; 255
     3fc:	60 e0       	ldi	r22, 0x00	; 0
     3fe:	70 e0       	ldi	r23, 0x00	; 0
     400:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     404:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     408:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
     40c:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     410:	82 30       	cpi	r24, 0x02	; 2
     412:	51 f0       	breq	.+20     	; 0x428 <__FUSE_REGION_LENGTH__+0x28>
     414:	60 e0       	ldi	r22, 0x00	; 0
     416:	70 e0       	ldi	r23, 0x00	; 0
     418:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     41c:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     420:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
     424:	80 e0       	ldi	r24, 0x00	; 0
     426:	1c c0       	rjmp	.+56     	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     428:	ce e6       	ldi	r28, 0x6E	; 110
     42a:	d7 e0       	ldi	r29, 0x07	; 7
     42c:	89 81       	ldd	r24, Y+1	; 0x01
     42e:	9a 81       	ldd	r25, Y+2	; 0x02
     430:	18 d7       	rcall	.+3632   	; 0x1262 <vPortFree>
     432:	8b 85       	ldd	r24, Y+11	; 0x0b
     434:	9c 85       	ldd	r25, Y+12	; 0x0c
     436:	15 d7       	rcall	.+3626   	; 0x1262 <vPortFree>
     438:	81 e0       	ldi	r24, 0x01	; 1
     43a:	88 83       	st	Y, r24
     43c:	ef 89       	ldd	r30, Y+23	; 0x17
     43e:	f8 8d       	ldd	r31, Y+24	; 0x18
     440:	60 e0       	ldi	r22, 0x00	; 0
     442:	70 e0       	ldi	r23, 0x00	; 0
     444:	80 e0       	ldi	r24, 0x00	; 0
     446:	90 e0       	ldi	r25, 0x00	; 0
     448:	19 95       	eicall
     44a:	60 e0       	ldi	r22, 0x00	; 0
     44c:	70 e0       	ldi	r23, 0x00	; 0
     44e:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     452:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     456:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
     45a:	81 e0       	ldi	r24, 0x01	; 1
     45c:	01 c0       	rjmp	.+2      	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     45e:	80 e0       	ldi	r24, 0x00	; 0
     460:	df 91       	pop	r29
     462:	cf 91       	pop	r28
     464:	08 95       	ret

00000466 <arq_send>:
     466:	ef 92       	push	r14
     468:	ff 92       	push	r15
     46a:	0f 93       	push	r16
     46c:	1f 93       	push	r17
     46e:	cf 93       	push	r28
     470:	df 93       	push	r29
     472:	00 d0       	rcall	.+0      	; 0x474 <arq_send+0xe>
     474:	1f 92       	push	r1
     476:	cd b7       	in	r28, 0x3d	; 61
     478:	de b7       	in	r29, 0x3e	; 62
     47a:	5c 83       	std	Y+4, r21	; 0x04
     47c:	4b 83       	std	Y+3, r20	; 0x03
     47e:	81 11       	cpse	r24, r1
     480:	7b c0       	rjmp	.+246    	; 0x578 <arq_send+0x112>
     482:	7b 01       	movw	r14, r22
     484:	20 e0       	ldi	r18, 0x00	; 0
     486:	4f ef       	ldi	r20, 0xFF	; 255
     488:	5f ef       	ldi	r21, 0xFF	; 255
     48a:	60 e0       	ldi	r22, 0x00	; 0
     48c:	70 e0       	ldi	r23, 0x00	; 0
     48e:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     492:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     496:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
     49a:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     49e:	82 30       	cpi	r24, 0x02	; 2
     4a0:	51 f4       	brne	.+20     	; 0x4b6 <arq_send+0x50>
     4a2:	e1 14       	cp	r14, r1
     4a4:	f1 04       	cpc	r15, r1
     4a6:	39 f0       	breq	.+14     	; 0x4b6 <arq_send+0x50>
     4a8:	0b 81       	ldd	r16, Y+3	; 0x03
     4aa:	1c 81       	ldd	r17, Y+4	; 0x04
     4ac:	c8 01       	movw	r24, r16
     4ae:	01 97       	sbiw	r24, 0x01	; 1
     4b0:	84 36       	cpi	r24, 0x64	; 100
     4b2:	91 05       	cpc	r25, r1
     4b4:	50 f0       	brcs	.+20     	; 0x4ca <arq_send+0x64>
     4b6:	60 e0       	ldi	r22, 0x00	; 0
     4b8:	70 e0       	ldi	r23, 0x00	; 0
     4ba:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     4be:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     4c2:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
     4c6:	80 e0       	ldi	r24, 0x00	; 0
     4c8:	58 c0       	rjmp	.+176    	; 0x57a <arq_send+0x114>
     4ca:	0e 5f       	subi	r16, 0xFE	; 254
     4cc:	1f 4f       	sbci	r17, 0xFF	; 255
     4ce:	20 91 77 07 	lds	r18, 0x0777	; 0x800777 <connections+0x9>
     4d2:	30 91 78 07 	lds	r19, 0x0778	; 0x800778 <connections+0xa>
     4d6:	80 e0       	ldi	r24, 0x00	; 0
     4d8:	91 e0       	ldi	r25, 0x01	; 1
     4da:	82 1b       	sub	r24, r18
     4dc:	93 0b       	sbc	r25, r19
     4de:	08 17       	cp	r16, r24
     4e0:	19 07       	cpc	r17, r25
     4e2:	08 f0       	brcs	.+2      	; 0x4e6 <arq_send+0x80>
     4e4:	3f c0       	rjmp	.+126    	; 0x564 <arq_send+0xfe>
     4e6:	20 91 81 07 	lds	r18, 0x0781	; 0x800781 <connections+0x13>
     4ea:	30 91 82 07 	lds	r19, 0x0782	; 0x800782 <connections+0x14>
     4ee:	84 e1       	ldi	r24, 0x14	; 20
     4f0:	90 e0       	ldi	r25, 0x00	; 0
     4f2:	82 1b       	sub	r24, r18
     4f4:	93 0b       	sbc	r25, r19
     4f6:	02 97       	sbiw	r24, 0x02	; 2
     4f8:	a8 f1       	brcs	.+106    	; 0x564 <arq_send+0xfe>
     4fa:	8a e2       	ldi	r24, 0x2A	; 42
     4fc:	90 e0       	ldi	r25, 0x00	; 0
     4fe:	9a 83       	std	Y+2, r25	; 0x02
     500:	89 83       	std	Y+1, r24	; 0x01
     502:	42 e0       	ldi	r20, 0x02	; 2
     504:	50 e0       	ldi	r21, 0x00	; 0
     506:	be 01       	movw	r22, r28
     508:	6d 5f       	subi	r22, 0xFD	; 253
     50a:	7f 4f       	sbci	r23, 0xFF	; 255
     50c:	8f e6       	ldi	r24, 0x6F	; 111
     50e:	97 e0       	ldi	r25, 0x07	; 7
     510:	b5 d2       	rcall	.+1386   	; 0xa7c <buffer_append>
     512:	4b 81       	ldd	r20, Y+3	; 0x03
     514:	5c 81       	ldd	r21, Y+4	; 0x04
     516:	b7 01       	movw	r22, r14
     518:	8f e6       	ldi	r24, 0x6F	; 111
     51a:	97 e0       	ldi	r25, 0x07	; 7
     51c:	af d2       	rcall	.+1374   	; 0xa7c <buffer_append>
     51e:	01 15       	cp	r16, r1
     520:	11 05       	cpc	r17, r1
     522:	b1 f0       	breq	.+44     	; 0x550 <arq_send+0xea>
     524:	90 2f       	mov	r25, r16
     526:	81 2f       	mov	r24, r17
     528:	0b 32       	cpi	r16, 0x2B	; 43
     52a:	11 05       	cpc	r17, r1
     52c:	10 f0       	brcs	.+4      	; 0x532 <arq_send+0xcc>
     52e:	9a e2       	ldi	r25, 0x2A	; 42
     530:	80 e0       	ldi	r24, 0x00	; 0
     532:	99 83       	std	Y+1, r25	; 0x01
     534:	8a 83       	std	Y+2, r24	; 0x02
     536:	42 e0       	ldi	r20, 0x02	; 2
     538:	50 e0       	ldi	r21, 0x00	; 0
     53a:	be 01       	movw	r22, r28
     53c:	6f 5f       	subi	r22, 0xFF	; 255
     53e:	7f 4f       	sbci	r23, 0xFF	; 255
     540:	89 e7       	ldi	r24, 0x79	; 121
     542:	97 e0       	ldi	r25, 0x07	; 7
     544:	9b d2       	rcall	.+1334   	; 0xa7c <buffer_append>
     546:	89 81       	ldd	r24, Y+1	; 0x01
     548:	9a 81       	ldd	r25, Y+2	; 0x02
     54a:	08 1b       	sub	r16, r24
     54c:	19 0b       	sbc	r17, r25
     54e:	51 f7       	brne	.-44     	; 0x524 <arq_send+0xbe>
     550:	60 e0       	ldi	r22, 0x00	; 0
     552:	70 e0       	ldi	r23, 0x00	; 0
     554:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     558:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     55c:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
     560:	8b 81       	ldd	r24, Y+3	; 0x03
     562:	0b c0       	rjmp	.+22     	; 0x57a <arq_send+0x114>
     564:	60 e0       	ldi	r22, 0x00	; 0
     566:	70 e0       	ldi	r23, 0x00	; 0
     568:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     56c:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     570:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
     574:	80 e0       	ldi	r24, 0x00	; 0
     576:	01 c0       	rjmp	.+2      	; 0x57a <arq_send+0x114>
     578:	80 e0       	ldi	r24, 0x00	; 0
     57a:	0f 90       	pop	r0
     57c:	0f 90       	pop	r0
     57e:	0f 90       	pop	r0
     580:	0f 90       	pop	r0
     582:	df 91       	pop	r29
     584:	cf 91       	pop	r28
     586:	1f 91       	pop	r17
     588:	0f 91       	pop	r16
     58a:	ff 90       	pop	r15
     58c:	ef 90       	pop	r14
     58e:	08 95       	ret

00000590 <arq_send_ack>:

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
     590:	cf 93       	push	r28
     592:	df 93       	push	r29
     594:	1f 92       	push	r1
     596:	1f 92       	push	r1
     598:	cd b7       	in	r28, 0x3d	; 61
     59a:	de b7       	in	r29, 0x3e	; 62
  if(id >= MAX_CONNECTIONS) return 0;
     59c:	81 11       	cpse	r24, r1
     59e:	14 c0       	rjmp	.+40     	; 0x5c8 <arq_send_ack+0x38>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
     5a0:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     5a4:	82 30       	cpi	r24, 0x02	; 2
     5a6:	91 f4       	brne	.+36     	; 0x5cc <arq_send_ack+0x3c>
     5a8:	66 23       	and	r22, r22
     5aa:	94 f0       	brlt	.+36     	; 0x5d0 <arq_send_ack+0x40>
    return 0;
  }
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
     5ac:	81 e0       	ldi	r24, 0x01	; 1
     5ae:	89 83       	std	Y+1, r24	; 0x01
  data[1] = sequence_number;
     5b0:	6a 83       	std	Y+2, r22	; 0x02
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
     5b2:	22 e0       	ldi	r18, 0x02	; 2
     5b4:	30 e0       	ldi	r19, 0x00	; 0
     5b6:	ae 01       	movw	r20, r28
     5b8:	4f 5f       	subi	r20, 0xFF	; 255
     5ba:	5f 4f       	sbci	r21, 0xFF	; 255
     5bc:	61 e0       	ldi	r22, 0x01	; 1
     5be:	80 91 8e 07 	lds	r24, 0x078E	; 0x80078e <connections+0x20>
     5c2:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <network_send>
     5c6:	05 c0       	rjmp	.+10     	; 0x5d2 <arq_send_ack+0x42>
uint8_t arq_send_string(arq_connection id, char *str) {
  return arq_send(id, (uint8_t*) str, strlen(str));
}

uint8_t arq_send_ack(arq_connection id, uint8_t sequence_number) {
  if(id >= MAX_CONNECTIONS) return 0;
     5c8:	80 e0       	ldi	r24, 0x00	; 0
     5ca:	03 c0       	rjmp	.+6      	; 0x5d2 <arq_send_ack+0x42>
  arq_connection_t *con = &connections[id];
  
  if(con->status != STATUS_CONNECTED || sequence_number > 127) {
    return 0;
     5cc:	80 e0       	ldi	r24, 0x00	; 0
     5ce:	01 c0       	rjmp	.+2      	; 0x5d2 <arq_send_ack+0x42>
     5d0:	80 e0       	ldi	r24, 0x00	; 0
  
  uint8_t data[2];
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}
     5d2:	0f 90       	pop	r0
     5d4:	0f 90       	pop	r0
     5d6:	df 91       	pop	r29
     5d8:	cf 91       	pop	r28
     5da:	08 95       	ret

000005dc <sender>:
/  When the transmit window has available space, it removes segments from the send buffer 
/  and sends them. It also increments a retransmit timer and timeout timer. When the retransmit timer
/  expires the function resends all the segments in the transmit window. On timeout the connection is
/  closed. 
*/
void sender(arq_connection id) { 
     5dc:	af 92       	push	r10
     5de:	bf 92       	push	r11
     5e0:	cf 92       	push	r12
     5e2:	df 92       	push	r13
     5e4:	ef 92       	push	r14
     5e6:	ff 92       	push	r15
     5e8:	0f 93       	push	r16
     5ea:	1f 93       	push	r17
     5ec:	cf 93       	push	r28
     5ee:	df 93       	push	r29
     5f0:	cd b7       	in	r28, 0x3d	; 61
     5f2:	de b7       	in	r29, 0x3e	; 62
     5f4:	ae 97       	sbiw	r28, 0x2e	; 46
     5f6:	0f b6       	in	r0, 0x3f	; 63
     5f8:	f8 94       	cli
     5fa:	de bf       	out	0x3e, r29	; 62
     5fc:	0f be       	out	0x3f, r0	; 63
     5fe:	cd bf       	out	0x3d, r28	; 61
  if(id >= MAX_CONNECTIONS) return;
     600:	81 11       	cpse	r24, r1
     602:	db c0       	rjmp	.+438    	; 0x7ba <sender+0x1de>
  arq_connection_t *con = &connections[id];
  if(con->status == STATUS_NONE) return;
     604:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     608:	88 23       	and	r24, r24
     60a:	09 f4       	brne	.+2      	; 0x60e <sender+0x32>
     60c:	d6 c0       	rjmp	.+428    	; 0x7ba <sender+0x1de>
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     60e:	20 e0       	ldi	r18, 0x00	; 0
     610:	4f ef       	ldi	r20, 0xFF	; 255
     612:	5f ef       	ldi	r21, 0xFF	; 255
     614:	60 e0       	ldi	r22, 0x00	; 0
     616:	70 e0       	ldi	r23, 0x00	; 0
     618:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     61c:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     620:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
  
  if(con->status != STATUS_CONNECTED) {
     624:	80 91 6e 07 	lds	r24, 0x076E	; 0x80076e <connections>
     628:	82 30       	cpi	r24, 0x02	; 2
     62a:	49 f0       	breq	.+18     	; 0x63e <sender+0x62>
    xSemaphoreGive(con->mutex);
     62c:	60 e0       	ldi	r22, 0x00	; 0
     62e:	70 e0       	ldi	r23, 0x00	; 0
     630:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     634:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     638:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
    return;
     63c:	be c0       	rjmp	.+380    	; 0x7ba <sender+0x1de>
  }

  if(con->timer_started) {
     63e:	80 91 8d 07 	lds	r24, 0x078D	; 0x80078d <connections+0x1f>
     642:	88 23       	and	r24, r24
     644:	09 f4       	brne	.+2      	; 0x648 <sender+0x6c>
     646:	62 c0       	rjmp	.+196    	; 0x70c <sender+0x130>
    con->timeout += 10;
     648:	ee e6       	ldi	r30, 0x6E	; 110
     64a:	f7 e0       	ldi	r31, 0x07	; 7
     64c:	85 8d       	ldd	r24, Z+29	; 0x1d
     64e:	96 8d       	ldd	r25, Z+30	; 0x1e
     650:	0a 96       	adiw	r24, 0x0a	; 10
     652:	96 8f       	std	Z+30, r25	; 0x1e
     654:	85 8f       	std	Z+29, r24	; 0x1d
    con->timer += 10;
     656:	24 8d       	ldd	r18, Z+28	; 0x1c
     658:	26 5f       	subi	r18, 0xF6	; 246
     65a:	24 8f       	std	Z+28, r18	; 0x1c
    if(con->timeout > LOST_CONNECTION_TIMEOUT_MS) { 
     65c:	89 3e       	cpi	r24, 0xE9	; 233
     65e:	93 40       	sbci	r25, 0x03	; 3
     660:	58 f0       	brcs	.+22     	; 0x678 <sender+0x9c>
      xSemaphoreGive(con->mutex);
     662:	60 e0       	ldi	r22, 0x00	; 0
     664:	70 e0       	ldi	r23, 0x00	; 0
     666:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     66a:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     66e:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
      arq_close_connection(id);
     672:	80 e0       	ldi	r24, 0x00	; 0
     674:	bc de       	rcall	.-648    	; 0x3ee <arq_close_connection>
      return;
     676:	a1 c0       	rjmp	.+322    	; 0x7ba <sender+0x1de>
    }
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
     678:	29 3c       	cpi	r18, 0xC9	; 201
     67a:	08 f4       	brcc	.+2      	; 0x67e <sender+0xa2>
     67c:	47 c0       	rjmp	.+142    	; 0x70c <sender+0x130>
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
     67e:	ee e6       	ldi	r30, 0x6E	; 110
     680:	f7 e0       	ldi	r31, 0x07	; 7
     682:	07 81       	ldd	r16, Z+7	; 0x07
     684:	10 85       	ldd	r17, Z+8	; 0x08
      uint16_t len = 0;
     686:	1e a6       	std	Y+46, r1	; 0x2e
     688:	1d a6       	std	Y+45, r1	; 0x2d
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
     68a:	a1 8c       	ldd	r10, Z+25	; 0x19
     68c:	83 8d       	ldd	r24, Z+27	; 0x1b
     68e:	a8 1a       	sub	r10, r24
     690:	8a 2d       	mov	r24, r10
     692:	8f 77       	andi	r24, 0x7F	; 127
     694:	a8 2e       	mov	r10, r24
      while(i < resend_count) {
     696:	c1 f1       	breq	.+112    	; 0x708 <sender+0x12c>
     698:	c1 2c       	mov	r12, r1
     69a:	d1 2c       	mov	r13, r1
     69c:	b1 2c       	mov	r11, r1
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
        data[1] = (con->sequence_base+i) & 127; 
     69e:	7f 01       	movw	r14, r30
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
        uint8_t data[MAX_PAYLOAD_SIZE];
        data[0] = TYPE_DATA;
     6a0:	19 82       	std	Y+1, r1	; 0x01
        data[1] = (con->sequence_base+i) & 127; 
     6a2:	f7 01       	movw	r30, r14
     6a4:	83 8d       	ldd	r24, Z+27	; 0x1b
     6a6:	8b 0d       	add	r24, r11
     6a8:	8f 77       	andi	r24, 0x7F	; 127
     6aa:	8a 83       	std	Y+2, r24	; 0x02
        buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*i, 2);
     6ac:	41 89       	ldd	r20, Z+17	; 0x11
     6ae:	52 89       	ldd	r21, Z+18	; 0x12
     6b0:	4c 0d       	add	r20, r12
     6b2:	5d 1d       	adc	r21, r13
     6b4:	22 e0       	ldi	r18, 0x02	; 2
     6b6:	30 e0       	ldi	r19, 0x00	; 0
     6b8:	be 01       	movw	r22, r28
     6ba:	63 5d       	subi	r22, 0xD3	; 211
     6bc:	7f 4f       	sbci	r23, 0xFF	; 255
     6be:	89 e7       	ldi	r24, 0x79	; 121
     6c0:	97 e0       	ldi	r25, 0x07	; 7
     6c2:	8b d2       	rcall	.+1302   	; 0xbda <buffer_read>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
     6c4:	2d a5       	ldd	r18, Y+45	; 0x2d
     6c6:	3e a5       	ldd	r19, Y+46	; 0x2e
     6c8:	a8 01       	movw	r20, r16
     6ca:	be 01       	movw	r22, r28
     6cc:	6d 5f       	subi	r22, 0xFD	; 253
     6ce:	7f 4f       	sbci	r23, 0xFF	; 255
     6d0:	8f e6       	ldi	r24, 0x6F	; 111
     6d2:	97 e0       	ldi	r25, 0x07	; 7
     6d4:	82 d2       	rcall	.+1284   	; 0xbda <buffer_read>
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
     6d6:	2d a5       	ldd	r18, Y+45	; 0x2d
     6d8:	3e a5       	ldd	r19, Y+46	; 0x2e
     6da:	02 0f       	add	r16, r18
     6dc:	13 1f       	adc	r17, r19
     6de:	f7 01       	movw	r30, r14
     6e0:	83 81       	ldd	r24, Z+3	; 0x03
     6e2:	94 81       	ldd	r25, Z+4	; 0x04
     6e4:	01 97       	sbiw	r24, 0x01	; 1
     6e6:	08 23       	and	r16, r24
     6e8:	19 23       	and	r17, r25
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     6ea:	2e 5f       	subi	r18, 0xFE	; 254
     6ec:	3f 4f       	sbci	r19, 0xFF	; 255
     6ee:	ae 01       	movw	r20, r28
     6f0:	4f 5f       	subi	r20, 0xFF	; 255
     6f2:	5f 4f       	sbci	r21, 0xFF	; 255
     6f4:	61 e0       	ldi	r22, 0x01	; 1
     6f6:	80 a1       	ldd	r24, Z+32	; 0x20
     6f8:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <network_send>
        ++i;
     6fc:	b3 94       	inc	r11
     6fe:	f2 e0       	ldi	r31, 0x02	; 2
     700:	cf 0e       	add	r12, r31
     702:	d1 1c       	adc	r13, r1
    if(con->timer > RETRANSMISSION_TIMEOUT_MS) {
      uint8_t i=0;
      uint16_t read_pos = con->send_buffer.tail;
      uint16_t len = 0;
      uint8_t resend_count = (con->sequence_number-con->sequence_base) & 127;
      while(i < resend_count) {
     704:	ab 10       	cpse	r10, r11
     706:	cc cf       	rjmp	.-104    	; 0x6a0 <sender+0xc4>
        buffer_read(&con->send_buffer, data+2, read_pos, len);
        read_pos = (read_pos + len) & (con->send_buffer.capacity-1);
        network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
        ++i;
      }
      con->timer = 0;
     708:	10 92 8a 07 	sts	0x078A, r1	; 0x80078a <connections+0x1c>
    }
  }
  if( ((con->sequence_number-con->sequence_base) & 127) < WINDOW_SIZE && con->send_buffer.head != con->send_buffer_window_end) {
     70c:	ee e6       	ldi	r30, 0x6E	; 110
     70e:	f7 e0       	ldi	r31, 0x07	; 7
     710:	81 8d       	ldd	r24, Z+25	; 0x19
     712:	48 2f       	mov	r20, r24
     714:	50 e0       	ldi	r21, 0x00	; 0
     716:	93 8d       	ldd	r25, Z+27	; 0x1b
     718:	49 1b       	sub	r20, r25
     71a:	51 09       	sbc	r21, r1
     71c:	4f 77       	andi	r20, 0x7F	; 127
     71e:	55 27       	eor	r21, r21
     720:	44 30       	cpi	r20, 0x04	; 4
     722:	51 05       	cpc	r21, r1
     724:	0c f0       	brlt	.+2      	; 0x728 <sender+0x14c>
     726:	41 c0       	rjmp	.+130    	; 0x7aa <sender+0x1ce>
     728:	65 81       	ldd	r22, Z+5	; 0x05
     72a:	76 81       	ldd	r23, Z+6	; 0x06
     72c:	25 89       	ldd	r18, Z+21	; 0x15
     72e:	36 89       	ldd	r19, Z+22	; 0x16
     730:	62 17       	cp	r22, r18
     732:	73 07       	cpc	r23, r19
     734:	d1 f1       	breq	.+116    	; 0x7aa <sender+0x1ce>
    uint8_t data[MAX_PAYLOAD_SIZE];
    uint16_t len;
    data[0] = TYPE_DATA;
     736:	19 82       	std	Y+1, r1	; 0x01
    data[1] = con->sequence_number;
     738:	8a 83       	std	Y+2, r24	; 0x02
    buffer_read(&con->segment_lengths, (uint8_t*) &len, con->segment_lengths.tail+2*((con->sequence_number-con->sequence_base) & 127), 2);
     73a:	8f 01       	movw	r16, r30
     73c:	44 0f       	add	r20, r20
     73e:	55 1f       	adc	r21, r21
     740:	81 89       	ldd	r24, Z+17	; 0x11
     742:	92 89       	ldd	r25, Z+18	; 0x12
     744:	48 0f       	add	r20, r24
     746:	59 1f       	adc	r21, r25
     748:	22 e0       	ldi	r18, 0x02	; 2
     74a:	30 e0       	ldi	r19, 0x00	; 0
     74c:	be 01       	movw	r22, r28
     74e:	63 5d       	subi	r22, 0xD3	; 211
     750:	7f 4f       	sbci	r23, 0xFF	; 255
     752:	89 e7       	ldi	r24, 0x79	; 121
     754:	97 e0       	ldi	r25, 0x07	; 7
     756:	41 d2       	rcall	.+1154   	; 0xbda <buffer_read>
    buffer_read(&con->send_buffer, &data[2], con->send_buffer_window_end, len);
     758:	2d a5       	ldd	r18, Y+45	; 0x2d
     75a:	3e a5       	ldd	r19, Y+46	; 0x2e
     75c:	f8 01       	movw	r30, r16
     75e:	45 89       	ldd	r20, Z+21	; 0x15
     760:	56 89       	ldd	r21, Z+22	; 0x16
     762:	be 01       	movw	r22, r28
     764:	6d 5f       	subi	r22, 0xFD	; 253
     766:	7f 4f       	sbci	r23, 0xFF	; 255
     768:	8f e6       	ldi	r24, 0x6F	; 111
     76a:	97 e0       	ldi	r25, 0x07	; 7
     76c:	36 d2       	rcall	.+1132   	; 0xbda <buffer_read>
    con->send_buffer_window_end = (con->send_buffer_window_end+len) & (con->send_buffer.capacity-1);
     76e:	2d a5       	ldd	r18, Y+45	; 0x2d
     770:	3e a5       	ldd	r19, Y+46	; 0x2e
     772:	f8 01       	movw	r30, r16
     774:	85 89       	ldd	r24, Z+21	; 0x15
     776:	96 89       	ldd	r25, Z+22	; 0x16
     778:	a9 01       	movw	r20, r18
     77a:	48 0f       	add	r20, r24
     77c:	59 1f       	adc	r21, r25
     77e:	83 81       	ldd	r24, Z+3	; 0x03
     780:	94 81       	ldd	r25, Z+4	; 0x04
     782:	01 97       	sbiw	r24, 0x01	; 1
     784:	84 23       	and	r24, r20
     786:	95 23       	and	r25, r21
     788:	96 8b       	std	Z+22, r25	; 0x16
     78a:	85 8b       	std	Z+21, r24	; 0x15
    con->timer_started = 1;
     78c:	81 e0       	ldi	r24, 0x01	; 1
     78e:	87 8f       	std	Z+31, r24	; 0x1f
    con->sequence_number = (con->sequence_number+1) & 127;
     790:	81 8d       	ldd	r24, Z+25	; 0x19
     792:	8f 5f       	subi	r24, 0xFF	; 255
     794:	8f 77       	andi	r24, 0x7F	; 127
     796:	81 8f       	std	Z+25, r24	; 0x19
    network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
     798:	2e 5f       	subi	r18, 0xFE	; 254
     79a:	3f 4f       	sbci	r19, 0xFF	; 255
     79c:	ae 01       	movw	r20, r28
     79e:	4f 5f       	subi	r20, 0xFF	; 255
     7a0:	5f 4f       	sbci	r21, 0xFF	; 255
     7a2:	61 e0       	ldi	r22, 0x01	; 1
     7a4:	80 a1       	ldd	r24, Z+32	; 0x20
     7a6:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <network_send>
  } 
  
  xSemaphoreGive(con->mutex);
     7aa:	60 e0       	ldi	r22, 0x00	; 0
     7ac:	70 e0       	ldi	r23, 0x00	; 0
     7ae:	80 91 f7 07 	lds	r24, 0x07F7	; 0x8007f7 <connections+0x89>
     7b2:	90 91 f8 07 	lds	r25, 0x07F8	; 0x8007f8 <connections+0x8a>
     7b6:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
}
     7ba:	ae 96       	adiw	r28, 0x2e	; 46
     7bc:	0f b6       	in	r0, 0x3f	; 63
     7be:	f8 94       	cli
     7c0:	de bf       	out	0x3e, r29	; 62
     7c2:	0f be       	out	0x3f, r0	; 63
     7c4:	cd bf       	out	0x3d, r28	; 61
     7c6:	df 91       	pop	r29
     7c8:	cf 91       	pop	r28
     7ca:	1f 91       	pop	r17
     7cc:	0f 91       	pop	r16
     7ce:	ff 90       	pop	r15
     7d0:	ef 90       	pop	r14
     7d2:	df 90       	pop	r13
     7d4:	cf 90       	pop	r12
     7d6:	bf 90       	pop	r11
     7d8:	af 90       	pop	r10
     7da:	08 95       	ret

000007dc <arq_reassembly>:

void arq_reassembly(arq_connection id, uint8_t *data, uint16_t len) { 
     7dc:	0f 93       	push	r16
     7de:	1f 93       	push	r17
     7e0:	cf 93       	push	r28
     7e2:	df 93       	push	r29
     7e4:	ea 01       	movw	r28, r20
  if(id >= MAX_CONNECTIONS) return;
     7e6:	81 11       	cpse	r24, r1
     7e8:	41 c0       	rjmp	.+130    	; 0x86c <arq_reassembly+0x90>
  
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
     7ea:	80 91 91 07 	lds	r24, 0x0791	; 0x800791 <connections+0x23>
     7ee:	90 91 92 07 	lds	r25, 0x0792	; 0x800792 <connections+0x24>
     7f2:	89 2b       	or	r24, r25
     7f4:	99 f4       	brne	.+38     	; 0x81c <arq_reassembly+0x40>
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
     7f6:	db 01       	movw	r26, r22
     7f8:	11 96       	adiw	r26, 0x01	; 1
     7fa:	8c 91       	ld	r24, X
     7fc:	11 97       	sbiw	r26, 0x01	; 1
     7fe:	90 e0       	ldi	r25, 0x00	; 0
     800:	98 2f       	mov	r25, r24
     802:	88 27       	eor	r24, r24
     804:	2c 91       	ld	r18, X
     806:	82 2b       	or	r24, r18
     808:	90 93 92 07 	sts	0x0792, r25	; 0x800792 <connections+0x24>
     80c:	80 93 91 07 	sts	0x0791, r24	; 0x800791 <connections+0x23>
    len-=2; // Remove the header from the length, left with the length of the payload
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
     810:	85 36       	cpi	r24, 0x65	; 101
     812:	91 05       	cpc	r25, r1
     814:	58 f5       	brcc	.+86     	; 0x86c <arq_reassembly+0x90>
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
    len-=2; // Remove the header from the length, left with the length of the payload
     816:	22 97       	sbiw	r28, 0x02	; 2
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
     818:	6e 5f       	subi	r22, 0xFE	; 254
     81a:	7f 4f       	sbci	r23, 0xFF	; 255
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
      return;
    }
  } 
  memcpy(con->message+con->num_received_bytes, data, len);
     81c:	0e e6       	ldi	r16, 0x6E	; 110
     81e:	17 e0       	ldi	r17, 0x07	; 7
     820:	f8 01       	movw	r30, r16
     822:	81 a1       	ldd	r24, Z+33	; 0x21
     824:	92 a1       	ldd	r25, Z+34	; 0x22
     826:	ae 01       	movw	r20, r28
     828:	8d 56       	subi	r24, 0x6D	; 109
     82a:	98 4f       	sbci	r25, 0xF8	; 248
     82c:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
  con->num_received_bytes += len;
     830:	d8 01       	movw	r26, r16
     832:	91 96       	adiw	r26, 0x21	; 33
     834:	6d 91       	ld	r22, X+
     836:	7c 91       	ld	r23, X
     838:	92 97       	sbiw	r26, 0x22	; 34
     83a:	6c 0f       	add	r22, r28
     83c:	7d 1f       	adc	r23, r29
     83e:	92 96       	adiw	r26, 0x22	; 34
     840:	7c 93       	st	X, r23
     842:	6e 93       	st	-X, r22
     844:	91 97       	sbiw	r26, 0x21	; 33
  
  if(con->num_received_bytes == con->receive_message_length) {
     846:	93 96       	adiw	r26, 0x23	; 35
     848:	8d 91       	ld	r24, X+
     84a:	9c 91       	ld	r25, X
     84c:	94 97       	sbiw	r26, 0x24	; 36
     84e:	68 17       	cp	r22, r24
     850:	79 07       	cpc	r23, r25
     852:	61 f4       	brne	.+24     	; 0x86c <arq_reassembly+0x90>
    con->callback_data_received(con->message, con->num_received_bytes);
     854:	57 96       	adiw	r26, 0x17	; 23
     856:	ed 91       	ld	r30, X+
     858:	fc 91       	ld	r31, X
     85a:	58 97       	sbiw	r26, 0x18	; 24
     85c:	83 e9       	ldi	r24, 0x93	; 147
     85e:	97 e0       	ldi	r25, 0x07	; 7
     860:	19 95       	eicall
    con->num_received_bytes = con->receive_message_length = 0;
     862:	f8 01       	movw	r30, r16
     864:	14 a2       	std	Z+36, r1	; 0x24
     866:	13 a2       	std	Z+35, r1	; 0x23
     868:	12 a2       	std	Z+34, r1	; 0x22
     86a:	11 a2       	std	Z+33, r1	; 0x21
  }
}
     86c:	df 91       	pop	r29
     86e:	cf 91       	pop	r28
     870:	1f 91       	pop	r17
     872:	0f 91       	pop	r16
     874:	08 95       	ret

00000876 <receiver>:
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
     876:	9f 92       	push	r9
     878:	af 92       	push	r10
     87a:	bf 92       	push	r11
     87c:	cf 92       	push	r12
     87e:	df 92       	push	r13
     880:	ef 92       	push	r14
     882:	ff 92       	push	r15
     884:	0f 93       	push	r16
     886:	1f 93       	push	r17
     888:	cf 93       	push	r28
     88a:	df 93       	push	r29
     88c:	1f 92       	push	r1
     88e:	cd b7       	in	r28, 0x3d	; 61
     890:	de b7       	in	r29, 0x3e	; 62
     892:	8b 01       	movw	r16, r22
     894:	5a 01       	movw	r10, r20
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
     896:	90 91 8e 07 	lds	r25, 0x078E	; 0x80078e <connections+0x20>
     89a:	98 13       	cpse	r25, r24
     89c:	b8 c0       	rjmp	.+368    	; 0xa0e <receiver+0x198>
     89e:	90 91 6e 07 	lds	r25, 0x076E	; 0x80076e <connections>
     8a2:	99 23       	and	r25, r25
     8a4:	09 f4       	brne	.+2      	; 0x8a8 <receiver+0x32>
     8a6:	b3 c0       	rjmp	.+358    	; 0xa0e <receiver+0x198>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     8a8:	fb 01       	movw	r30, r22
     8aa:	d0 80       	ld	r13, Z
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
      con = &connections[i];
     8ac:	0f 2e       	mov	r0, r31
     8ae:	fe e6       	ldi	r31, 0x6E	; 110
     8b0:	ef 2e       	mov	r14, r31
     8b2:	f7 e0       	ldi	r31, 0x07	; 7
     8b4:	ff 2e       	mov	r15, r31
     8b6:	f0 2d       	mov	r31, r0
     8b8:	13 c0       	rjmp	.+38     	; 0x8e0 <receiver+0x6a>
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
  if(con == NULL && type == TYPE_SYN && listening_task != NULL) {
     8ba:	e0 91 6c 07 	lds	r30, 0x076C	; 0x80076c <__data_end>
     8be:	f0 91 6d 07 	lds	r31, 0x076D	; 0x80076d <__data_end+0x1>
     8c2:	30 97       	sbiw	r30, 0x00	; 0
     8c4:	59 f0       	breq	.+22     	; 0x8dc <receiver+0x66>
    xTaskNotify(listening_task, address, eSetValueWithOverwrite);
     8c6:	48 2f       	mov	r20, r24
     8c8:	50 e0       	ldi	r21, 0x00	; 0
     8ca:	60 e0       	ldi	r22, 0x00	; 0
     8cc:	70 e0       	ldi	r23, 0x00	; 0
     8ce:	00 e0       	ldi	r16, 0x00	; 0
     8d0:	10 e0       	ldi	r17, 0x00	; 0
     8d2:	23 e0       	ldi	r18, 0x03	; 3
     8d4:	cf 01       	movw	r24, r30
     8d6:	0e 94 c7 31 	call	0x638e	; 0x638e <xTaskGenericNotify>
    return;
     8da:	aa c0       	rjmp	.+340    	; 0xa30 <receiver+0x1ba>
     8dc:	e1 2c       	mov	r14, r1
     8de:	f1 2c       	mov	r15, r1
  }
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     8e0:	20 e0       	ldi	r18, 0x00	; 0
     8e2:	4f ef       	ldi	r20, 0xFF	; 255
     8e4:	5f ef       	ldi	r21, 0xFF	; 255
     8e6:	60 e0       	ldi	r22, 0x00	; 0
     8e8:	70 e0       	ldi	r23, 0x00	; 0
     8ea:	f7 01       	movw	r30, r14
     8ec:	e7 57       	subi	r30, 0x77	; 119
     8ee:	ff 4f       	sbci	r31, 0xFF	; 255
     8f0:	80 81       	ld	r24, Z
     8f2:	91 81       	ldd	r25, Z+1	; 0x01
     8f4:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
  
  if(con->status == STATUS_CLOSED || con->status == STATUS_NONE || len == 0 || data == NULL) {
     8f8:	f7 01       	movw	r30, r14
     8fa:	80 81       	ld	r24, Z
     8fc:	82 30       	cpi	r24, 0x02	; 2
     8fe:	30 f0       	brcs	.+12     	; 0x90c <receiver+0x96>
     900:	a1 14       	cp	r10, r1
     902:	b1 04       	cpc	r11, r1
     904:	19 f0       	breq	.+6      	; 0x90c <receiver+0x96>
     906:	01 15       	cp	r16, r1
     908:	11 05       	cpc	r17, r1
     90a:	51 f4       	brne	.+20     	; 0x920 <receiver+0xaa>
    xSemaphoreGive(con->mutex);
     90c:	f7 01       	movw	r30, r14
     90e:	e7 57       	subi	r30, 0x77	; 119
     910:	ff 4f       	sbci	r31, 0xFF	; 255
     912:	60 e0       	ldi	r22, 0x00	; 0
     914:	70 e0       	ldi	r23, 0x00	; 0
     916:	80 81       	ld	r24, Z
     918:	91 81       	ldd	r25, Z+1	; 0x01
     91a:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
    return;
     91e:	88 c0       	rjmp	.+272    	; 0xa30 <receiver+0x1ba>
  }
  
  if(con->status == STATUS_CONNECTING && type == TYPE_SYNACK) {
     920:	83 30       	cpi	r24, 0x03	; 3
     922:	21 f5       	brne	.+72     	; 0x96c <receiver+0xf6>
     924:	f3 e0       	ldi	r31, 0x03	; 3
     926:	df 12       	cpse	r13, r31
     928:	21 c0       	rjmp	.+66     	; 0x96c <receiver+0xf6>
    if(con->blocked_task != NULL) {
     92a:	f7 01       	movw	r30, r14
     92c:	e5 57       	subi	r30, 0x75	; 117
     92e:	ff 4f       	sbci	r31, 0xFF	; 255
     930:	80 81       	ld	r24, Z
     932:	91 81       	ldd	r25, Z+1	; 0x01
     934:	00 97       	sbiw	r24, 0x00	; 0
     936:	81 f0       	breq	.+32     	; 0x958 <receiver+0xe2>
      xTaskNotifyGive(con->blocked_task);
     938:	00 e0       	ldi	r16, 0x00	; 0
     93a:	10 e0       	ldi	r17, 0x00	; 0
     93c:	22 e0       	ldi	r18, 0x02	; 2
     93e:	40 e0       	ldi	r20, 0x00	; 0
     940:	50 e0       	ldi	r21, 0x00	; 0
     942:	ba 01       	movw	r22, r20
     944:	0e 94 c7 31 	call	0x638e	; 0x638e <xTaskGenericNotify>
      con->blocked_task = NULL;
     948:	f7 01       	movw	r30, r14
     94a:	e5 57       	subi	r30, 0x75	; 117
     94c:	ff 4f       	sbci	r31, 0xFF	; 255
     94e:	11 82       	std	Z+1, r1	; 0x01
     950:	10 82       	st	Z, r1
      arq_send_ack(id, 0x00);
     952:	60 e0       	ldi	r22, 0x00	; 0
     954:	80 e0       	ldi	r24, 0x00	; 0
     956:	1c de       	rcall	.-968    	; 0x590 <arq_send_ack>
    }
    
    xSemaphoreGive(con->mutex);
     958:	f7 01       	movw	r30, r14
     95a:	e7 57       	subi	r30, 0x77	; 119
     95c:	ff 4f       	sbci	r31, 0xFF	; 255
     95e:	60 e0       	ldi	r22, 0x00	; 0
     960:	70 e0       	ldi	r23, 0x00	; 0
     962:	80 81       	ld	r24, Z
     964:	91 81       	ldd	r25, Z+1	; 0x01
     966:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
    return;
     96a:	62 c0       	rjmp	.+196    	; 0xa30 <receiver+0x1ba>
  }
  
  uint8_t sequence = data[1];
     96c:	f8 01       	movw	r30, r16
     96e:	c1 80       	ldd	r12, Z+1	; 0x01
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
     970:	dd 20       	and	r13, r13
     972:	09 f4       	brne	.+2      	; 0x976 <receiver+0x100>
     974:	52 c0       	rjmp	.+164    	; 0xa1a <receiver+0x1a4>
     976:	f4 e0       	ldi	r31, 0x04	; 4
     978:	df 12       	cpse	r13, r31
     97a:	13 c0       	rjmp	.+38     	; 0x9a2 <receiver+0x12c>
     97c:	53 c0       	rjmp	.+166    	; 0xa24 <receiver+0x1ae>
    if(sequence == con->request_number) {
      if(type == TYPE_DATA) arq_reassembly(id, &data[2], len-2);
     97e:	a5 01       	movw	r20, r10
     980:	42 50       	subi	r20, 0x02	; 2
     982:	51 09       	sbc	r21, r1
     984:	b8 01       	movw	r22, r16
     986:	6e 5f       	subi	r22, 0xFE	; 254
     988:	7f 4f       	sbci	r23, 0xFF	; 255
     98a:	80 e0       	ldi	r24, 0x00	; 0
     98c:	27 df       	rcall	.-434    	; 0x7dc <arq_reassembly>
      con->request_number = (con->request_number+1) & 127;
     98e:	f7 01       	movw	r30, r14
     990:	82 8d       	ldd	r24, Z+26	; 0x1a
     992:	8f 5f       	subi	r24, 0xFF	; 255
     994:	8f 77       	andi	r24, 0x7F	; 127
     996:	82 8f       	std	Z+26, r24	; 0x1a
    }
    arq_send_ack(id, con->request_number);
     998:	f7 01       	movw	r30, r14
     99a:	62 8d       	ldd	r22, Z+26	; 0x1a
     99c:	80 e0       	ldi	r24, 0x00	; 0
     99e:	f8 dd       	rcall	.-1040   	; 0x590 <arq_send_ack>
     9a0:	2c c0       	rjmp	.+88     	; 0x9fa <receiver+0x184>
  } else if(type == TYPE_ACK) {
     9a2:	f1 e0       	ldi	r31, 0x01	; 1
     9a4:	df 12       	cpse	r13, r31
     9a6:	29 c0       	rjmp	.+82     	; 0x9fa <receiver+0x184>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
     9a8:	f7 01       	movw	r30, r14
     9aa:	83 8d       	ldd	r24, Z+27	; 0x1b
     9ac:	fc 2d       	mov	r31, r12
     9ae:	f8 1b       	sub	r31, r24
     9b0:	8f 2f       	mov	r24, r31
     9b2:	8f 77       	andi	r24, 0x7F	; 127
     9b4:	98 2e       	mov	r9, r24
    if(count != 0) {
     9b6:	09 f1       	breq	.+66     	; 0x9fa <receiver+0x184>
     9b8:	d1 2c       	mov	r13, r1
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9ba:	57 01       	movw	r10, r14
     9bc:	8b e0       	ldi	r24, 0x0B	; 11
     9be:	a8 0e       	add	r10, r24
     9c0:	b1 1c       	adc	r11, r1
        buffer_remove(&con->send_buffer, NULL, len);
     9c2:	87 01       	movw	r16, r14
     9c4:	0f 5f       	subi	r16, 0xFF	; 255
     9c6:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     9c8:	42 e0       	ldi	r20, 0x02	; 2
     9ca:	50 e0       	ldi	r21, 0x00	; 0
     9cc:	be 01       	movw	r22, r28
     9ce:	6f 5f       	subi	r22, 0xFF	; 255
     9d0:	7f 4f       	sbci	r23, 0xFF	; 255
     9d2:	c5 01       	movw	r24, r10
     9d4:	50 d1       	rcall	.+672    	; 0xc76 <buffer_remove>
        buffer_remove(&con->send_buffer, NULL, len);
     9d6:	49 81       	ldd	r20, Y+1	; 0x01
     9d8:	50 e0       	ldi	r21, 0x00	; 0
     9da:	60 e0       	ldi	r22, 0x00	; 0
     9dc:	70 e0       	ldi	r23, 0x00	; 0
     9de:	c8 01       	movw	r24, r16
     9e0:	4a d1       	rcall	.+660    	; 0xc76 <buffer_remove>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
     9e2:	d3 94       	inc	r13
     9e4:	9d 10       	cpse	r9, r13
     9e6:	f0 cf       	rjmp	.-32     	; 0x9c8 <receiver+0x152>
        buffer_remove(&con->segment_lengths, &len, 2);
        buffer_remove(&con->send_buffer, NULL, len);
      }
      con->sequence_base = sequence;
     9e8:	f7 01       	movw	r30, r14
     9ea:	c3 8e       	std	Z+27, r12	; 0x1b

      con->timer = 0;
     9ec:	14 8e       	std	Z+28, r1	; 0x1c
      con->timeout = 0;
     9ee:	16 8e       	std	Z+30, r1	; 0x1e
     9f0:	15 8e       	std	Z+29, r1	; 0x1d
      if(con->sequence_base == con->sequence_number) con->timer_started = 0; // No more un-acked packets
     9f2:	81 8d       	ldd	r24, Z+25	; 0x19
     9f4:	c8 12       	cpse	r12, r24
     9f6:	01 c0       	rjmp	.+2      	; 0x9fa <receiver+0x184>
     9f8:	17 8e       	std	Z+31, r1	; 0x1f
    }
  }
  
  xSemaphoreGive(con->mutex);
     9fa:	f7 01       	movw	r30, r14
     9fc:	e7 57       	subi	r30, 0x77	; 119
     9fe:	ff 4f       	sbci	r31, 0xFF	; 255
     a00:	60 e0       	ldi	r22, 0x00	; 0
     a02:	70 e0       	ldi	r23, 0x00	; 0
     a04:	80 81       	ld	r24, Z
     a06:	91 81       	ldd	r25, Z+1	; 0x01
     a08:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
     a0c:	11 c0       	rjmp	.+34     	; 0xa30 <receiver+0x1ba>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     a0e:	f8 01       	movw	r30, r16
     a10:	d0 80       	ld	r13, Z
  
  if(con == NULL && type != TYPE_SYN) return;
     a12:	f2 e0       	ldi	r31, 0x02	; 2
     a14:	df 12       	cpse	r13, r31
     a16:	0c c0       	rjmp	.+24     	; 0xa30 <receiver+0x1ba>
     a18:	50 cf       	rjmp	.-352    	; 0x8ba <receiver+0x44>
    return;
  }
  
  uint8_t sequence = data[1];
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
    if(sequence == con->request_number) {
     a1a:	f7 01       	movw	r30, r14
     a1c:	82 8d       	ldd	r24, Z+26	; 0x1a
     a1e:	c8 12       	cpse	r12, r24
     a20:	bb cf       	rjmp	.-138    	; 0x998 <receiver+0x122>
     a22:	ad cf       	rjmp	.-166    	; 0x97e <receiver+0x108>
     a24:	f7 01       	movw	r30, r14
     a26:	82 8d       	ldd	r24, Z+26	; 0x1a
     a28:	c8 16       	cp	r12, r24
     a2a:	09 f4       	brne	.+2      	; 0xa2e <receiver+0x1b8>
     a2c:	b0 cf       	rjmp	.-160    	; 0x98e <receiver+0x118>
     a2e:	b4 cf       	rjmp	.-152    	; 0x998 <receiver+0x122>
    }
  }
  
  xSemaphoreGive(con->mutex);
  
}
     a30:	0f 90       	pop	r0
     a32:	df 91       	pop	r29
     a34:	cf 91       	pop	r28
     a36:	1f 91       	pop	r17
     a38:	0f 91       	pop	r16
     a3a:	ff 90       	pop	r15
     a3c:	ef 90       	pop	r14
     a3e:	df 90       	pop	r13
     a40:	cf 90       	pop	r12
     a42:	bf 90       	pop	r11
     a44:	af 90       	pop	r10
     a46:	9f 90       	pop	r9
     a48:	08 95       	ret

00000a4a <vARQTask>:
void vARQTask(void *pvParamters) {
  uint8_t i;
  
  while(1) {
    for(i=0;i<MAX_CONNECTIONS;i++) {
		sender(i);
     a4a:	80 e0       	ldi	r24, 0x00	; 0
     a4c:	c7 dd       	rcall	.-1138   	; 0x5dc <sender>
    }
    vTaskDelay(10 / portTICK_PERIOD_MS);
     a4e:	8a e0       	ldi	r24, 0x0A	; 10
     a50:	90 e0       	ldi	r25, 0x00	; 0
     a52:	0e 94 a5 29 	call	0x534a	; 0x534a <vTaskDelay>
     a56:	f9 cf       	rjmp	.-14     	; 0xa4a <vARQTask>

00000a58 <buffer_init>:
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
     a58:	fc 01       	movw	r30, r24
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a5a:	61 15       	cp	r22, r1
     a5c:	71 05       	cpc	r23, r1
     a5e:	61 f0       	breq	.+24     	; 0xa78 <buffer_init+0x20>
  b->buf = buf;
     a60:	71 83       	std	Z+1, r23	; 0x01
     a62:	60 83       	st	Z, r22
  b->capacity = size;
     a64:	53 83       	std	Z+3, r21	; 0x03
     a66:	42 83       	std	Z+2, r20	; 0x02
  b->head = b->tail = b->len = 0;
     a68:	11 86       	std	Z+9, r1	; 0x09
     a6a:	10 86       	std	Z+8, r1	; 0x08
     a6c:	17 82       	std	Z+7, r1	; 0x07
     a6e:	16 82       	std	Z+6, r1	; 0x06
     a70:	15 82       	std	Z+5, r1	; 0x05
     a72:	14 82       	std	Z+4, r1	; 0x04
  return 1;
     a74:	81 e0       	ldi	r24, 0x01	; 1
     a76:	08 95       	ret
#include "buffer.h"
#include "string.h"

uint8_t buffer_init(buffer_t *b, uint8_t *buf, uint16_t size) {
  if(buf == NULL) return 0; // Make sure the memory is allocated
     a78:	80 e0       	ldi	r24, 0x00	; 0
  b->buf = buf;
  b->capacity = size;
  b->head = b->tail = b->len = 0;
  return 1;
}
     a7a:	08 95       	ret

00000a7c <buffer_append>:

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
     a7c:	ef 92       	push	r14
     a7e:	ff 92       	push	r15
     a80:	0f 93       	push	r16
     a82:	1f 93       	push	r17
     a84:	cf 93       	push	r28
     a86:	df 93       	push	r29
     a88:	ec 01       	movw	r28, r24
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     a8a:	2a 81       	ldd	r18, Y+2	; 0x02
     a8c:	3b 81       	ldd	r19, Y+3	; 0x03
     a8e:	88 85       	ldd	r24, Y+8	; 0x08
     a90:	99 85       	ldd	r25, Y+9	; 0x09
     a92:	f9 01       	movw	r30, r18
     a94:	e8 1b       	sub	r30, r24
     a96:	f9 0b       	sbc	r31, r25
     a98:	e4 17       	cp	r30, r20
     a9a:	f5 07       	cpc	r31, r21
     a9c:	08 f4       	brcc	.+2      	; 0xaa0 <buffer_append+0x24>
     a9e:	49 c0       	rjmp	.+146    	; 0xb32 <buffer_append+0xb6>
     aa0:	8a 01       	movw	r16, r20
     aa2:	7b 01       	movw	r14, r22
  if(len < b->capacity - b->head) {
     aa4:	8c 81       	ldd	r24, Y+4	; 0x04
     aa6:	9d 81       	ldd	r25, Y+5	; 0x05
     aa8:	a9 01       	movw	r20, r18
     aaa:	48 1b       	sub	r20, r24
     aac:	59 0b       	sbc	r21, r25
     aae:	04 17       	cp	r16, r20
     ab0:	15 07       	cpc	r17, r21
     ab2:	a8 f4       	brcc	.+42     	; 0xade <buffer_append+0x62>
    memcpy(b->buf+b->head, data, len);
     ab4:	28 81       	ld	r18, Y
     ab6:	39 81       	ldd	r19, Y+1	; 0x01
     ab8:	a8 01       	movw	r20, r16
     aba:	82 0f       	add	r24, r18
     abc:	93 1f       	adc	r25, r19
     abe:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    b->head += len;
     ac2:	8c 81       	ldd	r24, Y+4	; 0x04
     ac4:	9d 81       	ldd	r25, Y+5	; 0x05
     ac6:	80 0f       	add	r24, r16
     ac8:	91 1f       	adc	r25, r17
     aca:	9d 83       	std	Y+5, r25	; 0x05
     acc:	8c 83       	std	Y+4, r24	; 0x04
    if(b->head == b->capacity) b->head = 0;
     ace:	2a 81       	ldd	r18, Y+2	; 0x02
     ad0:	3b 81       	ldd	r19, Y+3	; 0x03
     ad2:	82 17       	cp	r24, r18
     ad4:	93 07       	cpc	r25, r19
     ad6:	21 f5       	brne	.+72     	; 0xb20 <buffer_append+0xa4>
     ad8:	1d 82       	std	Y+5, r1	; 0x05
     ada:	1c 82       	std	Y+4, r1	; 0x04
     adc:	21 c0       	rjmp	.+66     	; 0xb20 <buffer_append+0xa4>
  } else {
    memcpy(b->buf+b->head, data, (b->capacity - b->head) );
     ade:	28 81       	ld	r18, Y
     ae0:	39 81       	ldd	r19, Y+1	; 0x01
     ae2:	82 0f       	add	r24, r18
     ae4:	93 1f       	adc	r25, r19
     ae6:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
     aea:	8c 81       	ldd	r24, Y+4	; 0x04
     aec:	9d 81       	ldd	r25, Y+5	; 0x05
     aee:	6a 81       	ldd	r22, Y+2	; 0x02
     af0:	7b 81       	ldd	r23, Y+3	; 0x03
     af2:	ac 01       	movw	r20, r24
     af4:	46 1b       	sub	r20, r22
     af6:	57 0b       	sbc	r21, r23
     af8:	40 0f       	add	r20, r16
     afa:	51 1f       	adc	r21, r17
     afc:	68 1b       	sub	r22, r24
     afe:	79 0b       	sbc	r23, r25
     b00:	6e 0d       	add	r22, r14
     b02:	7f 1d       	adc	r23, r15
     b04:	88 81       	ld	r24, Y
     b06:	99 81       	ldd	r25, Y+1	; 0x01
     b08:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    b->head = len-(b->capacity - b->head);
     b0c:	8c 81       	ldd	r24, Y+4	; 0x04
     b0e:	9d 81       	ldd	r25, Y+5	; 0x05
     b10:	2a 81       	ldd	r18, Y+2	; 0x02
     b12:	3b 81       	ldd	r19, Y+3	; 0x03
     b14:	82 1b       	sub	r24, r18
     b16:	93 0b       	sbc	r25, r19
     b18:	80 0f       	add	r24, r16
     b1a:	91 1f       	adc	r25, r17
     b1c:	9d 83       	std	Y+5, r25	; 0x05
     b1e:	8c 83       	std	Y+4, r24	; 0x04
  }
  b->len += len;
     b20:	48 85       	ldd	r20, Y+8	; 0x08
     b22:	59 85       	ldd	r21, Y+9	; 0x09
     b24:	04 0f       	add	r16, r20
     b26:	15 1f       	adc	r17, r21
     b28:	19 87       	std	Y+9, r17	; 0x09
     b2a:	08 87       	std	Y+8, r16	; 0x08
  return 1;
     b2c:	81 e0       	ldi	r24, 0x01	; 1
     b2e:	90 e0       	ldi	r25, 0x00	; 0
     b30:	02 c0       	rjmp	.+4      	; 0xb36 <buffer_append+0xba>
  b->head = b->tail = b->len = 0;
  return 1;
}

uint16_t buffer_append(buffer_t *b, uint8_t *data, uint16_t len) {
  if(len > b->capacity - b->len) return 0; //Not enough room in the buffer
     b32:	80 e0       	ldi	r24, 0x00	; 0
     b34:	90 e0       	ldi	r25, 0x00	; 0
    memcpy(b->buf, data + (b->capacity - b->head), len-(b->capacity - b->head));
    b->head = len-(b->capacity - b->head);
  }
  b->len += len;
  return 1;
}
     b36:	df 91       	pop	r29
     b38:	cf 91       	pop	r28
     b3a:	1f 91       	pop	r17
     b3c:	0f 91       	pop	r16
     b3e:	ff 90       	pop	r15
     b40:	ef 90       	pop	r14
     b42:	08 95       	ret

00000b44 <buffer_remove_token>:

//This reads bytes from the buffer until token is found, or nbytes is reached
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
     b44:	0f 93       	push	r16
     b46:	1f 93       	push	r17
     b48:	cf 93       	push	r28
     b4a:	df 93       	push	r29
     b4c:	fc 01       	movw	r30, r24
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     b4e:	21 15       	cp	r18, r1
     b50:	31 05       	cpc	r19, r1
     b52:	c9 f1       	breq	.+114    	; 0xbc6 <buffer_remove_token+0x82>
    if( b->tail != b->head ){ //see if any data is available
     b54:	a6 81       	ldd	r26, Z+6	; 0x06
     b56:	b7 81       	ldd	r27, Z+7	; 0x07
     b58:	84 81       	ldd	r24, Z+4	; 0x04
     b5a:	95 81       	ldd	r25, Z+5	; 0x05
     b5c:	a8 17       	cp	r26, r24
     b5e:	b9 07       	cpc	r27, r25
     b60:	a9 f1       	breq	.+106    	; 0xbcc <buffer_remove_token+0x88>
     b62:	c6 2f       	mov	r28, r22
     b64:	d7 2f       	mov	r29, r23
     b66:	80 e0       	ldi	r24, 0x00	; 0
     b68:	90 e0       	ldi	r25, 0x00	; 0
     b6a:	07 c0       	rjmp	.+14     	; 0xb7a <buffer_remove_token+0x36>
     b6c:	a6 81       	ldd	r26, Z+6	; 0x06
     b6e:	b7 81       	ldd	r27, Z+7	; 0x07
     b70:	64 81       	ldd	r22, Z+4	; 0x04
     b72:	75 81       	ldd	r23, Z+5	; 0x05
     b74:	a6 17       	cp	r26, r22
     b76:	b7 07       	cpc	r27, r23
     b78:	59 f1       	breq	.+86     	; 0xbd0 <buffer_remove_token+0x8c>
      *p++ = b->buf[b->tail];  //grab a byte from the buffer
     b7a:	60 81       	ld	r22, Z
     b7c:	71 81       	ldd	r23, Z+1	; 0x01
     b7e:	a6 0f       	add	r26, r22
     b80:	b7 1f       	adc	r27, r23
     b82:	5c 91       	ld	r21, X
     b84:	8e 01       	movw	r16, r28
     b86:	58 83       	st	Y, r21
      b->tail++;  //increment the tail
     b88:	66 81       	ldd	r22, Z+6	; 0x06
     b8a:	77 81       	ldd	r23, Z+7	; 0x07
     b8c:	6f 5f       	subi	r22, 0xFF	; 255
     b8e:	7f 4f       	sbci	r23, 0xFF	; 255
     b90:	77 83       	std	Z+7, r23	; 0x07
     b92:	66 83       	std	Z+6, r22	; 0x06
      b->len--;
     b94:	a0 85       	ldd	r26, Z+8	; 0x08
     b96:	b1 85       	ldd	r27, Z+9	; 0x09
     b98:	11 97       	sbiw	r26, 0x01	; 1
     b9a:	b1 87       	std	Z+9, r27	; 0x09
     b9c:	a0 87       	std	Z+8, r26	; 0x08
      if( b->tail == b->capacity ){  //check for wrap-around
     b9e:	a2 81       	ldd	r26, Z+2	; 0x02
     ba0:	b3 81       	ldd	r27, Z+3	; 0x03
     ba2:	6a 17       	cp	r22, r26
     ba4:	7b 07       	cpc	r23, r27
     ba6:	11 f4       	brne	.+4      	; 0xbac <buffer_remove_token+0x68>
        b->tail = 0;
     ba8:	17 82       	std	Z+7, r1	; 0x07
     baa:	16 82       	std	Z+6, r1	; 0x06
     bac:	21 96       	adiw	r28, 0x01	; 1
      }
      if(*(p-1) == token) return i+1;
     bae:	d8 01       	movw	r26, r16
     bb0:	5c 91       	ld	r21, X
     bb2:	54 13       	cpse	r21, r20
     bb4:	02 c0       	rjmp	.+4      	; 0xbba <buffer_remove_token+0x76>
     bb6:	01 96       	adiw	r24, 0x01	; 1
     bb8:	0b c0       	rjmp	.+22     	; 0xbd0 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     bba:	01 96       	adiw	r24, 0x01	; 1
     bbc:	28 17       	cp	r18, r24
     bbe:	39 07       	cpc	r19, r25
     bc0:	a9 f6       	brne	.-86     	; 0xb6c <buffer_remove_token+0x28>
      if(*(p-1) == token) return i+1;
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
     bc2:	c9 01       	movw	r24, r18
     bc4:	05 c0       	rjmp	.+10     	; 0xbd0 <buffer_remove_token+0x8c>
     bc6:	80 e0       	ldi	r24, 0x00	; 0
     bc8:	90 e0       	ldi	r25, 0x00	; 0
     bca:	02 c0       	rjmp	.+4      	; 0xbd0 <buffer_remove_token+0x8c>
//The number of bytes read is returned
uint16_t buffer_remove_token(buffer_t *b, uint8_t* data, uint8_t token, uint16_t nbytes){
  uint16_t i;
  uint8_t * p;
  p = data;
  for(i=0; i < nbytes; i++){
     bcc:	80 e0       	ldi	r24, 0x00	; 0
     bce:	90 e0       	ldi	r25, 0x00	; 0
    } else {
      return i; //number of bytes read
    }
  }
  return nbytes;
}
     bd0:	df 91       	pop	r29
     bd2:	cf 91       	pop	r28
     bd4:	1f 91       	pop	r17
     bd6:	0f 91       	pop	r16
     bd8:	08 95       	ret

00000bda <buffer_read>:
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
     bda:	cf 92       	push	r12
     bdc:	df 92       	push	r13
     bde:	ef 92       	push	r14
     be0:	ff 92       	push	r15
     be2:	0f 93       	push	r16
     be4:	1f 93       	push	r17
     be6:	cf 93       	push	r28
     be8:	df 93       	push	r29
     bea:	7c 01       	movw	r14, r24
     bec:	6b 01       	movw	r12, r22
     bee:	ea 01       	movw	r28, r20
     bf0:	89 01       	movw	r16, r18
  if(data == NULL) return 0;
     bf2:	67 2b       	or	r22, r23
     bf4:	a9 f1       	breq	.+106    	; 0xc60 <buffer_read+0x86>
  if(idx >= b->capacity) idx -= b->capacity;
     bf6:	fc 01       	movw	r30, r24
     bf8:	42 81       	ldd	r20, Z+2	; 0x02
     bfa:	53 81       	ldd	r21, Z+3	; 0x03
     bfc:	c4 17       	cp	r28, r20
     bfe:	d5 07       	cpc	r29, r21
     c00:	10 f0       	brcs	.+4      	; 0xc06 <buffer_read+0x2c>
     c02:	c4 1b       	sub	r28, r20
     c04:	d5 0b       	sbc	r29, r21
  if(b->capacity - idx >= len) {
     c06:	4c 1b       	sub	r20, r28
     c08:	5d 0b       	sbc	r21, r29
     c0a:	40 17       	cp	r20, r16
     c0c:	51 07       	cpc	r21, r17
     c0e:	60 f0       	brcs	.+24     	; 0xc28 <buffer_read+0x4e>
    memcpy(data, b->buf+idx, len);
     c10:	f7 01       	movw	r30, r14
     c12:	60 81       	ld	r22, Z
     c14:	71 81       	ldd	r23, Z+1	; 0x01
     c16:	6c 0f       	add	r22, r28
     c18:	7d 1f       	adc	r23, r29
     c1a:	a8 01       	movw	r20, r16
     c1c:	c6 01       	movw	r24, r12
     c1e:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
     c22:	80 2f       	mov	r24, r16
     c24:	91 2f       	mov	r25, r17
     c26:	1e c0       	rjmp	.+60     	; 0xc64 <buffer_read+0x8a>
  if(data == NULL) return 0;
  if(idx >= b->capacity) idx -= b->capacity;
  if(b->capacity - idx >= len) {
    memcpy(data, b->buf+idx, len);
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
     c28:	f7 01       	movw	r30, r14
     c2a:	60 81       	ld	r22, Z
     c2c:	71 81       	ldd	r23, Z+1	; 0x01
     c2e:	6c 0f       	add	r22, r28
     c30:	7d 1f       	adc	r23, r29
     c32:	c6 01       	movw	r24, r12
     c34:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
     c38:	f7 01       	movw	r30, r14
     c3a:	22 81       	ldd	r18, Z+2	; 0x02
     c3c:	33 81       	ldd	r19, Z+3	; 0x03
     c3e:	c9 01       	movw	r24, r18
     c40:	8c 1b       	sub	r24, r28
     c42:	9d 0b       	sbc	r25, r29
     c44:	a8 01       	movw	r20, r16
     c46:	42 1b       	sub	r20, r18
     c48:	53 0b       	sbc	r21, r19
     c4a:	4c 0f       	add	r20, r28
     c4c:	5d 1f       	adc	r21, r29
     c4e:	60 81       	ld	r22, Z
     c50:	71 81       	ldd	r23, Z+1	; 0x01
     c52:	8c 0d       	add	r24, r12
     c54:	9d 1d       	adc	r25, r13
     c56:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
  }
  return len;
     c5a:	80 2f       	mov	r24, r16
     c5c:	91 2f       	mov	r25, r17
     c5e:	02 c0       	rjmp	.+4      	; 0xc64 <buffer_read+0x8a>
  }
  return nbytes;
}
//Read, but dont remove from the buffer, 'len' bytes starting at idx
uint16_t buffer_read(buffer_t *b, uint8_t *data, uint16_t idx, uint16_t len) {
  if(data == NULL) return 0;
     c60:	80 e0       	ldi	r24, 0x00	; 0
     c62:	90 e0       	ldi	r25, 0x00	; 0
  } else {
    memcpy(data, b->buf+idx, b->capacity - idx);
    memcpy(data + (b->capacity - idx), b->buf, len - (b->capacity - idx) );
  }
  return len;
}
     c64:	df 91       	pop	r29
     c66:	cf 91       	pop	r28
     c68:	1f 91       	pop	r17
     c6a:	0f 91       	pop	r16
     c6c:	ff 90       	pop	r15
     c6e:	ef 90       	pop	r14
     c70:	df 90       	pop	r13
     c72:	cf 90       	pop	r12
     c74:	08 95       	ret

00000c76 <buffer_remove>:

//Remove 'len' bytes from the buffer and add them to 'data'
uint16_t buffer_remove(buffer_t *b, uint8_t *data, uint16_t len) {
     c76:	ef 92       	push	r14
     c78:	ff 92       	push	r15
     c7a:	0f 93       	push	r16
     c7c:	1f 93       	push	r17
     c7e:	cf 93       	push	r28
     c80:	df 93       	push	r29
     c82:	ec 01       	movw	r28, r24
     c84:	7b 01       	movw	r14, r22
  if(len > b->len) len = b->len;
     c86:	08 85       	ldd	r16, Y+8	; 0x08
     c88:	19 85       	ldd	r17, Y+9	; 0x09
     c8a:	40 17       	cp	r20, r16
     c8c:	51 07       	cpc	r21, r17
     c8e:	08 f4       	brcc	.+2      	; 0xc92 <buffer_remove+0x1c>
     c90:	8a 01       	movw	r16, r20
  if(b->capacity - b->tail >= len) {
     c92:	8e 81       	ldd	r24, Y+6	; 0x06
     c94:	9f 81       	ldd	r25, Y+7	; 0x07
     c96:	4a 81       	ldd	r20, Y+2	; 0x02
     c98:	5b 81       	ldd	r21, Y+3	; 0x03
     c9a:	48 1b       	sub	r20, r24
     c9c:	59 0b       	sbc	r21, r25
     c9e:	40 17       	cp	r20, r16
     ca0:	51 07       	cpc	r21, r17
     ca2:	c8 f0       	brcs	.+50     	; 0xcd6 <buffer_remove+0x60>
    if(data != NULL) memcpy(data, b->buf+b->tail, len);
     ca4:	e1 14       	cp	r14, r1
     ca6:	f1 04       	cpc	r15, r1
     ca8:	41 f0       	breq	.+16     	; 0xcba <buffer_remove+0x44>
     caa:	68 81       	ld	r22, Y
     cac:	79 81       	ldd	r23, Y+1	; 0x01
     cae:	68 0f       	add	r22, r24
     cb0:	79 1f       	adc	r23, r25
     cb2:	a8 01       	movw	r20, r16
     cb4:	c7 01       	movw	r24, r14
     cb6:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    b->tail = b->tail + len;
     cba:	8e 81       	ldd	r24, Y+6	; 0x06
     cbc:	9f 81       	ldd	r25, Y+7	; 0x07
     cbe:	80 0f       	add	r24, r16
     cc0:	91 1f       	adc	r25, r17
     cc2:	9f 83       	std	Y+7, r25	; 0x07
     cc4:	8e 83       	std	Y+6, r24	; 0x06
    if(b->tail == b->capacity) b->tail = 0;
     cc6:	2a 81       	ldd	r18, Y+2	; 0x02
     cc8:	3b 81       	ldd	r19, Y+3	; 0x03
     cca:	82 17       	cp	r24, r18
     ccc:	93 07       	cpc	r25, r19
     cce:	41 f5       	brne	.+80     	; 0xd20 <buffer_remove+0xaa>
     cd0:	1f 82       	std	Y+7, r1	; 0x07
     cd2:	1e 82       	std	Y+6, r1	; 0x06
     cd4:	25 c0       	rjmp	.+74     	; 0xd20 <buffer_remove+0xaa>
  } else {
    if(data != NULL) {
     cd6:	e1 14       	cp	r14, r1
     cd8:	f1 04       	cpc	r15, r1
     cda:	c1 f0       	breq	.+48     	; 0xd0c <buffer_remove+0x96>
      memcpy(data, b->buf+b->tail, b->capacity - b->tail);
     cdc:	68 81       	ld	r22, Y
     cde:	79 81       	ldd	r23, Y+1	; 0x01
     ce0:	68 0f       	add	r22, r24
     ce2:	79 1f       	adc	r23, r25
     ce4:	c7 01       	movw	r24, r14
     ce6:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
      memcpy(data + (b->capacity - b->tail), b->buf, len - (b->capacity - b->tail) );
     cea:	4e 81       	ldd	r20, Y+6	; 0x06
     cec:	5f 81       	ldd	r21, Y+7	; 0x07
     cee:	2a 81       	ldd	r18, Y+2	; 0x02
     cf0:	3b 81       	ldd	r19, Y+3	; 0x03
     cf2:	c9 01       	movw	r24, r18
     cf4:	84 1b       	sub	r24, r20
     cf6:	95 0b       	sbc	r25, r21
     cf8:	42 1b       	sub	r20, r18
     cfa:	53 0b       	sbc	r21, r19
     cfc:	40 0f       	add	r20, r16
     cfe:	51 1f       	adc	r21, r17
     d00:	68 81       	ld	r22, Y
     d02:	79 81       	ldd	r23, Y+1	; 0x01
     d04:	8e 0d       	add	r24, r14
     d06:	9f 1d       	adc	r25, r15
     d08:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    }
    b->tail = len - (b->capacity - b->tail);
     d0c:	8e 81       	ldd	r24, Y+6	; 0x06
     d0e:	9f 81       	ldd	r25, Y+7	; 0x07
     d10:	2a 81       	ldd	r18, Y+2	; 0x02
     d12:	3b 81       	ldd	r19, Y+3	; 0x03
     d14:	82 1b       	sub	r24, r18
     d16:	93 0b       	sbc	r25, r19
     d18:	80 0f       	add	r24, r16
     d1a:	91 1f       	adc	r25, r17
     d1c:	9f 83       	std	Y+7, r25	; 0x07
     d1e:	8e 83       	std	Y+6, r24	; 0x06
  }
  b->len -= len;
     d20:	88 85       	ldd	r24, Y+8	; 0x08
     d22:	99 85       	ldd	r25, Y+9	; 0x09
     d24:	80 1b       	sub	r24, r16
     d26:	91 0b       	sbc	r25, r17
     d28:	99 87       	std	Y+9, r25	; 0x09
     d2a:	88 87       	std	Y+8, r24	; 0x08
  return len;
     d2c:	c8 01       	movw	r24, r16
     d2e:	df 91       	pop	r29
     d30:	cf 91       	pop	r28
     d32:	1f 91       	pop	r17
     d34:	0f 91       	pop	r16
     d36:	ff 90       	pop	r15
     d38:	ef 90       	pop	r14
     d3a:	08 95       	ret

00000d3c <cobs_encode>:
/*****************************************************************************
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     d3c:	ef 92       	push	r14
     d3e:	ff 92       	push	r15
     d40:	0f 93       	push	r16
     d42:	1f 93       	push	r17
     d44:	cf 93       	push	r28
     d46:	df 93       	push	r29
     d48:	7c 01       	movw	r14, r24
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     d4a:	68 0f       	add	r22, r24
     d4c:	79 1f       	adc	r23, r25
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
     d4e:	fc 01       	movw	r30, r24
     d50:	31 96       	adiw	r30, 0x01	; 1
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     d52:	00 97       	sbiw	r24, 0x00	; 0
     d54:	19 f0       	breq	.+6      	; 0xd5c <cobs_encode+0x20>
     d56:	41 15       	cp	r20, r1
     d58:	51 05       	cpc	r21, r1
     d5a:	21 f4       	brne	.+8      	; 0xd64 <cobs_encode+0x28>
    {
        result.status = COBS_ENCODE_NULL_POINTER;
        return result;
     d5c:	60 e0       	ldi	r22, 0x00	; 0
     d5e:	70 e0       	ldi	r23, 0x00	; 0
     d60:	81 e0       	ldi	r24, 0x01	; 1
     d62:	4b c0       	rjmp	.+150    	; 0xdfa <cobs_encode+0xbe>
    }

    if (src_len != 0)
     d64:	21 15       	cp	r18, r1
     d66:	31 05       	cpc	r19, r1
     d68:	59 f1       	breq	.+86     	; 0xdc0 <cobs_encode+0x84>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d6a:	e6 17       	cp	r30, r22
     d6c:	f7 07       	cpc	r31, r23
     d6e:	60 f5       	brcc	.+88     	; 0xdc8 <cobs_encode+0x8c>
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     d70:	8a 01       	movw	r16, r20
     d72:	02 0f       	add	r16, r18
     d74:	13 1f       	adc	r17, r19
     d76:	da 01       	movw	r26, r20
     d78:	ec 01       	movw	r28, r24
     d7a:	91 e0       	ldi	r25, 0x01	; 1
                }
                if (search_len == 0xFF)
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     d7c:	2f ef       	ldi	r18, 0xFF	; 255
     d7e:	04 c0       	rjmp	.+8      	; 0xd88 <cobs_encode+0x4c>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     d80:	fa 01       	movw	r30, r20
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     d82:	e6 17       	cp	r30, r22
     d84:	f7 07       	cpc	r31, r23
     d86:	20 f5       	brcc	.+72     	; 0xdd0 <cobs_encode+0x94>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
                break;
            }

            src_byte = *src_ptr++;
     d88:	3d 91       	ld	r19, X+
            if (src_byte == 0)
     d8a:	31 11       	cpse	r19, r1
     d8c:	0a c0       	rjmp	.+20     	; 0xda2 <cobs_encode+0x66>
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
     d8e:	98 83       	st	Y, r25
                dst_code_write_ptr = dst_write_ptr++;
     d90:	cf 01       	movw	r24, r30
     d92:	01 96       	adiw	r24, 0x01	; 1
                search_len = 1;
                if (src_ptr >= src_end_ptr)
     d94:	a0 17       	cp	r26, r16
     d96:	b1 07       	cpc	r27, r17
     d98:	e8 f4       	brcc	.+58     	; 0xdd4 <cobs_encode+0x98>
     d9a:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     d9c:	fc 01       	movw	r30, r24
                search_len = 1;
     d9e:	91 e0       	ldi	r25, 0x01	; 1
     da0:	f0 cf       	rjmp	.-32     	; 0xd82 <cobs_encode+0x46>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     da2:	af 01       	movw	r20, r30
     da4:	4f 5f       	subi	r20, 0xFF	; 255
     da6:	5f 4f       	sbci	r21, 0xFF	; 255
     da8:	30 83       	st	Z, r19
                search_len++;
     daa:	9f 5f       	subi	r25, 0xFF	; 255
                if (src_ptr >= src_end_ptr)
     dac:	a0 17       	cp	r26, r16
     dae:	b1 07       	cpc	r27, r17
     db0:	b0 f4       	brcc	.+44     	; 0xdde <cobs_encode+0xa2>
                {
                    break;
                }
                if (search_len == 0xFF)
     db2:	9f 3f       	cpi	r25, 0xFF	; 255
     db4:	29 f7       	brne	.-54     	; 0xd80 <cobs_encode+0x44>
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
     db6:	28 83       	st	Y, r18
                    dst_code_write_ptr = dst_write_ptr++;
     db8:	32 96       	adiw	r30, 0x02	; 2
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     dba:	ea 01       	movw	r28, r20
                {
                    /* We have a long string of non-zero bytes, so we need
                     * to write out a length code of 0xFF. */
                    *dst_code_write_ptr = search_len;
                    dst_code_write_ptr = dst_write_ptr++;
                    search_len = 1;
     dbc:	91 e0       	ldi	r25, 0x01	; 1
     dbe:	e1 cf       	rjmp	.-62     	; 0xd82 <cobs_encode+0x46>
cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
     dc0:	ec 01       	movw	r28, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     dc2:	80 e0       	ldi	r24, 0x00	; 0
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_code_write_ptr  = dst_buf_ptr;
    uint8_t *           dst_write_ptr       = dst_code_write_ptr + 1;
    uint8_t             src_byte            = 0;
    uint8_t             search_len          = 1;
     dc4:	91 e0       	ldi	r25, 0x01	; 1
     dc6:	0d c0       	rjmp	.+26     	; 0xde2 <cobs_encode+0xa6>
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     dc8:	ec 01       	movw	r28, r24
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dca:	82 e0       	ldi	r24, 0x02	; 2
    {
        /* Iterate over the source bytes */
        for (;;)
        {
            /* Check for running out of output buffer space */
            if (dst_write_ptr >= dst_buf_end_ptr)
     dcc:	91 e0       	ldi	r25, 0x01	; 1
     dce:	09 c0       	rjmp	.+18     	; 0xde2 <cobs_encode+0xa6>
            {
                result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dd0:	82 e0       	ldi	r24, 0x02	; 2
     dd2:	07 c0       	rjmp	.+14     	; 0xde2 <cobs_encode+0xa6>
     dd4:	ef 01       	movw	r28, r30
            src_byte = *src_ptr++;
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
     dd6:	fc 01       	movw	r30, r24
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     dd8:	80 e0       	ldi	r24, 0x00	; 0
            if (src_byte == 0)
            {
                /* We found a zero byte */
                *dst_code_write_ptr = search_len;
                dst_code_write_ptr = dst_write_ptr++;
                search_len = 1;
     dda:	91 e0       	ldi	r25, 0x01	; 1
     ddc:	02 c0       	rjmp	.+4      	; 0xde2 <cobs_encode+0xa6>
                }
            }
            else
            {
                /* Copy the non-zero byte to the destination buffer */
                *dst_write_ptr++ = src_byte;
     dde:	fa 01       	movw	r30, r20
 * Functions
 ****************************************************************************/

cobs_encode_result cobs_encode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_encode_result  result              = { 0, COBS_ENCODE_OK };
     de0:	80 e0       	ldi	r24, 0x00	; 0

    /* We've reached the end of the source data (or possibly run out of output buffer)
     * Finalise the remaining output. In particular, write the code (length) byte.
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
     de2:	c6 17       	cp	r28, r22
     de4:	d7 07       	cpc	r29, r23
     de6:	18 f4       	brcc	.+6      	; 0xdee <cobs_encode+0xb2>
        dst_write_ptr = dst_buf_end_ptr;
    }
    else
    {
        /* Write the last code (length) byte. */
        *dst_code_write_ptr = search_len;
     de8:	98 83       	st	Y, r25
     dea:	bf 01       	movw	r22, r30
     dec:	01 c0       	rjmp	.+2      	; 0xdf0 <cobs_encode+0xb4>
     * Update the pointer to calculate the final output length.
     */
    if (dst_code_write_ptr >= dst_buf_end_ptr)
    {
        /* We've run out of output buffer to write the code byte. */
        result.status |= COBS_ENCODE_OUT_BUFFER_OVERFLOW;
     dee:	82 e0       	ldi	r24, 0x02	; 2
    }

    /* Calculate the output length, from the value of dst_code_write_ptr */
    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     df0:	9b 01       	movw	r18, r22
     df2:	2e 19       	sub	r18, r14
     df4:	3f 09       	sbc	r19, r15
     df6:	62 2f       	mov	r22, r18
     df8:	73 2f       	mov	r23, r19
}
     dfa:	df 91       	pop	r29
     dfc:	cf 91       	pop	r28
     dfe:	1f 91       	pop	r17
     e00:	0f 91       	pop	r16
     e02:	ff 90       	pop	r15
     e04:	ef 90       	pop	r14
     e06:	08 95       	ret

00000e08 <cobs_decode>:


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
     e08:	af 92       	push	r10
     e0a:	bf 92       	push	r11
     e0c:	cf 92       	push	r12
     e0e:	df 92       	push	r13
     e10:	ef 92       	push	r14
     e12:	ff 92       	push	r15
     e14:	0f 93       	push	r16
     e16:	1f 93       	push	r17
     e18:	cf 93       	push	r28
     e1a:	df 93       	push	r29
     e1c:	7c 01       	movw	r14, r24
     e1e:	da 01       	movw	r26, r20
    uint8_t             i;
    uint8_t             len_code;


    /* First, do a NULL pointer check and return immediately if it fails. */
    if ((dst_buf_ptr == NULL) || (src_ptr == NULL))
     e20:	00 97       	sbiw	r24, 0x00	; 0
     e22:	11 f0       	breq	.+4      	; 0xe28 <cobs_decode+0x20>
     e24:	10 97       	sbiw	r26, 0x00	; 0
     e26:	21 f4       	brne	.+8      	; 0xe30 <cobs_decode+0x28>
    {
        result.status = COBS_DECODE_NULL_POINTER;
        return result;
     e28:	60 e0       	ldi	r22, 0x00	; 0
     e2a:	70 e0       	ldi	r23, 0x00	; 0
     e2c:	81 e0       	ldi	r24, 0x01	; 1
     e2e:	5f c0       	rjmp	.+190    	; 0xeee <cobs_decode+0xe6>
    }

    if (src_len != 0)
     e30:	21 15       	cp	r18, r1
     e32:	31 05       	cpc	r19, r1
     e34:	09 f4       	brne	.+2      	; 0xe38 <cobs_decode+0x30>
     e36:	4b c0       	rjmp	.+150    	; 0xece <cobs_decode+0xc6>


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
     e38:	6a 01       	movw	r12, r20
     e3a:	c2 0e       	add	r12, r18
     e3c:	d3 1e       	adc	r13, r19
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
     e3e:	5c 01       	movw	r10, r24
     e40:	a6 0e       	add	r10, r22
     e42:	b7 1e       	adc	r11, r23
     e44:	8c 01       	movw	r16, r24
     e46:	50 e0       	ldi	r21, 0x00	; 0
     e48:	01 c0       	rjmp	.+2      	; 0xe4c <cobs_decode+0x44>
                src_byte = *src_ptr++;
                if (src_byte == 0)
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
     e4a:	8f 01       	movw	r16, r30

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     e4c:	ed 01       	movw	r28, r26
     e4e:	21 96       	adiw	r28, 0x01	; 1
     e50:	7c 91       	ld	r23, X
            if (len_code == 0)
     e52:	71 11       	cpse	r23, r1
     e54:	03 c0       	rjmp	.+6      	; 0xe5c <cobs_decode+0x54>
            {
                result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e56:	54 60       	ori	r21, 0x04	; 4
                break;
     e58:	f8 01       	movw	r30, r16
     e5a:	3d c0       	rjmp	.+122    	; 0xed6 <cobs_decode+0xce>
            }
            len_code--;
     e5c:	71 50       	subi	r23, 0x01	; 1

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
     e5e:	c6 01       	movw	r24, r12
     e60:	8c 1b       	sub	r24, r28
     e62:	9d 0b       	sbc	r25, r29
            if (len_code > remaining_bytes)
     e64:	27 2f       	mov	r18, r23
     e66:	30 e0       	ldi	r19, 0x00	; 0
     e68:	82 17       	cp	r24, r18
     e6a:	93 07       	cpc	r25, r19
     e6c:	10 f4       	brcc	.+4      	; 0xe72 <cobs_decode+0x6a>
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
                len_code = remaining_bytes;
     e6e:	78 2f       	mov	r23, r24

            /* Check length code against remaining input bytes */
            remaining_bytes = src_end_ptr - src_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_INPUT_TOO_SHORT;
     e70:	58 60       	ori	r21, 0x08	; 8
                len_code = remaining_bytes;
            }

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
     e72:	c5 01       	movw	r24, r10
     e74:	80 1b       	sub	r24, r16
     e76:	91 0b       	sbc	r25, r17
            if (len_code > remaining_bytes)
     e78:	27 2f       	mov	r18, r23
     e7a:	30 e0       	ldi	r19, 0x00	; 0
     e7c:	82 17       	cp	r24, r18
     e7e:	93 07       	cpc	r25, r19
     e80:	10 f4       	brcc	.+4      	; 0xe86 <cobs_decode+0x7e>
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
     e82:	78 2f       	mov	r23, r24

            /* Check length code against remaining output buffer space */
            remaining_bytes = dst_buf_end_ptr - dst_write_ptr;
            if (len_code > remaining_bytes)
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     e84:	52 60       	ori	r21, 0x02	; 2
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e86:	77 23       	and	r23, r23
     e88:	61 f1       	breq	.+88     	; 0xee2 <cobs_decode+0xda>
     e8a:	de 01       	movw	r26, r28
     e8c:	f8 01       	movw	r30, r16
     e8e:	97 2f       	mov	r25, r23
            {
                src_byte = *src_ptr++;
     e90:	3d 91       	ld	r19, X+
                if (src_byte == 0)
     e92:	31 11       	cpse	r19, r1
     e94:	01 c0       	rjmp	.+2      	; 0xe98 <cobs_decode+0x90>
                {
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
     e96:	54 60       	ori	r21, 0x04	; 4
                }
                *dst_write_ptr++ = src_byte;
     e98:	31 93       	st	Z+, r19
            {
                result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
                len_code = remaining_bytes;
            }

            for (i = len_code; i != 0; i--)
     e9a:	91 50       	subi	r25, 0x01	; 1
     e9c:	c9 f7       	brne	.-14     	; 0xe90 <cobs_decode+0x88>
     e9e:	ef ef       	ldi	r30, 0xFF	; 255
     ea0:	e7 0f       	add	r30, r23
     ea2:	f0 e0       	ldi	r31, 0x00	; 0
     ea4:	31 96       	adiw	r30, 0x01	; 1
     ea6:	de 01       	movw	r26, r28
     ea8:	ae 0f       	add	r26, r30
     eaa:	bf 1f       	adc	r27, r31
     eac:	e0 0f       	add	r30, r16
     eae:	f1 1f       	adc	r31, r17
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     eb0:	ac 15       	cp	r26, r12
     eb2:	bd 05       	cpc	r27, r13
     eb4:	80 f4       	brcc	.+32     	; 0xed6 <cobs_decode+0xce>
            {
                break;
            }

            /* Add a zero to the end */
            if (len_code != 0xFE)
     eb6:	7e 3f       	cpi	r23, 0xFE	; 254
     eb8:	41 f2       	breq	.-112    	; 0xe4a <cobs_decode+0x42>
            {
                if (dst_write_ptr >= dst_buf_end_ptr)
     eba:	ea 15       	cp	r30, r10
     ebc:	fb 05       	cpc	r31, r11
     ebe:	10 f0       	brcs	.+4      	; 0xec4 <cobs_decode+0xbc>
                {
                    result.status |= COBS_DECODE_OUT_BUFFER_OVERFLOW;
     ec0:	52 60       	ori	r21, 0x02	; 2
                    break;
     ec2:	09 c0       	rjmp	.+18     	; 0xed6 <cobs_decode+0xce>
                }
                *dst_write_ptr++ = 0;
     ec4:	8f 01       	movw	r16, r30
     ec6:	0f 5f       	subi	r16, 0xFF	; 255
     ec8:	1f 4f       	sbci	r17, 0xFF	; 255
     eca:	10 82       	st	Z, r1
     ecc:	bf cf       	rjmp	.-130    	; 0xe4c <cobs_decode+0x44>
cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
    const uint8_t *     src_end_ptr         = src_ptr + src_len;
    uint8_t *           dst_buf_end_ptr     = dst_buf_ptr + dst_buf_len;
    uint8_t *           dst_write_ptr       = dst_buf_ptr;
     ece:	fc 01       	movw	r30, r24
}


cobs_decode_result cobs_decode(uint8_t *dst_buf_ptr, size_t dst_buf_len, const uint8_t * src_ptr, size_t src_len)
{
    cobs_decode_result  result              = { 0, COBS_DECODE_OK };
     ed0:	50 e0       	ldi	r21, 0x00	; 0
     ed2:	01 c0       	rjmp	.+2      	; 0xed6 <cobs_decode+0xce>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ed4:	f8 01       	movw	r30, r16
        }
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
     ed6:	ee 19       	sub	r30, r14
     ed8:	ff 09       	sbc	r31, r15
     eda:	6e 2f       	mov	r22, r30
     edc:	7f 2f       	mov	r23, r31
     ede:	85 2f       	mov	r24, r21
     ee0:	06 c0       	rjmp	.+12     	; 0xeee <cobs_decode+0xe6>
                    result.status |= COBS_DECODE_ZERO_BYTE_IN_INPUT;
                }
                *dst_write_ptr++ = src_byte;
            }

            if (src_ptr >= src_end_ptr)
     ee2:	cc 15       	cp	r28, r12
     ee4:	dd 05       	cpc	r29, r13
     ee6:	b0 f7       	brcc	.-20     	; 0xed4 <cobs_decode+0xcc>
     ee8:	f8 01       	movw	r30, r16

    if (src_len != 0)
    {
        for (;;)
        {
            len_code = *src_ptr++;
     eea:	de 01       	movw	r26, r28
     eec:	e6 cf       	rjmp	.-52     	; 0xeba <cobs_decode+0xb2>
    }

    result.out_len = dst_write_ptr - dst_buf_ptr;

    return result;
}
     eee:	df 91       	pop	r29
     ef0:	cf 91       	pop	r28
     ef2:	1f 91       	pop	r17
     ef4:	0f 91       	pop	r16
     ef6:	ff 90       	pop	r15
     ef8:	ef 90       	pop	r14
     efa:	df 90       	pop	r13
     efc:	cf 90       	pop	r12
     efe:	bf 90       	pop	r11
     f00:	af 90       	pop	r10
     f02:	08 95       	ret

00000f04 <crc_ibutton_update>:
  return crc;
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
     f04:	86 27       	eor	r24, r22
     f06:	98 e0       	ldi	r25, 0x08	; 8
  for (i = 0; i < 8; i++) {
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
     f08:	2c e8       	ldi	r18, 0x8C	; 140
     f0a:	80 ff       	sbrs	r24, 0
     f0c:	03 c0       	rjmp	.+6      	; 0xf14 <crc_ibutton_update+0x10>
     f0e:	86 95       	lsr	r24
     f10:	82 27       	eor	r24, r18
     f12:	01 c0       	rjmp	.+2      	; 0xf16 <crc_ibutton_update+0x12>
    else crc >>= 1;
     f14:	86 95       	lsr	r24
     f16:	91 50       	subi	r25, 0x01	; 1
}

char crc_ibutton_update(char crc, char data) {
  char i;
  crc = crc ^ data;
  for (i = 0; i < 8; i++) {
     f18:	c1 f7       	brne	.-16     	; 0xf0a <crc_ibutton_update+0x6>
    if (crc & 0x01) crc = (crc >> 1) ^ 0x8C;
    else crc >>= 1;
  }
  return crc;
     f1a:	08 95       	ret

00000f1c <calculate_crc>:

#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
     f1c:	0f 93       	push	r16
     f1e:	1f 93       	push	r17
     f20:	cf 93       	push	r28
     f22:	df 93       	push	r29
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
     f24:	66 23       	and	r22, r22
     f26:	59 f0       	breq	.+22     	; 0xf3e <calculate_crc+0x22>
     f28:	8c 01       	movw	r16, r24
     f2a:	ec 01       	movw	r28, r24
     f2c:	06 0f       	add	r16, r22
     f2e:	11 1d       	adc	r17, r1
     f30:	80 e0       	ldi	r24, 0x00	; 0
    crc = crc_ibutton_update(crc, data[i]);
     f32:	69 91       	ld	r22, Y+
     f34:	e7 df       	rcall	.-50     	; 0xf04 <crc_ibutton_update>
char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
  int i;
  for(i=0;i<len;i++) {
     f36:	0c 17       	cp	r16, r28
     f38:	1d 07       	cpc	r17, r29
     f3a:	d9 f7       	brne	.-10     	; 0xf32 <calculate_crc+0x16>
     f3c:	01 c0       	rjmp	.+2      	; 0xf40 <calculate_crc+0x24>
#include "crc.h"

char crc_ibutton_update(char crc, char data);

char calculate_crc(char *data, char len) {
  char crc = 0;
     f3e:	80 e0       	ldi	r24, 0x00	; 0
  int i;
  for(i=0;i<len;i++) {
    crc = crc_ibutton_update(crc, data[i]);
  }
  return crc;
}
     f40:	df 91       	pop	r29
     f42:	cf 91       	pop	r28
     f44:	1f 91       	pop	r17
     f46:	0f 91       	pop	r16
     f48:	08 95       	ret

00000f4a <vDistSens_init>:
*/

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
     f4a:	80 b3       	in	r24, 0x10	; 16
     f4c:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     f4e:	ec e7       	ldi	r30, 0x7C	; 124
     f50:	f0 e0       	ldi	r31, 0x00	; 0
     f52:	80 81       	ld	r24, Z
     f54:	80 6c       	ori	r24, 0xC0	; 192
     f56:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
     f58:	ea e7       	ldi	r30, 0x7A	; 122
     f5a:	f0 e0       	ldi	r31, 0x00	; 0
     f5c:	80 81       	ld	r24, Z
     f5e:	80 68       	ori	r24, 0x80	; 128
     f60:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
     f62:	80 81       	ld	r24, Z
     f64:	84 60       	ori	r24, 0x04	; 4
     f66:	80 83       	st	Z, r24
     f68:	08 95       	ret

00000f6a <ui8DistSens_readCM>:
uint8_t ui8DistSens_readCM(uint8_t sensorDirection){
    
    uint8_t ui8_analogValue;
    
    /* Choose channel */
    ADMUX = sensorDirection;
     f6a:	ec e7       	ldi	r30, 0x7C	; 124
     f6c:	f0 e0       	ldi	r31, 0x00	; 0
     f6e:	80 83       	st	Z, r24
    
    /* Enable internal 2,54V AREF */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     f70:	90 81       	ld	r25, Z
     f72:	90 6c       	ori	r25, 0xC0	; 192
     f74:	90 83       	st	Z, r25
    
    /* Start conversion */
    ADCSRA |= (1<<ADSC);
     f76:	ea e7       	ldi	r30, 0x7A	; 122
     f78:	f0 e0       	ldi	r31, 0x00	; 0
     f7a:	90 81       	ld	r25, Z
     f7c:	90 64       	ori	r25, 0x40	; 64
     f7e:	90 83       	st	Z, r25
    loop_until_bit_is_clear(ADCSRA, ADSC); // Macro from <avr/io.h>, wait until bit bit in IO register is set.
     f80:	90 81       	ld	r25, Z
     f82:	96 fd       	sbrc	r25, 6
     f84:	fd cf       	rjmp	.-6      	; 0xf80 <ui8DistSens_readCM+0x16>

    /* Return the 8 most significant bits from the 10 bit register */
    ui8_analogValue = (ADCL >> 2) | (ADCH << 6);
     f86:	20 91 78 00 	lds	r18, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x700078>
     f8a:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x700079>
    // Returns corresponding distance in CM
    return ui8_analogToCM[sensorDirection][ui8_analogValue];
     f8e:	e8 2f       	mov	r30, r24
     f90:	f0 e0       	ldi	r31, 0x00	; 0
     f92:	26 95       	lsr	r18
     f94:	26 95       	lsr	r18
     f96:	30 e4       	ldi	r19, 0x40	; 64
     f98:	93 9f       	mul	r25, r19
     f9a:	c0 01       	movw	r24, r0
     f9c:	11 24       	eor	r1, r1
     f9e:	82 2b       	or	r24, r18
     fa0:	fe 2f       	mov	r31, r30
     fa2:	ee 27       	eor	r30, r30
     fa4:	e0 50       	subi	r30, 0x00	; 0
     fa6:	fe 4f       	sbci	r31, 0xFE	; 254
     fa8:	e8 0f       	add	r30, r24
     faa:	f1 1d       	adc	r31, r1
}
     fac:	80 81       	ld	r24, Z
     fae:	08 95       	ret

00000fb0 <vFunc_Inf2pi>:
#include <string.h>
#include <math.h>
#include <stdlib.h>

/* Take any angle and put it inside -pi,pi */
void vFunc_Inf2pi(float *angle_in_radians){
     fb0:	cf 92       	push	r12
     fb2:	df 92       	push	r13
     fb4:	ef 92       	push	r14
     fb6:	ff 92       	push	r15
     fb8:	cf 93       	push	r28
     fba:	df 93       	push	r29
     fbc:	ec 01       	movw	r28, r24
    do{
        if (*angle_in_radians > M_PI) *angle_in_radians -= 2*M_PI;
     fbe:	c8 80       	ld	r12, Y
     fc0:	d9 80       	ldd	r13, Y+1	; 0x01
     fc2:	ea 80       	ldd	r14, Y+2	; 0x02
     fc4:	fb 80       	ldd	r15, Y+3	; 0x03
     fc6:	2b ed       	ldi	r18, 0xDB	; 219
     fc8:	3f e0       	ldi	r19, 0x0F	; 15
     fca:	49 e4       	ldi	r20, 0x49	; 73
     fcc:	50 e4       	ldi	r21, 0x40	; 64
     fce:	c7 01       	movw	r24, r14
     fd0:	b6 01       	movw	r22, r12
     fd2:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
     fd6:	18 16       	cp	r1, r24
     fd8:	6c f4       	brge	.+26     	; 0xff4 <vFunc_Inf2pi+0x44>
     fda:	2b ed       	ldi	r18, 0xDB	; 219
     fdc:	3f e0       	ldi	r19, 0x0F	; 15
     fde:	49 ec       	ldi	r20, 0xC9	; 201
     fe0:	50 e4       	ldi	r21, 0x40	; 64
     fe2:	c7 01       	movw	r24, r14
     fe4:	b6 01       	movw	r22, r12
     fe6:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
     fea:	68 83       	st	Y, r22
     fec:	79 83       	std	Y+1, r23	; 0x01
     fee:	8a 83       	std	Y+2, r24	; 0x02
     ff0:	9b 83       	std	Y+3, r25	; 0x03
     ff2:	16 c0       	rjmp	.+44     	; 0x1020 <vFunc_Inf2pi+0x70>
        else if (*angle_in_radians < -M_PI) *angle_in_radians += 2*M_PI;
     ff4:	2b ed       	ldi	r18, 0xDB	; 219
     ff6:	3f e0       	ldi	r19, 0x0F	; 15
     ff8:	49 e4       	ldi	r20, 0x49	; 73
     ffa:	50 ec       	ldi	r21, 0xC0	; 192
     ffc:	c7 01       	movw	r24, r14
     ffe:	b6 01       	movw	r22, r12
    1000:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    1004:	88 23       	and	r24, r24
    1006:	64 f4       	brge	.+24     	; 0x1020 <vFunc_Inf2pi+0x70>
    1008:	2b ed       	ldi	r18, 0xDB	; 219
    100a:	3f e0       	ldi	r19, 0x0F	; 15
    100c:	49 ec       	ldi	r20, 0xC9	; 201
    100e:	50 e4       	ldi	r21, 0x40	; 64
    1010:	c7 01       	movw	r24, r14
    1012:	b6 01       	movw	r22, r12
    1014:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    1018:	68 83       	st	Y, r22
    101a:	79 83       	std	Y+1, r23	; 0x01
    101c:	8a 83       	std	Y+2, r24	; 0x02
    101e:	9b 83       	std	Y+3, r25	; 0x03
    } while (fabs(*angle_in_radians) > M_PI);
    1020:	88 81       	ld	r24, Y
    1022:	99 81       	ldd	r25, Y+1	; 0x01
    1024:	aa 81       	ldd	r26, Y+2	; 0x02
    1026:	bb 81       	ldd	r27, Y+3	; 0x03
    1028:	bc 01       	movw	r22, r24
    102a:	cd 01       	movw	r24, r26
    102c:	9f 77       	andi	r25, 0x7F	; 127
    102e:	2b ed       	ldi	r18, 0xDB	; 219
    1030:	3f e0       	ldi	r19, 0x0F	; 15
    1032:	49 e4       	ldi	r20, 0x49	; 73
    1034:	50 e4       	ldi	r21, 0x40	; 64
    1036:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    103a:	18 16       	cp	r1, r24
    103c:	0c f4       	brge	.+2      	; 0x1040 <vFunc_Inf2pi+0x90>
    103e:	bf cf       	rjmp	.-130    	; 0xfbe <vFunc_Inf2pi+0xe>
}
    1040:	df 91       	pop	r29
    1042:	cf 91       	pop	r28
    1044:	ff 90       	pop	r15
    1046:	ef 90       	pop	r14
    1048:	df 90       	pop	r13
    104a:	cf 90       	pop	r12
    104c:	08 95       	ret

0000104e <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    104e:	ef 92       	push	r14
    1050:	ff 92       	push	r15
    1052:	0f 93       	push	r16
    1054:	1f 93       	push	r17
    1056:	cf 93       	push	r28
    1058:	df 93       	push	r29
    105a:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    105c:	0e 94 17 2c 	call	0x582e	; 0x582e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    1060:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <pxEnd>
    1064:	90 91 02 08 	lds	r25, 0x0802	; 0x800802 <pxEnd+0x1>
    1068:	89 2b       	or	r24, r25
    106a:	41 f5       	brne	.+80     	; 0x10bc <pvPortMalloc+0x6e>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    106c:	e3 e0       	ldi	r30, 0x03	; 3
    106e:	f8 e0       	ldi	r31, 0x08	; 8
    1070:	a7 e0       	ldi	r26, 0x07	; 7
    1072:	b8 e0       	ldi	r27, 0x08	; 8
    1074:	b1 83       	std	Z+1, r27	; 0x01
    1076:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    1078:	13 82       	std	Z+3, r1	; 0x03
    107a:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    107c:	e3 e0       	ldi	r30, 0x03	; 3
    107e:	fa e1       	ldi	r31, 0x1A	; 26
    1080:	f0 93 02 08 	sts	0x0802, r31	; 0x800802 <pxEnd+0x1>
    1084:	e0 93 01 08 	sts	0x0801, r30	; 0x800801 <pxEnd>
	pxEnd->xBlockSize = 0;
    1088:	13 82       	std	Z+3, r1	; 0x03
    108a:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    108c:	11 82       	std	Z+1, r1	; 0x01
    108e:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    1090:	8c ef       	ldi	r24, 0xFC	; 252
    1092:	91 e1       	ldi	r25, 0x11	; 17
    1094:	13 96       	adiw	r26, 0x03	; 3
    1096:	9c 93       	st	X, r25
    1098:	8e 93       	st	-X, r24
    109a:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    109c:	ed 93       	st	X+, r30
    109e:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    10a0:	90 93 fe 07 	sts	0x07FE, r25	; 0x8007fe <xMinimumEverFreeBytesRemaining+0x1>
    10a4:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    10a8:	90 93 00 08 	sts	0x0800, r25	; 0x800800 <xFreeBytesRemaining+0x1>
    10ac:	80 93 ff 07 	sts	0x07FF, r24	; 0x8007ff <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    10b0:	80 e0       	ldi	r24, 0x00	; 0
    10b2:	90 e8       	ldi	r25, 0x80	; 128
    10b4:	90 93 fc 07 	sts	0x07FC, r25	; 0x8007fc <xBlockAllocatedBit+0x1>
    10b8:	80 93 fb 07 	sts	0x07FB, r24	; 0x8007fb <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    10bc:	80 91 fb 07 	lds	r24, 0x07FB	; 0x8007fb <xBlockAllocatedBit>
    10c0:	90 91 fc 07 	lds	r25, 0x07FC	; 0x8007fc <xBlockAllocatedBit+0x1>
    10c4:	8c 23       	and	r24, r28
    10c6:	9d 23       	and	r25, r29
    10c8:	89 2b       	or	r24, r25
    10ca:	09 f0       	breq	.+2      	; 0x10ce <pvPortMalloc+0x80>
    10cc:	b2 c0       	rjmp	.+356    	; 0x1232 <pvPortMalloc+0x1e4>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    10ce:	20 97       	sbiw	r28, 0x00	; 0
    10d0:	09 f4       	brne	.+2      	; 0x10d4 <pvPortMalloc+0x86>
    10d2:	b2 c0       	rjmp	.+356    	; 0x1238 <pvPortMalloc+0x1ea>
			{
				xWantedSize += xHeapStructSize;
    10d4:	ae 01       	movw	r20, r28
    10d6:	4c 5f       	subi	r20, 0xFC	; 252
    10d8:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    10da:	09 f4       	brne	.+2      	; 0x10de <pvPortMalloc+0x90>
    10dc:	b0 c0       	rjmp	.+352    	; 0x123e <pvPortMalloc+0x1f0>
    10de:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <xFreeBytesRemaining>
    10e2:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <xFreeBytesRemaining+0x1>
    10e6:	84 17       	cp	r24, r20
    10e8:	95 07       	cpc	r25, r21
    10ea:	08 f4       	brcc	.+2      	; 0x10ee <pvPortMalloc+0xa0>
    10ec:	ab c0       	rjmp	.+342    	; 0x1244 <pvPortMalloc+0x1f6>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    10ee:	e0 91 03 08 	lds	r30, 0x0803	; 0x800803 <xStart>
    10f2:	f0 91 04 08 	lds	r31, 0x0804	; 0x800804 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    10f6:	a3 e0       	ldi	r26, 0x03	; 3
    10f8:	b8 e0       	ldi	r27, 0x08	; 8
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    10fa:	02 c0       	rjmp	.+4      	; 0x1100 <pvPortMalloc+0xb2>
    10fc:	df 01       	movw	r26, r30
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    10fe:	f9 01       	movw	r30, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1100:	22 81       	ldd	r18, Z+2	; 0x02
    1102:	33 81       	ldd	r19, Z+3	; 0x03
    1104:	24 17       	cp	r18, r20
    1106:	35 07       	cpc	r19, r21
    1108:	28 f4       	brcc	.+10     	; 0x1114 <pvPortMalloc+0xc6>
    110a:	20 81       	ld	r18, Z
    110c:	31 81       	ldd	r19, Z+1	; 0x01
    110e:	21 15       	cp	r18, r1
    1110:	31 05       	cpc	r19, r1
    1112:	a1 f7       	brne	.-24     	; 0x10fc <pvPortMalloc+0xae>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    1114:	60 91 01 08 	lds	r22, 0x0801	; 0x800801 <pxEnd>
    1118:	70 91 02 08 	lds	r23, 0x0802	; 0x800802 <pxEnd+0x1>
    111c:	e6 17       	cp	r30, r22
    111e:	f7 07       	cpc	r31, r23
    1120:	09 f4       	brne	.+2      	; 0x1124 <pvPortMalloc+0xd6>
    1122:	93 c0       	rjmp	.+294    	; 0x124a <pvPortMalloc+0x1fc>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    1124:	cd 91       	ld	r28, X+
    1126:	dc 91       	ld	r29, X
    1128:	11 97       	sbiw	r26, 0x01	; 1
    112a:	7e 01       	movw	r14, r28
    112c:	84 e0       	ldi	r24, 0x04	; 4
    112e:	e8 0e       	add	r14, r24
    1130:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1132:	80 81       	ld	r24, Z
    1134:	91 81       	ldd	r25, Z+1	; 0x01
    1136:	8d 93       	st	X+, r24
    1138:	9c 93       	st	X, r25

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    113a:	82 81       	ldd	r24, Z+2	; 0x02
    113c:	93 81       	ldd	r25, Z+3	; 0x03
    113e:	84 1b       	sub	r24, r20
    1140:	95 0b       	sbc	r25, r21
    1142:	89 30       	cpi	r24, 0x09	; 9
    1144:	91 05       	cpc	r25, r1
    1146:	08 f4       	brcc	.+2      	; 0x114a <pvPortMalloc+0xfc>
    1148:	52 c0       	rjmp	.+164    	; 0x11ee <pvPortMalloc+0x1a0>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    114a:	9f 01       	movw	r18, r30
    114c:	24 0f       	add	r18, r20
    114e:	35 1f       	adc	r19, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    1150:	d9 01       	movw	r26, r18
    1152:	13 96       	adiw	r26, 0x03	; 3
    1154:	9c 93       	st	X, r25
    1156:	8e 93       	st	-X, r24
    1158:	12 97       	sbiw	r26, 0x02	; 2
						pxBlock->xBlockSize = xWantedSize;
    115a:	53 83       	std	Z+3, r21	; 0x03
    115c:	42 83       	std	Z+2, r20	; 0x02
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    115e:	a3 e0       	ldi	r26, 0x03	; 3
    1160:	b8 e0       	ldi	r27, 0x08	; 8
    1162:	01 c0       	rjmp	.+2      	; 0x1166 <pvPortMalloc+0x118>
    1164:	dc 01       	movw	r26, r24
    1166:	8d 91       	ld	r24, X+
    1168:	9c 91       	ld	r25, X
    116a:	11 97       	sbiw	r26, 0x01	; 1
    116c:	82 17       	cp	r24, r18
    116e:	93 07       	cpc	r25, r19
    1170:	c8 f3       	brcs	.-14     	; 0x1164 <pvPortMalloc+0x116>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1172:	12 96       	adiw	r26, 0x02	; 2
    1174:	4d 91       	ld	r20, X+
    1176:	5c 91       	ld	r21, X
    1178:	13 97       	sbiw	r26, 0x03	; 3
    117a:	8d 01       	movw	r16, r26
    117c:	04 0f       	add	r16, r20
    117e:	15 1f       	adc	r17, r21
    1180:	20 17       	cp	r18, r16
    1182:	31 07       	cpc	r19, r17
    1184:	51 f4       	brne	.+20     	; 0x119a <pvPortMalloc+0x14c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    1186:	e9 01       	movw	r28, r18
    1188:	2a 81       	ldd	r18, Y+2	; 0x02
    118a:	3b 81       	ldd	r19, Y+3	; 0x03
    118c:	42 0f       	add	r20, r18
    118e:	53 1f       	adc	r21, r19
    1190:	13 96       	adiw	r26, 0x03	; 3
    1192:	5c 93       	st	X, r21
    1194:	4e 93       	st	-X, r20
    1196:	12 97       	sbiw	r26, 0x02	; 2
    1198:	9d 01       	movw	r18, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    119a:	e9 01       	movw	r28, r18
    119c:	4a 81       	ldd	r20, Y+2	; 0x02
    119e:	5b 81       	ldd	r21, Y+3	; 0x03
    11a0:	89 01       	movw	r16, r18
    11a2:	04 0f       	add	r16, r20
    11a4:	15 1f       	adc	r17, r21
    11a6:	80 17       	cp	r24, r16
    11a8:	91 07       	cpc	r25, r17
    11aa:	c9 f4       	brne	.+50     	; 0x11de <pvPortMalloc+0x190>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    11ac:	60 17       	cp	r22, r16
    11ae:	71 07       	cpc	r23, r17
    11b0:	91 f0       	breq	.+36     	; 0x11d6 <pvPortMalloc+0x188>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    11b2:	e8 01       	movw	r28, r16
    11b4:	8a 81       	ldd	r24, Y+2	; 0x02
    11b6:	9b 81       	ldd	r25, Y+3	; 0x03
    11b8:	48 0f       	add	r20, r24
    11ba:	59 1f       	adc	r21, r25
    11bc:	e9 01       	movw	r28, r18
    11be:	5b 83       	std	Y+3, r21	; 0x03
    11c0:	4a 83       	std	Y+2, r20	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    11c2:	8d 91       	ld	r24, X+
    11c4:	9c 91       	ld	r25, X
    11c6:	11 97       	sbiw	r26, 0x01	; 1
    11c8:	ec 01       	movw	r28, r24
    11ca:	88 81       	ld	r24, Y
    11cc:	99 81       	ldd	r25, Y+1	; 0x01
    11ce:	e9 01       	movw	r28, r18
    11d0:	99 83       	std	Y+1, r25	; 0x01
    11d2:	88 83       	st	Y, r24
    11d4:	07 c0       	rjmp	.+14     	; 0x11e4 <pvPortMalloc+0x196>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    11d6:	e9 01       	movw	r28, r18
    11d8:	79 83       	std	Y+1, r23	; 0x01
    11da:	68 83       	st	Y, r22
    11dc:	03 c0       	rjmp	.+6      	; 0x11e4 <pvPortMalloc+0x196>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    11de:	e9 01       	movw	r28, r18
    11e0:	99 83       	std	Y+1, r25	; 0x01
    11e2:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    11e4:	a2 17       	cp	r26, r18
    11e6:	b3 07       	cpc	r27, r19
    11e8:	11 f0       	breq	.+4      	; 0x11ee <pvPortMalloc+0x1a0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    11ea:	2d 93       	st	X+, r18
    11ec:	3c 93       	st	X, r19
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    11ee:	22 81       	ldd	r18, Z+2	; 0x02
    11f0:	33 81       	ldd	r19, Z+3	; 0x03
    11f2:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <xFreeBytesRemaining>
    11f6:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <xFreeBytesRemaining+0x1>
    11fa:	82 1b       	sub	r24, r18
    11fc:	93 0b       	sbc	r25, r19
    11fe:	90 93 00 08 	sts	0x0800, r25	; 0x800800 <xFreeBytesRemaining+0x1>
    1202:	80 93 ff 07 	sts	0x07FF, r24	; 0x8007ff <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    1206:	40 91 fd 07 	lds	r20, 0x07FD	; 0x8007fd <xMinimumEverFreeBytesRemaining>
    120a:	50 91 fe 07 	lds	r21, 0x07FE	; 0x8007fe <xMinimumEverFreeBytesRemaining+0x1>
    120e:	84 17       	cp	r24, r20
    1210:	95 07       	cpc	r25, r21
    1212:	20 f4       	brcc	.+8      	; 0x121c <pvPortMalloc+0x1ce>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    1214:	90 93 fe 07 	sts	0x07FE, r25	; 0x8007fe <xMinimumEverFreeBytesRemaining+0x1>
    1218:	80 93 fd 07 	sts	0x07FD, r24	; 0x8007fd <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    121c:	80 91 fb 07 	lds	r24, 0x07FB	; 0x8007fb <xBlockAllocatedBit>
    1220:	90 91 fc 07 	lds	r25, 0x07FC	; 0x8007fc <xBlockAllocatedBit+0x1>
    1224:	28 2b       	or	r18, r24
    1226:	39 2b       	or	r19, r25
    1228:	33 83       	std	Z+3, r19	; 0x03
    122a:	22 83       	std	Z+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    122c:	11 82       	std	Z+1, r1	; 0x01
    122e:	10 82       	st	Z, r1
    1230:	0e c0       	rjmp	.+28     	; 0x124e <pvPortMalloc+0x200>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    1232:	e1 2c       	mov	r14, r1
    1234:	f1 2c       	mov	r15, r1
    1236:	0b c0       	rjmp	.+22     	; 0x124e <pvPortMalloc+0x200>
    1238:	e1 2c       	mov	r14, r1
    123a:	f1 2c       	mov	r15, r1
    123c:	08 c0       	rjmp	.+16     	; 0x124e <pvPortMalloc+0x200>
    123e:	e1 2c       	mov	r14, r1
    1240:	f1 2c       	mov	r15, r1
    1242:	05 c0       	rjmp	.+10     	; 0x124e <pvPortMalloc+0x200>
    1244:	e1 2c       	mov	r14, r1
    1246:	f1 2c       	mov	r15, r1
    1248:	02 c0       	rjmp	.+4      	; 0x124e <pvPortMalloc+0x200>
    124a:	e1 2c       	mov	r14, r1
    124c:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    124e:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    1252:	c7 01       	movw	r24, r14
    1254:	df 91       	pop	r29
    1256:	cf 91       	pop	r28
    1258:	1f 91       	pop	r17
    125a:	0f 91       	pop	r16
    125c:	ff 90       	pop	r15
    125e:	ef 90       	pop	r14
    1260:	08 95       	ret

00001262 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1262:	cf 93       	push	r28
    1264:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    1266:	00 97       	sbiw	r24, 0x00	; 0
    1268:	09 f4       	brne	.+2      	; 0x126c <vPortFree+0xa>
    126a:	68 c0       	rjmp	.+208    	; 0x133c <vPortFree+0xda>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    126c:	fc 01       	movw	r30, r24
    126e:	34 97       	sbiw	r30, 0x04	; 4
    1270:	22 81       	ldd	r18, Z+2	; 0x02
    1272:	33 81       	ldd	r19, Z+3	; 0x03
    1274:	40 91 fb 07 	lds	r20, 0x07FB	; 0x8007fb <xBlockAllocatedBit>
    1278:	50 91 fc 07 	lds	r21, 0x07FC	; 0x8007fc <xBlockAllocatedBit+0x1>
    127c:	b9 01       	movw	r22, r18
    127e:	64 23       	and	r22, r20
    1280:	75 23       	and	r23, r21
    1282:	67 2b       	or	r22, r23
    1284:	09 f4       	brne	.+2      	; 0x1288 <vPortFree+0x26>
    1286:	5a c0       	rjmp	.+180    	; 0x133c <vPortFree+0xda>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    1288:	60 81       	ld	r22, Z
    128a:	71 81       	ldd	r23, Z+1	; 0x01
    128c:	67 2b       	or	r22, r23
    128e:	09 f0       	breq	.+2      	; 0x1292 <vPortFree+0x30>
    1290:	55 c0       	rjmp	.+170    	; 0x133c <vPortFree+0xda>

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
    1292:	ef 01       	movw	r28, r30
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    1294:	40 95       	com	r20
    1296:	50 95       	com	r21
    1298:	24 23       	and	r18, r20
    129a:	35 23       	and	r19, r21
    129c:	33 83       	std	Z+3, r19	; 0x03
    129e:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    12a0:	0e 94 17 2c 	call	0x582e	; 0x582e <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    12a4:	4a 81       	ldd	r20, Y+2	; 0x02
    12a6:	5b 81       	ldd	r21, Y+3	; 0x03
    12a8:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <xFreeBytesRemaining>
    12ac:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <xFreeBytesRemaining+0x1>
    12b0:	84 0f       	add	r24, r20
    12b2:	95 1f       	adc	r25, r21
    12b4:	90 93 00 08 	sts	0x0800, r25	; 0x800800 <xFreeBytesRemaining+0x1>
    12b8:	80 93 ff 07 	sts	0x07FF, r24	; 0x8007ff <xFreeBytesRemaining>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    12bc:	e3 e0       	ldi	r30, 0x03	; 3
    12be:	f8 e0       	ldi	r31, 0x08	; 8
    12c0:	01 c0       	rjmp	.+2      	; 0x12c4 <vPortFree+0x62>
    12c2:	fc 01       	movw	r30, r24
    12c4:	80 81       	ld	r24, Z
    12c6:	91 81       	ldd	r25, Z+1	; 0x01
    12c8:	8c 17       	cp	r24, r28
    12ca:	9d 07       	cpc	r25, r29
    12cc:	d0 f3       	brcs	.-12     	; 0x12c2 <vPortFree+0x60>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    12ce:	22 81       	ldd	r18, Z+2	; 0x02
    12d0:	33 81       	ldd	r19, Z+3	; 0x03
    12d2:	bf 01       	movw	r22, r30
    12d4:	62 0f       	add	r22, r18
    12d6:	73 1f       	adc	r23, r19
    12d8:	c6 17       	cp	r28, r22
    12da:	d7 07       	cpc	r29, r23
    12dc:	29 f4       	brne	.+10     	; 0x12e8 <vPortFree+0x86>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    12de:	24 0f       	add	r18, r20
    12e0:	35 1f       	adc	r19, r21
    12e2:	33 83       	std	Z+3, r19	; 0x03
    12e4:	22 83       	std	Z+2, r18	; 0x02
    12e6:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    12e8:	2a 81       	ldd	r18, Y+2	; 0x02
    12ea:	3b 81       	ldd	r19, Y+3	; 0x03
    12ec:	de 01       	movw	r26, r28
    12ee:	a2 0f       	add	r26, r18
    12f0:	b3 1f       	adc	r27, r19
    12f2:	8a 17       	cp	r24, r26
    12f4:	9b 07       	cpc	r25, r27
    12f6:	c9 f4       	brne	.+50     	; 0x132a <vPortFree+0xc8>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    12f8:	80 91 01 08 	lds	r24, 0x0801	; 0x800801 <pxEnd>
    12fc:	90 91 02 08 	lds	r25, 0x0802	; 0x800802 <pxEnd+0x1>
    1300:	a8 17       	cp	r26, r24
    1302:	b9 07       	cpc	r27, r25
    1304:	79 f0       	breq	.+30     	; 0x1324 <vPortFree+0xc2>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    1306:	12 96       	adiw	r26, 0x02	; 2
    1308:	8d 91       	ld	r24, X+
    130a:	9c 91       	ld	r25, X
    130c:	13 97       	sbiw	r26, 0x03	; 3
    130e:	28 0f       	add	r18, r24
    1310:	39 1f       	adc	r19, r25
    1312:	3b 83       	std	Y+3, r19	; 0x03
    1314:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1316:	a0 81       	ld	r26, Z
    1318:	b1 81       	ldd	r27, Z+1	; 0x01
    131a:	8d 91       	ld	r24, X+
    131c:	9c 91       	ld	r25, X
    131e:	99 83       	std	Y+1, r25	; 0x01
    1320:	88 83       	st	Y, r24
    1322:	05 c0       	rjmp	.+10     	; 0x132e <vPortFree+0xcc>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    1324:	b9 83       	std	Y+1, r27	; 0x01
    1326:	a8 83       	st	Y, r26
    1328:	02 c0       	rjmp	.+4      	; 0x132e <vPortFree+0xcc>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    132a:	99 83       	std	Y+1, r25	; 0x01
    132c:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    132e:	ec 17       	cp	r30, r28
    1330:	fd 07       	cpc	r31, r29
    1332:	11 f0       	breq	.+4      	; 0x1338 <vPortFree+0xd6>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    1334:	d1 83       	std	Z+1, r29	; 0x01
    1336:	c0 83       	st	Z, r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
    1338:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    133c:	df 91       	pop	r29
    133e:	cf 91       	pop	r28
    1340:	08 95       	ret

00001342 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
	return xFreeBytesRemaining;
}
    1342:	80 91 ff 07 	lds	r24, 0x07FF	; 0x8007ff <xFreeBytesRemaining>
    1346:	90 91 00 08 	lds	r25, 0x0800	; 0x800800 <xFreeBytesRemaining+0x1>
    134a:	08 95       	ret

0000134c <sIMU_readRegisterRegion>:
}
float fIMU_readFloatGyroY( void ){
    
    float output = fIMU_calcGyro(i16IMU_readRawGyroY());
    return output;
}
    134c:	ef 92       	push	r14
    134e:	ff 92       	push	r15
    1350:	0f 93       	push	r16
    1352:	1f 93       	push	r17
    1354:	cf 93       	push	r28
    1356:	df 93       	push	r29
    1358:	ec 01       	movw	r28, r24
    135a:	e4 2e       	mov	r14, r20
    135c:	28 98       	cbi	0x05, 0	; 5
    135e:	86 2f       	mov	r24, r22
    1360:	80 68       	ori	r24, 0x80	; 128
    1362:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <ui8SPI_MasterTransmit>
    1366:	ee 20       	and	r14, r14
    1368:	b1 f0       	breq	.+44     	; 0x1396 <sIMU_readRegisterRegion+0x4a>
    136a:	0f ef       	ldi	r16, 0xFF	; 255
    136c:	0e 0d       	add	r16, r14
    136e:	10 e0       	ldi	r17, 0x00	; 0
    1370:	0f 5f       	subi	r16, 0xFF	; 255
    1372:	1f 4f       	sbci	r17, 0xFF	; 255
    1374:	0c 0f       	add	r16, r28
    1376:	1d 1f       	adc	r17, r29
    1378:	f1 2c       	mov	r15, r1
    137a:	80 e0       	ldi	r24, 0x00	; 0
    137c:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <ui8SPI_MasterTransmit>
    1380:	8f 3f       	cpi	r24, 0xFF	; 255
    1382:	09 f4       	brne	.+2      	; 0x1386 <sIMU_readRegisterRegion+0x3a>
    1384:	f3 94       	inc	r15
    1386:	89 93       	st	Y+, r24
    1388:	0c 17       	cp	r16, r28
    138a:	1d 07       	cpc	r17, r29
    138c:	b1 f7       	brne	.-20     	; 0x137a <sIMU_readRegisterRegion+0x2e>
    138e:	fe 10       	cpse	r15, r14
    1390:	04 c0       	rjmp	.+8      	; 0x139a <sIMU_readRegisterRegion+0x4e>
    1392:	85 e0       	ldi	r24, 0x05	; 5
    1394:	03 c0       	rjmp	.+6      	; 0x139c <sIMU_readRegisterRegion+0x50>
    1396:	85 e0       	ldi	r24, 0x05	; 5
    1398:	01 c0       	rjmp	.+2      	; 0x139c <sIMU_readRegisterRegion+0x50>
    139a:	80 e0       	ldi	r24, 0x00	; 0
    139c:	28 9a       	sbi	0x05, 0	; 5
    139e:	df 91       	pop	r29
    13a0:	cf 91       	pop	r28
    13a2:	1f 91       	pop	r17
    13a4:	0f 91       	pop	r16
    13a6:	ff 90       	pop	r15
    13a8:	ef 90       	pop	r14
    13aa:	08 95       	ret

000013ac <sIMU_readRegister>:
    13ac:	cf 93       	push	r28
    13ae:	df 93       	push	r29
    13b0:	ec 01       	movw	r28, r24
    13b2:	28 98       	cbi	0x05, 0	; 5
    13b4:	86 2f       	mov	r24, r22
    13b6:	80 68       	ori	r24, 0x80	; 128
    13b8:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <ui8SPI_MasterTransmit>
    13bc:	80 e0       	ldi	r24, 0x00	; 0
    13be:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <ui8SPI_MasterTransmit>
    13c2:	28 9a       	sbi	0x05, 0	; 5
    13c4:	8f 3f       	cpi	r24, 0xFF	; 255
    13c6:	11 f4       	brne	.+4      	; 0x13cc <sIMU_readRegister+0x20>
    13c8:	95 e0       	ldi	r25, 0x05	; 5
    13ca:	01 c0       	rjmp	.+2      	; 0x13ce <sIMU_readRegister+0x22>
    13cc:	90 e0       	ldi	r25, 0x00	; 0
    13ce:	88 83       	st	Y, r24
    13d0:	89 2f       	mov	r24, r25
    13d2:	df 91       	pop	r29
    13d4:	cf 91       	pop	r28
    13d6:	08 95       	ret

000013d8 <sIMU_Init>:
    13d8:	cf 93       	push	r28
    13da:	df 93       	push	r29
    13dc:	1f 92       	push	r1
    13de:	1f 92       	push	r1
    13e0:	cd b7       	in	r28, 0x3d	; 61
    13e2:	de b7       	in	r29, 0x3e	; 62
    13e4:	e3 e6       	ldi	r30, 0x63	; 99
    13e6:	fb e1       	ldi	r31, 0x1B	; 27
    13e8:	81 e0       	ldi	r24, 0x01	; 1
    13ea:	80 83       	st	Z, r24
    13ec:	24 ef       	ldi	r18, 0xF4	; 244
    13ee:	31 e0       	ldi	r19, 0x01	; 1
    13f0:	32 83       	std	Z+2, r19	; 0x02
    13f2:	21 83       	std	Z+1, r18	; 0x01
    13f4:	22 e8       	ldi	r18, 0x82	; 130
    13f6:	36 e0       	ldi	r19, 0x06	; 6
    13f8:	34 83       	std	Z+4, r19	; 0x04
    13fa:	23 83       	std	Z+3, r18	; 0x03
    13fc:	20 e9       	ldi	r18, 0x90	; 144
    13fe:	31 e0       	ldi	r19, 0x01	; 1
    1400:	36 83       	std	Z+6, r19	; 0x06
    1402:	25 83       	std	Z+5, r18	; 0x05
    1404:	17 82       	std	Z+7, r1	; 0x07
    1406:	10 86       	std	Z+8, r1	; 0x08
    1408:	81 87       	std	Z+9, r24	; 0x09
    140a:	82 87       	std	Z+10, r24	; 0x0a
    140c:	20 e1       	ldi	r18, 0x10	; 16
    140e:	30 e0       	ldi	r19, 0x00	; 0
    1410:	34 87       	std	Z+12, r19	; 0x0c
    1412:	23 87       	std	Z+11, r18	; 0x0b
    1414:	2d e0       	ldi	r18, 0x0D	; 13
    1416:	30 e0       	ldi	r19, 0x00	; 0
    1418:	36 87       	std	Z+14, r19	; 0x0e
    141a:	25 87       	std	Z+13, r18	; 0x0d
    141c:	22 e3       	ldi	r18, 0x32	; 50
    141e:	30 e0       	ldi	r19, 0x00	; 0
    1420:	30 8b       	std	Z+16, r19	; 0x10
    1422:	27 87       	std	Z+15, r18	; 0x0f
    1424:	11 8a       	std	Z+17, r1	; 0x11
    1426:	12 8a       	std	Z+18, r1	; 0x12
    1428:	83 8b       	std	Z+19, r24	; 0x13
    142a:	84 8b       	std	Z+20, r24	; 0x14
    142c:	88 eb       	ldi	r24, 0xB8	; 184
    142e:	9b e0       	ldi	r25, 0x0B	; 11
    1430:	96 8b       	std	Z+22, r25	; 0x16
    1432:	85 8b       	std	Z+21, r24	; 0x15
    1434:	8a e0       	ldi	r24, 0x0A	; 10
    1436:	90 e0       	ldi	r25, 0x00	; 0
    1438:	90 8f       	std	Z+24, r25	; 0x18
    143a:	87 8b       	std	Z+23, r24	; 0x17
    143c:	11 8e       	std	Z+25, r1	; 0x19
    143e:	10 92 7e 1b 	sts	0x1B7E, r1	; 0x801b7e <allOnesCounter+0x1>
    1442:	10 92 7d 1b 	sts	0x1B7D, r1	; 0x801b7d <allOnesCounter>
    1446:	10 92 80 1b 	sts	0x1B80, r1	; 0x801b80 <nonSuccessCounter+0x1>
    144a:	10 92 7f 1b 	sts	0x1B7F, r1	; 0x801b7f <nonSuccessCounter>
    144e:	0e 94 d1 26 	call	0x4da2	; 0x4da2 <vSPI_MasterInit>
    1452:	20 9a       	sbi	0x04, 0	; 4
    1454:	28 9a       	sbi	0x05, 0	; 5
    1456:	19 82       	std	Y+1, r1	; 0x01
    1458:	20 e1       	ldi	r18, 0x10	; 16
    145a:	37 e2       	ldi	r19, 0x27	; 39
    145c:	89 81       	ldd	r24, Y+1	; 0x01
    145e:	8f 5f       	subi	r24, 0xFF	; 255
    1460:	89 83       	std	Y+1, r24	; 0x01
    1462:	21 50       	subi	r18, 0x01	; 1
    1464:	31 09       	sbc	r19, r1
    1466:	d1 f7       	brne	.-12     	; 0x145c <sIMU_Init+0x84>
    1468:	6f e0       	ldi	r22, 0x0F	; 15
    146a:	ce 01       	movw	r24, r28
    146c:	02 96       	adiw	r24, 0x02	; 2
    146e:	9e df       	rcall	.-196    	; 0x13ac <sIMU_readRegister>
    1470:	8a 81       	ldd	r24, Y+2	; 0x02
    1472:	89 36       	cpi	r24, 0x69	; 105
    1474:	c9 f7       	brne	.-14     	; 0x1468 <sIMU_Init+0x90>
    1476:	80 e0       	ldi	r24, 0x00	; 0
    1478:	0f 90       	pop	r0
    147a:	0f 90       	pop	r0
    147c:	df 91       	pop	r29
    147e:	cf 91       	pop	r28
    1480:	08 95       	ret

00001482 <sIMU_readRegisterInt16>:
    1482:	0f 93       	push	r16
    1484:	1f 93       	push	r17
    1486:	cf 93       	push	r28
    1488:	df 93       	push	r29
    148a:	1f 92       	push	r1
    148c:	1f 92       	push	r1
    148e:	cd b7       	in	r28, 0x3d	; 61
    1490:	de b7       	in	r29, 0x3e	; 62
    1492:	8c 01       	movw	r16, r24
    1494:	42 e0       	ldi	r20, 0x02	; 2
    1496:	ce 01       	movw	r24, r28
    1498:	01 96       	adiw	r24, 0x01	; 1
    149a:	58 df       	rcall	.-336    	; 0x134c <sIMU_readRegisterRegion>
    149c:	2a 81       	ldd	r18, Y+2	; 0x02
    149e:	30 e0       	ldi	r19, 0x00	; 0
    14a0:	32 2f       	mov	r19, r18
    14a2:	22 27       	eor	r18, r18
    14a4:	99 81       	ldd	r25, Y+1	; 0x01
    14a6:	29 2b       	or	r18, r25
    14a8:	f8 01       	movw	r30, r16
    14aa:	31 83       	std	Z+1, r19	; 0x01
    14ac:	20 83       	st	Z, r18
    14ae:	0f 90       	pop	r0
    14b0:	0f 90       	pop	r0
    14b2:	df 91       	pop	r29
    14b4:	cf 91       	pop	r28
    14b6:	1f 91       	pop	r17
    14b8:	0f 91       	pop	r16
    14ba:	08 95       	ret

000014bc <sIMU_writeRegister>:
    14bc:	cf 93       	push	r28
    14be:	c6 2f       	mov	r28, r22
    14c0:	28 98       	cbi	0x05, 0	; 5
    14c2:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <ui8SPI_MasterTransmit>
    14c6:	8c 2f       	mov	r24, r28
    14c8:	0e 94 df 26 	call	0x4dbe	; 0x4dbe <ui8SPI_MasterTransmit>
    14cc:	28 9a       	sbi	0x05, 0	; 5
    14ce:	80 e0       	ldi	r24, 0x00	; 0
    14d0:	cf 91       	pop	r28
    14d2:	08 95       	ret

000014d4 <sIMU_begin>:
    14d4:	1f 93       	push	r17
    14d6:	cf 93       	push	r28
    14d8:	df 93       	push	r29
    14da:	1f 92       	push	r1
    14dc:	1f 92       	push	r1
    14de:	cd b7       	in	r28, 0x3d	; 61
    14e0:	de b7       	in	r29, 0x3e	; 62
    14e2:	19 82       	std	Y+1, r1	; 0x01
    14e4:	79 df       	rcall	.-270    	; 0x13d8 <sIMU_Init>
    14e6:	18 2f       	mov	r17, r24
    14e8:	19 82       	std	Y+1, r1	; 0x01
    14ea:	80 91 6c 1b 	lds	r24, 0x1B6C	; 0x801b6c <settings+0x9>
    14ee:	81 30       	cpi	r24, 0x01	; 1
    14f0:	09 f0       	breq	.+2      	; 0x14f4 <sIMU_begin+0x20>
    14f2:	83 c0       	rjmp	.+262    	; 0x15fa <sIMU_begin+0x126>
    14f4:	80 91 72 1b 	lds	r24, 0x1B72	; 0x801b72 <settings+0xf>
    14f8:	90 91 73 1b 	lds	r25, 0x1B73	; 0x801b73 <settings+0x10>
    14fc:	84 36       	cpi	r24, 0x64	; 100
    14fe:	91 05       	cpc	r25, r1
    1500:	41 f0       	breq	.+16     	; 0x1512 <sIMU_begin+0x3e>
    1502:	88 3c       	cpi	r24, 0xC8	; 200
    1504:	91 05       	cpc	r25, r1
    1506:	41 f0       	breq	.+16     	; 0x1518 <sIMU_begin+0x44>
    1508:	c2 97       	sbiw	r24, 0x32	; 50
    150a:	41 f4       	brne	.+16     	; 0x151c <sIMU_begin+0x48>
    150c:	83 e0       	ldi	r24, 0x03	; 3
    150e:	89 83       	std	Y+1, r24	; 0x01
    1510:	05 c0       	rjmp	.+10     	; 0x151c <sIMU_begin+0x48>
    1512:	82 e0       	ldi	r24, 0x02	; 2
    1514:	89 83       	std	Y+1, r24	; 0x01
    1516:	02 c0       	rjmp	.+4      	; 0x151c <sIMU_begin+0x48>
    1518:	81 e0       	ldi	r24, 0x01	; 1
    151a:	89 83       	std	Y+1, r24	; 0x01
    151c:	80 91 6e 1b 	lds	r24, 0x1B6E	; 0x801b6e <settings+0xb>
    1520:	90 91 6f 1b 	lds	r25, 0x1B6F	; 0x801b6f <settings+0xc>
    1524:	84 30       	cpi	r24, 0x04	; 4
    1526:	91 05       	cpc	r25, r1
    1528:	31 f0       	breq	.+12     	; 0x1536 <sIMU_begin+0x62>
    152a:	88 30       	cpi	r24, 0x08	; 8
    152c:	91 05       	cpc	r25, r1
    152e:	39 f0       	breq	.+14     	; 0x153e <sIMU_begin+0x6a>
    1530:	02 97       	sbiw	r24, 0x02	; 2
    1532:	49 f4       	brne	.+18     	; 0x1546 <sIMU_begin+0x72>
    1534:	0b c0       	rjmp	.+22     	; 0x154c <sIMU_begin+0x78>
    1536:	89 81       	ldd	r24, Y+1	; 0x01
    1538:	88 60       	ori	r24, 0x08	; 8
    153a:	89 83       	std	Y+1, r24	; 0x01
    153c:	07 c0       	rjmp	.+14     	; 0x154c <sIMU_begin+0x78>
    153e:	89 81       	ldd	r24, Y+1	; 0x01
    1540:	8c 60       	ori	r24, 0x0C	; 12
    1542:	89 83       	std	Y+1, r24	; 0x01
    1544:	03 c0       	rjmp	.+6      	; 0x154c <sIMU_begin+0x78>
    1546:	89 81       	ldd	r24, Y+1	; 0x01
    1548:	84 60       	ori	r24, 0x04	; 4
    154a:	89 83       	std	Y+1, r24	; 0x01
    154c:	80 91 70 1b 	lds	r24, 0x1B70	; 0x801b70 <settings+0xd>
    1550:	90 91 71 1b 	lds	r25, 0x1B71	; 0x801b71 <settings+0xe>
    1554:	80 3a       	cpi	r24, 0xA0	; 160
    1556:	21 e0       	ldi	r18, 0x01	; 1
    1558:	92 07       	cpc	r25, r18
    155a:	c1 f1       	breq	.+112    	; 0x15cc <sIMU_begin+0xf8>
    155c:	70 f4       	brcc	.+28     	; 0x157a <sIMU_begin+0xa6>
    155e:	8a 31       	cpi	r24, 0x1A	; 26
    1560:	91 05       	cpc	r25, r1
    1562:	21 f1       	breq	.+72     	; 0x15ac <sIMU_begin+0xd8>
    1564:	18 f4       	brcc	.+6      	; 0x156c <sIMU_begin+0x98>
    1566:	0d 97       	sbiw	r24, 0x0d	; 13
    1568:	e9 f0       	breq	.+58     	; 0x15a4 <sIMU_begin+0xd0>
    156a:	28 c0       	rjmp	.+80     	; 0x15bc <sIMU_begin+0xe8>
    156c:	84 33       	cpi	r24, 0x34	; 52
    156e:	91 05       	cpc	r25, r1
    1570:	09 f1       	breq	.+66     	; 0x15b4 <sIMU_begin+0xe0>
    1572:	80 3d       	cpi	r24, 0xD0	; 208
    1574:	91 05       	cpc	r25, r1
    1576:	31 f1       	breq	.+76     	; 0x15c4 <sIMU_begin+0xf0>
    1578:	21 c0       	rjmp	.+66     	; 0x15bc <sIMU_begin+0xe8>
    157a:	82 30       	cpi	r24, 0x02	; 2
    157c:	2d e0       	ldi	r18, 0x0D	; 13
    157e:	92 07       	cpc	r25, r18
    1580:	89 f1       	breq	.+98     	; 0x15e4 <sIMU_begin+0x110>
    1582:	40 f4       	brcc	.+16     	; 0x1594 <sIMU_begin+0xc0>
    1584:	81 34       	cpi	r24, 0x41	; 65
    1586:	23 e0       	ldi	r18, 0x03	; 3
    1588:	92 07       	cpc	r25, r18
    158a:	21 f1       	breq	.+72     	; 0x15d4 <sIMU_begin+0x100>
    158c:	8c 37       	cpi	r24, 0x7C	; 124
    158e:	96 40       	sbci	r25, 0x06	; 6
    1590:	29 f1       	breq	.+74     	; 0x15dc <sIMU_begin+0x108>
    1592:	14 c0       	rjmp	.+40     	; 0x15bc <sIMU_begin+0xe8>
    1594:	84 30       	cpi	r24, 0x04	; 4
    1596:	2a e1       	ldi	r18, 0x1A	; 26
    1598:	92 07       	cpc	r25, r18
    159a:	41 f1       	breq	.+80     	; 0x15ec <sIMU_begin+0x118>
    159c:	82 31       	cpi	r24, 0x12	; 18
    159e:	94 43       	sbci	r25, 0x34	; 52
    15a0:	49 f1       	breq	.+82     	; 0x15f4 <sIMU_begin+0x120>
    15a2:	0c c0       	rjmp	.+24     	; 0x15bc <sIMU_begin+0xe8>
    15a4:	89 81       	ldd	r24, Y+1	; 0x01
    15a6:	80 61       	ori	r24, 0x10	; 16
    15a8:	89 83       	std	Y+1, r24	; 0x01
    15aa:	27 c0       	rjmp	.+78     	; 0x15fa <sIMU_begin+0x126>
    15ac:	89 81       	ldd	r24, Y+1	; 0x01
    15ae:	80 62       	ori	r24, 0x20	; 32
    15b0:	89 83       	std	Y+1, r24	; 0x01
    15b2:	23 c0       	rjmp	.+70     	; 0x15fa <sIMU_begin+0x126>
    15b4:	89 81       	ldd	r24, Y+1	; 0x01
    15b6:	80 63       	ori	r24, 0x30	; 48
    15b8:	89 83       	std	Y+1, r24	; 0x01
    15ba:	1f c0       	rjmp	.+62     	; 0x15fa <sIMU_begin+0x126>
    15bc:	89 81       	ldd	r24, Y+1	; 0x01
    15be:	80 64       	ori	r24, 0x40	; 64
    15c0:	89 83       	std	Y+1, r24	; 0x01
    15c2:	1b c0       	rjmp	.+54     	; 0x15fa <sIMU_begin+0x126>
    15c4:	89 81       	ldd	r24, Y+1	; 0x01
    15c6:	80 65       	ori	r24, 0x50	; 80
    15c8:	89 83       	std	Y+1, r24	; 0x01
    15ca:	17 c0       	rjmp	.+46     	; 0x15fa <sIMU_begin+0x126>
    15cc:	89 81       	ldd	r24, Y+1	; 0x01
    15ce:	80 66       	ori	r24, 0x60	; 96
    15d0:	89 83       	std	Y+1, r24	; 0x01
    15d2:	13 c0       	rjmp	.+38     	; 0x15fa <sIMU_begin+0x126>
    15d4:	89 81       	ldd	r24, Y+1	; 0x01
    15d6:	80 67       	ori	r24, 0x70	; 112
    15d8:	89 83       	std	Y+1, r24	; 0x01
    15da:	0f c0       	rjmp	.+30     	; 0x15fa <sIMU_begin+0x126>
    15dc:	89 81       	ldd	r24, Y+1	; 0x01
    15de:	80 68       	ori	r24, 0x80	; 128
    15e0:	89 83       	std	Y+1, r24	; 0x01
    15e2:	0b c0       	rjmp	.+22     	; 0x15fa <sIMU_begin+0x126>
    15e4:	89 81       	ldd	r24, Y+1	; 0x01
    15e6:	80 69       	ori	r24, 0x90	; 144
    15e8:	89 83       	std	Y+1, r24	; 0x01
    15ea:	07 c0       	rjmp	.+14     	; 0x15fa <sIMU_begin+0x126>
    15ec:	89 81       	ldd	r24, Y+1	; 0x01
    15ee:	80 6a       	ori	r24, 0xA0	; 160
    15f0:	89 83       	std	Y+1, r24	; 0x01
    15f2:	03 c0       	rjmp	.+6      	; 0x15fa <sIMU_begin+0x126>
    15f4:	89 81       	ldd	r24, Y+1	; 0x01
    15f6:	80 6b       	ori	r24, 0xB0	; 176
    15f8:	89 83       	std	Y+1, r24	; 0x01
    15fa:	69 81       	ldd	r22, Y+1	; 0x01
    15fc:	80 e1       	ldi	r24, 0x10	; 16
    15fe:	5e df       	rcall	.-324    	; 0x14bc <sIMU_writeRegister>
    1600:	63 e1       	ldi	r22, 0x13	; 19
    1602:	ce 01       	movw	r24, r28
    1604:	01 96       	adiw	r24, 0x01	; 1
    1606:	d2 de       	rcall	.-604    	; 0x13ac <sIMU_readRegister>
    1608:	89 81       	ldd	r24, Y+1	; 0x01
    160a:	8f 77       	andi	r24, 0x7F	; 127
    160c:	89 83       	std	Y+1, r24	; 0x01
    160e:	90 91 6d 1b 	lds	r25, 0x1B6D	; 0x801b6d <settings+0xa>
    1612:	91 30       	cpi	r25, 0x01	; 1
    1614:	11 f4       	brne	.+4      	; 0x161a <sIMU_begin+0x146>
    1616:	80 68       	ori	r24, 0x80	; 128
    1618:	89 83       	std	Y+1, r24	; 0x01
    161a:	69 81       	ldd	r22, Y+1	; 0x01
    161c:	83 e1       	ldi	r24, 0x13	; 19
    161e:	4e df       	rcall	.-356    	; 0x14bc <sIMU_writeRegister>
    1620:	19 82       	std	Y+1, r1	; 0x01
    1622:	80 91 63 1b 	lds	r24, 0x1B63	; 0x801b63 <settings>
    1626:	81 30       	cpi	r24, 0x01	; 1
    1628:	09 f0       	breq	.+2      	; 0x162c <sIMU_begin+0x158>
    162a:	5b c0       	rjmp	.+182    	; 0x16e2 <sIMU_begin+0x20e>
    162c:	80 91 64 1b 	lds	r24, 0x1B64	; 0x801b64 <settings+0x1>
    1630:	90 91 65 1b 	lds	r25, 0x1B65	; 0x801b65 <settings+0x2>
    1634:	85 3f       	cpi	r24, 0xF5	; 245
    1636:	91 05       	cpc	r25, r1
    1638:	c1 f0       	breq	.+48     	; 0x166a <sIMU_begin+0x196>
    163a:	20 f4       	brcc	.+8      	; 0x1644 <sIMU_begin+0x170>
    163c:	8d 37       	cpi	r24, 0x7D	; 125
    163e:	91 05       	cpc	r25, r1
    1640:	49 f0       	breq	.+18     	; 0x1654 <sIMU_begin+0x180>
    1642:	11 c0       	rjmp	.+34     	; 0x1666 <sIMU_begin+0x192>
    1644:	84 3f       	cpi	r24, 0xF4	; 244
    1646:	21 e0       	ldi	r18, 0x01	; 1
    1648:	92 07       	cpc	r25, r18
    164a:	39 f0       	breq	.+14     	; 0x165a <sIMU_begin+0x186>
    164c:	88 3e       	cpi	r24, 0xE8	; 232
    164e:	93 40       	sbci	r25, 0x03	; 3
    1650:	39 f0       	breq	.+14     	; 0x1660 <sIMU_begin+0x18c>
    1652:	09 c0       	rjmp	.+18     	; 0x1666 <sIMU_begin+0x192>
    1654:	82 e0       	ldi	r24, 0x02	; 2
    1656:	89 83       	std	Y+1, r24	; 0x01
    1658:	08 c0       	rjmp	.+16     	; 0x166a <sIMU_begin+0x196>
    165a:	84 e0       	ldi	r24, 0x04	; 4
    165c:	89 83       	std	Y+1, r24	; 0x01
    165e:	05 c0       	rjmp	.+10     	; 0x166a <sIMU_begin+0x196>
    1660:	88 e0       	ldi	r24, 0x08	; 8
    1662:	89 83       	std	Y+1, r24	; 0x01
    1664:	02 c0       	rjmp	.+4      	; 0x166a <sIMU_begin+0x196>
    1666:	8c e0       	ldi	r24, 0x0C	; 12
    1668:	89 83       	std	Y+1, r24	; 0x01
    166a:	80 91 66 1b 	lds	r24, 0x1B66	; 0x801b66 <settings+0x3>
    166e:	90 91 67 1b 	lds	r25, 0x1B67	; 0x801b67 <settings+0x4>
    1672:	80 3d       	cpi	r24, 0xD0	; 208
    1674:	91 05       	cpc	r25, r1
    1676:	31 f1       	breq	.+76     	; 0x16c4 <sIMU_begin+0x1f0>
    1678:	48 f4       	brcc	.+18     	; 0x168c <sIMU_begin+0x1b8>
    167a:	8a 31       	cpi	r24, 0x1A	; 26
    167c:	91 05       	cpc	r25, r1
    167e:	b1 f0       	breq	.+44     	; 0x16ac <sIMU_begin+0x1d8>
    1680:	84 33       	cpi	r24, 0x34	; 52
    1682:	91 05       	cpc	r25, r1
    1684:	b9 f0       	breq	.+46     	; 0x16b4 <sIMU_begin+0x1e0>
    1686:	0d 97       	sbiw	r24, 0x0d	; 13
    1688:	c9 f4       	brne	.+50     	; 0x16bc <sIMU_begin+0x1e8>
    168a:	0c c0       	rjmp	.+24     	; 0x16a4 <sIMU_begin+0x1d0>
    168c:	81 34       	cpi	r24, 0x41	; 65
    168e:	23 e0       	ldi	r18, 0x03	; 3
    1690:	92 07       	cpc	r25, r18
    1692:	01 f1       	breq	.+64     	; 0x16d4 <sIMU_begin+0x200>
    1694:	8c 37       	cpi	r24, 0x7C	; 124
    1696:	26 e0       	ldi	r18, 0x06	; 6
    1698:	92 07       	cpc	r25, r18
    169a:	01 f1       	breq	.+64     	; 0x16dc <sIMU_begin+0x208>
    169c:	80 3a       	cpi	r24, 0xA0	; 160
    169e:	91 40       	sbci	r25, 0x01	; 1
    16a0:	69 f4       	brne	.+26     	; 0x16bc <sIMU_begin+0x1e8>
    16a2:	14 c0       	rjmp	.+40     	; 0x16cc <sIMU_begin+0x1f8>
    16a4:	89 81       	ldd	r24, Y+1	; 0x01
    16a6:	80 61       	ori	r24, 0x10	; 16
    16a8:	89 83       	std	Y+1, r24	; 0x01
    16aa:	1b c0       	rjmp	.+54     	; 0x16e2 <sIMU_begin+0x20e>
    16ac:	89 81       	ldd	r24, Y+1	; 0x01
    16ae:	80 62       	ori	r24, 0x20	; 32
    16b0:	89 83       	std	Y+1, r24	; 0x01
    16b2:	17 c0       	rjmp	.+46     	; 0x16e2 <sIMU_begin+0x20e>
    16b4:	89 81       	ldd	r24, Y+1	; 0x01
    16b6:	80 63       	ori	r24, 0x30	; 48
    16b8:	89 83       	std	Y+1, r24	; 0x01
    16ba:	13 c0       	rjmp	.+38     	; 0x16e2 <sIMU_begin+0x20e>
    16bc:	89 81       	ldd	r24, Y+1	; 0x01
    16be:	80 64       	ori	r24, 0x40	; 64
    16c0:	89 83       	std	Y+1, r24	; 0x01
    16c2:	0f c0       	rjmp	.+30     	; 0x16e2 <sIMU_begin+0x20e>
    16c4:	89 81       	ldd	r24, Y+1	; 0x01
    16c6:	80 65       	ori	r24, 0x50	; 80
    16c8:	89 83       	std	Y+1, r24	; 0x01
    16ca:	0b c0       	rjmp	.+22     	; 0x16e2 <sIMU_begin+0x20e>
    16cc:	89 81       	ldd	r24, Y+1	; 0x01
    16ce:	80 66       	ori	r24, 0x60	; 96
    16d0:	89 83       	std	Y+1, r24	; 0x01
    16d2:	07 c0       	rjmp	.+14     	; 0x16e2 <sIMU_begin+0x20e>
    16d4:	89 81       	ldd	r24, Y+1	; 0x01
    16d6:	80 67       	ori	r24, 0x70	; 112
    16d8:	89 83       	std	Y+1, r24	; 0x01
    16da:	03 c0       	rjmp	.+6      	; 0x16e2 <sIMU_begin+0x20e>
    16dc:	89 81       	ldd	r24, Y+1	; 0x01
    16de:	80 68       	ori	r24, 0x80	; 128
    16e0:	89 83       	std	Y+1, r24	; 0x01
    16e2:	69 81       	ldd	r22, Y+1	; 0x01
    16e4:	81 e1       	ldi	r24, 0x11	; 17
    16e6:	ea de       	rcall	.-556    	; 0x14bc <sIMU_writeRegister>
    16e8:	6f e0       	ldi	r22, 0x0F	; 15
    16ea:	ce 01       	movw	r24, r28
    16ec:	02 96       	adiw	r24, 0x02	; 2
    16ee:	5e de       	rcall	.-836    	; 0x13ac <sIMU_readRegister>
    16f0:	81 2f       	mov	r24, r17
    16f2:	0f 90       	pop	r0
    16f4:	0f 90       	pop	r0
    16f6:	df 91       	pop	r29
    16f8:	cf 91       	pop	r28
    16fa:	1f 91       	pop	r17
    16fc:	08 95       	ret

000016fe <i16IMU_readRawGyroZ>:
    16fe:	cf 93       	push	r28
    1700:	df 93       	push	r29
    1702:	1f 92       	push	r1
    1704:	1f 92       	push	r1
    1706:	cd b7       	in	r28, 0x3d	; 61
    1708:	de b7       	in	r29, 0x3e	; 62
    170a:	66 e2       	ldi	r22, 0x26	; 38
    170c:	ce 01       	movw	r24, r28
    170e:	01 96       	adiw	r24, 0x01	; 1
    1710:	b8 de       	rcall	.-656    	; 0x1482 <sIMU_readRegisterInt16>
    1712:	88 23       	and	r24, r24
    1714:	a9 f0       	breq	.+42     	; 0x1740 <i16IMU_readRawGyroZ+0x42>
    1716:	85 30       	cpi	r24, 0x05	; 5
    1718:	51 f4       	brne	.+20     	; 0x172e <i16IMU_readRawGyroZ+0x30>
    171a:	80 91 7d 1b 	lds	r24, 0x1B7D	; 0x801b7d <allOnesCounter>
    171e:	90 91 7e 1b 	lds	r25, 0x1B7E	; 0x801b7e <allOnesCounter+0x1>
    1722:	01 96       	adiw	r24, 0x01	; 1
    1724:	90 93 7e 1b 	sts	0x1B7E, r25	; 0x801b7e <allOnesCounter+0x1>
    1728:	80 93 7d 1b 	sts	0x1B7D, r24	; 0x801b7d <allOnesCounter>
    172c:	09 c0       	rjmp	.+18     	; 0x1740 <i16IMU_readRawGyroZ+0x42>
    172e:	80 91 7f 1b 	lds	r24, 0x1B7F	; 0x801b7f <nonSuccessCounter>
    1732:	90 91 80 1b 	lds	r25, 0x1B80	; 0x801b80 <nonSuccessCounter+0x1>
    1736:	01 96       	adiw	r24, 0x01	; 1
    1738:	90 93 80 1b 	sts	0x1B80, r25	; 0x801b80 <nonSuccessCounter+0x1>
    173c:	80 93 7f 1b 	sts	0x1B7F, r24	; 0x801b7f <nonSuccessCounter>
    1740:	89 81       	ldd	r24, Y+1	; 0x01
    1742:	9a 81       	ldd	r25, Y+2	; 0x02
    1744:	0f 90       	pop	r0
    1746:	0f 90       	pop	r0
    1748:	df 91       	pop	r29
    174a:	cf 91       	pop	r28
    174c:	08 95       	ret

0000174e <fIMU_calcGyro>:
    174e:	cf 92       	push	r12
    1750:	df 92       	push	r13
    1752:	ef 92       	push	r14
    1754:	ff 92       	push	r15
    1756:	cf 93       	push	r28
    1758:	fc 01       	movw	r30, r24
    175a:	40 91 64 1b 	lds	r20, 0x1B64	; 0x801b64 <settings+0x1>
    175e:	50 91 65 1b 	lds	r21, 0x1B65	; 0x801b65 <settings+0x2>
    1762:	45 3f       	cpi	r20, 0xF5	; 245
    1764:	51 05       	cpc	r21, r1
    1766:	b1 f0       	breq	.+44     	; 0x1794 <fIMU_calcGyro+0x46>
    1768:	9a 01       	movw	r18, r20
    176a:	a5 e2       	ldi	r26, 0x25	; 37
    176c:	b6 e0       	ldi	r27, 0x06	; 6
    176e:	0e 94 29 3b 	call	0x7652	; 0x7652 <__umulhisi3>
    1772:	48 1b       	sub	r20, r24
    1774:	59 0b       	sbc	r21, r25
    1776:	56 95       	lsr	r21
    1778:	47 95       	ror	r20
    177a:	84 0f       	add	r24, r20
    177c:	95 1f       	adc	r25, r21
    177e:	00 24       	eor	r0, r0
    1780:	88 0f       	add	r24, r24
    1782:	99 1f       	adc	r25, r25
    1784:	00 1c       	adc	r0, r0
    1786:	88 0f       	add	r24, r24
    1788:	99 1f       	adc	r25, r25
    178a:	00 1c       	adc	r0, r0
    178c:	89 2f       	mov	r24, r25
    178e:	90 2d       	mov	r25, r0
    1790:	c8 2f       	mov	r28, r24
    1792:	01 c0       	rjmp	.+2      	; 0x1796 <fIMU_calcGyro+0x48>
    1794:	c2 e0       	ldi	r28, 0x02	; 2
    1796:	bf 01       	movw	r22, r30
    1798:	ff 0f       	add	r31, r31
    179a:	88 0b       	sbc	r24, r24
    179c:	99 0b       	sbc	r25, r25
    179e:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    17a2:	20 e0       	ldi	r18, 0x00	; 0
    17a4:	30 e0       	ldi	r19, 0x00	; 0
    17a6:	4c e8       	ldi	r20, 0x8C	; 140
    17a8:	50 e4       	ldi	r21, 0x40	; 64
    17aa:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    17ae:	6b 01       	movw	r12, r22
    17b0:	7c 01       	movw	r14, r24
    17b2:	6c 2f       	mov	r22, r28
    17b4:	70 e0       	ldi	r23, 0x00	; 0
    17b6:	80 e0       	ldi	r24, 0x00	; 0
    17b8:	90 e0       	ldi	r25, 0x00	; 0
    17ba:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    17be:	9b 01       	movw	r18, r22
    17c0:	ac 01       	movw	r20, r24
    17c2:	c7 01       	movw	r24, r14
    17c4:	b6 01       	movw	r22, r12
    17c6:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    17ca:	20 e0       	ldi	r18, 0x00	; 0
    17cc:	30 e0       	ldi	r19, 0x00	; 0
    17ce:	4a e7       	ldi	r20, 0x7A	; 122
    17d0:	54 e4       	ldi	r21, 0x44	; 68
    17d2:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    17d6:	cf 91       	pop	r28
    17d8:	ff 90       	pop	r15
    17da:	ef 90       	pop	r14
    17dc:	df 90       	pop	r13
    17de:	cf 90       	pop	r12
    17e0:	08 95       	ret

000017e2 <fIMU_readFloatGyroZ>:
    }
    
    return output;
}
float fIMU_readFloatGyroZ(){
    float output = fIMU_calcGyro(i16IMU_readRawGyroZ());
    17e2:	8d df       	rcall	.-230    	; 0x16fe <i16IMU_readRawGyroZ>
    17e4:	b4 cf       	rjmp	.-152    	; 0x174e <fIMU_calcGyro>
    
    return output;
}
    17e6:	08 95       	ret

000017e8 <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    17e8:	ea e0       	ldi	r30, 0x0A	; 10
    17ea:	f1 e0       	ldi	r31, 0x01	; 1
    17ec:	80 81       	ld	r24, Z
    17ee:	87 60       	ori	r24, 0x07	; 7
    17f0:	80 83       	st	Z, r24
    17f2:	08 95       	ret

000017f4 <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
    17f4:	82 30       	cpi	r24, 0x02	; 2
    17f6:	91 05       	cpc	r25, r1
    17f8:	31 f4       	brne	.+12     	; 0x1806 <vLED_singleHigh+0x12>
    17fa:	eb e0       	ldi	r30, 0x0B	; 11
    17fc:	f1 e0       	ldi	r31, 0x01	; 1
    17fe:	80 81       	ld	r24, Z
    1800:	84 60       	ori	r24, 0x04	; 4
    1802:	80 83       	st	Z, r24
    1804:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
    1806:	81 30       	cpi	r24, 0x01	; 1
    1808:	91 05       	cpc	r25, r1
    180a:	31 f4       	brne	.+12     	; 0x1818 <vLED_singleHigh+0x24>
    180c:	eb e0       	ldi	r30, 0x0B	; 11
    180e:	f1 e0       	ldi	r31, 0x01	; 1
    1810:	80 81       	ld	r24, Z
    1812:	82 60       	ori	r24, 0x02	; 2
    1814:	80 83       	st	Z, r24
    1816:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
    1818:	89 2b       	or	r24, r25
    181a:	29 f4       	brne	.+10     	; 0x1826 <vLED_singleHigh+0x32>
    181c:	eb e0       	ldi	r30, 0x0B	; 11
    181e:	f1 e0       	ldi	r31, 0x01	; 1
    1820:	80 81       	ld	r24, Z
    1822:	81 60       	ori	r24, 0x01	; 1
    1824:	80 83       	st	Z, r24
    1826:	08 95       	ret

00001828 <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
    1828:	82 30       	cpi	r24, 0x02	; 2
    182a:	91 05       	cpc	r25, r1
    182c:	31 f4       	brne	.+12     	; 0x183a <vLED_singleLow+0x12>
    182e:	eb e0       	ldi	r30, 0x0B	; 11
    1830:	f1 e0       	ldi	r31, 0x01	; 1
    1832:	80 81       	ld	r24, Z
    1834:	8b 7f       	andi	r24, 0xFB	; 251
    1836:	80 83       	st	Z, r24
    1838:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
    183a:	81 30       	cpi	r24, 0x01	; 1
    183c:	91 05       	cpc	r25, r1
    183e:	31 f4       	brne	.+12     	; 0x184c <vLED_singleLow+0x24>
    1840:	eb e0       	ldi	r30, 0x0B	; 11
    1842:	f1 e0       	ldi	r31, 0x01	; 1
    1844:	80 81       	ld	r24, Z
    1846:	8d 7f       	andi	r24, 0xFD	; 253
    1848:	80 83       	st	Z, r24
    184a:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
    184c:	89 2b       	or	r24, r25
    184e:	29 f4       	brne	.+10     	; 0x185a <vLED_singleLow+0x32>
    1850:	eb e0       	ldi	r30, 0x0B	; 11
    1852:	f1 e0       	ldi	r31, 0x01	; 1
    1854:	80 81       	ld	r24, Z
    1856:	8e 7f       	andi	r24, 0xFE	; 254
    1858:	80 83       	st	Z, r24
    185a:	08 95       	ret

0000185c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    185c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    185e:	03 96       	adiw	r24, 0x03	; 3
    1860:	92 83       	std	Z+2, r25	; 0x02
    1862:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1864:	2f ef       	ldi	r18, 0xFF	; 255
    1866:	3f ef       	ldi	r19, 0xFF	; 255
    1868:	34 83       	std	Z+4, r19	; 0x04
    186a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    186c:	96 83       	std	Z+6, r25	; 0x06
    186e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1870:	90 87       	std	Z+8, r25	; 0x08
    1872:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1874:	10 82       	st	Z, r1
    1876:	08 95       	ret

00001878 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1878:	fc 01       	movw	r30, r24
    187a:	11 86       	std	Z+9, r1	; 0x09
    187c:	10 86       	std	Z+8, r1	; 0x08
    187e:	08 95       	ret

00001880 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1880:	cf 93       	push	r28
    1882:	df 93       	push	r29
    1884:	9c 01       	movw	r18, r24
    1886:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1888:	dc 01       	movw	r26, r24
    188a:	11 96       	adiw	r26, 0x01	; 1
    188c:	cd 91       	ld	r28, X+
    188e:	dc 91       	ld	r29, X
    1890:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1892:	d3 83       	std	Z+3, r29	; 0x03
    1894:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1896:	8c 81       	ldd	r24, Y+4	; 0x04
    1898:	9d 81       	ldd	r25, Y+5	; 0x05
    189a:	95 83       	std	Z+5, r25	; 0x05
    189c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    189e:	8c 81       	ldd	r24, Y+4	; 0x04
    18a0:	9d 81       	ldd	r25, Y+5	; 0x05
    18a2:	dc 01       	movw	r26, r24
    18a4:	13 96       	adiw	r26, 0x03	; 3
    18a6:	7c 93       	st	X, r23
    18a8:	6e 93       	st	-X, r22
    18aa:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    18ac:	7d 83       	std	Y+5, r23	; 0x05
    18ae:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    18b0:	31 87       	std	Z+9, r19	; 0x09
    18b2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    18b4:	f9 01       	movw	r30, r18
    18b6:	80 81       	ld	r24, Z
    18b8:	8f 5f       	subi	r24, 0xFF	; 255
    18ba:	80 83       	st	Z, r24
}
    18bc:	df 91       	pop	r29
    18be:	cf 91       	pop	r28
    18c0:	08 95       	ret

000018c2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    18c2:	cf 93       	push	r28
    18c4:	df 93       	push	r29
    18c6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    18c8:	48 81       	ld	r20, Y
    18ca:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    18cc:	4f 3f       	cpi	r20, 0xFF	; 255
    18ce:	2f ef       	ldi	r18, 0xFF	; 255
    18d0:	52 07       	cpc	r21, r18
    18d2:	21 f4       	brne	.+8      	; 0x18dc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    18d4:	fc 01       	movw	r30, r24
    18d6:	a7 81       	ldd	r26, Z+7	; 0x07
    18d8:	b0 85       	ldd	r27, Z+8	; 0x08
    18da:	0d c0       	rjmp	.+26     	; 0x18f6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    18dc:	dc 01       	movw	r26, r24
    18de:	13 96       	adiw	r26, 0x03	; 3
    18e0:	01 c0       	rjmp	.+2      	; 0x18e4 <vListInsert+0x22>
    18e2:	df 01       	movw	r26, r30
    18e4:	12 96       	adiw	r26, 0x02	; 2
    18e6:	ed 91       	ld	r30, X+
    18e8:	fc 91       	ld	r31, X
    18ea:	13 97       	sbiw	r26, 0x03	; 3
    18ec:	20 81       	ld	r18, Z
    18ee:	31 81       	ldd	r19, Z+1	; 0x01
    18f0:	42 17       	cp	r20, r18
    18f2:	53 07       	cpc	r21, r19
    18f4:	b0 f7       	brcc	.-20     	; 0x18e2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    18f6:	12 96       	adiw	r26, 0x02	; 2
    18f8:	ed 91       	ld	r30, X+
    18fa:	fc 91       	ld	r31, X
    18fc:	13 97       	sbiw	r26, 0x03	; 3
    18fe:	fb 83       	std	Y+3, r31	; 0x03
    1900:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    1902:	d5 83       	std	Z+5, r29	; 0x05
    1904:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1906:	bd 83       	std	Y+5, r27	; 0x05
    1908:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    190a:	13 96       	adiw	r26, 0x03	; 3
    190c:	dc 93       	st	X, r29
    190e:	ce 93       	st	-X, r28
    1910:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1912:	99 87       	std	Y+9, r25	; 0x09
    1914:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1916:	fc 01       	movw	r30, r24
    1918:	20 81       	ld	r18, Z
    191a:	2f 5f       	subi	r18, 0xFF	; 255
    191c:	20 83       	st	Z, r18
}
    191e:	df 91       	pop	r29
    1920:	cf 91       	pop	r28
    1922:	08 95       	ret

00001924 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1924:	cf 93       	push	r28
    1926:	df 93       	push	r29
    1928:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    192a:	a0 85       	ldd	r26, Z+8	; 0x08
    192c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    192e:	c2 81       	ldd	r28, Z+2	; 0x02
    1930:	d3 81       	ldd	r29, Z+3	; 0x03
    1932:	84 81       	ldd	r24, Z+4	; 0x04
    1934:	95 81       	ldd	r25, Z+5	; 0x05
    1936:	9d 83       	std	Y+5, r25	; 0x05
    1938:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    193a:	c4 81       	ldd	r28, Z+4	; 0x04
    193c:	d5 81       	ldd	r29, Z+5	; 0x05
    193e:	82 81       	ldd	r24, Z+2	; 0x02
    1940:	93 81       	ldd	r25, Z+3	; 0x03
    1942:	9b 83       	std	Y+3, r25	; 0x03
    1944:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1946:	11 96       	adiw	r26, 0x01	; 1
    1948:	8d 91       	ld	r24, X+
    194a:	9c 91       	ld	r25, X
    194c:	12 97       	sbiw	r26, 0x02	; 2
    194e:	e8 17       	cp	r30, r24
    1950:	f9 07       	cpc	r31, r25
    1952:	31 f4       	brne	.+12     	; 0x1960 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1954:	84 81       	ldd	r24, Z+4	; 0x04
    1956:	95 81       	ldd	r25, Z+5	; 0x05
    1958:	12 96       	adiw	r26, 0x02	; 2
    195a:	9c 93       	st	X, r25
    195c:	8e 93       	st	-X, r24
    195e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1960:	11 86       	std	Z+9, r1	; 0x09
    1962:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1964:	8c 91       	ld	r24, X
    1966:	81 50       	subi	r24, 0x01	; 1
    1968:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    196a:	df 91       	pop	r29
    196c:	cf 91       	pop	r28
    196e:	08 95       	ret

00001970 <vMainCommunicationTask>:
    #define toc PORTH &= ~(1<<PINH5)
#endif
void vMainPoseControllerTask( void *pvParameters );
/*  Communication task */
/*  Communication task */
void vMainCommunicationTask( void *pvParameters ){
    1970:	cf 93       	push	r28
    1972:	df 93       	push	r29
    1974:	cd b7       	in	r28, 0x3d	; 61
    1976:	de b7       	in	r29, 0x3e	; 62
    1978:	28 97       	sbiw	r28, 0x08	; 8
    197a:	0f b6       	in	r0, 0x3f	; 63
    197c:	f8 94       	cli
    197e:	de bf       	out	0x3e, r29	; 62
    1980:	0f be       	out	0x3f, r0	; 63
    1982:	cd bf       	out	0x3d, r28	; 61
	// Setup for the communication task
	
	struct sCartesian Setpoint = {0,0}; // Struct for setpoints from server
    1984:	19 82       	std	Y+1, r1	; 0x01
    1986:	1a 82       	std	Y+2, r1	; 0x02
    1988:	1b 82       	std	Y+3, r1	; 0x03
    198a:	1c 82       	std	Y+4, r1	; 0x04
    198c:	1d 82       	std	Y+5, r1	; 0x05
    198e:	1e 82       	std	Y+6, r1	; 0x06
    1990:	1f 82       	std	Y+7, r1	; 0x07
    1992:	18 86       	std	Y+8, r1	; 0x08

	message_t command_in; // Buffer for recieved messages

	server_communication_init();
    1994:	0e 94 59 24 	call	0x48b2	; 0x48b2 <server_communication_init>
	if(xTaskCreate(vARQTask, "ARQ", 300, NULL, 3, NULL) != pdPASS) {
    1998:	a1 2c       	mov	r10, r1
    199a:	b1 2c       	mov	r11, r1
    199c:	c1 2c       	mov	r12, r1
    199e:	d1 2c       	mov	r13, r1
    19a0:	e1 2c       	mov	r14, r1
    19a2:	f1 2c       	mov	r15, r1
    19a4:	03 e0       	ldi	r16, 0x03	; 3
    19a6:	20 e0       	ldi	r18, 0x00	; 0
    19a8:	30 e0       	ldi	r19, 0x00	; 0
    19aa:	4c e2       	ldi	r20, 0x2C	; 44
    19ac:	51 e0       	ldi	r21, 0x01	; 1
    19ae:	6b e0       	ldi	r22, 0x0B	; 11
    19b0:	76 e0       	ldi	r23, 0x06	; 6
    19b2:	85 e2       	ldi	r24, 0x25	; 37
    19b4:	95 e0       	ldi	r25, 0x05	; 5
    19b6:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <xTaskGenericCreate>
		//vLED_singleHigh(ledRED);
	}
	uint8_t success = 0;
	
	while(!success) {
		success = server_connect();
    19ba:	0e 94 62 24 	call	0x48c4	; 0x48c4 <server_connect>
    19be:	18 2f       	mov	r17, r24
		vTaskDelay(1000 / portTICK_PERIOD_MS);
    19c0:	88 ee       	ldi	r24, 0xE8	; 232
    19c2:	93 e0       	ldi	r25, 0x03	; 3
    19c4:	0e 94 a5 29 	call	0x534a	; 0x534a <vTaskDelay>
	if(xTaskCreate(vARQTask, "ARQ", 300, NULL, 3, NULL) != pdPASS) {
		//vLED_singleHigh(ledRED);
	}
	uint8_t success = 0;
	
	while(!success) {
    19c8:	11 23       	and	r17, r17
    19ca:	b9 f3       	breq	.-18     	; 0x19ba <vMainCommunicationTask+0x4a>
		success = server_connect();
		vTaskDelay(1000 / portTICK_PERIOD_MS);
		//vLED_toggle(ledGREEN);
	}
	
	send_handshake();
    19cc:	0e 94 6e 24 	call	0x48dc	; 0x48dc <send_handshake>
		
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
			taskENTER_CRITICAL();
			command_in = message_in;
    19d0:	0f 2e       	mov	r0, r31
    19d2:	fd e8       	ldi	r31, 0x8D	; 141
    19d4:	ef 2e       	mov	r14, r31
    19d6:	fb e1       	ldi	r31, 0x1B	; 27
    19d8:	ff 2e       	mov	r15, r31
    19da:	f0 2d       	mov	r31, r0
			
		
			switch(command_in.type){
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
					gHandshook = TRUE; // Set start flag true
    19dc:	01 e0       	ldi	r16, 0x01	; 1
	
	send_handshake();
	
	while(1){
		
		if (xSemaphoreTake(xCommandReadyBSem, portMAX_DELAY) == pdTRUE){
    19de:	20 e0       	ldi	r18, 0x00	; 0
    19e0:	4f ef       	ldi	r20, 0xFF	; 255
    19e2:	5f ef       	ldi	r21, 0xFF	; 255
    19e4:	60 e0       	ldi	r22, 0x00	; 0
    19e6:	70 e0       	ldi	r23, 0x00	; 0
    19e8:	80 91 89 1b 	lds	r24, 0x1B89	; 0x801b89 <xCommandReadyBSem>
    19ec:	90 91 8a 1b 	lds	r25, 0x1B8A	; 0x801b8a <xCommandReadyBSem+0x1>
    19f0:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
    19f4:	81 30       	cpi	r24, 0x01	; 1
    19f6:	09 f0       	breq	.+2      	; 0x19fa <vMainCommunicationTask+0x8a>
    19f8:	76 c0       	rjmp	.+236    	; 0x1ae6 <vMainCommunicationTask+0x176>
			// We have a new command from the server, copy it to the memory
			vTaskSuspendAll ();       // Temporarily disable context switching
    19fa:	0e 94 17 2c 	call	0x582e	; 0x582e <vTaskSuspendAll>
			taskENTER_CRITICAL();
    19fe:	0f b6       	in	r0, 0x3f	; 63
    1a00:	f8 94       	cli
    1a02:	0f 92       	push	r0
			command_in = message_in;
    1a04:	f7 01       	movw	r30, r14
    1a06:	10 81       	ld	r17, Z
    1a08:	a1 80       	ldd	r10, Z+1	; 0x01
    1a0a:	b2 80       	ldd	r11, Z+2	; 0x02
    1a0c:	c3 80       	ldd	r12, Z+3	; 0x03
    1a0e:	d4 80       	ldd	r13, Z+4	; 0x04
			taskEXIT_CRITICAL();
    1a10:	0f 90       	pop	r0
    1a12:	0f be       	out	0x3f, r0	; 63
			xTaskResumeAll ();      // Enable context switching
    1a14:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
			
		
			switch(command_in.type){
    1a18:	15 30       	cpi	r17, 0x05	; 5
    1a1a:	09 f4       	brne	.+2      	; 0x1a1e <vMainCommunicationTask+0xae>
    1a1c:	55 c0       	rjmp	.+170    	; 0x1ac8 <vMainCommunicationTask+0x158>
    1a1e:	28 f4       	brcc	.+10     	; 0x1a2a <vMainCommunicationTask+0xba>
    1a20:	12 30       	cpi	r17, 0x02	; 2
    1a22:	a9 f0       	breq	.+42     	; 0x1a4e <vMainCommunicationTask+0xde>
    1a24:	14 30       	cpi	r17, 0x04	; 4
    1a26:	a1 f1       	breq	.+104    	; 0x1a90 <vMainCommunicationTask+0x120>
    1a28:	5e c0       	rjmp	.+188    	; 0x1ae6 <vMainCommunicationTask+0x176>
    1a2a:	17 30       	cpi	r17, 0x07	; 7
    1a2c:	09 f4       	brne	.+2      	; 0x1a30 <vMainCommunicationTask+0xc0>
    1a2e:	54 c0       	rjmp	.+168    	; 0x1ad8 <vMainCommunicationTask+0x168>
    1a30:	18 f0       	brcs	.+6      	; 0x1a38 <vMainCommunicationTask+0xc8>
    1a32:	18 30       	cpi	r17, 0x08	; 8
    1a34:	49 f0       	breq	.+18     	; 0x1a48 <vMainCommunicationTask+0xd8>
    1a36:	57 c0       	rjmp	.+174    	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_CONFIRM:
					taskENTER_CRITICAL();
    1a38:	0f b6       	in	r0, 0x3f	; 63
    1a3a:	f8 94       	cli
    1a3c:	0f 92       	push	r0
					gHandshook = TRUE; // Set start flag true
    1a3e:	00 93 1c 1a 	sts	0x1A1C, r16	; 0x801a1c <gHandshook>
					taskEXIT_CRITICAL();
    1a42:	0f 90       	pop	r0
    1a44:	0f be       	out	0x3f, r0	; 63

					break;
    1a46:	4f c0       	rjmp	.+158    	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_PING:
					send_ping_response();
    1a48:	0e 94 76 25 	call	0x4aec	; 0x4aec <send_ping_response>
					break;
    1a4c:	4c c0       	rjmp	.+152    	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_ORDER:
					Setpoint.x = command_in.message.order.x;
    1a4e:	b5 01       	movw	r22, r10
    1a50:	bb 0c       	add	r11, r11
    1a52:	88 0b       	sbc	r24, r24
    1a54:	99 0b       	sbc	r25, r25
    1a56:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    1a5a:	69 83       	std	Y+1, r22	; 0x01
    1a5c:	7a 83       	std	Y+2, r23	; 0x02
    1a5e:	8b 83       	std	Y+3, r24	; 0x03
    1a60:	9c 83       	std	Y+4, r25	; 0x04
					Setpoint.y = command_in.message.order.y;
    1a62:	b6 01       	movw	r22, r12
    1a64:	dd 0c       	add	r13, r13
    1a66:	88 0b       	sbc	r24, r24
    1a68:	99 0b       	sbc	r25, r25
    1a6a:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    1a6e:	6d 83       	std	Y+5, r22	; 0x05
    1a70:	7e 83       	std	Y+6, r23	; 0x06
    1a72:	8f 83       	std	Y+7, r24	; 0x07
    1a74:	98 87       	std	Y+8, r25	; 0x08
					/* Relay new coordinates to position controller */
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1a76:	20 e0       	ldi	r18, 0x00	; 0
    1a78:	44 e6       	ldi	r20, 0x64	; 100
    1a7a:	50 e0       	ldi	r21, 0x00	; 0
    1a7c:	be 01       	movw	r22, r28
    1a7e:	6f 5f       	subi	r22, 0xFF	; 255
    1a80:	7f 4f       	sbci	r23, 0xFF	; 255
    1a82:	80 91 23 1a 	lds	r24, 0x1A23	; 0x801a23 <poseControllerQ>
    1a86:	90 91 24 1a 	lds	r25, 0x1A24	; 0x801a24 <poseControllerQ+0x1>
    1a8a:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <xQueueGenericSend>
					break;
    1a8e:	2b c0       	rjmp	.+86     	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_PAUSE:
					// Stop sending update messages
					taskENTER_CRITICAL();
    1a90:	0f b6       	in	r0, 0x3f	; 63
    1a92:	f8 94       	cli
    1a94:	0f 92       	push	r0
					gPaused = TRUE;
    1a96:	00 93 1b 1a 	sts	0x1A1B, r16	; 0x801a1b <gPaused>
					taskEXIT_CRITICAL();
    1a9a:	0f 90       	pop	r0
    1a9c:	0f be       	out	0x3f, r0	; 63
					// Stop controller
					Setpoint.x = 0;
    1a9e:	19 82       	std	Y+1, r1	; 0x01
    1aa0:	1a 82       	std	Y+2, r1	; 0x02
    1aa2:	1b 82       	std	Y+3, r1	; 0x03
    1aa4:	1c 82       	std	Y+4, r1	; 0x04
					Setpoint.y = 0;
    1aa6:	1d 82       	std	Y+5, r1	; 0x05
    1aa8:	1e 82       	std	Y+6, r1	; 0x06
    1aaa:	1f 82       	std	Y+7, r1	; 0x07
    1aac:	18 86       	std	Y+8, r1	; 0x08
					xQueueSend(poseControllerQ, &Setpoint, 100);
    1aae:	20 e0       	ldi	r18, 0x00	; 0
    1ab0:	44 e6       	ldi	r20, 0x64	; 100
    1ab2:	50 e0       	ldi	r21, 0x00	; 0
    1ab4:	be 01       	movw	r22, r28
    1ab6:	6f 5f       	subi	r22, 0xFF	; 255
    1ab8:	7f 4f       	sbci	r23, 0xFF	; 255
    1aba:	80 91 23 1a 	lds	r24, 0x1A23	; 0x801a23 <poseControllerQ>
    1abe:	90 91 24 1a 	lds	r25, 0x1A24	; 0x801a24 <poseControllerQ+0x1>
    1ac2:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <xQueueGenericSend>
					break;
    1ac6:	0f c0       	rjmp	.+30     	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_UNPAUSE:
					taskENTER_CRITICAL();
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	0f 92       	push	r0
					gPaused = FALSE;
    1ace:	10 92 1b 1a 	sts	0x1A1B, r1	; 0x801a1b <gPaused>
					taskEXIT_CRITICAL();
    1ad2:	0f 90       	pop	r0
    1ad4:	0f be       	out	0x3f, r0	; 63
					break;
    1ad6:	07 c0       	rjmp	.+14     	; 0x1ae6 <vMainCommunicationTask+0x176>
				case TYPE_FINISH:
					taskENTER_CRITICAL();
    1ad8:	0f b6       	in	r0, 0x3f	; 63
    1ada:	f8 94       	cli
    1adc:	0f 92       	push	r0
					gHandshook = FALSE;
    1ade:	10 92 1c 1a 	sts	0x1A1C, r1	; 0x801a1c <gHandshook>
					taskEXIT_CRITICAL();
    1ae2:	0f 90       	pop	r0
    1ae4:	0f be       	out	0x3f, r0	; 63
					break;
			}
			
			// Command is processed
		} // if (xCommandReady) end
		vLED_singleLow(ledYELLOW);
    1ae6:	81 e0       	ldi	r24, 0x01	; 1
    1ae8:	90 e0       	ldi	r25, 0x00	; 0
    1aea:	9e de       	rcall	.-708    	; 0x1828 <vLED_singleLow>
		//_delay_ms(100);
	}// While(1) end
    1aec:	78 cf       	rjmp	.-272    	; 0x19de <vMainCommunicationTask+0x6e>

00001aee <vMainSensorTowerTask>:
}// vMainComtask end

/*  Sensor tower task */
void vMainSensorTowerTask( void *pvParameters){
    1aee:	cf 93       	push	r28
    1af0:	df 93       	push	r29
    1af2:	cd b7       	in	r28, 0x3d	; 61
    1af4:	de b7       	in	r29, 0x3e	; 62
    1af6:	63 97       	sbiw	r28, 0x13	; 19
    1af8:	0f b6       	in	r0, 0x3f	; 63
    1afa:	f8 94       	cli
    1afc:	de bf       	out	0x3e, r29	; 62
    1afe:	0f be       	out	0x3f, r0	; 63
    1b00:	cd bf       	out	0x3d, r28	; 61
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    uint8_t robotMovement = moveStop;
    1b02:	19 82       	std	Y+1, r1	; 0x01
    
    uint8_t idleCounter = 0;
    1b04:	10 e0       	ldi	r17, 0x00	; 0
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    uint8_t servoResolution = 1;
    1b06:	21 e0       	ldi	r18, 0x01	; 1
    1b08:	28 8b       	std	Y+16, r18	; 0x10
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    uint8_t servoStep = 0;
    1b0a:	f1 2c       	mov	r15, r1
        
    float thetahat = 0;
    int16_t xhat = 0;
    int16_t yhat = 0;
    
    uint8_t rotationDirection = moveCounterClockwise;
    1b0c:	68 94       	set
    1b0e:	22 24       	eor	r2, r2
    1b10:	22 f8       	bld	r2, 2
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1b12:	68 94       	set
    1b14:	33 24       	eor	r3, r3
    1b16:	32 f8       	bld	r3, 2
    1b18:	0e c0       	rjmp	.+28     	; 0x1b36 <vMainSensorTowerTask+0x48>
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
                rotationDirection = moveClockwise;
    1b1a:	0f 2e       	mov	r0, r31
    1b1c:	f3 e0       	ldi	r31, 0x03	; 3
    1b1e:	2f 2e       	mov	r2, r31
    1b20:	f0 2d       	mov	r31, r0
    1b22:	09 c0       	rjmp	.+18     	; 0x1b36 <vMainSensorTowerTask+0x48>
    1b24:	0f 2e       	mov	r0, r31
    1b26:	f3 e0       	ldi	r31, 0x03	; 3
    1b28:	2f 2e       	mov	r2, r31
    1b2a:	f0 2d       	mov	r31, r0
    1b2c:	04 c0       	rjmp	.+8      	; 0x1b36 <vMainSensorTowerTask+0x48>
    1b2e:	0f 2e       	mov	r0, r31
    1b30:	f3 e0       	ldi	r31, 0x03	; 3
    1b32:	2f 2e       	mov	r2, r31
    1b34:	f0 2d       	mov	r31, r0
    TickType_t xLastWakeTime;
	
	uint8_t incr = 0;
    while(1){

	        if ((gHandshook == TRUE) && (gPaused == FALSE)){
    1b36:	80 91 1c 1a 	lds	r24, 0x1A1C	; 0x801a1c <gHandshook>
    1b3a:	81 30       	cpi	r24, 0x01	; 1
    1b3c:	09 f0       	breq	.+2      	; 0x1b40 <vMainSensorTowerTask+0x52>
    1b3e:	20 c1       	rjmp	.+576    	; 0x1d80 <vMainSensorTowerTask+0x292>
    1b40:	80 91 1b 1a 	lds	r24, 0x1A1B	; 0x801a1b <gPaused>
    1b44:	81 11       	cpse	r24, r1
    1b46:	1c c1       	rjmp	.+568    	; 0x1d80 <vMainSensorTowerTask+0x292>
            // xLastWakeTime variable with the current time.
            xLastWakeTime = xTaskGetTickCount(); 
    1b48:	0e 94 58 2d 	call	0x5ab0	; 0x5ab0 <xTaskGetTickCount>
    1b4c:	9b 83       	std	Y+3, r25	; 0x03
    1b4e:	8a 83       	std	Y+2, r24	; 0x02
            // Set scanning resolution depending on which movement the robot is executing.
            if (xQueueReceive(scanStatusQ, &robotMovement,150 / portTICK_PERIOD_MS) == pdTRUE){
    1b50:	20 e0       	ldi	r18, 0x00	; 0
    1b52:	46 e9       	ldi	r20, 0x96	; 150
    1b54:	50 e0       	ldi	r21, 0x00	; 0
    1b56:	be 01       	movw	r22, r28
    1b58:	6f 5f       	subi	r22, 0xFF	; 255
    1b5a:	7f 4f       	sbci	r23, 0xFF	; 255
    1b5c:	80 91 21 1a 	lds	r24, 0x1A21	; 0x801a21 <scanStatusQ>
    1b60:	90 91 22 1a 	lds	r25, 0x1A22	; 0x801a22 <scanStatusQ+0x1>
    1b64:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
    1b68:	81 30       	cpi	r24, 0x01	; 1
    1b6a:	c9 f4       	brne	.+50     	; 0x1b9e <vMainSensorTowerTask+0xb0>
                // Set servo step length according to movement, 
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
    1b6c:	89 81       	ldd	r24, Y+1	; 0x01
    1b6e:	88 23       	and	r24, r24
    1b70:	19 f0       	breq	.+6      	; 0x1b78 <vMainSensorTowerTask+0x8a>
    1b72:	83 30       	cpi	r24, 0x03	; 3
    1b74:	98 f4       	brcc	.+38     	; 0x1b9c <vMainSensorTowerTask+0xae>
    1b76:	08 c0       	rjmp	.+16     	; 0x1b88 <vMainSensorTowerTask+0x9a>
                {
                    case moveStop:
                        servoStep *= servoResolution;
    1b78:	38 89       	ldd	r19, Y+16	; 0x10
    1b7a:	f3 9e       	mul	r15, r19
    1b7c:	f0 2c       	mov	r15, r0
    1b7e:	11 24       	eor	r1, r1
                        servoResolution = 1;
                        idleCounter = 1;
    1b80:	11 e0       	ldi	r17, 0x01	; 1
                // Note that the iterations are skipped while robot is rotating (see further downbelow)
                switch (robotMovement)
                {
                    case moveStop:
                        servoStep *= servoResolution;
                        servoResolution = 1;
    1b82:	81 e0       	ldi	r24, 0x01	; 1
    1b84:	88 8b       	std	Y+16, r24	; 0x10
                        idleCounter = 1;
                    break;
    1b86:	0b c0       	rjmp	.+22     	; 0x1b9e <vMainSensorTowerTask+0xb0>
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
                        servoStep /= servoResolution;
    1b88:	9d ec       	ldi	r25, 0xCD	; 205
    1b8a:	f9 9e       	mul	r15, r25
    1b8c:	f1 2c       	mov	r15, r1
    1b8e:	11 24       	eor	r1, r1
    1b90:	f6 94       	lsr	r15
    1b92:	f6 94       	lsr	r15
                        idleCounter = 0;
    1b94:	10 e0       	ldi	r17, 0x00	; 0
                        servoResolution = 1;
                        idleCounter = 1;
                    break;
                    case moveForward:
                    case moveBackward:
                        servoResolution = 5;
    1b96:	25 e0       	ldi	r18, 0x05	; 5
    1b98:	28 8b       	std	Y+16, r18	; 0x10
                        servoStep /= servoResolution;
                        idleCounter = 0;
                    break;
    1b9a:	01 c0       	rjmp	.+2      	; 0x1b9e <vMainSensorTowerTask+0xb0>
                    case moveClockwise:
                    case moveCounterClockwise:
                        // Iterations are frozen while rotating, see further down
                        idleCounter = 0;
    1b9c:	10 e0       	ldi	r17, 0x00	; 0
                    default:
                        idleCounter = 0;
                    break;
                }
            }
            vServo_setAngle(servoStep*servoResolution);
    1b9e:	38 89       	ldd	r19, Y+16	; 0x10
    1ba0:	f3 9e       	mul	r15, r19
    1ba2:	80 2d       	mov	r24, r0
    1ba4:	11 24       	eor	r1, r1
    1ba6:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <vServo_setAngle>
            vTaskDelayUntil(&xLastWakeTime, 200 / portTICK_PERIOD_MS); // Wait total of 200 ms for servo to reach set point
    1baa:	68 ec       	ldi	r22, 0xC8	; 200
    1bac:	70 e0       	ldi	r23, 0x00	; 0
    1bae:	ce 01       	movw	r24, r28
    1bb0:	02 96       	adiw	r24, 0x02	; 2
    1bb2:	0e 94 02 28 	call	0x5004	; 0x5004 <vTaskDelayUntil>
            
            uint8_t forwardSensor = ui8DistSens_readCM(distSensFwd);
    1bb6:	80 e0       	ldi	r24, 0x00	; 0
    1bb8:	d8 d9       	rcall	.-3152   	; 0xf6a <ui8DistSens_readCM>
    1bba:	d8 2e       	mov	r13, r24
            uint8_t leftSensor = ui8DistSens_readCM(distSensLeft);
    1bbc:	81 e0       	ldi	r24, 0x01	; 1
    1bbe:	d5 d9       	rcall	.-3158   	; 0xf6a <ui8DistSens_readCM>
    1bc0:	e8 2e       	mov	r14, r24
            uint8_t rearSensor = ui8DistSens_readCM(distSensRear);
    1bc2:	83 e0       	ldi	r24, 0x03	; 3
    1bc4:	d2 d9       	rcall	.-3164   	; 0xf6a <ui8DistSens_readCM>
    1bc6:	c8 2e       	mov	r12, r24
            uint8_t rightSensor = ui8DistSens_readCM(distSensRight);
    1bc8:	82 e0       	ldi	r24, 0x02	; 2
    1bca:	cf d9       	rcall	.-3170   	; 0xf6a <ui8DistSens_readCM>
    1bcc:	89 8b       	std	Y+17, r24	; 0x11
    1bce:	20 e0       	ldi	r18, 0x00	; 0
		
            xSemaphoreTake(xPoseMutex,40 / portTICK_PERIOD_MS);
    1bd0:	48 e2       	ldi	r20, 0x28	; 40
    1bd2:	50 e0       	ldi	r21, 0x00	; 0
    1bd4:	60 e0       	ldi	r22, 0x00	; 0
    1bd6:	70 e0       	ldi	r23, 0x00	; 0
    1bd8:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    1bdc:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    1be0:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
    1be4:	40 90 17 1a 	lds	r4, 0x1A17	; 0x801a17 <gTheta_hat>
                thetahat = gTheta_hat;
    1be8:	50 90 18 1a 	lds	r5, 0x1A18	; 0x801a18 <gTheta_hat+0x1>
    1bec:	60 90 19 1a 	lds	r6, 0x1A19	; 0x801a19 <gTheta_hat+0x2>
    1bf0:	70 90 1a 1a 	lds	r7, 0x1A1A	; 0x801a1a <gTheta_hat+0x3>
    1bf4:	a0 90 15 1a 	lds	r10, 0x1A15	; 0x801a15 <gX_hat>
                xhat = gX_hat;
    1bf8:	b0 90 16 1a 	lds	r11, 0x1A16	; 0x801a16 <gX_hat+0x1>
    1bfc:	80 91 13 1a 	lds	r24, 0x1A13	; 0x801a13 <gY_hat>
                yhat = gY_hat;
    1c00:	90 91 14 1a 	lds	r25, 0x1A14	; 0x801a14 <gY_hat+0x1>
    1c04:	9d 87       	std	Y+13, r25	; 0x0d
    1c06:	8c 87       	std	Y+12, r24	; 0x0c
    1c08:	60 e0       	ldi	r22, 0x00	; 0
            xSemaphoreGive(xPoseMutex);
    1c0a:	70 e0       	ldi	r23, 0x00	; 0
    1c0c:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    1c10:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    1c14:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
    1c18:	1b 30       	cpi	r17, 0x0B	; 11
            
            // Experimental
            if ((idleCounter > 10) && (robotMovement == moveStop)){
    1c1a:	38 f0       	brcs	.+14     	; 0x1c2a <vMainSensorTowerTask+0x13c>
    1c1c:	89 81       	ldd	r24, Y+1	; 0x01
    1c1e:	81 11       	cpse	r24, r1
    1c20:	04 c0       	rjmp	.+8      	; 0x1c2a <vMainSensorTowerTask+0x13c>
    1c22:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <send_idle>
                // If the robot stands idle for 1 second, send 'status:idle' in case the server missed it.
                send_idle();
    1c26:	11 e0       	ldi	r17, 0x01	; 1
                idleCounter = 1;
    1c28:	06 c0       	rjmp	.+12     	; 0x1c36 <vMainSensorTowerTask+0x148>
    1c2a:	11 23       	and	r17, r17
            }
            else if ((idleCounter >= 1) && (robotMovement == moveStop)){
    1c2c:	21 f0       	breq	.+8      	; 0x1c36 <vMainSensorTowerTask+0x148>
    1c2e:	89 81       	ldd	r24, Y+1	; 0x01
    1c30:	81 11       	cpse	r24, r1
    1c32:	01 c0       	rjmp	.+2      	; 0x1c36 <vMainSensorTowerTask+0x148>
    1c34:	1f 5f       	subi	r17, 0xFF	; 255
                idleCounter++;
    1c36:	38 89       	ldd	r19, Y+16	; 0x10
            }             

            // Send updates to server
			
			//[Commented out to decrease messages, ]
            send_update(xhat/10,yhat/10,thetahat*RAD2DEG,servoStep*servoResolution,forwardSensor,leftSensor,rearSensor,rightSensor);
    1c38:	23 2f       	mov	r18, r19
    1c3a:	30 e0       	ldi	r19, 0x00	; 0
    1c3c:	3b 8b       	std	Y+19, r19	; 0x13
    1c3e:	2a 8b       	std	Y+18, r18	; 0x12
    1c40:	f2 9e       	mul	r15, r18
    1c42:	40 01       	movw	r8, r0
    1c44:	f3 9e       	mul	r15, r19
    1c46:	90 0c       	add	r9, r0
    1c48:	11 24       	eor	r1, r1
    1c4a:	8c 85       	ldd	r24, Y+12	; 0x0c
    1c4c:	9d 85       	ldd	r25, Y+13	; 0x0d
    1c4e:	6a e0       	ldi	r22, 0x0A	; 10
    1c50:	70 e0       	ldi	r23, 0x00	; 0
    1c52:	0e 94 16 3b 	call	0x762c	; 0x762c <__divmodhi4>
    1c56:	7d 87       	std	Y+13, r23	; 0x0d
    1c58:	6c 87       	std	Y+12, r22	; 0x0c
    1c5a:	c5 01       	movw	r24, r10
    1c5c:	6a e0       	ldi	r22, 0x0A	; 10
    1c5e:	70 e0       	ldi	r23, 0x00	; 0
    1c60:	0e 94 16 3b 	call	0x762c	; 0x762c <__divmodhi4>
    1c64:	7f 87       	std	Y+15, r23	; 0x0f
    1c66:	6e 87       	std	Y+14, r22	; 0x0e
    1c68:	20 e0       	ldi	r18, 0x00	; 0
    1c6a:	30 e0       	ldi	r19, 0x00	; 0
    1c6c:	44 e3       	ldi	r20, 0x34	; 52
    1c6e:	53 e4       	ldi	r21, 0x43	; 67
    1c70:	c3 01       	movw	r24, r6
    1c72:	b2 01       	movw	r22, r4
    1c74:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    1c78:	2b ed       	ldi	r18, 0xDB	; 219
    1c7a:	3f e0       	ldi	r19, 0x0F	; 15
    1c7c:	49 e4       	ldi	r20, 0x49	; 73
    1c7e:	50 e4       	ldi	r21, 0x40	; 64
    1c80:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    1c84:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    1c88:	a9 88       	ldd	r10, Y+17	; 0x11
    1c8a:	0d 2d       	mov	r16, r13
    1c8c:	94 01       	movw	r18, r8
    1c8e:	ab 01       	movw	r20, r22
    1c90:	6c 85       	ldd	r22, Y+12	; 0x0c
    1c92:	7d 85       	ldd	r23, Y+13	; 0x0d
    1c94:	8e 85       	ldd	r24, Y+14	; 0x0e
    1c96:	9f 85       	ldd	r25, Y+15	; 0x0f
    1c98:	0e 94 d3 24 	call	0x49a6	; 0x49a6 <send_update>
    1c9c:	8f e1       	ldi	r24, 0x1F	; 31
            
            
            // Low level anti collision
            uint8_t objectX;
            if ((servoStep*servoResolution) <= 30) objectX = forwardSensor;// * cos(servoStep*5);
    1c9e:	88 16       	cp	r8, r24
    1ca0:	91 04       	cpc	r9, r1
    1ca2:	2c f0       	brlt	.+10     	; 0x1cae <vMainSensorTowerTask+0x1c0>
    1ca4:	9c e3       	ldi	r25, 0x3C	; 60
            else if((servoStep*servoResolution) >= 60) objectX = rightSensor;// * cos(270 + servoStep*5);
    1ca6:	89 16       	cp	r8, r25
    1ca8:	91 04       	cpc	r9, r1
    1caa:	8c f1       	brlt	.+98     	; 0x1d0e <vMainSensorTowerTask+0x220>
    1cac:	d9 88       	ldd	r13, Y+17	; 0x11
    1cae:	8f ef       	ldi	r24, 0xFF	; 255
            else objectX = 0;
            

			
            if ((objectX > 0) && (objectX < 25)){
    1cb0:	8d 0d       	add	r24, r13
    1cb2:	88 31       	cpi	r24, 0x18	; 24
    1cb4:	60 f5       	brcc	.+88     	; 0x1d0e <vMainSensorTowerTask+0x220>
    1cb6:	2e 85       	ldd	r18, Y+14	; 0x0e
                // Stop controller
                struct sCartesian Setpoint = {xhat/10, yhat/10};
    1cb8:	3f 85       	ldd	r19, Y+15	; 0x0f
    1cba:	b9 01       	movw	r22, r18
    1cbc:	33 0f       	add	r19, r19
    1cbe:	88 0b       	sbc	r24, r24
    1cc0:	99 0b       	sbc	r25, r25
    1cc2:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    1cc6:	6c 83       	std	Y+4, r22	; 0x04
    1cc8:	7d 83       	std	Y+5, r23	; 0x05
    1cca:	8e 83       	std	Y+6, r24	; 0x06
    1ccc:	9f 83       	std	Y+7, r25	; 0x07
    1cce:	2c 85       	ldd	r18, Y+12	; 0x0c
    1cd0:	3d 85       	ldd	r19, Y+13	; 0x0d
    1cd2:	b9 01       	movw	r22, r18
    1cd4:	33 0f       	add	r19, r19
    1cd6:	88 0b       	sbc	r24, r24
    1cd8:	99 0b       	sbc	r25, r25
    1cda:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    1cde:	68 87       	std	Y+8, r22	; 0x08
    1ce0:	79 87       	std	Y+9, r23	; 0x09
    1ce2:	8a 87       	std	Y+10, r24	; 0x0a
    1ce4:	9b 87       	std	Y+11, r25	; 0x0b
    1ce6:	8f e0       	ldi	r24, 0x0F	; 15
					debug("anti kollisjon");
    1ce8:	96 e0       	ldi	r25, 0x06	; 6
    1cea:	9f 93       	push	r25
    1cec:	8f 93       	push	r24
    1cee:	0e 94 39 25 	call	0x4a72	; 0x4a72 <debug>
    1cf2:	20 e0       	ldi	r18, 0x00	; 0
                xQueueSend(poseControllerQ, &Setpoint, 100);
    1cf4:	44 e6       	ldi	r20, 0x64	; 100
    1cf6:	50 e0       	ldi	r21, 0x00	; 0
    1cf8:	be 01       	movw	r22, r28
    1cfa:	6c 5f       	subi	r22, 0xFC	; 252
    1cfc:	7f 4f       	sbci	r23, 0xFF	; 255
    1cfe:	80 91 23 1a 	lds	r24, 0x1A23	; 0x801a23 <poseControllerQ>
    1d02:	90 91 24 1a 	lds	r25, 0x1A24	; 0x801a24 <poseControllerQ+0x1>
    1d06:	0e 94 3b 1f 	call	0x3e76	; 0x3e76 <xQueueGenericSend>
    1d0a:	0f 90       	pop	r0
    1d0c:	0f 90       	pop	r0
    1d0e:	3b e5       	ldi	r19, 0x5B	; 91
				
				
            }
            
            // Iterate in a increasing/decreasign manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
    1d10:	83 16       	cp	r8, r19
    1d12:	91 04       	cpc	r9, r1
    1d14:	ac f4       	brge	.+42     	; 0x1d40 <vMainSensorTowerTask+0x252>
    1d16:	84 e0       	ldi	r24, 0x04	; 4
    1d18:	28 12       	cpse	r2, r24
    1d1a:	12 c0       	rjmp	.+36     	; 0x1d40 <vMainSensorTowerTask+0x252>
    1d1c:	89 81       	ldd	r24, Y+1	; 0x01
    1d1e:	83 30       	cpi	r24, 0x03	; 3
    1d20:	08 f0       	brcs	.+2      	; 0x1d24 <vMainSensorTowerTask+0x236>
    1d22:	44 c0       	rjmp	.+136    	; 0x1dac <vMainSensorTowerTask+0x2be>
    1d24:	f3 94       	inc	r15
                servoStep++;
    1d26:	2a 89       	ldd	r18, Y+18	; 0x12
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1d28:	3b 89       	ldd	r19, Y+19	; 0x13
    1d2a:	f2 9e       	mul	r15, r18
    1d2c:	40 01       	movw	r8, r0
    1d2e:	f3 9e       	mul	r15, r19
    1d30:	90 0c       	add	r9, r0
    1d32:	11 24       	eor	r1, r1
    1d34:	3a e5       	ldi	r19, 0x5A	; 90
    1d36:	83 16       	cp	r8, r19
    1d38:	91 04       	cpc	r9, r1
    1d3a:	0c f0       	brlt	.+2      	; 0x1d3e <vMainSensorTowerTask+0x250>
    1d3c:	ee ce       	rjmp	.-548    	; 0x1b1a <vMainSensorTowerTask+0x2c>
    1d3e:	17 c0       	rjmp	.+46     	; 0x1d6e <vMainSensorTowerTask+0x280>
    1d40:	18 14       	cp	r1, r8
            
            // Iterate in a increasing/decreasign manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1d42:	19 04       	cpc	r1, r9
    1d44:	44 f5       	brge	.+80     	; 0x1d96 <vMainSensorTowerTask+0x2a8>
    1d46:	83 e0       	ldi	r24, 0x03	; 3
    1d48:	28 12       	cpse	r2, r24
    1d4a:	2a c0       	rjmp	.+84     	; 0x1da0 <vMainSensorTowerTask+0x2b2>
    1d4c:	89 81       	ldd	r24, Y+1	; 0x01
    1d4e:	83 30       	cpi	r24, 0x03	; 3
    1d50:	08 f0       	brcs	.+2      	; 0x1d54 <vMainSensorTowerTask+0x266>
    1d52:	f1 ce       	rjmp	.-542    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d54:	fa 94       	dec	r15
                servoStep --;
    1d56:	2a 89       	ldd	r18, Y+18	; 0x12
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1d58:	3b 89       	ldd	r19, Y+19	; 0x13
    1d5a:	f2 9e       	mul	r15, r18
    1d5c:	40 01       	movw	r8, r0
    1d5e:	f3 9e       	mul	r15, r19
    1d60:	90 0c       	add	r9, r0
    1d62:	11 24       	eor	r1, r1
    1d64:	04 c0       	rjmp	.+8      	; 0x1d6e <vMainSensorTowerTask+0x280>
    1d66:	34 e0       	ldi	r19, 0x04	; 4
    1d68:	23 16       	cp	r2, r19
    1d6a:	09 f4       	brne	.+2      	; 0x1d6e <vMainSensorTowerTask+0x280>
    1d6c:	db ce       	rjmp	.-586    	; 0x1b24 <vMainSensorTowerTask+0x36>
    1d6e:	18 14       	cp	r1, r8
                rotationDirection = moveClockwise;
            }
            else if ((servoStep*servoResolution <= 0) && (rotationDirection == moveClockwise)){
    1d70:	19 04       	cpc	r1, r9
    1d72:	0c f4       	brge	.+2      	; 0x1d76 <vMainSensorTowerTask+0x288>
    1d74:	e0 ce       	rjmp	.-576    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d76:	83 e0       	ldi	r24, 0x03	; 3
    1d78:	28 12       	cpse	r2, r24
    1d7a:	dd ce       	rjmp	.-582    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d7c:	23 2c       	mov	r2, r3
                rotationDirection = moveCounterClockwise;
    1d7e:	db ce       	rjmp	.-586    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d80:	80 e0       	ldi	r24, 0x00	; 0
            }    
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
    1d82:	0e 94 9a 25 	call	0x4b34	; 0x4b34 <vServo_setAngle>
    1d86:	84 e6       	ldi	r24, 0x64	; 100
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
            vTaskDelay(100/portTICK_PERIOD_MS);
    1d88:	90 e0       	ldi	r25, 0x00	; 0
    1d8a:	0e 94 a5 29 	call	0x534a	; 0x534a <vTaskDelay>
    1d8e:	10 e0       	ldi	r17, 0x00	; 0
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
            idleCounter = 0;
    1d90:	f1 2c       	mov	r15, r1
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
            servoStep = 0;
    1d92:	23 2c       	mov	r2, r3
        }
		
        else{ // Disconnected or unconfirmed
            vServo_setAngle(0);
            // Reset servo incrementation
            rotationDirection = moveCounterClockwise;
    1d94:	d0 ce       	rjmp	.-608    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1d96:	9a e5       	ldi	r25, 0x5A	; 90
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1d98:	89 16       	cp	r8, r25
    1d9a:	91 04       	cpc	r9, r1
    1d9c:	64 f3       	brlt	.-40     	; 0x1d76 <vMainSensorTowerTask+0x288>
    1d9e:	0a c0       	rjmp	.+20     	; 0x1db4 <vMainSensorTowerTask+0x2c6>
    1da0:	2a e5       	ldi	r18, 0x5A	; 90
    1da2:	82 16       	cp	r8, r18
    1da4:	91 04       	cpc	r9, r1
    1da6:	0c f4       	brge	.+2      	; 0x1daa <vMainSensorTowerTask+0x2bc>
    1da8:	c6 ce       	rjmp	.-628    	; 0x1b36 <vMainSensorTowerTask+0x48>
    1daa:	dd cf       	rjmp	.-70     	; 0x1d66 <vMainSensorTowerTask+0x278>
    1dac:	18 14       	cp	r1, r8
            
            // Iterate in a increasing/decreasign manner and depending on the robots movement
            if ((servoStep*servoResolution <= 90) && (rotationDirection == moveCounterClockwise) && (robotMovement < moveClockwise)){
                servoStep++;
            }
            else if ((servoStep*servoResolution > 0) && (rotationDirection == moveClockwise) && (robotMovement < moveClockwise)){
    1dae:	19 04       	cpc	r1, r9
    1db0:	bc f3       	brlt	.-18     	; 0x1da0 <vMainSensorTowerTask+0x2b2>
    1db2:	f1 cf       	rjmp	.-30     	; 0x1d96 <vMainSensorTowerTask+0x2a8>
    1db4:	34 e0       	ldi	r19, 0x04	; 4
                servoStep --;
            }
            
            if ((servoStep*servoResolution >= 90) && (rotationDirection == moveCounterClockwise)){
    1db6:	23 16       	cp	r2, r19
    1db8:	09 f4       	brne	.+2      	; 0x1dbc <vMainSensorTowerTask+0x2ce>
    1dba:	b9 ce       	rjmp	.-654    	; 0x1b2e <vMainSensorTowerTask+0x40>
    1dbc:	dc cf       	rjmp	.-72     	; 0x1d76 <vMainSensorTowerTask+0x288>

00001dbe <vMainPoseControllerTask>:
    1dbe:	cf 93       	push	r28
        }
    }// While end
}

/*  Calculates new settings for the movement task */
void vMainPoseControllerTask( void *pvParameters ){
    1dc0:	df 93       	push	r29
    1dc2:	cd b7       	in	r28, 0x3d	; 61
    1dc4:	de b7       	in	r29, 0x3e	; 62
    1dc6:	c4 57       	subi	r28, 0x74	; 116
    1dc8:	d1 09       	sbc	r29, r1
    1dca:	0f b6       	in	r0, 0x3f	; 63
    1dcc:	f8 94       	cli
    1dce:	de bf       	out	0x3e, r29	; 62
    1dd0:	0f be       	out	0x3f, r0	; 63
    1dd2:	cd bf       	out	0x3d, r28	; 61
    #ifdef DEBUG
        debug("PoseController OK\n");
        uint8_t tellar = 0;
    #endif
    /* Task init */    
    struct sCartesian Setpoint = {0,0}; // Updates from server
    1dd4:	19 82       	std	Y+1, r1	; 0x01
    1dd6:	1a 82       	std	Y+2, r1	; 0x02
    1dd8:	1b 82       	std	Y+3, r1	; 0x03
    1dda:	1c 82       	std	Y+4, r1	; 0x04
    1ddc:	1d 82       	std	Y+5, r1	; 0x05
    1dde:	1e 82       	std	Y+6, r1	; 0x06
    1de0:	1f 82       	std	Y+7, r1	; 0x07
    1de2:	18 86       	std	Y+8, r1	; 0x08
    struct sCartesian Error = {0,0}; // Error values
    struct sPolar oldVal = {0};
    struct sPolar referenceModel = {0};
	float radiusEpsilon = 15; //[mm]The acceptable radius from goal for completion
	uint8_t lastMovement = 0;
    1de4:	19 86       	std	Y+9, r1	; 0x09
	int16_t xhat = 0;
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
    1de6:	1a 86       	std	Y+10, r1	; 0x0a
    1de8:	1b 86       	std	Y+11, r1	; 0x0b
    1dea:	1c 86       	std	Y+12, r1	; 0x0c
    1dec:	1d 86       	std	Y+13, r1	; 0x0d
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
	volatile int16_t LSpeed = 0;
    1dee:	1f 86       	std	Y+15, r1	; 0x0f
    1df0:	1e 86       	std	Y+14, r1	; 0x0e
	volatile int16_t RSpeed = 0;
    1df2:	19 8a       	std	Y+17, r1	; 0x11
    1df4:	18 8a       	std	Y+16, r1	; 0x10
	
	int16_t leftWheelTicks = 0;
    1df6:	1b 8a       	std	Y+19, r1	; 0x13
    1df8:	1a 8a       	std	Y+18, r1	; 0x12
	int16_t rightWheelTicks = 0;
    1dfa:	1d 8a       	std	Y+21, r1	; 0x15
    1dfc:	1c 8a       	std	Y+20, r1	; 0x14
	
	uint8_t leftEncoderVal = 0;
	uint8_t rightEncoderVal = 0;
	
	uint8_t gLeftWheelDirection = 0;
    1dfe:	1e 8a       	std	Y+22, r1	; 0x16
	uint8_t gRightWheelDirection = 0;
    1e00:	1f 8a       	std	Y+23, r1	; 0x17
	
	/* TESTING VARIABLES */
	float distanceStart = 0;
	float prevDist= 0;
	float prevThetaDiff = 0;
	float StartDiff = 0;
    1e02:	18 8e       	std	Y+24, r1	; 0x18
    1e04:	19 8e       	std	Y+25, r1	; 0x19
    1e06:	1a 8e       	std	Y+26, r1	; 0x1a
    1e08:	1b 8e       	std	Y+27, r1	; 0x1b
	uint8_t blabla = 0;
	uint8_t printInc = 0;
	float thetaTraveled = 0;
    uint8_t newOrder = FALSE;
	uint8_t initIncrement = 40;
	uint8_t bStuck = FALSE;
    1e0a:	aa 96       	adiw	r28, 0x2a	; 42
    1e0c:	1f ae       	std	Y+63, r1	; 0x3f
    1e0e:	aa 97       	sbiw	r28, 0x2a	; 42
	uint8_t baseRotationSpeed = 20;
	uint8_t starteds = 0;
	uint8_t blabla = 0;
	uint8_t printInc = 0;
	float thetaTraveled = 0;
    uint8_t newOrder = FALSE;
    1e10:	2d 96       	adiw	r28, 0x0d	; 13
    1e12:	1f ae       	std	Y+63, r1	; 0x3f
    1e14:	2d 97       	sbiw	r28, 0x0d	; 13
	uint8_t bBaseDownRampActFound = FALSE;
	uint8_t bBaseRotationSpeed = FALSE;
	uint8_t baseRotationSpeed = 20;
	uint8_t starteds = 0;
	uint8_t blabla = 0;
	uint8_t printInc = 0;
    1e16:	1f aa       	std	Y+55, r1	; 0x37
	uint8_t baseDownRampActuation = 5;
	uint8_t bBaseUpRampActFound = FALSE;
	uint8_t bBaseDownRampActFound = FALSE;
	uint8_t bBaseRotationSpeed = FALSE;
	uint8_t baseRotationSpeed = 20;
	uint8_t starteds = 0;
    1e18:	a8 96       	adiw	r28, 0x28	; 40
    1e1a:	1f ae       	std	Y+63, r1	; 0x3f
    1e1c:	a8 97       	sbiw	r28, 0x28	; 40
	uint8_t baseUpRampActuation = 10;
	uint8_t baseDownRampActuation = 5;
	uint8_t bBaseUpRampActFound = FALSE;
	uint8_t bBaseDownRampActFound = FALSE;
	uint8_t bBaseRotationSpeed = FALSE;
	uint8_t baseRotationSpeed = 20;
    1e1e:	24 e1       	ldi	r18, 0x14	; 20
    1e20:	23 96       	adiw	r28, 0x03	; 3
    1e22:	2f af       	std	Y+63, r18	; 0x3f
    1e24:	23 97       	sbiw	r28, 0x03	; 3
	uint8_t idlesendtInc = 0;
	uint8_t baseUpRampActuation = 10;
	uint8_t baseDownRampActuation = 5;
	uint8_t bBaseUpRampActFound = FALSE;
	uint8_t bBaseDownRampActFound = FALSE;
	uint8_t bBaseRotationSpeed = FALSE;
    1e26:	a9 96       	adiw	r28, 0x29	; 41
    1e28:	1f ae       	std	Y+63, r1	; 0x3f
    1e2a:	a9 97       	sbiw	r28, 0x29	; 41

	int sugmeg = 0;
	uint8_t idlesendtInc = 0;
	uint8_t baseUpRampActuation = 10;
	uint8_t baseDownRampActuation = 5;
	uint8_t bBaseUpRampActFound = FALSE;
    1e2c:	e5 96       	adiw	r28, 0x35	; 53
    1e2e:	1f ae       	std	Y+63, r1	; 0x3f
    1e30:	e5 97       	sbiw	r28, 0x35	; 53
	uint8_t stuckRotRight = 0;

	int sugmeg = 0;
	uint8_t idlesendtInc = 0;
	uint8_t baseUpRampActuation = 10;
	uint8_t baseDownRampActuation = 5;
    1e32:	45 e0       	ldi	r20, 0x05	; 5
    1e34:	e4 96       	adiw	r28, 0x34	; 52
    1e36:	4f af       	std	Y+63, r20	; 0x3f
    1e38:	e4 97       	sbiw	r28, 0x34	; 52
	uint8_t stuckRotLeft = 0;
	uint8_t stuckRotRight = 0;

	int sugmeg = 0;
	uint8_t idlesendtInc = 0;
	uint8_t baseUpRampActuation = 10;
    1e3a:	8a e0       	ldi	r24, 0x0A	; 10
    1e3c:	a7 96       	adiw	r28, 0x27	; 39
    1e3e:	8f af       	std	Y+63, r24	; 0x3f
    1e40:	a7 97       	sbiw	r28, 0x27	; 39
	float xhatStart = 0;
	float yhatStart = 0;

	uint8_t stuckIncrement = 0;
	uint8_t stuckRotLeft = 0;
	uint8_t stuckRotRight = 0;
    1e42:	19 ae       	std	Y+57, r1	; 0x39
	float thetahatStart = 0;
	float xhatStart = 0;
	float yhatStart = 0;

	uint8_t stuckIncrement = 0;
	uint8_t stuckRotLeft = 0;
    1e44:	18 ae       	std	Y+56, r1	; 0x38
	float StartDiff = 0;
	float thetahatStart = 0;
	float xhatStart = 0;
	float yhatStart = 0;

	uint8_t stuckIncrement = 0;
    1e46:	2c 96       	adiw	r28, 0x0c	; 12
    1e48:	1f ae       	std	Y+63, r1	; 0x3f
    1e4a:	2c 97       	sbiw	r28, 0x0c	; 12
	float prevDist= 0;
	float prevThetaDiff = 0;
	float StartDiff = 0;
	float thetahatStart = 0;
	float xhatStart = 0;
	float yhatStart = 0;
    1e4c:	e2 96       	adiw	r28, 0x32	; 50
    1e4e:	1c ae       	std	Y+60, r1	; 0x3c
    1e50:	1d ae       	std	Y+61, r1	; 0x3d
    1e52:	1e ae       	std	Y+62, r1	; 0x3e
    1e54:	1f ae       	std	Y+63, r1	; 0x3f
    1e56:	e2 97       	sbiw	r28, 0x32	; 50
	float distanceStart = 0;
	float prevDist= 0;
	float prevThetaDiff = 0;
	float StartDiff = 0;
	float thetahatStart = 0;
	float xhatStart = 0;
    1e58:	ae 96       	adiw	r28, 0x2e	; 46
    1e5a:	1c ae       	std	Y+60, r1	; 0x3c
    1e5c:	1d ae       	std	Y+61, r1	; 0x3d
    1e5e:	1e ae       	std	Y+62, r1	; 0x3e
    1e60:	1f ae       	std	Y+63, r1	; 0x3f
    1e62:	ae 97       	sbiw	r28, 0x2e	; 46
	uint8_t rightEncoderVal = 0;
	
	uint8_t gLeftWheelDirection = 0;
	uint8_t gRightWheelDirection = 0;
	
	uint8_t idleSendt = FALSE;
    1e64:	6b 96       	adiw	r28, 0x1b	; 27
    1e66:	1f ae       	std	Y+63, r1	; 0x3f
    1e68:	6b 97       	sbiw	r28, 0x1b	; 27
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
	
	uint8_t doneTurning = TRUE;
    1e6a:	91 e0       	ldi	r25, 0x01	; 1
    1e6c:	62 96       	adiw	r28, 0x12	; 18
    1e6e:	9f af       	std	Y+63, r25	; 0x3f
    1e70:	62 97       	sbiw	r28, 0x12	; 18
	float thetaTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
	float rightIntError = 0;
    1e72:	6a 96       	adiw	r28, 0x1a	; 26
    1e74:	1c ae       	std	Y+60, r1	; 0x3c
    1e76:	1d ae       	std	Y+61, r1	; 0x3d
    1e78:	1e ae       	std	Y+62, r1	; 0x3e
    1e7a:	1f ae       	std	Y+63, r1	; 0x3f
    1e7c:	6a 97       	sbiw	r28, 0x1a	; 26
	float ydiff = 0;
	float thetaTargt = 0;
	
	float prevLeftActuation = 0;
	float prevRightActtion = 0;
	float leftIntError = 0;
    1e7e:	61 96       	adiw	r28, 0x11	; 17
    1e80:	1c ae       	std	Y+60, r1	; 0x3c
    1e82:	1d ae       	std	Y+61, r1	; 0x3d
    1e84:	1e ae       	std	Y+62, r1	; 0x3e
    1e86:	1f ae       	std	Y+63, r1	; 0x3f
    1e88:	61 97       	sbiw	r28, 0x11	; 17
	float xTargt = 0;
	float yTargt = 0;
	
	float xdiff = 0;
	float ydiff = 0;
	float thetaTargt = 0;
    1e8a:	1b a6       	std	Y+43, r1	; 0x2b
    1e8c:	1c a6       	std	Y+44, r1	; 0x2c
    1e8e:	1d a6       	std	Y+45, r1	; 0x2d
    1e90:	1e a6       	std	Y+46, r1	; 0x2e
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
	float yTargt = 0;
    1e92:	22 96       	adiw	r28, 0x02	; 2
    1e94:	1c ae       	std	Y+60, r1	; 0x3c
    1e96:	1d ae       	std	Y+61, r1	; 0x3d
    1e98:	1e ae       	std	Y+62, r1	; 0x3e
    1e9a:	1f ae       	std	Y+63, r1	; 0x3f
    1e9c:	22 97       	sbiw	r28, 0x02	; 2
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
	float thetaDiff = 0;
	float xTargt = 0;
    1e9e:	1a ae       	std	Y+58, r1	; 0x3a
    1ea0:	1b ae       	std	Y+59, r1	; 0x3b
    1ea2:	1c ae       	std	Y+60, r1	; 0x3c
    1ea4:	1d ae       	std	Y+61, r1	; 0x3d
	float thetahat = 0;
	int16_t xhat = 0;
	int16_t yhat = 0;
	
	/* Goal variables*/
	float distance = 0;
    1ea6:	63 96       	adiw	r28, 0x13	; 19
    1ea8:	1f ae       	std	Y+63, r1	; 0x3f
    1eaa:	63 97       	sbiw	r28, 0x13	; 19
    1eac:	64 96       	adiw	r28, 0x14	; 20
    1eae:	1f ae       	std	Y+63, r1	; 0x3f
    1eb0:	64 97       	sbiw	r28, 0x14	; 20
    1eb2:	65 96       	adiw	r28, 0x15	; 21
    1eb4:	1f ae       	std	Y+63, r1	; 0x3f
    1eb6:	65 97       	sbiw	r28, 0x15	; 21
    1eb8:	66 96       	adiw	r28, 0x16	; 22
    1eba:	1f ae       	std	Y+63, r1	; 0x3f
    1ebc:	66 97       	sbiw	r28, 0x16	; 22
	float rotateThreshold = 0.5235; //[rad] The threshold at which the robot will go from driving to rotation. Equals 10 degrees
	float driveThreshold = 0.0174; // [rad ]The threshold at which the robot will go from rotation to driving. In degrees.
	float driveKp = 600; //Proportional gain for theta control during drive
	float driveKi = 10;//Integral gain for theta during drive
	float speedDecreaseThreshold = 300; //[mm] Distance from goal where the robot will decrease its speed inverse proportionally
	float speedIncreaseThreshold = 100;	//[mm] Distance from start of movement where the speed increases to avoid spinning
    1ebe:	1f a2       	std	Y+39, r1	; 0x27
    1ec0:	18 a6       	std	Y+40, r1	; 0x28
    1ec2:	a8 ec       	ldi	r26, 0xC8	; 200
    1ec4:	a9 a7       	std	Y+41, r26	; 0x29
    1ec6:	b2 e4       	ldi	r27, 0x42	; 66
    1ec8:	ba a7       	std	Y+42, r27	; 0x2a
	/* Controller variables for tuning */
	float rotateThreshold = 0.5235; //[rad] The threshold at which the robot will go from driving to rotation. Equals 10 degrees
	float driveThreshold = 0.0174; // [rad ]The threshold at which the robot will go from rotation to driving. In degrees.
	float driveKp = 600; //Proportional gain for theta control during drive
	float driveKi = 10;//Integral gain for theta during drive
	float speedDecreaseThreshold = 300; //[mm] Distance from goal where the robot will decrease its speed inverse proportionally
    1eca:	1b aa       	std	Y+51, r1	; 0x33
    1ecc:	1c aa       	std	Y+52, r1	; 0x34
    1ece:	26 e9       	ldi	r18, 0x96	; 150
    1ed0:	2d ab       	std	Y+53, r18	; 0x35
    1ed2:	43 e4       	ldi	r20, 0x43	; 67
    1ed4:	4e ab       	std	Y+54, r20	; 0x36
    struct sPolar referenceModel = {0};
	float radiusEpsilon = 15; //[mm]The acceptable radius from goal for completion
	uint8_t lastMovement = 0;
	
	uint8_t maxRotateActuation = 100; //The max speed the motors will run at during rotation max is 255
	uint8_t maxDriveActuation = 100; //The max speed the motors will run at during drive max is 255
    1ed6:	84 e6       	ldi	r24, 0x64	; 100
    1ed8:	e3 96       	adiw	r28, 0x33	; 51
    1eda:	8f af       	std	Y+63, r24	; 0x3f
    1edc:	e3 97       	sbiw	r28, 0x33	; 51
	
	uint8_t stuckValueFound = FALSE;
	 
	while(1){
		
		if (gHandshook){
    1ede:	80 91 1c 1a 	lds	r24, 0x1A1C	; 0x801a1c <gHandshook>
    1ee2:	88 23       	and	r24, r24
    1ee4:	09 f4       	brne	.+2      	; 0x1ee8 <vMainPoseControllerTask+0x12a>
    1ee6:	fd c7       	rjmp	.+4090   	; 0x2ee2 <__stack+0xce3>
    return 1;
}

static __inline__ uint8_t __iCliRetVal(void)
{
    cli();
    1ee8:	f8 94       	cli
		
			ATOMIC_BLOCK(ATOMIC_FORCEON){
				leftEncoderVal = gISR_leftWheelTicks;
    1eea:	40 91 1d 1a 	lds	r20, 0x1A1D	; 0x801a1d <gISR_leftWheelTicks>
				gISR_leftWheelTicks = 0;
    1eee:	10 92 1d 1a 	sts	0x1A1D, r1	; 0x801a1d <gISR_leftWheelTicks>
				rightEncoderVal = gISR_rightWheelTicks;
    1ef2:	10 91 1e 1a 	lds	r17, 0x1A1E	; 0x801a1e <gISR_rightWheelTicks>
				gISR_rightWheelTicks = 0;
    1ef6:	10 92 1e 1a 	sts	0x1A1E, r1	; 0x801a1e <gISR_rightWheelTicks>
    return 1;
}

static __inline__ void __iSeiParam(const uint8_t *__s)
{
    sei();
    1efa:	78 94       	sei
			}

			vMotorEncoderLeftTickFromISR(gLeftWheelDirection, &leftWheelTicks, leftEncoderVal);
    1efc:	be 01       	movw	r22, r28
    1efe:	6e 5e       	subi	r22, 0xEE	; 238
    1f00:	7f 4f       	sbci	r23, 0xFF	; 255
    1f02:	8e 89       	ldd	r24, Y+22	; 0x16
    1f04:	0e 94 d3 1a 	call	0x35a6	; 0x35a6 <vMotorEncoderLeftTickFromISR>
			vMotorEncoderRightTickFromISR(gRightWheelDirection, &rightWheelTicks, rightEncoderVal);
    1f08:	41 2f       	mov	r20, r17
    1f0a:	be 01       	movw	r22, r28
    1f0c:	6c 5e       	subi	r22, 0xEC	; 236
    1f0e:	7f 4f       	sbci	r23, 0xFF	; 255
    1f10:	8f 89       	ldd	r24, Y+23	; 0x17
    1f12:	0e 94 e8 1a 	call	0x35d0	; 0x35d0 <vMotorEncoderRightTickFromISR>
			
			xSemaphoreTake(xTickMutex,1 / portTICK_PERIOD_MS);
    1f16:	20 e0       	ldi	r18, 0x00	; 0
    1f18:	41 e0       	ldi	r20, 0x01	; 1
    1f1a:	50 e0       	ldi	r21, 0x00	; 0
    1f1c:	60 e0       	ldi	r22, 0x00	; 0
    1f1e:	70 e0       	ldi	r23, 0x00	; 0
    1f20:	80 91 85 1b 	lds	r24, 0x1B85	; 0x801b85 <xTickMutex>
    1f24:	90 91 86 1b 	lds	r25, 0x1B86	; 0x801b86 <xTickMutex+0x1>
    1f28:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
			gLeftWheelTicks = leftWheelTicks;
    1f2c:	8a 89       	ldd	r24, Y+18	; 0x12
    1f2e:	9b 89       	ldd	r25, Y+19	; 0x13
    1f30:	90 93 08 1a 	sts	0x1A08, r25	; 0x801a08 <gLeftWheelTicks+0x1>
    1f34:	80 93 07 1a 	sts	0x1A07, r24	; 0x801a07 <gLeftWheelTicks>
			gRightWheelTicks = rightWheelTicks;
    1f38:	8c 89       	ldd	r24, Y+20	; 0x14
    1f3a:	9d 89       	ldd	r25, Y+21	; 0x15
    1f3c:	90 93 0a 1a 	sts	0x1A0A, r25	; 0x801a0a <gRightWheelTicks+0x1>
    1f40:	80 93 09 1a 	sts	0x1A09, r24	; 0x801a09 <gRightWheelTicks>
			xSemaphoreGive(xTickMutex);
    1f44:	60 e0       	ldi	r22, 0x00	; 0
    1f46:	70 e0       	ldi	r23, 0x00	; 0
    1f48:	80 91 85 1b 	lds	r24, 0x1B85	; 0x801b85 <xTickMutex>
    1f4c:	90 91 86 1b 	lds	r25, 0x1B86	; 0x801b86 <xTickMutex+0x1>
    1f50:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
	
			if (xSemaphoreTake(xControllerBSem, portMAX_DELAY) == pdTRUE){    // Wait for synchronization from estimator
    1f54:	20 e0       	ldi	r18, 0x00	; 0
    1f56:	4f ef       	ldi	r20, 0xFF	; 255
    1f58:	5f ef       	ldi	r21, 0xFF	; 255
    1f5a:	60 e0       	ldi	r22, 0x00	; 0
    1f5c:	70 e0       	ldi	r23, 0x00	; 0
    1f5e:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <xControllerBSem>
    1f62:	90 91 84 1b 	lds	r25, 0x1B84	; 0x801b84 <xControllerBSem+0x1>
    1f66:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
    1f6a:	81 30       	cpi	r24, 0x01	; 1
    1f6c:	09 f0       	breq	.+2      	; 0x1f70 <vMainPoseControllerTask+0x1b2>
    1f6e:	b7 cf       	rjmp	.-146    	; 0x1ede <vMainPoseControllerTask+0x120>
				// Get robot pose
				xSemaphoreTake(xPoseMutex,portMAX_DELAY);
    1f70:	20 e0       	ldi	r18, 0x00	; 0
    1f72:	4f ef       	ldi	r20, 0xFF	; 255
    1f74:	5f ef       	ldi	r21, 0xFF	; 255
    1f76:	60 e0       	ldi	r22, 0x00	; 0
    1f78:	70 e0       	ldi	r23, 0x00	; 0
    1f7a:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    1f7e:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    1f82:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
					thetahat = gTheta_hat;
    1f86:	90 91 17 1a 	lds	r25, 0x1A17	; 0x801a17 <gTheta_hat>
    1f8a:	9f a7       	std	Y+47, r25	; 0x2f
    1f8c:	a0 91 18 1a 	lds	r26, 0x1A18	; 0x801a18 <gTheta_hat+0x1>
    1f90:	a8 ab       	std	Y+48, r26	; 0x30
    1f92:	b0 91 19 1a 	lds	r27, 0x1A19	; 0x801a19 <gTheta_hat+0x2>
    1f96:	b9 ab       	std	Y+49, r27	; 0x31
    1f98:	20 91 1a 1a 	lds	r18, 0x1A1A	; 0x801a1a <gTheta_hat+0x3>
    1f9c:	2a ab       	std	Y+50, r18	; 0x32
					xhat = gX_hat;
    1f9e:	20 90 15 1a 	lds	r2, 0x1A15	; 0x801a15 <gX_hat>
    1fa2:	30 90 16 1a 	lds	r3, 0x1A16	; 0x801a16 <gX_hat+0x1>
					yhat = gY_hat;
    1fa6:	00 91 13 1a 	lds	r16, 0x1A13	; 0x801a13 <gY_hat>
    1faa:	10 91 14 1a 	lds	r17, 0x1A14	; 0x801a14 <gY_hat+0x1>
					dLeft = gLeft;
    1fae:	80 91 0f 1a 	lds	r24, 0x1A0F	; 0x801a0f <gLeft>
    1fb2:	90 91 10 1a 	lds	r25, 0x1A10	; 0x801a10 <gLeft+0x1>
    1fb6:	a0 91 11 1a 	lds	r26, 0x1A11	; 0x801a11 <gLeft+0x2>
    1fba:	b0 91 12 1a 	lds	r27, 0x1A12	; 0x801a12 <gLeft+0x3>
    1fbe:	27 96       	adiw	r28, 0x07	; 7
    1fc0:	8c af       	std	Y+60, r24	; 0x3c
    1fc2:	9d af       	std	Y+61, r25	; 0x3d
    1fc4:	ae af       	std	Y+62, r26	; 0x3e
    1fc6:	bf af       	std	Y+63, r27	; 0x3f
    1fc8:	27 97       	sbiw	r28, 0x07	; 7
					dRight = gRight;
    1fca:	80 91 0b 1a 	lds	r24, 0x1A0B	; 0x801a0b <gRight>
    1fce:	90 91 0c 1a 	lds	r25, 0x1A0C	; 0x801a0c <gRight+0x1>
    1fd2:	a0 91 0d 1a 	lds	r26, 0x1A0D	; 0x801a0d <gRight+0x2>
    1fd6:	b0 91 0e 1a 	lds	r27, 0x1A0E	; 0x801a0e <gRight+0x3>
    1fda:	2b 96       	adiw	r28, 0x0b	; 11
    1fdc:	8c af       	std	Y+60, r24	; 0x3c
    1fde:	9d af       	std	Y+61, r25	; 0x3d
    1fe0:	ae af       	std	Y+62, r26	; 0x3e
    1fe2:	bf af       	std	Y+63, r27	; 0x3f
    1fe4:	2b 97       	sbiw	r28, 0x0b	; 11
				xSemaphoreGive(xPoseMutex);
    1fe6:	60 e0       	ldi	r22, 0x00	; 0
    1fe8:	70 e0       	ldi	r23, 0x00	; 0
    1fea:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    1fee:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    1ff2:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
				
				// Check if a new update is received
				if (xQueueReceive(poseControllerQ, &Setpoint, 0) == pdTRUE){
    1ff6:	20 e0       	ldi	r18, 0x00	; 0
    1ff8:	40 e0       	ldi	r20, 0x00	; 0
    1ffa:	50 e0       	ldi	r21, 0x00	; 0
    1ffc:	be 01       	movw	r22, r28
    1ffe:	6f 5f       	subi	r22, 0xFF	; 255
    2000:	7f 4f       	sbci	r23, 0xFF	; 255
    2002:	80 91 23 1a 	lds	r24, 0x1A23	; 0x801a23 <poseControllerQ>
    2006:	90 91 24 1a 	lds	r25, 0x1A24	; 0x801a24 <poseControllerQ+0x1>
    200a:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
    200e:	81 30       	cpi	r24, 0x01	; 1
    2010:	09 f0       	breq	.+2      	; 0x2014 <vMainPoseControllerTask+0x256>
    2012:	58 c0       	rjmp	.+176    	; 0x20c4 <vMainPoseControllerTask+0x306>
					//xQueueReceive(poseControllerQ, &Setpoint, 20 / portTICK_PERIOD_MS); // Receive theta and radius set points from com task, wait for 20ms if necessary
					xTargt = (float)Setpoint.x*10;	//Distance is received in cm, convert to mm for continuity
    2014:	20 e0       	ldi	r18, 0x00	; 0
    2016:	30 e0       	ldi	r19, 0x00	; 0
    2018:	40 e2       	ldi	r20, 0x20	; 32
    201a:	51 e4       	ldi	r21, 0x41	; 65
    201c:	69 81       	ldd	r22, Y+1	; 0x01
    201e:	7a 81       	ldd	r23, Y+2	; 0x02
    2020:	8b 81       	ldd	r24, Y+3	; 0x03
    2022:	9c 81       	ldd	r25, Y+4	; 0x04
    2024:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2028:	6a af       	std	Y+58, r22	; 0x3a
    202a:	7b af       	std	Y+59, r23	; 0x3b
    202c:	8c af       	std	Y+60, r24	; 0x3c
    202e:	9d af       	std	Y+61, r25	; 0x3d
					yTargt = (float)Setpoint.y*10;	//Distance is received in cm, convert to mm for continuity
    2030:	20 e0       	ldi	r18, 0x00	; 0
    2032:	30 e0       	ldi	r19, 0x00	; 0
    2034:	40 e2       	ldi	r20, 0x20	; 32
    2036:	51 e4       	ldi	r21, 0x41	; 65
    2038:	6d 81       	ldd	r22, Y+5	; 0x05
    203a:	7e 81       	ldd	r23, Y+6	; 0x06
    203c:	8f 81       	ldd	r24, Y+7	; 0x07
    203e:	98 85       	ldd	r25, Y+8	; 0x08
    2040:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2044:	22 96       	adiw	r28, 0x02	; 2
    2046:	6c af       	std	Y+60, r22	; 0x3c
    2048:	7d af       	std	Y+61, r23	; 0x3d
    204a:	8e af       	std	Y+62, r24	; 0x3e
    204c:	9f af       	std	Y+63, r25	; 0x3f
    204e:	22 97       	sbiw	r28, 0x02	; 2
					thetahatStart = thetahat;
					xhatStart = xhat;
    2050:	b1 01       	movw	r22, r2
    2052:	03 2c       	mov	r0, r3
    2054:	00 0c       	add	r0, r0
    2056:	88 0b       	sbc	r24, r24
    2058:	99 0b       	sbc	r25, r25
    205a:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    205e:	ae 96       	adiw	r28, 0x2e	; 46
    2060:	6c af       	std	Y+60, r22	; 0x3c
    2062:	7d af       	std	Y+61, r23	; 0x3d
    2064:	8e af       	std	Y+62, r24	; 0x3e
    2066:	9f af       	std	Y+63, r25	; 0x3f
    2068:	ae 97       	sbiw	r28, 0x2e	; 46
					yhatStart = yhat;
    206a:	b8 01       	movw	r22, r16
    206c:	01 2e       	mov	r0, r17
    206e:	00 0c       	add	r0, r0
    2070:	88 0b       	sbc	r24, r24
    2072:	99 0b       	sbc	r25, r25
    2074:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    2078:	e2 96       	adiw	r28, 0x32	; 50
    207a:	6c af       	std	Y+60, r22	; 0x3c
    207c:	7d af       	std	Y+61, r23	; 0x3d
    207e:	8e af       	std	Y+62, r24	; 0x3e
    2080:	9f af       	std	Y+63, r25	; 0x3f
    2082:	e2 97       	sbiw	r28, 0x32	; 50
					StartDiff = thetaTargt - thetahatStart;
    2084:	7f a5       	ldd	r23, Y+47	; 0x2f
    2086:	68 a9       	ldd	r22, Y+48	; 0x30
    2088:	99 a9       	ldd	r25, Y+49	; 0x31
    208a:	8a a9       	ldd	r24, Y+50	; 0x32
    208c:	27 2f       	mov	r18, r23
    208e:	36 2f       	mov	r19, r22
    2090:	49 2f       	mov	r20, r25
    2092:	58 2f       	mov	r21, r24
    2094:	6b a5       	ldd	r22, Y+43	; 0x2b
    2096:	7c a5       	ldd	r23, Y+44	; 0x2c
    2098:	8d a5       	ldd	r24, Y+45	; 0x2d
    209a:	9e a5       	ldd	r25, Y+46	; 0x2e
    209c:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    20a0:	68 8f       	std	Y+24, r22	; 0x18
    20a2:	79 8f       	std	Y+25, r23	; 0x19
    20a4:	8a 8f       	std	Y+26, r24	; 0x1a
    20a6:	9b 8f       	std	Y+27, r25	; 0x1b
					starteds++;
    20a8:	a8 96       	adiw	r28, 0x28	; 40
    20aa:	9f ad       	ldd	r25, Y+63	; 0x3f
    20ac:	a8 97       	sbiw	r28, 0x28	; 40
    20ae:	9f 5f       	subi	r25, 0xFF	; 255
    20b0:	a8 96       	adiw	r28, 0x28	; 40
    20b2:	9f af       	std	Y+63, r25	; 0x3f
    20b4:	a8 97       	sbiw	r28, 0x28	; 40
					printInc = 0;
					newOrder = TRUE;
    20b6:	a1 e0       	ldi	r26, 0x01	; 1
    20b8:	2d 96       	adiw	r28, 0x0d	; 13
    20ba:	af af       	std	Y+63, r26	; 0x3f
    20bc:	2d 97       	sbiw	r28, 0x0d	; 13
					thetahatStart = thetahat;
					xhatStart = xhat;
					yhatStart = yhat;
					StartDiff = thetaTargt - thetahatStart;
					starteds++;
					printInc = 0;
    20be:	1f aa       	std	Y+55, r1	; 0x37
					newOrder = TRUE;
					stuckRotLeft = 0;
					stuckRotRight = 0;
    20c0:	19 ae       	std	Y+57, r1	; 0x39
					yhatStart = yhat;
					StartDiff = thetaTargt - thetahatStart;
					starteds++;
					printInc = 0;
					newOrder = TRUE;
					stuckRotLeft = 0;
    20c2:	18 ae       	std	Y+56, r1	; 0x38
				} 
				
				
				
				prevDist = distance;
				distance = (float)sqrt((xTargt-xhat)*(xTargt-xhat) + (yTargt-yhat)*(yTargt-yhat));
    20c4:	b1 01       	movw	r22, r2
    20c6:	03 2c       	mov	r0, r3
    20c8:	00 0c       	add	r0, r0
    20ca:	88 0b       	sbc	r24, r24
    20cc:	99 0b       	sbc	r25, r25
    20ce:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    20d2:	9b 01       	movw	r18, r22
    20d4:	ac 01       	movw	r20, r24
    20d6:	6a ad       	ldd	r22, Y+58	; 0x3a
    20d8:	7b ad       	ldd	r23, Y+59	; 0x3b
    20da:	8c ad       	ldd	r24, Y+60	; 0x3c
    20dc:	9d ad       	ldd	r25, Y+61	; 0x3d
    20de:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    20e2:	4b 01       	movw	r8, r22
    20e4:	5c 01       	movw	r10, r24
    20e6:	b8 01       	movw	r22, r16
    20e8:	01 2e       	mov	r0, r17
    20ea:	00 0c       	add	r0, r0
    20ec:	88 0b       	sbc	r24, r24
    20ee:	99 0b       	sbc	r25, r25
    20f0:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    20f4:	9b 01       	movw	r18, r22
    20f6:	ac 01       	movw	r20, r24
    20f8:	22 96       	adiw	r28, 0x02	; 2
    20fa:	6c ad       	ldd	r22, Y+60	; 0x3c
    20fc:	7d ad       	ldd	r23, Y+61	; 0x3d
    20fe:	8e ad       	ldd	r24, Y+62	; 0x3e
    2100:	9f ad       	ldd	r25, Y+63	; 0x3f
    2102:	22 97       	sbiw	r28, 0x02	; 2
    2104:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    2108:	6b 01       	movw	r12, r22
    210a:	7c 01       	movw	r14, r24
    210c:	a5 01       	movw	r20, r10
    210e:	94 01       	movw	r18, r8
    2110:	c5 01       	movw	r24, r10
    2112:	b4 01       	movw	r22, r8
    2114:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2118:	6c 8f       	std	Y+28, r22	; 0x1c
    211a:	7d 8f       	std	Y+29, r23	; 0x1d
    211c:	8e 8f       	std	Y+30, r24	; 0x1e
    211e:	9f 8f       	std	Y+31, r25	; 0x1f
    2120:	a7 01       	movw	r20, r14
    2122:	96 01       	movw	r18, r12
    2124:	c7 01       	movw	r24, r14
    2126:	b6 01       	movw	r22, r12
    2128:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    212c:	2b 01       	movw	r4, r22
    212e:	3c 01       	movw	r6, r24
    2130:	a3 01       	movw	r20, r6
    2132:	92 01       	movw	r18, r4
    2134:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2136:	7d 8d       	ldd	r23, Y+29	; 0x1d
    2138:	8e 8d       	ldd	r24, Y+30	; 0x1e
    213a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    213c:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    2140:	0e 94 26 37 	call	0x6e4c	; 0x6e4c <sqrt>
    2144:	6c 8f       	std	Y+28, r22	; 0x1c
    2146:	78 a3       	std	Y+32, r23	; 0x20
    2148:	89 a3       	std	Y+33, r24	; 0x21
    214a:	9a a3       	std	Y+34, r25	; 0x22
				
				xdiff = xTargt - xhat;
				ydiff = yTargt - yhat;
				thetaTargt = atan2(ydiff,xdiff); //atan() returns radians
    214c:	a5 01       	movw	r20, r10
    214e:	94 01       	movw	r18, r8
    2150:	c7 01       	movw	r24, r14
    2152:	b6 01       	movw	r22, r12
    2154:	0e 94 ab 34 	call	0x6956	; 0x6956 <atan2>
    2158:	6b a7       	std	Y+43, r22	; 0x2b
    215a:	7c a7       	std	Y+44, r23	; 0x2c
    215c:	8d a7       	std	Y+45, r24	; 0x2d
    215e:	9e a7       	std	Y+46, r25	; 0x2e
				
				prevThetaDiff = thetaDiff;
    2160:	8a 85       	ldd	r24, Y+10	; 0x0a
    2162:	9b 85       	ldd	r25, Y+11	; 0x0b
    2164:	ac 85       	ldd	r26, Y+12	; 0x0c
    2166:	bd 85       	ldd	r27, Y+13	; 0x0d
    2168:	8b a3       	std	Y+35, r24	; 0x23
    216a:	9c a3       	std	Y+36, r25	; 0x24
    216c:	ad a3       	std	Y+37, r26	; 0x25
    216e:	be a3       	std	Y+38, r27	; 0x26
				thetaDiff = thetaTargt-thetahat; //Might be outside pi to -pi degrees
    2170:	7f a5       	ldd	r23, Y+47	; 0x2f
    2172:	68 a9       	ldd	r22, Y+48	; 0x30
    2174:	99 a9       	ldd	r25, Y+49	; 0x31
    2176:	8a a9       	ldd	r24, Y+50	; 0x32
    2178:	27 2f       	mov	r18, r23
    217a:	36 2f       	mov	r19, r22
    217c:	49 2f       	mov	r20, r25
    217e:	58 2f       	mov	r21, r24
    2180:	6b a5       	ldd	r22, Y+43	; 0x2b
    2182:	7c a5       	ldd	r23, Y+44	; 0x2c
    2184:	8d a5       	ldd	r24, Y+45	; 0x2d
    2186:	9e a5       	ldd	r25, Y+46	; 0x2e
    2188:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    218c:	4b 01       	movw	r8, r22
    218e:	5c 01       	movw	r10, r24
    2190:	6a 87       	std	Y+10, r22	; 0x0a
    2192:	7b 87       	std	Y+11, r23	; 0x0b
    2194:	8c 87       	std	Y+12, r24	; 0x0c
    2196:	9d 87       	std	Y+13, r25	; 0x0d
				vFunc_Inf2pi(&thetaDiff);
    2198:	ce 01       	movw	r24, r28
    219a:	0a 96       	adiw	r24, 0x0a	; 10
    219c:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
				
				//Hysteresis mechanics
				if (fabs(thetaDiff) > rotateThreshold){
    21a0:	ca 84       	ldd	r12, Y+10	; 0x0a
    21a2:	db 84       	ldd	r13, Y+11	; 0x0b
    21a4:	ec 84       	ldd	r14, Y+12	; 0x0c
    21a6:	fd 84       	ldd	r15, Y+13	; 0x0d
    21a8:	26 01       	movw	r4, r12
    21aa:	37 01       	movw	r6, r14
    21ac:	e8 94       	clt
    21ae:	77 f8       	bld	r7, 7
    21b0:	29 e1       	ldi	r18, 0x19	; 25
    21b2:	34 e0       	ldi	r19, 0x04	; 4
    21b4:	46 e0       	ldi	r20, 0x06	; 6
    21b6:	5f e3       	ldi	r21, 0x3F	; 63
    21b8:	c3 01       	movw	r24, r6
    21ba:	b2 01       	movw	r22, r4
    21bc:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    21c0:	18 16       	cp	r1, r24
    21c2:	7c f0       	brlt	.+30     	; 0x21e2 <vMainPoseControllerTask+0x424>
					doneTurning = FALSE;
				} else if (fabs(thetaDiff) < driveThreshold){
    21c4:	22 e7       	ldi	r18, 0x72	; 114
    21c6:	3a e8       	ldi	r19, 0x8A	; 138
    21c8:	4e e8       	ldi	r20, 0x8E	; 142
    21ca:	5c e3       	ldi	r21, 0x3C	; 60
    21cc:	c3 01       	movw	r24, r6
    21ce:	b2 01       	movw	r22, r4
    21d0:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    21d4:	88 23       	and	r24, r24
    21d6:	44 f4       	brge	.+16     	; 0x21e8 <vMainPoseControllerTask+0x42a>
					doneTurning = TRUE;
    21d8:	91 e0       	ldi	r25, 0x01	; 1
    21da:	62 96       	adiw	r28, 0x12	; 18
    21dc:	9f af       	std	Y+63, r25	; 0x3f
    21de:	62 97       	sbiw	r28, 0x12	; 18
    21e0:	03 c0       	rjmp	.+6      	; 0x21e8 <vMainPoseControllerTask+0x42a>
				thetaDiff = thetaTargt-thetahat; //Might be outside pi to -pi degrees
				vFunc_Inf2pi(&thetaDiff);
				
				//Hysteresis mechanics
				if (fabs(thetaDiff) > rotateThreshold){
					doneTurning = FALSE;
    21e2:	62 96       	adiw	r28, 0x12	; 18
    21e4:	1f ae       	std	Y+63, r1	; 0x3f
    21e6:	62 97       	sbiw	r28, 0x12	; 18
				} else if (fabs(thetaDiff) < driveThreshold){
					doneTurning = TRUE;
				}
				
				if ((prevThetaDiff-thetaDiff)>(M_PI/2) || ((prevThetaDiff-thetaDiff)<(-M_PI/2))) // Gone past target or new target
    21e8:	a7 01       	movw	r20, r14
    21ea:	96 01       	movw	r18, r12
    21ec:	6b a1       	ldd	r22, Y+35	; 0x23
    21ee:	7c a1       	ldd	r23, Y+36	; 0x24
    21f0:	8d a1       	ldd	r24, Y+37	; 0x25
    21f2:	9e a1       	ldd	r25, Y+38	; 0x26
    21f4:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    21f8:	6b 01       	movw	r12, r22
    21fa:	7c 01       	movw	r14, r24
    21fc:	2b ed       	ldi	r18, 0xDB	; 219
    21fe:	3f e0       	ldi	r19, 0x0F	; 15
    2200:	49 ec       	ldi	r20, 0xC9	; 201
    2202:	5f e3       	ldi	r21, 0x3F	; 63
    2204:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    2208:	18 16       	cp	r1, r24
    220a:	54 f0       	brlt	.+20     	; 0x2220 <__stack+0x21>
    220c:	2b ed       	ldi	r18, 0xDB	; 219
    220e:	3f e0       	ldi	r19, 0x0F	; 15
    2210:	49 ec       	ldi	r20, 0xC9	; 201
    2212:	5f eb       	ldi	r21, 0xBF	; 191
    2214:	c7 01       	movw	r24, r14
    2216:	b6 01       	movw	r22, r12
    2218:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    221c:	88 23       	and	r24, r24
    221e:	4c f4       	brge	.+18     	; 0x2232 <__stack+0x33>
				{
					StartDiff = thetaTargt-thetahat;
    2220:	88 8e       	std	Y+24, r8	; 0x18
    2222:	99 8e       	std	Y+25, r9	; 0x19
    2224:	aa 8e       	std	Y+26, r10	; 0x1a
    2226:	bb 8e       	std	Y+27, r11	; 0x1b
					distanceStart = distance;
    2228:	bc 8c       	ldd	r11, Y+28	; 0x1c
    222a:	a8 a0       	ldd	r10, Y+32	; 0x20
    222c:	99 a0       	ldd	r9, Y+33	; 0x21
    222e:	8a a0       	ldd	r8, Y+34	; 0x22
    2230:	38 c0       	rjmp	.+112    	; 0x22a2 <__stack+0xa3>
				} else {
					distanceStart = (float)sqrt((xTargt-xhatStart)*(xTargt-xhatStart) + (yTargt-yhatStart)*(yTargt-yhatStart)); // KAN KANSKJE BLI FEIL VED ROTATSJON I STARTEN. ROBOTEN ROTERER IKKE HELT STATISK S XHAT OG YHAT KAN VRE FEIL
    2232:	ae 96       	adiw	r28, 0x2e	; 46
    2234:	2c ad       	ldd	r18, Y+60	; 0x3c
    2236:	3d ad       	ldd	r19, Y+61	; 0x3d
    2238:	4e ad       	ldd	r20, Y+62	; 0x3e
    223a:	5f ad       	ldd	r21, Y+63	; 0x3f
    223c:	ae 97       	sbiw	r28, 0x2e	; 46
    223e:	6a ad       	ldd	r22, Y+58	; 0x3a
    2240:	7b ad       	ldd	r23, Y+59	; 0x3b
    2242:	8c ad       	ldd	r24, Y+60	; 0x3c
    2244:	9d ad       	ldd	r25, Y+61	; 0x3d
    2246:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    224a:	4b 01       	movw	r8, r22
    224c:	5c 01       	movw	r10, r24
    224e:	e2 96       	adiw	r28, 0x32	; 50
    2250:	2c ad       	ldd	r18, Y+60	; 0x3c
    2252:	3d ad       	ldd	r19, Y+61	; 0x3d
    2254:	4e ad       	ldd	r20, Y+62	; 0x3e
    2256:	5f ad       	ldd	r21, Y+63	; 0x3f
    2258:	e2 97       	sbiw	r28, 0x32	; 50
    225a:	22 96       	adiw	r28, 0x02	; 2
    225c:	6c ad       	ldd	r22, Y+60	; 0x3c
    225e:	7d ad       	ldd	r23, Y+61	; 0x3d
    2260:	8e ad       	ldd	r24, Y+62	; 0x3e
    2262:	9f ad       	ldd	r25, Y+63	; 0x3f
    2264:	22 97       	sbiw	r28, 0x02	; 2
    2266:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    226a:	6b 01       	movw	r12, r22
    226c:	7c 01       	movw	r14, r24
    226e:	a5 01       	movw	r20, r10
    2270:	94 01       	movw	r18, r8
    2272:	c5 01       	movw	r24, r10
    2274:	b4 01       	movw	r22, r8
    2276:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    227a:	4b 01       	movw	r8, r22
    227c:	5c 01       	movw	r10, r24
    227e:	a7 01       	movw	r20, r14
    2280:	96 01       	movw	r18, r12
    2282:	c7 01       	movw	r24, r14
    2284:	b6 01       	movw	r22, r12
    2286:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    228a:	9b 01       	movw	r18, r22
    228c:	ac 01       	movw	r20, r24
    228e:	c5 01       	movw	r24, r10
    2290:	b4 01       	movw	r22, r8
    2292:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    2296:	0e 94 26 37 	call	0x6e4c	; 0x6e4c <sqrt>
    229a:	b6 2e       	mov	r11, r22
    229c:	a7 2e       	mov	r10, r23
    229e:	98 2e       	mov	r9, r24
    22a0:	89 2e       	mov	r8, r25
				}
				
				vFunc_Inf2pi(&StartDiff);
    22a2:	ce 01       	movw	r24, r28
    22a4:	48 96       	adiw	r24, 0x18	; 24
    22a6:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
				StartDiff = fabs(StartDiff);
    22aa:	c8 8c       	ldd	r12, Y+24	; 0x18
    22ac:	d9 8c       	ldd	r13, Y+25	; 0x19
    22ae:	ea 8c       	ldd	r14, Y+26	; 0x1a
    22b0:	fb 8c       	ldd	r15, Y+27	; 0x1b
    22b2:	e8 94       	clt
    22b4:	f7 f8       	bld	r15, 7
    22b6:	c8 8e       	std	Y+24, r12	; 0x18
    22b8:	d9 8e       	std	Y+25, r13	; 0x19
    22ba:	ea 8e       	std	Y+26, r14	; 0x1a
    22bc:	fb 8e       	std	Y+27, r15	; 0x1b
				
				
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
				if(distanceStart > 0 && distanceStart < (speedIncreaseThreshold+speedDecreaseThreshold)){ // Check if distance is shorter than upramp threshold + downramp threshold
    22be:	20 e0       	ldi	r18, 0x00	; 0
    22c0:	30 e0       	ldi	r19, 0x00	; 0
    22c2:	a9 01       	movw	r20, r18
    22c4:	6b 2d       	mov	r22, r11
    22c6:	7a 2d       	mov	r23, r10
    22c8:	89 2d       	mov	r24, r9
    22ca:	98 2d       	mov	r25, r8
    22cc:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    22d0:	18 16       	cp	r1, r24
    22d2:	0c f0       	brlt	.+2      	; 0x22d6 <__stack+0xd7>
    22d4:	86 c0       	rjmp	.+268    	; 0x23e2 <__stack+0x1e3>
    22d6:	2f a1       	ldd	r18, Y+39	; 0x27
    22d8:	38 a5       	ldd	r19, Y+40	; 0x28
    22da:	49 a5       	ldd	r20, Y+41	; 0x29
    22dc:	5a a5       	ldd	r21, Y+42	; 0x2a
    22de:	6b a9       	ldd	r22, Y+51	; 0x33
    22e0:	7c a9       	ldd	r23, Y+52	; 0x34
    22e2:	8d a9       	ldd	r24, Y+53	; 0x35
    22e4:	9e a9       	ldd	r25, Y+54	; 0x36
    22e6:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    22ea:	9b 01       	movw	r18, r22
    22ec:	ac 01       	movw	r20, r24
    22ee:	6b 2d       	mov	r22, r11
    22f0:	7a 2d       	mov	r23, r10
    22f2:	89 2d       	mov	r24, r9
    22f4:	98 2d       	mov	r25, r8
    22f6:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    22fa:	88 23       	and	r24, r24
    22fc:	0c f0       	brlt	.+2      	; 0x2300 <__stack+0x101>
    22fe:	98 c0       	rjmp	.+304    	; 0x2430 <__stack+0x231>
					float temp_inc = speedIncreaseThreshold;
					float temp_dec = speedDecreaseThreshold;
					speedIncreaseThreshold = distanceStart/4; // scale increase threshold to 1/4 of the Start distance
    2300:	20 e0       	ldi	r18, 0x00	; 0
    2302:	30 e0       	ldi	r19, 0x00	; 0
    2304:	40 e8       	ldi	r20, 0x80	; 128
    2306:	5e e3       	ldi	r21, 0x3E	; 62
    2308:	6b 2d       	mov	r22, r11
    230a:	7a 2d       	mov	r23, r10
    230c:	89 2d       	mov	r24, r9
    230e:	98 2d       	mov	r25, r8
    2310:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2314:	76 2e       	mov	r7, r22
    2316:	67 2e       	mov	r6, r23
    2318:	58 2e       	mov	r5, r24
    231a:	49 2e       	mov	r4, r25
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
    231c:	20 e0       	ldi	r18, 0x00	; 0
    231e:	30 e0       	ldi	r19, 0x00	; 0
    2320:	40 e4       	ldi	r20, 0x40	; 64
    2322:	50 e4       	ldi	r21, 0x40	; 64
    2324:	6b 2d       	mov	r22, r11
    2326:	7a 2d       	mov	r23, r10
    2328:	89 2d       	mov	r24, r9
    232a:	98 2d       	mov	r25, r8
    232c:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2330:	20 e0       	ldi	r18, 0x00	; 0
    2332:	30 e0       	ldi	r19, 0x00	; 0
    2334:	40 e8       	ldi	r20, 0x80	; 128
    2336:	5e e3       	ldi	r21, 0x3E	; 62
    2338:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    233c:	a3 96       	adiw	r28, 0x23	; 35
    233e:	6f af       	std	Y+63, r22	; 0x3f
    2340:	a3 97       	sbiw	r28, 0x23	; 35
    2342:	a4 96       	adiw	r28, 0x24	; 36
    2344:	7f af       	std	Y+63, r23	; 0x3f
    2346:	a4 97       	sbiw	r28, 0x24	; 36
    2348:	a5 96       	adiw	r28, 0x25	; 37
    234a:	8f af       	std	Y+63, r24	; 0x3f
    234c:	a5 97       	sbiw	r28, 0x25	; 37
    234e:	a6 96       	adiw	r28, 0x26	; 38
    2350:	9f af       	std	Y+63, r25	; 0x3f
    2352:	a6 97       	sbiw	r28, 0x26	; 38
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
    2354:	2f a1       	ldd	r18, Y+39	; 0x27
    2356:	38 a5       	ldd	r19, Y+40	; 0x28
    2358:	49 a5       	ldd	r20, Y+41	; 0x29
    235a:	5a a5       	ldd	r21, Y+42	; 0x2a
    235c:	67 2d       	mov	r22, r7
    235e:	76 2d       	mov	r23, r6
    2360:	85 2d       	mov	r24, r5
    2362:	94 2d       	mov	r25, r4
    2364:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    2368:	6b a3       	std	Y+35, r22	; 0x23
    236a:	6c 96       	adiw	r28, 0x1c	; 28
    236c:	7f af       	std	Y+63, r23	; 0x3f
    236e:	6c 97       	sbiw	r28, 0x1c	; 28
    2370:	6d 96       	adiw	r28, 0x1d	; 29
    2372:	8f af       	std	Y+63, r24	; 0x3f
    2374:	6d 97       	sbiw	r28, 0x1d	; 29
    2376:	6e 96       	adiw	r28, 0x1e	; 30
    2378:	9f af       	std	Y+63, r25	; 0x3f
    237a:	6e 97       	sbiw	r28, 0x1e	; 30
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
    237c:	2b a9       	ldd	r18, Y+51	; 0x33
    237e:	3c a9       	ldd	r19, Y+52	; 0x34
    2380:	4d a9       	ldd	r20, Y+53	; 0x35
    2382:	5e a9       	ldd	r21, Y+54	; 0x36
    2384:	a3 96       	adiw	r28, 0x23	; 35
    2386:	6f ad       	ldd	r22, Y+63	; 0x3f
    2388:	a3 97       	sbiw	r28, 0x23	; 35
    238a:	a4 96       	adiw	r28, 0x24	; 36
    238c:	7f ad       	ldd	r23, Y+63	; 0x3f
    238e:	a4 97       	sbiw	r28, 0x24	; 36
    2390:	a5 96       	adiw	r28, 0x25	; 37
    2392:	8f ad       	ldd	r24, Y+63	; 0x3f
    2394:	a5 97       	sbiw	r28, 0x25	; 37
    2396:	a6 96       	adiw	r28, 0x26	; 38
    2398:	9f ad       	ldd	r25, Y+63	; 0x3f
    239a:	a6 97       	sbiw	r28, 0x26	; 38
    239c:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    23a0:	6f 96       	adiw	r28, 0x1f	; 31
    23a2:	6f af       	std	Y+63, r22	; 0x3f
    23a4:	6f 97       	sbiw	r28, 0x1f	; 31
    23a6:	a0 96       	adiw	r28, 0x20	; 32
    23a8:	7f af       	std	Y+63, r23	; 0x3f
    23aa:	a0 97       	sbiw	r28, 0x20	; 32
    23ac:	a1 96       	adiw	r28, 0x21	; 33
    23ae:	8f af       	std	Y+63, r24	; 0x3f
    23b0:	a1 97       	sbiw	r28, 0x21	; 33
    23b2:	a2 96       	adiw	r28, 0x22	; 34
    23b4:	9f af       	std	Y+63, r25	; 0x3f
    23b6:	a2 97       	sbiw	r28, 0x22	; 34
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
				if(distanceStart > 0 && distanceStart < (speedIncreaseThreshold+speedDecreaseThreshold)){ // Check if distance is shorter than upramp threshold + downramp threshold
					float temp_inc = speedIncreaseThreshold;
					float temp_dec = speedDecreaseThreshold;
					speedIncreaseThreshold = distanceStart/4; // scale increase threshold to 1/4 of the Start distance
    23b8:	7f a2       	std	Y+39, r7	; 0x27
    23ba:	68 a6       	std	Y+40, r6	; 0x28
    23bc:	59 a6       	std	Y+41, r5	; 0x29
    23be:	4a a6       	std	Y+42, r4	; 0x2a
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
    23c0:	a3 96       	adiw	r28, 0x23	; 35
    23c2:	af ad       	ldd	r26, Y+63	; 0x3f
    23c4:	a3 97       	sbiw	r28, 0x23	; 35
    23c6:	ab ab       	std	Y+51, r26	; 0x33
    23c8:	a4 96       	adiw	r28, 0x24	; 36
    23ca:	bf ad       	ldd	r27, Y+63	; 0x3f
    23cc:	a4 97       	sbiw	r28, 0x24	; 36
    23ce:	bc ab       	std	Y+52, r27	; 0x34
    23d0:	a5 96       	adiw	r28, 0x25	; 37
    23d2:	2f ad       	ldd	r18, Y+63	; 0x3f
    23d4:	a5 97       	sbiw	r28, 0x25	; 37
    23d6:	2d ab       	std	Y+53, r18	; 0x35
    23d8:	a6 96       	adiw	r28, 0x26	; 38
    23da:	4f ad       	ldd	r20, Y+63	; 0x3f
    23dc:	a6 97       	sbiw	r28, 0x26	; 38
    23de:	4e ab       	std	Y+54, r20	; 0x36
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
				if(distanceStart > 0 && distanceStart < (speedIncreaseThreshold+speedDecreaseThreshold)){ // Check if distance is shorter than upramp threshold + downramp threshold
    23e0:	4d c0       	rjmp	.+154    	; 0x247c <__stack+0x27d>
				vFunc_Inf2pi(&StartDiff);
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
    23e2:	6f 96       	adiw	r28, 0x1f	; 31
    23e4:	1f ae       	std	Y+63, r1	; 0x3f
    23e6:	6f 97       	sbiw	r28, 0x1f	; 31
    23e8:	a0 96       	adiw	r28, 0x20	; 32
    23ea:	1f ae       	std	Y+63, r1	; 0x3f
    23ec:	a0 97       	sbiw	r28, 0x20	; 32
    23ee:	80 e8       	ldi	r24, 0x80	; 128
    23f0:	a1 96       	adiw	r28, 0x21	; 33
    23f2:	8f af       	std	Y+63, r24	; 0x3f
    23f4:	a1 97       	sbiw	r28, 0x21	; 33
    23f6:	9f e3       	ldi	r25, 0x3F	; 63
    23f8:	a2 96       	adiw	r28, 0x22	; 34
    23fa:	9f af       	std	Y+63, r25	; 0x3f
    23fc:	a2 97       	sbiw	r28, 0x22	; 34
				
				vFunc_Inf2pi(&StartDiff);
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
    23fe:	1b a2       	std	Y+35, r1	; 0x23
    2400:	6c 96       	adiw	r28, 0x1c	; 28
    2402:	1f ae       	std	Y+63, r1	; 0x3f
    2404:	6c 97       	sbiw	r28, 0x1c	; 28
    2406:	a0 e8       	ldi	r26, 0x80	; 128
    2408:	6d 96       	adiw	r28, 0x1d	; 29
    240a:	af af       	std	Y+63, r26	; 0x3f
    240c:	6d 97       	sbiw	r28, 0x1d	; 29
    240e:	bf e3       	ldi	r27, 0x3F	; 63
    2410:	6e 96       	adiw	r28, 0x1e	; 30
    2412:	bf af       	std	Y+63, r27	; 0x3f
    2414:	6e 97       	sbiw	r28, 0x1e	; 30
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
				} else {
					speedDecreaseThreshold = 300;
					speedIncreaseThreshold = 100;
    2416:	1f a2       	std	Y+39, r1	; 0x27
    2418:	18 a6       	std	Y+40, r1	; 0x28
    241a:	28 ec       	ldi	r18, 0xC8	; 200
    241c:	29 a7       	std	Y+41, r18	; 0x29
    241e:	42 e4       	ldi	r20, 0x42	; 66
    2420:	4a a7       	std	Y+42, r20	; 0x2a
					speedIncreaseThreshold = distanceStart/4; // scale increase threshold to 1/4 of the Start distance
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
				} else {
					speedDecreaseThreshold = 300;
    2422:	1b aa       	std	Y+51, r1	; 0x33
    2424:	1c aa       	std	Y+52, r1	; 0x34
    2426:	86 e9       	ldi	r24, 0x96	; 150
    2428:	8d ab       	std	Y+53, r24	; 0x35
    242a:	93 e4       	ldi	r25, 0x43	; 67
    242c:	9e ab       	std	Y+54, r25	; 0x36
    242e:	26 c0       	rjmp	.+76     	; 0x247c <__stack+0x27d>
				vFunc_Inf2pi(&StartDiff);
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
				float shortDistDecRatio = 1.0;
    2430:	6f 96       	adiw	r28, 0x1f	; 31
    2432:	1f ae       	std	Y+63, r1	; 0x3f
    2434:	6f 97       	sbiw	r28, 0x1f	; 31
    2436:	a0 96       	adiw	r28, 0x20	; 32
    2438:	1f ae       	std	Y+63, r1	; 0x3f
    243a:	a0 97       	sbiw	r28, 0x20	; 32
    243c:	a0 e8       	ldi	r26, 0x80	; 128
    243e:	a1 96       	adiw	r28, 0x21	; 33
    2440:	af af       	std	Y+63, r26	; 0x3f
    2442:	a1 97       	sbiw	r28, 0x21	; 33
    2444:	bf e3       	ldi	r27, 0x3F	; 63
    2446:	a2 96       	adiw	r28, 0x22	; 34
    2448:	bf af       	std	Y+63, r27	; 0x3f
    244a:	a2 97       	sbiw	r28, 0x22	; 34
				
				vFunc_Inf2pi(&StartDiff);
				StartDiff = fabs(StartDiff);
				
				
				float shortDistIncRatio = 1.0;
    244c:	1b a2       	std	Y+35, r1	; 0x23
    244e:	6c 96       	adiw	r28, 0x1c	; 28
    2450:	1f ae       	std	Y+63, r1	; 0x3f
    2452:	6c 97       	sbiw	r28, 0x1c	; 28
    2454:	20 e8       	ldi	r18, 0x80	; 128
    2456:	6d 96       	adiw	r28, 0x1d	; 29
    2458:	2f af       	std	Y+63, r18	; 0x3f
    245a:	6d 97       	sbiw	r28, 0x1d	; 29
    245c:	4f e3       	ldi	r20, 0x3F	; 63
    245e:	6e 96       	adiw	r28, 0x1e	; 30
    2460:	4f af       	std	Y+63, r20	; 0x3f
    2462:	6e 97       	sbiw	r28, 0x1e	; 30
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
				} else {
					speedDecreaseThreshold = 300;
					speedIncreaseThreshold = 100;
    2464:	1f a2       	std	Y+39, r1	; 0x27
    2466:	18 a6       	std	Y+40, r1	; 0x28
    2468:	88 ec       	ldi	r24, 0xC8	; 200
    246a:	89 a7       	std	Y+41, r24	; 0x29
    246c:	92 e4       	ldi	r25, 0x42	; 66
    246e:	9a a7       	std	Y+42, r25	; 0x2a
					speedIncreaseThreshold = distanceStart/4; // scale increase threshold to 1/4 of the Start distance
					speedDecreaseThreshold = distanceStart*3/4; // scale the decrease threshold to 3/4 of the start distance
					shortDistIncRatio = speedIncreaseThreshold/temp_inc; // ratio of new threshold to original one, used to scale the max actuation to the motors
					shortDistDecRatio = speedDecreaseThreshold/temp_dec; // ratio of new threshold to original one, used to scale the max actuation to the motors
				} else {
					speedDecreaseThreshold = 300;
    2470:	1b aa       	std	Y+51, r1	; 0x33
    2472:	1c aa       	std	Y+52, r1	; 0x34
    2474:	a6 e9       	ldi	r26, 0x96	; 150
    2476:	ad ab       	std	Y+53, r26	; 0x35
    2478:	b3 e4       	ldi	r27, 0x43	; 67
    247a:	be ab       	std	Y+54, r27	; 0x36
					speedIncreaseThreshold = 100;
				}
				
				if(distance > radiusEpsilon){//Not close enough to target
    247c:	20 e0       	ldi	r18, 0x00	; 0
    247e:	30 e0       	ldi	r19, 0x00	; 0
    2480:	40 e7       	ldi	r20, 0x70	; 112
    2482:	51 e4       	ldi	r21, 0x41	; 65
    2484:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2486:	78 a1       	ldd	r23, Y+32	; 0x20
    2488:	89 a1       	ldd	r24, Y+33	; 0x21
    248a:	9a a1       	ldd	r25, Y+34	; 0x22
    248c:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    2490:	18 16       	cp	r1, r24
    2492:	0c f0       	brlt	.+2      	; 0x2496 <__stack+0x297>
    2494:	d7 c4       	rjmp	.+2478   	; 0x2e44 <__stack+0xc45>
					
					
				
					idleSendt = FALSE;
				
					if (doneTurning){//Start forward movement
    2496:	62 96       	adiw	r28, 0x12	; 18
    2498:	2f ad       	ldd	r18, Y+63	; 0x3f
    249a:	62 97       	sbiw	r28, 0x12	; 18
    249c:	22 23       	and	r18, r18
    249e:	09 f4       	brne	.+2      	; 0x24a2 <__stack+0x2a3>
    24a0:	6b c2       	rjmp	.+1238   	; 0x2978 <__stack+0x779>
						//debug("Done Turning");
						stuckRotLeft = 0;
						stuckRotRight = 0;
						float distanceTraveled = distanceStart-distance;
    24a2:	2c 8d       	ldd	r18, Y+28	; 0x1c
    24a4:	38 a1       	ldd	r19, Y+32	; 0x20
    24a6:	49 a1       	ldd	r20, Y+33	; 0x21
    24a8:	5a a1       	ldd	r21, Y+34	; 0x22
    24aa:	6b 2d       	mov	r22, r11
    24ac:	7a 2d       	mov	r23, r10
    24ae:	89 2d       	mov	r24, r9
    24b0:	98 2d       	mov	r25, r8
    24b2:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    24b6:	4b 01       	movw	r8, r22
    24b8:	5c 01       	movw	r10, r24
						
						// Ramp up
						if (distanceTraveled >= 0 && distanceTraveled <= speedIncreaseThreshold){
    24ba:	20 e0       	ldi	r18, 0x00	; 0
    24bc:	30 e0       	ldi	r19, 0x00	; 0
    24be:	a9 01       	movw	r20, r18
    24c0:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    24c4:	88 23       	and	r24, r24
    24c6:	0c f4       	brge	.+2      	; 0x24ca <__stack+0x2cb>
    24c8:	b3 c0       	rjmp	.+358    	; 0x2630 <__stack+0x431>
    24ca:	a5 01       	movw	r20, r10
    24cc:	94 01       	movw	r18, r8
    24ce:	6f a1       	ldd	r22, Y+39	; 0x27
    24d0:	78 a5       	ldd	r23, Y+40	; 0x28
    24d2:	89 a5       	ldd	r24, Y+41	; 0x29
    24d4:	9a a5       	ldd	r25, Y+42	; 0x2a
    24d6:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    24da:	88 23       	and	r24, r24
    24dc:	0c f4       	brge	.+2      	; 0x24e0 <__stack+0x2e1>
    24de:	a8 c0       	rjmp	.+336    	; 0x2630 <__stack+0x431>
							if (!bBaseUpRampActFound){
    24e0:	e5 96       	adiw	r28, 0x35	; 53
    24e2:	4f ad       	ldd	r20, Y+63	; 0x3f
    24e4:	e5 97       	sbiw	r28, 0x35	; 53
    24e6:	41 11       	cpse	r20, r1
    24e8:	33 c0       	rjmp	.+102    	; 0x2550 <__stack+0x351>
								if (distanceTraveled < 15){
    24ea:	20 e0       	ldi	r18, 0x00	; 0
    24ec:	30 e0       	ldi	r19, 0x00	; 0
    24ee:	40 e7       	ldi	r20, 0x70	; 112
    24f0:	51 e4       	ldi	r21, 0x41	; 65
    24f2:	c5 01       	movw	r24, r10
    24f4:	b4 01       	movw	r22, r8
    24f6:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    24fa:	88 23       	and	r24, r24
    24fc:	44 f4       	brge	.+16     	; 0x250e <__stack+0x30f>
									baseUpRampActuation++;
    24fe:	a7 96       	adiw	r28, 0x27	; 39
    2500:	8f ad       	ldd	r24, Y+63	; 0x3f
    2502:	a7 97       	sbiw	r28, 0x27	; 39
    2504:	8f 5f       	subi	r24, 0xFF	; 255
    2506:	a7 96       	adiw	r28, 0x27	; 39
    2508:	8f af       	std	Y+63, r24	; 0x3f
    250a:	a7 97       	sbiw	r28, 0x27	; 39
    250c:	42 c0       	rjmp	.+132    	; 0x2592 <__stack+0x393>
								} else {
									bBaseUpRampActFound = TRUE;
									maxDriveActuation = baseUpRampActuation + 10;
    250e:	a7 96       	adiw	r28, 0x27	; 39
    2510:	9f ad       	ldd	r25, Y+63	; 0x3f
    2512:	a7 97       	sbiw	r28, 0x27	; 39
    2514:	96 5f       	subi	r25, 0xF6	; 246
    2516:	e3 96       	adiw	r28, 0x33	; 51
    2518:	9f af       	std	Y+63, r25	; 0x3f
    251a:	e3 97       	sbiw	r28, 0x33	; 51
									baseRotationSpeed = baseUpRampActuation;
									debug("bBaseUp: %i",baseUpRampActuation);
    251c:	1f 92       	push	r1
    251e:	a7 96       	adiw	r28, 0x27	; 39
    2520:	af ad       	ldd	r26, Y+63	; 0x3f
    2522:	a7 97       	sbiw	r28, 0x27	; 39
    2524:	af 93       	push	r26
    2526:	8e e1       	ldi	r24, 0x1E	; 30
    2528:	96 e0       	ldi	r25, 0x06	; 6
    252a:	9f 93       	push	r25
    252c:	8f 93       	push	r24
    252e:	0e 94 39 25 	call	0x4a72	; 0x4a72 <debug>
    2532:	0f 90       	pop	r0
    2534:	0f 90       	pop	r0
    2536:	0f 90       	pop	r0
    2538:	0f 90       	pop	r0
								if (distanceTraveled < 15){
									baseUpRampActuation++;
								} else {
									bBaseUpRampActFound = TRUE;
									maxDriveActuation = baseUpRampActuation + 10;
									baseRotationSpeed = baseUpRampActuation;
    253a:	a7 96       	adiw	r28, 0x27	; 39
    253c:	bf ad       	ldd	r27, Y+63	; 0x3f
    253e:	a7 97       	sbiw	r28, 0x27	; 39
    2540:	23 96       	adiw	r28, 0x03	; 3
    2542:	bf af       	std	Y+63, r27	; 0x3f
    2544:	23 97       	sbiw	r28, 0x03	; 3
						if (distanceTraveled >= 0 && distanceTraveled <= speedIncreaseThreshold){
							if (!bBaseUpRampActFound){
								if (distanceTraveled < 15){
									baseUpRampActuation++;
								} else {
									bBaseUpRampActFound = TRUE;
    2546:	21 e0       	ldi	r18, 0x01	; 1
    2548:	e5 96       	adiw	r28, 0x35	; 53
    254a:	2f af       	std	Y+63, r18	; 0x3f
    254c:	e5 97       	sbiw	r28, 0x35	; 53
    254e:	21 c0       	rjmp	.+66     	; 0x2592 <__stack+0x393>
									maxDriveActuation = baseUpRampActuation + 10;
									baseRotationSpeed = baseUpRampActuation;
									debug("bBaseUp: %i",baseUpRampActuation);
								}
							} else if (dLeft == 0 || dRight == 0){
    2550:	20 e0       	ldi	r18, 0x00	; 0
    2552:	30 e0       	ldi	r19, 0x00	; 0
    2554:	a9 01       	movw	r20, r18
    2556:	27 96       	adiw	r28, 0x07	; 7
    2558:	6c ad       	ldd	r22, Y+60	; 0x3c
    255a:	7d ad       	ldd	r23, Y+61	; 0x3d
    255c:	8e ad       	ldd	r24, Y+62	; 0x3e
    255e:	9f ad       	ldd	r25, Y+63	; 0x3f
    2560:	27 97       	sbiw	r28, 0x07	; 7
    2562:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2566:	88 23       	and	r24, r24
    2568:	69 f0       	breq	.+26     	; 0x2584 <__stack+0x385>
    256a:	20 e0       	ldi	r18, 0x00	; 0
    256c:	30 e0       	ldi	r19, 0x00	; 0
    256e:	a9 01       	movw	r20, r18
    2570:	2b 96       	adiw	r28, 0x0b	; 11
    2572:	6c ad       	ldd	r22, Y+60	; 0x3c
    2574:	7d ad       	ldd	r23, Y+61	; 0x3d
    2576:	8e ad       	ldd	r24, Y+62	; 0x3e
    2578:	9f ad       	ldd	r25, Y+63	; 0x3f
    257a:	2b 97       	sbiw	r28, 0x0b	; 11
    257c:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2580:	81 11       	cpse	r24, r1
    2582:	07 c0       	rjmp	.+14     	; 0x2592 <__stack+0x393>
								stuckIncrement+=2;
    2584:	2c 96       	adiw	r28, 0x0c	; 12
    2586:	4f ad       	ldd	r20, Y+63	; 0x3f
    2588:	2c 97       	sbiw	r28, 0x0c	; 12
    258a:	4e 5f       	subi	r20, 0xFE	; 254
    258c:	2c 96       	adiw	r28, 0x0c	; 12
    258e:	4f af       	std	Y+63, r20	; 0x3f
    2590:	2c 97       	sbiw	r28, 0x0c	; 12
							} else {
								//stuckIncrement = 0;
							}
							//currentDriveActuation = baseUpRampActuation + stuckIncrement;
							
							float minUpDrive = baseUpRampActuation+stuckIncrement;
    2592:	2c 96       	adiw	r28, 0x0c	; 12
    2594:	8f ad       	ldd	r24, Y+63	; 0x3f
    2596:	2c 97       	sbiw	r28, 0x0c	; 12
    2598:	68 2f       	mov	r22, r24
    259a:	70 e0       	ldi	r23, 0x00	; 0
    259c:	a7 96       	adiw	r28, 0x27	; 39
    259e:	9f ad       	ldd	r25, Y+63	; 0x3f
    25a0:	a7 97       	sbiw	r28, 0x27	; 39
    25a2:	69 0f       	add	r22, r25
    25a4:	71 1d       	adc	r23, r1
    25a6:	07 2e       	mov	r0, r23
    25a8:	00 0c       	add	r0, r0
    25aa:	88 0b       	sbc	r24, r24
    25ac:	99 0b       	sbc	r25, r25
    25ae:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    25b2:	2b 01       	movw	r4, r22
    25b4:	3c 01       	movw	r6, r24
							currentDriveActuation =	((((100-minUpDrive)/100)*(maxDriveActuation*shortDistIncRatio))*distanceTraveled/speedIncreaseThreshold) + (baseUpRampActuation+stuckIncrement);
    25b6:	9b 01       	movw	r18, r22
    25b8:	ac 01       	movw	r20, r24
    25ba:	60 e0       	ldi	r22, 0x00	; 0
    25bc:	70 e0       	ldi	r23, 0x00	; 0
    25be:	88 ec       	ldi	r24, 0xC8	; 200
    25c0:	92 e4       	ldi	r25, 0x42	; 66
    25c2:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    25c6:	20 e0       	ldi	r18, 0x00	; 0
    25c8:	30 e0       	ldi	r19, 0x00	; 0
    25ca:	48 ec       	ldi	r20, 0xC8	; 200
    25cc:	52 e4       	ldi	r21, 0x42	; 66
    25ce:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    25d2:	6b 01       	movw	r12, r22
    25d4:	7c 01       	movw	r14, r24
    25d6:	e3 96       	adiw	r28, 0x33	; 51
    25d8:	af ad       	ldd	r26, Y+63	; 0x3f
    25da:	e3 97       	sbiw	r28, 0x33	; 51
    25dc:	6a 2f       	mov	r22, r26
    25de:	70 e0       	ldi	r23, 0x00	; 0
    25e0:	80 e0       	ldi	r24, 0x00	; 0
    25e2:	90 e0       	ldi	r25, 0x00	; 0
    25e4:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    25e8:	2b a1       	ldd	r18, Y+35	; 0x23
    25ea:	6c 96       	adiw	r28, 0x1c	; 28
    25ec:	3f ad       	ldd	r19, Y+63	; 0x3f
    25ee:	6c 97       	sbiw	r28, 0x1c	; 28
    25f0:	6d 96       	adiw	r28, 0x1d	; 29
    25f2:	4f ad       	ldd	r20, Y+63	; 0x3f
    25f4:	6d 97       	sbiw	r28, 0x1d	; 29
    25f6:	6e 96       	adiw	r28, 0x1e	; 30
    25f8:	5f ad       	ldd	r21, Y+63	; 0x3f
    25fa:	6e 97       	sbiw	r28, 0x1e	; 30
    25fc:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2600:	9b 01       	movw	r18, r22
    2602:	ac 01       	movw	r20, r24
    2604:	c7 01       	movw	r24, r14
    2606:	b6 01       	movw	r22, r12
    2608:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    260c:	a5 01       	movw	r20, r10
    260e:	94 01       	movw	r18, r8
    2610:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2614:	2f a1       	ldd	r18, Y+39	; 0x27
    2616:	38 a5       	ldd	r19, Y+40	; 0x28
    2618:	49 a5       	ldd	r20, Y+41	; 0x29
    261a:	5a a5       	ldd	r21, Y+42	; 0x2a
    261c:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    2620:	a3 01       	movw	r20, r6
    2622:	92 01       	movw	r18, r4
    2624:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    2628:	0e 94 72 35 	call	0x6ae4	; 0x6ae4 <__fixunssfsi>
    262c:	16 2f       	mov	r17, r22
						stuckRotLeft = 0;
						stuckRotRight = 0;
						float distanceTraveled = distanceStart-distance;
						
						// Ramp up
						if (distanceTraveled >= 0 && distanceTraveled <= speedIncreaseThreshold){
    262e:	c2 c0       	rjmp	.+388    	; 0x27b4 <__stack+0x5b5>
							float minUpDrive = baseUpRampActuation+stuckIncrement;
							currentDriveActuation =	((((100-minUpDrive)/100)*(maxDriveActuation*shortDistIncRatio))*distanceTraveled/speedIncreaseThreshold) + (baseUpRampActuation+stuckIncrement);
						}
						
						// Ramp down
						else if (distance < speedDecreaseThreshold){
    2630:	2c 8d       	ldd	r18, Y+28	; 0x1c
    2632:	38 a1       	ldd	r19, Y+32	; 0x20
    2634:	49 a1       	ldd	r20, Y+33	; 0x21
    2636:	5a a1       	ldd	r21, Y+34	; 0x22
    2638:	6b a9       	ldd	r22, Y+51	; 0x33
    263a:	7c a9       	ldd	r23, Y+52	; 0x34
    263c:	8d a9       	ldd	r24, Y+53	; 0x35
    263e:	9e a9       	ldd	r25, Y+54	; 0x36
    2640:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    2644:	18 16       	cp	r1, r24
    2646:	0c f0       	brlt	.+2      	; 0x264a <__stack+0x44b>
    2648:	b2 c0       	rjmp	.+356    	; 0x27ae <__stack+0x5af>
							if (distance >50){
    264a:	20 e0       	ldi	r18, 0x00	; 0
    264c:	30 e0       	ldi	r19, 0x00	; 0
    264e:	48 e4       	ldi	r20, 0x48	; 72
    2650:	52 e4       	ldi	r21, 0x42	; 66
    2652:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2654:	78 a1       	ldd	r23, Y+32	; 0x20
    2656:	89 a1       	ldd	r24, Y+33	; 0x21
    2658:	9a a1       	ldd	r25, Y+34	; 0x22
    265a:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    265e:	18 16       	cp	r1, r24
    2660:	5c f5       	brge	.+86     	; 0x26b8 <__stack+0x4b9>
								if (dLeft == 0 || dRight == 0){
    2662:	20 e0       	ldi	r18, 0x00	; 0
    2664:	30 e0       	ldi	r19, 0x00	; 0
    2666:	a9 01       	movw	r20, r18
    2668:	27 96       	adiw	r28, 0x07	; 7
    266a:	6c ad       	ldd	r22, Y+60	; 0x3c
    266c:	7d ad       	ldd	r23, Y+61	; 0x3d
    266e:	8e ad       	ldd	r24, Y+62	; 0x3e
    2670:	9f ad       	ldd	r25, Y+63	; 0x3f
    2672:	27 97       	sbiw	r28, 0x07	; 7
    2674:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2678:	88 23       	and	r24, r24
    267a:	91 f0       	breq	.+36     	; 0x26a0 <__stack+0x4a1>
    267c:	20 e0       	ldi	r18, 0x00	; 0
    267e:	30 e0       	ldi	r19, 0x00	; 0
    2680:	a9 01       	movw	r20, r18
    2682:	2b 96       	adiw	r28, 0x0b	; 11
    2684:	6c ad       	ldd	r22, Y+60	; 0x3c
    2686:	7d ad       	ldd	r23, Y+61	; 0x3d
    2688:	8e ad       	ldd	r24, Y+62	; 0x3e
    268a:	9f ad       	ldd	r25, Y+63	; 0x3f
    268c:	2b 97       	sbiw	r28, 0x0b	; 11
    268e:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2692:	81 11       	cpse	r24, r1
    2694:	09 c0       	rjmp	.+18     	; 0x26a8 <__stack+0x4a9>
									stuckIncrement=2;
    2696:	b2 e0       	ldi	r27, 0x02	; 2
    2698:	2c 96       	adiw	r28, 0x0c	; 12
    269a:	bf af       	std	Y+63, r27	; 0x3f
    269c:	2c 97       	sbiw	r28, 0x0c	; 12
    269e:	04 c0       	rjmp	.+8      	; 0x26a8 <__stack+0x4a9>
    26a0:	22 e0       	ldi	r18, 0x02	; 2
    26a2:	2c 96       	adiw	r28, 0x0c	; 12
    26a4:	2f af       	std	Y+63, r18	; 0x3f
    26a6:	2c 97       	sbiw	r28, 0x0c	; 12
									} else {
									//stuckIncrement = 0;
								}
								currentDriveActuation = baseUpRampActuation + stuckIncrement;
    26a8:	2c 96       	adiw	r28, 0x0c	; 12
    26aa:	1f ad       	ldd	r17, Y+63	; 0x3f
    26ac:	2c 97       	sbiw	r28, 0x0c	; 12
    26ae:	a7 96       	adiw	r28, 0x27	; 39
    26b0:	4f ad       	ldd	r20, Y+63	; 0x3f
    26b2:	a7 97       	sbiw	r28, 0x27	; 39
    26b4:	14 0f       	add	r17, r20
    26b6:	7e c0       	rjmp	.+252    	; 0x27b4 <__stack+0x5b5>
								} else {
								if (prevDist==distance){
    26b8:	2c 8d       	ldd	r18, Y+28	; 0x1c
    26ba:	38 a1       	ldd	r19, Y+32	; 0x20
    26bc:	49 a1       	ldd	r20, Y+33	; 0x21
    26be:	5a a1       	ldd	r21, Y+34	; 0x22
    26c0:	63 96       	adiw	r28, 0x13	; 19
    26c2:	6f ad       	ldd	r22, Y+63	; 0x3f
    26c4:	63 97       	sbiw	r28, 0x13	; 19
    26c6:	64 96       	adiw	r28, 0x14	; 20
    26c8:	7f ad       	ldd	r23, Y+63	; 0x3f
    26ca:	64 97       	sbiw	r28, 0x14	; 20
    26cc:	65 96       	adiw	r28, 0x15	; 21
    26ce:	8f ad       	ldd	r24, Y+63	; 0x3f
    26d0:	65 97       	sbiw	r28, 0x15	; 21
    26d2:	66 96       	adiw	r28, 0x16	; 22
    26d4:	9f ad       	ldd	r25, Y+63	; 0x3f
    26d6:	66 97       	sbiw	r28, 0x16	; 22
    26d8:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    26dc:	81 11       	cpse	r24, r1
    26de:	0e c0       	rjmp	.+28     	; 0x26fc <__stack+0x4fd>
									stuckIncrement= baseUpRampActuation-baseDownRampActuation;
    26e0:	a7 96       	adiw	r28, 0x27	; 39
    26e2:	8f ad       	ldd	r24, Y+63	; 0x3f
    26e4:	a7 97       	sbiw	r28, 0x27	; 39
    26e6:	e4 96       	adiw	r28, 0x34	; 52
    26e8:	9f ad       	ldd	r25, Y+63	; 0x3f
    26ea:	e4 97       	sbiw	r28, 0x34	; 52
    26ec:	89 1b       	sub	r24, r25
    26ee:	2c 96       	adiw	r28, 0x0c	; 12
    26f0:	8f af       	std	Y+63, r24	; 0x3f
    26f2:	2c 97       	sbiw	r28, 0x0c	; 12
									baseDownRampActuation += 5;
    26f4:	9b 5f       	subi	r25, 0xFB	; 251
    26f6:	e4 96       	adiw	r28, 0x34	; 52
    26f8:	9f af       	std	Y+63, r25	; 0x3f
    26fa:	e4 97       	sbiw	r28, 0x34	; 52
									} else {
									//stuckIncrement = 0;
								}
								float minDownDrive = (baseDownRampActuation)+stuckIncrement;
    26fc:	2c 96       	adiw	r28, 0x0c	; 12
    26fe:	af ad       	ldd	r26, Y+63	; 0x3f
    2700:	2c 97       	sbiw	r28, 0x0c	; 12
    2702:	6a 2f       	mov	r22, r26
    2704:	70 e0       	ldi	r23, 0x00	; 0
    2706:	e4 96       	adiw	r28, 0x34	; 52
    2708:	bf ad       	ldd	r27, Y+63	; 0x3f
    270a:	e4 97       	sbiw	r28, 0x34	; 52
    270c:	6b 0f       	add	r22, r27
    270e:	71 1d       	adc	r23, r1
    2710:	07 2e       	mov	r0, r23
    2712:	00 0c       	add	r0, r0
    2714:	88 0b       	sbc	r24, r24
    2716:	99 0b       	sbc	r25, r25
    2718:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    271c:	4b 01       	movw	r8, r22
    271e:	5c 01       	movw	r10, r24
								currentDriveActuation =	((((100-minDownDrive)/100)*(maxDriveActuation*shortDistDecRatio))*(distance/speedDecreaseThreshold)) + ((baseDownRampActuation)+stuckIncrement);
    2720:	9b 01       	movw	r18, r22
    2722:	ac 01       	movw	r20, r24
    2724:	60 e0       	ldi	r22, 0x00	; 0
    2726:	70 e0       	ldi	r23, 0x00	; 0
    2728:	88 ec       	ldi	r24, 0xC8	; 200
    272a:	92 e4       	ldi	r25, 0x42	; 66
    272c:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    2730:	20 e0       	ldi	r18, 0x00	; 0
    2732:	30 e0       	ldi	r19, 0x00	; 0
    2734:	48 ec       	ldi	r20, 0xC8	; 200
    2736:	52 e4       	ldi	r21, 0x42	; 66
    2738:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    273c:	6b 01       	movw	r12, r22
    273e:	7c 01       	movw	r14, r24
    2740:	e3 96       	adiw	r28, 0x33	; 51
    2742:	2f ad       	ldd	r18, Y+63	; 0x3f
    2744:	e3 97       	sbiw	r28, 0x33	; 51
    2746:	62 2f       	mov	r22, r18
    2748:	70 e0       	ldi	r23, 0x00	; 0
    274a:	80 e0       	ldi	r24, 0x00	; 0
    274c:	90 e0       	ldi	r25, 0x00	; 0
    274e:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    2752:	6f 96       	adiw	r28, 0x1f	; 31
    2754:	2f ad       	ldd	r18, Y+63	; 0x3f
    2756:	6f 97       	sbiw	r28, 0x1f	; 31
    2758:	a0 96       	adiw	r28, 0x20	; 32
    275a:	3f ad       	ldd	r19, Y+63	; 0x3f
    275c:	a0 97       	sbiw	r28, 0x20	; 32
    275e:	a1 96       	adiw	r28, 0x21	; 33
    2760:	4f ad       	ldd	r20, Y+63	; 0x3f
    2762:	a1 97       	sbiw	r28, 0x21	; 33
    2764:	a2 96       	adiw	r28, 0x22	; 34
    2766:	5f ad       	ldd	r21, Y+63	; 0x3f
    2768:	a2 97       	sbiw	r28, 0x22	; 34
    276a:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    276e:	9b 01       	movw	r18, r22
    2770:	ac 01       	movw	r20, r24
    2772:	c7 01       	movw	r24, r14
    2774:	b6 01       	movw	r22, r12
    2776:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    277a:	6b 01       	movw	r12, r22
    277c:	7c 01       	movw	r14, r24
    277e:	2b a9       	ldd	r18, Y+51	; 0x33
    2780:	3c a9       	ldd	r19, Y+52	; 0x34
    2782:	4d a9       	ldd	r20, Y+53	; 0x35
    2784:	5e a9       	ldd	r21, Y+54	; 0x36
    2786:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2788:	78 a1       	ldd	r23, Y+32	; 0x20
    278a:	89 a1       	ldd	r24, Y+33	; 0x21
    278c:	9a a1       	ldd	r25, Y+34	; 0x22
    278e:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    2792:	9b 01       	movw	r18, r22
    2794:	ac 01       	movw	r20, r24
    2796:	c7 01       	movw	r24, r14
    2798:	b6 01       	movw	r22, r12
    279a:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    279e:	a5 01       	movw	r20, r10
    27a0:	94 01       	movw	r18, r8
    27a2:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    27a6:	0e 94 72 35 	call	0x6ae4	; 0x6ae4 <__fixunssfsi>
    27aa:	16 2f       	mov	r17, r22
    27ac:	03 c0       	rjmp	.+6      	; 0x27b4 <__stack+0x5b5>
							}
							} else	{
							currentDriveActuation = maxDriveActuation;
    27ae:	e3 96       	adiw	r28, 0x33	; 51
    27b0:	1f ad       	ldd	r17, Y+63	; 0x3f
    27b2:	e3 97       	sbiw	r28, 0x33	; 51
							//currentDriveActuation = baseUpRampActuation;
						}
						
						if (thetaDiff >= 0){//Moving left
    27b4:	8a 84       	ldd	r8, Y+10	; 0x0a
    27b6:	9b 84       	ldd	r9, Y+11	; 0x0b
    27b8:	ac 84       	ldd	r10, Y+12	; 0x0c
    27ba:	bd 84       	ldd	r11, Y+13	; 0x0d
    27bc:	20 e0       	ldi	r18, 0x00	; 0
    27be:	30 e0       	ldi	r19, 0x00	; 0
    27c0:	a9 01       	movw	r20, r18
    27c2:	c5 01       	movw	r24, r10
    27c4:	b4 01       	movw	r22, r8
    27c6:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    27ca:	88 23       	and	r24, r24
    27cc:	0c f4       	brge	.+2      	; 0x27d0 <__stack+0x5d1>
    27ce:	54 c0       	rjmp	.+168    	; 0x2878 <__stack+0x679>
							LSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*leftIntError; //Simple PI controller for theta
    27d0:	01 2f       	mov	r16, r17
    27d2:	10 e0       	ldi	r17, 0x00	; 0
    27d4:	b8 01       	movw	r22, r16
    27d6:	01 2e       	mov	r0, r17
    27d8:	00 0c       	add	r0, r0
    27da:	88 0b       	sbc	r24, r24
    27dc:	99 0b       	sbc	r25, r25
    27de:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    27e2:	6b 01       	movw	r12, r22
    27e4:	7c 01       	movw	r14, r24
    27e6:	c5 01       	movw	r24, r10
    27e8:	b4 01       	movw	r22, r8
    27ea:	9f 77       	andi	r25, 0x7F	; 127
    27ec:	20 e0       	ldi	r18, 0x00	; 0
    27ee:	30 e0       	ldi	r19, 0x00	; 0
    27f0:	46 e1       	ldi	r20, 0x16	; 22
    27f2:	54 e4       	ldi	r21, 0x44	; 68
    27f4:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    27f8:	9b 01       	movw	r18, r22
    27fa:	ac 01       	movw	r20, r24
    27fc:	c7 01       	movw	r24, r14
    27fe:	b6 01       	movw	r22, r12
    2800:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    2804:	6b 01       	movw	r12, r22
    2806:	7c 01       	movw	r14, r24
    2808:	20 e0       	ldi	r18, 0x00	; 0
    280a:	30 e0       	ldi	r19, 0x00	; 0
    280c:	40 e2       	ldi	r20, 0x20	; 32
    280e:	51 e4       	ldi	r21, 0x41	; 65
    2810:	61 96       	adiw	r28, 0x11	; 17
    2812:	6c ad       	ldd	r22, Y+60	; 0x3c
    2814:	7d ad       	ldd	r23, Y+61	; 0x3d
    2816:	8e ad       	ldd	r24, Y+62	; 0x3e
    2818:	9f ad       	ldd	r25, Y+63	; 0x3f
    281a:	61 97       	sbiw	r28, 0x11	; 17
    281c:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2820:	9b 01       	movw	r18, r22
    2822:	ac 01       	movw	r20, r24
    2824:	c7 01       	movw	r24, r14
    2826:	b6 01       	movw	r22, r12
    2828:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    282c:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    2830:	7f 87       	std	Y+15, r23	; 0x0f
    2832:	6e 87       	std	Y+14, r22	; 0x0e
							
							//Saturation
							if (LSpeed > currentDriveActuation){
    2834:	8e 85       	ldd	r24, Y+14	; 0x0e
    2836:	9f 85       	ldd	r25, Y+15	; 0x0f
    2838:	08 17       	cp	r16, r24
    283a:	19 07       	cpc	r17, r25
    283c:	1c f4       	brge	.+6      	; 0x2844 <__stack+0x645>
								LSpeed = currentDriveActuation;
    283e:	1f 87       	std	Y+15, r17	; 0x0f
    2840:	0e 87       	std	Y+14, r16	; 0x0e
    2842:	06 c0       	rjmp	.+12     	; 0x2850 <__stack+0x651>
							}else if(LSpeed < 0){
    2844:	8e 85       	ldd	r24, Y+14	; 0x0e
    2846:	9f 85       	ldd	r25, Y+15	; 0x0f
    2848:	99 23       	and	r25, r25
    284a:	14 f4       	brge	.+4      	; 0x2850 <__stack+0x651>
								LSpeed = 0;
    284c:	1f 86       	std	Y+15, r1	; 0x0f
    284e:	1e 86       	std	Y+14, r1	; 0x0e
							}
							RSpeed = currentDriveActuation;
    2850:	19 8b       	std	Y+17, r17	; 0x11
    2852:	08 8b       	std	Y+16, r16	; 0x10
							if (dLeft == 0){
    2854:	20 e0       	ldi	r18, 0x00	; 0
    2856:	30 e0       	ldi	r19, 0x00	; 0
    2858:	a9 01       	movw	r20, r18
    285a:	27 96       	adiw	r28, 0x07	; 7
    285c:	6c ad       	ldd	r22, Y+60	; 0x3c
    285e:	7d ad       	ldd	r23, Y+61	; 0x3d
    2860:	8e ad       	ldd	r24, Y+62	; 0x3e
    2862:	9f ad       	ldd	r25, Y+63	; 0x3f
    2864:	27 97       	sbiw	r28, 0x07	; 7
    2866:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    286a:	81 11       	cpse	r24, r1
    286c:	58 c0       	rjmp	.+176    	; 0x291e <__stack+0x71f>
								RSpeed = currentDriveActuation + 15;
    286e:	01 5f       	subi	r16, 0xF1	; 241
    2870:	1f 4f       	sbci	r17, 0xFF	; 255
    2872:	19 8b       	std	Y+17, r17	; 0x11
    2874:	08 8b       	std	Y+16, r16	; 0x10
    2876:	53 c0       	rjmp	.+166    	; 0x291e <__stack+0x71f>
							}
							
						}else{//Moving right
							RSpeed = currentDriveActuation - driveKp*fabs(thetaDiff) - driveKi*rightIntError; //Simple PI controller for theta
    2878:	01 2f       	mov	r16, r17
    287a:	10 e0       	ldi	r17, 0x00	; 0
    287c:	b8 01       	movw	r22, r16
    287e:	01 2e       	mov	r0, r17
    2880:	00 0c       	add	r0, r0
    2882:	88 0b       	sbc	r24, r24
    2884:	99 0b       	sbc	r25, r25
    2886:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    288a:	6b 01       	movw	r12, r22
    288c:	7c 01       	movw	r14, r24
    288e:	c5 01       	movw	r24, r10
    2890:	b4 01       	movw	r22, r8
    2892:	9f 77       	andi	r25, 0x7F	; 127
    2894:	20 e0       	ldi	r18, 0x00	; 0
    2896:	30 e0       	ldi	r19, 0x00	; 0
    2898:	46 e1       	ldi	r20, 0x16	; 22
    289a:	54 e4       	ldi	r21, 0x44	; 68
    289c:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    28a0:	9b 01       	movw	r18, r22
    28a2:	ac 01       	movw	r20, r24
    28a4:	c7 01       	movw	r24, r14
    28a6:	b6 01       	movw	r22, r12
    28a8:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    28ac:	6b 01       	movw	r12, r22
    28ae:	7c 01       	movw	r14, r24
    28b0:	20 e0       	ldi	r18, 0x00	; 0
    28b2:	30 e0       	ldi	r19, 0x00	; 0
    28b4:	40 e2       	ldi	r20, 0x20	; 32
    28b6:	51 e4       	ldi	r21, 0x41	; 65
    28b8:	6a 96       	adiw	r28, 0x1a	; 26
    28ba:	6c ad       	ldd	r22, Y+60	; 0x3c
    28bc:	7d ad       	ldd	r23, Y+61	; 0x3d
    28be:	8e ad       	ldd	r24, Y+62	; 0x3e
    28c0:	9f ad       	ldd	r25, Y+63	; 0x3f
    28c2:	6a 97       	sbiw	r28, 0x1a	; 26
    28c4:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    28c8:	9b 01       	movw	r18, r22
    28ca:	ac 01       	movw	r20, r24
    28cc:	c7 01       	movw	r24, r14
    28ce:	b6 01       	movw	r22, r12
    28d0:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    28d4:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    28d8:	79 8b       	std	Y+17, r23	; 0x11
    28da:	68 8b       	std	Y+16, r22	; 0x10
							
							//Saturation
							if (RSpeed > currentDriveActuation){
    28dc:	88 89       	ldd	r24, Y+16	; 0x10
    28de:	99 89       	ldd	r25, Y+17	; 0x11
    28e0:	08 17       	cp	r16, r24
    28e2:	19 07       	cpc	r17, r25
    28e4:	1c f4       	brge	.+6      	; 0x28ec <__stack+0x6ed>
								RSpeed = currentDriveActuation;
    28e6:	19 8b       	std	Y+17, r17	; 0x11
    28e8:	08 8b       	std	Y+16, r16	; 0x10
    28ea:	06 c0       	rjmp	.+12     	; 0x28f8 <__stack+0x6f9>
							}else if(RSpeed < 0){
    28ec:	88 89       	ldd	r24, Y+16	; 0x10
    28ee:	99 89       	ldd	r25, Y+17	; 0x11
    28f0:	99 23       	and	r25, r25
    28f2:	14 f4       	brge	.+4      	; 0x28f8 <__stack+0x6f9>
								RSpeed = 0;
    28f4:	19 8a       	std	Y+17, r1	; 0x11
    28f6:	18 8a       	std	Y+16, r1	; 0x10
							}
							LSpeed = currentDriveActuation;
    28f8:	1f 87       	std	Y+15, r17	; 0x0f
    28fa:	0e 87       	std	Y+14, r16	; 0x0e
							if (dRight == 0){
    28fc:	20 e0       	ldi	r18, 0x00	; 0
    28fe:	30 e0       	ldi	r19, 0x00	; 0
    2900:	a9 01       	movw	r20, r18
    2902:	2b 96       	adiw	r28, 0x0b	; 11
    2904:	6c ad       	ldd	r22, Y+60	; 0x3c
    2906:	7d ad       	ldd	r23, Y+61	; 0x3d
    2908:	8e ad       	ldd	r24, Y+62	; 0x3e
    290a:	9f ad       	ldd	r25, Y+63	; 0x3f
    290c:	2b 97       	sbiw	r28, 0x0b	; 11
    290e:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2912:	81 11       	cpse	r24, r1
    2914:	04 c0       	rjmp	.+8      	; 0x291e <__stack+0x71f>
								LSpeed = currentDriveActuation + 15;
    2916:	01 5f       	subi	r16, 0xF1	; 241
    2918:	1f 4f       	sbci	r17, 0xFF	; 255
    291a:	1f 87       	std	Y+15, r17	; 0x0f
    291c:	0e 87       	std	Y+14, r16	; 0x0e
							}
						}
						
						leftIntError += thetaDiff;
    291e:	ca 84       	ldd	r12, Y+10	; 0x0a
    2920:	db 84       	ldd	r13, Y+11	; 0x0b
    2922:	ec 84       	ldd	r14, Y+12	; 0x0c
    2924:	fd 84       	ldd	r15, Y+13	; 0x0d
    2926:	a7 01       	movw	r20, r14
    2928:	96 01       	movw	r18, r12
    292a:	61 96       	adiw	r28, 0x11	; 17
    292c:	6c ad       	ldd	r22, Y+60	; 0x3c
    292e:	7d ad       	ldd	r23, Y+61	; 0x3d
    2930:	8e ad       	ldd	r24, Y+62	; 0x3e
    2932:	9f ad       	ldd	r25, Y+63	; 0x3f
    2934:	61 97       	sbiw	r28, 0x11	; 17
    2936:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    293a:	61 96       	adiw	r28, 0x11	; 17
    293c:	6c af       	std	Y+60, r22	; 0x3c
    293e:	7d af       	std	Y+61, r23	; 0x3d
    2940:	8e af       	std	Y+62, r24	; 0x3e
    2942:	9f af       	std	Y+63, r25	; 0x3f
    2944:	61 97       	sbiw	r28, 0x11	; 17
						rightIntError -= thetaDiff;
    2946:	a7 01       	movw	r20, r14
    2948:	96 01       	movw	r18, r12
    294a:	6a 96       	adiw	r28, 0x1a	; 26
    294c:	6c ad       	ldd	r22, Y+60	; 0x3c
    294e:	7d ad       	ldd	r23, Y+61	; 0x3d
    2950:	8e ad       	ldd	r24, Y+62	; 0x3e
    2952:	9f ad       	ldd	r25, Y+63	; 0x3f
    2954:	6a 97       	sbiw	r28, 0x1a	; 26
    2956:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    295a:	6a 96       	adiw	r28, 0x1a	; 26
    295c:	6c af       	std	Y+60, r22	; 0x3c
    295e:	7d af       	std	Y+61, r23	; 0x3d
    2960:	8e af       	std	Y+62, r24	; 0x3e
    2962:	9f af       	std	Y+63, r25	; 0x3f
    2964:	6a 97       	sbiw	r28, 0x1a	; 26
						
						
						gRightWheelDirection = motorRightForward;
    2966:	86 e0       	ldi	r24, 0x06	; 6
    2968:	8f 8b       	std	Y+23, r24	; 0x17
						gLeftWheelDirection = motorLeftForward;
    296a:	84 e0       	ldi	r24, 0x04	; 4
    296c:	8e 8b       	std	Y+22, r24	; 0x16
						lastMovement = moveForward;
    296e:	81 e0       	ldi	r24, 0x01	; 1
    2970:	89 87       	std	Y+9, r24	; 0x09
					idleSendt = FALSE;
				
					if (doneTurning){//Start forward movement
						//debug("Done Turning");
						stuckRotLeft = 0;
						stuckRotRight = 0;
    2972:	19 ae       	std	Y+57, r1	; 0x39
				
					idleSendt = FALSE;
				
					if (doneTurning){//Start forward movement
						//debug("Done Turning");
						stuckRotLeft = 0;
    2974:	18 ae       	std	Y+56, r1	; 0x38
    2976:	57 c2       	rjmp	.+1198   	; 0x2e26 <__stack+0xc27>
			
					}else{ //Turn within 1 degree of target
						
						// Make sure to reset stuck variables if we have gone past target:
						
						if (thetaDiff >= 0){//Rotating left
    2978:	8a 84       	ldd	r8, Y+10	; 0x0a
    297a:	9b 84       	ldd	r9, Y+11	; 0x0b
    297c:	ac 84       	ldd	r10, Y+12	; 0x0c
    297e:	bd 84       	ldd	r11, Y+13	; 0x0d
    2980:	20 e0       	ldi	r18, 0x00	; 0
    2982:	30 e0       	ldi	r19, 0x00	; 0
    2984:	a9 01       	movw	r20, r18
    2986:	c5 01       	movw	r24, r10
    2988:	b4 01       	movw	r22, r8
    298a:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    298e:	88 23       	and	r24, r24
    2990:	34 f0       	brlt	.+12     	; 0x299e <__stack+0x79f>
							if (lastMovement==moveClockwise){
    2992:	89 85       	ldd	r24, Y+9	; 0x09
    2994:	83 30       	cpi	r24, 0x03	; 3
    2996:	41 f4       	brne	.+16     	; 0x29a8 <__stack+0x7a9>
								stuckRotLeft = 0;
								stuckRotRight = 0;
    2998:	19 ae       	std	Y+57, r1	; 0x39
						
						// Make sure to reset stuck variables if we have gone past target:
						
						if (thetaDiff >= 0){//Rotating left
							if (lastMovement==moveClockwise){
								stuckRotLeft = 0;
    299a:	18 ae       	std	Y+56, r1	; 0x38
    299c:	05 c0       	rjmp	.+10     	; 0x29a8 <__stack+0x7a9>
								stuckRotRight = 0;
							}
						}else{//Rotating right
							if (lastMovement==moveCounterClockwise){
    299e:	89 85       	ldd	r24, Y+9	; 0x09
    29a0:	84 30       	cpi	r24, 0x04	; 4
    29a2:	11 f4       	brne	.+4      	; 0x29a8 <__stack+0x7a9>
								stuckRotLeft = 0;
								stuckRotRight = 0;
    29a4:	19 ae       	std	Y+57, r1	; 0x39
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}else{//Rotating right
							if (lastMovement==moveCounterClockwise){
								stuckRotLeft = 0;
    29a6:	18 ae       	std	Y+56, r1	; 0x38
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
						thetaTraveled = StartDiff - fabs(thetaDiff);
    29a8:	a5 01       	movw	r20, r10
    29aa:	94 01       	movw	r18, r8
    29ac:	5f 77       	andi	r21, 0x7F	; 127
    29ae:	c7 01       	movw	r24, r14
    29b0:	b6 01       	movw	r22, r12
    29b2:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    29b6:	6b 01       	movw	r12, r22
    29b8:	7c 01       	movw	r14, r24
						if (!bBaseRotationSpeed ){
    29ba:	a9 96       	adiw	r28, 0x29	; 41
    29bc:	4f ad       	ldd	r20, Y+63	; 0x3f
    29be:	a9 97       	sbiw	r28, 0x29	; 41
    29c0:	41 11       	cpse	r20, r1
    29c2:	28 c0       	rjmp	.+80     	; 0x2a14 <__stack+0x815>
							if ((thetaTraveled <= rotateThreshold/2) || bStuck) {
    29c4:	29 e1       	ldi	r18, 0x19	; 25
    29c6:	34 e0       	ldi	r19, 0x04	; 4
    29c8:	46 e8       	ldi	r20, 0x86	; 134
    29ca:	5e e3       	ldi	r21, 0x3E	; 62
    29cc:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    29d0:	18 16       	cp	r1, r24
    29d2:	2c f4       	brge	.+10     	; 0x29de <__stack+0x7df>
    29d4:	aa 96       	adiw	r28, 0x2a	; 42
    29d6:	8f ad       	ldd	r24, Y+63	; 0x3f
    29d8:	aa 97       	sbiw	r28, 0x2a	; 42
    29da:	88 23       	and	r24, r24
    29dc:	41 f0       	breq	.+16     	; 0x29ee <__stack+0x7ef>
								baseRotationSpeed++;
    29de:	23 96       	adiw	r28, 0x03	; 3
    29e0:	9f ad       	ldd	r25, Y+63	; 0x3f
    29e2:	23 97       	sbiw	r28, 0x03	; 3
    29e4:	9f 5f       	subi	r25, 0xFF	; 255
    29e6:	23 96       	adiw	r28, 0x03	; 3
    29e8:	9f af       	std	Y+63, r25	; 0x3f
    29ea:	23 97       	sbiw	r28, 0x03	; 3
    29ec:	13 c0       	rjmp	.+38     	; 0x2a14 <__stack+0x815>
							} else {
								bBaseRotationSpeed = TRUE;
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
    29ee:	1f 92       	push	r1
    29f0:	23 96       	adiw	r28, 0x03	; 3
    29f2:	af ad       	ldd	r26, Y+63	; 0x3f
    29f4:	23 97       	sbiw	r28, 0x03	; 3
    29f6:	af 93       	push	r26
    29f8:	89 e4       	ldi	r24, 0x49	; 73
    29fa:	96 e0       	ldi	r25, 0x06	; 6
    29fc:	9f 93       	push	r25
    29fe:	8f 93       	push	r24
    2a00:	0e 94 39 25 	call	0x4a72	; 0x4a72 <debug>
    2a04:	0f 90       	pop	r0
    2a06:	0f 90       	pop	r0
    2a08:	0f 90       	pop	r0
    2a0a:	0f 90       	pop	r0
						thetaTraveled = StartDiff - fabs(thetaDiff);
						if (!bBaseRotationSpeed ){
							if ((thetaTraveled <= rotateThreshold/2) || bStuck) {
								baseRotationSpeed++;
							} else {
								bBaseRotationSpeed = TRUE;
    2a0c:	b1 e0       	ldi	r27, 0x01	; 1
    2a0e:	a9 96       	adiw	r28, 0x29	; 41
    2a10:	bf af       	std	Y+63, r27	; 0x3f
    2a12:	a9 97       	sbiw	r28, 0x29	; 41
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
    2a14:	2d 96       	adiw	r28, 0x0d	; 13
    2a16:	2f ad       	ldd	r18, Y+63	; 0x3f
    2a18:	2d 97       	sbiw	r28, 0x0d	; 13
    2a1a:	21 11       	cpse	r18, r1
    2a1c:	0e c0       	rjmp	.+28     	; 0x2a3a <__stack+0x83b>
    2a1e:	20 e0       	ldi	r18, 0x00	; 0
    2a20:	30 e0       	ldi	r19, 0x00	; 0
    2a22:	a9 01       	movw	r20, r18
    2a24:	27 96       	adiw	r28, 0x07	; 7
    2a26:	6c ad       	ldd	r22, Y+60	; 0x3c
    2a28:	7d ad       	ldd	r23, Y+61	; 0x3d
    2a2a:	8e ad       	ldd	r24, Y+62	; 0x3e
    2a2c:	9f ad       	ldd	r25, Y+63	; 0x3f
    2a2e:	27 97       	sbiw	r28, 0x07	; 7
    2a30:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2a34:	88 23       	and	r24, r24
    2a36:	b9 f0       	breq	.+46     	; 0x2a66 <__stack+0x867>
    2a38:	58 c2       	rjmp	.+1200   	; 0x2eea <__stack+0xceb>
    2a3a:	20 e0       	ldi	r18, 0x00	; 0
    2a3c:	30 e0       	ldi	r19, 0x00	; 0
    2a3e:	a9 01       	movw	r20, r18
    2a40:	2b 96       	adiw	r28, 0x0b	; 11
    2a42:	6c ad       	ldd	r22, Y+60	; 0x3c
    2a44:	7d ad       	ldd	r23, Y+61	; 0x3d
    2a46:	8e ad       	ldd	r24, Y+62	; 0x3e
    2a48:	9f ad       	ldd	r25, Y+63	; 0x3f
    2a4a:	2b 97       	sbiw	r28, 0x0b	; 11
    2a4c:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2a50:	81 11       	cpse	r24, r1
    2a52:	3f c0       	rjmp	.+126    	; 0x2ad2 <__stack+0x8d3>
    2a54:	a9 96       	adiw	r28, 0x29	; 41
    2a56:	4f ad       	ldd	r20, Y+63	; 0x3f
    2a58:	a9 97       	sbiw	r28, 0x29	; 41
    2a5a:	41 11       	cpse	r20, r1
    2a5c:	57 c2       	rjmp	.+1198   	; 0x2f0c <__stack+0xd0d>
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
							}
						} else {
							//stuckRotInc = 0;
							bStuck = FALSE;
    2a5e:	aa 96       	adiw	r28, 0x2a	; 42
    2a60:	1f ae       	std	Y+63, r1	; 0x3f
    2a62:	aa 97       	sbiw	r28, 0x2a	; 42
    2a64:	39 c0       	rjmp	.+114    	; 0x2ad8 <__stack+0x8d9>
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
							if (dLeft == 0){
								stuckRotLeft++;
    2a66:	88 ad       	ldd	r24, Y+56	; 0x38
    2a68:	8f 5f       	subi	r24, 0xFF	; 255
    2a6a:	88 af       	std	Y+56, r24	; 0x38
							}
							if (dRight == 0){
    2a6c:	20 e0       	ldi	r18, 0x00	; 0
    2a6e:	30 e0       	ldi	r19, 0x00	; 0
    2a70:	a9 01       	movw	r20, r18
    2a72:	2b 96       	adiw	r28, 0x0b	; 11
    2a74:	6c ad       	ldd	r22, Y+60	; 0x3c
    2a76:	7d ad       	ldd	r23, Y+61	; 0x3d
    2a78:	8e ad       	ldd	r24, Y+62	; 0x3e
    2a7a:	9f ad       	ldd	r25, Y+63	; 0x3f
    2a7c:	2b 97       	sbiw	r28, 0x0b	; 11
    2a7e:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2a82:	81 11       	cpse	r24, r1
    2a84:	03 c0       	rjmp	.+6      	; 0x2a8c <__stack+0x88d>
								stuckRotRight++;
    2a86:	99 ad       	ldd	r25, Y+57	; 0x39
    2a88:	9f 5f       	subi	r25, 0xFF	; 255
    2a8a:	99 af       	std	Y+57, r25	; 0x39
							}
							//debug("#stuck: %i",stuckRotInc);
							if (stuckRotLeft > 10 || stuckRotRight > 10){
    2a8c:	a8 ad       	ldd	r26, Y+56	; 0x38
    2a8e:	ab 30       	cpi	r26, 0x0B	; 11
    2a90:	18 f4       	brcc	.+6      	; 0x2a98 <__stack+0x899>
    2a92:	b9 ad       	ldd	r27, Y+57	; 0x39
    2a94:	bb 30       	cpi	r27, 0x0B	; 11
    2a96:	00 f1       	brcs	.+64     	; 0x2ad8 <__stack+0x8d9>
								bBaseRotationSpeed = FALSE;
								bStuck = TRUE;
								baseRotationSpeed += 10;
    2a98:	23 96       	adiw	r28, 0x03	; 3
    2a9a:	2f ad       	ldd	r18, Y+63	; 0x3f
    2a9c:	23 97       	sbiw	r28, 0x03	; 3
    2a9e:	26 5f       	subi	r18, 0xF6	; 246
    2aa0:	23 96       	adiw	r28, 0x03	; 3
    2aa2:	2f af       	std	Y+63, r18	; 0x3f
    2aa4:	23 97       	sbiw	r28, 0x03	; 3
								stuckRotLeft = 0;
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
    2aa6:	1f 92       	push	r1
    2aa8:	2f 93       	push	r18
    2aaa:	8a e2       	ldi	r24, 0x2A	; 42
    2aac:	96 e0       	ldi	r25, 0x06	; 6
    2aae:	9f 93       	push	r25
    2ab0:	8f 93       	push	r24
    2ab2:	0e 94 39 25 	call	0x4a72	; 0x4a72 <debug>
    2ab6:	0f 90       	pop	r0
    2ab8:	0f 90       	pop	r0
    2aba:	0f 90       	pop	r0
    2abc:	0f 90       	pop	r0
								stuckRotRight++;
							}
							//debug("#stuck: %i",stuckRotInc);
							if (stuckRotLeft > 10 || stuckRotRight > 10){
								bBaseRotationSpeed = FALSE;
								bStuck = TRUE;
    2abe:	b1 e0       	ldi	r27, 0x01	; 1
    2ac0:	aa 96       	adiw	r28, 0x2a	; 42
    2ac2:	bf af       	std	Y+63, r27	; 0x3f
    2ac4:	aa 97       	sbiw	r28, 0x2a	; 42
							if (dRight == 0){
								stuckRotRight++;
							}
							//debug("#stuck: %i",stuckRotInc);
							if (stuckRotLeft > 10 || stuckRotRight > 10){
								bBaseRotationSpeed = FALSE;
    2ac6:	a9 96       	adiw	r28, 0x29	; 41
    2ac8:	1f ae       	std	Y+63, r1	; 0x3f
    2aca:	a9 97       	sbiw	r28, 0x29	; 41
								bStuck = TRUE;
								baseRotationSpeed += 10;
								stuckRotLeft = 0;
								stuckRotRight = 0;
    2acc:	19 ae       	std	Y+57, r1	; 0x39
							//debug("#stuck: %i",stuckRotInc);
							if (stuckRotLeft > 10 || stuckRotRight > 10){
								bBaseRotationSpeed = FALSE;
								bStuck = TRUE;
								baseRotationSpeed += 10;
								stuckRotLeft = 0;
    2ace:	18 ae       	std	Y+56, r1	; 0x38
    2ad0:	03 c0       	rjmp	.+6      	; 0x2ad8 <__stack+0x8d9>
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
							}
						} else {
							//stuckRotInc = 0;
							bStuck = FALSE;
    2ad2:	aa 96       	adiw	r28, 0x2a	; 42
    2ad4:	1f ae       	std	Y+63, r1	; 0x3f
    2ad6:	aa 97       	sbiw	r28, 0x2a	; 42
							//debug("stuck = 0");
						}
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
    2ad8:	2d 96       	adiw	r28, 0x0d	; 13
    2ada:	2f ad       	ldd	r18, Y+63	; 0x3f
    2adc:	2d 97       	sbiw	r28, 0x0d	; 13
    2ade:	21 30       	cpi	r18, 0x01	; 1
    2ae0:	a9 f4       	brne	.+42     	; 0x2b0c <__stack+0x90d>
    2ae2:	23 96       	adiw	r28, 0x03	; 3
    2ae4:	4f ad       	ldd	r20, Y+63	; 0x3f
    2ae6:	23 97       	sbiw	r28, 0x03	; 3
    2ae8:	45 36       	cpi	r20, 0x65	; 101
    2aea:	80 f0       	brcs	.+32     	; 0x2b0c <__stack+0x90d>
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
    2aec:	1f 92       	push	r1
    2aee:	4f 93       	push	r20
    2af0:	8e e3       	ldi	r24, 0x3E	; 62
    2af2:	96 e0       	ldi	r25, 0x06	; 6
    2af4:	9f 93       	push	r25
    2af6:	8f 93       	push	r24
    2af8:	0e 94 39 25 	call	0x4a72	; 0x4a72 <debug>
    2afc:	0f 90       	pop	r0
    2afe:	0f 90       	pop	r0
    2b00:	0f 90       	pop	r0
    2b02:	0f 90       	pop	r0
							baseRotationSpeed = 70;
    2b04:	b6 e4       	ldi	r27, 0x46	; 70
    2b06:	23 96       	adiw	r28, 0x03	; 3
    2b08:	bf af       	std	Y+63, r27	; 0x3f
    2b0a:	23 97       	sbiw	r28, 0x03	; 3
						}
						newOrder = FALSE;
						if (thetaTraveled < (0.25 * StartDiff)) {
    2b0c:	20 e0       	ldi	r18, 0x00	; 0
    2b0e:	30 e0       	ldi	r19, 0x00	; 0
    2b10:	40 e8       	ldi	r20, 0x80	; 128
    2b12:	5e e3       	ldi	r21, 0x3E	; 62
    2b14:	68 8d       	ldd	r22, Y+24	; 0x18
    2b16:	79 8d       	ldd	r23, Y+25	; 0x19
    2b18:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2b1a:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2b1c:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2b20:	9b 01       	movw	r18, r22
    2b22:	ac 01       	movw	r20, r24
    2b24:	c7 01       	movw	r24, r14
    2b26:	b6 01       	movw	r22, r12
    2b28:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2b2c:	88 23       	and	r24, r24
    2b2e:	0c f0       	brlt	.+2      	; 0x2b32 <__stack+0x933>
    2b30:	cd c0       	rjmp	.+410    	; 0x2ccc <__stack+0xacd>
							if (!bBaseRotationSpeed){
    2b32:	a9 96       	adiw	r28, 0x29	; 41
    2b34:	2f ad       	ldd	r18, Y+63	; 0x3f
    2b36:	a9 97       	sbiw	r28, 0x29	; 41
    2b38:	21 11       	cpse	r18, r1
    2b3a:	63 c0       	rjmp	.+198    	; 0x2c02 <__stack+0xa03>
								if (thetaDiff >= 0){//Rotating left
    2b3c:	20 e0       	ldi	r18, 0x00	; 0
    2b3e:	30 e0       	ldi	r19, 0x00	; 0
    2b40:	a9 01       	movw	r20, r18
    2b42:	6a 85       	ldd	r22, Y+10	; 0x0a
    2b44:	7b 85       	ldd	r23, Y+11	; 0x0b
    2b46:	8c 85       	ldd	r24, Y+12	; 0x0c
    2b48:	9d 85       	ldd	r25, Y+13	; 0x0d
    2b4a:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    2b4e:	88 23       	and	r24, r24
    2b50:	64 f1       	brlt	.+88     	; 0x2baa <__stack+0x9ab>
									LSpeed = -(baseRotationSpeed + stuckRotLeft);
    2b52:	23 96       	adiw	r28, 0x03	; 3
    2b54:	4f ad       	ldd	r20, Y+63	; 0x3f
    2b56:	23 97       	sbiw	r28, 0x03	; 3
    2b58:	84 2f       	mov	r24, r20
    2b5a:	90 e0       	ldi	r25, 0x00	; 0
    2b5c:	9c 01       	movw	r18, r24
    2b5e:	a8 ad       	ldd	r26, Y+56	; 0x38
    2b60:	2a 0f       	add	r18, r26
    2b62:	31 1d       	adc	r19, r1
    2b64:	31 95       	neg	r19
    2b66:	21 95       	neg	r18
    2b68:	31 09       	sbc	r19, r1
    2b6a:	3f 87       	std	Y+15, r19	; 0x0f
    2b6c:	2e 87       	std	Y+14, r18	; 0x0e
									gLeftWheelDirection = motorLeftBackward;
    2b6e:	25 e0       	ldi	r18, 0x05	; 5
    2b70:	2e 8b       	std	Y+22, r18	; 0x16
									RSpeed = (baseRotationSpeed + stuckRotRight);
    2b72:	b9 ad       	ldd	r27, Y+57	; 0x39
    2b74:	8b 0f       	add	r24, r27
    2b76:	91 1d       	adc	r25, r1
    2b78:	99 8b       	std	Y+17, r25	; 0x11
    2b7a:	88 8b       	std	Y+16, r24	; 0x10
									gRightWheelDirection = motorRightForward;
    2b7c:	86 e0       	ldi	r24, 0x06	; 6
    2b7e:	8f 8b       	std	Y+23, r24	; 0x17
									lastMovement = moveCounterClockwise;
    2b80:	84 e0       	ldi	r24, 0x04	; 4
    2b82:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2b84:	2d 96       	adiw	r28, 0x0d	; 13
    2b86:	1f ae       	std	Y+63, r1	; 0x3f
    2b88:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2b8a:	2c 96       	adiw	r28, 0x0c	; 12
    2b8c:	1f ae       	std	Y+63, r1	; 0x3f
    2b8e:	2c 97       	sbiw	r28, 0x0c	; 12
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2b90:	6a 96       	adiw	r28, 0x1a	; 26
    2b92:	1c ae       	std	Y+60, r1	; 0x3c
    2b94:	1d ae       	std	Y+61, r1	; 0x3d
    2b96:	1e ae       	std	Y+62, r1	; 0x3e
    2b98:	1f ae       	std	Y+63, r1	; 0x3f
    2b9a:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2b9c:	61 96       	adiw	r28, 0x11	; 17
    2b9e:	1c ae       	std	Y+60, r1	; 0x3c
    2ba0:	1d ae       	std	Y+61, r1	; 0x3d
    2ba2:	1e ae       	std	Y+62, r1	; 0x3e
    2ba4:	1f ae       	std	Y+63, r1	; 0x3f
    2ba6:	61 97       	sbiw	r28, 0x11	; 17
    2ba8:	3e c1       	rjmp	.+636    	; 0x2e26 <__stack+0xc27>
									gLeftWheelDirection = motorLeftBackward;
									RSpeed = (baseRotationSpeed + stuckRotRight);
									gRightWheelDirection = motorRightForward;
									lastMovement = moveCounterClockwise;
								}else{//Rotating right
									LSpeed = (baseRotationSpeed + stuckRotLeft);
    2baa:	23 96       	adiw	r28, 0x03	; 3
    2bac:	2f ad       	ldd	r18, Y+63	; 0x3f
    2bae:	23 97       	sbiw	r28, 0x03	; 3
    2bb0:	82 2f       	mov	r24, r18
    2bb2:	90 e0       	ldi	r25, 0x00	; 0
    2bb4:	9c 01       	movw	r18, r24
    2bb6:	48 ad       	ldd	r20, Y+56	; 0x38
    2bb8:	24 0f       	add	r18, r20
    2bba:	31 1d       	adc	r19, r1
    2bbc:	3f 87       	std	Y+15, r19	; 0x0f
    2bbe:	2e 87       	std	Y+14, r18	; 0x0e
									gLeftWheelDirection = motorLeftForward;
    2bc0:	24 e0       	ldi	r18, 0x04	; 4
    2bc2:	2e 8b       	std	Y+22, r18	; 0x16
									RSpeed = -(baseRotationSpeed + stuckRotRight);
    2bc4:	a9 ad       	ldd	r26, Y+57	; 0x39
    2bc6:	8a 0f       	add	r24, r26
    2bc8:	91 1d       	adc	r25, r1
    2bca:	91 95       	neg	r25
    2bcc:	81 95       	neg	r24
    2bce:	91 09       	sbc	r25, r1
    2bd0:	99 8b       	std	Y+17, r25	; 0x11
    2bd2:	88 8b       	std	Y+16, r24	; 0x10
									gRightWheelDirection = motorRightBackward;
    2bd4:	85 e0       	ldi	r24, 0x05	; 5
    2bd6:	8f 8b       	std	Y+23, r24	; 0x17
									lastMovement = moveClockwise;
    2bd8:	83 e0       	ldi	r24, 0x03	; 3
    2bda:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2bdc:	2d 96       	adiw	r28, 0x0d	; 13
    2bde:	1f ae       	std	Y+63, r1	; 0x3f
    2be0:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2be2:	2c 96       	adiw	r28, 0x0c	; 12
    2be4:	1f ae       	std	Y+63, r1	; 0x3f
    2be6:	2c 97       	sbiw	r28, 0x0c	; 12
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2be8:	6a 96       	adiw	r28, 0x1a	; 26
    2bea:	1c ae       	std	Y+60, r1	; 0x3c
    2bec:	1d ae       	std	Y+61, r1	; 0x3d
    2bee:	1e ae       	std	Y+62, r1	; 0x3e
    2bf0:	1f ae       	std	Y+63, r1	; 0x3f
    2bf2:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2bf4:	61 96       	adiw	r28, 0x11	; 17
    2bf6:	1c ae       	std	Y+60, r1	; 0x3c
    2bf8:	1d ae       	std	Y+61, r1	; 0x3d
    2bfa:	1e ae       	std	Y+62, r1	; 0x3e
    2bfc:	1f ae       	std	Y+63, r1	; 0x3f
    2bfe:	61 97       	sbiw	r28, 0x11	; 17
    2c00:	12 c1       	rjmp	.+548    	; 0x2e26 <__stack+0xc27>
									RSpeed = -(baseRotationSpeed + stuckRotRight);
									gRightWheelDirection = motorRightBackward;
									lastMovement = moveClockwise;
								}
							} else {
								if (thetaDiff >= 0){//Rotating left
    2c02:	20 e0       	ldi	r18, 0x00	; 0
    2c04:	30 e0       	ldi	r19, 0x00	; 0
    2c06:	a9 01       	movw	r20, r18
    2c08:	6a 85       	ldd	r22, Y+10	; 0x0a
    2c0a:	7b 85       	ldd	r23, Y+11	; 0x0b
    2c0c:	8c 85       	ldd	r24, Y+12	; 0x0c
    2c0e:	9d 85       	ldd	r25, Y+13	; 0x0d
    2c10:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    2c14:	88 23       	and	r24, r24
    2c16:	6c f1       	brlt	.+90     	; 0x2c72 <__stack+0xa73>
									LSpeed = -(baseRotationSpeed-10 + stuckRotLeft);
    2c18:	23 96       	adiw	r28, 0x03	; 3
    2c1a:	bf ad       	ldd	r27, Y+63	; 0x3f
    2c1c:	23 97       	sbiw	r28, 0x03	; 3
    2c1e:	8b 2f       	mov	r24, r27
    2c20:	90 e0       	ldi	r25, 0x00	; 0
    2c22:	0a 97       	sbiw	r24, 0x0a	; 10
    2c24:	9c 01       	movw	r18, r24
    2c26:	48 ad       	ldd	r20, Y+56	; 0x38
    2c28:	24 0f       	add	r18, r20
    2c2a:	31 1d       	adc	r19, r1
    2c2c:	31 95       	neg	r19
    2c2e:	21 95       	neg	r18
    2c30:	31 09       	sbc	r19, r1
    2c32:	3f 87       	std	Y+15, r19	; 0x0f
    2c34:	2e 87       	std	Y+14, r18	; 0x0e
									gLeftWheelDirection = motorLeftBackward;
    2c36:	25 e0       	ldi	r18, 0x05	; 5
    2c38:	2e 8b       	std	Y+22, r18	; 0x16
									RSpeed = ((baseRotationSpeed-10) + stuckRotRight);
    2c3a:	a9 ad       	ldd	r26, Y+57	; 0x39
    2c3c:	8a 0f       	add	r24, r26
    2c3e:	91 1d       	adc	r25, r1
    2c40:	99 8b       	std	Y+17, r25	; 0x11
    2c42:	88 8b       	std	Y+16, r24	; 0x10
									gRightWheelDirection = motorRightForward;
    2c44:	86 e0       	ldi	r24, 0x06	; 6
    2c46:	8f 8b       	std	Y+23, r24	; 0x17
									lastMovement = moveCounterClockwise;
    2c48:	84 e0       	ldi	r24, 0x04	; 4
    2c4a:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2c4c:	2d 96       	adiw	r28, 0x0d	; 13
    2c4e:	1f ae       	std	Y+63, r1	; 0x3f
    2c50:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2c52:	2c 96       	adiw	r28, 0x0c	; 12
    2c54:	1f ae       	std	Y+63, r1	; 0x3f
    2c56:	2c 97       	sbiw	r28, 0x0c	; 12
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2c58:	6a 96       	adiw	r28, 0x1a	; 26
    2c5a:	1c ae       	std	Y+60, r1	; 0x3c
    2c5c:	1d ae       	std	Y+61, r1	; 0x3d
    2c5e:	1e ae       	std	Y+62, r1	; 0x3e
    2c60:	1f ae       	std	Y+63, r1	; 0x3f
    2c62:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2c64:	61 96       	adiw	r28, 0x11	; 17
    2c66:	1c ae       	std	Y+60, r1	; 0x3c
    2c68:	1d ae       	std	Y+61, r1	; 0x3d
    2c6a:	1e ae       	std	Y+62, r1	; 0x3e
    2c6c:	1f ae       	std	Y+63, r1	; 0x3f
    2c6e:	61 97       	sbiw	r28, 0x11	; 17
    2c70:	da c0       	rjmp	.+436    	; 0x2e26 <__stack+0xc27>
									gLeftWheelDirection = motorLeftBackward;
									RSpeed = ((baseRotationSpeed-10) + stuckRotRight);
									gRightWheelDirection = motorRightForward;
									lastMovement = moveCounterClockwise;
								}else{//Rotating right
									LSpeed = ((baseRotationSpeed-10) + stuckRotLeft);
    2c72:	23 96       	adiw	r28, 0x03	; 3
    2c74:	bf ad       	ldd	r27, Y+63	; 0x3f
    2c76:	23 97       	sbiw	r28, 0x03	; 3
    2c78:	8b 2f       	mov	r24, r27
    2c7a:	90 e0       	ldi	r25, 0x00	; 0
    2c7c:	0a 97       	sbiw	r24, 0x0a	; 10
    2c7e:	9c 01       	movw	r18, r24
    2c80:	48 ad       	ldd	r20, Y+56	; 0x38
    2c82:	24 0f       	add	r18, r20
    2c84:	31 1d       	adc	r19, r1
    2c86:	3f 87       	std	Y+15, r19	; 0x0f
    2c88:	2e 87       	std	Y+14, r18	; 0x0e
									gLeftWheelDirection = motorLeftForward;
    2c8a:	24 e0       	ldi	r18, 0x04	; 4
    2c8c:	2e 8b       	std	Y+22, r18	; 0x16
									RSpeed = -((baseRotationSpeed-10) + stuckRotRight);
    2c8e:	a9 ad       	ldd	r26, Y+57	; 0x39
    2c90:	8a 0f       	add	r24, r26
    2c92:	91 1d       	adc	r25, r1
    2c94:	91 95       	neg	r25
    2c96:	81 95       	neg	r24
    2c98:	91 09       	sbc	r25, r1
    2c9a:	99 8b       	std	Y+17, r25	; 0x11
    2c9c:	88 8b       	std	Y+16, r24	; 0x10
									gRightWheelDirection = motorRightBackward;
    2c9e:	85 e0       	ldi	r24, 0x05	; 5
    2ca0:	8f 8b       	std	Y+23, r24	; 0x17
									lastMovement = moveClockwise;
    2ca2:	83 e0       	ldi	r24, 0x03	; 3
    2ca4:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2ca6:	2d 96       	adiw	r28, 0x0d	; 13
    2ca8:	1f ae       	std	Y+63, r1	; 0x3f
    2caa:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2cac:	2c 96       	adiw	r28, 0x0c	; 12
    2cae:	1f ae       	std	Y+63, r1	; 0x3f
    2cb0:	2c 97       	sbiw	r28, 0x0c	; 12
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2cb2:	6a 96       	adiw	r28, 0x1a	; 26
    2cb4:	1c ae       	std	Y+60, r1	; 0x3c
    2cb6:	1d ae       	std	Y+61, r1	; 0x3d
    2cb8:	1e ae       	std	Y+62, r1	; 0x3e
    2cba:	1f ae       	std	Y+63, r1	; 0x3f
    2cbc:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2cbe:	61 96       	adiw	r28, 0x11	; 17
    2cc0:	1c ae       	std	Y+60, r1	; 0x3c
    2cc2:	1d ae       	std	Y+61, r1	; 0x3d
    2cc4:	1e ae       	std	Y+62, r1	; 0x3e
    2cc6:	1f ae       	std	Y+63, r1	; 0x3f
    2cc8:	61 97       	sbiw	r28, 0x11	; 17
    2cca:	ad c0       	rjmp	.+346    	; 0x2e26 <__stack+0xc27>
									gRightWheelDirection = motorRightBackward;
									lastMovement = moveClockwise;
								}
							}
						} else {
							if (thetaDiff >= 0){//Rotating left
    2ccc:	ca 84       	ldd	r12, Y+10	; 0x0a
    2cce:	db 84       	ldd	r13, Y+11	; 0x0b
    2cd0:	ec 84       	ldd	r14, Y+12	; 0x0c
    2cd2:	fd 84       	ldd	r15, Y+13	; 0x0d
    2cd4:	20 e0       	ldi	r18, 0x00	; 0
    2cd6:	30 e0       	ldi	r19, 0x00	; 0
    2cd8:	a9 01       	movw	r20, r18
    2cda:	c7 01       	movw	r24, r14
    2cdc:	b6 01       	movw	r22, r12
    2cde:	0e 94 ae 36 	call	0x6d5c	; 0x6d5c <__gesf2>
    2ce2:	88 23       	and	r24, r24
    2ce4:	0c f4       	brge	.+2      	; 0x2ce8 <__stack+0xae9>
    2ce6:	50 c0       	rjmp	.+160    	; 0x2d88 <__stack+0xb89>
								LSpeed = -(((baseRotationSpeed-30) + stuckRotLeft) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
    2ce8:	23 96       	adiw	r28, 0x03	; 3
    2cea:	bf ad       	ldd	r27, Y+63	; 0x3f
    2cec:	23 97       	sbiw	r28, 0x03	; 3
    2cee:	0b 2f       	mov	r16, r27
    2cf0:	10 e0       	ldi	r17, 0x00	; 0
    2cf2:	0e 51       	subi	r16, 0x1E	; 30
    2cf4:	11 09       	sbc	r17, r1
    2cf6:	c7 01       	movw	r24, r14
    2cf8:	b6 01       	movw	r22, r12
    2cfa:	9f 77       	andi	r25, 0x7F	; 127
    2cfc:	24 ee       	ldi	r18, 0xE4	; 228
    2cfe:	37 eb       	ldi	r19, 0xB7	; 183
    2d00:	4b e4       	ldi	r20, 0x4B	; 75
    2d02:	51 e4       	ldi	r21, 0x41	; 65
    2d04:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2d08:	6b 01       	movw	r12, r22
    2d0a:	7c 01       	movw	r14, r24
    2d0c:	b8 01       	movw	r22, r16
    2d0e:	28 ad       	ldd	r18, Y+56	; 0x38
    2d10:	62 0f       	add	r22, r18
    2d12:	71 1d       	adc	r23, r1
    2d14:	07 2e       	mov	r0, r23
    2d16:	00 0c       	add	r0, r0
    2d18:	88 0b       	sbc	r24, r24
    2d1a:	99 0b       	sbc	r25, r25
    2d1c:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    2d20:	a7 01       	movw	r20, r14
    2d22:	96 01       	movw	r18, r12
    2d24:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    2d28:	90 58       	subi	r25, 0x80	; 128
    2d2a:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    2d2e:	7f 87       	std	Y+15, r23	; 0x0f
    2d30:	6e 87       	std	Y+14, r22	; 0x0e
								gLeftWheelDirection = motorLeftBackward;
    2d32:	85 e0       	ldi	r24, 0x05	; 5
    2d34:	8e 8b       	std	Y+22, r24	; 0x16
								RSpeed = (((baseRotationSpeed-30) + stuckRotRight) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
    2d36:	b8 01       	movw	r22, r16
    2d38:	49 ad       	ldd	r20, Y+57	; 0x39
    2d3a:	64 0f       	add	r22, r20
    2d3c:	71 1d       	adc	r23, r1
    2d3e:	07 2e       	mov	r0, r23
    2d40:	00 0c       	add	r0, r0
    2d42:	88 0b       	sbc	r24, r24
    2d44:	99 0b       	sbc	r25, r25
    2d46:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    2d4a:	a7 01       	movw	r20, r14
    2d4c:	96 01       	movw	r18, r12
    2d4e:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    2d52:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    2d56:	79 8b       	std	Y+17, r23	; 0x11
    2d58:	68 8b       	std	Y+16, r22	; 0x10
								gRightWheelDirection = motorRightForward;
    2d5a:	86 e0       	ldi	r24, 0x06	; 6
    2d5c:	8f 8b       	std	Y+23, r24	; 0x17
								lastMovement = moveCounterClockwise;
    2d5e:	84 e0       	ldi	r24, 0x04	; 4
    2d60:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2d62:	2d 96       	adiw	r28, 0x0d	; 13
    2d64:	1f ae       	std	Y+63, r1	; 0x3f
    2d66:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2d68:	2c 96       	adiw	r28, 0x0c	; 12
    2d6a:	1f ae       	std	Y+63, r1	; 0x3f
    2d6c:	2c 97       	sbiw	r28, 0x0c	; 12
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2d6e:	6a 96       	adiw	r28, 0x1a	; 26
    2d70:	1c ae       	std	Y+60, r1	; 0x3c
    2d72:	1d ae       	std	Y+61, r1	; 0x3d
    2d74:	1e ae       	std	Y+62, r1	; 0x3e
    2d76:	1f ae       	std	Y+63, r1	; 0x3f
    2d78:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2d7a:	61 96       	adiw	r28, 0x11	; 17
    2d7c:	1c ae       	std	Y+60, r1	; 0x3c
    2d7e:	1d ae       	std	Y+61, r1	; 0x3d
    2d80:	1e ae       	std	Y+62, r1	; 0x3e
    2d82:	1f ae       	std	Y+63, r1	; 0x3f
    2d84:	61 97       	sbiw	r28, 0x11	; 17
    2d86:	4f c0       	rjmp	.+158    	; 0x2e26 <__stack+0xc27>
								gLeftWheelDirection = motorLeftBackward;
								RSpeed = (((baseRotationSpeed-30) + stuckRotRight) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
								gRightWheelDirection = motorRightForward;
								lastMovement = moveCounterClockwise;
							}else{//Rotating right
								LSpeed = (((baseRotationSpeed-30) + stuckRotLeft) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
    2d88:	23 96       	adiw	r28, 0x03	; 3
    2d8a:	8f ad       	ldd	r24, Y+63	; 0x3f
    2d8c:	23 97       	sbiw	r28, 0x03	; 3
    2d8e:	08 2f       	mov	r16, r24
    2d90:	10 e0       	ldi	r17, 0x00	; 0
    2d92:	0e 51       	subi	r16, 0x1E	; 30
    2d94:	11 09       	sbc	r17, r1
    2d96:	c7 01       	movw	r24, r14
    2d98:	b6 01       	movw	r22, r12
    2d9a:	9f 77       	andi	r25, 0x7F	; 127
    2d9c:	24 ee       	ldi	r18, 0xE4	; 228
    2d9e:	37 eb       	ldi	r19, 0xB7	; 183
    2da0:	4b e4       	ldi	r20, 0x4B	; 75
    2da2:	51 e4       	ldi	r21, 0x41	; 65
    2da4:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2da8:	6b 01       	movw	r12, r22
    2daa:	7c 01       	movw	r14, r24
    2dac:	b8 01       	movw	r22, r16
    2dae:	98 ad       	ldd	r25, Y+56	; 0x38
    2db0:	69 0f       	add	r22, r25
    2db2:	71 1d       	adc	r23, r1
    2db4:	07 2e       	mov	r0, r23
    2db6:	00 0c       	add	r0, r0
    2db8:	88 0b       	sbc	r24, r24
    2dba:	99 0b       	sbc	r25, r25
    2dbc:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    2dc0:	a7 01       	movw	r20, r14
    2dc2:	96 01       	movw	r18, r12
    2dc4:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    2dc8:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    2dcc:	7f 87       	std	Y+15, r23	; 0x0f
    2dce:	6e 87       	std	Y+14, r22	; 0x0e
								gLeftWheelDirection = motorLeftForward;
    2dd0:	84 e0       	ldi	r24, 0x04	; 4
    2dd2:	8e 8b       	std	Y+22, r24	; 0x16
								RSpeed = -(((baseRotationSpeed-30) + stuckRotRight) + (30*(4/(3*M_PI))*fabs(thetaDiff)));
    2dd4:	b8 01       	movw	r22, r16
    2dd6:	a9 ad       	ldd	r26, Y+57	; 0x39
    2dd8:	6a 0f       	add	r22, r26
    2dda:	71 1d       	adc	r23, r1
    2ddc:	07 2e       	mov	r0, r23
    2dde:	00 0c       	add	r0, r0
    2de0:	88 0b       	sbc	r24, r24
    2de2:	99 0b       	sbc	r25, r25
    2de4:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    2de8:	a7 01       	movw	r20, r14
    2dea:	96 01       	movw	r18, r12
    2dec:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    2df0:	90 58       	subi	r25, 0x80	; 128
    2df2:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    2df6:	79 8b       	std	Y+17, r23	; 0x11
    2df8:	68 8b       	std	Y+16, r22	; 0x10
								gRightWheelDirection = motorRightBackward;
    2dfa:	85 e0       	ldi	r24, 0x05	; 5
    2dfc:	8f 8b       	std	Y+23, r24	; 0x17
								lastMovement = moveClockwise;
    2dfe:	83 e0       	ldi	r24, 0x03	; 3
    2e00:	89 87       	std	Y+9, r24	; 0x09
						if ( newOrder == TRUE && baseRotationSpeed > 100 )
						{
							debug("new order, baseRot: %i", baseRotationSpeed);
							baseRotationSpeed = 70;
						}
						newOrder = FALSE;
    2e02:	2d 96       	adiw	r28, 0x0d	; 13
    2e04:	1f ae       	std	Y+63, r1	; 0x3f
    2e06:	2d 97       	sbiw	r28, 0x0d	; 13
								stuckRotLeft = 0;
								stuckRotRight = 0;
							}
						}
						
						stuckIncrement = 0;
    2e08:	2c 96       	adiw	r28, 0x0c	; 12
    2e0a:	1f ae       	std	Y+63, r1	; 0x3f
    2e0c:	2c 97       	sbiw	r28, 0x0c	; 12
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
						rightIntError = 0;
    2e0e:	6a 96       	adiw	r28, 0x1a	; 26
    2e10:	1c ae       	std	Y+60, r1	; 0x3c
    2e12:	1d ae       	std	Y+61, r1	; 0x3d
    2e14:	1e ae       	std	Y+62, r1	; 0x3e
    2e16:	1f ae       	std	Y+63, r1	; 0x3f
    2e18:	6a 97       	sbiw	r28, 0x1a	; 26
								} else if (dRight > dLeft && dLeft == 0){
									LSpeed+=1;
								}
							}
						}*/
						leftIntError = 0;
    2e1a:	61 96       	adiw	r28, 0x11	; 17
    2e1c:	1c ae       	std	Y+60, r1	; 0x3c
    2e1e:	1d ae       	std	Y+61, r1	; 0x3d
    2e20:	1e ae       	std	Y+62, r1	; 0x3e
    2e22:	1f ae       	std	Y+63, r1	; 0x3f
    2e24:	61 97       	sbiw	r28, 0x11	; 17
						rightIntError = 0;
					}
				
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
    2e26:	68 89       	ldd	r22, Y+16	; 0x10
    2e28:	79 89       	ldd	r23, Y+17	; 0x11
    2e2a:	8e 85       	ldd	r24, Y+14	; 0x0e
    2e2c:	9f 85       	ldd	r25, Y+15	; 0x0f
    2e2e:	9e 01       	movw	r18, r28
    2e30:	29 5e       	subi	r18, 0xE9	; 233
    2e32:	3f 4f       	sbci	r19, 0xFF	; 255
    2e34:	ae 01       	movw	r20, r28
    2e36:	4a 5e       	subi	r20, 0xEA	; 234
    2e38:	5f 4f       	sbci	r21, 0xFF	; 255
    2e3a:	8e d3       	rcall	.+1820   	; 0x3558 <vMotorMovementSwitch>
					//Simple speed controller as the robot nears the target
					blabla++;
					
					
				
					idleSendt = FALSE;
    2e3c:	6b 96       	adiw	r28, 0x1b	; 27
    2e3e:	1f ae       	std	Y+63, r1	; 0x3f
    2e40:	6b 97       	sbiw	r28, 0x1b	; 27
    2e42:	32 c0       	rjmp	.+100    	; 0x2ea8 <__stack+0xca9>
	
					vMotorMovementSwitch(LSpeed,RSpeed, &gLeftWheelDirection, &gRightWheelDirection);
					*/
				}else{
					
					if (idleSendt == FALSE){
    2e44:	6b 96       	adiw	r28, 0x1b	; 27
    2e46:	bf ad       	ldd	r27, Y+63	; 0x3f
    2e48:	6b 97       	sbiw	r28, 0x1b	; 27
    2e4a:	b1 11       	cpse	r27, r1
    2e4c:	06 c0       	rjmp	.+12     	; 0x2e5a <__stack+0xc5b>
						send_idle();
    2e4e:	0e 94 15 25 	call	0x4a2a	; 0x4a2a <send_idle>
						//debug("xhat: %i, yhat: %i",xhat,yhat);
						idlesendtInc = 0;
						//vMotorMovementSwitch(-255,-255, &gLeftWheelDirection, &gRightWheelDirection);
						idleSendt = TRUE;
    2e52:	21 e0       	ldi	r18, 0x01	; 1
    2e54:	6b 96       	adiw	r28, 0x1b	; 27
    2e56:	2f af       	std	Y+63, r18	; 0x3f
    2e58:	6b 97       	sbiw	r28, 0x1b	; 27
					}
					idlesendtInc++;
					if (prevDist < distance){
						//vMotorMovementSwitch(-baseUpRampActuation,-baseUpRampActuation, &gLeftWheelDirection, &gRightWheelDirection);
					}
					if (printInc==100 && starteds>0){
    2e5a:	4f a9       	ldd	r20, Y+55	; 0x37
    2e5c:	44 36       	cpi	r20, 0x64	; 100
    2e5e:	f1 f4       	brne	.+60     	; 0x2e9c <__stack+0xc9d>
    2e60:	a8 96       	adiw	r28, 0x28	; 40
    2e62:	8f ad       	ldd	r24, Y+63	; 0x3f
    2e64:	a8 97       	sbiw	r28, 0x28	; 40
    2e66:	88 23       	and	r24, r24
    2e68:	c9 f0       	breq	.+50     	; 0x2e9c <__stack+0xc9d>
						debug("xhat: %i, yhat: %i, theta: %f",xhat,yhat,thetahat);
    2e6a:	9a a9       	ldd	r25, Y+50	; 0x32
    2e6c:	9f 93       	push	r25
    2e6e:	a9 a9       	ldd	r26, Y+49	; 0x31
    2e70:	af 93       	push	r26
    2e72:	b8 a9       	ldd	r27, Y+48	; 0x30
    2e74:	bf 93       	push	r27
    2e76:	2f a5       	ldd	r18, Y+47	; 0x2f
    2e78:	2f 93       	push	r18
    2e7a:	1f 93       	push	r17
    2e7c:	0f 93       	push	r16
    2e7e:	3f 92       	push	r3
    2e80:	2f 92       	push	r2
    2e82:	85 e5       	ldi	r24, 0x55	; 85
    2e84:	96 e0       	ldi	r25, 0x06	; 6
    2e86:	9f 93       	push	r25
    2e88:	8f 93       	push	r24
    2e8a:	0e 94 39 25 	call	0x4a72	; 0x4a72 <debug>
						printInc = 0;
    2e8e:	0f b6       	in	r0, 0x3f	; 63
    2e90:	f8 94       	cli
    2e92:	de bf       	out	0x3e, r29	; 62
    2e94:	0f be       	out	0x3f, r0	; 63
    2e96:	cd bf       	out	0x3d, r28	; 61
    2e98:	1f aa       	std	Y+55, r1	; 0x37
    2e9a:	03 c0       	rjmp	.+6      	; 0x2ea2 <__stack+0xca3>
					} else {
						printInc++;
    2e9c:	9f a9       	ldd	r25, Y+55	; 0x37
    2e9e:	9f 5f       	subi	r25, 0xFF	; 255
					}
					vMotorBrakeLeft();
    2ea0:	9f ab       	std	Y+55, r25	; 0x37
					vMotorBrakeRight();
    2ea2:	49 d3       	rcall	.+1682   	; 0x3536 <vMotorBrakeLeft>
    2ea4:	4c d3       	rcall	.+1688   	; 0x353e <vMotorBrakeRight>

					lastMovement = moveStop;
    2ea6:	19 86       	std	Y+9, r1	; 0x09
				}
				xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
    2ea8:	20 e0       	ldi	r18, 0x00	; 0
    2eaa:	40 e0       	ldi	r20, 0x00	; 0
    2eac:	50 e0       	ldi	r21, 0x00	; 0
    2eae:	be 01       	movw	r22, r28
    2eb0:	67 5f       	subi	r22, 0xF7	; 247
    2eb2:	7f 4f       	sbci	r23, 0xFF	; 255
    2eb4:	80 91 21 1a 	lds	r24, 0x1A21	; 0x801a21 <scanStatusQ>
    2eb8:	90 91 22 1a 	lds	r25, 0x1A22	; 0x801a22 <scanStatusQ+0x1>
    2ebc:	dc d7       	rcall	.+4024   	; 0x3e76 <xQueueGenericSend>
				} 
				
				
				
				prevDist = distance;
				distance = (float)sqrt((xTargt-xhat)*(xTargt-xhat) + (yTargt-yhat)*(yTargt-yhat));
    2ebe:	ac 8d       	ldd	r26, Y+28	; 0x1c
    2ec0:	63 96       	adiw	r28, 0x13	; 19
    2ec2:	af af       	std	Y+63, r26	; 0x3f
    2ec4:	63 97       	sbiw	r28, 0x13	; 19
    2ec6:	b8 a1       	ldd	r27, Y+32	; 0x20
    2ec8:	64 96       	adiw	r28, 0x14	; 20
    2eca:	bf af       	std	Y+63, r27	; 0x3f
    2ecc:	64 97       	sbiw	r28, 0x14	; 20
    2ece:	29 a1       	ldd	r18, Y+33	; 0x21
    2ed0:	65 96       	adiw	r28, 0x15	; 21
    2ed2:	2f af       	std	Y+63, r18	; 0x3f
    2ed4:	65 97       	sbiw	r28, 0x15	; 21
    2ed6:	4a a1       	ldd	r20, Y+34	; 0x22
    2ed8:	66 96       	adiw	r28, 0x16	; 22
    2eda:	4f af       	std	Y+63, r20	; 0x3f
    2edc:	66 97       	sbiw	r28, 0x16	; 22
				xQueueSend(scanStatusQ, &lastMovement, 0); // Send the current movement to the scan task
			} // No semaphore available, task is blocking
		} //if(gHandshook) end
		else{
			
			vMotorBrakeLeft();
    2ede:	0c 94 6f 0f 	jmp	0x1ede	; 0x1ede <vMainPoseControllerTask+0x120>
			vMotorBrakeRight();
    2ee2:	29 d3       	rcall	.+1618   	; 0x3536 <vMotorBrakeLeft>
    2ee4:	2c d3       	rcall	.+1624   	; 0x353e <vMotorBrakeRight>
    2ee6:	0c 94 6f 0f 	jmp	0x1ede	; 0x1ede <vMainPoseControllerTask+0x120>
								bBaseRotationSpeed = TRUE;
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
    2eea:	20 e0       	ldi	r18, 0x00	; 0
    2eec:	30 e0       	ldi	r19, 0x00	; 0
    2eee:	a9 01       	movw	r20, r18
    2ef0:	2b 96       	adiw	r28, 0x0b	; 11
    2ef2:	6c ad       	ldd	r22, Y+60	; 0x3c
    2ef4:	7d ad       	ldd	r23, Y+61	; 0x3d
    2ef6:	8e ad       	ldd	r24, Y+62	; 0x3e
    2ef8:	9f ad       	ldd	r25, Y+63	; 0x3f
    2efa:	2b 97       	sbiw	r28, 0x0b	; 11
    2efc:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2f00:	88 23       	and	r24, r24
    2f02:	91 f0       	breq	.+36     	; 0x2f28 <__stack+0xd29>
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
							}
						} else {
							//stuckRotInc = 0;
							bStuck = FALSE;
    2f04:	aa 96       	adiw	r28, 0x2a	; 42
    2f06:	1f ae       	std	Y+63, r1	; 0x3f
    2f08:	aa 97       	sbiw	r28, 0x2a	; 42
    2f0a:	00 ce       	rjmp	.-1024   	; 0x2b0c <__stack+0x90d>
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
							if (dLeft == 0){
    2f0c:	20 e0       	ldi	r18, 0x00	; 0
    2f0e:	30 e0       	ldi	r19, 0x00	; 0
    2f10:	a9 01       	movw	r20, r18
    2f12:	27 96       	adiw	r28, 0x07	; 7
    2f14:	6c ad       	ldd	r22, Y+60	; 0x3c
    2f16:	7d ad       	ldd	r23, Y+61	; 0x3d
    2f18:	8e ad       	ldd	r24, Y+62	; 0x3e
    2f1a:	9f ad       	ldd	r25, Y+63	; 0x3f
    2f1c:	27 97       	sbiw	r28, 0x07	; 7
    2f1e:	0e 94 fe 34 	call	0x69fc	; 0x69fc <__cmpsf2>
    2f22:	81 11       	cpse	r24, r1
    2f24:	b0 cd       	rjmp	.-1184   	; 0x2a86 <__stack+0x887>
    2f26:	9f cd       	rjmp	.-1218   	; 0x2a66 <__stack+0x867>
								bBaseRotationSpeed = TRUE;
								//baseRotationSpeed += 5;
								debug("baseRot: %i", baseRotationSpeed);
							}
						}
						if (newOrder == FALSE && dLeft==0 ||dRight==0 && bBaseRotationSpeed){
    2f28:	a9 96       	adiw	r28, 0x29	; 41
    2f2a:	8f ad       	ldd	r24, Y+63	; 0x3f
    2f2c:	a9 97       	sbiw	r28, 0x29	; 41
    2f2e:	81 11       	cpse	r24, r1
    2f30:	aa cd       	rjmp	.-1196   	; 0x2a86 <__stack+0x887>
								stuckRotRight = 0;
								debug("stuck! rotSpeed: %i",baseRotationSpeed);
							}
						} else {
							//stuckRotInc = 0;
							bStuck = FALSE;
    2f32:	aa 96       	adiw	r28, 0x2a	; 42
    2f34:	1f ae       	std	Y+63, r1	; 0x3f
    2f36:	aa 97       	sbiw	r28, 0x2a	; 42
    2f38:	cf cd       	rjmp	.-1122   	; 0x2ad8 <__stack+0x8d9>

00002f3a <vMainPoseEstimatorTask>:
		}
	}
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    2f3a:	cf 93       	push	r28
    2f3c:	df 93       	push	r29
    2f3e:	cd b7       	in	r28, 0x3d	; 61
    2f40:	de b7       	in	r29, 0x3e	; 62
    2f42:	6e 97       	sbiw	r28, 0x1e	; 30
    2f44:	0f b6       	in	r0, 0x3f	; 63
    2f46:	f8 94       	cli
    2f48:	de bf       	out	0x3e, r29	; 62
    2f4a:	0f be       	out	0x3f, r0	; 63
    2f4c:	cd bf       	out	0x3d, r28	; 61
    const TickType_t xDelay = PERIOD_ESTIMATOR_MS;
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;

    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    2f4e:	19 82       	std	Y+1, r1	; 0x01
    2f50:	1a 82       	std	Y+2, r1	; 0x02
    2f52:	1b 82       	std	Y+3, r1	; 0x03
    2f54:	1c 82       	std	Y+4, r1	; 0x04
        uint8_t printerTellar = 0;     
    #endif
    
    // Initialise the xLastWakeTime variable with the current time.
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    2f56:	0e 94 58 2d 	call	0x5ab0	; 0x5ab0 <xTaskGetTickCount>
    2f5a:	9e 83       	std	Y+6, r25	; 0x06
    2f5c:	8d 83       	std	Y+5, r24	; 0x05
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    
    float gyroOffset = 0.0;
    2f5e:	1b 86       	std	Y+11, r1	; 0x0b
    2f60:	1c 86       	std	Y+12, r1	; 0x0c
    2f62:	1d 86       	std	Y+13, r1	; 0x0d
    2f64:	1e 86       	std	Y+14, r1	; 0x0e

    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    float predictedY = 0.0;
    2f66:	1b 8a       	std	Y+19, r1	; 0x13
    2f68:	1c 8a       	std	Y+20, r1	; 0x14
    2f6a:	1d 8a       	std	Y+21, r1	; 0x15
    2f6c:	1e 8a       	std	Y+22, r1	; 0x16
    float period_in_S = PERIOD_ESTIMATOR_MS / 1000.0f;

    float kalmanGain = 0.5;
    
    float predictedTheta = 0.0;
    float predictedX = 0.0;
    2f6e:	1f 86       	std	Y+15, r1	; 0x0f
    2f70:	18 8a       	std	Y+16, r1	; 0x10
    2f72:	19 8a       	std	Y+17, r1	; 0x11
    2f74:	1a 8a       	std	Y+18, r1	; 0x12
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    int16_t previous_ticksRight = 0;  
    2f76:	e1 2c       	mov	r14, r1
    2f78:	f1 2c       	mov	r15, r1
	}
}

/* Pose estimator task */
void vMainPoseEstimatorTask( void *pvParameters ){
    int16_t previous_ticksLeft = 0;
    2f7a:	c1 2c       	mov	r12, r1
    2f7c:	d1 2c       	mov	r13, r1
    TickType_t xLastWakeTime;
    xLastWakeTime = xTaskGetTickCount();
    
    while(1){
        // Loop
        vTaskDelayUntil(&xLastWakeTime, xDelay / portTICK_PERIOD_MS );  
    2f7e:	68 e2       	ldi	r22, 0x28	; 40
    2f80:	70 e0       	ldi	r23, 0x00	; 0
    2f82:	ce 01       	movw	r24, r28
    2f84:	05 96       	adiw	r24, 0x05	; 5
    2f86:	0e 94 02 28 	call	0x5004	; 0x5004 <vTaskDelayUntil>
        if (gHandshook){ // Check if we are ready    
    2f8a:	80 91 1c 1a 	lds	r24, 0x1A1C	; 0x801a1c <gHandshook>
    2f8e:	88 23       	and	r24, r24
    2f90:	09 f4       	brne	.+2      	; 0x2f94 <vMainPoseEstimatorTask+0x5a>
    2f92:	1f c1       	rjmp	.+574    	; 0x31d2 <vMainPoseEstimatorTask+0x298>
            int16_t leftWheelTicks = 0;
            int16_t rightWheelTicks = 0;
            float dRobot = 0;
			float dTheta = 0;
            // Get encoder data, protect the global tick variables
            xSemaphoreTake(xTickMutex, 15 / portTICK_PERIOD_MS);
    2f94:	20 e0       	ldi	r18, 0x00	; 0
    2f96:	4f e0       	ldi	r20, 0x0F	; 15
    2f98:	50 e0       	ldi	r21, 0x00	; 0
    2f9a:	60 e0       	ldi	r22, 0x00	; 0
    2f9c:	70 e0       	ldi	r23, 0x00	; 0
    2f9e:	80 91 85 1b 	lds	r24, 0x1B85	; 0x801b85 <xTickMutex>
    2fa2:	90 91 86 1b 	lds	r25, 0x1B86	; 0x801b86 <xTickMutex+0x1>
    2fa6:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
                leftWheelTicks = gLeftWheelTicks;
    2faa:	20 90 07 1a 	lds	r2, 0x1A07	; 0x801a07 <gLeftWheelTicks>
    2fae:	30 90 08 1a 	lds	r3, 0x1A08	; 0x801a08 <gLeftWheelTicks+0x1>
                rightWheelTicks = gRightWheelTicks;
    2fb2:	00 91 09 1a 	lds	r16, 0x1A09	; 0x801a09 <gRightWheelTicks>
    2fb6:	10 91 0a 1a 	lds	r17, 0x1A0A	; 0x801a0a <gRightWheelTicks+0x1>
            xSemaphoreGive(xTickMutex);
    2fba:	60 e0       	ldi	r22, 0x00	; 0
    2fbc:	70 e0       	ldi	r23, 0x00	; 0
    2fbe:	80 91 85 1b 	lds	r24, 0x1B85	; 0x801b85 <xTickMutex>
    2fc2:	90 91 86 1b 	lds	r25, 0x1B86	; 0x801b86 <xTickMutex+0x1>
    2fc6:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
			
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
    2fca:	b1 01       	movw	r22, r2
    2fcc:	6c 19       	sub	r22, r12
    2fce:	7d 09       	sbc	r23, r13
    2fd0:	07 2e       	mov	r0, r23
    2fd2:	00 0c       	add	r0, r0
    2fd4:	88 0b       	sbc	r24, r24
    2fd6:	99 0b       	sbc	r25, r25
    2fd8:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    2fdc:	28 ef       	ldi	r18, 0xF8	; 248
    2fde:	33 e5       	ldi	r19, 0x53	; 83
    2fe0:	43 ea       	ldi	r20, 0xA3	; 163
    2fe2:	5f e3       	ldi	r21, 0x3F	; 63
    2fe4:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    2fe8:	2b 01       	movw	r4, r22
    2fea:	3c 01       	movw	r6, r24
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
    2fec:	b8 01       	movw	r22, r16
    2fee:	6e 19       	sub	r22, r14
    2ff0:	7f 09       	sbc	r23, r15
    2ff2:	07 2e       	mov	r0, r23
    2ff4:	00 0c       	add	r0, r0
    2ff6:	88 0b       	sbc	r24, r24
    2ff8:	99 0b       	sbc	r25, r25
    2ffa:	0e 94 a0 35 	call	0x6b40	; 0x6b40 <__floatsisf>
    2ffe:	28 ef       	ldi	r18, 0xF8	; 248
    3000:	33 e5       	ldi	r19, 0x53	; 83
    3002:	43 ea       	ldi	r20, 0xA3	; 163
    3004:	5f e3       	ldi	r21, 0x3F	; 63
    3006:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    300a:	4b 01       	movw	r8, r22
    300c:	5c 01       	movw	r10, r24
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
			
			
            dRobot = (dLeft + dRight) / 2;           
    300e:	9b 01       	movw	r18, r22
    3010:	ac 01       	movw	r20, r24
    3012:	c3 01       	movw	r24, r6
    3014:	b2 01       	movw	r22, r4
    3016:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    301a:	20 e0       	ldi	r18, 0x00	; 0
    301c:	30 e0       	ldi	r19, 0x00	; 0
    301e:	40 e0       	ldi	r20, 0x00	; 0
    3020:	5f e3       	ldi	r21, 0x3F	; 63
    3022:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    3026:	6f 8b       	std	Y+23, r22	; 0x17
    3028:	78 8f       	std	Y+24, r23	; 0x18
    302a:	89 8f       	std	Y+25, r24	; 0x19
    302c:	9a 8f       	std	Y+26, r25	; 0x1a
            dTheta = (dRight - dLeft) / WHEELBASE_MM; // Get angle from encoders, dervied from arch of circles formula
			 
            /* PREDICT */
            // Get gyro data:
            float gyrZ = (fIMU_readFloatGyroZ() - gyroOffset);
    302e:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <fIMU_readFloatGyroZ>
    3032:	2b 85       	ldd	r18, Y+11	; 0x0b
    3034:	3c 85       	ldd	r19, Y+12	; 0x0c
    3036:	4d 85       	ldd	r20, Y+13	; 0x0d
    3038:	5e 85       	ldd	r21, Y+14	; 0x0e
    303a:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    303e:	6b 01       	movw	r12, r22
    3040:	7c 01       	movw	r14, r24
            gyrZ *= period_in_S * DEG2RAD; // Scale gyro measurement      
            
			
			
            // Fuse heading from sensors to predict heading:
            dTheta =  (1 - gyroWeight) * dTheta + gyroWeight * gyrZ;
    3042:	a3 01       	movw	r20, r6
    3044:	92 01       	movw	r18, r4
    3046:	c5 01       	movw	r24, r10
    3048:	b4 01       	movw	r22, r8
    304a:	0e 94 37 34 	call	0x686e	; 0x686e <__subsf3>
    304e:	20 e0       	ldi	r18, 0x00	; 0
    3050:	30 e0       	ldi	r19, 0x00	; 0
    3052:	47 e1       	ldi	r20, 0x17	; 23
    3054:	53 e4       	ldi	r21, 0x43	; 67
    3056:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    305a:	20 e0       	ldi	r18, 0x00	; 0
    305c:	30 e0       	ldi	r19, 0x00	; 0
    305e:	40 e0       	ldi	r20, 0x00	; 0
    3060:	50 e0       	ldi	r21, 0x00	; 0
    3062:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    3066:	6f 83       	std	Y+7, r22	; 0x07
    3068:	78 87       	std	Y+8, r23	; 0x08
    306a:	89 87       	std	Y+9, r24	; 0x09
    306c:	9a 87       	std	Y+10, r25	; 0x0a
    306e:	24 ed       	ldi	r18, 0xD4	; 212
    3070:	32 e0       	ldi	r19, 0x02	; 2
    3072:	47 e3       	ldi	r20, 0x37	; 55
    3074:	5a e3       	ldi	r21, 0x3A	; 58
    3076:	c7 01       	movw	r24, r14
    3078:	b6 01       	movw	r22, r12
    307a:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    307e:	2f 81       	ldd	r18, Y+7	; 0x07
    3080:	38 85       	ldd	r19, Y+8	; 0x08
    3082:	49 85       	ldd	r20, Y+9	; 0x09
    3084:	5a 85       	ldd	r21, Y+10	; 0x0a
    3086:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    308a:	6f 83       	std	Y+7, r22	; 0x07
    308c:	78 87       	std	Y+8, r23	; 0x08
    308e:	89 87       	std	Y+9, r24	; 0x09
    3090:	9a 87       	std	Y+10, r25	; 0x0a
            
            
            // Estimate global X and Y pos
            // Todo; Include accelerator measurements to estimate position and handle wheel slippage
            predictedX = predictedX + (dRobot * cos(predictedTheta + 0.5 * dTheta)); 
    3092:	c9 80       	ldd	r12, Y+1	; 0x01
    3094:	da 80       	ldd	r13, Y+2	; 0x02
    3096:	eb 80       	ldd	r14, Y+3	; 0x03
    3098:	fc 80       	ldd	r15, Y+4	; 0x04
    309a:	20 e0       	ldi	r18, 0x00	; 0
    309c:	30 e0       	ldi	r19, 0x00	; 0
    309e:	40 e0       	ldi	r20, 0x00	; 0
    30a0:	5f e3       	ldi	r21, 0x3F	; 63
    30a2:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    30a6:	a7 01       	movw	r20, r14
    30a8:	96 01       	movw	r18, r12
    30aa:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    30ae:	6b 8f       	std	Y+27, r22	; 0x1b
    30b0:	7c 8f       	std	Y+28, r23	; 0x1c
    30b2:	8d 8f       	std	Y+29, r24	; 0x1d
    30b4:	9e 8f       	std	Y+30, r25	; 0x1e
    30b6:	0e 94 02 35 	call	0x6a04	; 0x6a04 <cos>
    30ba:	9b 01       	movw	r18, r22
    30bc:	ac 01       	movw	r20, r24
    30be:	6f 89       	ldd	r22, Y+23	; 0x17
    30c0:	78 8d       	ldd	r23, Y+24	; 0x18
    30c2:	89 8d       	ldd	r24, Y+25	; 0x19
    30c4:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30c6:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    30ca:	9b 01       	movw	r18, r22
    30cc:	ac 01       	movw	r20, r24
    30ce:	6f 85       	ldd	r22, Y+15	; 0x0f
    30d0:	78 89       	ldd	r23, Y+16	; 0x10
    30d2:	89 89       	ldd	r24, Y+17	; 0x11
    30d4:	9a 89       	ldd	r25, Y+18	; 0x12
    30d6:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    30da:	6f 87       	std	Y+15, r22	; 0x0f
    30dc:	78 8b       	std	Y+16, r23	; 0x10
    30de:	89 8b       	std	Y+17, r24	; 0x11
    30e0:	9a 8b       	std	Y+18, r25	; 0x12
            predictedY = predictedY + (dRobot * sin(predictedTheta + 0.5 * dTheta));
    30e2:	6b 8d       	ldd	r22, Y+27	; 0x1b
    30e4:	7c 8d       	ldd	r23, Y+28	; 0x1c
    30e6:	8d 8d       	ldd	r24, Y+29	; 0x1d
    30e8:	9e 8d       	ldd	r25, Y+30	; 0x1e
    30ea:	0e 94 1c 37 	call	0x6e38	; 0x6e38 <sin>
    30ee:	9b 01       	movw	r18, r22
    30f0:	ac 01       	movw	r20, r24
    30f2:	6f 89       	ldd	r22, Y+23	; 0x17
    30f4:	78 8d       	ldd	r23, Y+24	; 0x18
    30f6:	89 8d       	ldd	r24, Y+25	; 0x19
    30f8:	9a 8d       	ldd	r25, Y+26	; 0x1a
    30fa:	0e 94 b9 36 	call	0x6d72	; 0x6d72 <__mulsf3>
    30fe:	9b 01       	movw	r18, r22
    3100:	ac 01       	movw	r20, r24
    3102:	6b 89       	ldd	r22, Y+19	; 0x13
    3104:	7c 89       	ldd	r23, Y+20	; 0x14
    3106:	8d 89       	ldd	r24, Y+21	; 0x15
    3108:	9e 89       	ldd	r25, Y+22	; 0x16
    310a:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    310e:	6b 8b       	std	Y+19, r22	; 0x13
    3110:	7c 8b       	std	Y+20, r23	; 0x14
    3112:	8d 8b       	std	Y+21, r24	; 0x15
    3114:	9e 8b       	std	Y+22, r25	; 0x16

            // Predicted (a priori) state estimate for theta
            predictedTheta += dTheta;
    3116:	a7 01       	movw	r20, r14
    3118:	96 01       	movw	r18, r12
    311a:	6f 81       	ldd	r22, Y+7	; 0x07
    311c:	78 85       	ldd	r23, Y+8	; 0x08
    311e:	89 85       	ldd	r24, Y+9	; 0x09
    3120:	9a 85       	ldd	r25, Y+10	; 0x0a
    3122:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    3126:	69 83       	std	Y+1, r22	; 0x01
    3128:	7a 83       	std	Y+2, r23	; 0x02
    312a:	8b 83       	std	Y+3, r24	; 0x03
    312c:	9c 83       	std	Y+4, r25	; 0x04
                //vLED_singleLow(ledYELLOW);
            }            
            //*/
           
            //predictedTheta  += kalmanGain*(error);
			vFunc_Inf2pi(&predictedTheta);            
    312e:	ce 01       	movw	r24, r28
    3130:	01 96       	adiw	r24, 0x01	; 1
    3132:	0e 94 d8 07 	call	0xfb0	; 0xfb0 <vFunc_Inf2pi>
            
            // Updated (a posteriori) estimate covariance
            covariance_filter_predicted = (1 - kalmanGain) * covariance_filter_predicted;  

            // Update pose
            xSemaphoreTake(xPoseMutex, 15 / portTICK_PERIOD_MS);
    3136:	20 e0       	ldi	r18, 0x00	; 0
    3138:	4f e0       	ldi	r20, 0x0F	; 15
    313a:	50 e0       	ldi	r21, 0x00	; 0
    313c:	60 e0       	ldi	r22, 0x00	; 0
    313e:	70 e0       	ldi	r23, 0x00	; 0
    3140:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    3144:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    3148:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
                gTheta_hat = predictedTheta;
    314c:	89 81       	ldd	r24, Y+1	; 0x01
    314e:	9a 81       	ldd	r25, Y+2	; 0x02
    3150:	ab 81       	ldd	r26, Y+3	; 0x03
    3152:	bc 81       	ldd	r27, Y+4	; 0x04
    3154:	80 93 17 1a 	sts	0x1A17, r24	; 0x801a17 <gTheta_hat>
    3158:	90 93 18 1a 	sts	0x1A18, r25	; 0x801a18 <gTheta_hat+0x1>
    315c:	a0 93 19 1a 	sts	0x1A19, r26	; 0x801a19 <gTheta_hat+0x2>
    3160:	b0 93 1a 1a 	sts	0x1A1A, r27	; 0x801a1a <gTheta_hat+0x3>
                gX_hat = predictedX;
    3164:	6f 85       	ldd	r22, Y+15	; 0x0f
    3166:	78 89       	ldd	r23, Y+16	; 0x10
    3168:	89 89       	ldd	r24, Y+17	; 0x11
    316a:	9a 89       	ldd	r25, Y+18	; 0x12
    316c:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    3170:	70 93 16 1a 	sts	0x1A16, r23	; 0x801a16 <gX_hat+0x1>
    3174:	60 93 15 1a 	sts	0x1A15, r22	; 0x801a15 <gX_hat>
                gY_hat = predictedY;
    3178:	6b 89       	ldd	r22, Y+19	; 0x13
    317a:	7c 89       	ldd	r23, Y+20	; 0x14
    317c:	8d 89       	ldd	r24, Y+21	; 0x15
    317e:	9e 89       	ldd	r25, Y+22	; 0x16
    3180:	0e 94 6d 35 	call	0x6ada	; 0x6ada <__fixsfsi>
    3184:	70 93 14 1a 	sts	0x1A14, r23	; 0x801a14 <gY_hat+0x1>
    3188:	60 93 13 1a 	sts	0x1A13, r22	; 0x801a13 <gY_hat>
				gLeft = dLeft;
    318c:	40 92 0f 1a 	sts	0x1A0F, r4	; 0x801a0f <gLeft>
    3190:	50 92 10 1a 	sts	0x1A10, r5	; 0x801a10 <gLeft+0x1>
    3194:	60 92 11 1a 	sts	0x1A11, r6	; 0x801a11 <gLeft+0x2>
    3198:	70 92 12 1a 	sts	0x1A12, r7	; 0x801a12 <gLeft+0x3>
				gRight = dRight;
    319c:	80 92 0b 1a 	sts	0x1A0B, r8	; 0x801a0b <gRight>
    31a0:	90 92 0c 1a 	sts	0x1A0C, r9	; 0x801a0c <gRight+0x1>
    31a4:	a0 92 0d 1a 	sts	0x1A0D, r10	; 0x801a0d <gRight+0x2>
    31a8:	b0 92 0e 1a 	sts	0x1A0E, r11	; 0x801a0e <gRight+0x3>
            xSemaphoreGive(xPoseMutex);
    31ac:	60 e0       	ldi	r22, 0x00	; 0
    31ae:	70 e0       	ldi	r23, 0x00	; 0
    31b0:	80 91 8b 1b 	lds	r24, 0x1B8B	; 0x801b8b <xPoseMutex>
    31b4:	90 91 8c 1b 	lds	r25, 0x1B8C	; 0x801b8c <xPoseMutex+0x1>
    31b8:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
			
            // Send semaphore to controller
            xSemaphoreGive(xControllerBSem);
    31bc:	60 e0       	ldi	r22, 0x00	; 0
    31be:	70 e0       	ldi	r23, 0x00	; 0
    31c0:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <xControllerBSem>
    31c4:	90 91 84 1b 	lds	r25, 0x1B84	; 0x801b84 <xControllerBSem+0x1>
    31c8:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
            xSemaphoreGive(xTickMutex);
			
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
            previous_ticksRight = rightWheelTicks;
    31cc:	78 01       	movw	r14, r16
                rightWheelTicks = gRightWheelTicks;
            xSemaphoreGive(xTickMutex);
			
            float dLeft = (float)(leftWheelTicks - previous_ticksLeft) * WHEEL_FACTOR_MM; // Distance left wheel has traveled since last sample
            float dRight =(float)(rightWheelTicks - previous_ticksRight) * WHEEL_FACTOR_MM; // Distance right wheel has traveled since last sample
            previous_ticksLeft = leftWheelTicks;
    31ce:	61 01       	movw	r12, r2
    31d0:	d6 ce       	rjmp	.-596    	; 0x2f7e <vMainPoseEstimatorTask+0x44>
    31d2:	05 e6       	ldi	r16, 0x65	; 101
    31d4:	10 e0       	ldi	r17, 0x00	; 0
    31d6:	81 2c       	mov	r8, r1
    31d8:	91 2c       	mov	r9, r1
    31da:	a1 2c       	mov	r10, r1
    31dc:	b1 2c       	mov	r11, r1
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
                gyro+= fIMU_readFloatGyroZ();
    31de:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <fIMU_readFloatGyroZ>
    31e2:	9b 01       	movw	r18, r22
    31e4:	ac 01       	movw	r20, r24
    31e6:	68 2d       	mov	r22, r8
    31e8:	79 2d       	mov	r23, r9
    31ea:	8a 2d       	mov	r24, r10
    31ec:	9b 2d       	mov	r25, r11
    31ee:	0e 94 38 34 	call	0x6870	; 0x6870 <__addsf3>
    31f2:	86 2e       	mov	r8, r22
    31f4:	97 2e       	mov	r9, r23
    31f6:	a8 2e       	mov	r10, r24
    31f8:	b9 2e       	mov	r11, r25
    31fa:	01 50       	subi	r16, 0x01	; 1
    31fc:	11 09       	sbc	r17, r1
        else{
            // Not connected, getting heading and gyro bias
            uint16_t i;
            uint16_t samples = 100;
            float gyro = 0;
            for (i = 0; i<=samples; i++){
    31fe:	79 f7       	brne	.-34     	; 0x31de <vMainPoseEstimatorTask+0x2a4>
                gyro+= fIMU_readFloatGyroZ();
            }
			gyroOffset = gyro / (float)i;   
    3200:	20 e0       	ldi	r18, 0x00	; 0
    3202:	30 e0       	ldi	r19, 0x00	; 0
    3204:	4a ec       	ldi	r20, 0xCA	; 202
    3206:	52 e4       	ldi	r21, 0x42	; 66
    3208:	0e 94 05 35 	call	0x6a0a	; 0x6a0a <__divsf3>
    320c:	6b 87       	std	Y+11, r22	; 0x0b
    320e:	7c 87       	std	Y+12, r23	; 0x0c
    3210:	8d 87       	std	Y+13, r24	; 0x0d
    3212:	9e 87       	std	Y+14, r25	; 0x0e
    3214:	b4 ce       	rjmp	.-664    	; 0x2f7e <vMainPoseEstimatorTask+0x44>

00003216 <vApplicationStackOverflowHook>:
}


/*  In case of stack overflow, disable all interrupts and handle it  */
void vApplicationStackOverflowHook(TaskHandle_t *pxTask, signed char *pcTaskName){
    cli();
    3216:	f8 94       	cli
    3218:	ff cf       	rjmp	.-2      	; 0x3218 <vApplicationStackOverflowHook+0x2>

0000321a <main>:
        //ledPORT ^= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    }// While(1) end
}

/*  Main function   */
int main(void){
    321a:	cf 93       	push	r28
    321c:	df 93       	push	r29
    321e:	1f 92       	push	r1
    3220:	1f 92       	push	r1
    3222:	cd b7       	in	r28, 0x3d	; 61
    3224:	de b7       	in	r29, 0x3e	; 62
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */

	MCUCR &= ~(1<<JTD);
    3226:	85 b7       	in	r24, 0x35	; 53
    3228:	8f 77       	andi	r24, 0x7F	; 127
    322a:	85 bf       	out	0x35, r24	; 53
	volatile size_t heap;
    vLED_init();
    322c:	0e 94 f4 0b 	call	0x17e8	; 0x17e8 <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    3230:	80 e0       	ldi	r24, 0x00	; 0
    3232:	90 e0       	ldi	r25, 0x00	; 0
    3234:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    3238:	0e 94 55 33 	call	0x66aa	; 0x66aa <vUSART_init>
    network_init();
    323c:	31 d2       	rcall	.+1122   	; 0x36a0 <network_init>
    arq_init();
    323e:	0e 94 43 01 	call	0x286	; 0x286 <arq_init>
    simple_p_init(server_receiver);
    3242:	87 e4       	ldi	r24, 0x47	; 71
    3244:	94 e2       	ldi	r25, 0x24	; 36
    3246:	0e 94 45 26 	call	0x4c8a	; 0x4c8a <simple_p_init>
        debug("tictoc!\n");
        tic;
    #endif
	
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    324a:	80 e0       	ldi	r24, 0x00	; 0
    324c:	0e 94 bd 25 	call	0x4b7a	; 0x4b7a <vServo_init>
    /* Initialize sensors */
    vDistSens_init();
    3250:	0e 94 a5 07 	call	0xf4a	; 0xf4a <vDistSens_init>
    /* Initialize motor controller */
    vMotor_init();
    3254:	ed d0       	rcall	.+474    	; 0x3430 <vMotor_init>
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        debug("IMU init..\n");
    #endif
    sIMU_begin(); 
    3256:	0e 94 6a 0a 	call	0x14d4	; 0x14d4 <sIMU_begin>
}*/
	
    
    /* Initialize RTOS utilities  */

	heap = xPortGetFreeHeapSize();
    325a:	0e 94 a1 09 	call	0x1342	; 0x1342 <xPortGetFreeHeapSize>
    325e:	9a 83       	std	Y+2, r25	; 0x02
    3260:	89 83       	std	Y+1, r24	; 0x01
    poseControllerQ = xQueueCreate(1, sizeof(struct sCartesian)); // For setpoints to controller
    3262:	40 e0       	ldi	r20, 0x00	; 0
    3264:	68 e0       	ldi	r22, 0x08	; 8
    3266:	81 e0       	ldi	r24, 0x01	; 1
    3268:	32 d4       	rcall	.+2148   	; 0x3ace <xQueueGenericCreate>
    326a:	90 93 24 1a 	sts	0x1A24, r25	; 0x801a24 <poseControllerQ+0x1>
    326e:	80 93 23 1a 	sts	0x1A23, r24	; 0x801a23 <poseControllerQ>
    scanStatusQ = xQueueCreate(1,sizeof(uint8_t)); // For robot status
    3272:	40 e0       	ldi	r20, 0x00	; 0
    3274:	61 e0       	ldi	r22, 0x01	; 1
    3276:	81 e0       	ldi	r24, 0x01	; 1
    3278:	2a d4       	rcall	.+2132   	; 0x3ace <xQueueGenericCreate>
    327a:	90 93 22 1a 	sts	0x1A22, r25	; 0x801a22 <scanStatusQ+0x1>
    327e:	80 93 21 1a 	sts	0x1A21, r24	; 0x801a21 <scanStatusQ>
    actuationQ = xQueueCreate(2,sizeof(uint8_t)); // To send variable actuation to motors
    3282:	40 e0       	ldi	r20, 0x00	; 0
    3284:	61 e0       	ldi	r22, 0x01	; 1
    3286:	82 e0       	ldi	r24, 0x02	; 2
    3288:	22 d4       	rcall	.+2116   	; 0x3ace <xQueueGenericCreate>
    328a:	90 93 20 1a 	sts	0x1A20, r25	; 0x801a20 <actuationQ+0x1>
    328e:	80 93 1f 1a 	sts	0x1A1F, r24	; 0x801a1f <actuationQ>
    
    xPoseMutex = xSemaphoreCreateMutex(); // Global variables for robot pose. Only updated from estimator, accessed from many
    3292:	81 e0       	ldi	r24, 0x01	; 1
    3294:	6e d4       	rcall	.+2268   	; 0x3b72 <xQueueCreateMutex>
    3296:	90 93 8c 1b 	sts	0x1B8C, r25	; 0x801b8c <xPoseMutex+0x1>
    329a:	80 93 8b 1b 	sts	0x1B8B, r24	; 0x801b8b <xPoseMutex>
    xUartMutex = xSemaphoreCreateMutex(); // Protected printf with a mutex, may cause fragmented bytes if higher priority task want to print as well
    329e:	81 e0       	ldi	r24, 0x01	; 1
    32a0:	68 d4       	rcall	.+2256   	; 0x3b72 <xQueueCreateMutex>
    32a2:	90 93 88 1b 	sts	0x1B88, r25	; 0x801b88 <xUartMutex+0x1>
    32a6:	80 93 87 1b 	sts	0x1B87, r24	; 0x801b87 <xUartMutex>
    xTickMutex = xSemaphoreCreateMutex(); // Global variable to hold robot tick values
    32aa:	81 e0       	ldi	r24, 0x01	; 1
    32ac:	62 d4       	rcall	.+2244   	; 0x3b72 <xQueueCreateMutex>
    32ae:	90 93 86 1b 	sts	0x1B86, r25	; 0x801b86 <xTickMutex+0x1>
    32b2:	80 93 85 1b 	sts	0x1B85, r24	; 0x801b85 <xTickMutex>
    
    xControllerBSem = xSemaphoreCreateBinary(); // Estimator to Controller synchronization
    32b6:	43 e0       	ldi	r20, 0x03	; 3
    32b8:	60 e0       	ldi	r22, 0x00	; 0
    32ba:	81 e0       	ldi	r24, 0x01	; 1
    32bc:	08 d4       	rcall	.+2064   	; 0x3ace <xQueueGenericCreate>
    32be:	90 93 84 1b 	sts	0x1B84, r25	; 0x801b84 <xControllerBSem+0x1>
    32c2:	80 93 83 1b 	sts	0x1B83, r24	; 0x801b83 <xControllerBSem>
    xCommandReadyBSem = xSemaphoreCreateBinary(); // uart ISR to comm task sync
    32c6:	43 e0       	ldi	r20, 0x03	; 3
    32c8:	60 e0       	ldi	r22, 0x00	; 0
    32ca:	81 e0       	ldi	r24, 0x01	; 1
    32cc:	00 d4       	rcall	.+2048   	; 0x3ace <xQueueGenericCreate>
    32ce:	90 93 8a 1b 	sts	0x1B8A, r25	; 0x801b8a <xCommandReadyBSem+0x1>
    32d2:	80 93 89 1b 	sts	0x1B89, r24	; 0x801b89 <xCommandReadyBSem>
    32d6:	a1 2c       	mov	r10, r1
    
    // Todo: Check return variable to ensure RTOS utilities were successfully initialized before continue
    
    xTaskCreate(vMainCommunicationTask, "Comm", 300, NULL, 3, NULL); // Dependant on ISR from UART, sends instructions to other tasks
    32d8:	b1 2c       	mov	r11, r1
    32da:	c1 2c       	mov	r12, r1
    32dc:	d1 2c       	mov	r13, r1
    32de:	e1 2c       	mov	r14, r1
    32e0:	f1 2c       	mov	r15, r1
    32e2:	03 e0       	ldi	r16, 0x03	; 3
    32e4:	20 e0       	ldi	r18, 0x00	; 0
    32e6:	30 e0       	ldi	r19, 0x00	; 0
    32e8:	4c e2       	ldi	r20, 0x2C	; 44
    32ea:	51 e0       	ldi	r21, 0x01	; 1
    32ec:	63 e7       	ldi	r22, 0x73	; 115
    32ee:	76 e0       	ldi	r23, 0x06	; 6
    32f0:	88 eb       	ldi	r24, 0xB8	; 184
    32f2:	9c e0       	ldi	r25, 0x0C	; 12
    32f4:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <xTaskGenericCreate>
    32f8:	02 e0       	ldi	r16, 0x02	; 2
    xTaskCreate(vMainPoseControllerTask, "PoseCon", 400, NULL, 2, NULL); // Dependant on estimator, sends instructions to movement task
    32fa:	20 e0       	ldi	r18, 0x00	; 0
    32fc:	30 e0       	ldi	r19, 0x00	; 0
    32fe:	40 e9       	ldi	r20, 0x90	; 144
    3300:	51 e0       	ldi	r21, 0x01	; 1
    3302:	68 e7       	ldi	r22, 0x78	; 120
    3304:	76 e0       	ldi	r23, 0x06	; 6
    3306:	8f ed       	ldi	r24, 0xDF	; 223
    3308:	9e e0       	ldi	r25, 0x0E	; 14
    330a:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <xTaskGenericCreate>
    330e:	04 e0       	ldi	r16, 0x04	; 4
	xTaskCreate(vMainPoseEstimatorTask, "PoseEst", 350, NULL, 4, NULL); // Independent task, uses ticks from ISR
    3310:	20 e0       	ldi	r18, 0x00	; 0
    3312:	30 e0       	ldi	r19, 0x00	; 0
    3314:	4e e5       	ldi	r20, 0x5E	; 94
    3316:	51 e0       	ldi	r21, 0x01	; 1
    3318:	60 e8       	ldi	r22, 0x80	; 128
    331a:	76 e0       	ldi	r23, 0x06	; 6
    331c:	8d e9       	ldi	r24, 0x9D	; 157
    331e:	97 e1       	ldi	r25, 0x17	; 23
    3320:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <xTaskGenericCreate>
    3324:	01 e0       	ldi	r16, 0x01	; 1
    xTaskCreate(vMainSensorTowerTask,"Tower",300, NULL, 1, NULL); // Independent task, but use pose updates from estimator
    3326:	20 e0       	ldi	r18, 0x00	; 0
    3328:	30 e0       	ldi	r19, 0x00	; 0
    332a:	4c e2       	ldi	r20, 0x2C	; 44
    332c:	51 e0       	ldi	r21, 0x01	; 1
    332e:	68 e8       	ldi	r22, 0x88	; 136
    3330:	76 e0       	ldi	r23, 0x06	; 6
    3332:	87 e7       	ldi	r24, 0x77	; 119
    3334:	9d e0       	ldi	r25, 0x0D	; 13
    3336:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <xTaskGenericCreate>
    333a:	0e 94 a1 09 	call	0x1342	; 0x1342 <xPortGetFreeHeapSize>

	heap = xPortGetFreeHeapSize();
    333e:	9a 83       	std	Y+2, r25	; 0x02
    3340:	89 83       	std	Y+1, r24	; 0x01
    3342:	78 94       	sei

    sei();
    3344:	80 e0       	ldi	r24, 0x00	; 0
    vLED_singleLow(ledRED);
    3346:	90 e0       	ldi	r25, 0x00	; 0
    3348:	0e 94 14 0c 	call	0x1828	; 0x1828 <vLED_singleLow>
    334c:	0e 94 2a 2b 	call	0x5654	; 0x5654 <vTaskStartScheduler>
    #ifdef DEBUG
    debug("Starting scheduler ....\n");
    #endif
    /*  Start scheduler */
    vTaskStartScheduler();
    3350:	80 e0       	ldi	r24, 0x00	; 0
	
	
	vLED_singleHigh(ledRED);
    3352:	90 e0       	ldi	r25, 0x00	; 0
    3354:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <vLED_singleHigh>
    3358:	82 e0       	ldi	r24, 0x02	; 2
	//vLED_singleHigh(ledYELLOW);
	vLED_singleHigh(ledGREEN);
    335a:	90 e0       	ldi	r25, 0x00	; 0
    335c:	0e 94 fa 0b 	call	0x17f4	; 0x17f4 <vLED_singleHigh>
    3360:	0e e8       	ldi	r16, 0x8E	; 142
	
    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
        debug("RAM fail\n");
    3362:	16 e0       	ldi	r17, 0x06	; 6
    3364:	f8 94       	cli
	//vLED_singleHigh(ledYELLOW);
	vLED_singleHigh(ledGREEN);
	
    /*  MCU is out of RAM if the program comes here */
    while(1){
        cli();
    3366:	1f 93       	push	r17
        debug("RAM fail\n");
    3368:	0f 93       	push	r16
    336a:	0e 94 39 25 	call	0x4a72	; 0x4a72 <debug>
    336e:	0f 90       	pop	r0
    3370:	0f 90       	pop	r0
    3372:	f8 cf       	rjmp	.-16     	; 0x3364 <main+0x14a>

00003374 <__vector_3>:
    3374:	1f 92       	push	r1

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    3376:	0f 92       	push	r0
    3378:	0f b6       	in	r0, 0x3f	; 63
    337a:	0f 92       	push	r0
    337c:	11 24       	eor	r1, r1
    337e:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    3380:	80 91 1d 1a 	lds	r24, 0x1A1D	; 0x801a1d <gISR_leftWheelTicks>
    3384:	8f 5f       	subi	r24, 0xFF	; 255
    3386:	80 93 1d 1a 	sts	0x1A1D, r24	; 0x801a1d <gISR_leftWheelTicks>
}
    338a:	8f 91       	pop	r24
    338c:	0f 90       	pop	r0
    338e:	0f be       	out	0x3f, r0	; 63
    3390:	0f 90       	pop	r0
    3392:	1f 90       	pop	r1
    3394:	18 95       	reti

00003396 <__vector_4>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    3396:	1f 92       	push	r1
    3398:	0f 92       	push	r0
    339a:	0f b6       	in	r0, 0x3f	; 63
    339c:	0f 92       	push	r0
    339e:	11 24       	eor	r1, r1
    33a0:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    33a2:	80 91 1e 1a 	lds	r24, 0x1A1E	; 0x801a1e <gISR_rightWheelTicks>
    33a6:	8f 5f       	subi	r24, 0xFF	; 255
    33a8:	80 93 1e 1a 	sts	0x1A1E, r24	; 0x801a1e <gISR_rightWheelTicks>
}
    33ac:	8f 91       	pop	r24
    33ae:	0f 90       	pop	r0
    33b0:	0f be       	out	0x3f, r0	; 63
    33b2:	0f 90       	pop	r0
    33b4:	1f 90       	pop	r1
    33b6:	18 95       	reti

000033b8 <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    33b8:	1f 92       	push	r1
    33ba:	0f 92       	push	r0
    33bc:	0f b6       	in	r0, 0x3f	; 63
    33be:	0f 92       	push	r0
    33c0:	11 24       	eor	r1, r1
    33c2:	0b b6       	in	r0, 0x3b	; 59
    33c4:	0f 92       	push	r0
    33c6:	2f 93       	push	r18
    33c8:	3f 93       	push	r19
    33ca:	4f 93       	push	r20
    33cc:	5f 93       	push	r21
    33ce:	6f 93       	push	r22
    33d0:	7f 93       	push	r23
    33d2:	8f 93       	push	r24
    33d4:	9f 93       	push	r25
    33d6:	af 93       	push	r26
    33d8:	bf 93       	push	r27
    33da:	ef 93       	push	r30
    33dc:	ff 93       	push	r31
    if (nRFconnected){
    33de:	64 9b       	sbis	0x0c, 4	; 12
    33e0:	0c c0       	rjmp	.+24     	; 0x33fa <__vector_5+0x42>
        // indicate we are connected
        //vLED_singleHigh(ledGREEN);
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    33e2:	10 92 1c 1a 	sts	0x1A1C, r1	; 0x801a1c <gHandshook>
        gPaused = FALSE;
    33e6:	10 92 1b 1a 	sts	0x1A1B, r1	; 0x801a1b <gPaused>
        //vLED_singleLow(ledGREEN);
        //vLED_singleLow(ledYELLOW);
        //vLED_singleLow(ledRED);
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    33ea:	60 e0       	ldi	r22, 0x00	; 0
    33ec:	70 e0       	ldi	r23, 0x00	; 0
    33ee:	80 91 89 1b 	lds	r24, 0x1B89	; 0x801b89 <xCommandReadyBSem>
    33f2:	90 91 8a 1b 	lds	r25, 0x1B8A	; 0x801b8a <xCommandReadyBSem+0x1>
    33f6:	0e 94 7c 22 	call	0x44f8	; 0x44f8 <xQueueGiveFromISR>
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    33fa:	60 e0       	ldi	r22, 0x00	; 0
    33fc:	70 e0       	ldi	r23, 0x00	; 0
    33fe:	80 91 83 1b 	lds	r24, 0x1B83	; 0x801b83 <xControllerBSem>
    3402:	90 91 84 1b 	lds	r25, 0x1B84	; 0x801b84 <xControllerBSem+0x1>
    3406:	0e 94 7c 22 	call	0x44f8	; 0x44f8 <xQueueGiveFromISR>
}
    340a:	ff 91       	pop	r31
    340c:	ef 91       	pop	r30
    340e:	bf 91       	pop	r27
    3410:	af 91       	pop	r26
    3412:	9f 91       	pop	r25
    3414:	8f 91       	pop	r24
    3416:	7f 91       	pop	r23
    3418:	6f 91       	pop	r22
    341a:	5f 91       	pop	r21
    341c:	4f 91       	pop	r20
    341e:	3f 91       	pop	r19
    3420:	2f 91       	pop	r18
    3422:	0f 90       	pop	r0
    3424:	0b be       	out	0x3b, r0	; 59
    3426:	0f 90       	pop	r0
    3428:	0f be       	out	0x3f, r0	; 63
    342a:	0f 90       	pop	r0
    342c:	1f 90       	pop	r1
    342e:	18 95       	reti

00003430 <vMotor_init>:

void vMotorGlideRight(){
    motorRightPWM = 0;
    //PORTH &= ~(1<<motorRightOn);
    PORTH &= ~(1<<motorRightForward);
    PORTH &= ~(1<<motorRightBackward);
    3430:	e1 e0       	ldi	r30, 0x01	; 1
    3432:	f1 e0       	ldi	r31, 0x01	; 1
    3434:	80 81       	ld	r24, Z
    3436:	80 63       	ori	r24, 0x30	; 48
    3438:	80 83       	st	Z, r24
    343a:	26 9a       	sbi	0x04, 6	; 4
    343c:	84 b1       	in	r24, 0x04	; 4
    343e:	80 66       	ori	r24, 0x60	; 96
    3440:	84 b9       	out	0x04, r24	; 4
    3442:	27 9a       	sbi	0x04, 7	; 4
    3444:	2f 98       	cbi	0x05, 7	; 5
    3446:	2e 98       	cbi	0x05, 6	; 5
    3448:	85 b1       	in	r24, 0x05	; 5
    344a:	8f 79       	andi	r24, 0x9F	; 159
    344c:	85 b9       	out	0x05, r24	; 5
    344e:	e2 e0       	ldi	r30, 0x02	; 2
    3450:	f1 e0       	ldi	r31, 0x01	; 1
    3452:	80 81       	ld	r24, Z
    3454:	8f 7c       	andi	r24, 0xCF	; 207
    3456:	80 83       	st	Z, r24
    3458:	8a b1       	in	r24, 0x0a	; 10
    345a:	8a b9       	out	0x0a, r24	; 10
    345c:	8b b1       	in	r24, 0x0b	; 11
    345e:	8c 60       	ori	r24, 0x0C	; 12
    3460:	8b b9       	out	0x0b, r24	; 11
    3462:	6c 98       	cbi	0x0d, 4	; 13
    3464:	8d b3       	in	r24, 0x1d	; 29
    3466:	8d bb       	out	0x1d, r24	; 29
    3468:	e9 e6       	ldi	r30, 0x69	; 105
    346a:	f0 e0       	ldi	r31, 0x00	; 0
    346c:	80 81       	ld	r24, Z
    346e:	80 6f       	ori	r24, 0xF0	; 240
    3470:	80 83       	st	Z, r24
    3472:	ea e6       	ldi	r30, 0x6A	; 106
    3474:	f0 e0       	ldi	r31, 0x00	; 0
    3476:	80 81       	ld	r24, Z
    3478:	81 60       	ori	r24, 0x01	; 1
    347a:	80 83       	st	Z, r24
    347c:	8c e1       	ldi	r24, 0x1C	; 28
    347e:	8c bb       	out	0x1c, r24	; 28
    3480:	8d b3       	in	r24, 0x1d	; 29
    3482:	8c 61       	ori	r24, 0x1C	; 28
    3484:	8d bb       	out	0x1d, r24	; 29
    3486:	84 b5       	in	r24, 0x24	; 36
    3488:	80 68       	ori	r24, 0x80	; 128
    348a:	84 bd       	out	0x24, r24	; 36
    348c:	e0 e8       	ldi	r30, 0x80	; 128
    348e:	f0 e0       	ldi	r31, 0x00	; 0
    3490:	80 81       	ld	r24, Z
    3492:	80 62       	ori	r24, 0x20	; 32
    3494:	80 83       	st	Z, r24
    3496:	84 b5       	in	r24, 0x24	; 36
    3498:	83 60       	ori	r24, 0x03	; 3
    349a:	84 bd       	out	0x24, r24	; 36
    349c:	85 b5       	in	r24, 0x25	; 37
    349e:	85 bd       	out	0x25, r24	; 37
    34a0:	80 81       	ld	r24, Z
    34a2:	81 60       	ori	r24, 0x01	; 1
    34a4:	80 83       	st	Z, r24
    34a6:	a1 e8       	ldi	r26, 0x81	; 129
    34a8:	b0 e0       	ldi	r27, 0x00	; 0
    34aa:	8c 91       	ld	r24, X
    34ac:	88 60       	ori	r24, 0x08	; 8
    34ae:	8c 93       	st	X, r24
    34b0:	85 b5       	in	r24, 0x25	; 37
    34b2:	85 60       	ori	r24, 0x05	; 5
    34b4:	85 bd       	out	0x25, r24	; 37
    34b6:	8c 91       	ld	r24, X
    34b8:	85 60       	ori	r24, 0x05	; 5
    34ba:	8c 93       	st	X, r24
    34bc:	80 81       	ld	r24, Z
    34be:	80 83       	st	Z, r24
    34c0:	e0 eb       	ldi	r30, 0xB0	; 176
    34c2:	f0 e0       	ldi	r31, 0x00	; 0
    34c4:	80 81       	ld	r24, Z
    34c6:	80 83       	st	Z, r24
    34c8:	80 81       	ld	r24, Z
    34ca:	80 83       	st	Z, r24
    34cc:	e0 ea       	ldi	r30, 0xA0	; 160
    34ce:	f0 e0       	ldi	r31, 0x00	; 0
    34d0:	80 81       	ld	r24, Z
    34d2:	80 83       	st	Z, r24
    34d4:	08 95       	ret

000034d6 <vMotorMoveLeftForward>:
    34d6:	87 bd       	out	0x27, r24	; 39
    34d8:	2c 9a       	sbi	0x05, 4	; 5
    34da:	2d 98       	cbi	0x05, 5	; 5
    34dc:	84 e0       	ldi	r24, 0x04	; 4
    34de:	fb 01       	movw	r30, r22
    34e0:	80 83       	st	Z, r24
    34e2:	08 95       	ret

000034e4 <vMotorMoveRightForward>:
    34e4:	90 e0       	ldi	r25, 0x00	; 0
    34e6:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    34ea:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    34ee:	e2 e0       	ldi	r30, 0x02	; 2
    34f0:	f1 e0       	ldi	r31, 0x01	; 1
    34f2:	80 81       	ld	r24, Z
    34f4:	80 64       	ori	r24, 0x40	; 64
    34f6:	80 83       	st	Z, r24
    34f8:	80 81       	ld	r24, Z
    34fa:	8f 7d       	andi	r24, 0xDF	; 223
    34fc:	80 83       	st	Z, r24
    34fe:	86 e0       	ldi	r24, 0x06	; 6
    3500:	fb 01       	movw	r30, r22
    3502:	80 83       	st	Z, r24
    3504:	08 95       	ret

00003506 <vMotorMoveLeftBackward>:
    3506:	87 bd       	out	0x27, r24	; 39
    3508:	2c 98       	cbi	0x05, 4	; 5
    350a:	2d 9a       	sbi	0x05, 5	; 5
    350c:	85 e0       	ldi	r24, 0x05	; 5
    350e:	fb 01       	movw	r30, r22
    3510:	80 83       	st	Z, r24
    3512:	08 95       	ret

00003514 <vMotorMoveRightBackward>:
    3514:	90 e0       	ldi	r25, 0x00	; 0
    3516:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    351a:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    351e:	e2 e0       	ldi	r30, 0x02	; 2
    3520:	f1 e0       	ldi	r31, 0x01	; 1
    3522:	80 81       	ld	r24, Z
    3524:	8f 7b       	andi	r24, 0xBF	; 191
    3526:	80 83       	st	Z, r24
    3528:	80 81       	ld	r24, Z
    352a:	80 62       	ori	r24, 0x20	; 32
    352c:	80 83       	st	Z, r24
    352e:	85 e0       	ldi	r24, 0x05	; 5
    3530:	fb 01       	movw	r30, r22
    3532:	80 83       	st	Z, r24
    3534:	08 95       	ret

00003536 <vMotorBrakeLeft>:
    3536:	17 bc       	out	0x27, r1	; 39
    3538:	2c 98       	cbi	0x05, 4	; 5
    353a:	2d 98       	cbi	0x05, 5	; 5
    353c:	08 95       	ret

0000353e <vMotorBrakeRight>:
    353e:	10 92 8b 00 	sts	0x008B, r1	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    3542:	10 92 8a 00 	sts	0x008A, r1	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    3546:	e2 e0       	ldi	r30, 0x02	; 2
    3548:	f1 e0       	ldi	r31, 0x01	; 1
    354a:	80 81       	ld	r24, Z
    354c:	8f 7b       	andi	r24, 0xBF	; 191
    354e:	80 83       	st	Z, r24
    3550:	80 81       	ld	r24, Z
    3552:	8f 7d       	andi	r24, 0xDF	; 223
    3554:	80 83       	st	Z, r24
    3556:	08 95       	ret

00003558 <vMotorMovementSwitch>:
}

/* Switch for robot movement to abstract the logic away from main */

void vMotorMovementSwitch(int16_t leftSpeed, int16_t rightSpeed, uint8_t *leftWheelDirection, uint8_t *rightWheelDirection){
    3558:	0f 93       	push	r16
    355a:	1f 93       	push	r17
    355c:	cf 93       	push	r28
    355e:	df 93       	push	r29
    3560:	eb 01       	movw	r28, r22
    3562:	89 01       	movw	r16, r18
    if (leftSpeed > 0){
    3564:	18 16       	cp	r1, r24
    3566:	19 06       	cpc	r1, r25
    3568:	1c f4       	brge	.+6      	; 0x3570 <vMotorMovementSwitch+0x18>
		vMotorMoveLeftForward(leftSpeed, leftWheelDirection);
    356a:	ba 01       	movw	r22, r20
    356c:	b4 df       	rcall	.-152    	; 0x34d6 <vMotorMoveLeftForward>
    356e:	07 c0       	rjmp	.+14     	; 0x357e <vMotorMovementSwitch+0x26>
    }else if(leftSpeed < 0){
    3570:	99 23       	and	r25, r25
    3572:	24 f4       	brge	.+8      	; 0x357c <vMotorMovementSwitch+0x24>
		vMotorMoveLeftBackward(-leftSpeed,leftWheelDirection);
    3574:	ba 01       	movw	r22, r20
    3576:	81 95       	neg	r24
    3578:	c6 df       	rcall	.-116    	; 0x3506 <vMotorMoveLeftBackward>
    }else{
		vMotorBrakeLeft();
    357a:	01 c0       	rjmp	.+2      	; 0x357e <vMotorMovementSwitch+0x26>
    357c:	dc df       	rcall	.-72     	; 0x3536 <vMotorBrakeLeft>
	}
	
	if (rightSpeed > 0) {
    357e:	1c 16       	cp	r1, r28
    3580:	1d 06       	cpc	r1, r29
		vMotorMoveRightForward(rightSpeed,rightWheelDirection);
    3582:	24 f4       	brge	.+8      	; 0x358c <vMotorMovementSwitch+0x34>
    3584:	b8 01       	movw	r22, r16
    3586:	8c 2f       	mov	r24, r28
    3588:	ad df       	rcall	.-166    	; 0x34e4 <vMotorMoveRightForward>
    358a:	08 c0       	rjmp	.+16     	; 0x359c <vMotorMovementSwitch+0x44>
	}else if (rightSpeed < 0) {
    358c:	dd 23       	and	r29, r29
		vMotorMoveRightBackward(-rightSpeed,rightWheelDirection);
    358e:	2c f4       	brge	.+10     	; 0x359a <vMotorMovementSwitch+0x42>
    3590:	b8 01       	movw	r22, r16
    3592:	8c 2f       	mov	r24, r28
    3594:	81 95       	neg	r24
    3596:	be df       	rcall	.-132    	; 0x3514 <vMotorMoveRightBackward>
	}else {
		vMotorBrakeRight();
    3598:	01 c0       	rjmp	.+2      	; 0x359c <vMotorMovementSwitch+0x44>
    359a:	d1 df       	rcall	.-94     	; 0x353e <vMotorBrakeRight>
	}
}
    359c:	df 91       	pop	r29
    359e:	cf 91       	pop	r28
    35a0:	1f 91       	pop	r17
    35a2:	0f 91       	pop	r16
    35a4:	08 95       	ret

000035a6 <vMotorEncoderLeftTickFromISR>:

/* Handle ISR ticks from encoder, Please note that we are losing accuracy here due to division */
void vMotorEncoderLeftTickFromISR(uint8_t wheelDirection, int16_t *leftWheelTicks, uint8_t leftEncoderTicks){
    switch (wheelDirection){
    35a6:	84 30       	cpi	r24, 0x04	; 4
    35a8:	19 f0       	breq	.+6      	; 0x35b0 <vMotorEncoderLeftTickFromISR+0xa>
    35aa:	85 30       	cpi	r24, 0x05	; 5
    35ac:	49 f0       	breq	.+18     	; 0x35c0 <vMotorEncoderLeftTickFromISR+0x1a>
    35ae:	08 95       	ret
        case motorLeftForward:{
            *leftWheelTicks += leftEncoderTicks;
    35b0:	fb 01       	movw	r30, r22
    35b2:	80 81       	ld	r24, Z
    35b4:	91 81       	ldd	r25, Z+1	; 0x01
    35b6:	84 0f       	add	r24, r20
    35b8:	91 1d       	adc	r25, r1
    35ba:	91 83       	std	Z+1, r25	; 0x01
    35bc:	80 83       	st	Z, r24
            break;
    35be:	08 95       	ret
        }
        case  motorLeftBackward:{
            *leftWheelTicks -= leftEncoderTicks;
    35c0:	fb 01       	movw	r30, r22
    35c2:	80 81       	ld	r24, Z
    35c4:	91 81       	ldd	r25, Z+1	; 0x01
    35c6:	84 1b       	sub	r24, r20
    35c8:	91 09       	sbc	r25, r1
    35ca:	91 83       	std	Z+1, r25	; 0x01
    35cc:	80 83       	st	Z, r24
    35ce:	08 95       	ret

000035d0 <vMotorEncoderRightTickFromISR>:
        // We have a count when the robot is supposedly not moving.
        break;
    }
}
void vMotorEncoderRightTickFromISR(uint8_t wheelDirection, int16_t *rightWheelTicks, uint8_t rightEncoderTicks){
    switch (wheelDirection){
    35d0:	85 30       	cpi	r24, 0x05	; 5
    35d2:	51 f0       	breq	.+20     	; 0x35e8 <vMotorEncoderRightTickFromISR+0x18>
    35d4:	86 30       	cpi	r24, 0x06	; 6
    35d6:	79 f4       	brne	.+30     	; 0x35f6 <vMotorEncoderRightTickFromISR+0x26>
        case motorRightForward:{
            *rightWheelTicks += rightEncoderTicks;
    35d8:	fb 01       	movw	r30, r22
    35da:	80 81       	ld	r24, Z
    35dc:	91 81       	ldd	r25, Z+1	; 0x01
    35de:	84 0f       	add	r24, r20
    35e0:	91 1d       	adc	r25, r1
    35e2:	91 83       	std	Z+1, r25	; 0x01
    35e4:	80 83       	st	Z, r24
            break;
    35e6:	08 95       	ret
        }
        case  motorRightBackward:{
            *rightWheelTicks -= rightEncoderTicks;
    35e8:	fb 01       	movw	r30, r22
    35ea:	80 81       	ld	r24, Z
    35ec:	91 81       	ldd	r25, Z+1	; 0x01
    35ee:	84 1b       	sub	r24, r20
    35f0:	91 09       	sbc	r25, r1
    35f2:	91 83       	std	Z+1, r25	; 0x01
    35f4:	80 83       	st	Z, r24
    35f6:	08 95       	ret

000035f8 <network_receive>:

uint8_t network_get_address(void) {
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint8_t len) {
    35f8:	ef 92       	push	r14
    35fa:	ff 92       	push	r15
    35fc:	0f 93       	push	r16
    35fe:	1f 93       	push	r17
    3600:	cf 93       	push	r28
    3602:	df 93       	push	r29
    3604:	7c 01       	movw	r14, r24
	uint8_t *decoded_data = pvPortMalloc(len);
    3606:	c6 2f       	mov	r28, r22
    3608:	d0 e0       	ldi	r29, 0x00	; 0
    360a:	ce 01       	movw	r24, r28
    360c:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3610:	8c 01       	movw	r16, r24
	cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    3612:	9e 01       	movw	r18, r28
    3614:	21 50       	subi	r18, 0x01	; 1
    3616:	31 09       	sbc	r19, r1
    3618:	a7 01       	movw	r20, r14
    361a:	be 01       	movw	r22, r28
    361c:	0e 94 04 07 	call	0xe08	; 0xe08 <cobs_decode>
	
	if(result.status != COBS_DECODE_OK) {
    3620:	88 23       	and	r24, r24
    3622:	21 f0       	breq	.+8      	; 0x362c <network_receive+0x34>
		vPortFree(decoded_data);
    3624:	c8 01       	movw	r24, r16
    3626:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
		return;
    362a:	33 c0       	rjmp	.+102    	; 0x3692 <network_receive+0x9a>
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint8_t len) {
	uint8_t *decoded_data = pvPortMalloc(len);
	cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    362c:	86 2f       	mov	r24, r22
    362e:	97 2f       	mov	r25, r23
    3630:	ec 01       	movw	r28, r24
	
	if(result.status != COBS_DECODE_OK) {
		vPortFree(decoded_data);
		return;
	}
	if(decoded_data[result.out_len-1] != calculate_crc(decoded_data, result.out_len-1) ) {
    3632:	f8 01       	movw	r30, r16
    3634:	e8 0f       	add	r30, r24
    3636:	f9 1f       	adc	r31, r25
    3638:	31 97       	sbiw	r30, 0x01	; 1
    363a:	f0 80       	ld	r15, Z
    363c:	6f ef       	ldi	r22, 0xFF	; 255
    363e:	68 0f       	add	r22, r24
    3640:	c8 01       	movw	r24, r16
    3642:	0e 94 8e 07 	call	0xf1c	; 0xf1c <calculate_crc>
    3646:	f8 16       	cp	r15, r24
    3648:	21 f0       	breq	.+8      	; 0x3652 <network_receive+0x5a>
		vPortFree(decoded_data);
    364a:	c8 01       	movw	r24, r16
    364c:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
		return;
    3650:	20 c0       	rjmp	.+64     	; 0x3692 <network_receive+0x9a>
	}
	uint8_t receiver = decoded_data[0];
	uint8_t sender = decoded_data[1];
	uint8_t protocol = decoded_data[2];
	if(receiver != ADDRESS) {
    3652:	d8 01       	movw	r26, r16
    3654:	8c 91       	ld	r24, X
    3656:	83 30       	cpi	r24, 0x03	; 3
    3658:	21 f0       	breq	.+8      	; 0x3662 <network_receive+0x6a>
		vPortFree(decoded_data);
    365a:	c8 01       	movw	r24, r16
    365c:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
		return;
    3660:	18 c0       	rjmp	.+48     	; 0x3692 <network_receive+0x9a>
	}
	receive_callbacks[protocol](sender, decoded_data+3, result.out_len-4);
    3662:	ae 01       	movw	r20, r28
    3664:	44 50       	subi	r20, 0x04	; 4
    3666:	51 09       	sbc	r21, r1
    3668:	b8 01       	movw	r22, r16
    366a:	6d 5f       	subi	r22, 0xFD	; 253
    366c:	7f 4f       	sbci	r23, 0xFF	; 255
    366e:	d8 01       	movw	r26, r16
    3670:	12 96       	adiw	r26, 0x02	; 2
    3672:	ec 91       	ld	r30, X
    3674:	12 97       	sbiw	r26, 0x02	; 2
    3676:	f0 e0       	ldi	r31, 0x00	; 0
    3678:	ee 0f       	add	r30, r30
    367a:	ff 1f       	adc	r31, r31
    367c:	e9 55       	subi	r30, 0x59	; 89
    367e:	f4 4e       	sbci	r31, 0xE4	; 228
    3680:	01 90       	ld	r0, Z+
    3682:	f0 81       	ld	r31, Z
    3684:	e0 2d       	mov	r30, r0
    3686:	11 96       	adiw	r26, 0x01	; 1
    3688:	8c 91       	ld	r24, X
    368a:	19 95       	eicall
	vPortFree(decoded_data);
    368c:	c8 01       	movw	r24, r16
    368e:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
}
    3692:	df 91       	pop	r29
    3694:	cf 91       	pop	r28
    3696:	1f 91       	pop	r17
    3698:	0f 91       	pop	r16
    369a:	ff 90       	pop	r15
    369c:	ef 90       	pop	r14
    369e:	08 95       	ret

000036a0 <network_init>:
void network_receive(uint8_t *frame, uint8_t len);

void (*receive_callbacks[10])(uint8_t, uint8_t*, uint16_t);

void network_init(void) {
  vUSART_set_receive_callback(network_receive);
    36a0:	8c ef       	ldi	r24, 0xFC	; 252
    36a2:	9a e1       	ldi	r25, 0x1A	; 26
    36a4:	0c 94 c6 33 	jmp	0x678c	; 0x678c <vUSART_set_receive_callback>
    36a8:	08 95       	ret

000036aa <network_set_callback>:
}

void network_set_callback(uint8_t protocol, void (*cb)(uint8_t, uint8_t*, uint16_t)) {
  if(protocol == PROTOCOL_ARQ || protocol == PROTOCOL_SIMPLE) receive_callbacks[protocol] = cb;
    36aa:	82 30       	cpi	r24, 0x02	; 2
    36ac:	40 f4       	brcc	.+16     	; 0x36be <network_set_callback+0x14>
    36ae:	e8 2f       	mov	r30, r24
    36b0:	f0 e0       	ldi	r31, 0x00	; 0
    36b2:	ee 0f       	add	r30, r30
    36b4:	ff 1f       	adc	r31, r31
    36b6:	e9 55       	subi	r30, 0x59	; 89
    36b8:	f4 4e       	sbci	r31, 0xE4	; 228
    36ba:	71 83       	std	Z+1, r23	; 0x01
    36bc:	60 83       	st	Z, r22
    36be:	08 95       	ret

000036c0 <network_send>:
}
    
uint8_t network_send(uint8_t remote_address, uint8_t protocol, uint8_t *data, uint16_t len) {
    36c0:	8f 92       	push	r8
    36c2:	9f 92       	push	r9
    36c4:	af 92       	push	r10
    36c6:	bf 92       	push	r11
    36c8:	cf 92       	push	r12
    36ca:	df 92       	push	r13
    36cc:	ef 92       	push	r14
    36ce:	ff 92       	push	r15
    36d0:	0f 93       	push	r16
    36d2:	1f 93       	push	r17
    36d4:	cf 93       	push	r28
    36d6:	df 93       	push	r29
    36d8:	88 2e       	mov	r8, r24
    36da:	96 2e       	mov	r9, r22
    36dc:	5a 01       	movw	r10, r20
    36de:	89 01       	movw	r16, r18
  uint8_t *packet = pvPortMalloc(len+4);
    36e0:	69 01       	movw	r12, r18
    36e2:	84 e0       	ldi	r24, 0x04	; 4
    36e4:	c8 0e       	add	r12, r24
    36e6:	d1 1c       	adc	r13, r1
    36e8:	c6 01       	movw	r24, r12
    36ea:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    36ee:	ec 01       	movw	r28, r24
  uint8_t *encoded_data = pvPortMalloc(len+6);
    36f0:	c8 01       	movw	r24, r16
    36f2:	06 96       	adiw	r24, 0x06	; 6
    36f4:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    36f8:	7c 01       	movw	r14, r24
  if(packet == NULL || encoded_data == NULL) {
    36fa:	20 97       	sbiw	r28, 0x00	; 0
    36fc:	11 f0       	breq	.+4      	; 0x3702 <network_send+0x42>
    36fe:	89 2b       	or	r24, r25
    3700:	41 f4       	brne	.+16     	; 0x3712 <network_send+0x52>
    vPortFree(packet);
    3702:	ce 01       	movw	r24, r28
    3704:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    vPortFree(encoded_data);
    3708:	c7 01       	movw	r24, r14
    370a:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    return 0;
    370e:	80 e0       	ldi	r24, 0x00	; 0
    3710:	3c c0       	rjmp	.+120    	; 0x378a <network_send+0xca>
  }
  packet[0] = remote_address;
    3712:	88 82       	st	Y, r8
  packet[1] = ADDRESS;
    3714:	83 e0       	ldi	r24, 0x03	; 3
    3716:	89 83       	std	Y+1, r24	; 0x01
  packet[2] = protocol;
    3718:	9a 82       	std	Y+2, r9	; 0x02
  memcpy(packet+3, data, len);
    371a:	a8 01       	movw	r20, r16
    371c:	b5 01       	movw	r22, r10
    371e:	ce 01       	movw	r24, r28
    3720:	03 96       	adiw	r24, 0x03	; 3
    3722:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
  packet[3+len] = calculate_crc(packet, 3+len);
    3726:	58 01       	movw	r10, r16
    3728:	e3 e0       	ldi	r30, 0x03	; 3
    372a:	ae 0e       	add	r10, r30
    372c:	b1 1c       	adc	r11, r1
    372e:	ac 0e       	add	r10, r28
    3730:	bd 1e       	adc	r11, r29
    3732:	63 e0       	ldi	r22, 0x03	; 3
    3734:	60 0f       	add	r22, r16
    3736:	ce 01       	movw	r24, r28
    3738:	0e 94 8e 07 	call	0xf1c	; 0xf1c <calculate_crc>
    373c:	f5 01       	movw	r30, r10
    373e:	80 83       	st	Z, r24
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    3740:	b8 01       	movw	r22, r16
    3742:	6b 5f       	subi	r22, 0xFB	; 251
    3744:	7f 4f       	sbci	r23, 0xFF	; 255
    3746:	96 01       	movw	r18, r12
    3748:	ae 01       	movw	r20, r28
    374a:	c7 01       	movw	r24, r14
    374c:	0e 94 9e 06 	call	0xd3c	; 0xd3c <cobs_encode>
  if(result.status != COBS_ENCODE_OK) {
    3750:	88 23       	and	r24, r24
    3752:	41 f0       	breq	.+16     	; 0x3764 <network_send+0xa4>
    vPortFree(packet);
    3754:	ce 01       	movw	r24, r28
    3756:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    vPortFree(encoded_data);
    375a:	c7 01       	movw	r24, r14
    375c:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    return 0;
    3760:	80 e0       	ldi	r24, 0x00	; 0
    3762:	13 c0       	rjmp	.+38     	; 0x378a <network_send+0xca>
  packet[0] = remote_address;
  packet[1] = ADDRESS;
  packet[2] = protocol;
  memcpy(packet+3, data, len);
  packet[3+len] = calculate_crc(packet, 3+len);
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    3764:	86 2f       	mov	r24, r22
    3766:	97 2f       	mov	r25, r23
  if(result.status != COBS_ENCODE_OK) {
    vPortFree(packet);
    vPortFree(encoded_data);
    return 0;
  }
  encoded_data[result.out_len] = 0x00;
    3768:	f7 01       	movw	r30, r14
    376a:	e8 0f       	add	r30, r24
    376c:	f9 1f       	adc	r31, r25
    376e:	10 82       	st	Z, r1
  vUSART_send(encoded_data, result.out_len+1);
    3770:	bc 01       	movw	r22, r24
    3772:	6f 5f       	subi	r22, 0xFF	; 255
    3774:	7f 4f       	sbci	r23, 0xFF	; 255
    3776:	c7 01       	movw	r24, r14
    3778:	0e 94 a2 33 	call	0x6744	; 0x6744 <vUSART_send>
  vPortFree(packet);
    377c:	ce 01       	movw	r24, r28
    377e:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  vPortFree(encoded_data);
    3782:	c7 01       	movw	r24, r14
    3784:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  return 1;
    3788:	81 e0       	ldi	r24, 0x01	; 1
}
    378a:	df 91       	pop	r29
    378c:	cf 91       	pop	r28
    378e:	1f 91       	pop	r17
    3790:	0f 91       	pop	r16
    3792:	ff 90       	pop	r15
    3794:	ef 90       	pop	r14
    3796:	df 90       	pop	r13
    3798:	cf 90       	pop	r12
    379a:	bf 90       	pop	r11
    379c:	af 90       	pop	r10
    379e:	9f 90       	pop	r9
    37a0:	8f 90       	pop	r8
    37a2:	08 95       	ret

000037a4 <pxPortInitialiseStack>:
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    37a4:	31 e1       	ldi	r19, 0x11	; 17
    37a6:	fc 01       	movw	r30, r24
    37a8:	30 83       	st	Z, r19
    37aa:	31 97       	sbiw	r30, 0x01	; 1
    37ac:	22 e2       	ldi	r18, 0x22	; 34
    37ae:	20 83       	st	Z, r18
    37b0:	31 97       	sbiw	r30, 0x01	; 1
    37b2:	a3 e3       	ldi	r26, 0x33	; 51
    37b4:	a0 83       	st	Z, r26
    37b6:	31 97       	sbiw	r30, 0x01	; 1
    37b8:	60 83       	st	Z, r22
    37ba:	31 97       	sbiw	r30, 0x01	; 1
    37bc:	70 83       	st	Z, r23
    37be:	31 97       	sbiw	r30, 0x01	; 1
    37c0:	10 82       	st	Z, r1
    37c2:	31 97       	sbiw	r30, 0x01	; 1
    37c4:	10 82       	st	Z, r1
    37c6:	31 97       	sbiw	r30, 0x01	; 1
    37c8:	60 e8       	ldi	r22, 0x80	; 128
    37ca:	60 83       	st	Z, r22
    37cc:	31 97       	sbiw	r30, 0x01	; 1
    37ce:	10 82       	st	Z, r1
    37d0:	31 97       	sbiw	r30, 0x01	; 1
    37d2:	10 82       	st	Z, r1
    37d4:	31 97       	sbiw	r30, 0x01	; 1
    37d6:	10 82       	st	Z, r1
    37d8:	31 97       	sbiw	r30, 0x01	; 1
    37da:	62 e0       	ldi	r22, 0x02	; 2
    37dc:	60 83       	st	Z, r22
    37de:	31 97       	sbiw	r30, 0x01	; 1
    37e0:	63 e0       	ldi	r22, 0x03	; 3
    37e2:	60 83       	st	Z, r22
    37e4:	31 97       	sbiw	r30, 0x01	; 1
    37e6:	64 e0       	ldi	r22, 0x04	; 4
    37e8:	60 83       	st	Z, r22
    37ea:	31 97       	sbiw	r30, 0x01	; 1
    37ec:	65 e0       	ldi	r22, 0x05	; 5
    37ee:	60 83       	st	Z, r22
    37f0:	31 97       	sbiw	r30, 0x01	; 1
    37f2:	66 e0       	ldi	r22, 0x06	; 6
    37f4:	60 83       	st	Z, r22
    37f6:	31 97       	sbiw	r30, 0x01	; 1
    37f8:	67 e0       	ldi	r22, 0x07	; 7
    37fa:	60 83       	st	Z, r22
    37fc:	31 97       	sbiw	r30, 0x01	; 1
    37fe:	68 e0       	ldi	r22, 0x08	; 8
    3800:	60 83       	st	Z, r22
    3802:	31 97       	sbiw	r30, 0x01	; 1
    3804:	69 e0       	ldi	r22, 0x09	; 9
    3806:	60 83       	st	Z, r22
    3808:	31 97       	sbiw	r30, 0x01	; 1
    380a:	60 e1       	ldi	r22, 0x10	; 16
    380c:	60 83       	st	Z, r22
    380e:	31 97       	sbiw	r30, 0x01	; 1
    3810:	30 83       	st	Z, r19
    3812:	31 97       	sbiw	r30, 0x01	; 1
    3814:	32 e1       	ldi	r19, 0x12	; 18
    3816:	30 83       	st	Z, r19
    3818:	31 97       	sbiw	r30, 0x01	; 1
    381a:	33 e1       	ldi	r19, 0x13	; 19
    381c:	30 83       	st	Z, r19
    381e:	31 97       	sbiw	r30, 0x01	; 1
    3820:	34 e1       	ldi	r19, 0x14	; 20
    3822:	30 83       	st	Z, r19
    3824:	31 97       	sbiw	r30, 0x01	; 1
    3826:	35 e1       	ldi	r19, 0x15	; 21
    3828:	30 83       	st	Z, r19
    382a:	31 97       	sbiw	r30, 0x01	; 1
    382c:	36 e1       	ldi	r19, 0x16	; 22
    382e:	30 83       	st	Z, r19
    3830:	31 97       	sbiw	r30, 0x01	; 1
    3832:	37 e1       	ldi	r19, 0x17	; 23
    3834:	30 83       	st	Z, r19
    3836:	31 97       	sbiw	r30, 0x01	; 1
    3838:	38 e1       	ldi	r19, 0x18	; 24
    383a:	30 83       	st	Z, r19
    383c:	31 97       	sbiw	r30, 0x01	; 1
    383e:	39 e1       	ldi	r19, 0x19	; 25
    3840:	30 83       	st	Z, r19
    3842:	31 97       	sbiw	r30, 0x01	; 1
    3844:	30 e2       	ldi	r19, 0x20	; 32
    3846:	30 83       	st	Z, r19
    3848:	31 97       	sbiw	r30, 0x01	; 1
    384a:	31 e2       	ldi	r19, 0x21	; 33
    384c:	30 83       	st	Z, r19
    384e:	31 97       	sbiw	r30, 0x01	; 1
    3850:	20 83       	st	Z, r18
    3852:	31 97       	sbiw	r30, 0x01	; 1
    3854:	23 e2       	ldi	r18, 0x23	; 35
    3856:	20 83       	st	Z, r18
    3858:	31 97       	sbiw	r30, 0x01	; 1
    385a:	40 83       	st	Z, r20
    385c:	31 97       	sbiw	r30, 0x01	; 1
    385e:	50 83       	st	Z, r21
    3860:	31 97       	sbiw	r30, 0x01	; 1
    3862:	26 e2       	ldi	r18, 0x26	; 38
    3864:	20 83       	st	Z, r18
    3866:	31 97       	sbiw	r30, 0x01	; 1
    3868:	27 e2       	ldi	r18, 0x27	; 39
    386a:	20 83       	st	Z, r18
    386c:	31 97       	sbiw	r30, 0x01	; 1
    386e:	28 e2       	ldi	r18, 0x28	; 40
    3870:	20 83       	st	Z, r18
    3872:	31 97       	sbiw	r30, 0x01	; 1
    3874:	29 e2       	ldi	r18, 0x29	; 41
    3876:	20 83       	st	Z, r18
    3878:	31 97       	sbiw	r30, 0x01	; 1
    387a:	20 e3       	ldi	r18, 0x30	; 48
    387c:	20 83       	st	Z, r18
    387e:	31 97       	sbiw	r30, 0x01	; 1
    3880:	21 e3       	ldi	r18, 0x31	; 49
    3882:	20 83       	st	Z, r18
    3884:	89 97       	sbiw	r24, 0x29	; 41
    3886:	08 95       	ret

00003888 <xPortStartScheduler>:
    3888:	88 ee       	ldi	r24, 0xE8	; 232
    388a:	93 e0       	ldi	r25, 0x03	; 3
    388c:	90 93 bc 1b 	sts	0x1BBC, r25	; 0x801bbc <portTickRateHz+0x1>
    3890:	80 93 bb 1b 	sts	0x1BBB, r24	; 0x801bbb <portTickRateHz>
    3894:	90 93 be 1b 	sts	0x1BBE, r25	; 0x801bbe <ticksRemainingInSec+0x1>
    3898:	80 93 bd 1b 	sts	0x1BBD, r24	; 0x801bbd <ticksRemainingInSec>
    389c:	10 92 99 00 	sts	0x0099, r1	; 0x800099 <__TEXT_REGION_LENGTH__+0x700099>
    38a0:	89 ef       	ldi	r24, 0xF9	; 249
    38a2:	80 93 98 00 	sts	0x0098, r24	; 0x800098 <__TEXT_REGION_LENGTH__+0x700098>
    38a6:	8b e0       	ldi	r24, 0x0B	; 11
    38a8:	80 93 91 00 	sts	0x0091, r24	; 0x800091 <__TEXT_REGION_LENGTH__+0x700091>
    38ac:	e1 e7       	ldi	r30, 0x71	; 113
    38ae:	f0 e0       	ldi	r31, 0x00	; 0
    38b0:	80 81       	ld	r24, Z
    38b2:	82 60       	ori	r24, 0x02	; 2
    38b4:	80 83       	st	Z, r24
    38b6:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    38ba:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    38be:	cd 91       	ld	r28, X+
    38c0:	cd bf       	out	0x3d, r28	; 61
    38c2:	dd 91       	ld	r29, X+
    38c4:	de bf       	out	0x3e, r29	; 62
    38c6:	ff 91       	pop	r31
    38c8:	ef 91       	pop	r30
    38ca:	df 91       	pop	r29
    38cc:	cf 91       	pop	r28
    38ce:	bf 91       	pop	r27
    38d0:	af 91       	pop	r26
    38d2:	9f 91       	pop	r25
    38d4:	8f 91       	pop	r24
    38d6:	7f 91       	pop	r23
    38d8:	6f 91       	pop	r22
    38da:	5f 91       	pop	r21
    38dc:	4f 91       	pop	r20
    38de:	3f 91       	pop	r19
    38e0:	2f 91       	pop	r18
    38e2:	1f 91       	pop	r17
    38e4:	0f 91       	pop	r16
    38e6:	ff 90       	pop	r15
    38e8:	ef 90       	pop	r14
    38ea:	df 90       	pop	r13
    38ec:	cf 90       	pop	r12
    38ee:	bf 90       	pop	r11
    38f0:	af 90       	pop	r10
    38f2:	9f 90       	pop	r9
    38f4:	8f 90       	pop	r8
    38f6:	7f 90       	pop	r7
    38f8:	6f 90       	pop	r6
    38fa:	5f 90       	pop	r5
    38fc:	4f 90       	pop	r4
    38fe:	3f 90       	pop	r3
    3900:	2f 90       	pop	r2
    3902:	1f 90       	pop	r1
    3904:	0f 90       	pop	r0
    3906:	0c be       	out	0x3c, r0	; 60
    3908:	0f 90       	pop	r0
    390a:	0b be       	out	0x3b, r0	; 59
    390c:	0f 90       	pop	r0
    390e:	0f be       	out	0x3f, r0	; 63
    3910:	0f 90       	pop	r0
    3912:	08 95       	ret
    3914:	81 e0       	ldi	r24, 0x01	; 1
    3916:	08 95       	ret

00003918 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    3918:	0f 92       	push	r0
    391a:	0f b6       	in	r0, 0x3f	; 63
    391c:	f8 94       	cli
    391e:	0f 92       	push	r0
    3920:	0b b6       	in	r0, 0x3b	; 59
    3922:	0f 92       	push	r0
    3924:	0c b6       	in	r0, 0x3c	; 60
    3926:	0f 92       	push	r0
    3928:	1f 92       	push	r1
    392a:	11 24       	eor	r1, r1
    392c:	2f 92       	push	r2
    392e:	3f 92       	push	r3
    3930:	4f 92       	push	r4
    3932:	5f 92       	push	r5
    3934:	6f 92       	push	r6
    3936:	7f 92       	push	r7
    3938:	8f 92       	push	r8
    393a:	9f 92       	push	r9
    393c:	af 92       	push	r10
    393e:	bf 92       	push	r11
    3940:	cf 92       	push	r12
    3942:	df 92       	push	r13
    3944:	ef 92       	push	r14
    3946:	ff 92       	push	r15
    3948:	0f 93       	push	r16
    394a:	1f 93       	push	r17
    394c:	2f 93       	push	r18
    394e:	3f 93       	push	r19
    3950:	4f 93       	push	r20
    3952:	5f 93       	push	r21
    3954:	6f 93       	push	r22
    3956:	7f 93       	push	r23
    3958:	8f 93       	push	r24
    395a:	9f 93       	push	r25
    395c:	af 93       	push	r26
    395e:	bf 93       	push	r27
    3960:	cf 93       	push	r28
    3962:	df 93       	push	r29
    3964:	ef 93       	push	r30
    3966:	ff 93       	push	r31
    3968:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    396c:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    3970:	0d b6       	in	r0, 0x3d	; 61
    3972:	0d 92       	st	X+, r0
    3974:	0e b6       	in	r0, 0x3e	; 62
    3976:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    3978:	0e 94 23 2e 	call	0x5c46	; 0x5c46 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    397c:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    3980:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    3984:	cd 91       	ld	r28, X+
    3986:	cd bf       	out	0x3d, r28	; 61
    3988:	dd 91       	ld	r29, X+
    398a:	de bf       	out	0x3e, r29	; 62
    398c:	ff 91       	pop	r31
    398e:	ef 91       	pop	r30
    3990:	df 91       	pop	r29
    3992:	cf 91       	pop	r28
    3994:	bf 91       	pop	r27
    3996:	af 91       	pop	r26
    3998:	9f 91       	pop	r25
    399a:	8f 91       	pop	r24
    399c:	7f 91       	pop	r23
    399e:	6f 91       	pop	r22
    39a0:	5f 91       	pop	r21
    39a2:	4f 91       	pop	r20
    39a4:	3f 91       	pop	r19
    39a6:	2f 91       	pop	r18
    39a8:	1f 91       	pop	r17
    39aa:	0f 91       	pop	r16
    39ac:	ff 90       	pop	r15
    39ae:	ef 90       	pop	r14
    39b0:	df 90       	pop	r13
    39b2:	cf 90       	pop	r12
    39b4:	bf 90       	pop	r11
    39b6:	af 90       	pop	r10
    39b8:	9f 90       	pop	r9
    39ba:	8f 90       	pop	r8
    39bc:	7f 90       	pop	r7
    39be:	6f 90       	pop	r6
    39c0:	5f 90       	pop	r5
    39c2:	4f 90       	pop	r4
    39c4:	3f 90       	pop	r3
    39c6:	2f 90       	pop	r2
    39c8:	1f 90       	pop	r1
    39ca:	0f 90       	pop	r0
    39cc:	0c be       	out	0x3c, r0	; 60
    39ce:	0f 90       	pop	r0
    39d0:	0b be       	out	0x3b, r0	; 59
    39d2:	0f 90       	pop	r0
    39d4:	0f be       	out	0x3f, r0	; 63
    39d6:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    39d8:	08 95       	ret

000039da <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    39da:	0f 92       	push	r0
    39dc:	0f b6       	in	r0, 0x3f	; 63
    39de:	f8 94       	cli
    39e0:	0f 92       	push	r0
    39e2:	0b b6       	in	r0, 0x3b	; 59
    39e4:	0f 92       	push	r0
    39e6:	0c b6       	in	r0, 0x3c	; 60
    39e8:	0f 92       	push	r0
    39ea:	1f 92       	push	r1
    39ec:	11 24       	eor	r1, r1
    39ee:	2f 92       	push	r2
    39f0:	3f 92       	push	r3
    39f2:	4f 92       	push	r4
    39f4:	5f 92       	push	r5
    39f6:	6f 92       	push	r6
    39f8:	7f 92       	push	r7
    39fa:	8f 92       	push	r8
    39fc:	9f 92       	push	r9
    39fe:	af 92       	push	r10
    3a00:	bf 92       	push	r11
    3a02:	cf 92       	push	r12
    3a04:	df 92       	push	r13
    3a06:	ef 92       	push	r14
    3a08:	ff 92       	push	r15
    3a0a:	0f 93       	push	r16
    3a0c:	1f 93       	push	r17
    3a0e:	2f 93       	push	r18
    3a10:	3f 93       	push	r19
    3a12:	4f 93       	push	r20
    3a14:	5f 93       	push	r21
    3a16:	6f 93       	push	r22
    3a18:	7f 93       	push	r23
    3a1a:	8f 93       	push	r24
    3a1c:	9f 93       	push	r25
    3a1e:	af 93       	push	r26
    3a20:	bf 93       	push	r27
    3a22:	cf 93       	push	r28
    3a24:	df 93       	push	r29
    3a26:	ef 93       	push	r30
    3a28:	ff 93       	push	r31
    3a2a:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    3a2e:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    3a32:	0d b6       	in	r0, 0x3d	; 61
    3a34:	0d 92       	st	X+, r0
    3a36:	0e b6       	in	r0, 0x3e	; 62
    3a38:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    3a3a:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    3a3c:	80 91 bd 1b 	lds	r24, 0x1BBD	; 0x801bbd <ticksRemainingInSec>
    3a40:	90 91 be 1b 	lds	r25, 0x1BBE	; 0x801bbe <ticksRemainingInSec+0x1>
    3a44:	01 97       	sbiw	r24, 0x01	; 1
    3a46:	90 93 be 1b 	sts	0x1BBE, r25	; 0x801bbe <ticksRemainingInSec+0x1>
    3a4a:	80 93 bd 1b 	sts	0x1BBD, r24	; 0x801bbd <ticksRemainingInSec>
    3a4e:	89 2b       	or	r24, r25
    3a50:	41 f4       	brne	.+16     	; 0x3a62 <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    3a52:	80 91 bb 1b 	lds	r24, 0x1BBB	; 0x801bbb <portTickRateHz>
    3a56:	90 91 bc 1b 	lds	r25, 0x1BBC	; 0x801bbc <portTickRateHz+0x1>
    3a5a:	90 93 be 1b 	sts	0x1BBE, r25	; 0x801bbe <ticksRemainingInSec+0x1>
    3a5e:	80 93 bd 1b 	sts	0x1BBD, r24	; 0x801bbd <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    3a62:	0e 94 62 2d 	call	0x5ac4	; 0x5ac4 <xTaskIncrementTick>
    3a66:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    3a68:	0e 94 23 2e 	call	0x5c46	; 0x5c46 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    3a6c:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    3a70:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    3a74:	cd 91       	ld	r28, X+
    3a76:	cd bf       	out	0x3d, r28	; 61
    3a78:	dd 91       	ld	r29, X+
    3a7a:	de bf       	out	0x3e, r29	; 62
    3a7c:	ff 91       	pop	r31
    3a7e:	ef 91       	pop	r30
    3a80:	df 91       	pop	r29
    3a82:	cf 91       	pop	r28
    3a84:	bf 91       	pop	r27
    3a86:	af 91       	pop	r26
    3a88:	9f 91       	pop	r25
    3a8a:	8f 91       	pop	r24
    3a8c:	7f 91       	pop	r23
    3a8e:	6f 91       	pop	r22
    3a90:	5f 91       	pop	r21
    3a92:	4f 91       	pop	r20
    3a94:	3f 91       	pop	r19
    3a96:	2f 91       	pop	r18
    3a98:	1f 91       	pop	r17
    3a9a:	0f 91       	pop	r16
    3a9c:	ff 90       	pop	r15
    3a9e:	ef 90       	pop	r14
    3aa0:	df 90       	pop	r13
    3aa2:	cf 90       	pop	r12
    3aa4:	bf 90       	pop	r11
    3aa6:	af 90       	pop	r10
    3aa8:	9f 90       	pop	r9
    3aaa:	8f 90       	pop	r8
    3aac:	7f 90       	pop	r7
    3aae:	6f 90       	pop	r6
    3ab0:	5f 90       	pop	r5
    3ab2:	4f 90       	pop	r4
    3ab4:	3f 90       	pop	r3
    3ab6:	2f 90       	pop	r2
    3ab8:	1f 90       	pop	r1
    3aba:	0f 90       	pop	r0
    3abc:	0c be       	out	0x3c, r0	; 60
    3abe:	0f 90       	pop	r0
    3ac0:	0b be       	out	0x3b, r0	; 59
    3ac2:	0f 90       	pop	r0
    3ac4:	0f be       	out	0x3f, r0	; 63
    3ac6:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    3ac8:	08 95       	ret

00003aca <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    3aca:	87 df       	rcall	.-242    	; 0x39da <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    3acc:	18 95       	reti

00003ace <xQueueGenericCreate>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    3ace:	0f 93       	push	r16
    3ad0:	1f 93       	push	r17
    3ad2:	cf 93       	push	r28
    3ad4:	df 93       	push	r29
    3ad6:	08 2f       	mov	r16, r24
    3ad8:	16 2f       	mov	r17, r22
    3ada:	66 23       	and	r22, r22
    3adc:	09 f4       	brne	.+2      	; 0x3ae0 <xQueueGenericCreate+0x12>
    3ade:	3b c0       	rjmp	.+118    	; 0x3b56 <xQueueGenericCreate+0x88>
    3ae0:	86 9f       	mul	r24, r22
    3ae2:	c0 01       	movw	r24, r0
    3ae4:	11 24       	eor	r1, r1
    3ae6:	80 96       	adiw	r24, 0x20	; 32
    3ae8:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3aec:	ec 01       	movw	r28, r24
    3aee:	00 97       	sbiw	r24, 0x00	; 0
    3af0:	21 f4       	brne	.+8      	; 0x3afa <xQueueGenericCreate+0x2c>
    3af2:	39 c0       	rjmp	.+114    	; 0x3b66 <xQueueGenericCreate+0x98>
    3af4:	d9 83       	std	Y+1, r29	; 0x01
    3af6:	c8 83       	st	Y, r28
    3af8:	03 c0       	rjmp	.+6      	; 0x3b00 <xQueueGenericCreate+0x32>
    3afa:	4f 96       	adiw	r24, 0x1f	; 31
    3afc:	99 83       	std	Y+1, r25	; 0x01
    3afe:	88 83       	st	Y, r24
    3b00:	0b 8f       	std	Y+27, r16	; 0x1b
    3b02:	1c 8f       	std	Y+28, r17	; 0x1c
    3b04:	0f b6       	in	r0, 0x3f	; 63
    3b06:	f8 94       	cli
    3b08:	0f 92       	push	r0
    3b0a:	48 81       	ld	r20, Y
    3b0c:	59 81       	ldd	r21, Y+1	; 0x01
    3b0e:	2c 8d       	ldd	r18, Y+28	; 0x1c
    3b10:	30 e0       	ldi	r19, 0x00	; 0
    3b12:	6b 8d       	ldd	r22, Y+27	; 0x1b
    3b14:	62 9f       	mul	r22, r18
    3b16:	c0 01       	movw	r24, r0
    3b18:	63 9f       	mul	r22, r19
    3b1a:	90 0d       	add	r25, r0
    3b1c:	11 24       	eor	r1, r1
    3b1e:	ba 01       	movw	r22, r20
    3b20:	68 0f       	add	r22, r24
    3b22:	79 1f       	adc	r23, r25
    3b24:	7b 83       	std	Y+3, r23	; 0x03
    3b26:	6a 83       	std	Y+2, r22	; 0x02
    3b28:	1a 8e       	std	Y+26, r1	; 0x1a
    3b2a:	5d 83       	std	Y+5, r21	; 0x05
    3b2c:	4c 83       	std	Y+4, r20	; 0x04
    3b2e:	82 1b       	sub	r24, r18
    3b30:	93 0b       	sbc	r25, r19
    3b32:	84 0f       	add	r24, r20
    3b34:	95 1f       	adc	r25, r21
    3b36:	9f 83       	std	Y+7, r25	; 0x07
    3b38:	8e 83       	std	Y+6, r24	; 0x06
    3b3a:	8f ef       	ldi	r24, 0xFF	; 255
    3b3c:	8d 8f       	std	Y+29, r24	; 0x1d
    3b3e:	8e 8f       	std	Y+30, r24	; 0x1e
    3b40:	ce 01       	movw	r24, r28
    3b42:	08 96       	adiw	r24, 0x08	; 8
    3b44:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    3b48:	ce 01       	movw	r24, r28
    3b4a:	41 96       	adiw	r24, 0x11	; 17
    3b4c:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    3b50:	0f 90       	pop	r0
    3b52:	0f be       	out	0x3f, r0	; 63
    3b54:	08 c0       	rjmp	.+16     	; 0x3b66 <xQueueGenericCreate+0x98>
    3b56:	8f e1       	ldi	r24, 0x1F	; 31
    3b58:	90 e0       	ldi	r25, 0x00	; 0
    3b5a:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3b5e:	ec 01       	movw	r28, r24
    3b60:	89 2b       	or	r24, r25
    3b62:	09 f0       	breq	.+2      	; 0x3b66 <xQueueGenericCreate+0x98>
    3b64:	c7 cf       	rjmp	.-114    	; 0x3af4 <xQueueGenericCreate+0x26>
    3b66:	ce 01       	movw	r24, r28
    3b68:	df 91       	pop	r29
    3b6a:	cf 91       	pop	r28
    3b6c:	1f 91       	pop	r17
    3b6e:	0f 91       	pop	r16
    3b70:	08 95       	ret

00003b72 <xQueueCreateMutex>:
    3b72:	9f 92       	push	r9
    3b74:	af 92       	push	r10
    3b76:	bf 92       	push	r11
    3b78:	cf 92       	push	r12
    3b7a:	df 92       	push	r13
    3b7c:	ef 92       	push	r14
    3b7e:	ff 92       	push	r15
    3b80:	0f 93       	push	r16
    3b82:	1f 93       	push	r17
    3b84:	cf 93       	push	r28
    3b86:	df 93       	push	r29
    3b88:	00 d0       	rcall	.+0      	; 0x3b8a <xQueueCreateMutex+0x18>
    3b8a:	1f 92       	push	r1
    3b8c:	1f 92       	push	r1
    3b8e:	cd b7       	in	r28, 0x3d	; 61
    3b90:	de b7       	in	r29, 0x3e	; 62
    3b92:	8f e1       	ldi	r24, 0x1F	; 31
    3b94:	90 e0       	ldi	r25, 0x00	; 0
    3b96:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    3b9a:	8c 01       	movw	r16, r24
    3b9c:	00 97       	sbiw	r24, 0x00	; 0
    3b9e:	09 f4       	brne	.+2      	; 0x3ba2 <xQueueCreateMutex+0x30>
    3ba0:	58 c1       	rjmp	.+688    	; 0x3e52 <xQueueCreateMutex+0x2e0>
    3ba2:	fc 01       	movw	r30, r24
    3ba4:	13 82       	std	Z+3, r1	; 0x03
    3ba6:	12 82       	std	Z+2, r1	; 0x02
    3ba8:	11 82       	std	Z+1, r1	; 0x01
    3baa:	10 82       	st	Z, r1
    3bac:	15 82       	std	Z+5, r1	; 0x05
    3bae:	14 82       	std	Z+4, r1	; 0x04
    3bb0:	17 82       	std	Z+7, r1	; 0x07
    3bb2:	16 82       	std	Z+6, r1	; 0x06
    3bb4:	12 8e       	std	Z+26, r1	; 0x1a
    3bb6:	81 e0       	ldi	r24, 0x01	; 1
    3bb8:	83 8f       	std	Z+27, r24	; 0x1b
    3bba:	14 8e       	std	Z+28, r1	; 0x1c
    3bbc:	8f ef       	ldi	r24, 0xFF	; 255
    3bbe:	85 8f       	std	Z+29, r24	; 0x1d
    3bc0:	86 8f       	std	Z+30, r24	; 0x1e
    3bc2:	78 01       	movw	r14, r16
    3bc4:	f8 e0       	ldi	r31, 0x08	; 8
    3bc6:	ef 0e       	add	r14, r31
    3bc8:	f1 1c       	adc	r15, r1
    3bca:	c7 01       	movw	r24, r14
    3bcc:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    3bd0:	68 01       	movw	r12, r16
    3bd2:	81 e1       	ldi	r24, 0x11	; 17
    3bd4:	c8 0e       	add	r12, r24
    3bd6:	d1 1c       	adc	r13, r1
    3bd8:	c6 01       	movw	r24, r12
    3bda:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    3bde:	1d 82       	std	Y+5, r1	; 0x05
    3be0:	1c 82       	std	Y+4, r1	; 0x04
    3be2:	a1 2c       	mov	r10, r1
    3be4:	99 24       	eor	r9, r9
    3be6:	93 94       	inc	r9
    3be8:	bb 24       	eor	r11, r11
    3bea:	ba 94       	dec	r11
    3bec:	0f b6       	in	r0, 0x3f	; 63
    3bee:	f8 94       	cli
    3bf0:	0f 92       	push	r0
    3bf2:	f8 01       	movw	r30, r16
    3bf4:	92 8d       	ldd	r25, Z+26	; 0x1a
    3bf6:	83 8d       	ldd	r24, Z+27	; 0x1b
    3bf8:	98 17       	cp	r25, r24
    3bfa:	f0 f4       	brcc	.+60     	; 0x3c38 <xQueueCreateMutex+0xc6>
    3bfc:	80 81       	ld	r24, Z
    3bfe:	91 81       	ldd	r25, Z+1	; 0x01
    3c00:	89 2b       	or	r24, r25
    3c02:	09 f0       	breq	.+2      	; 0x3c06 <xQueueCreateMutex+0x94>
    3c04:	1d c1       	rjmp	.+570    	; 0x3e40 <xQueueCreateMutex+0x2ce>
    3c06:	82 81       	ldd	r24, Z+2	; 0x02
    3c08:	93 81       	ldd	r25, Z+3	; 0x03
    3c0a:	0e 94 ff 2f 	call	0x5ffe	; 0x5ffe <xTaskPriorityDisinherit>
    3c0e:	f8 01       	movw	r30, r16
    3c10:	13 82       	std	Z+3, r1	; 0x03
    3c12:	12 82       	std	Z+2, r1	; 0x02
    3c14:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c16:	9f 5f       	subi	r25, 0xFF	; 255
    3c18:	92 8f       	std	Z+26, r25	; 0x1a
    3c1a:	91 89       	ldd	r25, Z+17	; 0x11
    3c1c:	99 23       	and	r25, r25
    3c1e:	39 f0       	breq	.+14     	; 0x3c2e <xQueueCreateMutex+0xbc>
    3c20:	c6 01       	movw	r24, r12
    3c22:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    3c26:	81 30       	cpi	r24, 0x01	; 1
    3c28:	21 f4       	brne	.+8      	; 0x3c32 <xQueueCreateMutex+0xc0>
    3c2a:	76 de       	rcall	.-788    	; 0x3918 <vPortYield>
    3c2c:	02 c0       	rjmp	.+4      	; 0x3c32 <xQueueCreateMutex+0xc0>
    3c2e:	81 11       	cpse	r24, r1
    3c30:	73 de       	rcall	.-794    	; 0x3918 <vPortYield>
    3c32:	0f 90       	pop	r0
    3c34:	0f be       	out	0x3f, r0	; 63
    3c36:	0d c1       	rjmp	.+538    	; 0x3e52 <xQueueCreateMutex+0x2e0>
    3c38:	8c 81       	ldd	r24, Y+4	; 0x04
    3c3a:	9d 81       	ldd	r25, Y+5	; 0x05
    3c3c:	89 2b       	or	r24, r25
    3c3e:	19 f4       	brne	.+6      	; 0x3c46 <xQueueCreateMutex+0xd4>
    3c40:	0f 90       	pop	r0
    3c42:	0f be       	out	0x3f, r0	; 63
    3c44:	06 c1       	rjmp	.+524    	; 0x3e52 <xQueueCreateMutex+0x2e0>
    3c46:	a1 10       	cpse	r10, r1
    3c48:	05 c0       	rjmp	.+10     	; 0x3c54 <xQueueCreateMutex+0xe2>
    3c4a:	ce 01       	movw	r24, r28
    3c4c:	01 96       	adiw	r24, 0x01	; 1
    3c4e:	0e 94 4e 2f 	call	0x5e9c	; 0x5e9c <vTaskSetTimeOutState>
    3c52:	a9 2c       	mov	r10, r9
    3c54:	0f 90       	pop	r0
    3c56:	0f be       	out	0x3f, r0	; 63
    3c58:	0e 94 17 2c 	call	0x582e	; 0x582e <vTaskSuspendAll>
    3c5c:	0f b6       	in	r0, 0x3f	; 63
    3c5e:	f8 94       	cli
    3c60:	0f 92       	push	r0
    3c62:	f8 01       	movw	r30, r16
    3c64:	85 8d       	ldd	r24, Z+29	; 0x1d
    3c66:	8f 3f       	cpi	r24, 0xFF	; 255
    3c68:	09 f4       	brne	.+2      	; 0x3c6c <xQueueCreateMutex+0xfa>
    3c6a:	15 8e       	std	Z+29, r1	; 0x1d
    3c6c:	f8 01       	movw	r30, r16
    3c6e:	86 8d       	ldd	r24, Z+30	; 0x1e
    3c70:	8f 3f       	cpi	r24, 0xFF	; 255
    3c72:	09 f4       	brne	.+2      	; 0x3c76 <xQueueCreateMutex+0x104>
    3c74:	16 8e       	std	Z+30, r1	; 0x1e
    3c76:	0f 90       	pop	r0
    3c78:	0f be       	out	0x3f, r0	; 63
    3c7a:	be 01       	movw	r22, r28
    3c7c:	6c 5f       	subi	r22, 0xFC	; 252
    3c7e:	7f 4f       	sbci	r23, 0xFF	; 255
    3c80:	ce 01       	movw	r24, r28
    3c82:	01 96       	adiw	r24, 0x01	; 1
    3c84:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <xTaskCheckForTimeOut>
    3c88:	81 11       	cpse	r24, r1
    3c8a:	96 c0       	rjmp	.+300    	; 0x3db8 <xQueueCreateMutex+0x246>
    3c8c:	0f b6       	in	r0, 0x3f	; 63
    3c8e:	f8 94       	cli
    3c90:	0f 92       	push	r0
    3c92:	f8 01       	movw	r30, r16
    3c94:	92 8d       	ldd	r25, Z+26	; 0x1a
    3c96:	83 8d       	ldd	r24, Z+27	; 0x1b
    3c98:	0f 90       	pop	r0
    3c9a:	0f be       	out	0x3f, r0	; 63
    3c9c:	98 13       	cpse	r25, r24
    3c9e:	4a c0       	rjmp	.+148    	; 0x3d34 <xQueueCreateMutex+0x1c2>
    3ca0:	6c 81       	ldd	r22, Y+4	; 0x04
    3ca2:	7d 81       	ldd	r23, Y+5	; 0x05
    3ca4:	c7 01       	movw	r24, r14
    3ca6:	0e 94 ab 2e 	call	0x5d56	; 0x5d56 <vTaskPlaceOnEventList>
    3caa:	0f b6       	in	r0, 0x3f	; 63
    3cac:	f8 94       	cli
    3cae:	0f 92       	push	r0
    3cb0:	f8 01       	movw	r30, r16
    3cb2:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cb4:	18 16       	cp	r1, r24
    3cb6:	ac f4       	brge	.+42     	; 0x3ce2 <xQueueCreateMutex+0x170>
    3cb8:	81 89       	ldd	r24, Z+17	; 0x11
    3cba:	81 11       	cpse	r24, r1
    3cbc:	05 c0       	rjmp	.+10     	; 0x3cc8 <xQueueCreateMutex+0x156>
    3cbe:	11 c0       	rjmp	.+34     	; 0x3ce2 <xQueueCreateMutex+0x170>
    3cc0:	f8 01       	movw	r30, r16
    3cc2:	81 89       	ldd	r24, Z+17	; 0x11
    3cc4:	88 23       	and	r24, r24
    3cc6:	69 f0       	breq	.+26     	; 0x3ce2 <xQueueCreateMutex+0x170>
    3cc8:	c6 01       	movw	r24, r12
    3cca:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    3cce:	81 11       	cpse	r24, r1
    3cd0:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    3cd4:	f8 01       	movw	r30, r16
    3cd6:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cd8:	81 50       	subi	r24, 0x01	; 1
    3cda:	86 8f       	std	Z+30, r24	; 0x1e
    3cdc:	86 8d       	ldd	r24, Z+30	; 0x1e
    3cde:	18 16       	cp	r1, r24
    3ce0:	7c f3       	brlt	.-34     	; 0x3cc0 <xQueueCreateMutex+0x14e>
    3ce2:	f8 01       	movw	r30, r16
    3ce4:	b6 8e       	std	Z+30, r11	; 0x1e
    3ce6:	0f 90       	pop	r0
    3ce8:	0f be       	out	0x3f, r0	; 63
    3cea:	0f b6       	in	r0, 0x3f	; 63
    3cec:	f8 94       	cli
    3cee:	0f 92       	push	r0
    3cf0:	85 8d       	ldd	r24, Z+29	; 0x1d
    3cf2:	18 16       	cp	r1, r24
    3cf4:	ac f4       	brge	.+42     	; 0x3d20 <xQueueCreateMutex+0x1ae>
    3cf6:	80 85       	ldd	r24, Z+8	; 0x08
    3cf8:	81 11       	cpse	r24, r1
    3cfa:	05 c0       	rjmp	.+10     	; 0x3d06 <xQueueCreateMutex+0x194>
    3cfc:	11 c0       	rjmp	.+34     	; 0x3d20 <xQueueCreateMutex+0x1ae>
    3cfe:	f8 01       	movw	r30, r16
    3d00:	80 85       	ldd	r24, Z+8	; 0x08
    3d02:	88 23       	and	r24, r24
    3d04:	69 f0       	breq	.+26     	; 0x3d20 <xQueueCreateMutex+0x1ae>
    3d06:	c7 01       	movw	r24, r14
    3d08:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    3d0c:	81 11       	cpse	r24, r1
    3d0e:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    3d12:	f8 01       	movw	r30, r16
    3d14:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d16:	81 50       	subi	r24, 0x01	; 1
    3d18:	85 8f       	std	Z+29, r24	; 0x1d
    3d1a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d1c:	18 16       	cp	r1, r24
    3d1e:	7c f3       	brlt	.-34     	; 0x3cfe <xQueueCreateMutex+0x18c>
    3d20:	f8 01       	movw	r30, r16
    3d22:	b5 8e       	std	Z+29, r11	; 0x1d
    3d24:	0f 90       	pop	r0
    3d26:	0f be       	out	0x3f, r0	; 63
    3d28:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    3d2c:	81 11       	cpse	r24, r1
    3d2e:	5e cf       	rjmp	.-324    	; 0x3bec <xQueueCreateMutex+0x7a>
    3d30:	f3 dd       	rcall	.-1050   	; 0x3918 <vPortYield>
    3d32:	5c cf       	rjmp	.-328    	; 0x3bec <xQueueCreateMutex+0x7a>
    3d34:	0f b6       	in	r0, 0x3f	; 63
    3d36:	f8 94       	cli
    3d38:	0f 92       	push	r0
    3d3a:	f8 01       	movw	r30, r16
    3d3c:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d3e:	18 16       	cp	r1, r24
    3d40:	ac f4       	brge	.+42     	; 0x3d6c <xQueueCreateMutex+0x1fa>
    3d42:	81 89       	ldd	r24, Z+17	; 0x11
    3d44:	81 11       	cpse	r24, r1
    3d46:	05 c0       	rjmp	.+10     	; 0x3d52 <xQueueCreateMutex+0x1e0>
    3d48:	11 c0       	rjmp	.+34     	; 0x3d6c <xQueueCreateMutex+0x1fa>
    3d4a:	f8 01       	movw	r30, r16
    3d4c:	81 89       	ldd	r24, Z+17	; 0x11
    3d4e:	88 23       	and	r24, r24
    3d50:	69 f0       	breq	.+26     	; 0x3d6c <xQueueCreateMutex+0x1fa>
    3d52:	c6 01       	movw	r24, r12
    3d54:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    3d58:	81 11       	cpse	r24, r1
    3d5a:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    3d5e:	f8 01       	movw	r30, r16
    3d60:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d62:	81 50       	subi	r24, 0x01	; 1
    3d64:	86 8f       	std	Z+30, r24	; 0x1e
    3d66:	86 8d       	ldd	r24, Z+30	; 0x1e
    3d68:	18 16       	cp	r1, r24
    3d6a:	7c f3       	brlt	.-34     	; 0x3d4a <xQueueCreateMutex+0x1d8>
    3d6c:	f8 01       	movw	r30, r16
    3d6e:	b6 8e       	std	Z+30, r11	; 0x1e
    3d70:	0f 90       	pop	r0
    3d72:	0f be       	out	0x3f, r0	; 63
    3d74:	0f b6       	in	r0, 0x3f	; 63
    3d76:	f8 94       	cli
    3d78:	0f 92       	push	r0
    3d7a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3d7c:	18 16       	cp	r1, r24
    3d7e:	ac f4       	brge	.+42     	; 0x3daa <xQueueCreateMutex+0x238>
    3d80:	80 85       	ldd	r24, Z+8	; 0x08
    3d82:	81 11       	cpse	r24, r1
    3d84:	05 c0       	rjmp	.+10     	; 0x3d90 <xQueueCreateMutex+0x21e>
    3d86:	11 c0       	rjmp	.+34     	; 0x3daa <xQueueCreateMutex+0x238>
    3d88:	f8 01       	movw	r30, r16
    3d8a:	80 85       	ldd	r24, Z+8	; 0x08
    3d8c:	88 23       	and	r24, r24
    3d8e:	69 f0       	breq	.+26     	; 0x3daa <xQueueCreateMutex+0x238>
    3d90:	c7 01       	movw	r24, r14
    3d92:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    3d96:	81 11       	cpse	r24, r1
    3d98:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    3d9c:	f8 01       	movw	r30, r16
    3d9e:	85 8d       	ldd	r24, Z+29	; 0x1d
    3da0:	81 50       	subi	r24, 0x01	; 1
    3da2:	85 8f       	std	Z+29, r24	; 0x1d
    3da4:	85 8d       	ldd	r24, Z+29	; 0x1d
    3da6:	18 16       	cp	r1, r24
    3da8:	7c f3       	brlt	.-34     	; 0x3d88 <xQueueCreateMutex+0x216>
    3daa:	f8 01       	movw	r30, r16
    3dac:	b5 8e       	std	Z+29, r11	; 0x1d
    3dae:	0f 90       	pop	r0
    3db0:	0f be       	out	0x3f, r0	; 63
    3db2:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    3db6:	1a cf       	rjmp	.-460    	; 0x3bec <xQueueCreateMutex+0x7a>
    3db8:	0f b6       	in	r0, 0x3f	; 63
    3dba:	f8 94       	cli
    3dbc:	0f 92       	push	r0
    3dbe:	f8 01       	movw	r30, r16
    3dc0:	86 8d       	ldd	r24, Z+30	; 0x1e
    3dc2:	18 16       	cp	r1, r24
    3dc4:	ac f4       	brge	.+42     	; 0x3df0 <xQueueCreateMutex+0x27e>
    3dc6:	81 89       	ldd	r24, Z+17	; 0x11
    3dc8:	81 11       	cpse	r24, r1
    3dca:	05 c0       	rjmp	.+10     	; 0x3dd6 <xQueueCreateMutex+0x264>
    3dcc:	11 c0       	rjmp	.+34     	; 0x3df0 <xQueueCreateMutex+0x27e>
    3dce:	f8 01       	movw	r30, r16
    3dd0:	81 89       	ldd	r24, Z+17	; 0x11
    3dd2:	88 23       	and	r24, r24
    3dd4:	69 f0       	breq	.+26     	; 0x3df0 <xQueueCreateMutex+0x27e>
    3dd6:	c6 01       	movw	r24, r12
    3dd8:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    3ddc:	81 11       	cpse	r24, r1
    3dde:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    3de2:	f8 01       	movw	r30, r16
    3de4:	86 8d       	ldd	r24, Z+30	; 0x1e
    3de6:	81 50       	subi	r24, 0x01	; 1
    3de8:	86 8f       	std	Z+30, r24	; 0x1e
    3dea:	86 8d       	ldd	r24, Z+30	; 0x1e
    3dec:	18 16       	cp	r1, r24
    3dee:	7c f3       	brlt	.-34     	; 0x3dce <xQueueCreateMutex+0x25c>
    3df0:	8f ef       	ldi	r24, 0xFF	; 255
    3df2:	f8 01       	movw	r30, r16
    3df4:	86 8f       	std	Z+30, r24	; 0x1e
    3df6:	0f 90       	pop	r0
    3df8:	0f be       	out	0x3f, r0	; 63
    3dfa:	0f b6       	in	r0, 0x3f	; 63
    3dfc:	f8 94       	cli
    3dfe:	0f 92       	push	r0
    3e00:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e02:	18 16       	cp	r1, r24
    3e04:	ac f4       	brge	.+42     	; 0x3e30 <xQueueCreateMutex+0x2be>
    3e06:	80 85       	ldd	r24, Z+8	; 0x08
    3e08:	81 11       	cpse	r24, r1
    3e0a:	05 c0       	rjmp	.+10     	; 0x3e16 <xQueueCreateMutex+0x2a4>
    3e0c:	11 c0       	rjmp	.+34     	; 0x3e30 <xQueueCreateMutex+0x2be>
    3e0e:	f8 01       	movw	r30, r16
    3e10:	80 85       	ldd	r24, Z+8	; 0x08
    3e12:	88 23       	and	r24, r24
    3e14:	69 f0       	breq	.+26     	; 0x3e30 <xQueueCreateMutex+0x2be>
    3e16:	c7 01       	movw	r24, r14
    3e18:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    3e1c:	81 11       	cpse	r24, r1
    3e1e:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    3e22:	f8 01       	movw	r30, r16
    3e24:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e26:	81 50       	subi	r24, 0x01	; 1
    3e28:	85 8f       	std	Z+29, r24	; 0x1d
    3e2a:	85 8d       	ldd	r24, Z+29	; 0x1d
    3e2c:	18 16       	cp	r1, r24
    3e2e:	7c f3       	brlt	.-34     	; 0x3e0e <xQueueCreateMutex+0x29c>
    3e30:	8f ef       	ldi	r24, 0xFF	; 255
    3e32:	f8 01       	movw	r30, r16
    3e34:	85 8f       	std	Z+29, r24	; 0x1d
    3e36:	0f 90       	pop	r0
    3e38:	0f be       	out	0x3f, r0	; 63
    3e3a:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    3e3e:	09 c0       	rjmp	.+18     	; 0x3e52 <xQueueCreateMutex+0x2e0>
    3e40:	f8 01       	movw	r30, r16
    3e42:	82 8d       	ldd	r24, Z+26	; 0x1a
    3e44:	8f 5f       	subi	r24, 0xFF	; 255
    3e46:	82 8f       	std	Z+26, r24	; 0x1a
    3e48:	81 89       	ldd	r24, Z+17	; 0x11
    3e4a:	88 23       	and	r24, r24
    3e4c:	09 f4       	brne	.+2      	; 0x3e50 <xQueueCreateMutex+0x2de>
    3e4e:	f1 ce       	rjmp	.-542    	; 0x3c32 <xQueueCreateMutex+0xc0>
    3e50:	e7 ce       	rjmp	.-562    	; 0x3c20 <xQueueCreateMutex+0xae>
    3e52:	c8 01       	movw	r24, r16
    3e54:	0f 90       	pop	r0
    3e56:	0f 90       	pop	r0
    3e58:	0f 90       	pop	r0
    3e5a:	0f 90       	pop	r0
    3e5c:	0f 90       	pop	r0
    3e5e:	df 91       	pop	r29
    3e60:	cf 91       	pop	r28
    3e62:	1f 91       	pop	r17
    3e64:	0f 91       	pop	r16
    3e66:	ff 90       	pop	r15
    3e68:	ef 90       	pop	r14
    3e6a:	df 90       	pop	r13
    3e6c:	cf 90       	pop	r12
    3e6e:	bf 90       	pop	r11
    3e70:	af 90       	pop	r10
    3e72:	9f 90       	pop	r9
    3e74:	08 95       	ret

00003e76 <xQueueGenericSend>:
    3e76:	6f 92       	push	r6
    3e78:	7f 92       	push	r7
    3e7a:	8f 92       	push	r8
    3e7c:	9f 92       	push	r9
    3e7e:	af 92       	push	r10
    3e80:	bf 92       	push	r11
    3e82:	cf 92       	push	r12
    3e84:	df 92       	push	r13
    3e86:	ef 92       	push	r14
    3e88:	ff 92       	push	r15
    3e8a:	0f 93       	push	r16
    3e8c:	1f 93       	push	r17
    3e8e:	cf 93       	push	r28
    3e90:	df 93       	push	r29
    3e92:	00 d0       	rcall	.+0      	; 0x3e94 <xQueueGenericSend+0x1e>
    3e94:	1f 92       	push	r1
    3e96:	1f 92       	push	r1
    3e98:	cd b7       	in	r28, 0x3d	; 61
    3e9a:	de b7       	in	r29, 0x3e	; 62
    3e9c:	8c 01       	movw	r16, r24
    3e9e:	5b 01       	movw	r10, r22
    3ea0:	5d 83       	std	Y+5, r21	; 0x05
    3ea2:	4c 83       	std	Y+4, r20	; 0x04
    3ea4:	72 2e       	mov	r7, r18
    3ea6:	81 2c       	mov	r8, r1
    3ea8:	66 24       	eor	r6, r6
    3eaa:	63 94       	inc	r6
    3eac:	99 24       	eor	r9, r9
    3eae:	9a 94       	dec	r9
    3eb0:	7c 01       	movw	r14, r24
    3eb2:	88 e0       	ldi	r24, 0x08	; 8
    3eb4:	e8 0e       	add	r14, r24
    3eb6:	f1 1c       	adc	r15, r1
    3eb8:	68 01       	movw	r12, r16
    3eba:	e1 e1       	ldi	r30, 0x11	; 17
    3ebc:	ce 0e       	add	r12, r30
    3ebe:	d1 1c       	adc	r13, r1
    3ec0:	0f b6       	in	r0, 0x3f	; 63
    3ec2:	f8 94       	cli
    3ec4:	0f 92       	push	r0
    3ec6:	f8 01       	movw	r30, r16
    3ec8:	92 8d       	ldd	r25, Z+26	; 0x1a
    3eca:	83 8d       	ldd	r24, Z+27	; 0x1b
    3ecc:	98 17       	cp	r25, r24
    3ece:	20 f0       	brcs	.+8      	; 0x3ed8 <xQueueGenericSend+0x62>
    3ed0:	f2 e0       	ldi	r31, 0x02	; 2
    3ed2:	7f 12       	cpse	r7, r31
    3ed4:	6e c0       	rjmp	.+220    	; 0x3fb2 <xQueueGenericSend+0x13c>
    3ed6:	7d c1       	rjmp	.+762    	; 0x41d2 <xQueueGenericSend+0x35c>
    3ed8:	f8 01       	movw	r30, r16
    3eda:	44 8d       	ldd	r20, Z+28	; 0x1c
    3edc:	41 11       	cpse	r20, r1
    3ede:	15 c0       	rjmp	.+42     	; 0x3f0a <xQueueGenericSend+0x94>
    3ee0:	f8 01       	movw	r30, r16
    3ee2:	80 81       	ld	r24, Z
    3ee4:	91 81       	ldd	r25, Z+1	; 0x01
    3ee6:	89 2b       	or	r24, r25
    3ee8:	09 f0       	breq	.+2      	; 0x3eec <xQueueGenericSend+0x76>
    3eea:	79 c1       	rjmp	.+754    	; 0x41de <xQueueGenericSend+0x368>
    3eec:	82 81       	ldd	r24, Z+2	; 0x02
    3eee:	93 81       	ldd	r25, Z+3	; 0x03
    3ef0:	0e 94 ff 2f 	call	0x5ffe	; 0x5ffe <xTaskPriorityDisinherit>
    3ef4:	f8 01       	movw	r30, r16
    3ef6:	13 82       	std	Z+3, r1	; 0x03
    3ef8:	12 82       	std	Z+2, r1	; 0x02
    3efa:	92 8d       	ldd	r25, Z+26	; 0x1a
    3efc:	9f 5f       	subi	r25, 0xFF	; 255
    3efe:	92 8f       	std	Z+26, r25	; 0x1a
    3f00:	91 89       	ldd	r25, Z+17	; 0x11
    3f02:	99 23       	and	r25, r25
    3f04:	09 f4       	brne	.+2      	; 0x3f08 <xQueueGenericSend+0x92>
    3f06:	4f c0       	rjmp	.+158    	; 0x3fa6 <xQueueGenericSend+0x130>
    3f08:	46 c0       	rjmp	.+140    	; 0x3f96 <xQueueGenericSend+0x120>
    3f0a:	71 10       	cpse	r7, r1
    3f0c:	1a c0       	rjmp	.+52     	; 0x3f42 <xQueueGenericSend+0xcc>
    3f0e:	50 e0       	ldi	r21, 0x00	; 0
    3f10:	b5 01       	movw	r22, r10
    3f12:	f8 01       	movw	r30, r16
    3f14:	84 81       	ldd	r24, Z+4	; 0x04
    3f16:	95 81       	ldd	r25, Z+5	; 0x05
    3f18:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    3f1c:	f8 01       	movw	r30, r16
    3f1e:	24 8d       	ldd	r18, Z+28	; 0x1c
    3f20:	84 81       	ldd	r24, Z+4	; 0x04
    3f22:	95 81       	ldd	r25, Z+5	; 0x05
    3f24:	82 0f       	add	r24, r18
    3f26:	91 1d       	adc	r25, r1
    3f28:	95 83       	std	Z+5, r25	; 0x05
    3f2a:	84 83       	std	Z+4, r24	; 0x04
    3f2c:	22 81       	ldd	r18, Z+2	; 0x02
    3f2e:	33 81       	ldd	r19, Z+3	; 0x03
    3f30:	82 17       	cp	r24, r18
    3f32:	93 07       	cpc	r25, r19
    3f34:	08 f4       	brcc	.+2      	; 0x3f38 <xQueueGenericSend+0xc2>
    3f36:	53 c1       	rjmp	.+678    	; 0x41de <xQueueGenericSend+0x368>
    3f38:	80 81       	ld	r24, Z
    3f3a:	91 81       	ldd	r25, Z+1	; 0x01
    3f3c:	95 83       	std	Z+5, r25	; 0x05
    3f3e:	84 83       	std	Z+4, r24	; 0x04
    3f40:	4e c1       	rjmp	.+668    	; 0x41de <xQueueGenericSend+0x368>
    3f42:	50 e0       	ldi	r21, 0x00	; 0
    3f44:	b5 01       	movw	r22, r10
    3f46:	f8 01       	movw	r30, r16
    3f48:	86 81       	ldd	r24, Z+6	; 0x06
    3f4a:	97 81       	ldd	r25, Z+7	; 0x07
    3f4c:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    3f50:	f8 01       	movw	r30, r16
    3f52:	84 8d       	ldd	r24, Z+28	; 0x1c
    3f54:	90 e0       	ldi	r25, 0x00	; 0
    3f56:	91 95       	neg	r25
    3f58:	81 95       	neg	r24
    3f5a:	91 09       	sbc	r25, r1
    3f5c:	26 81       	ldd	r18, Z+6	; 0x06
    3f5e:	37 81       	ldd	r19, Z+7	; 0x07
    3f60:	28 0f       	add	r18, r24
    3f62:	39 1f       	adc	r19, r25
    3f64:	37 83       	std	Z+7, r19	; 0x07
    3f66:	26 83       	std	Z+6, r18	; 0x06
    3f68:	40 81       	ld	r20, Z
    3f6a:	51 81       	ldd	r21, Z+1	; 0x01
    3f6c:	24 17       	cp	r18, r20
    3f6e:	35 07       	cpc	r19, r21
    3f70:	30 f4       	brcc	.+12     	; 0x3f7e <xQueueGenericSend+0x108>
    3f72:	22 81       	ldd	r18, Z+2	; 0x02
    3f74:	33 81       	ldd	r19, Z+3	; 0x03
    3f76:	82 0f       	add	r24, r18
    3f78:	93 1f       	adc	r25, r19
    3f7a:	97 83       	std	Z+7, r25	; 0x07
    3f7c:	86 83       	std	Z+6, r24	; 0x06
    3f7e:	f2 e0       	ldi	r31, 0x02	; 2
    3f80:	7f 12       	cpse	r7, r31
    3f82:	2d c1       	rjmp	.+602    	; 0x41de <xQueueGenericSend+0x368>
    3f84:	f8 01       	movw	r30, r16
    3f86:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f88:	88 23       	and	r24, r24
    3f8a:	09 f4       	brne	.+2      	; 0x3f8e <xQueueGenericSend+0x118>
    3f8c:	28 c1       	rjmp	.+592    	; 0x41de <xQueueGenericSend+0x368>
    3f8e:	82 8d       	ldd	r24, Z+26	; 0x1a
    3f90:	81 50       	subi	r24, 0x01	; 1
    3f92:	82 8f       	std	Z+26, r24	; 0x1a
    3f94:	24 c1       	rjmp	.+584    	; 0x41de <xQueueGenericSend+0x368>
    3f96:	c8 01       	movw	r24, r16
    3f98:	41 96       	adiw	r24, 0x11	; 17
    3f9a:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    3f9e:	81 30       	cpi	r24, 0x01	; 1
    3fa0:	21 f4       	brne	.+8      	; 0x3faa <xQueueGenericSend+0x134>
    3fa2:	ba dc       	rcall	.-1676   	; 0x3918 <vPortYield>
    3fa4:	02 c0       	rjmp	.+4      	; 0x3faa <xQueueGenericSend+0x134>
    3fa6:	81 11       	cpse	r24, r1
    3fa8:	b7 dc       	rcall	.-1682   	; 0x3918 <vPortYield>
    3faa:	0f 90       	pop	r0
    3fac:	0f be       	out	0x3f, r0	; 63
    3fae:	81 e0       	ldi	r24, 0x01	; 1
    3fb0:	1e c1       	rjmp	.+572    	; 0x41ee <xQueueGenericSend+0x378>
    3fb2:	8c 81       	ldd	r24, Y+4	; 0x04
    3fb4:	9d 81       	ldd	r25, Y+5	; 0x05
    3fb6:	89 2b       	or	r24, r25
    3fb8:	21 f4       	brne	.+8      	; 0x3fc2 <xQueueGenericSend+0x14c>
    3fba:	0f 90       	pop	r0
    3fbc:	0f be       	out	0x3f, r0	; 63
    3fbe:	80 e0       	ldi	r24, 0x00	; 0
    3fc0:	16 c1       	rjmp	.+556    	; 0x41ee <xQueueGenericSend+0x378>
    3fc2:	81 10       	cpse	r8, r1
    3fc4:	05 c0       	rjmp	.+10     	; 0x3fd0 <xQueueGenericSend+0x15a>
    3fc6:	ce 01       	movw	r24, r28
    3fc8:	01 96       	adiw	r24, 0x01	; 1
    3fca:	0e 94 4e 2f 	call	0x5e9c	; 0x5e9c <vTaskSetTimeOutState>
    3fce:	86 2c       	mov	r8, r6
    3fd0:	0f 90       	pop	r0
    3fd2:	0f be       	out	0x3f, r0	; 63
    3fd4:	0e 94 17 2c 	call	0x582e	; 0x582e <vTaskSuspendAll>
    3fd8:	0f b6       	in	r0, 0x3f	; 63
    3fda:	f8 94       	cli
    3fdc:	0f 92       	push	r0
    3fde:	f8 01       	movw	r30, r16
    3fe0:	85 8d       	ldd	r24, Z+29	; 0x1d
    3fe2:	8f 3f       	cpi	r24, 0xFF	; 255
    3fe4:	09 f4       	brne	.+2      	; 0x3fe8 <xQueueGenericSend+0x172>
    3fe6:	15 8e       	std	Z+29, r1	; 0x1d
    3fe8:	f8 01       	movw	r30, r16
    3fea:	86 8d       	ldd	r24, Z+30	; 0x1e
    3fec:	8f 3f       	cpi	r24, 0xFF	; 255
    3fee:	09 f4       	brne	.+2      	; 0x3ff2 <xQueueGenericSend+0x17c>
    3ff0:	16 8e       	std	Z+30, r1	; 0x1e
    3ff2:	0f 90       	pop	r0
    3ff4:	0f be       	out	0x3f, r0	; 63
    3ff6:	be 01       	movw	r22, r28
    3ff8:	6c 5f       	subi	r22, 0xFC	; 252
    3ffa:	7f 4f       	sbci	r23, 0xFF	; 255
    3ffc:	ce 01       	movw	r24, r28
    3ffe:	01 96       	adiw	r24, 0x01	; 1
    4000:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <xTaskCheckForTimeOut>
    4004:	81 11       	cpse	r24, r1
    4006:	96 c0       	rjmp	.+300    	; 0x4134 <xQueueGenericSend+0x2be>
    4008:	0f b6       	in	r0, 0x3f	; 63
    400a:	f8 94       	cli
    400c:	0f 92       	push	r0
    400e:	f8 01       	movw	r30, r16
    4010:	92 8d       	ldd	r25, Z+26	; 0x1a
    4012:	83 8d       	ldd	r24, Z+27	; 0x1b
    4014:	0f 90       	pop	r0
    4016:	0f be       	out	0x3f, r0	; 63
    4018:	98 13       	cpse	r25, r24
    401a:	4a c0       	rjmp	.+148    	; 0x40b0 <xQueueGenericSend+0x23a>
    401c:	6c 81       	ldd	r22, Y+4	; 0x04
    401e:	7d 81       	ldd	r23, Y+5	; 0x05
    4020:	c7 01       	movw	r24, r14
    4022:	0e 94 ab 2e 	call	0x5d56	; 0x5d56 <vTaskPlaceOnEventList>
    4026:	0f b6       	in	r0, 0x3f	; 63
    4028:	f8 94       	cli
    402a:	0f 92       	push	r0
    402c:	f8 01       	movw	r30, r16
    402e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4030:	18 16       	cp	r1, r24
    4032:	ac f4       	brge	.+42     	; 0x405e <xQueueGenericSend+0x1e8>
    4034:	81 89       	ldd	r24, Z+17	; 0x11
    4036:	81 11       	cpse	r24, r1
    4038:	05 c0       	rjmp	.+10     	; 0x4044 <xQueueGenericSend+0x1ce>
    403a:	11 c0       	rjmp	.+34     	; 0x405e <xQueueGenericSend+0x1e8>
    403c:	f8 01       	movw	r30, r16
    403e:	81 89       	ldd	r24, Z+17	; 0x11
    4040:	88 23       	and	r24, r24
    4042:	69 f0       	breq	.+26     	; 0x405e <xQueueGenericSend+0x1e8>
    4044:	c6 01       	movw	r24, r12
    4046:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    404a:	81 11       	cpse	r24, r1
    404c:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    4050:	f8 01       	movw	r30, r16
    4052:	86 8d       	ldd	r24, Z+30	; 0x1e
    4054:	81 50       	subi	r24, 0x01	; 1
    4056:	86 8f       	std	Z+30, r24	; 0x1e
    4058:	86 8d       	ldd	r24, Z+30	; 0x1e
    405a:	18 16       	cp	r1, r24
    405c:	7c f3       	brlt	.-34     	; 0x403c <xQueueGenericSend+0x1c6>
    405e:	f8 01       	movw	r30, r16
    4060:	96 8e       	std	Z+30, r9	; 0x1e
    4062:	0f 90       	pop	r0
    4064:	0f be       	out	0x3f, r0	; 63
    4066:	0f b6       	in	r0, 0x3f	; 63
    4068:	f8 94       	cli
    406a:	0f 92       	push	r0
    406c:	85 8d       	ldd	r24, Z+29	; 0x1d
    406e:	18 16       	cp	r1, r24
    4070:	ac f4       	brge	.+42     	; 0x409c <xQueueGenericSend+0x226>
    4072:	80 85       	ldd	r24, Z+8	; 0x08
    4074:	81 11       	cpse	r24, r1
    4076:	05 c0       	rjmp	.+10     	; 0x4082 <xQueueGenericSend+0x20c>
    4078:	11 c0       	rjmp	.+34     	; 0x409c <xQueueGenericSend+0x226>
    407a:	f8 01       	movw	r30, r16
    407c:	80 85       	ldd	r24, Z+8	; 0x08
    407e:	88 23       	and	r24, r24
    4080:	69 f0       	breq	.+26     	; 0x409c <xQueueGenericSend+0x226>
    4082:	c7 01       	movw	r24, r14
    4084:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4088:	81 11       	cpse	r24, r1
    408a:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    408e:	f8 01       	movw	r30, r16
    4090:	85 8d       	ldd	r24, Z+29	; 0x1d
    4092:	81 50       	subi	r24, 0x01	; 1
    4094:	85 8f       	std	Z+29, r24	; 0x1d
    4096:	85 8d       	ldd	r24, Z+29	; 0x1d
    4098:	18 16       	cp	r1, r24
    409a:	7c f3       	brlt	.-34     	; 0x407a <xQueueGenericSend+0x204>
    409c:	f8 01       	movw	r30, r16
    409e:	95 8e       	std	Z+29, r9	; 0x1d
    40a0:	0f 90       	pop	r0
    40a2:	0f be       	out	0x3f, r0	; 63
    40a4:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    40a8:	81 11       	cpse	r24, r1
    40aa:	0a cf       	rjmp	.-492    	; 0x3ec0 <xQueueGenericSend+0x4a>
    40ac:	35 dc       	rcall	.-1942   	; 0x3918 <vPortYield>
    40ae:	08 cf       	rjmp	.-496    	; 0x3ec0 <xQueueGenericSend+0x4a>
    40b0:	0f b6       	in	r0, 0x3f	; 63
    40b2:	f8 94       	cli
    40b4:	0f 92       	push	r0
    40b6:	f8 01       	movw	r30, r16
    40b8:	86 8d       	ldd	r24, Z+30	; 0x1e
    40ba:	18 16       	cp	r1, r24
    40bc:	ac f4       	brge	.+42     	; 0x40e8 <xQueueGenericSend+0x272>
    40be:	81 89       	ldd	r24, Z+17	; 0x11
    40c0:	81 11       	cpse	r24, r1
    40c2:	05 c0       	rjmp	.+10     	; 0x40ce <xQueueGenericSend+0x258>
    40c4:	11 c0       	rjmp	.+34     	; 0x40e8 <xQueueGenericSend+0x272>
    40c6:	f8 01       	movw	r30, r16
    40c8:	81 89       	ldd	r24, Z+17	; 0x11
    40ca:	88 23       	and	r24, r24
    40cc:	69 f0       	breq	.+26     	; 0x40e8 <xQueueGenericSend+0x272>
    40ce:	c6 01       	movw	r24, r12
    40d0:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    40d4:	81 11       	cpse	r24, r1
    40d6:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    40da:	f8 01       	movw	r30, r16
    40dc:	86 8d       	ldd	r24, Z+30	; 0x1e
    40de:	81 50       	subi	r24, 0x01	; 1
    40e0:	86 8f       	std	Z+30, r24	; 0x1e
    40e2:	86 8d       	ldd	r24, Z+30	; 0x1e
    40e4:	18 16       	cp	r1, r24
    40e6:	7c f3       	brlt	.-34     	; 0x40c6 <xQueueGenericSend+0x250>
    40e8:	f8 01       	movw	r30, r16
    40ea:	96 8e       	std	Z+30, r9	; 0x1e
    40ec:	0f 90       	pop	r0
    40ee:	0f be       	out	0x3f, r0	; 63
    40f0:	0f b6       	in	r0, 0x3f	; 63
    40f2:	f8 94       	cli
    40f4:	0f 92       	push	r0
    40f6:	85 8d       	ldd	r24, Z+29	; 0x1d
    40f8:	18 16       	cp	r1, r24
    40fa:	ac f4       	brge	.+42     	; 0x4126 <xQueueGenericSend+0x2b0>
    40fc:	80 85       	ldd	r24, Z+8	; 0x08
    40fe:	81 11       	cpse	r24, r1
    4100:	05 c0       	rjmp	.+10     	; 0x410c <xQueueGenericSend+0x296>
    4102:	11 c0       	rjmp	.+34     	; 0x4126 <xQueueGenericSend+0x2b0>
    4104:	f8 01       	movw	r30, r16
    4106:	80 85       	ldd	r24, Z+8	; 0x08
    4108:	88 23       	and	r24, r24
    410a:	69 f0       	breq	.+26     	; 0x4126 <xQueueGenericSend+0x2b0>
    410c:	c7 01       	movw	r24, r14
    410e:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4112:	81 11       	cpse	r24, r1
    4114:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    4118:	f8 01       	movw	r30, r16
    411a:	85 8d       	ldd	r24, Z+29	; 0x1d
    411c:	81 50       	subi	r24, 0x01	; 1
    411e:	85 8f       	std	Z+29, r24	; 0x1d
    4120:	85 8d       	ldd	r24, Z+29	; 0x1d
    4122:	18 16       	cp	r1, r24
    4124:	7c f3       	brlt	.-34     	; 0x4104 <xQueueGenericSend+0x28e>
    4126:	f8 01       	movw	r30, r16
    4128:	95 8e       	std	Z+29, r9	; 0x1d
    412a:	0f 90       	pop	r0
    412c:	0f be       	out	0x3f, r0	; 63
    412e:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    4132:	c6 ce       	rjmp	.-628    	; 0x3ec0 <xQueueGenericSend+0x4a>
    4134:	0f b6       	in	r0, 0x3f	; 63
    4136:	f8 94       	cli
    4138:	0f 92       	push	r0
    413a:	f8 01       	movw	r30, r16
    413c:	86 8d       	ldd	r24, Z+30	; 0x1e
    413e:	18 16       	cp	r1, r24
    4140:	d4 f4       	brge	.+52     	; 0x4176 <xQueueGenericSend+0x300>
    4142:	81 89       	ldd	r24, Z+17	; 0x11
    4144:	81 11       	cpse	r24, r1
    4146:	06 c0       	rjmp	.+12     	; 0x4154 <xQueueGenericSend+0x2de>
    4148:	16 c0       	rjmp	.+44     	; 0x4176 <xQueueGenericSend+0x300>
    414a:	f8 01       	movw	r30, r16
    414c:	81 89       	ldd	r24, Z+17	; 0x11
    414e:	81 11       	cpse	r24, r1
    4150:	05 c0       	rjmp	.+10     	; 0x415c <xQueueGenericSend+0x2e6>
    4152:	11 c0       	rjmp	.+34     	; 0x4176 <xQueueGenericSend+0x300>
    4154:	78 01       	movw	r14, r16
    4156:	f1 e1       	ldi	r31, 0x11	; 17
    4158:	ef 0e       	add	r14, r31
    415a:	f1 1c       	adc	r15, r1
    415c:	c7 01       	movw	r24, r14
    415e:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4162:	81 11       	cpse	r24, r1
    4164:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    4168:	f8 01       	movw	r30, r16
    416a:	86 8d       	ldd	r24, Z+30	; 0x1e
    416c:	81 50       	subi	r24, 0x01	; 1
    416e:	86 8f       	std	Z+30, r24	; 0x1e
    4170:	86 8d       	ldd	r24, Z+30	; 0x1e
    4172:	18 16       	cp	r1, r24
    4174:	54 f3       	brlt	.-44     	; 0x414a <xQueueGenericSend+0x2d4>
    4176:	8f ef       	ldi	r24, 0xFF	; 255
    4178:	f8 01       	movw	r30, r16
    417a:	86 8f       	std	Z+30, r24	; 0x1e
    417c:	0f 90       	pop	r0
    417e:	0f be       	out	0x3f, r0	; 63
    4180:	0f b6       	in	r0, 0x3f	; 63
    4182:	f8 94       	cli
    4184:	0f 92       	push	r0
    4186:	85 8d       	ldd	r24, Z+29	; 0x1d
    4188:	18 16       	cp	r1, r24
    418a:	d4 f4       	brge	.+52     	; 0x41c0 <xQueueGenericSend+0x34a>
    418c:	80 85       	ldd	r24, Z+8	; 0x08
    418e:	81 11       	cpse	r24, r1
    4190:	06 c0       	rjmp	.+12     	; 0x419e <xQueueGenericSend+0x328>
    4192:	16 c0       	rjmp	.+44     	; 0x41c0 <xQueueGenericSend+0x34a>
    4194:	f8 01       	movw	r30, r16
    4196:	80 85       	ldd	r24, Z+8	; 0x08
    4198:	81 11       	cpse	r24, r1
    419a:	05 c0       	rjmp	.+10     	; 0x41a6 <xQueueGenericSend+0x330>
    419c:	11 c0       	rjmp	.+34     	; 0x41c0 <xQueueGenericSend+0x34a>
    419e:	78 01       	movw	r14, r16
    41a0:	f8 e0       	ldi	r31, 0x08	; 8
    41a2:	ef 0e       	add	r14, r31
    41a4:	f1 1c       	adc	r15, r1
    41a6:	c7 01       	movw	r24, r14
    41a8:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    41ac:	81 11       	cpse	r24, r1
    41ae:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    41b2:	f8 01       	movw	r30, r16
    41b4:	85 8d       	ldd	r24, Z+29	; 0x1d
    41b6:	81 50       	subi	r24, 0x01	; 1
    41b8:	85 8f       	std	Z+29, r24	; 0x1d
    41ba:	85 8d       	ldd	r24, Z+29	; 0x1d
    41bc:	18 16       	cp	r1, r24
    41be:	54 f3       	brlt	.-44     	; 0x4194 <xQueueGenericSend+0x31e>
    41c0:	8f ef       	ldi	r24, 0xFF	; 255
    41c2:	f8 01       	movw	r30, r16
    41c4:	85 8f       	std	Z+29, r24	; 0x1d
    41c6:	0f 90       	pop	r0
    41c8:	0f be       	out	0x3f, r0	; 63
    41ca:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    41ce:	80 e0       	ldi	r24, 0x00	; 0
    41d0:	0e c0       	rjmp	.+28     	; 0x41ee <xQueueGenericSend+0x378>
    41d2:	f8 01       	movw	r30, r16
    41d4:	44 8d       	ldd	r20, Z+28	; 0x1c
    41d6:	44 23       	and	r20, r20
    41d8:	09 f4       	brne	.+2      	; 0x41dc <xQueueGenericSend+0x366>
    41da:	82 ce       	rjmp	.-764    	; 0x3ee0 <xQueueGenericSend+0x6a>
    41dc:	b2 ce       	rjmp	.-668    	; 0x3f42 <xQueueGenericSend+0xcc>
    41de:	f8 01       	movw	r30, r16
    41e0:	82 8d       	ldd	r24, Z+26	; 0x1a
    41e2:	8f 5f       	subi	r24, 0xFF	; 255
    41e4:	82 8f       	std	Z+26, r24	; 0x1a
    41e6:	81 89       	ldd	r24, Z+17	; 0x11
    41e8:	81 11       	cpse	r24, r1
    41ea:	d5 ce       	rjmp	.-598    	; 0x3f96 <xQueueGenericSend+0x120>
    41ec:	de ce       	rjmp	.-580    	; 0x3faa <xQueueGenericSend+0x134>
    41ee:	0f 90       	pop	r0
    41f0:	0f 90       	pop	r0
    41f2:	0f 90       	pop	r0
    41f4:	0f 90       	pop	r0
    41f6:	0f 90       	pop	r0
    41f8:	df 91       	pop	r29
    41fa:	cf 91       	pop	r28
    41fc:	1f 91       	pop	r17
    41fe:	0f 91       	pop	r16
    4200:	ff 90       	pop	r15
    4202:	ef 90       	pop	r14
    4204:	df 90       	pop	r13
    4206:	cf 90       	pop	r12
    4208:	bf 90       	pop	r11
    420a:	af 90       	pop	r10
    420c:	9f 90       	pop	r9
    420e:	8f 90       	pop	r8
    4210:	7f 90       	pop	r7
    4212:	6f 90       	pop	r6
    4214:	08 95       	ret

00004216 <xQueueGive>:
    4216:	9f 92       	push	r9
    4218:	af 92       	push	r10
    421a:	bf 92       	push	r11
    421c:	cf 92       	push	r12
    421e:	df 92       	push	r13
    4220:	ef 92       	push	r14
    4222:	ff 92       	push	r15
    4224:	0f 93       	push	r16
    4226:	1f 93       	push	r17
    4228:	cf 93       	push	r28
    422a:	df 93       	push	r29
    422c:	00 d0       	rcall	.+0      	; 0x422e <xQueueGive+0x18>
    422e:	1f 92       	push	r1
    4230:	1f 92       	push	r1
    4232:	cd b7       	in	r28, 0x3d	; 61
    4234:	de b7       	in	r29, 0x3e	; 62
    4236:	8c 01       	movw	r16, r24
    4238:	7d 83       	std	Y+5, r23	; 0x05
    423a:	6c 83       	std	Y+4, r22	; 0x04
    423c:	a1 2c       	mov	r10, r1
    423e:	99 24       	eor	r9, r9
    4240:	93 94       	inc	r9
    4242:	bb 24       	eor	r11, r11
    4244:	ba 94       	dec	r11
    4246:	7c 01       	movw	r14, r24
    4248:	88 e0       	ldi	r24, 0x08	; 8
    424a:	e8 0e       	add	r14, r24
    424c:	f1 1c       	adc	r15, r1
    424e:	68 01       	movw	r12, r16
    4250:	e1 e1       	ldi	r30, 0x11	; 17
    4252:	ce 0e       	add	r12, r30
    4254:	d1 1c       	adc	r13, r1
    4256:	0f b6       	in	r0, 0x3f	; 63
    4258:	f8 94       	cli
    425a:	0f 92       	push	r0
    425c:	f8 01       	movw	r30, r16
    425e:	92 8d       	ldd	r25, Z+26	; 0x1a
    4260:	83 8d       	ldd	r24, Z+27	; 0x1b
    4262:	98 17       	cp	r25, r24
    4264:	00 f5       	brcc	.+64     	; 0x42a6 <xQueueGive+0x90>
    4266:	80 81       	ld	r24, Z
    4268:	91 81       	ldd	r25, Z+1	; 0x01
    426a:	89 2b       	or	r24, r25
    426c:	09 f0       	breq	.+2      	; 0x4270 <xQueueGive+0x5a>
    426e:	2b c1       	rjmp	.+598    	; 0x44c6 <xQueueGive+0x2b0>
    4270:	82 81       	ldd	r24, Z+2	; 0x02
    4272:	93 81       	ldd	r25, Z+3	; 0x03
    4274:	0e 94 ff 2f 	call	0x5ffe	; 0x5ffe <xTaskPriorityDisinherit>
    4278:	f8 01       	movw	r30, r16
    427a:	13 82       	std	Z+3, r1	; 0x03
    427c:	12 82       	std	Z+2, r1	; 0x02
    427e:	92 8d       	ldd	r25, Z+26	; 0x1a
    4280:	9f 5f       	subi	r25, 0xFF	; 255
    4282:	92 8f       	std	Z+26, r25	; 0x1a
    4284:	91 89       	ldd	r25, Z+17	; 0x11
    4286:	99 23       	and	r25, r25
    4288:	41 f0       	breq	.+16     	; 0x429a <xQueueGive+0x84>
    428a:	c8 01       	movw	r24, r16
    428c:	41 96       	adiw	r24, 0x11	; 17
    428e:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4292:	81 30       	cpi	r24, 0x01	; 1
    4294:	21 f4       	brne	.+8      	; 0x429e <xQueueGive+0x88>
    4296:	40 db       	rcall	.-2432   	; 0x3918 <vPortYield>
    4298:	02 c0       	rjmp	.+4      	; 0x429e <xQueueGive+0x88>
    429a:	81 11       	cpse	r24, r1
    429c:	3d db       	rcall	.-2438   	; 0x3918 <vPortYield>
    429e:	0f 90       	pop	r0
    42a0:	0f be       	out	0x3f, r0	; 63
    42a2:	81 e0       	ldi	r24, 0x01	; 1
    42a4:	18 c1       	rjmp	.+560    	; 0x44d6 <xQueueGive+0x2c0>
    42a6:	8c 81       	ldd	r24, Y+4	; 0x04
    42a8:	9d 81       	ldd	r25, Y+5	; 0x05
    42aa:	89 2b       	or	r24, r25
    42ac:	21 f4       	brne	.+8      	; 0x42b6 <xQueueGive+0xa0>
    42ae:	0f 90       	pop	r0
    42b0:	0f be       	out	0x3f, r0	; 63
    42b2:	80 e0       	ldi	r24, 0x00	; 0
    42b4:	10 c1       	rjmp	.+544    	; 0x44d6 <xQueueGive+0x2c0>
    42b6:	a1 10       	cpse	r10, r1
    42b8:	05 c0       	rjmp	.+10     	; 0x42c4 <xQueueGive+0xae>
    42ba:	ce 01       	movw	r24, r28
    42bc:	01 96       	adiw	r24, 0x01	; 1
    42be:	0e 94 4e 2f 	call	0x5e9c	; 0x5e9c <vTaskSetTimeOutState>
    42c2:	a9 2c       	mov	r10, r9
    42c4:	0f 90       	pop	r0
    42c6:	0f be       	out	0x3f, r0	; 63
    42c8:	0e 94 17 2c 	call	0x582e	; 0x582e <vTaskSuspendAll>
    42cc:	0f b6       	in	r0, 0x3f	; 63
    42ce:	f8 94       	cli
    42d0:	0f 92       	push	r0
    42d2:	f8 01       	movw	r30, r16
    42d4:	85 8d       	ldd	r24, Z+29	; 0x1d
    42d6:	8f 3f       	cpi	r24, 0xFF	; 255
    42d8:	09 f4       	brne	.+2      	; 0x42dc <xQueueGive+0xc6>
    42da:	15 8e       	std	Z+29, r1	; 0x1d
    42dc:	f8 01       	movw	r30, r16
    42de:	86 8d       	ldd	r24, Z+30	; 0x1e
    42e0:	8f 3f       	cpi	r24, 0xFF	; 255
    42e2:	09 f4       	brne	.+2      	; 0x42e6 <xQueueGive+0xd0>
    42e4:	16 8e       	std	Z+30, r1	; 0x1e
    42e6:	0f 90       	pop	r0
    42e8:	0f be       	out	0x3f, r0	; 63
    42ea:	be 01       	movw	r22, r28
    42ec:	6c 5f       	subi	r22, 0xFC	; 252
    42ee:	7f 4f       	sbci	r23, 0xFF	; 255
    42f0:	ce 01       	movw	r24, r28
    42f2:	01 96       	adiw	r24, 0x01	; 1
    42f4:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <xTaskCheckForTimeOut>
    42f8:	81 11       	cpse	r24, r1
    42fa:	96 c0       	rjmp	.+300    	; 0x4428 <xQueueGive+0x212>
    42fc:	0f b6       	in	r0, 0x3f	; 63
    42fe:	f8 94       	cli
    4300:	0f 92       	push	r0
    4302:	f8 01       	movw	r30, r16
    4304:	92 8d       	ldd	r25, Z+26	; 0x1a
    4306:	83 8d       	ldd	r24, Z+27	; 0x1b
    4308:	0f 90       	pop	r0
    430a:	0f be       	out	0x3f, r0	; 63
    430c:	98 13       	cpse	r25, r24
    430e:	4a c0       	rjmp	.+148    	; 0x43a4 <xQueueGive+0x18e>
    4310:	6c 81       	ldd	r22, Y+4	; 0x04
    4312:	7d 81       	ldd	r23, Y+5	; 0x05
    4314:	c7 01       	movw	r24, r14
    4316:	0e 94 ab 2e 	call	0x5d56	; 0x5d56 <vTaskPlaceOnEventList>
    431a:	0f b6       	in	r0, 0x3f	; 63
    431c:	f8 94       	cli
    431e:	0f 92       	push	r0
    4320:	f8 01       	movw	r30, r16
    4322:	86 8d       	ldd	r24, Z+30	; 0x1e
    4324:	18 16       	cp	r1, r24
    4326:	ac f4       	brge	.+42     	; 0x4352 <xQueueGive+0x13c>
    4328:	81 89       	ldd	r24, Z+17	; 0x11
    432a:	81 11       	cpse	r24, r1
    432c:	05 c0       	rjmp	.+10     	; 0x4338 <xQueueGive+0x122>
    432e:	11 c0       	rjmp	.+34     	; 0x4352 <xQueueGive+0x13c>
    4330:	f8 01       	movw	r30, r16
    4332:	81 89       	ldd	r24, Z+17	; 0x11
    4334:	88 23       	and	r24, r24
    4336:	69 f0       	breq	.+26     	; 0x4352 <xQueueGive+0x13c>
    4338:	c6 01       	movw	r24, r12
    433a:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    433e:	81 11       	cpse	r24, r1
    4340:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    4344:	f8 01       	movw	r30, r16
    4346:	86 8d       	ldd	r24, Z+30	; 0x1e
    4348:	81 50       	subi	r24, 0x01	; 1
    434a:	86 8f       	std	Z+30, r24	; 0x1e
    434c:	86 8d       	ldd	r24, Z+30	; 0x1e
    434e:	18 16       	cp	r1, r24
    4350:	7c f3       	brlt	.-34     	; 0x4330 <xQueueGive+0x11a>
    4352:	f8 01       	movw	r30, r16
    4354:	b6 8e       	std	Z+30, r11	; 0x1e
    4356:	0f 90       	pop	r0
    4358:	0f be       	out	0x3f, r0	; 63
    435a:	0f b6       	in	r0, 0x3f	; 63
    435c:	f8 94       	cli
    435e:	0f 92       	push	r0
    4360:	85 8d       	ldd	r24, Z+29	; 0x1d
    4362:	18 16       	cp	r1, r24
    4364:	ac f4       	brge	.+42     	; 0x4390 <xQueueGive+0x17a>
    4366:	80 85       	ldd	r24, Z+8	; 0x08
    4368:	81 11       	cpse	r24, r1
    436a:	05 c0       	rjmp	.+10     	; 0x4376 <xQueueGive+0x160>
    436c:	11 c0       	rjmp	.+34     	; 0x4390 <xQueueGive+0x17a>
    436e:	f8 01       	movw	r30, r16
    4370:	80 85       	ldd	r24, Z+8	; 0x08
    4372:	88 23       	and	r24, r24
    4374:	69 f0       	breq	.+26     	; 0x4390 <xQueueGive+0x17a>
    4376:	c7 01       	movw	r24, r14
    4378:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    437c:	81 11       	cpse	r24, r1
    437e:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    4382:	f8 01       	movw	r30, r16
    4384:	85 8d       	ldd	r24, Z+29	; 0x1d
    4386:	81 50       	subi	r24, 0x01	; 1
    4388:	85 8f       	std	Z+29, r24	; 0x1d
    438a:	85 8d       	ldd	r24, Z+29	; 0x1d
    438c:	18 16       	cp	r1, r24
    438e:	7c f3       	brlt	.-34     	; 0x436e <xQueueGive+0x158>
    4390:	f8 01       	movw	r30, r16
    4392:	b5 8e       	std	Z+29, r11	; 0x1d
    4394:	0f 90       	pop	r0
    4396:	0f be       	out	0x3f, r0	; 63
    4398:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    439c:	81 11       	cpse	r24, r1
    439e:	5b cf       	rjmp	.-330    	; 0x4256 <xQueueGive+0x40>
    43a0:	bb da       	rcall	.-2698   	; 0x3918 <vPortYield>
    43a2:	59 cf       	rjmp	.-334    	; 0x4256 <xQueueGive+0x40>
    43a4:	0f b6       	in	r0, 0x3f	; 63
    43a6:	f8 94       	cli
    43a8:	0f 92       	push	r0
    43aa:	f8 01       	movw	r30, r16
    43ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    43ae:	18 16       	cp	r1, r24
    43b0:	ac f4       	brge	.+42     	; 0x43dc <xQueueGive+0x1c6>
    43b2:	81 89       	ldd	r24, Z+17	; 0x11
    43b4:	81 11       	cpse	r24, r1
    43b6:	05 c0       	rjmp	.+10     	; 0x43c2 <xQueueGive+0x1ac>
    43b8:	11 c0       	rjmp	.+34     	; 0x43dc <xQueueGive+0x1c6>
    43ba:	f8 01       	movw	r30, r16
    43bc:	81 89       	ldd	r24, Z+17	; 0x11
    43be:	88 23       	and	r24, r24
    43c0:	69 f0       	breq	.+26     	; 0x43dc <xQueueGive+0x1c6>
    43c2:	c6 01       	movw	r24, r12
    43c4:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    43c8:	81 11       	cpse	r24, r1
    43ca:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    43ce:	f8 01       	movw	r30, r16
    43d0:	86 8d       	ldd	r24, Z+30	; 0x1e
    43d2:	81 50       	subi	r24, 0x01	; 1
    43d4:	86 8f       	std	Z+30, r24	; 0x1e
    43d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    43d8:	18 16       	cp	r1, r24
    43da:	7c f3       	brlt	.-34     	; 0x43ba <xQueueGive+0x1a4>
    43dc:	f8 01       	movw	r30, r16
    43de:	b6 8e       	std	Z+30, r11	; 0x1e
    43e0:	0f 90       	pop	r0
    43e2:	0f be       	out	0x3f, r0	; 63
    43e4:	0f b6       	in	r0, 0x3f	; 63
    43e6:	f8 94       	cli
    43e8:	0f 92       	push	r0
    43ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    43ec:	18 16       	cp	r1, r24
    43ee:	ac f4       	brge	.+42     	; 0x441a <xQueueGive+0x204>
    43f0:	80 85       	ldd	r24, Z+8	; 0x08
    43f2:	81 11       	cpse	r24, r1
    43f4:	05 c0       	rjmp	.+10     	; 0x4400 <xQueueGive+0x1ea>
    43f6:	11 c0       	rjmp	.+34     	; 0x441a <xQueueGive+0x204>
    43f8:	f8 01       	movw	r30, r16
    43fa:	80 85       	ldd	r24, Z+8	; 0x08
    43fc:	88 23       	and	r24, r24
    43fe:	69 f0       	breq	.+26     	; 0x441a <xQueueGive+0x204>
    4400:	c7 01       	movw	r24, r14
    4402:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4406:	81 11       	cpse	r24, r1
    4408:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    440c:	f8 01       	movw	r30, r16
    440e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4410:	81 50       	subi	r24, 0x01	; 1
    4412:	85 8f       	std	Z+29, r24	; 0x1d
    4414:	85 8d       	ldd	r24, Z+29	; 0x1d
    4416:	18 16       	cp	r1, r24
    4418:	7c f3       	brlt	.-34     	; 0x43f8 <xQueueGive+0x1e2>
    441a:	f8 01       	movw	r30, r16
    441c:	b5 8e       	std	Z+29, r11	; 0x1d
    441e:	0f 90       	pop	r0
    4420:	0f be       	out	0x3f, r0	; 63
    4422:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    4426:	17 cf       	rjmp	.-466    	; 0x4256 <xQueueGive+0x40>
    4428:	0f b6       	in	r0, 0x3f	; 63
    442a:	f8 94       	cli
    442c:	0f 92       	push	r0
    442e:	f8 01       	movw	r30, r16
    4430:	86 8d       	ldd	r24, Z+30	; 0x1e
    4432:	18 16       	cp	r1, r24
    4434:	d4 f4       	brge	.+52     	; 0x446a <xQueueGive+0x254>
    4436:	81 89       	ldd	r24, Z+17	; 0x11
    4438:	81 11       	cpse	r24, r1
    443a:	06 c0       	rjmp	.+12     	; 0x4448 <xQueueGive+0x232>
    443c:	16 c0       	rjmp	.+44     	; 0x446a <xQueueGive+0x254>
    443e:	f8 01       	movw	r30, r16
    4440:	81 89       	ldd	r24, Z+17	; 0x11
    4442:	81 11       	cpse	r24, r1
    4444:	05 c0       	rjmp	.+10     	; 0x4450 <xQueueGive+0x23a>
    4446:	11 c0       	rjmp	.+34     	; 0x446a <xQueueGive+0x254>
    4448:	78 01       	movw	r14, r16
    444a:	f1 e1       	ldi	r31, 0x11	; 17
    444c:	ef 0e       	add	r14, r31
    444e:	f1 1c       	adc	r15, r1
    4450:	c7 01       	movw	r24, r14
    4452:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4456:	81 11       	cpse	r24, r1
    4458:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    445c:	f8 01       	movw	r30, r16
    445e:	86 8d       	ldd	r24, Z+30	; 0x1e
    4460:	81 50       	subi	r24, 0x01	; 1
    4462:	86 8f       	std	Z+30, r24	; 0x1e
    4464:	86 8d       	ldd	r24, Z+30	; 0x1e
    4466:	18 16       	cp	r1, r24
    4468:	54 f3       	brlt	.-44     	; 0x443e <xQueueGive+0x228>
    446a:	8f ef       	ldi	r24, 0xFF	; 255
    446c:	f8 01       	movw	r30, r16
    446e:	86 8f       	std	Z+30, r24	; 0x1e
    4470:	0f 90       	pop	r0
    4472:	0f be       	out	0x3f, r0	; 63
    4474:	0f b6       	in	r0, 0x3f	; 63
    4476:	f8 94       	cli
    4478:	0f 92       	push	r0
    447a:	85 8d       	ldd	r24, Z+29	; 0x1d
    447c:	18 16       	cp	r1, r24
    447e:	d4 f4       	brge	.+52     	; 0x44b4 <xQueueGive+0x29e>
    4480:	80 85       	ldd	r24, Z+8	; 0x08
    4482:	81 11       	cpse	r24, r1
    4484:	06 c0       	rjmp	.+12     	; 0x4492 <xQueueGive+0x27c>
    4486:	16 c0       	rjmp	.+44     	; 0x44b4 <xQueueGive+0x29e>
    4488:	f8 01       	movw	r30, r16
    448a:	80 85       	ldd	r24, Z+8	; 0x08
    448c:	81 11       	cpse	r24, r1
    448e:	05 c0       	rjmp	.+10     	; 0x449a <xQueueGive+0x284>
    4490:	11 c0       	rjmp	.+34     	; 0x44b4 <xQueueGive+0x29e>
    4492:	78 01       	movw	r14, r16
    4494:	f8 e0       	ldi	r31, 0x08	; 8
    4496:	ef 0e       	add	r14, r31
    4498:	f1 1c       	adc	r15, r1
    449a:	c7 01       	movw	r24, r14
    449c:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    44a0:	81 11       	cpse	r24, r1
    44a2:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
    44a6:	f8 01       	movw	r30, r16
    44a8:	85 8d       	ldd	r24, Z+29	; 0x1d
    44aa:	81 50       	subi	r24, 0x01	; 1
    44ac:	85 8f       	std	Z+29, r24	; 0x1d
    44ae:	85 8d       	ldd	r24, Z+29	; 0x1d
    44b0:	18 16       	cp	r1, r24
    44b2:	54 f3       	brlt	.-44     	; 0x4488 <xQueueGive+0x272>
    44b4:	8f ef       	ldi	r24, 0xFF	; 255
    44b6:	f8 01       	movw	r30, r16
    44b8:	85 8f       	std	Z+29, r24	; 0x1d
    44ba:	0f 90       	pop	r0
    44bc:	0f be       	out	0x3f, r0	; 63
    44be:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    44c2:	80 e0       	ldi	r24, 0x00	; 0
    44c4:	08 c0       	rjmp	.+16     	; 0x44d6 <xQueueGive+0x2c0>
    44c6:	f8 01       	movw	r30, r16
    44c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    44ca:	8f 5f       	subi	r24, 0xFF	; 255
    44cc:	82 8f       	std	Z+26, r24	; 0x1a
    44ce:	81 89       	ldd	r24, Z+17	; 0x11
    44d0:	81 11       	cpse	r24, r1
    44d2:	db ce       	rjmp	.-586    	; 0x428a <xQueueGive+0x74>
    44d4:	e4 ce       	rjmp	.-568    	; 0x429e <xQueueGive+0x88>
    44d6:	0f 90       	pop	r0
    44d8:	0f 90       	pop	r0
    44da:	0f 90       	pop	r0
    44dc:	0f 90       	pop	r0
    44de:	0f 90       	pop	r0
    44e0:	df 91       	pop	r29
    44e2:	cf 91       	pop	r28
    44e4:	1f 91       	pop	r17
    44e6:	0f 91       	pop	r16
    44e8:	ff 90       	pop	r15
    44ea:	ef 90       	pop	r14
    44ec:	df 90       	pop	r13
    44ee:	cf 90       	pop	r12
    44f0:	bf 90       	pop	r11
    44f2:	af 90       	pop	r10
    44f4:	9f 90       	pop	r9
    44f6:	08 95       	ret

000044f8 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    44f8:	cf 93       	push	r28
    44fa:	df 93       	push	r29
    44fc:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    44fe:	92 8d       	ldd	r25, Z+26	; 0x1a
    4500:	83 8d       	ldd	r24, Z+27	; 0x1b
    4502:	98 17       	cp	r25, r24
    4504:	d0 f4       	brcc	.+52     	; 0x453a <xQueueGiveFromISR+0x42>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    4506:	82 8d       	ldd	r24, Z+26	; 0x1a
    4508:	8f 5f       	subi	r24, 0xFF	; 255
    450a:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    450c:	86 8d       	ldd	r24, Z+30	; 0x1e
    450e:	8f 3f       	cpi	r24, 0xFF	; 255
    4510:	79 f4       	brne	.+30     	; 0x4530 <xQueueGiveFromISR+0x38>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4512:	81 89       	ldd	r24, Z+17	; 0x11
    4514:	88 23       	and	r24, r24
    4516:	99 f0       	breq	.+38     	; 0x453e <xQueueGiveFromISR+0x46>
    4518:	eb 01       	movw	r28, r22
    451a:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    451c:	41 96       	adiw	r24, 0x11	; 17
    451e:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4522:	88 23       	and	r24, r24
    4524:	71 f0       	breq	.+28     	; 0x4542 <xQueueGiveFromISR+0x4a>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    4526:	20 97       	sbiw	r28, 0x00	; 0
    4528:	71 f0       	breq	.+28     	; 0x4546 <xQueueGiveFromISR+0x4e>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    452a:	81 e0       	ldi	r24, 0x01	; 1
    452c:	88 83       	st	Y, r24
    452e:	0c c0       	rjmp	.+24     	; 0x4548 <xQueueGiveFromISR+0x50>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    4530:	86 8d       	ldd	r24, Z+30	; 0x1e
    4532:	8f 5f       	subi	r24, 0xFF	; 255
    4534:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    4536:	81 e0       	ldi	r24, 0x01	; 1
    4538:	07 c0       	rjmp	.+14     	; 0x4548 <xQueueGiveFromISR+0x50>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    453a:	80 e0       	ldi	r24, 0x00	; 0
    453c:	05 c0       	rjmp	.+10     	; 0x4548 <xQueueGiveFromISR+0x50>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    453e:	81 e0       	ldi	r24, 0x01	; 1
    4540:	03 c0       	rjmp	.+6      	; 0x4548 <xQueueGiveFromISR+0x50>
    4542:	81 e0       	ldi	r24, 0x01	; 1
    4544:	01 c0       	rjmp	.+2      	; 0x4548 <xQueueGiveFromISR+0x50>
    4546:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    4548:	df 91       	pop	r29
    454a:	cf 91       	pop	r28
    454c:	08 95       	ret

0000454e <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    454e:	6f 92       	push	r6
    4550:	7f 92       	push	r7
    4552:	8f 92       	push	r8
    4554:	9f 92       	push	r9
    4556:	af 92       	push	r10
    4558:	bf 92       	push	r11
    455a:	cf 92       	push	r12
    455c:	df 92       	push	r13
    455e:	ef 92       	push	r14
    4560:	ff 92       	push	r15
    4562:	0f 93       	push	r16
    4564:	1f 93       	push	r17
    4566:	cf 93       	push	r28
    4568:	df 93       	push	r29
    456a:	00 d0       	rcall	.+0      	; 0x456c <xQueueGenericReceive+0x1e>
    456c:	1f 92       	push	r1
    456e:	1f 92       	push	r1
    4570:	cd b7       	in	r28, 0x3d	; 61
    4572:	de b7       	in	r29, 0x3e	; 62
    4574:	8c 01       	movw	r16, r24
    4576:	5b 01       	movw	r10, r22
    4578:	5d 83       	std	Y+5, r21	; 0x05
    457a:	4c 83       	std	Y+4, r20	; 0x04
    457c:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    457e:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    4580:	77 24       	eor	r7, r7
    4582:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4584:	99 24       	eor	r9, r9
    4586:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4588:	6c 01       	movw	r12, r24
    458a:	88 e0       	ldi	r24, 0x08	; 8
    458c:	c8 0e       	add	r12, r24
    458e:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4590:	78 01       	movw	r14, r16
    4592:	e1 e1       	ldi	r30, 0x11	; 17
    4594:	ee 0e       	add	r14, r30
    4596:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    4598:	0f b6       	in	r0, 0x3f	; 63
    459a:	f8 94       	cli
    459c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    459e:	f8 01       	movw	r30, r16
    45a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    45a2:	88 23       	and	r24, r24
    45a4:	09 f4       	brne	.+2      	; 0x45a8 <xQueueGenericReceive+0x5a>
    45a6:	45 c0       	rjmp	.+138    	; 0x4632 <xQueueGenericReceive+0xe4>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    45a8:	e6 80       	ldd	r14, Z+6	; 0x06
    45aa:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    45ac:	44 8d       	ldd	r20, Z+28	; 0x1c
    45ae:	44 23       	and	r20, r20
    45b0:	a9 f0       	breq	.+42     	; 0x45dc <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    45b2:	50 e0       	ldi	r21, 0x00	; 0
    45b4:	c7 01       	movw	r24, r14
    45b6:	84 0f       	add	r24, r20
    45b8:	95 1f       	adc	r25, r21
    45ba:	97 83       	std	Z+7, r25	; 0x07
    45bc:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    45be:	22 81       	ldd	r18, Z+2	; 0x02
    45c0:	33 81       	ldd	r19, Z+3	; 0x03
    45c2:	82 17       	cp	r24, r18
    45c4:	93 07       	cpc	r25, r19
    45c6:	20 f0       	brcs	.+8      	; 0x45d0 <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    45c8:	80 81       	ld	r24, Z
    45ca:	91 81       	ldd	r25, Z+1	; 0x01
    45cc:	97 83       	std	Z+7, r25	; 0x07
    45ce:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    45d0:	f8 01       	movw	r30, r16
    45d2:	66 81       	ldd	r22, Z+6	; 0x06
    45d4:	77 81       	ldd	r23, Z+7	; 0x07
    45d6:	c5 01       	movw	r24, r10
    45d8:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    45dc:	61 10       	cpse	r6, r1
    45de:	19 c0       	rjmp	.+50     	; 0x4612 <xQueueGenericReceive+0xc4>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    45e0:	f8 01       	movw	r30, r16
    45e2:	82 8d       	ldd	r24, Z+26	; 0x1a
    45e4:	81 50       	subi	r24, 0x01	; 1
    45e6:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    45e8:	80 81       	ld	r24, Z
    45ea:	91 81       	ldd	r25, Z+1	; 0x01
    45ec:	89 2b       	or	r24, r25
    45ee:	29 f4       	brne	.+10     	; 0x45fa <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    45f0:	0e 94 3f 30 	call	0x607e	; 0x607e <pvTaskIncrementMutexHeldCount>
    45f4:	f8 01       	movw	r30, r16
    45f6:	93 83       	std	Z+3, r25	; 0x03
    45f8:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    45fa:	f8 01       	movw	r30, r16
    45fc:	80 85       	ldd	r24, Z+8	; 0x08
    45fe:	88 23       	and	r24, r24
    4600:	a1 f0       	breq	.+40     	; 0x462a <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    4602:	c8 01       	movw	r24, r16
    4604:	08 96       	adiw	r24, 0x08	; 8
    4606:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    460a:	81 30       	cpi	r24, 0x01	; 1
    460c:	71 f4       	brne	.+28     	; 0x462a <xQueueGenericReceive+0xdc>
						{
							queueYIELD_IF_USING_PREEMPTION();
    460e:	84 d9       	rcall	.-3320   	; 0x3918 <vPortYield>
    4610:	0c c0       	rjmp	.+24     	; 0x462a <xQueueGenericReceive+0xdc>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    4612:	f8 01       	movw	r30, r16
    4614:	f7 82       	std	Z+7, r15	; 0x07
    4616:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4618:	81 89       	ldd	r24, Z+17	; 0x11
    461a:	88 23       	and	r24, r24
    461c:	31 f0       	breq	.+12     	; 0x462a <xQueueGenericReceive+0xdc>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    461e:	c8 01       	movw	r24, r16
    4620:	41 96       	adiw	r24, 0x11	; 17
    4622:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    4626:	81 11       	cpse	r24, r1
    4628:	77 d9       	rcall	.-3346   	; 0x3918 <vPortYield>
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    462a:	0f 90       	pop	r0
    462c:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    462e:	81 e0       	ldi	r24, 0x01	; 1
    4630:	1a c1       	rjmp	.+564    	; 0x4866 <xQueueGenericReceive+0x318>
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    4632:	8c 81       	ldd	r24, Y+4	; 0x04
    4634:	9d 81       	ldd	r25, Y+5	; 0x05
    4636:	89 2b       	or	r24, r25
    4638:	21 f4       	brne	.+8      	; 0x4642 <xQueueGenericReceive+0xf4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    463a:	0f 90       	pop	r0
    463c:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    463e:	80 e0       	ldi	r24, 0x00	; 0
    4640:	12 c1       	rjmp	.+548    	; 0x4866 <xQueueGenericReceive+0x318>
				}
				else if( xEntryTimeSet == pdFALSE )
    4642:	81 10       	cpse	r8, r1
    4644:	05 c0       	rjmp	.+10     	; 0x4650 <xQueueGenericReceive+0x102>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    4646:	ce 01       	movw	r24, r28
    4648:	01 96       	adiw	r24, 0x01	; 1
    464a:	0e 94 4e 2f 	call	0x5e9c	; 0x5e9c <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    464e:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    4650:	0f 90       	pop	r0
    4652:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    4654:	0e 94 17 2c 	call	0x582e	; 0x582e <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    4658:	0f b6       	in	r0, 0x3f	; 63
    465a:	f8 94       	cli
    465c:	0f 92       	push	r0
    465e:	f8 01       	movw	r30, r16
    4660:	85 8d       	ldd	r24, Z+29	; 0x1d
    4662:	8f 3f       	cpi	r24, 0xFF	; 255
    4664:	09 f4       	brne	.+2      	; 0x4668 <xQueueGenericReceive+0x11a>
    4666:	15 8e       	std	Z+29, r1	; 0x1d
    4668:	f8 01       	movw	r30, r16
    466a:	86 8d       	ldd	r24, Z+30	; 0x1e
    466c:	8f 3f       	cpi	r24, 0xFF	; 255
    466e:	09 f4       	brne	.+2      	; 0x4672 <xQueueGenericReceive+0x124>
    4670:	16 8e       	std	Z+30, r1	; 0x1e
    4672:	0f 90       	pop	r0
    4674:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    4676:	be 01       	movw	r22, r28
    4678:	6c 5f       	subi	r22, 0xFC	; 252
    467a:	7f 4f       	sbci	r23, 0xFF	; 255
    467c:	ce 01       	movw	r24, r28
    467e:	01 96       	adiw	r24, 0x01	; 1
    4680:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <xTaskCheckForTimeOut>
    4684:	81 11       	cpse	r24, r1
    4686:	a2 c0       	rjmp	.+324    	; 0x47cc <xQueueGenericReceive+0x27e>

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    4688:	0f b6       	in	r0, 0x3f	; 63
    468a:	f8 94       	cli
    468c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    468e:	f8 01       	movw	r30, r16
    4690:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    4692:	0f 90       	pop	r0
    4694:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    4696:	81 11       	cpse	r24, r1
    4698:	57 c0       	rjmp	.+174    	; 0x4748 <xQueueGenericReceive+0x1fa>
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    469a:	80 81       	ld	r24, Z
    469c:	91 81       	ldd	r25, Z+1	; 0x01
    469e:	89 2b       	or	r24, r25
    46a0:	49 f4       	brne	.+18     	; 0x46b4 <xQueueGenericReceive+0x166>
					{
						taskENTER_CRITICAL();
    46a2:	0f b6       	in	r0, 0x3f	; 63
    46a4:	f8 94       	cli
    46a6:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    46a8:	82 81       	ldd	r24, Z+2	; 0x02
    46aa:	93 81       	ldd	r25, Z+3	; 0x03
    46ac:	0e 94 9d 2f 	call	0x5f3a	; 0x5f3a <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    46b0:	0f 90       	pop	r0
    46b2:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    46b4:	6c 81       	ldd	r22, Y+4	; 0x04
    46b6:	7d 81       	ldd	r23, Y+5	; 0x05
    46b8:	c7 01       	movw	r24, r14
    46ba:	0e 94 ab 2e 	call	0x5d56	; 0x5d56 <vTaskPlaceOnEventList>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    46be:	0f b6       	in	r0, 0x3f	; 63
    46c0:	f8 94       	cli
    46c2:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    46c4:	f8 01       	movw	r30, r16
    46c6:	86 8d       	ldd	r24, Z+30	; 0x1e
    46c8:	18 16       	cp	r1, r24
    46ca:	ac f4       	brge	.+42     	; 0x46f6 <xQueueGenericReceive+0x1a8>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    46cc:	81 89       	ldd	r24, Z+17	; 0x11
    46ce:	81 11       	cpse	r24, r1
    46d0:	05 c0       	rjmp	.+10     	; 0x46dc <xQueueGenericReceive+0x18e>
    46d2:	11 c0       	rjmp	.+34     	; 0x46f6 <xQueueGenericReceive+0x1a8>
    46d4:	f8 01       	movw	r30, r16
    46d6:	81 89       	ldd	r24, Z+17	; 0x11
    46d8:	88 23       	and	r24, r24
    46da:	69 f0       	breq	.+26     	; 0x46f6 <xQueueGenericReceive+0x1a8>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    46dc:	c7 01       	movw	r24, r14
    46de:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    46e2:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    46e4:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    46e8:	f8 01       	movw	r30, r16
    46ea:	86 8d       	ldd	r24, Z+30	; 0x1e
    46ec:	81 50       	subi	r24, 0x01	; 1
    46ee:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    46f0:	86 8d       	ldd	r24, Z+30	; 0x1e
    46f2:	18 16       	cp	r1, r24
    46f4:	7c f3       	brlt	.-34     	; 0x46d4 <xQueueGenericReceive+0x186>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    46f6:	f8 01       	movw	r30, r16
    46f8:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    46fa:	0f 90       	pop	r0
    46fc:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    46fe:	0f b6       	in	r0, 0x3f	; 63
    4700:	f8 94       	cli
    4702:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4704:	85 8d       	ldd	r24, Z+29	; 0x1d
    4706:	18 16       	cp	r1, r24
    4708:	ac f4       	brge	.+42     	; 0x4734 <xQueueGenericReceive+0x1e6>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    470a:	80 85       	ldd	r24, Z+8	; 0x08
    470c:	81 11       	cpse	r24, r1
    470e:	05 c0       	rjmp	.+10     	; 0x471a <xQueueGenericReceive+0x1cc>
    4710:	11 c0       	rjmp	.+34     	; 0x4734 <xQueueGenericReceive+0x1e6>
    4712:	f8 01       	movw	r30, r16
    4714:	80 85       	ldd	r24, Z+8	; 0x08
    4716:	88 23       	and	r24, r24
    4718:	69 f0       	breq	.+26     	; 0x4734 <xQueueGenericReceive+0x1e6>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    471a:	c6 01       	movw	r24, r12
    471c:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4720:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    4722:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    4726:	f8 01       	movw	r30, r16
    4728:	85 8d       	ldd	r24, Z+29	; 0x1d
    472a:	81 50       	subi	r24, 0x01	; 1
    472c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    472e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4730:	18 16       	cp	r1, r24
    4732:	7c f3       	brlt	.-34     	; 0x4712 <xQueueGenericReceive+0x1c4>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4734:	f8 01       	movw	r30, r16
    4736:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    4738:	0f 90       	pop	r0
    473a:	0f be       	out	0x3f, r0	; 63
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    473c:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    4740:	81 11       	cpse	r24, r1
				{
					portYIELD_WITHIN_API();
    4742:	2a cf       	rjmp	.-428    	; 0x4598 <xQueueGenericReceive+0x4a>
    4744:	e9 d8       	rcall	.-3630   	; 0x3918 <vPortYield>
    4746:	28 cf       	rjmp	.-432    	; 0x4598 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    4748:	0f b6       	in	r0, 0x3f	; 63
    474a:	f8 94       	cli
    474c:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    474e:	f8 01       	movw	r30, r16
    4750:	86 8d       	ldd	r24, Z+30	; 0x1e
    4752:	18 16       	cp	r1, r24
    4754:	ac f4       	brge	.+42     	; 0x4780 <xQueueGenericReceive+0x232>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    4756:	81 89       	ldd	r24, Z+17	; 0x11
    4758:	81 11       	cpse	r24, r1
    475a:	05 c0       	rjmp	.+10     	; 0x4766 <xQueueGenericReceive+0x218>
    475c:	11 c0       	rjmp	.+34     	; 0x4780 <xQueueGenericReceive+0x232>
    475e:	f8 01       	movw	r30, r16
    4760:	81 89       	ldd	r24, Z+17	; 0x11
    4762:	88 23       	and	r24, r24
    4764:	69 f0       	breq	.+26     	; 0x4780 <xQueueGenericReceive+0x232>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    4766:	c7 01       	movw	r24, r14
    4768:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    476c:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    476e:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    4772:	f8 01       	movw	r30, r16
    4774:	86 8d       	ldd	r24, Z+30	; 0x1e
    4776:	81 50       	subi	r24, 0x01	; 1
    4778:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    477a:	86 8d       	ldd	r24, Z+30	; 0x1e
    477c:	18 16       	cp	r1, r24
    477e:	7c f3       	brlt	.-34     	; 0x475e <xQueueGenericReceive+0x210>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    4780:	f8 01       	movw	r30, r16
    4782:	96 8e       	std	Z+30, r9	; 0x1e
	}
	taskEXIT_CRITICAL();
    4784:	0f 90       	pop	r0
    4786:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4788:	0f b6       	in	r0, 0x3f	; 63
    478a:	f8 94       	cli
    478c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    478e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4790:	18 16       	cp	r1, r24
    4792:	ac f4       	brge	.+42     	; 0x47be <xQueueGenericReceive+0x270>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4794:	80 85       	ldd	r24, Z+8	; 0x08
    4796:	81 11       	cpse	r24, r1
    4798:	05 c0       	rjmp	.+10     	; 0x47a4 <xQueueGenericReceive+0x256>
    479a:	11 c0       	rjmp	.+34     	; 0x47be <xQueueGenericReceive+0x270>
    479c:	f8 01       	movw	r30, r16
    479e:	80 85       	ldd	r24, Z+8	; 0x08
    47a0:	88 23       	and	r24, r24
    47a2:	69 f0       	breq	.+26     	; 0x47be <xQueueGenericReceive+0x270>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    47a4:	c6 01       	movw	r24, r12
    47a6:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    47aa:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    47ac:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    47b0:	f8 01       	movw	r30, r16
    47b2:	85 8d       	ldd	r24, Z+29	; 0x1d
    47b4:	81 50       	subi	r24, 0x01	; 1
    47b6:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    47b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    47ba:	18 16       	cp	r1, r24
    47bc:	7c f3       	brlt	.-34     	; 0x479c <xQueueGenericReceive+0x24e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    47be:	f8 01       	movw	r30, r16
    47c0:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    47c2:	0f 90       	pop	r0
    47c4:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    47c6:	0e 94 1d 2c 	call	0x583a	; 0x583a <xTaskResumeAll>
    47ca:	e6 ce       	rjmp	.-564    	; 0x4598 <xQueueGenericReceive+0x4a>

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    47cc:	0f b6       	in	r0, 0x3f	; 63
    47ce:	f8 94       	cli
    47d0:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    47d2:	f8 01       	movw	r30, r16
    47d4:	86 8d       	ldd	r24, Z+30	; 0x1e
    47d6:	18 16       	cp	r1, r24
    47d8:	d4 f4       	brge	.+52     	; 0x480e <xQueueGenericReceive+0x2c0>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    47da:	81 89       	ldd	r24, Z+17	; 0x11
    47dc:	81 11       	cpse	r24, r1
    47de:	06 c0       	rjmp	.+12     	; 0x47ec <xQueueGenericReceive+0x29e>
    47e0:	16 c0       	rjmp	.+44     	; 0x480e <xQueueGenericReceive+0x2c0>
    47e2:	f8 01       	movw	r30, r16
    47e4:	81 89       	ldd	r24, Z+17	; 0x11
    47e6:	81 11       	cpse	r24, r1
    47e8:	05 c0       	rjmp	.+10     	; 0x47f4 <xQueueGenericReceive+0x2a6>
    47ea:	11 c0       	rjmp	.+34     	; 0x480e <xQueueGenericReceive+0x2c0>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    47ec:	78 01       	movw	r14, r16
    47ee:	f1 e1       	ldi	r31, 0x11	; 17
    47f0:	ef 0e       	add	r14, r31
    47f2:	f1 1c       	adc	r15, r1
    47f4:	c7 01       	movw	r24, r14
    47f6:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    47fa:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    47fc:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    4800:	f8 01       	movw	r30, r16
    4802:	86 8d       	ldd	r24, Z+30	; 0x1e
    4804:	81 50       	subi	r24, 0x01	; 1
    4806:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    4808:	86 8d       	ldd	r24, Z+30	; 0x1e
    480a:	18 16       	cp	r1, r24
    480c:	54 f3       	brlt	.-44     	; 0x47e2 <xQueueGenericReceive+0x294>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    480e:	8f ef       	ldi	r24, 0xFF	; 255
    4810:	f8 01       	movw	r30, r16
    4812:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    4814:	0f 90       	pop	r0
    4816:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    4818:	0f b6       	in	r0, 0x3f	; 63
    481a:	f8 94       	cli
    481c:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    481e:	85 8d       	ldd	r24, Z+29	; 0x1d
    4820:	18 16       	cp	r1, r24
    4822:	d4 f4       	brge	.+52     	; 0x4858 <xQueueGenericReceive+0x30a>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    4824:	80 85       	ldd	r24, Z+8	; 0x08
    4826:	81 11       	cpse	r24, r1
    4828:	06 c0       	rjmp	.+12     	; 0x4836 <xQueueGenericReceive+0x2e8>
    482a:	16 c0       	rjmp	.+44     	; 0x4858 <xQueueGenericReceive+0x30a>
    482c:	f8 01       	movw	r30, r16
    482e:	80 85       	ldd	r24, Z+8	; 0x08
    4830:	81 11       	cpse	r24, r1
    4832:	05 c0       	rjmp	.+10     	; 0x483e <xQueueGenericReceive+0x2f0>
    4834:	11 c0       	rjmp	.+34     	; 0x4858 <xQueueGenericReceive+0x30a>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    4836:	78 01       	movw	r14, r16
    4838:	f8 e0       	ldi	r31, 0x08	; 8
    483a:	ef 0e       	add	r14, r31
    483c:	f1 1c       	adc	r15, r1
    483e:	c7 01       	movw	r24, r14
    4840:	0e 94 06 2f 	call	0x5e0c	; 0x5e0c <xTaskRemoveFromEventList>
    4844:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    4846:	0e 94 94 2f 	call	0x5f28	; 0x5f28 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    484a:	f8 01       	movw	r30, r16
    484c:	85 8d       	ldd	r24, Z+29	; 0x1d
    484e:	81 50       	subi	r24, 0x01	; 1
    4850:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    4852:	85 8d       	ldd	r24, Z+29	; 0x1d
    4854:	18 16       	cp	r1, r24
    4856:	54 f3       	brlt	.-44     	; 0x482c <xQueueGenericReceive+0x2de>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    4858:	8f ef       	ldi	r24, 0xFF	; 255
    485a:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    485c:	85 8f       	std	Z+29, r24	; 0x1d
    485e:	0f 90       	pop	r0
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    4860:	0f be       	out	0x3f, r0	; 63
    4862:	eb d7       	rcall	.+4054   	; 0x583a <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    4864:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
}
    4866:	0f 90       	pop	r0
    4868:	0f 90       	pop	r0
    486a:	0f 90       	pop	r0
    486c:	0f 90       	pop	r0
    486e:	0f 90       	pop	r0
    4870:	df 91       	pop	r29
    4872:	cf 91       	pop	r28
    4874:	1f 91       	pop	r17
    4876:	0f 91       	pop	r16
    4878:	ff 90       	pop	r15
    487a:	ef 90       	pop	r14
    487c:	df 90       	pop	r13
    487e:	cf 90       	pop	r12
    4880:	bf 90       	pop	r11
    4882:	af 90       	pop	r10
    4884:	9f 90       	pop	r9
    4886:	8f 90       	pop	r8
    4888:	7f 90       	pop	r7
    488a:	6f 90       	pop	r6
    488c:	08 95       	ret

0000488e <server_receiver>:
  uint8_t status = TYPE_PING_RESPONSE;
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
  else simple_p_send(SERVER_ADDRESS, &status, 1);
}

void server_receiver(uint8_t *data, uint16_t len) {
    488e:	ab 01       	movw	r20, r22
  if(data == NULL) { // ARQ passes NULL to the callback when connection is lost
    4890:	00 97       	sbiw	r24, 0x00	; 0
    4892:	11 f4       	brne	.+4      	; 0x4898 <server_receiver+0xa>
      gHandshook = 0;
    4894:	10 92 1c 1a 	sts	0x1A1C, r1	; 0x801a1c <gHandshook>
  }
  memcpy(&message_in, data, len);
    4898:	bc 01       	movw	r22, r24
    489a:	8d e8       	ldi	r24, 0x8D	; 141
    489c:	9b e1       	ldi	r25, 0x1B	; 27
    489e:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
  xSemaphoreGive(xCommandReadyBSem);
    48a2:	60 e0       	ldi	r22, 0x00	; 0
    48a4:	70 e0       	ldi	r23, 0x00	; 0
    48a6:	80 91 89 1b 	lds	r24, 0x1B89	; 0x801b89 <xCommandReadyBSem>
    48aa:	90 91 8a 1b 	lds	r25, 0x1B8A	; 0x801b8a <xCommandReadyBSem+0x1>
    48ae:	b3 cc       	rjmp	.-1690   	; 0x4216 <xQueueGive>
    48b0:	08 95       	ret

000048b2 <server_communication_init>:
#define TYPE_PING           8
#define TYPE_PING_RESPONSE  9
#define TYPE_DEBUG          10

void server_communication_init(void) {
  if(connected) return;
    48b2:	80 91 25 1a 	lds	r24, 0x1A25	; 0x801a25 <connected>
    48b6:	81 11       	cpse	r24, r1
    48b8:	04 c0       	rjmp	.+8      	; 0x48c2 <server_communication_init+0x10>
  server_connection = arq_new_connection();
    48ba:	0e 94 60 01 	call	0x2c0	; 0x2c0 <arq_new_connection>
    48be:	80 93 bf 1b 	sts	0x1BBF, r24	; 0x801bbf <server_connection>
    48c2:	08 95       	ret

000048c4 <server_connect>:
}

uint8_t server_connect(void) {
  connected = arq_connect(server_connection, SERVER_ADDRESS, server_receiver, 1000);
    48c4:	28 ee       	ldi	r18, 0xE8	; 232
    48c6:	33 e0       	ldi	r19, 0x03	; 3
    48c8:	47 e4       	ldi	r20, 0x47	; 71
    48ca:	54 e2       	ldi	r21, 0x24	; 36
    48cc:	60 e0       	ldi	r22, 0x00	; 0
    48ce:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    48d2:	0e 94 7c 01 	call	0x2f8	; 0x2f8 <arq_connect>
    48d6:	80 93 25 1a 	sts	0x1A25, r24	; 0x801a25 <connected>
  return connected;
}
    48da:	08 95       	ret

000048dc <send_handshake>:

uint8_t send_handshake(void) {
    48dc:	cf 93       	push	r28
    48de:	df 93       	push	r29
    48e0:	cd b7       	in	r28, 0x3d	; 61
    48e2:	de b7       	in	r29, 0x3e	; 62
    48e4:	e4 97       	sbiw	r28, 0x34	; 52
    48e6:	0f b6       	in	r0, 0x3f	; 63
    48e8:	f8 94       	cli
    48ea:	de bf       	out	0x3e, r29	; 62
    48ec:	0f be       	out	0x3f, r0	; 63
    48ee:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return 0;
    48f0:	80 91 25 1a 	lds	r24, 0x1A25	; 0x801a25 <connected>
    48f4:	88 23       	and	r24, r24
    48f6:	09 f4       	brne	.+2      	; 0x48fa <send_handshake+0x1e>
    48f8:	4d c0       	rjmp	.+154    	; 0x4994 <send_handshake+0xb8>
  message_t msg;
  msg.type = TYPE_HANDSHAKE;
    48fa:	19 82       	std	Y+1, r1	; 0x01
  msg.message.handshake.name_length = ROBOT_NAME_LENGTH;
    48fc:	83 e0       	ldi	r24, 0x03	; 3
    48fe:	8a 83       	std	Y+2, r24	; 0x02
  strcpy((char*)msg.message.handshake.name, ROBOT_NAME);
    4900:	81 e4       	ldi	r24, 0x41	; 65
    4902:	92 e5       	ldi	r25, 0x52	; 82
    4904:	9c 83       	std	Y+4, r25	; 0x04
    4906:	8b 83       	std	Y+3, r24	; 0x03
    4908:	84 e4       	ldi	r24, 0x44	; 68
    490a:	90 e0       	ldi	r25, 0x00	; 0
    490c:	9e 83       	std	Y+6, r25	; 0x06
    490e:	8d 83       	std	Y+5, r24	; 0x05
  msg.message.handshake.width = ROBOT_TOTAL_WIDTH_MM;
    4910:	24 eb       	ldi	r18, 0xB4	; 180
    4912:	30 e0       	ldi	r19, 0x00	; 0
    4914:	3f 83       	std	Y+7, r19	; 0x07
    4916:	2e 83       	std	Y+6, r18	; 0x06
  msg.message.handshake.length = ROBOT_TOTAL_LENGTH_MM;
    4918:	85 ef       	ldi	r24, 0xF5	; 245
    491a:	90 e0       	ldi	r25, 0x00	; 0
    491c:	99 87       	std	Y+9, r25	; 0x09
    491e:	88 87       	std	Y+8, r24	; 0x08
  msg.message.handshake.axel_offset = ROBOT_AXEL_OFFSET_MM;
    4920:	88 e3       	ldi	r24, 0x38	; 56
    4922:	8c 87       	std	Y+12, r24	; 0x0c
  msg.message.handshake.tower_offset_x = SENSOR_TOWER_OFFSET_X_MM;
    4924:	8a 87       	std	Y+10, r24	; 0x0a
  msg.message.handshake.tower_offset_y = SENSOR_TOWER_OFFSET_Y_MM;
    4926:	1b 86       	std	Y+11, r1	; 0x0b
  msg.message.handshake.sensor_offset1 = SENSOR_OFFSET_RADIUS_MM;
    4928:	85 e1       	ldi	r24, 0x15	; 21
    492a:	8d 87       	std	Y+13, r24	; 0x0d
  msg.message.handshake.sensor_offset2 = SENSOR_OFFSET_RADIUS_MM;
    492c:	8e 87       	std	Y+14, r24	; 0x0e
  msg.message.handshake.sensor_offset3 = SENSOR_OFFSET_RADIUS_MM;
    492e:	8f 87       	std	Y+15, r24	; 0x0f
  msg.message.handshake.sensor_offset4 = SENSOR_OFFSET_RADIUS_MM;
    4930:	88 8b       	std	Y+16, r24	; 0x10
  msg.message.handshake.sensor_heading1 = SENSOR1_HEADING_DEG;
    4932:	1a 8a       	std	Y+18, r1	; 0x12
    4934:	19 8a       	std	Y+17, r1	; 0x11
  msg.message.handshake.sensor_heading2 = SENSOR2_HEADING_DEG;
    4936:	8a e5       	ldi	r24, 0x5A	; 90
    4938:	90 e0       	ldi	r25, 0x00	; 0
    493a:	9c 8b       	std	Y+20, r25	; 0x14
    493c:	8b 8b       	std	Y+19, r24	; 0x13
  msg.message.handshake.sensor_heading3 = SENSOR3_HEADING_DEG;
    493e:	3e 8b       	std	Y+22, r19	; 0x16
    4940:	2d 8b       	std	Y+21, r18	; 0x15
  msg.message.handshake.sensor_heading4 = SENSOR4_HEADING_DEG;
    4942:	8e e0       	ldi	r24, 0x0E	; 14
    4944:	91 e0       	ldi	r25, 0x01	; 1
    4946:	98 8f       	std	Y+24, r25	; 0x18
    4948:	8f 8b       	std	Y+23, r24	; 0x17
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
    494a:	88 ec       	ldi	r24, 0xC8	; 200
    494c:	90 e0       	ldi	r25, 0x00	; 0
    494e:	9a 8f       	std	Y+26, r25	; 0x1a
    4950:	89 8f       	std	Y+25, r24	; 0x19
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    4952:	8a e1       	ldi	r24, 0x1A	; 26
    4954:	fe 01       	movw	r30, r28
    4956:	31 96       	adiw	r30, 0x01	; 1
    4958:	de 01       	movw	r26, r28
    495a:	5b 96       	adiw	r26, 0x1b	; 27
    495c:	01 90       	ld	r0, Z+
    495e:	0d 92       	st	X+, r0
    4960:	8a 95       	dec	r24
    4962:	e1 f7       	brne	.-8      	; 0x495c <send_handshake+0x80>
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
    4964:	80 91 00 06 	lds	r24, 0x0600	; 0x800600 <use_arq>
    4968:	88 23       	and	r24, r24
    496a:	59 f0       	breq	.+22     	; 0x4982 <send_handshake+0xa6>
    496c:	4a e1       	ldi	r20, 0x1A	; 26
    496e:	50 e0       	ldi	r21, 0x00	; 0
    4970:	be 01       	movw	r22, r28
    4972:	65 5e       	subi	r22, 0xE5	; 229
    4974:	7f 4f       	sbci	r23, 0xFF	; 255
    4976:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    497a:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
  else simple_p_send(server_connection, data, sizeof(data));
  return 1;
    497e:	81 e0       	ldi	r24, 0x01	; 1
    4980:	09 c0       	rjmp	.+18     	; 0x4994 <send_handshake+0xb8>
  msg.message.handshake.deadline = ROBOT_DEADLINE_MS;
  
  uint8_t data[sizeof(handshake_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
  if(use_arq[TYPE_HANDSHAKE]) arq_send(server_connection, data, sizeof(data));
  else simple_p_send(server_connection, data, sizeof(data));
    4982:	4a e1       	ldi	r20, 0x1A	; 26
    4984:	50 e0       	ldi	r21, 0x00	; 0
    4986:	be 01       	movw	r22, r28
    4988:	65 5e       	subi	r22, 0xE5	; 229
    498a:	7f 4f       	sbci	r23, 0xFF	; 255
    498c:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4990:	89 d1       	rcall	.+786    	; 0x4ca4 <simple_p_send>
  return 1;
    4992:	81 e0       	ldi	r24, 0x01	; 1
}
    4994:	e4 96       	adiw	r28, 0x34	; 52
    4996:	0f b6       	in	r0, 0x3f	; 63
    4998:	f8 94       	cli
    499a:	de bf       	out	0x3e, r29	; 62
    499c:	0f be       	out	0x3f, r0	; 63
    499e:	cd bf       	out	0x3d, r28	; 61
    49a0:	df 91       	pop	r29
    49a2:	cf 91       	pop	r28
    49a4:	08 95       	ret

000049a6 <send_update>:

void send_update(int16_t x_cm, int16_t y_cm, int16_t heading_deg, int16_t towerAngle_deg, uint8_t S1_cm, uint8_t S2_cm, uint8_t S3_cm, uint8_t S4_cm){
    49a6:	af 92       	push	r10
    49a8:	cf 92       	push	r12
    49aa:	ef 92       	push	r14
    49ac:	0f 93       	push	r16
    49ae:	cf 93       	push	r28
    49b0:	df 93       	push	r29
    49b2:	cd b7       	in	r28, 0x3d	; 61
    49b4:	de b7       	in	r29, 0x3e	; 62
    49b6:	2d 97       	sbiw	r28, 0x0d	; 13
    49b8:	0f b6       	in	r0, 0x3f	; 63
    49ba:	f8 94       	cli
    49bc:	de bf       	out	0x3e, r29	; 62
    49be:	0f be       	out	0x3f, r0	; 63
    49c0:	cd bf       	out	0x3d, r28	; 61
  if(!connected) return;
    49c2:	e0 91 25 1a 	lds	r30, 0x1A25	; 0x801a25 <connected>
    49c6:	ee 23       	and	r30, r30
    49c8:	19 f1       	breq	.+70     	; 0x4a10 <send_update+0x6a>
  msg.message.update.sensor1 = S1_cm;
  msg.message.update.sensor2 = S2_cm;
  msg.message.update.sensor3 = S3_cm;
  msg.message.update.sensor4 = S4_cm;
  uint8_t data[sizeof(update_message_t)+1];
  memcpy(data, (uint8_t*) &msg, sizeof(data));
    49ca:	e1 e0       	ldi	r30, 0x01	; 1
    49cc:	e9 83       	std	Y+1, r30	; 0x01
    49ce:	9b 83       	std	Y+3, r25	; 0x03
    49d0:	8a 83       	std	Y+2, r24	; 0x02
    49d2:	7d 83       	std	Y+5, r23	; 0x05
    49d4:	6c 83       	std	Y+4, r22	; 0x04
    49d6:	5f 83       	std	Y+7, r21	; 0x07
    49d8:	4e 83       	std	Y+6, r20	; 0x06
    49da:	39 87       	std	Y+9, r19	; 0x09
    49dc:	28 87       	std	Y+8, r18	; 0x08
    49de:	0a 87       	std	Y+10, r16	; 0x0a
    49e0:	eb 86       	std	Y+11, r14	; 0x0b
    49e2:	cc 86       	std	Y+12, r12	; 0x0c
    49e4:	ad 86       	std	Y+13, r10	; 0x0d
  if(use_arq[TYPE_UPDATE]) arq_send(server_connection, data, sizeof(data));
    49e6:	80 91 01 06 	lds	r24, 0x0601	; 0x800601 <use_arq+0x1>
    49ea:	88 23       	and	r24, r24
    49ec:	51 f0       	breq	.+20     	; 0x4a02 <send_update+0x5c>
    49ee:	4d e0       	ldi	r20, 0x0D	; 13
    49f0:	50 e0       	ldi	r21, 0x00	; 0
    49f2:	be 01       	movw	r22, r28
    49f4:	6f 5f       	subi	r22, 0xFF	; 255
    49f6:	7f 4f       	sbci	r23, 0xFF	; 255
    49f8:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    49fc:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4a00:	07 c0       	rjmp	.+14     	; 0x4a10 <send_update+0x6a>
  else simple_p_send(SERVER_ADDRESS, data, sizeof(data));
    4a02:	4d e0       	ldi	r20, 0x0D	; 13
    4a04:	50 e0       	ldi	r21, 0x00	; 0
    4a06:	be 01       	movw	r22, r28
    4a08:	6f 5f       	subi	r22, 0xFF	; 255
    4a0a:	7f 4f       	sbci	r23, 0xFF	; 255
    4a0c:	80 e0       	ldi	r24, 0x00	; 0
    4a0e:	4a d1       	rcall	.+660    	; 0x4ca4 <simple_p_send>
}
    4a10:	2d 96       	adiw	r28, 0x0d	; 13
    4a12:	0f b6       	in	r0, 0x3f	; 63
    4a14:	f8 94       	cli
    4a16:	de bf       	out	0x3e, r29	; 62
    4a18:	0f be       	out	0x3f, r0	; 63
    4a1a:	cd bf       	out	0x3d, r28	; 61
    4a1c:	df 91       	pop	r29
    4a1e:	cf 91       	pop	r28
    4a20:	0f 91       	pop	r16
    4a22:	ef 90       	pop	r14
    4a24:	cf 90       	pop	r12
    4a26:	af 90       	pop	r10
    4a28:	08 95       	ret

00004a2a <send_idle>:

void send_idle(void) {
    4a2a:	cf 93       	push	r28
    4a2c:	df 93       	push	r29
    4a2e:	1f 92       	push	r1
    4a30:	cd b7       	in	r28, 0x3d	; 61
    4a32:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    4a34:	80 91 25 1a 	lds	r24, 0x1A25	; 0x801a25 <connected>
    4a38:	88 23       	and	r24, r24
    4a3a:	b9 f0       	breq	.+46     	; 0x4a6a <send_idle+0x40>
  uint8_t status = TYPE_IDLE;
    4a3c:	83 e0       	ldi	r24, 0x03	; 3
    4a3e:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_IDLE]) arq_send(server_connection, &status, 1);
    4a40:	80 91 03 06 	lds	r24, 0x0603	; 0x800603 <use_arq+0x3>
    4a44:	88 23       	and	r24, r24
    4a46:	51 f0       	breq	.+20     	; 0x4a5c <send_idle+0x32>
    4a48:	41 e0       	ldi	r20, 0x01	; 1
    4a4a:	50 e0       	ldi	r21, 0x00	; 0
    4a4c:	be 01       	movw	r22, r28
    4a4e:	6f 5f       	subi	r22, 0xFF	; 255
    4a50:	7f 4f       	sbci	r23, 0xFF	; 255
    4a52:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4a56:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4a5a:	07 c0       	rjmp	.+14     	; 0x4a6a <send_idle+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    4a5c:	41 e0       	ldi	r20, 0x01	; 1
    4a5e:	50 e0       	ldi	r21, 0x00	; 0
    4a60:	be 01       	movw	r22, r28
    4a62:	6f 5f       	subi	r22, 0xFF	; 255
    4a64:	7f 4f       	sbci	r23, 0xFF	; 255
    4a66:	80 e0       	ldi	r24, 0x00	; 0
    4a68:	1d d1       	rcall	.+570    	; 0x4ca4 <simple_p_send>
}
    4a6a:	0f 90       	pop	r0
    4a6c:	df 91       	pop	r29
    4a6e:	cf 91       	pop	r28
    4a70:	08 95       	ret

00004a72 <debug>:
void debug(const char *fmt, ...) {
    4a72:	cf 93       	push	r28
    4a74:	df 93       	push	r29
    4a76:	cd b7       	in	r28, 0x3d	; 61
    4a78:	de b7       	in	r29, 0x3e	; 62
    4a7a:	c4 56       	subi	r28, 0x64	; 100
    4a7c:	d1 09       	sbc	r29, r1
    4a7e:	0f b6       	in	r0, 0x3f	; 63
    4a80:	f8 94       	cli
    4a82:	de bf       	out	0x3e, r29	; 62
    4a84:	0f be       	out	0x3f, r0	; 63
    4a86:	cd bf       	out	0x3d, r28	; 61
    4a88:	ae 01       	movw	r20, r28
    4a8a:	46 59       	subi	r20, 0x96	; 150
    4a8c:	5f 4f       	sbci	r21, 0xFF	; 255
    4a8e:	fa 01       	movw	r30, r20
    4a90:	61 91       	ld	r22, Z+
    4a92:	71 91       	ld	r23, Z+
    4a94:	af 01       	movw	r20, r30
	uint8_t buf[100];
	va_list ap;
	buf[0] = TYPE_DEBUG;
    4a96:	8a e0       	ldi	r24, 0x0A	; 10
    4a98:	89 83       	std	Y+1, r24	; 0x01
	va_start(ap, fmt);
	uint8_t ret = vsprintf((char*)buf+1, fmt, ap);
    4a9a:	ce 01       	movw	r24, r28
    4a9c:	02 96       	adiw	r24, 0x02	; 2
    4a9e:	0e 94 86 3c 	call	0x790c	; 0x790c <vsprintf>
	va_end(ap);
	if (ret > 0) {
    4aa2:	88 23       	and	r24, r24
    4aa4:	c9 f0       	breq	.+50     	; 0x4ad8 <debug+0x66>
		if(use_arq[TYPE_DEBUG]) arq_send(server_connection, buf, ret+1);
    4aa6:	20 91 0a 06 	lds	r18, 0x060A	; 0x80060a <use_arq+0xa>
    4aaa:	22 23       	and	r18, r18
    4aac:	61 f0       	breq	.+24     	; 0x4ac6 <debug+0x54>
    4aae:	99 27       	eor	r25, r25
    4ab0:	ac 01       	movw	r20, r24
    4ab2:	4f 5f       	subi	r20, 0xFF	; 255
    4ab4:	5f 4f       	sbci	r21, 0xFF	; 255
    4ab6:	be 01       	movw	r22, r28
    4ab8:	6f 5f       	subi	r22, 0xFF	; 255
    4aba:	7f 4f       	sbci	r23, 0xFF	; 255
    4abc:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4ac0:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4ac4:	09 c0       	rjmp	.+18     	; 0x4ad8 <debug+0x66>
		else simple_p_send(SERVER_ADDRESS, buf, ret+1);
    4ac6:	99 27       	eor	r25, r25
    4ac8:	ac 01       	movw	r20, r24
    4aca:	4f 5f       	subi	r20, 0xFF	; 255
    4acc:	5f 4f       	sbci	r21, 0xFF	; 255
    4ace:	be 01       	movw	r22, r28
    4ad0:	6f 5f       	subi	r22, 0xFF	; 255
    4ad2:	7f 4f       	sbci	r23, 0xFF	; 255
    4ad4:	80 e0       	ldi	r24, 0x00	; 0
    4ad6:	e6 d0       	rcall	.+460    	; 0x4ca4 <simple_p_send>
	}
}
    4ad8:	cc 59       	subi	r28, 0x9C	; 156
    4ada:	df 4f       	sbci	r29, 0xFF	; 255
    4adc:	0f b6       	in	r0, 0x3f	; 63
    4ade:	f8 94       	cli
    4ae0:	de bf       	out	0x3e, r29	; 62
    4ae2:	0f be       	out	0x3f, r0	; 63
    4ae4:	cd bf       	out	0x3d, r28	; 61
    4ae6:	df 91       	pop	r29
    4ae8:	cf 91       	pop	r28
    4aea:	08 95       	ret

00004aec <send_ping_response>:

void send_ping_response(void) {
    4aec:	cf 93       	push	r28
    4aee:	df 93       	push	r29
    4af0:	1f 92       	push	r1
    4af2:	cd b7       	in	r28, 0x3d	; 61
    4af4:	de b7       	in	r29, 0x3e	; 62
  if(!connected) return;
    4af6:	80 91 25 1a 	lds	r24, 0x1A25	; 0x801a25 <connected>
    4afa:	88 23       	and	r24, r24
    4afc:	b9 f0       	breq	.+46     	; 0x4b2c <send_ping_response+0x40>
  uint8_t status = TYPE_PING_RESPONSE;
    4afe:	89 e0       	ldi	r24, 0x09	; 9
    4b00:	89 83       	std	Y+1, r24	; 0x01
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
    4b02:	80 91 09 06 	lds	r24, 0x0609	; 0x800609 <use_arq+0x9>
    4b06:	88 23       	and	r24, r24
    4b08:	51 f0       	breq	.+20     	; 0x4b1e <send_ping_response+0x32>
    4b0a:	41 e0       	ldi	r20, 0x01	; 1
    4b0c:	50 e0       	ldi	r21, 0x00	; 0
    4b0e:	be 01       	movw	r22, r28
    4b10:	6f 5f       	subi	r22, 0xFF	; 255
    4b12:	7f 4f       	sbci	r23, 0xFF	; 255
    4b14:	80 91 bf 1b 	lds	r24, 0x1BBF	; 0x801bbf <server_connection>
    4b18:	0e 94 33 02 	call	0x466	; 0x466 <arq_send>
    4b1c:	07 c0       	rjmp	.+14     	; 0x4b2c <send_ping_response+0x40>
  else simple_p_send(SERVER_ADDRESS, &status, 1);
    4b1e:	41 e0       	ldi	r20, 0x01	; 1
    4b20:	50 e0       	ldi	r21, 0x00	; 0
    4b22:	be 01       	movw	r22, r28
    4b24:	6f 5f       	subi	r22, 0xFF	; 255
    4b26:	7f 4f       	sbci	r23, 0xFF	; 255
    4b28:	80 e0       	ldi	r24, 0x00	; 0
    4b2a:	bc d0       	rcall	.+376    	; 0x4ca4 <simple_p_send>
}
    4b2c:	0f 90       	pop	r0
    4b2e:	df 91       	pop	r29
    4b30:	cf 91       	pop	r28
    4b32:	08 95       	ret

00004b34 <vServo_setAngle>:

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
	//debug("vServo_setAngle: %i", ServoAngleDeg);
	/* Ensure feasible values */
	if (ServoAngleDeg >= 90){
    4b34:	8a 35       	cpi	r24, 0x5A	; 90
    4b36:	38 f0       	brcs	.+14     	; 0x4b46 <vServo_setAngle+0x12>
		ServoAngleDeg = 90;
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    4b38:	80 e9       	ldi	r24, 0x90	; 144
    4b3a:	9b e0       	ldi	r25, 0x0B	; 11
    4b3c:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    4b40:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    4b44:	08 95       	ret
	}
	else if(ServoAngleDeg <= 0){
    4b46:	81 11       	cpse	r24, r1
    4b48:	07 c0       	rjmp	.+14     	; 0x4b58 <vServo_setAngle+0x24>
		ServoAngleDeg = 0;
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    4b4a:	8d e2       	ldi	r24, 0x2D	; 45
    4b4c:	95 e0       	ldi	r25, 0x05	; 5
    4b4e:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    4b52:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    4b56:	08 95       	ret
	}
	else if (ServoAngleDeg>0 && ServoAngleDeg<90)
    4b58:	9f ef       	ldi	r25, 0xFF	; 255
    4b5a:	98 0f       	add	r25, r24
    4b5c:	99 35       	cpi	r25, 0x59	; 89
    4b5e:	60 f4       	brcc	.+24     	; 0x4b78 <vServo_setAngle+0x44>
	{
		/* Fetch pulse width from array and set to output */
		servoOCR = DEG_TO_PWM[ServoAngleDeg];
    4b60:	e8 2f       	mov	r30, r24
    4b62:	f0 e0       	ldi	r31, 0x00	; 0
    4b64:	ee 0f       	add	r30, r30
    4b66:	ff 1f       	adc	r31, r31
    4b68:	e8 56       	subi	r30, 0x68	; 104
    4b6a:	f9 4f       	sbci	r31, 0xF9	; 249
    4b6c:	80 81       	ld	r24, Z
    4b6e:	91 81       	ldd	r25, Z+1	; 0x01
    4b70:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    4b74:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    4b78:	08 95       	ret

00004b7a <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
	/* Clear OCnA/OCnB on Compare Match, set */
	/* OCnA/OCnB at BOTTOM (non-inverting mode) */
	/* Datasheet p.155 Table 17-4 */
	TCCR4A |= (1<<COM4B1) | (0<<COM4B0);
    4b7a:	a0 ea       	ldi	r26, 0xA0	; 160
    4b7c:	b0 e0       	ldi	r27, 0x00	; 0
    4b7e:	9c 91       	ld	r25, X
    4b80:	90 62       	ori	r25, 0x20	; 32
    4b82:	9c 93       	st	X, r25
	
	/* Waveform generation mode 14: Fast PWM */
	/* top: ICRn, Update bottom, flag set on top */
	/* Datasheet p.145 Table 17-2 */
	
	TCCR4B |= (1<<WGM43) | (1<<WGM42);
    4b84:	e1 ea       	ldi	r30, 0xA1	; 161
    4b86:	f0 e0       	ldi	r31, 0x00	; 0
    4b88:	90 81       	ld	r25, Z
    4b8a:	98 61       	ori	r25, 0x18	; 24
    4b8c:	90 83       	st	Z, r25
	TCCR4A |= (1<<WGM41) | (0<<WGM40);
    4b8e:	9c 91       	ld	r25, X
    4b90:	92 60       	ori	r25, 0x02	; 2
    4b92:	9c 93       	st	X, r25

	/* Clock select bit description: */
	/* clkI/O/8 (From prescaler) - Datasheet p.157 Table 17-6*/

	TCCR4B |= (0<<CS42) | (1<<CS41) | (0<<CS40);
    4b94:	90 81       	ld	r25, Z
    4b96:	92 60       	ori	r25, 0x02	; 2
    4b98:	90 83       	st	Z, r25
	
	/* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
	/* Datasheet p.125 */
	ICR4 = 39999; // 49999 for 20mhz, 39 999 for 16Mhz
    4b9a:	2f e3       	ldi	r18, 0x3F	; 63
    4b9c:	3c e9       	ldi	r19, 0x9C	; 156
    4b9e:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>
    4ba2:	20 93 a6 00 	sts	0x00A6, r18	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
	
	/*Port H Pin 7 as servo PWM Output (OC4B)*/
	servoReg |= (1<<servoPin);
    4ba6:	e1 e0       	ldi	r30, 0x01	; 1
    4ba8:	f1 e0       	ldi	r31, 0x01	; 1
    4baa:	90 81       	ld	r25, Z
    4bac:	90 61       	ori	r25, 0x10	; 16
    4bae:	90 83       	st	Z, r25
	
	/*  Set angle to desired start angle (usually 0)*/
	vServo_setAngle(servoAngleDeg);
    4bb0:	c1 cf       	rjmp	.-126    	; 0x4b34 <vServo_setAngle>
    4bb2:	08 95       	ret

00004bb4 <simple_p_reassembly>:
  vPortFree(part);
  return 1;
}


void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length) {
    4bb4:	ef 92       	push	r14
    4bb6:	ff 92       	push	r15
    4bb8:	0f 93       	push	r16
    4bba:	1f 93       	push	r17
    4bbc:	cf 93       	push	r28
    4bbe:	df 93       	push	r29
  uint8_t i;
  uint8_t id = 0xFF;
  uint8_t free = 0xFF;
  for(i=0;i<MAX_MESSAGES;i++) {
    if(messages[i].address == 0xFF && free == 0xFF) free = i;
    4bc0:	90 91 27 1a 	lds	r25, 0x1A27	; 0x801a27 <messages+0x1>
    4bc4:	9f 3f       	cpi	r25, 0xFF	; 255
    4bc6:	11 f0       	breq	.+4      	; 0x4bcc <simple_p_reassembly+0x18>
    else if(messages[i].address == sender) {
    4bc8:	98 13       	cpse	r25, r24
    4bca:	58 c0       	rjmp	.+176    	; 0x4c7c <simple_p_reassembly+0xc8>
  if(id == 0xFF && free == 0xFF) return; // Not room for any more messages, and none is stored for this address
  else if(id == 0xFF && free != 0xFF) { // Did not find any part messages from this sender, but there is room to store a new one
    id = free; 
  }
    
  if(data[0] == 0) { // First part of a new message
    4bcc:	fb 01       	movw	r30, r22
    4bce:	80 81       	ld	r24, Z
    4bd0:	81 11       	cpse	r24, r1
    4bd2:	05 c0       	rjmp	.+10     	; 0x4bde <simple_p_reassembly+0x2a>
    messages[id].num_received_bytes = 0;
    4bd4:	10 92 29 1a 	sts	0x1A29, r1	; 0x801a29 <messages+0x3>
    4bd8:	10 92 28 1a 	sts	0x1A28, r1	; 0x801a28 <messages+0x2>
    4bdc:	0c c0       	rjmp	.+24     	; 0x4bf6 <simple_p_reassembly+0x42>
  } else if(data[0] != messages[id].next_part) {
    4bde:	90 91 2a 1a 	lds	r25, 0x1A2A	; 0x801a2a <messages+0x4>
    4be2:	89 17       	cp	r24, r25
    4be4:	41 f0       	breq	.+16     	; 0x4bf6 <simple_p_reassembly+0x42>
    messages[id].next_part = 0;
    4be6:	e6 e2       	ldi	r30, 0x26	; 38
    4be8:	fa e1       	ldi	r31, 0x1A	; 26
    4bea:	14 82       	std	Z+4, r1	; 0x04
    messages[id].num_received_bytes = 0;
    4bec:	13 82       	std	Z+3, r1	; 0x03
    4bee:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    4bf0:	8f ef       	ldi	r24, 0xFF	; 255
    4bf2:	81 83       	std	Z+1, r24	; 0x01
    return;
    4bf4:	43 c0       	rjmp	.+134    	; 0x4c7c <simple_p_reassembly+0xc8>
  }

  if(messages[id].num_received_bytes + (length-2) > MAX_MESSAGE_SIZE) { // Message is larger than what can be handled, discard it
    4bf6:	80 91 28 1a 	lds	r24, 0x1A28	; 0x801a28 <messages+0x2>
    4bfa:	90 91 29 1a 	lds	r25, 0x1A29	; 0x801a29 <messages+0x3>
    4bfe:	9c 01       	movw	r18, r24
    4c00:	22 50       	subi	r18, 0x02	; 2
    4c02:	31 09       	sbc	r19, r1
    4c04:	24 0f       	add	r18, r20
    4c06:	35 1f       	adc	r19, r21
    4c08:	25 36       	cpi	r18, 0x65	; 101
    4c0a:	31 05       	cpc	r19, r1
    4c0c:	40 f0       	brcs	.+16     	; 0x4c1e <simple_p_reassembly+0x6a>
    messages[id].num_received_bytes = 0;
    4c0e:	e6 e2       	ldi	r30, 0x26	; 38
    4c10:	fa e1       	ldi	r31, 0x1A	; 26
    4c12:	13 82       	std	Z+3, r1	; 0x03
    4c14:	12 82       	std	Z+2, r1	; 0x02
    messages[id].next_part = 0;
    4c16:	14 82       	std	Z+4, r1	; 0x04
    messages[id].address = 0xFF;
    4c18:	8f ef       	ldi	r24, 0xFF	; 255
    4c1a:	81 83       	std	Z+1, r24	; 0x01
    return;
    4c1c:	2f c0       	rjmp	.+94     	; 0x4c7c <simple_p_reassembly+0xc8>
    4c1e:	8a 01       	movw	r16, r20
    4c20:	eb 01       	movw	r28, r22
  }
  
  messages[id].next_part++;
    4c22:	0f 2e       	mov	r0, r31
    4c24:	f6 e2       	ldi	r31, 0x26	; 38
    4c26:	ef 2e       	mov	r14, r31
    4c28:	fa e1       	ldi	r31, 0x1A	; 26
    4c2a:	ff 2e       	mov	r15, r31
    4c2c:	f0 2d       	mov	r31, r0
    4c2e:	f7 01       	movw	r30, r14
    4c30:	24 81       	ldd	r18, Z+4	; 0x04
    4c32:	2f 5f       	subi	r18, 0xFF	; 255
    4c34:	24 83       	std	Z+4, r18	; 0x04
  memcpy(messages[id].message+messages[id].num_received_bytes, data+2, length-2);
    4c36:	42 50       	subi	r20, 0x02	; 2
    4c38:	51 09       	sbc	r21, r1
    4c3a:	6e 5f       	subi	r22, 0xFE	; 254
    4c3c:	7f 4f       	sbci	r23, 0xFF	; 255
    4c3e:	85 5d       	subi	r24, 0xD5	; 213
    4c40:	95 4e       	sbci	r25, 0xE5	; 229
    4c42:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
  messages[id].num_received_bytes += (length-2);
    4c46:	f7 01       	movw	r30, r14
    4c48:	42 81       	ldd	r20, Z+2	; 0x02
    4c4a:	53 81       	ldd	r21, Z+3	; 0x03
    4c4c:	42 50       	subi	r20, 0x02	; 2
    4c4e:	51 09       	sbc	r21, r1
    4c50:	ba 01       	movw	r22, r20
    4c52:	60 0f       	add	r22, r16
    4c54:	71 1f       	adc	r23, r17
    4c56:	73 83       	std	Z+3, r23	; 0x03
    4c58:	62 83       	std	Z+2, r22	; 0x02
  
  if(data[0] == data[1]) {
    4c5a:	98 81       	ld	r25, Y
    4c5c:	89 81       	ldd	r24, Y+1	; 0x01
    4c5e:	98 13       	cpse	r25, r24
    4c60:	0d c0       	rjmp	.+26     	; 0x4c7c <simple_p_reassembly+0xc8>
    callback_data_received(messages[id].message, messages[id].num_received_bytes);
    4c62:	e0 91 c0 1b 	lds	r30, 0x1BC0	; 0x801bc0 <callback_data_received>
    4c66:	f0 91 c1 1b 	lds	r31, 0x1BC1	; 0x801bc1 <callback_data_received+0x1>
    4c6a:	8b e2       	ldi	r24, 0x2B	; 43
    4c6c:	9a e1       	ldi	r25, 0x1A	; 26
    4c6e:	19 95       	eicall
    messages[id].num_received_bytes = messages[id].next_part = 0;
    4c70:	f7 01       	movw	r30, r14
    4c72:	14 82       	std	Z+4, r1	; 0x04
    4c74:	13 82       	std	Z+3, r1	; 0x03
    4c76:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    4c78:	8f ef       	ldi	r24, 0xFF	; 255
    4c7a:	81 83       	std	Z+1, r24	; 0x01
  }
    4c7c:	df 91       	pop	r29
    4c7e:	cf 91       	pop	r28
    4c80:	1f 91       	pop	r17
    4c82:	0f 91       	pop	r16
    4c84:	ff 90       	pop	r15
    4c86:	ef 90       	pop	r14
    4c88:	08 95       	ret

00004c8a <simple_p_init>:
void (*callback_data_received)(uint8_t*, uint16_t); 

void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length);

void simple_p_init(void (*cb)(uint8_t*, uint16_t)) {
  callback_data_received = cb;
    4c8a:	90 93 c1 1b 	sts	0x1BC1, r25	; 0x801bc1 <callback_data_received+0x1>
    4c8e:	80 93 c0 1b 	sts	0x1BC0, r24	; 0x801bc0 <callback_data_received>
  uint8_t i;
  network_set_callback(PROTOCOL_SIMPLE, simple_p_reassembly);
    4c92:	6a ed       	ldi	r22, 0xDA	; 218
    4c94:	75 e2       	ldi	r23, 0x25	; 37
    4c96:	80 e0       	ldi	r24, 0x00	; 0
    4c98:	0e 94 55 1b 	call	0x36aa	; 0x36aa <network_set_callback>
  for(i=0;i<MAX_MESSAGES;i++) {
    messages[i].address = 0xFF;
    4c9c:	8f ef       	ldi	r24, 0xFF	; 255
    4c9e:	80 93 27 1a 	sts	0x1A27, r24	; 0x801a27 <messages+0x1>
    4ca2:	08 95       	ret

00004ca4 <simple_p_send>:
  }
}

uint8_t simple_p_send(uint8_t address, uint8_t *data, uint16_t length) {  
    4ca4:	5f 92       	push	r5
    4ca6:	6f 92       	push	r6
    4ca8:	7f 92       	push	r7
    4caa:	8f 92       	push	r8
    4cac:	9f 92       	push	r9
    4cae:	af 92       	push	r10
    4cb0:	bf 92       	push	r11
    4cb2:	cf 92       	push	r12
    4cb4:	df 92       	push	r13
    4cb6:	ef 92       	push	r14
    4cb8:	ff 92       	push	r15
    4cba:	0f 93       	push	r16
    4cbc:	1f 93       	push	r17
    4cbe:	cf 93       	push	r28
    4cc0:	df 93       	push	r29
    4cc2:	58 2e       	mov	r5, r24
    4cc4:	5b 01       	movw	r10, r22
    4cc6:	8a 01       	movw	r16, r20
  uint16_t tmp;
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
    4cc8:	8c e2       	ldi	r24, 0x2C	; 44
    4cca:	90 e0       	ldi	r25, 0x00	; 0
    4ccc:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4cd0:	7c 01       	movw	r14, r24
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
    4cd2:	98 01       	movw	r18, r16
    4cd4:	36 95       	lsr	r19
    4cd6:	27 95       	ror	r18
    4cd8:	ad e0       	ldi	r26, 0x0D	; 13
    4cda:	b3 ec       	ldi	r27, 0xC3	; 195
    4cdc:	0e 94 29 3b 	call	0x7652	; 0x7652 <__umulhisi3>
    4ce0:	92 95       	swap	r25
    4ce2:	82 95       	swap	r24
    4ce4:	8f 70       	andi	r24, 0x0F	; 15
    4ce6:	89 27       	eor	r24, r25
    4ce8:	9f 70       	andi	r25, 0x0F	; 15
    4cea:	89 27       	eor	r24, r25
    4cec:	4a e2       	ldi	r20, 0x2A	; 42
    4cee:	48 9f       	mul	r20, r24
    4cf0:	90 01       	movw	r18, r0
    4cf2:	49 9f       	mul	r20, r25
    4cf4:	30 0d       	add	r19, r0
    4cf6:	11 24       	eor	r1, r1
    4cf8:	41 e0       	ldi	r20, 0x01	; 1
    4cfa:	02 17       	cp	r16, r18
    4cfc:	13 07       	cpc	r17, r19
    4cfe:	09 f4       	brne	.+2      	; 0x4d02 <simple_p_send+0x5e>
    4d00:	40 e0       	ldi	r20, 0x00	; 0
    4d02:	98 01       	movw	r18, r16
    4d04:	36 95       	lsr	r19
    4d06:	27 95       	ror	r18
    4d08:	ad e0       	ldi	r26, 0x0D	; 13
    4d0a:	b3 ec       	ldi	r27, 0xC3	; 195
    4d0c:	0e 94 29 3b 	call	0x7652	; 0x7652 <__umulhisi3>
    4d10:	92 95       	swap	r25
    4d12:	82 95       	swap	r24
    4d14:	8f 70       	andi	r24, 0x0F	; 15
    4d16:	89 27       	eor	r24, r25
    4d18:	9f 70       	andi	r25, 0x0F	; 15
    4d1a:	89 27       	eor	r24, r25
    4d1c:	84 0f       	add	r24, r20
  while(remaining > 0) {
    4d1e:	01 15       	cp	r16, r1
    4d20:	11 05       	cpc	r17, r1
    4d22:	59 f1       	breq	.+86     	; 0x4d7a <simple_p_send+0xd6>
    4d24:	90 e0       	ldi	r25, 0x00	; 0
    4d26:	c1 2c       	mov	r12, r1
    4d28:	d1 2c       	mov	r13, r1
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    part[1] = number_of_parts-1;
    4d2a:	66 24       	eor	r6, r6
    4d2c:	6a 94       	dec	r6
    4d2e:	68 0e       	add	r6, r24
    memcpy(part+2, data+offset, tmp);
    4d30:	47 01       	movw	r8, r14
    4d32:	82 e0       	ldi	r24, 0x02	; 2
    4d34:	88 0e       	add	r8, r24
    4d36:	91 1c       	adc	r9, r1
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    4d38:	e8 01       	movw	r28, r16
    4d3a:	0b 32       	cpi	r16, 0x2B	; 43
    4d3c:	11 05       	cpc	r17, r1
    4d3e:	10 f0       	brcs	.+4      	; 0x4d44 <simple_p_send+0xa0>
    4d40:	ca e2       	ldi	r28, 0x2A	; 42
    4d42:	d0 e0       	ldi	r29, 0x00	; 0
    part[0] = part_number++;
    4d44:	77 24       	eor	r7, r7
    4d46:	73 94       	inc	r7
    4d48:	79 0e       	add	r7, r25
    4d4a:	f7 01       	movw	r30, r14
    4d4c:	90 83       	st	Z, r25
    part[1] = number_of_parts-1;
    4d4e:	61 82       	std	Z+1, r6	; 0x01
    memcpy(part+2, data+offset, tmp);
    4d50:	b5 01       	movw	r22, r10
    4d52:	6c 0d       	add	r22, r12
    4d54:	7d 1d       	adc	r23, r13
    4d56:	ae 01       	movw	r20, r28
    4d58:	c4 01       	movw	r24, r8
    4d5a:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    4d5e:	9e 01       	movw	r18, r28
    4d60:	2e 5f       	subi	r18, 0xFE	; 254
    4d62:	3f 4f       	sbci	r19, 0xFF	; 255
    4d64:	a7 01       	movw	r20, r14
    4d66:	60 e0       	ldi	r22, 0x00	; 0
    4d68:	85 2d       	mov	r24, r5
    4d6a:	0e 94 60 1b 	call	0x36c0	; 0x36c0 <network_send>
    offset += tmp;
    4d6e:	cc 0e       	add	r12, r28
    4d70:	dd 1e       	adc	r13, r29
    remaining -= tmp;
    4d72:	0c 1b       	sub	r16, r28
    4d74:	1d 0b       	sbc	r17, r29
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    tmp = remaining < (MAX_PAYLOAD_SIZE-2) ? remaining : (MAX_PAYLOAD_SIZE-2);
    part[0] = part_number++;
    4d76:	97 2d       	mov	r25, r7
  uint16_t remaining = length;
  uint16_t offset = 0;
  uint8_t *part = pvPortMalloc(MAX_PAYLOAD_SIZE);
  uint8_t part_number=0;
  uint8_t number_of_parts = (length/(MAX_PAYLOAD_SIZE-2)) + (length % (MAX_PAYLOAD_SIZE-2) != 0);
  while(remaining > 0) {
    4d78:	f9 f6       	brne	.-66     	; 0x4d38 <simple_p_send+0x94>
    memcpy(part+2, data+offset, tmp);
    network_send(address, PROTOCOL_SIMPLE, part, tmp+2);
    offset += tmp;
    remaining -= tmp;
  }
  vPortFree(part);
    4d7a:	c7 01       	movw	r24, r14
    4d7c:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
  return 1;
}
    4d80:	81 e0       	ldi	r24, 0x01	; 1
    4d82:	df 91       	pop	r29
    4d84:	cf 91       	pop	r28
    4d86:	1f 91       	pop	r17
    4d88:	0f 91       	pop	r16
    4d8a:	ff 90       	pop	r15
    4d8c:	ef 90       	pop	r14
    4d8e:	df 90       	pop	r13
    4d90:	cf 90       	pop	r12
    4d92:	bf 90       	pop	r11
    4d94:	af 90       	pop	r10
    4d96:	9f 90       	pop	r9
    4d98:	8f 90       	pop	r8
    4d9a:	7f 90       	pop	r7
    4d9c:	6f 90       	pop	r6
    4d9e:	5f 90       	pop	r5
    4da0:	08 95       	ret

00004da2 <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    4da2:	84 b1       	in	r24, 0x04	; 4
    4da4:	87 60       	ori	r24, 0x07	; 7
    4da6:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    4da8:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    4daa:	8c b5       	in	r24, 0x2c	; 44
    4dac:	81 60       	ori	r24, 0x01	; 1
    4dae:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    4db0:	8c b5       	in	r24, 0x2c	; 44
    4db2:	8c 65       	ori	r24, 0x5C	; 92
    4db4:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    4db6:	8c b5       	in	r24, 0x2c	; 44
    4db8:	8f 7d       	andi	r24, 0xDF	; 223
    4dba:	8c bd       	out	0x2c, r24	; 44
    4dbc:	08 95       	ret

00004dbe <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    4dbe:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    4dc0:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    4dc2:	0d b4       	in	r0, 0x2d	; 45
    4dc4:	07 fe       	sbrs	r0, 7
    4dc6:	fd cf       	rjmp	.-6      	; 0x4dc2 <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    4dc8:	8e b5       	in	r24, 0x2e	; 46
}
    4dca:	08 95       	ret

00004dcc <xTaskGenericCreate>:
    4dcc:	4f 92       	push	r4
    4dce:	5f 92       	push	r5
    4dd0:	6f 92       	push	r6
    4dd2:	7f 92       	push	r7
    4dd4:	8f 92       	push	r8
    4dd6:	9f 92       	push	r9
    4dd8:	af 92       	push	r10
    4dda:	bf 92       	push	r11
    4ddc:	cf 92       	push	r12
    4dde:	df 92       	push	r13
    4de0:	ef 92       	push	r14
    4de2:	ff 92       	push	r15
    4de4:	0f 93       	push	r16
    4de6:	1f 93       	push	r17
    4de8:	cf 93       	push	r28
    4dea:	df 93       	push	r29
    4dec:	4c 01       	movw	r8, r24
    4dee:	eb 01       	movw	r28, r22
    4df0:	5a 01       	movw	r10, r20
    4df2:	29 01       	movw	r4, r18
    4df4:	c1 14       	cp	r12, r1
    4df6:	d1 04       	cpc	r13, r1
    4df8:	39 f4       	brne	.+14     	; 0x4e08 <xTaskGenericCreate+0x3c>
    4dfa:	ca 01       	movw	r24, r20
    4dfc:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4e00:	6c 01       	movw	r12, r24
    4e02:	89 2b       	or	r24, r25
    4e04:	09 f4       	brne	.+2      	; 0x4e08 <xTaskGenericCreate+0x3c>
    4e06:	ec c0       	rjmp	.+472    	; 0x4fe0 <xTaskGenericCreate+0x214>
    4e08:	88 e2       	ldi	r24, 0x28	; 40
    4e0a:	90 e0       	ldi	r25, 0x00	; 0
    4e0c:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    4e10:	3c 01       	movw	r6, r24
    4e12:	00 97       	sbiw	r24, 0x00	; 0
    4e14:	b9 f0       	breq	.+46     	; 0x4e44 <xTaskGenericCreate+0x78>
    4e16:	fc 01       	movw	r30, r24
    4e18:	d0 8e       	std	Z+24, r13	; 0x18
    4e1a:	c7 8a       	std	Z+23, r12	; 0x17
    4e1c:	a5 01       	movw	r20, r10
    4e1e:	65 ea       	ldi	r22, 0xA5	; 165
    4e20:	70 e0       	ldi	r23, 0x00	; 0
    4e22:	c6 01       	movw	r24, r12
    4e24:	0e 94 38 3c 	call	0x7870	; 0x7870 <memset>
    4e28:	f1 e0       	ldi	r31, 0x01	; 1
    4e2a:	af 1a       	sub	r10, r31
    4e2c:	b1 08       	sbc	r11, r1
    4e2e:	f3 01       	movw	r30, r6
    4e30:	87 89       	ldd	r24, Z+23	; 0x17
    4e32:	90 8d       	ldd	r25, Z+24	; 0x18
    4e34:	a8 0e       	add	r10, r24
    4e36:	b9 1e       	adc	r11, r25
    4e38:	88 81       	ld	r24, Y
    4e3a:	81 8f       	std	Z+25, r24	; 0x19
    4e3c:	88 81       	ld	r24, Y
    4e3e:	81 11       	cpse	r24, r1
    4e40:	05 c0       	rjmp	.+10     	; 0x4e4c <xTaskGenericCreate+0x80>
    4e42:	14 c0       	rjmp	.+40     	; 0x4e6c <xTaskGenericCreate+0xa0>
    4e44:	c6 01       	movw	r24, r12
    4e46:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    4e4a:	ca c0       	rjmp	.+404    	; 0x4fe0 <xTaskGenericCreate+0x214>
    4e4c:	d3 01       	movw	r26, r6
    4e4e:	5a 96       	adiw	r26, 0x1a	; 26
    4e50:	fe 01       	movw	r30, r28
    4e52:	31 96       	adiw	r30, 0x01	; 1
    4e54:	9e 01       	movw	r18, r28
    4e56:	28 5f       	subi	r18, 0xF8	; 248
    4e58:	3f 4f       	sbci	r19, 0xFF	; 255
    4e5a:	ef 01       	movw	r28, r30
    4e5c:	81 91       	ld	r24, Z+
    4e5e:	8d 93       	st	X+, r24
    4e60:	88 81       	ld	r24, Y
    4e62:	88 23       	and	r24, r24
    4e64:	19 f0       	breq	.+6      	; 0x4e6c <xTaskGenericCreate+0xa0>
    4e66:	2e 17       	cp	r18, r30
    4e68:	3f 07       	cpc	r19, r31
    4e6a:	b9 f7       	brne	.-18     	; 0x4e5a <xTaskGenericCreate+0x8e>
    4e6c:	f3 01       	movw	r30, r6
    4e6e:	10 a2       	std	Z+32, r1	; 0x20
    4e70:	10 2f       	mov	r17, r16
    4e72:	06 30       	cpi	r16, 0x06	; 6
    4e74:	08 f0       	brcs	.+2      	; 0x4e78 <xTaskGenericCreate+0xac>
    4e76:	15 e0       	ldi	r17, 0x05	; 5
    4e78:	f3 01       	movw	r30, r6
    4e7a:	16 8b       	std	Z+22, r17	; 0x16
    4e7c:	11 a3       	std	Z+33, r17	; 0x21
    4e7e:	12 a2       	std	Z+34, r1	; 0x22
    4e80:	e3 01       	movw	r28, r6
    4e82:	22 96       	adiw	r28, 0x02	; 2
    4e84:	ce 01       	movw	r24, r28
    4e86:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialiseItem>
    4e8a:	c3 01       	movw	r24, r6
    4e8c:	0c 96       	adiw	r24, 0x0c	; 12
    4e8e:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialiseItem>
    4e92:	f3 01       	movw	r30, r6
    4e94:	71 86       	std	Z+9, r7	; 0x09
    4e96:	60 86       	std	Z+8, r6	; 0x08
    4e98:	86 e0       	ldi	r24, 0x06	; 6
    4e9a:	90 e0       	ldi	r25, 0x00	; 0
    4e9c:	81 1b       	sub	r24, r17
    4e9e:	91 09       	sbc	r25, r1
    4ea0:	95 87       	std	Z+13, r25	; 0x0d
    4ea2:	84 87       	std	Z+12, r24	; 0x0c
    4ea4:	73 8a       	std	Z+19, r7	; 0x13
    4ea6:	62 8a       	std	Z+18, r6	; 0x12
    4ea8:	13 a2       	std	Z+35, r1	; 0x23
    4eaa:	14 a2       	std	Z+36, r1	; 0x24
    4eac:	15 a2       	std	Z+37, r1	; 0x25
    4eae:	16 a2       	std	Z+38, r1	; 0x26
    4eb0:	17 a2       	std	Z+39, r1	; 0x27
    4eb2:	a2 01       	movw	r20, r4
    4eb4:	b4 01       	movw	r22, r8
    4eb6:	c5 01       	movw	r24, r10
    4eb8:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <pxPortInitialiseStack>
    4ebc:	f3 01       	movw	r30, r6
    4ebe:	91 83       	std	Z+1, r25	; 0x01
    4ec0:	80 83       	st	Z, r24
    4ec2:	e1 14       	cp	r14, r1
    4ec4:	f1 04       	cpc	r15, r1
    4ec6:	19 f0       	breq	.+6      	; 0x4ece <xTaskGenericCreate+0x102>
    4ec8:	f7 01       	movw	r30, r14
    4eca:	71 82       	std	Z+1, r7	; 0x01
    4ecc:	60 82       	st	Z, r6
    4ece:	0f b6       	in	r0, 0x3f	; 63
    4ed0:	f8 94       	cli
    4ed2:	0f 92       	push	r0
    4ed4:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    4ed8:	8f 5f       	subi	r24, 0xFF	; 255
    4eda:	80 93 9a 1a 	sts	0x1A9A, r24	; 0x801a9a <uxCurrentNumberOfTasks>
    4ede:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    4ee2:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    4ee6:	89 2b       	or	r24, r25
    4ee8:	d9 f5       	brne	.+118    	; 0x4f60 <xTaskGenericCreate+0x194>
    4eea:	70 92 fa 1a 	sts	0x1AFA, r7	; 0x801afa <pxCurrentTCB+0x1>
    4eee:	60 92 f9 1a 	sts	0x1AF9, r6	; 0x801af9 <pxCurrentTCB>
    4ef2:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    4ef6:	81 30       	cpi	r24, 0x01	; 1
    4ef8:	09 f0       	breq	.+2      	; 0x4efc <xTaskGenericCreate+0x130>
    4efa:	41 c0       	rjmp	.+130    	; 0x4f7e <xTaskGenericCreate+0x1b2>
    4efc:	0f 2e       	mov	r0, r31
    4efe:	f3 ec       	ldi	r31, 0xC3	; 195
    4f00:	ef 2e       	mov	r14, r31
    4f02:	fa e1       	ldi	r31, 0x1A	; 26
    4f04:	ff 2e       	mov	r15, r31
    4f06:	f0 2d       	mov	r31, r0
    4f08:	0f 2e       	mov	r0, r31
    4f0a:	f9 ef       	ldi	r31, 0xF9	; 249
    4f0c:	cf 2e       	mov	r12, r31
    4f0e:	fa e1       	ldi	r31, 0x1A	; 26
    4f10:	df 2e       	mov	r13, r31
    4f12:	f0 2d       	mov	r31, r0
    4f14:	c7 01       	movw	r24, r14
    4f16:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4f1a:	f9 e0       	ldi	r31, 0x09	; 9
    4f1c:	ef 0e       	add	r14, r31
    4f1e:	f1 1c       	adc	r15, r1
    4f20:	ec 14       	cp	r14, r12
    4f22:	fd 04       	cpc	r15, r13
    4f24:	b9 f7       	brne	.-18     	; 0x4f14 <xTaskGenericCreate+0x148>
    4f26:	8a eb       	ldi	r24, 0xBA	; 186
    4f28:	9a e1       	ldi	r25, 0x1A	; 26
    4f2a:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4f2e:	81 eb       	ldi	r24, 0xB1	; 177
    4f30:	9a e1       	ldi	r25, 0x1A	; 26
    4f32:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4f36:	84 ea       	ldi	r24, 0xA4	; 164
    4f38:	9a e1       	ldi	r25, 0x1A	; 26
    4f3a:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4f3e:	8b e9       	ldi	r24, 0x9B	; 155
    4f40:	9a e1       	ldi	r25, 0x1A	; 26
    4f42:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    4f46:	8a eb       	ldi	r24, 0xBA	; 186
    4f48:	9a e1       	ldi	r25, 0x1A	; 26
    4f4a:	90 93 b0 1a 	sts	0x1AB0, r25	; 0x801ab0 <pxDelayedTaskList+0x1>
    4f4e:	80 93 af 1a 	sts	0x1AAF, r24	; 0x801aaf <pxDelayedTaskList>
    4f52:	81 eb       	ldi	r24, 0xB1	; 177
    4f54:	9a e1       	ldi	r25, 0x1A	; 26
    4f56:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    4f5a:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    4f5e:	0f c0       	rjmp	.+30     	; 0x4f7e <xTaskGenericCreate+0x1b2>
    4f60:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <xSchedulerRunning>
    4f64:	81 11       	cpse	r24, r1
    4f66:	0b c0       	rjmp	.+22     	; 0x4f7e <xTaskGenericCreate+0x1b2>
    4f68:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    4f6c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    4f70:	86 89       	ldd	r24, Z+22	; 0x16
    4f72:	08 17       	cp	r16, r24
    4f74:	20 f0       	brcs	.+8      	; 0x4f7e <xTaskGenericCreate+0x1b2>
    4f76:	70 92 fa 1a 	sts	0x1AFA, r7	; 0x801afa <pxCurrentTCB+0x1>
    4f7a:	60 92 f9 1a 	sts	0x1AF9, r6	; 0x801af9 <pxCurrentTCB>
    4f7e:	80 91 92 1a 	lds	r24, 0x1A92	; 0x801a92 <uxTaskNumber>
    4f82:	8f 5f       	subi	r24, 0xFF	; 255
    4f84:	80 93 92 1a 	sts	0x1A92, r24	; 0x801a92 <uxTaskNumber>
    4f88:	f3 01       	movw	r30, r6
    4f8a:	86 89       	ldd	r24, Z+22	; 0x16
    4f8c:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    4f90:	98 17       	cp	r25, r24
    4f92:	10 f4       	brcc	.+4      	; 0x4f98 <xTaskGenericCreate+0x1cc>
    4f94:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    4f98:	90 e0       	ldi	r25, 0x00	; 0
    4f9a:	9c 01       	movw	r18, r24
    4f9c:	22 0f       	add	r18, r18
    4f9e:	33 1f       	adc	r19, r19
    4fa0:	22 0f       	add	r18, r18
    4fa2:	33 1f       	adc	r19, r19
    4fa4:	22 0f       	add	r18, r18
    4fa6:	33 1f       	adc	r19, r19
    4fa8:	82 0f       	add	r24, r18
    4faa:	93 1f       	adc	r25, r19
    4fac:	be 01       	movw	r22, r28
    4fae:	8d 53       	subi	r24, 0x3D	; 61
    4fb0:	95 4e       	sbci	r25, 0xE5	; 229
    4fb2:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    4fb6:	0f 90       	pop	r0
    4fb8:	0f be       	out	0x3f, r0	; 63
    4fba:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <xSchedulerRunning>
    4fbe:	88 23       	and	r24, r24
    4fc0:	59 f0       	breq	.+22     	; 0x4fd8 <xTaskGenericCreate+0x20c>
    4fc2:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    4fc6:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    4fca:	86 89       	ldd	r24, Z+22	; 0x16
    4fcc:	80 17       	cp	r24, r16
    4fce:	30 f4       	brcc	.+12     	; 0x4fdc <xTaskGenericCreate+0x210>
    4fd0:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    4fd4:	81 e0       	ldi	r24, 0x01	; 1
    4fd6:	05 c0       	rjmp	.+10     	; 0x4fe2 <xTaskGenericCreate+0x216>
    4fd8:	81 e0       	ldi	r24, 0x01	; 1
    4fda:	03 c0       	rjmp	.+6      	; 0x4fe2 <xTaskGenericCreate+0x216>
    4fdc:	81 e0       	ldi	r24, 0x01	; 1
    4fde:	01 c0       	rjmp	.+2      	; 0x4fe2 <xTaskGenericCreate+0x216>
    4fe0:	8f ef       	ldi	r24, 0xFF	; 255
    4fe2:	df 91       	pop	r29
    4fe4:	cf 91       	pop	r28
    4fe6:	1f 91       	pop	r17
    4fe8:	0f 91       	pop	r16
    4fea:	ff 90       	pop	r15
    4fec:	ef 90       	pop	r14
    4fee:	df 90       	pop	r13
    4ff0:	cf 90       	pop	r12
    4ff2:	bf 90       	pop	r11
    4ff4:	af 90       	pop	r10
    4ff6:	9f 90       	pop	r9
    4ff8:	8f 90       	pop	r8
    4ffa:	7f 90       	pop	r7
    4ffc:	6f 90       	pop	r6
    4ffe:	5f 90       	pop	r5
    5000:	4f 90       	pop	r4
    5002:	08 95       	ret

00005004 <vTaskDelayUntil>:
    5004:	9f 92       	push	r9
    5006:	af 92       	push	r10
    5008:	bf 92       	push	r11
    500a:	cf 92       	push	r12
    500c:	df 92       	push	r13
    500e:	ef 92       	push	r14
    5010:	ff 92       	push	r15
    5012:	0f 93       	push	r16
    5014:	1f 93       	push	r17
    5016:	cf 93       	push	r28
    5018:	df 93       	push	r29
    501a:	fc 01       	movw	r30, r24
    501c:	90 91 8f 1a 	lds	r25, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5020:	9f 5f       	subi	r25, 0xFF	; 255
    5022:	90 93 8f 1a 	sts	0x1A8F, r25	; 0x801a8f <uxSchedulerSuspended>
    5026:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    502a:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    502e:	20 81       	ld	r18, Z
    5030:	31 81       	ldd	r19, Z+1	; 0x01
    5032:	e9 01       	movw	r28, r18
    5034:	c6 0f       	add	r28, r22
    5036:	d7 1f       	adc	r29, r23
    5038:	82 17       	cp	r24, r18
    503a:	93 07       	cpc	r25, r19
    503c:	58 f4       	brcc	.+22     	; 0x5054 <vTaskDelayUntil+0x50>
    503e:	c2 17       	cp	r28, r18
    5040:	d3 07       	cpc	r29, r19
    5042:	08 f0       	brcs	.+2      	; 0x5046 <vTaskDelayUntil+0x42>
    5044:	6e c1       	rjmp	.+732    	; 0x5322 <vTaskDelayUntil+0x31e>
    5046:	d1 83       	std	Z+1, r29	; 0x01
    5048:	c0 83       	st	Z, r28
    504a:	8c 17       	cp	r24, r28
    504c:	9d 07       	cpc	r25, r29
    504e:	08 f0       	brcs	.+2      	; 0x5052 <vTaskDelayUntil+0x4e>
    5050:	42 c0       	rjmp	.+132    	; 0x50d6 <vTaskDelayUntil+0xd2>
    5052:	09 c0       	rjmp	.+18     	; 0x5066 <vTaskDelayUntil+0x62>
    5054:	c2 17       	cp	r28, r18
    5056:	d3 07       	cpc	r29, r19
    5058:	08 f4       	brcc	.+2      	; 0x505c <vTaskDelayUntil+0x58>
    505a:	60 c1       	rjmp	.+704    	; 0x531c <vTaskDelayUntil+0x318>
    505c:	8c 17       	cp	r24, r28
    505e:	9d 07       	cpc	r25, r29
    5060:	08 f4       	brcc	.+2      	; 0x5064 <vTaskDelayUntil+0x60>
    5062:	5c c1       	rjmp	.+696    	; 0x531c <vTaskDelayUntil+0x318>
    5064:	5e c1       	rjmp	.+700    	; 0x5322 <vTaskDelayUntil+0x31e>
    5066:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    506a:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    506e:	02 96       	adiw	r24, 0x02	; 2
    5070:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5074:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5078:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    507c:	d3 83       	std	Z+3, r29	; 0x03
    507e:	c2 83       	std	Z+2, r28	; 0x02
    5080:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5084:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5088:	c8 17       	cp	r28, r24
    508a:	d9 07       	cpc	r29, r25
    508c:	68 f4       	brcc	.+26     	; 0x50a8 <vTaskDelayUntil+0xa4>
    508e:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5092:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5096:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    509a:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    509e:	6e 5f       	subi	r22, 0xFE	; 254
    50a0:	7f 4f       	sbci	r23, 0xFF	; 255
    50a2:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    50a6:	17 c0       	rjmp	.+46     	; 0x50d6 <vTaskDelayUntil+0xd2>
    50a8:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    50ac:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    50b0:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    50b4:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    50b8:	6e 5f       	subi	r22, 0xFE	; 254
    50ba:	7f 4f       	sbci	r23, 0xFF	; 255
    50bc:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    50c0:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    50c4:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    50c8:	c8 17       	cp	r28, r24
    50ca:	d9 07       	cpc	r29, r25
    50cc:	20 f4       	brcc	.+8      	; 0x50d6 <vTaskDelayUntil+0xd2>
    50ce:	d0 93 91 1a 	sts	0x1A91, r29	; 0x801a91 <xNextTaskUnblockTime+0x1>
    50d2:	c0 93 90 1a 	sts	0x1A90, r28	; 0x801a90 <xNextTaskUnblockTime>
    50d6:	0f b6       	in	r0, 0x3f	; 63
    50d8:	f8 94       	cli
    50da:	0f 92       	push	r0
    50dc:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    50e0:	81 50       	subi	r24, 0x01	; 1
    50e2:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <uxSchedulerSuspended>
    50e6:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    50ea:	81 11       	cpse	r24, r1
    50ec:	0d c1       	rjmp	.+538    	; 0x5308 <vTaskDelayUntil+0x304>
    50ee:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    50f2:	81 11       	cpse	r24, r1
    50f4:	33 c0       	rjmp	.+102    	; 0x515c <vTaskDelayUntil+0x158>
    50f6:	0b c1       	rjmp	.+534    	; 0x530e <vTaskDelayUntil+0x30a>
    50f8:	d7 01       	movw	r26, r14
    50fa:	15 96       	adiw	r26, 0x05	; 5
    50fc:	ed 91       	ld	r30, X+
    50fe:	fc 91       	ld	r31, X
    5100:	16 97       	sbiw	r26, 0x06	; 6
    5102:	c6 81       	ldd	r28, Z+6	; 0x06
    5104:	d7 81       	ldd	r29, Z+7	; 0x07
    5106:	ce 01       	movw	r24, r28
    5108:	0c 96       	adiw	r24, 0x0c	; 12
    510a:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    510e:	8e 01       	movw	r16, r28
    5110:	0e 5f       	subi	r16, 0xFE	; 254
    5112:	1f 4f       	sbci	r17, 0xFF	; 255
    5114:	c8 01       	movw	r24, r16
    5116:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    511a:	8e 89       	ldd	r24, Y+22	; 0x16
    511c:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5120:	98 17       	cp	r25, r24
    5122:	10 f4       	brcc	.+4      	; 0x5128 <vTaskDelayUntil+0x124>
    5124:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5128:	90 e0       	ldi	r25, 0x00	; 0
    512a:	9c 01       	movw	r18, r24
    512c:	22 0f       	add	r18, r18
    512e:	33 1f       	adc	r19, r19
    5130:	22 0f       	add	r18, r18
    5132:	33 1f       	adc	r19, r19
    5134:	22 0f       	add	r18, r18
    5136:	33 1f       	adc	r19, r19
    5138:	82 0f       	add	r24, r18
    513a:	93 1f       	adc	r25, r19
    513c:	b8 01       	movw	r22, r16
    513e:	8d 53       	subi	r24, 0x3D	; 61
    5140:	95 4e       	sbci	r25, 0xE5	; 229
    5142:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5146:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    514a:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    514e:	9e 89       	ldd	r25, Y+22	; 0x16
    5150:	86 89       	ldd	r24, Z+22	; 0x16
    5152:	98 17       	cp	r25, r24
    5154:	58 f0       	brcs	.+22     	; 0x516c <vTaskDelayUntil+0x168>
    5156:	d0 92 94 1a 	sts	0x1A94, r13	; 0x801a94 <xYieldPending>
    515a:	08 c0       	rjmp	.+16     	; 0x516c <vTaskDelayUntil+0x168>
    515c:	0f 2e       	mov	r0, r31
    515e:	f4 ea       	ldi	r31, 0xA4	; 164
    5160:	ef 2e       	mov	r14, r31
    5162:	fa e1       	ldi	r31, 0x1A	; 26
    5164:	ff 2e       	mov	r15, r31
    5166:	f0 2d       	mov	r31, r0
    5168:	dd 24       	eor	r13, r13
    516a:	d3 94       	inc	r13
    516c:	f7 01       	movw	r30, r14
    516e:	80 81       	ld	r24, Z
    5170:	81 11       	cpse	r24, r1
    5172:	c2 cf       	rjmp	.-124    	; 0x50f8 <vTaskDelayUntil+0xf4>
    5174:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5178:	88 23       	and	r24, r24
    517a:	09 f4       	brne	.+2      	; 0x517e <vTaskDelayUntil+0x17a>
    517c:	bd c0       	rjmp	.+378    	; 0x52f8 <vTaskDelayUntil+0x2f4>
    517e:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5182:	88 23       	and	r24, r24
    5184:	09 f4       	brne	.+2      	; 0x5188 <vTaskDelayUntil+0x184>
    5186:	b8 c0       	rjmp	.+368    	; 0x52f8 <vTaskDelayUntil+0x2f4>
    5188:	91 2c       	mov	r9, r1
    518a:	bb 24       	eor	r11, r11
    518c:	b3 94       	inc	r11
    518e:	cc 24       	eor	r12, r12
    5190:	ca 94       	dec	r12
    5192:	dc 2c       	mov	r13, r12
    5194:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5198:	81 11       	cpse	r24, r1
    519a:	98 c0       	rjmp	.+304    	; 0x52cc <vTaskDelayUntil+0x2c8>
    519c:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    51a0:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    51a4:	01 96       	adiw	r24, 0x01	; 1
    51a6:	90 93 99 1a 	sts	0x1A99, r25	; 0x801a99 <xTickCount+0x1>
    51aa:	80 93 98 1a 	sts	0x1A98, r24	; 0x801a98 <xTickCount>
    51ae:	e0 90 98 1a 	lds	r14, 0x1A98	; 0x801a98 <xTickCount>
    51b2:	f0 90 99 1a 	lds	r15, 0x1A99	; 0x801a99 <xTickCount+0x1>
    51b6:	e1 14       	cp	r14, r1
    51b8:	f1 04       	cpc	r15, r1
    51ba:	89 f5       	brne	.+98     	; 0x521e <vTaskDelayUntil+0x21a>
    51bc:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    51c0:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    51c4:	20 91 ad 1a 	lds	r18, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    51c8:	30 91 ae 1a 	lds	r19, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    51cc:	30 93 b0 1a 	sts	0x1AB0, r19	; 0x801ab0 <pxDelayedTaskList+0x1>
    51d0:	20 93 af 1a 	sts	0x1AAF, r18	; 0x801aaf <pxDelayedTaskList>
    51d4:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    51d8:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    51dc:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    51e0:	8f 5f       	subi	r24, 0xFF	; 255
    51e2:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <xNumOfOverflows>
    51e6:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    51ea:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    51ee:	80 81       	ld	r24, Z
    51f0:	81 11       	cpse	r24, r1
    51f2:	05 c0       	rjmp	.+10     	; 0x51fe <vTaskDelayUntil+0x1fa>
    51f4:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    51f8:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    51fc:	10 c0       	rjmp	.+32     	; 0x521e <vTaskDelayUntil+0x21a>
    51fe:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5202:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5206:	05 80       	ldd	r0, Z+5	; 0x05
    5208:	f6 81       	ldd	r31, Z+6	; 0x06
    520a:	e0 2d       	mov	r30, r0
    520c:	06 80       	ldd	r0, Z+6	; 0x06
    520e:	f7 81       	ldd	r31, Z+7	; 0x07
    5210:	e0 2d       	mov	r30, r0
    5212:	82 81       	ldd	r24, Z+2	; 0x02
    5214:	93 81       	ldd	r25, Z+3	; 0x03
    5216:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    521a:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    521e:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    5222:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5226:	e8 16       	cp	r14, r24
    5228:	f9 06       	cpc	r15, r25
    522a:	08 f4       	brcc	.+2      	; 0x522e <vTaskDelayUntil+0x22a>
    522c:	7d c0       	rjmp	.+250    	; 0x5328 <vTaskDelayUntil+0x324>
    522e:	a9 2c       	mov	r10, r9
    5230:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5234:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5238:	80 81       	ld	r24, Z
    523a:	81 11       	cpse	r24, r1
    523c:	05 c0       	rjmp	.+10     	; 0x5248 <vTaskDelayUntil+0x244>
    523e:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5242:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    5246:	48 c0       	rjmp	.+144    	; 0x52d8 <vTaskDelayUntil+0x2d4>
    5248:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    524c:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5250:	05 80       	ldd	r0, Z+5	; 0x05
    5252:	f6 81       	ldd	r31, Z+6	; 0x06
    5254:	e0 2d       	mov	r30, r0
    5256:	c6 81       	ldd	r28, Z+6	; 0x06
    5258:	d7 81       	ldd	r29, Z+7	; 0x07
    525a:	8a 81       	ldd	r24, Y+2	; 0x02
    525c:	9b 81       	ldd	r25, Y+3	; 0x03
    525e:	e8 16       	cp	r14, r24
    5260:	f9 06       	cpc	r15, r25
    5262:	28 f4       	brcc	.+10     	; 0x526e <vTaskDelayUntil+0x26a>
    5264:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5268:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    526c:	35 c0       	rjmp	.+106    	; 0x52d8 <vTaskDelayUntil+0x2d4>
    526e:	8e 01       	movw	r16, r28
    5270:	0e 5f       	subi	r16, 0xFE	; 254
    5272:	1f 4f       	sbci	r17, 0xFF	; 255
    5274:	c8 01       	movw	r24, r16
    5276:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    527a:	8c 89       	ldd	r24, Y+20	; 0x14
    527c:	9d 89       	ldd	r25, Y+21	; 0x15
    527e:	89 2b       	or	r24, r25
    5280:	21 f0       	breq	.+8      	; 0x528a <vTaskDelayUntil+0x286>
    5282:	ce 01       	movw	r24, r28
    5284:	0c 96       	adiw	r24, 0x0c	; 12
    5286:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    528a:	8e 89       	ldd	r24, Y+22	; 0x16
    528c:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5290:	98 17       	cp	r25, r24
    5292:	10 f4       	brcc	.+4      	; 0x5298 <vTaskDelayUntil+0x294>
    5294:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5298:	90 e0       	ldi	r25, 0x00	; 0
    529a:	9c 01       	movw	r18, r24
    529c:	22 0f       	add	r18, r18
    529e:	33 1f       	adc	r19, r19
    52a0:	22 0f       	add	r18, r18
    52a2:	33 1f       	adc	r19, r19
    52a4:	22 0f       	add	r18, r18
    52a6:	33 1f       	adc	r19, r19
    52a8:	82 0f       	add	r24, r18
    52aa:	93 1f       	adc	r25, r19
    52ac:	b8 01       	movw	r22, r16
    52ae:	8d 53       	subi	r24, 0x3D	; 61
    52b0:	95 4e       	sbci	r25, 0xE5	; 229
    52b2:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    52b6:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    52ba:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    52be:	9e 89       	ldd	r25, Y+22	; 0x16
    52c0:	86 89       	ldd	r24, Z+22	; 0x16
    52c2:	98 17       	cp	r25, r24
    52c4:	08 f4       	brcc	.+2      	; 0x52c8 <vTaskDelayUntil+0x2c4>
    52c6:	b4 cf       	rjmp	.-152    	; 0x5230 <vTaskDelayUntil+0x22c>
    52c8:	ab 2c       	mov	r10, r11
    52ca:	b2 cf       	rjmp	.-156    	; 0x5230 <vTaskDelayUntil+0x22c>
    52cc:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    52d0:	8f 5f       	subi	r24, 0xFF	; 255
    52d2:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    52d6:	28 c0       	rjmp	.+80     	; 0x5328 <vTaskDelayUntil+0x324>
    52d8:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    52dc:	81 11       	cpse	r24, r1
    52de:	01 c0       	rjmp	.+2      	; 0x52e2 <vTaskDelayUntil+0x2de>
    52e0:	a1 10       	cpse	r10, r1
    52e2:	b0 92 94 1a 	sts	0x1A94, r11	; 0x801a94 <xYieldPending>
    52e6:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    52ea:	81 50       	subi	r24, 0x01	; 1
    52ec:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    52f0:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    52f4:	81 11       	cpse	r24, r1
    52f6:	4e cf       	rjmp	.-356    	; 0x5194 <vTaskDelayUntil+0x190>
    52f8:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    52fc:	81 30       	cpi	r24, 0x01	; 1
    52fe:	31 f4       	brne	.+12     	; 0x530c <vTaskDelayUntil+0x308>
    5300:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    5304:	81 e0       	ldi	r24, 0x01	; 1
    5306:	03 c0       	rjmp	.+6      	; 0x530e <vTaskDelayUntil+0x30a>
    5308:	80 e0       	ldi	r24, 0x00	; 0
    530a:	01 c0       	rjmp	.+2      	; 0x530e <vTaskDelayUntil+0x30a>
    530c:	80 e0       	ldi	r24, 0x00	; 0
    530e:	0f 90       	pop	r0
    5310:	0f be       	out	0x3f, r0	; 63
    5312:	81 11       	cpse	r24, r1
    5314:	0e c0       	rjmp	.+28     	; 0x5332 <vTaskDelayUntil+0x32e>
    5316:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    531a:	0b c0       	rjmp	.+22     	; 0x5332 <vTaskDelayUntil+0x32e>
    531c:	d1 83       	std	Z+1, r29	; 0x01
    531e:	c0 83       	st	Z, r28
    5320:	a2 ce       	rjmp	.-700    	; 0x5066 <vTaskDelayUntil+0x62>
    5322:	d1 83       	std	Z+1, r29	; 0x01
    5324:	c0 83       	st	Z, r28
    5326:	d7 ce       	rjmp	.-594    	; 0x50d6 <vTaskDelayUntil+0xd2>
    5328:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    532c:	81 11       	cpse	r24, r1
    532e:	d9 cf       	rjmp	.-78     	; 0x52e2 <vTaskDelayUntil+0x2de>
    5330:	da cf       	rjmp	.-76     	; 0x52e6 <vTaskDelayUntil+0x2e2>
    5332:	df 91       	pop	r29
    5334:	cf 91       	pop	r28
    5336:	1f 91       	pop	r17
    5338:	0f 91       	pop	r16
    533a:	ff 90       	pop	r15
    533c:	ef 90       	pop	r14
    533e:	df 90       	pop	r13
    5340:	cf 90       	pop	r12
    5342:	bf 90       	pop	r11
    5344:	af 90       	pop	r10
    5346:	9f 90       	pop	r9
    5348:	08 95       	ret

0000534a <vTaskDelay>:
    534a:	9f 92       	push	r9
    534c:	af 92       	push	r10
    534e:	bf 92       	push	r11
    5350:	cf 92       	push	r12
    5352:	df 92       	push	r13
    5354:	ef 92       	push	r14
    5356:	ff 92       	push	r15
    5358:	0f 93       	push	r16
    535a:	1f 93       	push	r17
    535c:	cf 93       	push	r28
    535e:	df 93       	push	r29
    5360:	00 97       	sbiw	r24, 0x00	; 0
    5362:	09 f4       	brne	.+2      	; 0x5366 <vTaskDelay+0x1c>
    5364:	63 c1       	rjmp	.+710    	; 0x562c <vTaskDelay+0x2e2>
    5366:	20 91 8f 1a 	lds	r18, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    536a:	2f 5f       	subi	r18, 0xFF	; 255
    536c:	20 93 8f 1a 	sts	0x1A8F, r18	; 0x801a8f <uxSchedulerSuspended>
    5370:	c0 91 98 1a 	lds	r28, 0x1A98	; 0x801a98 <xTickCount>
    5374:	d0 91 99 1a 	lds	r29, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5378:	c8 0f       	add	r28, r24
    537a:	d9 1f       	adc	r29, r25
    537c:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5380:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5384:	02 96       	adiw	r24, 0x02	; 2
    5386:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    538a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    538e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5392:	d3 83       	std	Z+3, r29	; 0x03
    5394:	c2 83       	std	Z+2, r28	; 0x02
    5396:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    539a:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    539e:	c8 17       	cp	r28, r24
    53a0:	d9 07       	cpc	r29, r25
    53a2:	68 f4       	brcc	.+26     	; 0x53be <vTaskDelay+0x74>
    53a4:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    53a8:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    53ac:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    53b0:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    53b4:	6e 5f       	subi	r22, 0xFE	; 254
    53b6:	7f 4f       	sbci	r23, 0xFF	; 255
    53b8:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    53bc:	17 c0       	rjmp	.+46     	; 0x53ec <vTaskDelay+0xa2>
    53be:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    53c2:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    53c6:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    53ca:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    53ce:	6e 5f       	subi	r22, 0xFE	; 254
    53d0:	7f 4f       	sbci	r23, 0xFF	; 255
    53d2:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    53d6:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    53da:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    53de:	c8 17       	cp	r28, r24
    53e0:	d9 07       	cpc	r29, r25
    53e2:	20 f4       	brcc	.+8      	; 0x53ec <vTaskDelay+0xa2>
    53e4:	d0 93 91 1a 	sts	0x1A91, r29	; 0x801a91 <xNextTaskUnblockTime+0x1>
    53e8:	c0 93 90 1a 	sts	0x1A90, r28	; 0x801a90 <xNextTaskUnblockTime>
    53ec:	0f b6       	in	r0, 0x3f	; 63
    53ee:	f8 94       	cli
    53f0:	0f 92       	push	r0
    53f2:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    53f6:	81 50       	subi	r24, 0x01	; 1
    53f8:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <uxSchedulerSuspended>
    53fc:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5400:	81 11       	cpse	r24, r1
    5402:	0d c1       	rjmp	.+538    	; 0x561e <vTaskDelay+0x2d4>
    5404:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    5408:	81 11       	cpse	r24, r1
    540a:	33 c0       	rjmp	.+102    	; 0x5472 <vTaskDelay+0x128>
    540c:	0b c1       	rjmp	.+534    	; 0x5624 <vTaskDelay+0x2da>
    540e:	d7 01       	movw	r26, r14
    5410:	15 96       	adiw	r26, 0x05	; 5
    5412:	ed 91       	ld	r30, X+
    5414:	fc 91       	ld	r31, X
    5416:	16 97       	sbiw	r26, 0x06	; 6
    5418:	c6 81       	ldd	r28, Z+6	; 0x06
    541a:	d7 81       	ldd	r29, Z+7	; 0x07
    541c:	ce 01       	movw	r24, r28
    541e:	0c 96       	adiw	r24, 0x0c	; 12
    5420:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5424:	8e 01       	movw	r16, r28
    5426:	0e 5f       	subi	r16, 0xFE	; 254
    5428:	1f 4f       	sbci	r17, 0xFF	; 255
    542a:	c8 01       	movw	r24, r16
    542c:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5430:	8e 89       	ldd	r24, Y+22	; 0x16
    5432:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5436:	98 17       	cp	r25, r24
    5438:	10 f4       	brcc	.+4      	; 0x543e <vTaskDelay+0xf4>
    543a:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    543e:	90 e0       	ldi	r25, 0x00	; 0
    5440:	9c 01       	movw	r18, r24
    5442:	22 0f       	add	r18, r18
    5444:	33 1f       	adc	r19, r19
    5446:	22 0f       	add	r18, r18
    5448:	33 1f       	adc	r19, r19
    544a:	22 0f       	add	r18, r18
    544c:	33 1f       	adc	r19, r19
    544e:	82 0f       	add	r24, r18
    5450:	93 1f       	adc	r25, r19
    5452:	b8 01       	movw	r22, r16
    5454:	8d 53       	subi	r24, 0x3D	; 61
    5456:	95 4e       	sbci	r25, 0xE5	; 229
    5458:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    545c:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5460:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5464:	9e 89       	ldd	r25, Y+22	; 0x16
    5466:	86 89       	ldd	r24, Z+22	; 0x16
    5468:	98 17       	cp	r25, r24
    546a:	58 f0       	brcs	.+22     	; 0x5482 <vTaskDelay+0x138>
    546c:	d0 92 94 1a 	sts	0x1A94, r13	; 0x801a94 <xYieldPending>
    5470:	08 c0       	rjmp	.+16     	; 0x5482 <vTaskDelay+0x138>
    5472:	0f 2e       	mov	r0, r31
    5474:	f4 ea       	ldi	r31, 0xA4	; 164
    5476:	ef 2e       	mov	r14, r31
    5478:	fa e1       	ldi	r31, 0x1A	; 26
    547a:	ff 2e       	mov	r15, r31
    547c:	f0 2d       	mov	r31, r0
    547e:	dd 24       	eor	r13, r13
    5480:	d3 94       	inc	r13
    5482:	f7 01       	movw	r30, r14
    5484:	80 81       	ld	r24, Z
    5486:	81 11       	cpse	r24, r1
    5488:	c2 cf       	rjmp	.-124    	; 0x540e <vTaskDelay+0xc4>
    548a:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    548e:	88 23       	and	r24, r24
    5490:	09 f4       	brne	.+2      	; 0x5494 <vTaskDelay+0x14a>
    5492:	bd c0       	rjmp	.+378    	; 0x560e <vTaskDelay+0x2c4>
    5494:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5498:	88 23       	and	r24, r24
    549a:	09 f4       	brne	.+2      	; 0x549e <vTaskDelay+0x154>
    549c:	b8 c0       	rjmp	.+368    	; 0x560e <vTaskDelay+0x2c4>
    549e:	91 2c       	mov	r9, r1
    54a0:	bb 24       	eor	r11, r11
    54a2:	b3 94       	inc	r11
    54a4:	cc 24       	eor	r12, r12
    54a6:	ca 94       	dec	r12
    54a8:	dc 2c       	mov	r13, r12
    54aa:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    54ae:	81 11       	cpse	r24, r1
    54b0:	98 c0       	rjmp	.+304    	; 0x55e2 <vTaskDelay+0x298>
    54b2:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    54b6:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    54ba:	01 96       	adiw	r24, 0x01	; 1
    54bc:	90 93 99 1a 	sts	0x1A99, r25	; 0x801a99 <xTickCount+0x1>
    54c0:	80 93 98 1a 	sts	0x1A98, r24	; 0x801a98 <xTickCount>
    54c4:	e0 90 98 1a 	lds	r14, 0x1A98	; 0x801a98 <xTickCount>
    54c8:	f0 90 99 1a 	lds	r15, 0x1A99	; 0x801a99 <xTickCount+0x1>
    54cc:	e1 14       	cp	r14, r1
    54ce:	f1 04       	cpc	r15, r1
    54d0:	89 f5       	brne	.+98     	; 0x5534 <vTaskDelay+0x1ea>
    54d2:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    54d6:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    54da:	20 91 ad 1a 	lds	r18, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    54de:	30 91 ae 1a 	lds	r19, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    54e2:	30 93 b0 1a 	sts	0x1AB0, r19	; 0x801ab0 <pxDelayedTaskList+0x1>
    54e6:	20 93 af 1a 	sts	0x1AAF, r18	; 0x801aaf <pxDelayedTaskList>
    54ea:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    54ee:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    54f2:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    54f6:	8f 5f       	subi	r24, 0xFF	; 255
    54f8:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <xNumOfOverflows>
    54fc:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5500:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5504:	80 81       	ld	r24, Z
    5506:	81 11       	cpse	r24, r1
    5508:	05 c0       	rjmp	.+10     	; 0x5514 <vTaskDelay+0x1ca>
    550a:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    550e:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    5512:	10 c0       	rjmp	.+32     	; 0x5534 <vTaskDelay+0x1ea>
    5514:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5518:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    551c:	05 80       	ldd	r0, Z+5	; 0x05
    551e:	f6 81       	ldd	r31, Z+6	; 0x06
    5520:	e0 2d       	mov	r30, r0
    5522:	06 80       	ldd	r0, Z+6	; 0x06
    5524:	f7 81       	ldd	r31, Z+7	; 0x07
    5526:	e0 2d       	mov	r30, r0
    5528:	82 81       	ldd	r24, Z+2	; 0x02
    552a:	93 81       	ldd	r25, Z+3	; 0x03
    552c:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5530:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5534:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    5538:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    553c:	e8 16       	cp	r14, r24
    553e:	f9 06       	cpc	r15, r25
    5540:	08 f4       	brcc	.+2      	; 0x5544 <vTaskDelay+0x1fa>
    5542:	77 c0       	rjmp	.+238    	; 0x5632 <vTaskDelay+0x2e8>
    5544:	a9 2c       	mov	r10, r9
    5546:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    554a:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    554e:	80 81       	ld	r24, Z
    5550:	81 11       	cpse	r24, r1
    5552:	05 c0       	rjmp	.+10     	; 0x555e <vTaskDelay+0x214>
    5554:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5558:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    555c:	48 c0       	rjmp	.+144    	; 0x55ee <vTaskDelay+0x2a4>
    555e:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5562:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5566:	05 80       	ldd	r0, Z+5	; 0x05
    5568:	f6 81       	ldd	r31, Z+6	; 0x06
    556a:	e0 2d       	mov	r30, r0
    556c:	c6 81       	ldd	r28, Z+6	; 0x06
    556e:	d7 81       	ldd	r29, Z+7	; 0x07
    5570:	8a 81       	ldd	r24, Y+2	; 0x02
    5572:	9b 81       	ldd	r25, Y+3	; 0x03
    5574:	e8 16       	cp	r14, r24
    5576:	f9 06       	cpc	r15, r25
    5578:	28 f4       	brcc	.+10     	; 0x5584 <vTaskDelay+0x23a>
    557a:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    557e:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5582:	35 c0       	rjmp	.+106    	; 0x55ee <vTaskDelay+0x2a4>
    5584:	8e 01       	movw	r16, r28
    5586:	0e 5f       	subi	r16, 0xFE	; 254
    5588:	1f 4f       	sbci	r17, 0xFF	; 255
    558a:	c8 01       	movw	r24, r16
    558c:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5590:	8c 89       	ldd	r24, Y+20	; 0x14
    5592:	9d 89       	ldd	r25, Y+21	; 0x15
    5594:	89 2b       	or	r24, r25
    5596:	21 f0       	breq	.+8      	; 0x55a0 <vTaskDelay+0x256>
    5598:	ce 01       	movw	r24, r28
    559a:	0c 96       	adiw	r24, 0x0c	; 12
    559c:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    55a0:	8e 89       	ldd	r24, Y+22	; 0x16
    55a2:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    55a6:	98 17       	cp	r25, r24
    55a8:	10 f4       	brcc	.+4      	; 0x55ae <vTaskDelay+0x264>
    55aa:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    55ae:	90 e0       	ldi	r25, 0x00	; 0
    55b0:	9c 01       	movw	r18, r24
    55b2:	22 0f       	add	r18, r18
    55b4:	33 1f       	adc	r19, r19
    55b6:	22 0f       	add	r18, r18
    55b8:	33 1f       	adc	r19, r19
    55ba:	22 0f       	add	r18, r18
    55bc:	33 1f       	adc	r19, r19
    55be:	82 0f       	add	r24, r18
    55c0:	93 1f       	adc	r25, r19
    55c2:	b8 01       	movw	r22, r16
    55c4:	8d 53       	subi	r24, 0x3D	; 61
    55c6:	95 4e       	sbci	r25, 0xE5	; 229
    55c8:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    55cc:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    55d0:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    55d4:	9e 89       	ldd	r25, Y+22	; 0x16
    55d6:	86 89       	ldd	r24, Z+22	; 0x16
    55d8:	98 17       	cp	r25, r24
    55da:	08 f4       	brcc	.+2      	; 0x55de <vTaskDelay+0x294>
    55dc:	b4 cf       	rjmp	.-152    	; 0x5546 <vTaskDelay+0x1fc>
    55de:	ab 2c       	mov	r10, r11
    55e0:	b2 cf       	rjmp	.-156    	; 0x5546 <vTaskDelay+0x1fc>
    55e2:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    55e6:	8f 5f       	subi	r24, 0xFF	; 255
    55e8:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    55ec:	22 c0       	rjmp	.+68     	; 0x5632 <vTaskDelay+0x2e8>
    55ee:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    55f2:	81 11       	cpse	r24, r1
    55f4:	01 c0       	rjmp	.+2      	; 0x55f8 <vTaskDelay+0x2ae>
    55f6:	a1 10       	cpse	r10, r1
    55f8:	b0 92 94 1a 	sts	0x1A94, r11	; 0x801a94 <xYieldPending>
    55fc:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5600:	81 50       	subi	r24, 0x01	; 1
    5602:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    5606:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    560a:	81 11       	cpse	r24, r1
    560c:	4e cf       	rjmp	.-356    	; 0x54aa <vTaskDelay+0x160>
    560e:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5612:	81 30       	cpi	r24, 0x01	; 1
    5614:	31 f4       	brne	.+12     	; 0x5622 <vTaskDelay+0x2d8>
    5616:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    561a:	81 e0       	ldi	r24, 0x01	; 1
    561c:	03 c0       	rjmp	.+6      	; 0x5624 <vTaskDelay+0x2da>
    561e:	80 e0       	ldi	r24, 0x00	; 0
    5620:	01 c0       	rjmp	.+2      	; 0x5624 <vTaskDelay+0x2da>
    5622:	80 e0       	ldi	r24, 0x00	; 0
    5624:	0f 90       	pop	r0
    5626:	0f be       	out	0x3f, r0	; 63
    5628:	81 11       	cpse	r24, r1
    562a:	08 c0       	rjmp	.+16     	; 0x563c <vTaskDelay+0x2f2>
    562c:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    5630:	05 c0       	rjmp	.+10     	; 0x563c <vTaskDelay+0x2f2>
    5632:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5636:	81 11       	cpse	r24, r1
    5638:	df cf       	rjmp	.-66     	; 0x55f8 <vTaskDelay+0x2ae>
    563a:	e0 cf       	rjmp	.-64     	; 0x55fc <vTaskDelay+0x2b2>
    563c:	df 91       	pop	r29
    563e:	cf 91       	pop	r28
    5640:	1f 91       	pop	r17
    5642:	0f 91       	pop	r16
    5644:	ff 90       	pop	r15
    5646:	ef 90       	pop	r14
    5648:	df 90       	pop	r13
    564a:	cf 90       	pop	r12
    564c:	bf 90       	pop	r11
    564e:	af 90       	pop	r10
    5650:	9f 90       	pop	r9
    5652:	08 95       	ret

00005654 <vTaskStartScheduler>:
    5654:	cf 92       	push	r12
    5656:	df 92       	push	r13
    5658:	ef 92       	push	r14
    565a:	ff 92       	push	r15
    565c:	0f 93       	push	r16
    565e:	1f 93       	push	r17
    5660:	cf 93       	push	r28
    5662:	df 93       	push	r29
    5664:	85 e5       	ldi	r24, 0x55	; 85
    5666:	90 e0       	ldi	r25, 0x00	; 0
    5668:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    566c:	8c 01       	movw	r16, r24
    566e:	89 2b       	or	r24, r25
    5670:	09 f4       	brne	.+2      	; 0x5674 <vTaskStartScheduler+0x20>
    5672:	d4 c0       	rjmp	.+424    	; 0x581c <vTaskStartScheduler+0x1c8>
    5674:	88 e2       	ldi	r24, 0x28	; 40
    5676:	90 e0       	ldi	r25, 0x00	; 0
    5678:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
    567c:	ec 01       	movw	r28, r24
    567e:	89 2b       	or	r24, r25
    5680:	b1 f0       	breq	.+44     	; 0x56ae <vTaskStartScheduler+0x5a>
    5682:	18 8f       	std	Y+24, r17	; 0x18
    5684:	0f 8b       	std	Y+23, r16	; 0x17
    5686:	45 e5       	ldi	r20, 0x55	; 85
    5688:	50 e0       	ldi	r21, 0x00	; 0
    568a:	65 ea       	ldi	r22, 0xA5	; 165
    568c:	70 e0       	ldi	r23, 0x00	; 0
    568e:	c8 01       	movw	r24, r16
    5690:	0e 94 38 3c 	call	0x7870	; 0x7870 <memset>
    5694:	0f 89       	ldd	r16, Y+23	; 0x17
    5696:	18 8d       	ldd	r17, Y+24	; 0x18
    5698:	0c 5a       	subi	r16, 0xAC	; 172
    569a:	1f 4f       	sbci	r17, 0xFF	; 255
    569c:	89 e4       	ldi	r24, 0x49	; 73
    569e:	89 8f       	std	Y+25, r24	; 0x19
    56a0:	ef e4       	ldi	r30, 0x4F	; 79
    56a2:	f7 e0       	ldi	r31, 0x07	; 7
    56a4:	de 01       	movw	r26, r28
    56a6:	5a 96       	adiw	r26, 0x1a	; 26
    56a8:	26 e5       	ldi	r18, 0x56	; 86
    56aa:	37 e0       	ldi	r19, 0x07	; 7
    56ac:	04 c0       	rjmp	.+8      	; 0x56b6 <vTaskStartScheduler+0x62>
    56ae:	c8 01       	movw	r24, r16
    56b0:	0e 94 31 09 	call	0x1262	; 0x1262 <vPortFree>
    56b4:	b3 c0       	rjmp	.+358    	; 0x581c <vTaskStartScheduler+0x1c8>
    56b6:	81 91       	ld	r24, Z+
    56b8:	8d 93       	st	X+, r24
    56ba:	88 23       	and	r24, r24
    56bc:	19 f0       	breq	.+6      	; 0x56c4 <vTaskStartScheduler+0x70>
    56be:	2e 17       	cp	r18, r30
    56c0:	3f 07       	cpc	r19, r31
    56c2:	c9 f7       	brne	.-14     	; 0x56b6 <vTaskStartScheduler+0x62>
    56c4:	18 a2       	std	Y+32, r1	; 0x20
    56c6:	1e 8a       	std	Y+22, r1	; 0x16
    56c8:	19 a2       	std	Y+33, r1	; 0x21
    56ca:	1a a2       	std	Y+34, r1	; 0x22
    56cc:	7e 01       	movw	r14, r28
    56ce:	82 e0       	ldi	r24, 0x02	; 2
    56d0:	e8 0e       	add	r14, r24
    56d2:	f1 1c       	adc	r15, r1
    56d4:	c7 01       	movw	r24, r14
    56d6:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialiseItem>
    56da:	ce 01       	movw	r24, r28
    56dc:	0c 96       	adiw	r24, 0x0c	; 12
    56de:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialiseItem>
    56e2:	d9 87       	std	Y+9, r29	; 0x09
    56e4:	c8 87       	std	Y+8, r28	; 0x08
    56e6:	86 e0       	ldi	r24, 0x06	; 6
    56e8:	90 e0       	ldi	r25, 0x00	; 0
    56ea:	9d 87       	std	Y+13, r25	; 0x0d
    56ec:	8c 87       	std	Y+12, r24	; 0x0c
    56ee:	db 8b       	std	Y+19, r29	; 0x13
    56f0:	ca 8b       	std	Y+18, r28	; 0x12
    56f2:	1b a2       	std	Y+35, r1	; 0x23
    56f4:	1c a2       	std	Y+36, r1	; 0x24
    56f6:	1d a2       	std	Y+37, r1	; 0x25
    56f8:	1e a2       	std	Y+38, r1	; 0x26
    56fa:	1f a2       	std	Y+39, r1	; 0x27
    56fc:	40 e0       	ldi	r20, 0x00	; 0
    56fe:	50 e0       	ldi	r21, 0x00	; 0
    5700:	69 e1       	ldi	r22, 0x19	; 25
    5702:	71 e0       	ldi	r23, 0x01	; 1
    5704:	c8 01       	movw	r24, r16
    5706:	0e 94 d2 1b 	call	0x37a4	; 0x37a4 <pxPortInitialiseStack>
    570a:	99 83       	std	Y+1, r25	; 0x01
    570c:	88 83       	st	Y, r24
    570e:	0f b6       	in	r0, 0x3f	; 63
    5710:	f8 94       	cli
    5712:	0f 92       	push	r0
    5714:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    5718:	8f 5f       	subi	r24, 0xFF	; 255
    571a:	80 93 9a 1a 	sts	0x1A9A, r24	; 0x801a9a <uxCurrentNumberOfTasks>
    571e:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5722:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5726:	89 2b       	or	r24, r25
    5728:	a9 f5       	brne	.+106    	; 0x5794 <vTaskStartScheduler+0x140>
    572a:	d0 93 fa 1a 	sts	0x1AFA, r29	; 0x801afa <pxCurrentTCB+0x1>
    572e:	c0 93 f9 1a 	sts	0x1AF9, r28	; 0x801af9 <pxCurrentTCB>
    5732:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    5736:	81 30       	cpi	r24, 0x01	; 1
    5738:	e1 f5       	brne	.+120    	; 0x57b2 <vTaskStartScheduler+0x15e>
    573a:	03 ec       	ldi	r16, 0xC3	; 195
    573c:	1a e1       	ldi	r17, 0x1A	; 26
    573e:	0f 2e       	mov	r0, r31
    5740:	f9 ef       	ldi	r31, 0xF9	; 249
    5742:	cf 2e       	mov	r12, r31
    5744:	fa e1       	ldi	r31, 0x1A	; 26
    5746:	df 2e       	mov	r13, r31
    5748:	f0 2d       	mov	r31, r0
    574a:	c8 01       	movw	r24, r16
    574c:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    5750:	07 5f       	subi	r16, 0xF7	; 247
    5752:	1f 4f       	sbci	r17, 0xFF	; 255
    5754:	c0 16       	cp	r12, r16
    5756:	d1 06       	cpc	r13, r17
    5758:	c1 f7       	brne	.-16     	; 0x574a <vTaskStartScheduler+0xf6>
    575a:	8a eb       	ldi	r24, 0xBA	; 186
    575c:	9a e1       	ldi	r25, 0x1A	; 26
    575e:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    5762:	81 eb       	ldi	r24, 0xB1	; 177
    5764:	9a e1       	ldi	r25, 0x1A	; 26
    5766:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    576a:	84 ea       	ldi	r24, 0xA4	; 164
    576c:	9a e1       	ldi	r25, 0x1A	; 26
    576e:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    5772:	8b e9       	ldi	r24, 0x9B	; 155
    5774:	9a e1       	ldi	r25, 0x1A	; 26
    5776:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInitialise>
    577a:	8a eb       	ldi	r24, 0xBA	; 186
    577c:	9a e1       	ldi	r25, 0x1A	; 26
    577e:	90 93 b0 1a 	sts	0x1AB0, r25	; 0x801ab0 <pxDelayedTaskList+0x1>
    5782:	80 93 af 1a 	sts	0x1AAF, r24	; 0x801aaf <pxDelayedTaskList>
    5786:	81 eb       	ldi	r24, 0xB1	; 177
    5788:	9a e1       	ldi	r25, 0x1A	; 26
    578a:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    578e:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    5792:	0f c0       	rjmp	.+30     	; 0x57b2 <vTaskStartScheduler+0x15e>
    5794:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <xSchedulerRunning>
    5798:	81 11       	cpse	r24, r1
    579a:	0b c0       	rjmp	.+22     	; 0x57b2 <vTaskStartScheduler+0x15e>
    579c:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    57a0:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    57a4:	86 89       	ldd	r24, Z+22	; 0x16
    57a6:	81 11       	cpse	r24, r1
    57a8:	04 c0       	rjmp	.+8      	; 0x57b2 <vTaskStartScheduler+0x15e>
    57aa:	d0 93 fa 1a 	sts	0x1AFA, r29	; 0x801afa <pxCurrentTCB+0x1>
    57ae:	c0 93 f9 1a 	sts	0x1AF9, r28	; 0x801af9 <pxCurrentTCB>
    57b2:	80 91 92 1a 	lds	r24, 0x1A92	; 0x801a92 <uxTaskNumber>
    57b6:	8f 5f       	subi	r24, 0xFF	; 255
    57b8:	80 93 92 1a 	sts	0x1A92, r24	; 0x801a92 <uxTaskNumber>
    57bc:	8e 89       	ldd	r24, Y+22	; 0x16
    57be:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    57c2:	98 17       	cp	r25, r24
    57c4:	10 f4       	brcc	.+4      	; 0x57ca <vTaskStartScheduler+0x176>
    57c6:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    57ca:	90 e0       	ldi	r25, 0x00	; 0
    57cc:	9c 01       	movw	r18, r24
    57ce:	22 0f       	add	r18, r18
    57d0:	33 1f       	adc	r19, r19
    57d2:	22 0f       	add	r18, r18
    57d4:	33 1f       	adc	r19, r19
    57d6:	22 0f       	add	r18, r18
    57d8:	33 1f       	adc	r19, r19
    57da:	82 0f       	add	r24, r18
    57dc:	93 1f       	adc	r25, r19
    57de:	b7 01       	movw	r22, r14
    57e0:	8d 53       	subi	r24, 0x3D	; 61
    57e2:	95 4e       	sbci	r25, 0xE5	; 229
    57e4:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    57e8:	0f 90       	pop	r0
    57ea:	0f be       	out	0x3f, r0	; 63
    57ec:	80 91 96 1a 	lds	r24, 0x1A96	; 0x801a96 <xSchedulerRunning>
    57f0:	88 23       	and	r24, r24
    57f2:	21 f0       	breq	.+8      	; 0x57fc <vTaskStartScheduler+0x1a8>
    57f4:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    57f8:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    57fc:	f8 94       	cli
    57fe:	8f ef       	ldi	r24, 0xFF	; 255
    5800:	9f ef       	ldi	r25, 0xFF	; 255
    5802:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5806:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    580a:	81 e0       	ldi	r24, 0x01	; 1
    580c:	80 93 96 1a 	sts	0x1A96, r24	; 0x801a96 <xSchedulerRunning>
    5810:	10 92 99 1a 	sts	0x1A99, r1	; 0x801a99 <xTickCount+0x1>
    5814:	10 92 98 1a 	sts	0x1A98, r1	; 0x801a98 <xTickCount>
    5818:	0e 94 44 1c 	call	0x3888	; 0x3888 <xPortStartScheduler>
    581c:	df 91       	pop	r29
    581e:	cf 91       	pop	r28
    5820:	1f 91       	pop	r17
    5822:	0f 91       	pop	r16
    5824:	ff 90       	pop	r15
    5826:	ef 90       	pop	r14
    5828:	df 90       	pop	r13
    582a:	cf 90       	pop	r12
    582c:	08 95       	ret

0000582e <vTaskSuspendAll>:
    582e:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5832:	8f 5f       	subi	r24, 0xFF	; 255
    5834:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <uxSchedulerSuspended>
    5838:	08 95       	ret

0000583a <xTaskResumeAll>:
    583a:	9f 92       	push	r9
    583c:	af 92       	push	r10
    583e:	bf 92       	push	r11
    5840:	cf 92       	push	r12
    5842:	df 92       	push	r13
    5844:	ef 92       	push	r14
    5846:	ff 92       	push	r15
    5848:	0f 93       	push	r16
    584a:	1f 93       	push	r17
    584c:	cf 93       	push	r28
    584e:	df 93       	push	r29
    5850:	0f b6       	in	r0, 0x3f	; 63
    5852:	f8 94       	cli
    5854:	0f 92       	push	r0
    5856:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    585a:	81 50       	subi	r24, 0x01	; 1
    585c:	80 93 8f 1a 	sts	0x1A8F, r24	; 0x801a8f <uxSchedulerSuspended>
    5860:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5864:	81 11       	cpse	r24, r1
    5866:	0d c1       	rjmp	.+538    	; 0x5a82 <xTaskResumeAll+0x248>
    5868:	80 91 9a 1a 	lds	r24, 0x1A9A	; 0x801a9a <uxCurrentNumberOfTasks>
    586c:	81 11       	cpse	r24, r1
    586e:	33 c0       	rjmp	.+102    	; 0x58d6 <xTaskResumeAll+0x9c>
    5870:	0b c1       	rjmp	.+534    	; 0x5a88 <xTaskResumeAll+0x24e>
    5872:	d7 01       	movw	r26, r14
    5874:	15 96       	adiw	r26, 0x05	; 5
    5876:	ed 91       	ld	r30, X+
    5878:	fc 91       	ld	r31, X
    587a:	16 97       	sbiw	r26, 0x06	; 6
    587c:	c6 81       	ldd	r28, Z+6	; 0x06
    587e:	d7 81       	ldd	r29, Z+7	; 0x07
    5880:	ce 01       	movw	r24, r28
    5882:	0c 96       	adiw	r24, 0x0c	; 12
    5884:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5888:	8e 01       	movw	r16, r28
    588a:	0e 5f       	subi	r16, 0xFE	; 254
    588c:	1f 4f       	sbci	r17, 0xFF	; 255
    588e:	c8 01       	movw	r24, r16
    5890:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5894:	8e 89       	ldd	r24, Y+22	; 0x16
    5896:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    589a:	98 17       	cp	r25, r24
    589c:	10 f4       	brcc	.+4      	; 0x58a2 <xTaskResumeAll+0x68>
    589e:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    58a2:	90 e0       	ldi	r25, 0x00	; 0
    58a4:	9c 01       	movw	r18, r24
    58a6:	22 0f       	add	r18, r18
    58a8:	33 1f       	adc	r19, r19
    58aa:	22 0f       	add	r18, r18
    58ac:	33 1f       	adc	r19, r19
    58ae:	22 0f       	add	r18, r18
    58b0:	33 1f       	adc	r19, r19
    58b2:	82 0f       	add	r24, r18
    58b4:	93 1f       	adc	r25, r19
    58b6:	b8 01       	movw	r22, r16
    58b8:	8d 53       	subi	r24, 0x3D	; 61
    58ba:	95 4e       	sbci	r25, 0xE5	; 229
    58bc:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    58c0:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    58c4:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    58c8:	9e 89       	ldd	r25, Y+22	; 0x16
    58ca:	86 89       	ldd	r24, Z+22	; 0x16
    58cc:	98 17       	cp	r25, r24
    58ce:	58 f0       	brcs	.+22     	; 0x58e6 <xTaskResumeAll+0xac>
    58d0:	d0 92 94 1a 	sts	0x1A94, r13	; 0x801a94 <xYieldPending>
    58d4:	08 c0       	rjmp	.+16     	; 0x58e6 <xTaskResumeAll+0xac>
    58d6:	0f 2e       	mov	r0, r31
    58d8:	f4 ea       	ldi	r31, 0xA4	; 164
    58da:	ef 2e       	mov	r14, r31
    58dc:	fa e1       	ldi	r31, 0x1A	; 26
    58de:	ff 2e       	mov	r15, r31
    58e0:	f0 2d       	mov	r31, r0
    58e2:	dd 24       	eor	r13, r13
    58e4:	d3 94       	inc	r13
    58e6:	f7 01       	movw	r30, r14
    58e8:	80 81       	ld	r24, Z
    58ea:	81 11       	cpse	r24, r1
    58ec:	c2 cf       	rjmp	.-124    	; 0x5872 <xTaskResumeAll+0x38>
    58ee:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    58f2:	88 23       	and	r24, r24
    58f4:	09 f4       	brne	.+2      	; 0x58f8 <xTaskResumeAll+0xbe>
    58f6:	bd c0       	rjmp	.+378    	; 0x5a72 <xTaskResumeAll+0x238>
    58f8:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    58fc:	88 23       	and	r24, r24
    58fe:	09 f4       	brne	.+2      	; 0x5902 <xTaskResumeAll+0xc8>
    5900:	b8 c0       	rjmp	.+368    	; 0x5a72 <xTaskResumeAll+0x238>
    5902:	91 2c       	mov	r9, r1
    5904:	bb 24       	eor	r11, r11
    5906:	b3 94       	inc	r11
    5908:	cc 24       	eor	r12, r12
    590a:	ca 94       	dec	r12
    590c:	dc 2c       	mov	r13, r12
    590e:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5912:	81 11       	cpse	r24, r1
    5914:	98 c0       	rjmp	.+304    	; 0x5a46 <xTaskResumeAll+0x20c>
    5916:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    591a:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    591e:	01 96       	adiw	r24, 0x01	; 1
    5920:	90 93 99 1a 	sts	0x1A99, r25	; 0x801a99 <xTickCount+0x1>
    5924:	80 93 98 1a 	sts	0x1A98, r24	; 0x801a98 <xTickCount>
    5928:	e0 90 98 1a 	lds	r14, 0x1A98	; 0x801a98 <xTickCount>
    592c:	f0 90 99 1a 	lds	r15, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5930:	e1 14       	cp	r14, r1
    5932:	f1 04       	cpc	r15, r1
    5934:	89 f5       	brne	.+98     	; 0x5998 <xTaskResumeAll+0x15e>
    5936:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    593a:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    593e:	20 91 ad 1a 	lds	r18, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    5942:	30 91 ae 1a 	lds	r19, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5946:	30 93 b0 1a 	sts	0x1AB0, r19	; 0x801ab0 <pxDelayedTaskList+0x1>
    594a:	20 93 af 1a 	sts	0x1AAF, r18	; 0x801aaf <pxDelayedTaskList>
    594e:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5952:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    5956:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    595a:	8f 5f       	subi	r24, 0xFF	; 255
    595c:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <xNumOfOverflows>
    5960:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5964:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5968:	80 81       	ld	r24, Z
    596a:	81 11       	cpse	r24, r1
    596c:	05 c0       	rjmp	.+10     	; 0x5978 <xTaskResumeAll+0x13e>
    596e:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5972:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    5976:	10 c0       	rjmp	.+32     	; 0x5998 <xTaskResumeAll+0x15e>
    5978:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    597c:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5980:	05 80       	ldd	r0, Z+5	; 0x05
    5982:	f6 81       	ldd	r31, Z+6	; 0x06
    5984:	e0 2d       	mov	r30, r0
    5986:	06 80       	ldd	r0, Z+6	; 0x06
    5988:	f7 81       	ldd	r31, Z+7	; 0x07
    598a:	e0 2d       	mov	r30, r0
    598c:	82 81       	ldd	r24, Z+2	; 0x02
    598e:	93 81       	ldd	r25, Z+3	; 0x03
    5990:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5994:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5998:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    599c:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    59a0:	e8 16       	cp	r14, r24
    59a2:	f9 06       	cpc	r15, r25
    59a4:	08 f4       	brcc	.+2      	; 0x59a8 <xTaskResumeAll+0x16e>
    59a6:	73 c0       	rjmp	.+230    	; 0x5a8e <xTaskResumeAll+0x254>
    59a8:	a9 2c       	mov	r10, r9
    59aa:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    59ae:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    59b2:	80 81       	ld	r24, Z
    59b4:	81 11       	cpse	r24, r1
    59b6:	05 c0       	rjmp	.+10     	; 0x59c2 <xTaskResumeAll+0x188>
    59b8:	d0 92 91 1a 	sts	0x1A91, r13	; 0x801a91 <xNextTaskUnblockTime+0x1>
    59bc:	c0 92 90 1a 	sts	0x1A90, r12	; 0x801a90 <xNextTaskUnblockTime>
    59c0:	48 c0       	rjmp	.+144    	; 0x5a52 <xTaskResumeAll+0x218>
    59c2:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    59c6:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    59ca:	05 80       	ldd	r0, Z+5	; 0x05
    59cc:	f6 81       	ldd	r31, Z+6	; 0x06
    59ce:	e0 2d       	mov	r30, r0
    59d0:	c6 81       	ldd	r28, Z+6	; 0x06
    59d2:	d7 81       	ldd	r29, Z+7	; 0x07
    59d4:	8a 81       	ldd	r24, Y+2	; 0x02
    59d6:	9b 81       	ldd	r25, Y+3	; 0x03
    59d8:	e8 16       	cp	r14, r24
    59da:	f9 06       	cpc	r15, r25
    59dc:	28 f4       	brcc	.+10     	; 0x59e8 <xTaskResumeAll+0x1ae>
    59de:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    59e2:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    59e6:	35 c0       	rjmp	.+106    	; 0x5a52 <xTaskResumeAll+0x218>
    59e8:	8e 01       	movw	r16, r28
    59ea:	0e 5f       	subi	r16, 0xFE	; 254
    59ec:	1f 4f       	sbci	r17, 0xFF	; 255
    59ee:	c8 01       	movw	r24, r16
    59f0:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    59f4:	8c 89       	ldd	r24, Y+20	; 0x14
    59f6:	9d 89       	ldd	r25, Y+21	; 0x15
    59f8:	89 2b       	or	r24, r25
    59fa:	21 f0       	breq	.+8      	; 0x5a04 <xTaskResumeAll+0x1ca>
    59fc:	ce 01       	movw	r24, r28
    59fe:	0c 96       	adiw	r24, 0x0c	; 12
    5a00:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5a04:	8e 89       	ldd	r24, Y+22	; 0x16
    5a06:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5a0a:	98 17       	cp	r25, r24
    5a0c:	10 f4       	brcc	.+4      	; 0x5a12 <xTaskResumeAll+0x1d8>
    5a0e:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5a12:	90 e0       	ldi	r25, 0x00	; 0
    5a14:	9c 01       	movw	r18, r24
    5a16:	22 0f       	add	r18, r18
    5a18:	33 1f       	adc	r19, r19
    5a1a:	22 0f       	add	r18, r18
    5a1c:	33 1f       	adc	r19, r19
    5a1e:	22 0f       	add	r18, r18
    5a20:	33 1f       	adc	r19, r19
    5a22:	82 0f       	add	r24, r18
    5a24:	93 1f       	adc	r25, r19
    5a26:	b8 01       	movw	r22, r16
    5a28:	8d 53       	subi	r24, 0x3D	; 61
    5a2a:	95 4e       	sbci	r25, 0xE5	; 229
    5a2c:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5a30:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5a34:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5a38:	9e 89       	ldd	r25, Y+22	; 0x16
    5a3a:	86 89       	ldd	r24, Z+22	; 0x16
    5a3c:	98 17       	cp	r25, r24
    5a3e:	08 f4       	brcc	.+2      	; 0x5a42 <xTaskResumeAll+0x208>
    5a40:	b4 cf       	rjmp	.-152    	; 0x59aa <xTaskResumeAll+0x170>
    5a42:	ab 2c       	mov	r10, r11
    5a44:	b2 cf       	rjmp	.-156    	; 0x59aa <xTaskResumeAll+0x170>
    5a46:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5a4a:	8f 5f       	subi	r24, 0xFF	; 255
    5a4c:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    5a50:	1e c0       	rjmp	.+60     	; 0x5a8e <xTaskResumeAll+0x254>
    5a52:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5a56:	81 11       	cpse	r24, r1
    5a58:	01 c0       	rjmp	.+2      	; 0x5a5c <xTaskResumeAll+0x222>
    5a5a:	a1 10       	cpse	r10, r1
    5a5c:	b0 92 94 1a 	sts	0x1A94, r11	; 0x801a94 <xYieldPending>
    5a60:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5a64:	81 50       	subi	r24, 0x01	; 1
    5a66:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    5a6a:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5a6e:	81 11       	cpse	r24, r1
    5a70:	4e cf       	rjmp	.-356    	; 0x590e <xTaskResumeAll+0xd4>
    5a72:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5a76:	81 30       	cpi	r24, 0x01	; 1
    5a78:	31 f4       	brne	.+12     	; 0x5a86 <xTaskResumeAll+0x24c>
    5a7a:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    5a7e:	81 e0       	ldi	r24, 0x01	; 1
    5a80:	03 c0       	rjmp	.+6      	; 0x5a88 <xTaskResumeAll+0x24e>
    5a82:	80 e0       	ldi	r24, 0x00	; 0
    5a84:	01 c0       	rjmp	.+2      	; 0x5a88 <xTaskResumeAll+0x24e>
    5a86:	80 e0       	ldi	r24, 0x00	; 0
    5a88:	0f 90       	pop	r0
    5a8a:	0f be       	out	0x3f, r0	; 63
    5a8c:	05 c0       	rjmp	.+10     	; 0x5a98 <xTaskResumeAll+0x25e>
    5a8e:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5a92:	81 11       	cpse	r24, r1
    5a94:	e3 cf       	rjmp	.-58     	; 0x5a5c <xTaskResumeAll+0x222>
    5a96:	e4 cf       	rjmp	.-56     	; 0x5a60 <xTaskResumeAll+0x226>
    5a98:	df 91       	pop	r29
    5a9a:	cf 91       	pop	r28
    5a9c:	1f 91       	pop	r17
    5a9e:	0f 91       	pop	r16
    5aa0:	ff 90       	pop	r15
    5aa2:	ef 90       	pop	r14
    5aa4:	df 90       	pop	r13
    5aa6:	cf 90       	pop	r12
    5aa8:	bf 90       	pop	r11
    5aaa:	af 90       	pop	r10
    5aac:	9f 90       	pop	r9
    5aae:	08 95       	ret

00005ab0 <xTaskGetTickCount>:
    5ab0:	0f b6       	in	r0, 0x3f	; 63
    5ab2:	f8 94       	cli
    5ab4:	0f 92       	push	r0
    5ab6:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5aba:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5abe:	0f 90       	pop	r0
    5ac0:	0f be       	out	0x3f, r0	; 63
    5ac2:	08 95       	ret

00005ac4 <xTaskIncrementTick>:
    5ac4:	cf 92       	push	r12
    5ac6:	df 92       	push	r13
    5ac8:	ef 92       	push	r14
    5aca:	ff 92       	push	r15
    5acc:	0f 93       	push	r16
    5ace:	1f 93       	push	r17
    5ad0:	cf 93       	push	r28
    5ad2:	df 93       	push	r29
    5ad4:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5ad8:	81 11       	cpse	r24, r1
    5ada:	9f c0       	rjmp	.+318    	; 0x5c1a <xTaskIncrementTick+0x156>
    5adc:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5ae0:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5ae4:	01 96       	adiw	r24, 0x01	; 1
    5ae6:	90 93 99 1a 	sts	0x1A99, r25	; 0x801a99 <xTickCount+0x1>
    5aea:	80 93 98 1a 	sts	0x1A98, r24	; 0x801a98 <xTickCount>
    5aee:	e0 90 98 1a 	lds	r14, 0x1A98	; 0x801a98 <xTickCount>
    5af2:	f0 90 99 1a 	lds	r15, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5af6:	e1 14       	cp	r14, r1
    5af8:	f1 04       	cpc	r15, r1
    5afa:	99 f5       	brne	.+102    	; 0x5b62 <xTaskIncrementTick+0x9e>
    5afc:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5b00:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b04:	20 91 ad 1a 	lds	r18, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    5b08:	30 91 ae 1a 	lds	r19, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5b0c:	30 93 b0 1a 	sts	0x1AB0, r19	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b10:	20 93 af 1a 	sts	0x1AAF, r18	; 0x801aaf <pxDelayedTaskList>
    5b14:	90 93 ae 1a 	sts	0x1AAE, r25	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5b18:	80 93 ad 1a 	sts	0x1AAD, r24	; 0x801aad <pxOverflowDelayedTaskList>
    5b1c:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    5b20:	8f 5f       	subi	r24, 0xFF	; 255
    5b22:	80 93 93 1a 	sts	0x1A93, r24	; 0x801a93 <xNumOfOverflows>
    5b26:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5b2a:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b2e:	80 81       	ld	r24, Z
    5b30:	81 11       	cpse	r24, r1
    5b32:	07 c0       	rjmp	.+14     	; 0x5b42 <xTaskIncrementTick+0x7e>
    5b34:	8f ef       	ldi	r24, 0xFF	; 255
    5b36:	9f ef       	ldi	r25, 0xFF	; 255
    5b38:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5b3c:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5b40:	10 c0       	rjmp	.+32     	; 0x5b62 <xTaskIncrementTick+0x9e>
    5b42:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5b46:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b4a:	05 80       	ldd	r0, Z+5	; 0x05
    5b4c:	f6 81       	ldd	r31, Z+6	; 0x06
    5b4e:	e0 2d       	mov	r30, r0
    5b50:	06 80       	ldd	r0, Z+6	; 0x06
    5b52:	f7 81       	ldd	r31, Z+7	; 0x07
    5b54:	e0 2d       	mov	r30, r0
    5b56:	82 81       	ldd	r24, Z+2	; 0x02
    5b58:	93 81       	ldd	r25, Z+3	; 0x03
    5b5a:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5b5e:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5b62:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    5b66:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5b6a:	e8 16       	cp	r14, r24
    5b6c:	f9 06       	cpc	r15, r25
    5b6e:	10 f4       	brcc	.+4      	; 0x5b74 <xTaskIncrementTick+0xb0>
    5b70:	d1 2c       	mov	r13, r1
    5b72:	59 c0       	rjmp	.+178    	; 0x5c26 <xTaskIncrementTick+0x162>
    5b74:	d1 2c       	mov	r13, r1
    5b76:	cc 24       	eor	r12, r12
    5b78:	c3 94       	inc	r12
    5b7a:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5b7e:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b82:	80 81       	ld	r24, Z
    5b84:	81 11       	cpse	r24, r1
    5b86:	07 c0       	rjmp	.+14     	; 0x5b96 <xTaskIncrementTick+0xd2>
    5b88:	8f ef       	ldi	r24, 0xFF	; 255
    5b8a:	9f ef       	ldi	r25, 0xFF	; 255
    5b8c:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5b90:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5b94:	48 c0       	rjmp	.+144    	; 0x5c26 <xTaskIncrementTick+0x162>
    5b96:	e0 91 af 1a 	lds	r30, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5b9a:	f0 91 b0 1a 	lds	r31, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5b9e:	05 80       	ldd	r0, Z+5	; 0x05
    5ba0:	f6 81       	ldd	r31, Z+6	; 0x06
    5ba2:	e0 2d       	mov	r30, r0
    5ba4:	c6 81       	ldd	r28, Z+6	; 0x06
    5ba6:	d7 81       	ldd	r29, Z+7	; 0x07
    5ba8:	8a 81       	ldd	r24, Y+2	; 0x02
    5baa:	9b 81       	ldd	r25, Y+3	; 0x03
    5bac:	e8 16       	cp	r14, r24
    5bae:	f9 06       	cpc	r15, r25
    5bb0:	28 f4       	brcc	.+10     	; 0x5bbc <xTaskIncrementTick+0xf8>
    5bb2:	90 93 91 1a 	sts	0x1A91, r25	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5bb6:	80 93 90 1a 	sts	0x1A90, r24	; 0x801a90 <xNextTaskUnblockTime>
    5bba:	35 c0       	rjmp	.+106    	; 0x5c26 <xTaskIncrementTick+0x162>
    5bbc:	8e 01       	movw	r16, r28
    5bbe:	0e 5f       	subi	r16, 0xFE	; 254
    5bc0:	1f 4f       	sbci	r17, 0xFF	; 255
    5bc2:	c8 01       	movw	r24, r16
    5bc4:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5bc8:	8c 89       	ldd	r24, Y+20	; 0x14
    5bca:	9d 89       	ldd	r25, Y+21	; 0x15
    5bcc:	89 2b       	or	r24, r25
    5bce:	21 f0       	breq	.+8      	; 0x5bd8 <xTaskIncrementTick+0x114>
    5bd0:	ce 01       	movw	r24, r28
    5bd2:	0c 96       	adiw	r24, 0x0c	; 12
    5bd4:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5bd8:	8e 89       	ldd	r24, Y+22	; 0x16
    5bda:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5bde:	98 17       	cp	r25, r24
    5be0:	10 f4       	brcc	.+4      	; 0x5be6 <xTaskIncrementTick+0x122>
    5be2:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5be6:	90 e0       	ldi	r25, 0x00	; 0
    5be8:	9c 01       	movw	r18, r24
    5bea:	22 0f       	add	r18, r18
    5bec:	33 1f       	adc	r19, r19
    5bee:	22 0f       	add	r18, r18
    5bf0:	33 1f       	adc	r19, r19
    5bf2:	22 0f       	add	r18, r18
    5bf4:	33 1f       	adc	r19, r19
    5bf6:	82 0f       	add	r24, r18
    5bf8:	93 1f       	adc	r25, r19
    5bfa:	b8 01       	movw	r22, r16
    5bfc:	8d 53       	subi	r24, 0x3D	; 61
    5bfe:	95 4e       	sbci	r25, 0xE5	; 229
    5c00:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5c04:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c08:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c0c:	9e 89       	ldd	r25, Y+22	; 0x16
    5c0e:	86 89       	ldd	r24, Z+22	; 0x16
    5c10:	98 17       	cp	r25, r24
    5c12:	08 f4       	brcc	.+2      	; 0x5c16 <xTaskIncrementTick+0x152>
    5c14:	b2 cf       	rjmp	.-156    	; 0x5b7a <xTaskIncrementTick+0xb6>
    5c16:	dc 2c       	mov	r13, r12
    5c18:	b0 cf       	rjmp	.-160    	; 0x5b7a <xTaskIncrementTick+0xb6>
    5c1a:	80 91 95 1a 	lds	r24, 0x1A95	; 0x801a95 <uxPendedTicks>
    5c1e:	8f 5f       	subi	r24, 0xFF	; 255
    5c20:	80 93 95 1a 	sts	0x1A95, r24	; 0x801a95 <uxPendedTicks>
    5c24:	d1 2c       	mov	r13, r1
    5c26:	80 91 94 1a 	lds	r24, 0x1A94	; 0x801a94 <xYieldPending>
    5c2a:	88 23       	and	r24, r24
    5c2c:	11 f0       	breq	.+4      	; 0x5c32 <xTaskIncrementTick+0x16e>
    5c2e:	dd 24       	eor	r13, r13
    5c30:	d3 94       	inc	r13
    5c32:	8d 2d       	mov	r24, r13
    5c34:	df 91       	pop	r29
    5c36:	cf 91       	pop	r28
    5c38:	1f 91       	pop	r17
    5c3a:	0f 91       	pop	r16
    5c3c:	ff 90       	pop	r15
    5c3e:	ef 90       	pop	r14
    5c40:	df 90       	pop	r13
    5c42:	cf 90       	pop	r12
    5c44:	08 95       	ret

00005c46 <vTaskSwitchContext>:
    5c46:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5c4a:	88 23       	and	r24, r24
    5c4c:	21 f0       	breq	.+8      	; 0x5c56 <vTaskSwitchContext+0x10>
    5c4e:	81 e0       	ldi	r24, 0x01	; 1
    5c50:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xYieldPending>
    5c54:	08 95       	ret
    5c56:	10 92 94 1a 	sts	0x1A94, r1	; 0x801a94 <xYieldPending>
    5c5a:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c5e:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c62:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c66:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c6a:	2d 91       	ld	r18, X+
    5c6c:	3c 91       	ld	r19, X
    5c6e:	87 89       	ldd	r24, Z+23	; 0x17
    5c70:	90 8d       	ldd	r25, Z+24	; 0x18
    5c72:	82 17       	cp	r24, r18
    5c74:	93 07       	cpc	r25, r19
    5c76:	60 f0       	brcs	.+24     	; 0x5c90 <vTaskSwitchContext+0x4a>
    5c78:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c7c:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c80:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5c84:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5c88:	67 5e       	subi	r22, 0xE7	; 231
    5c8a:	7f 4f       	sbci	r23, 0xFF	; 255
    5c8c:	0e 94 0b 19 	call	0x3216	; 0x3216 <vApplicationStackOverflowHook>
    5c90:	80 91 97 1a 	lds	r24, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5c94:	90 e0       	ldi	r25, 0x00	; 0
    5c96:	fc 01       	movw	r30, r24
    5c98:	ee 0f       	add	r30, r30
    5c9a:	ff 1f       	adc	r31, r31
    5c9c:	ee 0f       	add	r30, r30
    5c9e:	ff 1f       	adc	r31, r31
    5ca0:	ee 0f       	add	r30, r30
    5ca2:	ff 1f       	adc	r31, r31
    5ca4:	8e 0f       	add	r24, r30
    5ca6:	9f 1f       	adc	r25, r31
    5ca8:	fc 01       	movw	r30, r24
    5caa:	ed 53       	subi	r30, 0x3D	; 61
    5cac:	f5 4e       	sbci	r31, 0xE5	; 229
    5cae:	80 81       	ld	r24, Z
    5cb0:	81 11       	cpse	r24, r1
    5cb2:	17 c0       	rjmp	.+46     	; 0x5ce2 <vTaskSwitchContext+0x9c>
    5cb4:	80 91 97 1a 	lds	r24, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5cb8:	81 50       	subi	r24, 0x01	; 1
    5cba:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5cbe:	80 91 97 1a 	lds	r24, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5cc2:	90 e0       	ldi	r25, 0x00	; 0
    5cc4:	fc 01       	movw	r30, r24
    5cc6:	ee 0f       	add	r30, r30
    5cc8:	ff 1f       	adc	r31, r31
    5cca:	ee 0f       	add	r30, r30
    5ccc:	ff 1f       	adc	r31, r31
    5cce:	ee 0f       	add	r30, r30
    5cd0:	ff 1f       	adc	r31, r31
    5cd2:	8e 0f       	add	r24, r30
    5cd4:	9f 1f       	adc	r25, r31
    5cd6:	fc 01       	movw	r30, r24
    5cd8:	ed 53       	subi	r30, 0x3D	; 61
    5cda:	f5 4e       	sbci	r31, 0xE5	; 229
    5cdc:	80 81       	ld	r24, Z
    5cde:	88 23       	and	r24, r24
    5ce0:	49 f3       	breq	.-46     	; 0x5cb4 <vTaskSwitchContext+0x6e>
    5ce2:	80 91 97 1a 	lds	r24, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5ce6:	90 e0       	ldi	r25, 0x00	; 0
    5ce8:	9c 01       	movw	r18, r24
    5cea:	22 0f       	add	r18, r18
    5cec:	33 1f       	adc	r19, r19
    5cee:	22 0f       	add	r18, r18
    5cf0:	33 1f       	adc	r19, r19
    5cf2:	22 0f       	add	r18, r18
    5cf4:	33 1f       	adc	r19, r19
    5cf6:	28 0f       	add	r18, r24
    5cf8:	39 1f       	adc	r19, r25
    5cfa:	d9 01       	movw	r26, r18
    5cfc:	ad 53       	subi	r26, 0x3D	; 61
    5cfe:	b5 4e       	sbci	r27, 0xE5	; 229
    5d00:	11 96       	adiw	r26, 0x01	; 1
    5d02:	ed 91       	ld	r30, X+
    5d04:	fc 91       	ld	r31, X
    5d06:	12 97       	sbiw	r26, 0x02	; 2
    5d08:	02 80       	ldd	r0, Z+2	; 0x02
    5d0a:	f3 81       	ldd	r31, Z+3	; 0x03
    5d0c:	e0 2d       	mov	r30, r0
    5d0e:	12 96       	adiw	r26, 0x02	; 2
    5d10:	fc 93       	st	X, r31
    5d12:	ee 93       	st	-X, r30
    5d14:	11 97       	sbiw	r26, 0x01	; 1
    5d16:	2a 53       	subi	r18, 0x3A	; 58
    5d18:	35 4e       	sbci	r19, 0xE5	; 229
    5d1a:	e2 17       	cp	r30, r18
    5d1c:	f3 07       	cpc	r31, r19
    5d1e:	29 f4       	brne	.+10     	; 0x5d2a <vTaskSwitchContext+0xe4>
    5d20:	22 81       	ldd	r18, Z+2	; 0x02
    5d22:	33 81       	ldd	r19, Z+3	; 0x03
    5d24:	fd 01       	movw	r30, r26
    5d26:	32 83       	std	Z+2, r19	; 0x02
    5d28:	21 83       	std	Z+1, r18	; 0x01
    5d2a:	fc 01       	movw	r30, r24
    5d2c:	ee 0f       	add	r30, r30
    5d2e:	ff 1f       	adc	r31, r31
    5d30:	ee 0f       	add	r30, r30
    5d32:	ff 1f       	adc	r31, r31
    5d34:	ee 0f       	add	r30, r30
    5d36:	ff 1f       	adc	r31, r31
    5d38:	8e 0f       	add	r24, r30
    5d3a:	9f 1f       	adc	r25, r31
    5d3c:	fc 01       	movw	r30, r24
    5d3e:	ed 53       	subi	r30, 0x3D	; 61
    5d40:	f5 4e       	sbci	r31, 0xE5	; 229
    5d42:	01 80       	ldd	r0, Z+1	; 0x01
    5d44:	f2 81       	ldd	r31, Z+2	; 0x02
    5d46:	e0 2d       	mov	r30, r0
    5d48:	86 81       	ldd	r24, Z+6	; 0x06
    5d4a:	97 81       	ldd	r25, Z+7	; 0x07
    5d4c:	90 93 fa 1a 	sts	0x1AFA, r25	; 0x801afa <pxCurrentTCB+0x1>
    5d50:	80 93 f9 1a 	sts	0x1AF9, r24	; 0x801af9 <pxCurrentTCB>
    5d54:	08 95       	ret

00005d56 <vTaskPlaceOnEventList>:
    5d56:	cf 93       	push	r28
    5d58:	df 93       	push	r29
    5d5a:	eb 01       	movw	r28, r22
    5d5c:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d60:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5d64:	64 5f       	subi	r22, 0xF4	; 244
    5d66:	7f 4f       	sbci	r23, 0xFF	; 255
    5d68:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5d6c:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d70:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5d74:	02 96       	adiw	r24, 0x02	; 2
    5d76:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5d7a:	cf 3f       	cpi	r28, 0xFF	; 255
    5d7c:	8f ef       	ldi	r24, 0xFF	; 255
    5d7e:	d8 07       	cpc	r29, r24
    5d80:	59 f4       	brne	.+22     	; 0x5d98 <vTaskPlaceOnEventList+0x42>
    5d82:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5d86:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5d8a:	6e 5f       	subi	r22, 0xFE	; 254
    5d8c:	7f 4f       	sbci	r23, 0xFF	; 255
    5d8e:	8b e9       	ldi	r24, 0x9B	; 155
    5d90:	9a e1       	ldi	r25, 0x1A	; 26
    5d92:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5d96:	37 c0       	rjmp	.+110    	; 0x5e06 <vTaskPlaceOnEventList+0xb0>
    5d98:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5d9c:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5da0:	c8 0f       	add	r28, r24
    5da2:	d9 1f       	adc	r29, r25
    5da4:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5da8:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5dac:	d3 83       	std	Z+3, r29	; 0x03
    5dae:	c2 83       	std	Z+2, r28	; 0x02
    5db0:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5db4:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5db8:	c8 17       	cp	r28, r24
    5dba:	d9 07       	cpc	r29, r25
    5dbc:	68 f4       	brcc	.+26     	; 0x5dd8 <vTaskPlaceOnEventList+0x82>
    5dbe:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5dc2:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5dc6:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    5dca:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    5dce:	6e 5f       	subi	r22, 0xFE	; 254
    5dd0:	7f 4f       	sbci	r23, 0xFF	; 255
    5dd2:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5dd6:	17 c0       	rjmp	.+46     	; 0x5e06 <vTaskPlaceOnEventList+0xb0>
    5dd8:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5ddc:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5de0:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    5de4:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    5de8:	6e 5f       	subi	r22, 0xFE	; 254
    5dea:	7f 4f       	sbci	r23, 0xFF	; 255
    5dec:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    5df0:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    5df4:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5df8:	c8 17       	cp	r28, r24
    5dfa:	d9 07       	cpc	r29, r25
    5dfc:	20 f4       	brcc	.+8      	; 0x5e06 <vTaskPlaceOnEventList+0xb0>
    5dfe:	d0 93 91 1a 	sts	0x1A91, r29	; 0x801a91 <xNextTaskUnblockTime+0x1>
    5e02:	c0 93 90 1a 	sts	0x1A90, r28	; 0x801a90 <xNextTaskUnblockTime>
    5e06:	df 91       	pop	r29
    5e08:	cf 91       	pop	r28
    5e0a:	08 95       	ret

00005e0c <xTaskRemoveFromEventList>:
    5e0c:	0f 93       	push	r16
    5e0e:	1f 93       	push	r17
    5e10:	cf 93       	push	r28
    5e12:	df 93       	push	r29
    5e14:	dc 01       	movw	r26, r24
    5e16:	15 96       	adiw	r26, 0x05	; 5
    5e18:	ed 91       	ld	r30, X+
    5e1a:	fc 91       	ld	r31, X
    5e1c:	16 97       	sbiw	r26, 0x06	; 6
    5e1e:	c6 81       	ldd	r28, Z+6	; 0x06
    5e20:	d7 81       	ldd	r29, Z+7	; 0x07
    5e22:	8e 01       	movw	r16, r28
    5e24:	04 5f       	subi	r16, 0xF4	; 244
    5e26:	1f 4f       	sbci	r17, 0xFF	; 255
    5e28:	c8 01       	movw	r24, r16
    5e2a:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5e2e:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    5e32:	81 11       	cpse	r24, r1
    5e34:	1c c0       	rjmp	.+56     	; 0x5e6e <xTaskRemoveFromEventList+0x62>
    5e36:	0a 50       	subi	r16, 0x0A	; 10
    5e38:	11 09       	sbc	r17, r1
    5e3a:	c8 01       	movw	r24, r16
    5e3c:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5e40:	8e 89       	ldd	r24, Y+22	; 0x16
    5e42:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5e46:	98 17       	cp	r25, r24
    5e48:	10 f4       	brcc	.+4      	; 0x5e4e <xTaskRemoveFromEventList+0x42>
    5e4a:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5e4e:	90 e0       	ldi	r25, 0x00	; 0
    5e50:	9c 01       	movw	r18, r24
    5e52:	22 0f       	add	r18, r18
    5e54:	33 1f       	adc	r19, r19
    5e56:	22 0f       	add	r18, r18
    5e58:	33 1f       	adc	r19, r19
    5e5a:	22 0f       	add	r18, r18
    5e5c:	33 1f       	adc	r19, r19
    5e5e:	82 0f       	add	r24, r18
    5e60:	93 1f       	adc	r25, r19
    5e62:	b8 01       	movw	r22, r16
    5e64:	8d 53       	subi	r24, 0x3D	; 61
    5e66:	95 4e       	sbci	r25, 0xE5	; 229
    5e68:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5e6c:	05 c0       	rjmp	.+10     	; 0x5e78 <xTaskRemoveFromEventList+0x6c>
    5e6e:	b8 01       	movw	r22, r16
    5e70:	84 ea       	ldi	r24, 0xA4	; 164
    5e72:	9a e1       	ldi	r25, 0x1A	; 26
    5e74:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5e78:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5e7c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5e80:	9e 89       	ldd	r25, Y+22	; 0x16
    5e82:	86 89       	ldd	r24, Z+22	; 0x16
    5e84:	89 17       	cp	r24, r25
    5e86:	20 f4       	brcc	.+8      	; 0x5e90 <xTaskRemoveFromEventList+0x84>
    5e88:	81 e0       	ldi	r24, 0x01	; 1
    5e8a:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xYieldPending>
    5e8e:	01 c0       	rjmp	.+2      	; 0x5e92 <xTaskRemoveFromEventList+0x86>
    5e90:	80 e0       	ldi	r24, 0x00	; 0
    5e92:	df 91       	pop	r29
    5e94:	cf 91       	pop	r28
    5e96:	1f 91       	pop	r17
    5e98:	0f 91       	pop	r16
    5e9a:	08 95       	ret

00005e9c <vTaskSetTimeOutState>:
    5e9c:	20 91 93 1a 	lds	r18, 0x1A93	; 0x801a93 <xNumOfOverflows>
    5ea0:	fc 01       	movw	r30, r24
    5ea2:	20 83       	st	Z, r18
    5ea4:	20 91 98 1a 	lds	r18, 0x1A98	; 0x801a98 <xTickCount>
    5ea8:	30 91 99 1a 	lds	r19, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5eac:	32 83       	std	Z+2, r19	; 0x02
    5eae:	21 83       	std	Z+1, r18	; 0x01
    5eb0:	08 95       	ret

00005eb2 <xTaskCheckForTimeOut>:
    5eb2:	fc 01       	movw	r30, r24
    5eb4:	0f b6       	in	r0, 0x3f	; 63
    5eb6:	f8 94       	cli
    5eb8:	0f 92       	push	r0
    5eba:	20 91 98 1a 	lds	r18, 0x1A98	; 0x801a98 <xTickCount>
    5ebe:	30 91 99 1a 	lds	r19, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5ec2:	db 01       	movw	r26, r22
    5ec4:	8d 91       	ld	r24, X+
    5ec6:	9c 91       	ld	r25, X
    5ec8:	8f 3f       	cpi	r24, 0xFF	; 255
    5eca:	bf ef       	ldi	r27, 0xFF	; 255
    5ecc:	9b 07       	cpc	r25, r27
    5ece:	21 f1       	breq	.+72     	; 0x5f18 <xTaskCheckForTimeOut+0x66>
    5ed0:	40 91 93 1a 	lds	r20, 0x1A93	; 0x801a93 <xNumOfOverflows>
    5ed4:	50 81       	ld	r21, Z
    5ed6:	54 17       	cp	r21, r20
    5ed8:	29 f0       	breq	.+10     	; 0x5ee4 <xTaskCheckForTimeOut+0x32>
    5eda:	41 81       	ldd	r20, Z+1	; 0x01
    5edc:	52 81       	ldd	r21, Z+2	; 0x02
    5ede:	24 17       	cp	r18, r20
    5ee0:	35 07       	cpc	r19, r21
    5ee2:	e0 f4       	brcc	.+56     	; 0x5f1c <xTaskCheckForTimeOut+0x6a>
    5ee4:	41 81       	ldd	r20, Z+1	; 0x01
    5ee6:	52 81       	ldd	r21, Z+2	; 0x02
    5ee8:	d9 01       	movw	r26, r18
    5eea:	a4 1b       	sub	r26, r20
    5eec:	b5 0b       	sbc	r27, r21
    5eee:	a8 17       	cp	r26, r24
    5ef0:	b9 07       	cpc	r27, r25
    5ef2:	b0 f4       	brcc	.+44     	; 0x5f20 <xTaskCheckForTimeOut+0x6e>
    5ef4:	42 1b       	sub	r20, r18
    5ef6:	53 0b       	sbc	r21, r19
    5ef8:	84 0f       	add	r24, r20
    5efa:	95 1f       	adc	r25, r21
    5efc:	db 01       	movw	r26, r22
    5efe:	8d 93       	st	X+, r24
    5f00:	9c 93       	st	X, r25
    5f02:	80 91 93 1a 	lds	r24, 0x1A93	; 0x801a93 <xNumOfOverflows>
    5f06:	80 83       	st	Z, r24
    5f08:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    5f0c:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    5f10:	92 83       	std	Z+2, r25	; 0x02
    5f12:	81 83       	std	Z+1, r24	; 0x01
    5f14:	80 e0       	ldi	r24, 0x00	; 0
    5f16:	05 c0       	rjmp	.+10     	; 0x5f22 <xTaskCheckForTimeOut+0x70>
    5f18:	80 e0       	ldi	r24, 0x00	; 0
    5f1a:	03 c0       	rjmp	.+6      	; 0x5f22 <xTaskCheckForTimeOut+0x70>
    5f1c:	81 e0       	ldi	r24, 0x01	; 1
    5f1e:	01 c0       	rjmp	.+2      	; 0x5f22 <xTaskCheckForTimeOut+0x70>
    5f20:	81 e0       	ldi	r24, 0x01	; 1
    5f22:	0f 90       	pop	r0
    5f24:	0f be       	out	0x3f, r0	; 63
    5f26:	08 95       	ret

00005f28 <vTaskMissedYield>:
    5f28:	81 e0       	ldi	r24, 0x01	; 1
    5f2a:	80 93 94 1a 	sts	0x1A94, r24	; 0x801a94 <xYieldPending>
    5f2e:	08 95       	ret

00005f30 <xTaskGetCurrentTaskHandle>:
    5f30:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5f34:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5f38:	08 95       	ret

00005f3a <vTaskPriorityInherit>:
    5f3a:	0f 93       	push	r16
    5f3c:	1f 93       	push	r17
    5f3e:	cf 93       	push	r28
    5f40:	df 93       	push	r29
    5f42:	fc 01       	movw	r30, r24
    5f44:	89 2b       	or	r24, r25
    5f46:	09 f4       	brne	.+2      	; 0x5f4a <vTaskPriorityInherit+0x10>
    5f48:	55 c0       	rjmp	.+170    	; 0x5ff4 <vTaskPriorityInherit+0xba>
    5f4a:	26 89       	ldd	r18, Z+22	; 0x16
    5f4c:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5f50:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5f54:	56 96       	adiw	r26, 0x16	; 22
    5f56:	8c 91       	ld	r24, X
    5f58:	28 17       	cp	r18, r24
    5f5a:	08 f0       	brcs	.+2      	; 0x5f5e <vTaskPriorityInherit+0x24>
    5f5c:	4b c0       	rjmp	.+150    	; 0x5ff4 <vTaskPriorityInherit+0xba>
    5f5e:	84 85       	ldd	r24, Z+12	; 0x0c
    5f60:	95 85       	ldd	r25, Z+13	; 0x0d
    5f62:	99 23       	and	r25, r25
    5f64:	64 f0       	brlt	.+24     	; 0x5f7e <vTaskPriorityInherit+0x44>
    5f66:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5f6a:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5f6e:	56 96       	adiw	r26, 0x16	; 22
    5f70:	3c 91       	ld	r19, X
    5f72:	86 e0       	ldi	r24, 0x06	; 6
    5f74:	90 e0       	ldi	r25, 0x00	; 0
    5f76:	83 1b       	sub	r24, r19
    5f78:	91 09       	sbc	r25, r1
    5f7a:	95 87       	std	Z+13, r25	; 0x0d
    5f7c:	84 87       	std	Z+12, r24	; 0x0c
    5f7e:	30 e0       	ldi	r19, 0x00	; 0
    5f80:	c9 01       	movw	r24, r18
    5f82:	88 0f       	add	r24, r24
    5f84:	99 1f       	adc	r25, r25
    5f86:	88 0f       	add	r24, r24
    5f88:	99 1f       	adc	r25, r25
    5f8a:	88 0f       	add	r24, r24
    5f8c:	99 1f       	adc	r25, r25
    5f8e:	28 0f       	add	r18, r24
    5f90:	39 1f       	adc	r19, r25
    5f92:	2d 53       	subi	r18, 0x3D	; 61
    5f94:	35 4e       	sbci	r19, 0xE5	; 229
    5f96:	82 85       	ldd	r24, Z+10	; 0x0a
    5f98:	93 85       	ldd	r25, Z+11	; 0x0b
    5f9a:	82 17       	cp	r24, r18
    5f9c:	93 07       	cpc	r25, r19
    5f9e:	19 f5       	brne	.+70     	; 0x5fe6 <vTaskPriorityInherit+0xac>
    5fa0:	8f 01       	movw	r16, r30
    5fa2:	ef 01       	movw	r28, r30
    5fa4:	22 96       	adiw	r28, 0x02	; 2
    5fa6:	ce 01       	movw	r24, r28
    5fa8:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    5fac:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5fb0:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5fb4:	86 89       	ldd	r24, Z+22	; 0x16
    5fb6:	f8 01       	movw	r30, r16
    5fb8:	86 8b       	std	Z+22, r24	; 0x16
    5fba:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    5fbe:	98 17       	cp	r25, r24
    5fc0:	10 f4       	brcc	.+4      	; 0x5fc6 <vTaskPriorityInherit+0x8c>
    5fc2:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    5fc6:	90 e0       	ldi	r25, 0x00	; 0
    5fc8:	9c 01       	movw	r18, r24
    5fca:	22 0f       	add	r18, r18
    5fcc:	33 1f       	adc	r19, r19
    5fce:	22 0f       	add	r18, r18
    5fd0:	33 1f       	adc	r19, r19
    5fd2:	22 0f       	add	r18, r18
    5fd4:	33 1f       	adc	r19, r19
    5fd6:	82 0f       	add	r24, r18
    5fd8:	93 1f       	adc	r25, r19
    5fda:	be 01       	movw	r22, r28
    5fdc:	8d 53       	subi	r24, 0x3D	; 61
    5fde:	95 4e       	sbci	r25, 0xE5	; 229
    5fe0:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    5fe4:	07 c0       	rjmp	.+14     	; 0x5ff4 <vTaskPriorityInherit+0xba>
    5fe6:	a0 91 f9 1a 	lds	r26, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    5fea:	b0 91 fa 1a 	lds	r27, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    5fee:	56 96       	adiw	r26, 0x16	; 22
    5ff0:	8c 91       	ld	r24, X
    5ff2:	86 8b       	std	Z+22, r24	; 0x16
    5ff4:	df 91       	pop	r29
    5ff6:	cf 91       	pop	r28
    5ff8:	1f 91       	pop	r17
    5ffa:	0f 91       	pop	r16
    5ffc:	08 95       	ret

00005ffe <xTaskPriorityDisinherit>:
    5ffe:	0f 93       	push	r16
    6000:	1f 93       	push	r17
    6002:	cf 93       	push	r28
    6004:	df 93       	push	r29
    6006:	fc 01       	movw	r30, r24
    6008:	89 2b       	or	r24, r25
    600a:	79 f1       	breq	.+94     	; 0x606a <xTaskPriorityDisinherit+0x6c>
    600c:	82 a1       	ldd	r24, Z+34	; 0x22
    600e:	81 50       	subi	r24, 0x01	; 1
    6010:	82 a3       	std	Z+34, r24	; 0x22
    6012:	26 89       	ldd	r18, Z+22	; 0x16
    6014:	91 a1       	ldd	r25, Z+33	; 0x21
    6016:	29 17       	cp	r18, r25
    6018:	51 f1       	breq	.+84     	; 0x606e <xTaskPriorityDisinherit+0x70>
    601a:	81 11       	cpse	r24, r1
    601c:	2a c0       	rjmp	.+84     	; 0x6072 <xTaskPriorityDisinherit+0x74>
    601e:	ef 01       	movw	r28, r30
    6020:	8f 01       	movw	r16, r30
    6022:	0e 5f       	subi	r16, 0xFE	; 254
    6024:	1f 4f       	sbci	r17, 0xFF	; 255
    6026:	c8 01       	movw	r24, r16
    6028:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    602c:	89 a1       	ldd	r24, Y+33	; 0x21
    602e:	8e 8b       	std	Y+22, r24	; 0x16
    6030:	26 e0       	ldi	r18, 0x06	; 6
    6032:	30 e0       	ldi	r19, 0x00	; 0
    6034:	28 1b       	sub	r18, r24
    6036:	31 09       	sbc	r19, r1
    6038:	3d 87       	std	Y+13, r19	; 0x0d
    603a:	2c 87       	std	Y+12, r18	; 0x0c
    603c:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    6040:	98 17       	cp	r25, r24
    6042:	10 f4       	brcc	.+4      	; 0x6048 <xTaskPriorityDisinherit+0x4a>
    6044:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    6048:	90 e0       	ldi	r25, 0x00	; 0
    604a:	9c 01       	movw	r18, r24
    604c:	22 0f       	add	r18, r18
    604e:	33 1f       	adc	r19, r19
    6050:	22 0f       	add	r18, r18
    6052:	33 1f       	adc	r19, r19
    6054:	22 0f       	add	r18, r18
    6056:	33 1f       	adc	r19, r19
    6058:	82 0f       	add	r24, r18
    605a:	93 1f       	adc	r25, r19
    605c:	b8 01       	movw	r22, r16
    605e:	8d 53       	subi	r24, 0x3D	; 61
    6060:	95 4e       	sbci	r25, 0xE5	; 229
    6062:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    6066:	81 e0       	ldi	r24, 0x01	; 1
    6068:	05 c0       	rjmp	.+10     	; 0x6074 <xTaskPriorityDisinherit+0x76>
    606a:	80 e0       	ldi	r24, 0x00	; 0
    606c:	03 c0       	rjmp	.+6      	; 0x6074 <xTaskPriorityDisinherit+0x76>
    606e:	80 e0       	ldi	r24, 0x00	; 0
    6070:	01 c0       	rjmp	.+2      	; 0x6074 <xTaskPriorityDisinherit+0x76>
    6072:	80 e0       	ldi	r24, 0x00	; 0
    6074:	df 91       	pop	r29
    6076:	cf 91       	pop	r28
    6078:	1f 91       	pop	r17
    607a:	0f 91       	pop	r16
    607c:	08 95       	ret

0000607e <pvTaskIncrementMutexHeldCount>:
    607e:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6082:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6086:	89 2b       	or	r24, r25
    6088:	39 f0       	breq	.+14     	; 0x6098 <pvTaskIncrementMutexHeldCount+0x1a>
    608a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    608e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6092:	82 a1       	ldd	r24, Z+34	; 0x22
    6094:	8f 5f       	subi	r24, 0xFF	; 255
    6096:	82 a3       	std	Z+34, r24	; 0x22
    6098:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    609c:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60a0:	08 95       	ret

000060a2 <ulTaskNotifyTake>:
    60a2:	0f 93       	push	r16
    60a4:	1f 93       	push	r17
    60a6:	cf 93       	push	r28
    60a8:	df 93       	push	r29
    60aa:	18 2f       	mov	r17, r24
    60ac:	eb 01       	movw	r28, r22
    60ae:	0f b6       	in	r0, 0x3f	; 63
    60b0:	f8 94       	cli
    60b2:	0f 92       	push	r0
    60b4:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    60b8:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60bc:	83 a1       	ldd	r24, Z+35	; 0x23
    60be:	94 a1       	ldd	r25, Z+36	; 0x24
    60c0:	a5 a1       	ldd	r26, Z+37	; 0x25
    60c2:	b6 a1       	ldd	r27, Z+38	; 0x26
    60c4:	89 2b       	or	r24, r25
    60c6:	8a 2b       	or	r24, r26
    60c8:	8b 2b       	or	r24, r27
    60ca:	09 f0       	breq	.+2      	; 0x60ce <ulTaskNotifyTake+0x2c>
    60cc:	58 c0       	rjmp	.+176    	; 0x617e <ulTaskNotifyTake+0xdc>
    60ce:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    60d2:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60d6:	81 e0       	ldi	r24, 0x01	; 1
    60d8:	87 a3       	std	Z+39, r24	; 0x27
    60da:	20 97       	sbiw	r28, 0x00	; 0
    60dc:	09 f4       	brne	.+2      	; 0x60e0 <ulTaskNotifyTake+0x3e>
    60de:	4f c0       	rjmp	.+158    	; 0x617e <ulTaskNotifyTake+0xdc>
    60e0:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    60e4:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60e8:	02 96       	adiw	r24, 0x02	; 2
    60ea:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    60ee:	cf 3f       	cpi	r28, 0xFF	; 255
    60f0:	8f ef       	ldi	r24, 0xFF	; 255
    60f2:	d8 07       	cpc	r29, r24
    60f4:	59 f4       	brne	.+22     	; 0x610c <ulTaskNotifyTake+0x6a>
    60f6:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    60fa:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    60fe:	6e 5f       	subi	r22, 0xFE	; 254
    6100:	7f 4f       	sbci	r23, 0xFF	; 255
    6102:	8b e9       	ldi	r24, 0x9B	; 155
    6104:	9a e1       	ldi	r25, 0x1A	; 26
    6106:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    610a:	37 c0       	rjmp	.+110    	; 0x617a <ulTaskNotifyTake+0xd8>
    610c:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    6110:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    6114:	c8 0f       	add	r28, r24
    6116:	d9 1f       	adc	r29, r25
    6118:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    611c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6120:	d3 83       	std	Z+3, r29	; 0x03
    6122:	c2 83       	std	Z+2, r28	; 0x02
    6124:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    6128:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    612c:	c8 17       	cp	r28, r24
    612e:	d9 07       	cpc	r29, r25
    6130:	68 f4       	brcc	.+26     	; 0x614c <ulTaskNotifyTake+0xaa>
    6132:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6136:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    613a:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    613e:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    6142:	6e 5f       	subi	r22, 0xFE	; 254
    6144:	7f 4f       	sbci	r23, 0xFF	; 255
    6146:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    614a:	17 c0       	rjmp	.+46     	; 0x617a <ulTaskNotifyTake+0xd8>
    614c:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6150:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6154:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    6158:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    615c:	6e 5f       	subi	r22, 0xFE	; 254
    615e:	7f 4f       	sbci	r23, 0xFF	; 255
    6160:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    6164:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    6168:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    616c:	c8 17       	cp	r28, r24
    616e:	d9 07       	cpc	r29, r25
    6170:	20 f4       	brcc	.+8      	; 0x617a <ulTaskNotifyTake+0xd8>
    6172:	d0 93 91 1a 	sts	0x1A91, r29	; 0x801a91 <xNextTaskUnblockTime+0x1>
    6176:	c0 93 90 1a 	sts	0x1A90, r28	; 0x801a90 <xNextTaskUnblockTime>
    617a:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    617e:	0f 90       	pop	r0
    6180:	0f be       	out	0x3f, r0	; 63
    6182:	0f b6       	in	r0, 0x3f	; 63
    6184:	f8 94       	cli
    6186:	0f 92       	push	r0
    6188:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    618c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6190:	63 a1       	ldd	r22, Z+35	; 0x23
    6192:	74 a1       	ldd	r23, Z+36	; 0x24
    6194:	85 a1       	ldd	r24, Z+37	; 0x25
    6196:	96 a1       	ldd	r25, Z+38	; 0x26
    6198:	61 15       	cp	r22, r1
    619a:	71 05       	cpc	r23, r1
    619c:	81 05       	cpc	r24, r1
    619e:	91 05       	cpc	r25, r1
    61a0:	d9 f0       	breq	.+54     	; 0x61d8 <ulTaskNotifyTake+0x136>
    61a2:	11 23       	and	r17, r17
    61a4:	49 f0       	breq	.+18     	; 0x61b8 <ulTaskNotifyTake+0x116>
    61a6:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    61aa:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    61ae:	13 a2       	std	Z+35, r1	; 0x23
    61b0:	14 a2       	std	Z+36, r1	; 0x24
    61b2:	15 a2       	std	Z+37, r1	; 0x25
    61b4:	16 a2       	std	Z+38, r1	; 0x26
    61b6:	10 c0       	rjmp	.+32     	; 0x61d8 <ulTaskNotifyTake+0x136>
    61b8:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    61bc:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    61c0:	03 a1       	ldd	r16, Z+35	; 0x23
    61c2:	14 a1       	ldd	r17, Z+36	; 0x24
    61c4:	25 a1       	ldd	r18, Z+37	; 0x25
    61c6:	36 a1       	ldd	r19, Z+38	; 0x26
    61c8:	01 50       	subi	r16, 0x01	; 1
    61ca:	11 09       	sbc	r17, r1
    61cc:	21 09       	sbc	r18, r1
    61ce:	31 09       	sbc	r19, r1
    61d0:	03 a3       	std	Z+35, r16	; 0x23
    61d2:	14 a3       	std	Z+36, r17	; 0x24
    61d4:	25 a3       	std	Z+37, r18	; 0x25
    61d6:	36 a3       	std	Z+38, r19	; 0x26
    61d8:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    61dc:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    61e0:	17 a2       	std	Z+39, r1	; 0x27
    61e2:	0f 90       	pop	r0
    61e4:	0f be       	out	0x3f, r0	; 63
    61e6:	df 91       	pop	r29
    61e8:	cf 91       	pop	r28
    61ea:	1f 91       	pop	r17
    61ec:	0f 91       	pop	r16
    61ee:	08 95       	ret

000061f0 <xTaskNotifyWait>:
    61f0:	4f 92       	push	r4
    61f2:	5f 92       	push	r5
    61f4:	6f 92       	push	r6
    61f6:	7f 92       	push	r7
    61f8:	8f 92       	push	r8
    61fa:	9f 92       	push	r9
    61fc:	af 92       	push	r10
    61fe:	bf 92       	push	r11
    6200:	ef 92       	push	r14
    6202:	ff 92       	push	r15
    6204:	0f 93       	push	r16
    6206:	1f 93       	push	r17
    6208:	49 01       	movw	r8, r18
    620a:	5a 01       	movw	r10, r20
    620c:	0f b6       	in	r0, 0x3f	; 63
    620e:	f8 94       	cli
    6210:	0f 92       	push	r0
    6212:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6216:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    621a:	27 a1       	ldd	r18, Z+39	; 0x27
    621c:	22 30       	cpi	r18, 0x02	; 2
    621e:	09 f4       	brne	.+2      	; 0x6222 <xTaskNotifyWait+0x32>
    6220:	6f c0       	rjmp	.+222    	; 0x6300 <xTaskNotifyWait+0x110>
    6222:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6226:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    622a:	43 a0       	ldd	r4, Z+35	; 0x23
    622c:	54 a0       	ldd	r5, Z+36	; 0x24
    622e:	65 a0       	ldd	r6, Z+37	; 0x25
    6230:	76 a0       	ldd	r7, Z+38	; 0x26
    6232:	dc 01       	movw	r26, r24
    6234:	cb 01       	movw	r24, r22
    6236:	80 95       	com	r24
    6238:	90 95       	com	r25
    623a:	a0 95       	com	r26
    623c:	b0 95       	com	r27
    623e:	84 21       	and	r24, r4
    6240:	95 21       	and	r25, r5
    6242:	a6 21       	and	r26, r6
    6244:	b7 21       	and	r27, r7
    6246:	83 a3       	std	Z+35, r24	; 0x23
    6248:	94 a3       	std	Z+36, r25	; 0x24
    624a:	a5 a3       	std	Z+37, r26	; 0x25
    624c:	b6 a3       	std	Z+38, r27	; 0x26
    624e:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6252:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6256:	81 e0       	ldi	r24, 0x01	; 1
    6258:	87 a3       	std	Z+39, r24	; 0x27
    625a:	e1 14       	cp	r14, r1
    625c:	f1 04       	cpc	r15, r1
    625e:	09 f4       	brne	.+2      	; 0x6262 <xTaskNotifyWait+0x72>
    6260:	4f c0       	rjmp	.+158    	; 0x6300 <xTaskNotifyWait+0x110>
    6262:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6266:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    626a:	02 96       	adiw	r24, 0x02	; 2
    626c:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    6270:	8f ef       	ldi	r24, 0xFF	; 255
    6272:	e8 16       	cp	r14, r24
    6274:	f8 06       	cpc	r15, r24
    6276:	59 f4       	brne	.+22     	; 0x628e <xTaskNotifyWait+0x9e>
    6278:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    627c:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6280:	6e 5f       	subi	r22, 0xFE	; 254
    6282:	7f 4f       	sbci	r23, 0xFF	; 255
    6284:	8b e9       	ldi	r24, 0x9B	; 155
    6286:	9a e1       	ldi	r25, 0x1A	; 26
    6288:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    628c:	37 c0       	rjmp	.+110    	; 0x62fc <xTaskNotifyWait+0x10c>
    628e:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    6292:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    6296:	e8 0e       	add	r14, r24
    6298:	f9 1e       	adc	r15, r25
    629a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    629e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    62a2:	f3 82       	std	Z+3, r15	; 0x03
    62a4:	e2 82       	std	Z+2, r14	; 0x02
    62a6:	80 91 98 1a 	lds	r24, 0x1A98	; 0x801a98 <xTickCount>
    62aa:	90 91 99 1a 	lds	r25, 0x1A99	; 0x801a99 <xTickCount+0x1>
    62ae:	e8 16       	cp	r14, r24
    62b0:	f9 06       	cpc	r15, r25
    62b2:	68 f4       	brcc	.+26     	; 0x62ce <xTaskNotifyWait+0xde>
    62b4:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    62b8:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    62bc:	80 91 ad 1a 	lds	r24, 0x1AAD	; 0x801aad <pxOverflowDelayedTaskList>
    62c0:	90 91 ae 1a 	lds	r25, 0x1AAE	; 0x801aae <pxOverflowDelayedTaskList+0x1>
    62c4:	6e 5f       	subi	r22, 0xFE	; 254
    62c6:	7f 4f       	sbci	r23, 0xFF	; 255
    62c8:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    62cc:	17 c0       	rjmp	.+46     	; 0x62fc <xTaskNotifyWait+0x10c>
    62ce:	60 91 f9 1a 	lds	r22, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    62d2:	70 91 fa 1a 	lds	r23, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    62d6:	80 91 af 1a 	lds	r24, 0x1AAF	; 0x801aaf <pxDelayedTaskList>
    62da:	90 91 b0 1a 	lds	r25, 0x1AB0	; 0x801ab0 <pxDelayedTaskList+0x1>
    62de:	6e 5f       	subi	r22, 0xFE	; 254
    62e0:	7f 4f       	sbci	r23, 0xFF	; 255
    62e2:	0e 94 61 0c 	call	0x18c2	; 0x18c2 <vListInsert>
    62e6:	80 91 90 1a 	lds	r24, 0x1A90	; 0x801a90 <xNextTaskUnblockTime>
    62ea:	90 91 91 1a 	lds	r25, 0x1A91	; 0x801a91 <xNextTaskUnblockTime+0x1>
    62ee:	e8 16       	cp	r14, r24
    62f0:	f9 06       	cpc	r15, r25
    62f2:	20 f4       	brcc	.+8      	; 0x62fc <xTaskNotifyWait+0x10c>
    62f4:	f0 92 91 1a 	sts	0x1A91, r15	; 0x801a91 <xNextTaskUnblockTime+0x1>
    62f8:	e0 92 90 1a 	sts	0x1A90, r14	; 0x801a90 <xNextTaskUnblockTime>
    62fc:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    6300:	0f 90       	pop	r0
    6302:	0f be       	out	0x3f, r0	; 63
    6304:	0f b6       	in	r0, 0x3f	; 63
    6306:	f8 94       	cli
    6308:	0f 92       	push	r0
    630a:	01 15       	cp	r16, r1
    630c:	11 05       	cpc	r17, r1
    630e:	69 f0       	breq	.+26     	; 0x632a <xTaskNotifyWait+0x13a>
    6310:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6314:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6318:	83 a1       	ldd	r24, Z+35	; 0x23
    631a:	94 a1       	ldd	r25, Z+36	; 0x24
    631c:	a5 a1       	ldd	r26, Z+37	; 0x25
    631e:	b6 a1       	ldd	r27, Z+38	; 0x26
    6320:	f8 01       	movw	r30, r16
    6322:	80 83       	st	Z, r24
    6324:	91 83       	std	Z+1, r25	; 0x01
    6326:	a2 83       	std	Z+2, r26	; 0x02
    6328:	b3 83       	std	Z+3, r27	; 0x03
    632a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    632e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6332:	87 a1       	ldd	r24, Z+39	; 0x27
    6334:	81 30       	cpi	r24, 0x01	; 1
    6336:	b1 f0       	breq	.+44     	; 0x6364 <xTaskNotifyWait+0x174>
    6338:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    633c:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6340:	83 a1       	ldd	r24, Z+35	; 0x23
    6342:	94 a1       	ldd	r25, Z+36	; 0x24
    6344:	a5 a1       	ldd	r26, Z+37	; 0x25
    6346:	b6 a1       	ldd	r27, Z+38	; 0x26
    6348:	80 94       	com	r8
    634a:	90 94       	com	r9
    634c:	a0 94       	com	r10
    634e:	b0 94       	com	r11
    6350:	88 22       	and	r8, r24
    6352:	99 22       	and	r9, r25
    6354:	aa 22       	and	r10, r26
    6356:	bb 22       	and	r11, r27
    6358:	83 a2       	std	Z+35, r8	; 0x23
    635a:	94 a2       	std	Z+36, r9	; 0x24
    635c:	a5 a2       	std	Z+37, r10	; 0x25
    635e:	b6 a2       	std	Z+38, r11	; 0x26
    6360:	81 e0       	ldi	r24, 0x01	; 1
    6362:	01 c0       	rjmp	.+2      	; 0x6366 <xTaskNotifyWait+0x176>
    6364:	80 e0       	ldi	r24, 0x00	; 0
    6366:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    636a:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    636e:	17 a2       	std	Z+39, r1	; 0x27
    6370:	0f 90       	pop	r0
    6372:	0f be       	out	0x3f, r0	; 63
    6374:	1f 91       	pop	r17
    6376:	0f 91       	pop	r16
    6378:	ff 90       	pop	r15
    637a:	ef 90       	pop	r14
    637c:	bf 90       	pop	r11
    637e:	af 90       	pop	r10
    6380:	9f 90       	pop	r9
    6382:	8f 90       	pop	r8
    6384:	7f 90       	pop	r7
    6386:	6f 90       	pop	r6
    6388:	5f 90       	pop	r5
    638a:	4f 90       	pop	r4
    638c:	08 95       	ret

0000638e <xTaskGenericNotify>:
    638e:	0f 93       	push	r16
    6390:	1f 93       	push	r17
    6392:	cf 93       	push	r28
    6394:	df 93       	push	r29
    6396:	fc 01       	movw	r30, r24
    6398:	0f b6       	in	r0, 0x3f	; 63
    639a:	f8 94       	cli
    639c:	0f 92       	push	r0
    639e:	01 15       	cp	r16, r1
    63a0:	11 05       	cpc	r17, r1
    63a2:	49 f0       	breq	.+18     	; 0x63b6 <xTaskGenericNotify+0x28>
    63a4:	83 a1       	ldd	r24, Z+35	; 0x23
    63a6:	94 a1       	ldd	r25, Z+36	; 0x24
    63a8:	a5 a1       	ldd	r26, Z+37	; 0x25
    63aa:	b6 a1       	ldd	r27, Z+38	; 0x26
    63ac:	e8 01       	movw	r28, r16
    63ae:	88 83       	st	Y, r24
    63b0:	99 83       	std	Y+1, r25	; 0x01
    63b2:	aa 83       	std	Y+2, r26	; 0x02
    63b4:	bb 83       	std	Y+3, r27	; 0x03
    63b6:	87 a1       	ldd	r24, Z+39	; 0x27
    63b8:	92 e0       	ldi	r25, 0x02	; 2
    63ba:	97 a3       	std	Z+39, r25	; 0x27
    63bc:	22 30       	cpi	r18, 0x02	; 2
    63be:	b1 f0       	breq	.+44     	; 0x63ec <xTaskGenericNotify+0x5e>
    63c0:	18 f4       	brcc	.+6      	; 0x63c8 <xTaskGenericNotify+0x3a>
    63c2:	21 30       	cpi	r18, 0x01	; 1
    63c4:	31 f0       	breq	.+12     	; 0x63d2 <xTaskGenericNotify+0x44>
    63c6:	2a c0       	rjmp	.+84     	; 0x641c <xTaskGenericNotify+0x8e>
    63c8:	23 30       	cpi	r18, 0x03	; 3
    63ca:	e9 f0       	breq	.+58     	; 0x6406 <xTaskGenericNotify+0x78>
    63cc:	24 30       	cpi	r18, 0x04	; 4
    63ce:	01 f1       	breq	.+64     	; 0x6410 <xTaskGenericNotify+0x82>
    63d0:	25 c0       	rjmp	.+74     	; 0x641c <xTaskGenericNotify+0x8e>
    63d2:	03 a1       	ldd	r16, Z+35	; 0x23
    63d4:	14 a1       	ldd	r17, Z+36	; 0x24
    63d6:	25 a1       	ldd	r18, Z+37	; 0x25
    63d8:	36 a1       	ldd	r19, Z+38	; 0x26
    63da:	40 2b       	or	r20, r16
    63dc:	51 2b       	or	r21, r17
    63de:	62 2b       	or	r22, r18
    63e0:	73 2b       	or	r23, r19
    63e2:	43 a3       	std	Z+35, r20	; 0x23
    63e4:	54 a3       	std	Z+36, r21	; 0x24
    63e6:	65 a3       	std	Z+37, r22	; 0x25
    63e8:	76 a3       	std	Z+38, r23	; 0x26
    63ea:	18 c0       	rjmp	.+48     	; 0x641c <xTaskGenericNotify+0x8e>
    63ec:	43 a1       	ldd	r20, Z+35	; 0x23
    63ee:	54 a1       	ldd	r21, Z+36	; 0x24
    63f0:	65 a1       	ldd	r22, Z+37	; 0x25
    63f2:	76 a1       	ldd	r23, Z+38	; 0x26
    63f4:	4f 5f       	subi	r20, 0xFF	; 255
    63f6:	5f 4f       	sbci	r21, 0xFF	; 255
    63f8:	6f 4f       	sbci	r22, 0xFF	; 255
    63fa:	7f 4f       	sbci	r23, 0xFF	; 255
    63fc:	43 a3       	std	Z+35, r20	; 0x23
    63fe:	54 a3       	std	Z+36, r21	; 0x24
    6400:	65 a3       	std	Z+37, r22	; 0x25
    6402:	76 a3       	std	Z+38, r23	; 0x26
    6404:	0b c0       	rjmp	.+22     	; 0x641c <xTaskGenericNotify+0x8e>
    6406:	43 a3       	std	Z+35, r20	; 0x23
    6408:	54 a3       	std	Z+36, r21	; 0x24
    640a:	65 a3       	std	Z+37, r22	; 0x25
    640c:	76 a3       	std	Z+38, r23	; 0x26
    640e:	06 c0       	rjmp	.+12     	; 0x641c <xTaskGenericNotify+0x8e>
    6410:	82 30       	cpi	r24, 0x02	; 2
    6412:	79 f1       	breq	.+94     	; 0x6472 <xTaskGenericNotify+0xe4>
    6414:	43 a3       	std	Z+35, r20	; 0x23
    6416:	54 a3       	std	Z+36, r21	; 0x24
    6418:	65 a3       	std	Z+37, r22	; 0x25
    641a:	76 a3       	std	Z+38, r23	; 0x26
    641c:	81 30       	cpi	r24, 0x01	; 1
    641e:	59 f5       	brne	.+86     	; 0x6476 <xTaskGenericNotify+0xe8>
    6420:	ef 01       	movw	r28, r30
    6422:	8f 01       	movw	r16, r30
    6424:	0e 5f       	subi	r16, 0xFE	; 254
    6426:	1f 4f       	sbci	r17, 0xFF	; 255
    6428:	c8 01       	movw	r24, r16
    642a:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    642e:	8e 89       	ldd	r24, Y+22	; 0x16
    6430:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    6434:	98 17       	cp	r25, r24
    6436:	10 f4       	brcc	.+4      	; 0x643c <xTaskGenericNotify+0xae>
    6438:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    643c:	90 e0       	ldi	r25, 0x00	; 0
    643e:	9c 01       	movw	r18, r24
    6440:	22 0f       	add	r18, r18
    6442:	33 1f       	adc	r19, r19
    6444:	22 0f       	add	r18, r18
    6446:	33 1f       	adc	r19, r19
    6448:	22 0f       	add	r18, r18
    644a:	33 1f       	adc	r19, r19
    644c:	82 0f       	add	r24, r18
    644e:	93 1f       	adc	r25, r19
    6450:	b8 01       	movw	r22, r16
    6452:	8d 53       	subi	r24, 0x3D	; 61
    6454:	95 4e       	sbci	r25, 0xE5	; 229
    6456:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    645a:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    645e:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6462:	9e 89       	ldd	r25, Y+22	; 0x16
    6464:	86 89       	ldd	r24, Z+22	; 0x16
    6466:	89 17       	cp	r24, r25
    6468:	40 f4       	brcc	.+16     	; 0x647a <xTaskGenericNotify+0xec>
    646a:	0e 94 8c 1c 	call	0x3918	; 0x3918 <vPortYield>
    646e:	81 e0       	ldi	r24, 0x01	; 1
    6470:	05 c0       	rjmp	.+10     	; 0x647c <xTaskGenericNotify+0xee>
    6472:	80 e0       	ldi	r24, 0x00	; 0
    6474:	03 c0       	rjmp	.+6      	; 0x647c <xTaskGenericNotify+0xee>
    6476:	81 e0       	ldi	r24, 0x01	; 1
    6478:	01 c0       	rjmp	.+2      	; 0x647c <xTaskGenericNotify+0xee>
    647a:	81 e0       	ldi	r24, 0x01	; 1
    647c:	0f 90       	pop	r0
    647e:	0f be       	out	0x3f, r0	; 63
    6480:	df 91       	pop	r29
    6482:	cf 91       	pop	r28
    6484:	1f 91       	pop	r17
    6486:	0f 91       	pop	r16
    6488:	08 95       	ret

0000648a <xTaskGenericNotifyFromISR>:
    648a:	ef 92       	push	r14
    648c:	ff 92       	push	r15
    648e:	0f 93       	push	r16
    6490:	1f 93       	push	r17
    6492:	cf 93       	push	r28
    6494:	df 93       	push	r29
    6496:	fc 01       	movw	r30, r24
    6498:	01 15       	cp	r16, r1
    649a:	11 05       	cpc	r17, r1
    649c:	49 f0       	breq	.+18     	; 0x64b0 <xTaskGenericNotifyFromISR+0x26>
    649e:	83 a1       	ldd	r24, Z+35	; 0x23
    64a0:	94 a1       	ldd	r25, Z+36	; 0x24
    64a2:	a5 a1       	ldd	r26, Z+37	; 0x25
    64a4:	b6 a1       	ldd	r27, Z+38	; 0x26
    64a6:	e8 01       	movw	r28, r16
    64a8:	88 83       	st	Y, r24
    64aa:	99 83       	std	Y+1, r25	; 0x01
    64ac:	aa 83       	std	Y+2, r26	; 0x02
    64ae:	bb 83       	std	Y+3, r27	; 0x03
    64b0:	87 a1       	ldd	r24, Z+39	; 0x27
    64b2:	92 e0       	ldi	r25, 0x02	; 2
    64b4:	97 a3       	std	Z+39, r25	; 0x27
    64b6:	22 30       	cpi	r18, 0x02	; 2
    64b8:	b1 f0       	breq	.+44     	; 0x64e6 <xTaskGenericNotifyFromISR+0x5c>
    64ba:	18 f4       	brcc	.+6      	; 0x64c2 <xTaskGenericNotifyFromISR+0x38>
    64bc:	21 30       	cpi	r18, 0x01	; 1
    64be:	31 f0       	breq	.+12     	; 0x64cc <xTaskGenericNotifyFromISR+0x42>
    64c0:	2a c0       	rjmp	.+84     	; 0x6516 <xTaskGenericNotifyFromISR+0x8c>
    64c2:	23 30       	cpi	r18, 0x03	; 3
    64c4:	e9 f0       	breq	.+58     	; 0x6500 <xTaskGenericNotifyFromISR+0x76>
    64c6:	24 30       	cpi	r18, 0x04	; 4
    64c8:	01 f1       	breq	.+64     	; 0x650a <xTaskGenericNotifyFromISR+0x80>
    64ca:	25 c0       	rjmp	.+74     	; 0x6516 <xTaskGenericNotifyFromISR+0x8c>
    64cc:	03 a1       	ldd	r16, Z+35	; 0x23
    64ce:	14 a1       	ldd	r17, Z+36	; 0x24
    64d0:	25 a1       	ldd	r18, Z+37	; 0x25
    64d2:	36 a1       	ldd	r19, Z+38	; 0x26
    64d4:	40 2b       	or	r20, r16
    64d6:	51 2b       	or	r21, r17
    64d8:	62 2b       	or	r22, r18
    64da:	73 2b       	or	r23, r19
    64dc:	43 a3       	std	Z+35, r20	; 0x23
    64de:	54 a3       	std	Z+36, r21	; 0x24
    64e0:	65 a3       	std	Z+37, r22	; 0x25
    64e2:	76 a3       	std	Z+38, r23	; 0x26
    64e4:	18 c0       	rjmp	.+48     	; 0x6516 <xTaskGenericNotifyFromISR+0x8c>
    64e6:	43 a1       	ldd	r20, Z+35	; 0x23
    64e8:	54 a1       	ldd	r21, Z+36	; 0x24
    64ea:	65 a1       	ldd	r22, Z+37	; 0x25
    64ec:	76 a1       	ldd	r23, Z+38	; 0x26
    64ee:	4f 5f       	subi	r20, 0xFF	; 255
    64f0:	5f 4f       	sbci	r21, 0xFF	; 255
    64f2:	6f 4f       	sbci	r22, 0xFF	; 255
    64f4:	7f 4f       	sbci	r23, 0xFF	; 255
    64f6:	43 a3       	std	Z+35, r20	; 0x23
    64f8:	54 a3       	std	Z+36, r21	; 0x24
    64fa:	65 a3       	std	Z+37, r22	; 0x25
    64fc:	76 a3       	std	Z+38, r23	; 0x26
    64fe:	0b c0       	rjmp	.+22     	; 0x6516 <xTaskGenericNotifyFromISR+0x8c>
    6500:	43 a3       	std	Z+35, r20	; 0x23
    6502:	54 a3       	std	Z+36, r21	; 0x24
    6504:	65 a3       	std	Z+37, r22	; 0x25
    6506:	76 a3       	std	Z+38, r23	; 0x26
    6508:	06 c0       	rjmp	.+12     	; 0x6516 <xTaskGenericNotifyFromISR+0x8c>
    650a:	82 30       	cpi	r24, 0x02	; 2
    650c:	f1 f1       	breq	.+124    	; 0x658a <xTaskGenericNotifyFromISR+0x100>
    650e:	43 a3       	std	Z+35, r20	; 0x23
    6510:	54 a3       	std	Z+36, r21	; 0x24
    6512:	65 a3       	std	Z+37, r22	; 0x25
    6514:	76 a3       	std	Z+38, r23	; 0x26
    6516:	81 30       	cpi	r24, 0x01	; 1
    6518:	d1 f5       	brne	.+116    	; 0x658e <xTaskGenericNotifyFromISR+0x104>
    651a:	ef 01       	movw	r28, r30
    651c:	80 91 8f 1a 	lds	r24, 0x1A8F	; 0x801a8f <uxSchedulerSuspended>
    6520:	81 11       	cpse	r24, r1
    6522:	1d c0       	rjmp	.+58     	; 0x655e <xTaskGenericNotifyFromISR+0xd4>
    6524:	8f 01       	movw	r16, r30
    6526:	0e 5f       	subi	r16, 0xFE	; 254
    6528:	1f 4f       	sbci	r17, 0xFF	; 255
    652a:	c8 01       	movw	r24, r16
    652c:	0e 94 92 0c 	call	0x1924	; 0x1924 <uxListRemove>
    6530:	8e 89       	ldd	r24, Y+22	; 0x16
    6532:	90 91 97 1a 	lds	r25, 0x1A97	; 0x801a97 <uxTopReadyPriority>
    6536:	98 17       	cp	r25, r24
    6538:	10 f4       	brcc	.+4      	; 0x653e <xTaskGenericNotifyFromISR+0xb4>
    653a:	80 93 97 1a 	sts	0x1A97, r24	; 0x801a97 <uxTopReadyPriority>
    653e:	90 e0       	ldi	r25, 0x00	; 0
    6540:	9c 01       	movw	r18, r24
    6542:	22 0f       	add	r18, r18
    6544:	33 1f       	adc	r19, r19
    6546:	22 0f       	add	r18, r18
    6548:	33 1f       	adc	r19, r19
    654a:	22 0f       	add	r18, r18
    654c:	33 1f       	adc	r19, r19
    654e:	82 0f       	add	r24, r18
    6550:	93 1f       	adc	r25, r19
    6552:	b8 01       	movw	r22, r16
    6554:	8d 53       	subi	r24, 0x3D	; 61
    6556:	95 4e       	sbci	r25, 0xE5	; 229
    6558:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    655c:	07 c0       	rjmp	.+14     	; 0x656c <xTaskGenericNotifyFromISR+0xe2>
    655e:	bf 01       	movw	r22, r30
    6560:	64 5f       	subi	r22, 0xF4	; 244
    6562:	7f 4f       	sbci	r23, 0xFF	; 255
    6564:	84 ea       	ldi	r24, 0xA4	; 164
    6566:	9a e1       	ldi	r25, 0x1A	; 26
    6568:	0e 94 40 0c 	call	0x1880	; 0x1880 <vListInsertEnd>
    656c:	e0 91 f9 1a 	lds	r30, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    6570:	f0 91 fa 1a 	lds	r31, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>
    6574:	9e 89       	ldd	r25, Y+22	; 0x16
    6576:	86 89       	ldd	r24, Z+22	; 0x16
    6578:	89 17       	cp	r24, r25
    657a:	58 f4       	brcc	.+22     	; 0x6592 <xTaskGenericNotifyFromISR+0x108>
    657c:	e1 14       	cp	r14, r1
    657e:	f1 04       	cpc	r15, r1
    6580:	51 f0       	breq	.+20     	; 0x6596 <xTaskGenericNotifyFromISR+0x10c>
    6582:	81 e0       	ldi	r24, 0x01	; 1
    6584:	f7 01       	movw	r30, r14
    6586:	80 83       	st	Z, r24
    6588:	07 c0       	rjmp	.+14     	; 0x6598 <xTaskGenericNotifyFromISR+0x10e>
    658a:	80 e0       	ldi	r24, 0x00	; 0
    658c:	05 c0       	rjmp	.+10     	; 0x6598 <xTaskGenericNotifyFromISR+0x10e>
    658e:	81 e0       	ldi	r24, 0x01	; 1
    6590:	03 c0       	rjmp	.+6      	; 0x6598 <xTaskGenericNotifyFromISR+0x10e>
    6592:	81 e0       	ldi	r24, 0x01	; 1
    6594:	01 c0       	rjmp	.+2      	; 0x6598 <xTaskGenericNotifyFromISR+0x10e>
    6596:	81 e0       	ldi	r24, 0x01	; 1
    6598:	df 91       	pop	r29
    659a:	cf 91       	pop	r28
    659c:	1f 91       	pop	r17
    659e:	0f 91       	pop	r16
    65a0:	ff 90       	pop	r15
    65a2:	ef 90       	pop	r14
    65a4:	08 95       	ret

000065a6 <xTaskNotifyStateClear>:

		pxTCB = ( TCB_t * ) xTask;

		/* If null is passed in here then it is the calling task that is having
		its notification state cleared. */
		pxTCB = prvGetTCBFromHandle( pxTCB );
    65a6:	00 97       	sbiw	r24, 0x00	; 0
    65a8:	21 f4       	brne	.+8      	; 0x65b2 <xTaskNotifyStateClear+0xc>
    65aa:	80 91 f9 1a 	lds	r24, 0x1AF9	; 0x801af9 <pxCurrentTCB>
    65ae:	90 91 fa 1a 	lds	r25, 0x1AFA	; 0x801afa <pxCurrentTCB+0x1>

		taskENTER_CRITICAL();
    65b2:	0f b6       	in	r0, 0x3f	; 63
    65b4:	f8 94       	cli
    65b6:	0f 92       	push	r0
		{
			if( pxTCB->eNotifyState == eNotified )
    65b8:	fc 01       	movw	r30, r24
    65ba:	27 a1       	ldd	r18, Z+39	; 0x27
    65bc:	22 30       	cpi	r18, 0x02	; 2
    65be:	19 f4       	brne	.+6      	; 0x65c6 <xTaskNotifyStateClear+0x20>
			{
				pxTCB->eNotifyState = eNotWaitingNotification;
    65c0:	17 a2       	std	Z+39, r1	; 0x27
				xReturn = pdPASS;
    65c2:	81 e0       	ldi	r24, 0x01	; 1
    65c4:	01 c0       	rjmp	.+2      	; 0x65c8 <xTaskNotifyStateClear+0x22>
			}
			else
			{
				xReturn = pdFAIL;
    65c6:	80 e0       	ldi	r24, 0x00	; 0
			}
		}
		taskEXIT_CRITICAL();
    65c8:	0f 90       	pop	r0
    65ca:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    65cc:	08 95       	ret

000065ce <vFrameReaderTask>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint8_t)) {
	receive_callback = cb;
}

void vFrameReaderTask( void *pvParameters ){
    65ce:	cf 93       	push	r28
    65d0:	df 93       	push	r29
    65d2:	00 d0       	rcall	.+0      	; 0x65d4 <vFrameReaderTask+0x6>
    65d4:	1f 92       	push	r1
    65d6:	cd b7       	in	r28, 0x3d	; 61
    65d8:	de b7       	in	r29, 0x3e	; 62
	frame_receiver = xTaskGetCurrentTaskHandle();
    65da:	aa dc       	rcall	.-1708   	; 0x5f30 <xTaskGetCurrentTaskHandle>
    65dc:	90 93 62 1b 	sts	0x1B62, r25	; 0x801b62 <frame_receiver+0x1>
    65e0:	80 93 61 1b 	sts	0x1B61, r24	; 0x801b61 <frame_receiver>
	uint32_t notification_value = 0;
    65e4:	19 82       	std	Y+1, r1	; 0x01
    65e6:	1a 82       	std	Y+2, r1	; 0x02
    65e8:	1b 82       	std	Y+3, r1	; 0x03
    65ea:	1c 82       	std	Y+4, r1	; 0x04
	while(1){
		xTaskNotifyWait(0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);
    65ec:	ee 24       	eor	r14, r14
    65ee:	ea 94       	dec	r14
    65f0:	fe 2c       	mov	r15, r14
    65f2:	8e 01       	movw	r16, r28
    65f4:	0f 5f       	subi	r16, 0xFF	; 255
    65f6:	1f 4f       	sbci	r17, 0xFF	; 255
    65f8:	2f ef       	ldi	r18, 0xFF	; 255
    65fa:	3f ef       	ldi	r19, 0xFF	; 255
    65fc:	a9 01       	movw	r20, r18
    65fe:	6f ef       	ldi	r22, 0xFF	; 255
    6600:	7f ef       	ldi	r23, 0xFF	; 255
    6602:	cb 01       	movw	r24, r22
    6604:	f5 dd       	rcall	.-1046   	; 0x61f0 <xTaskNotifyWait>
		if(receive_callback != NULL) receive_callback(receive_buffer, (uint8_t)notification_value);
    6606:	e0 91 c2 1b 	lds	r30, 0x1BC2	; 0x801bc2 <receive_callback>
    660a:	f0 91 c3 1b 	lds	r31, 0x1BC3	; 0x801bc3 <receive_callback+0x1>
    660e:	30 97       	sbiw	r30, 0x00	; 0
    6610:	69 f3       	breq	.-38     	; 0x65ec <vFrameReaderTask+0x1e>
    6612:	69 81       	ldd	r22, Y+1	; 0x01
    6614:	84 ec       	ldi	r24, 0xC4	; 196
    6616:	9b e1       	ldi	r25, 0x1B	; 27
    6618:	19 95       	eicall
    661a:	e8 cf       	rjmp	.-48     	; 0x65ec <vFrameReaderTask+0x1e>

0000661c <vUartSendTask>:
	}
}

void vUartSendTask(void *pvParamters) {
    661c:	cf 93       	push	r28
    661e:	df 93       	push	r29
    6620:	cd b7       	in	r28, 0x3d	; 61
    6622:	de b7       	in	r29, 0x3e	; 62
    6624:	c4 56       	subi	r28, 0x64	; 100
    6626:	d1 09       	sbc	r29, r1
    6628:	0f b6       	in	r0, 0x3f	; 63
    662a:	f8 94       	cli
    662c:	de bf       	out	0x3e, r29	; 62
    662e:	0f be       	out	0x3f, r0	; 63
    6630:	cd bf       	out	0x3d, r28	; 61
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    6632:	00 ed       	ldi	r16, 0xD0	; 208
    6634:	10 e0       	ldi	r17, 0x00	; 0
				UDR2 = data[i];
    6636:	0f 2e       	mov	r0, r31
    6638:	f6 ed       	ldi	r31, 0xD6	; 214
    663a:	ef 2e       	mov	r14, r31
    663c:	f1 2c       	mov	r15, r1
    663e:	f0 2d       	mov	r31, r0
void vUartSendTask(void *pvParamters) {
	uint8_t data[100];
	uint16_t num;
	uint16_t i;
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
    6640:	20 e0       	ldi	r18, 0x00	; 0
    6642:	4f ef       	ldi	r20, 0xFF	; 255
    6644:	5f ef       	ldi	r21, 0xFF	; 255
    6646:	60 e0       	ldi	r22, 0x00	; 0
    6648:	70 e0       	ldi	r23, 0x00	; 0
    664a:	80 91 87 1b 	lds	r24, 0x1B87	; 0x801b87 <xUartMutex>
    664e:	90 91 88 1b 	lds	r25, 0x1B88	; 0x801b88 <xUartMutex+0x1>
    6652:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
    6656:	24 e6       	ldi	r18, 0x64	; 100
    6658:	30 e0       	ldi	r19, 0x00	; 0
    665a:	40 e0       	ldi	r20, 0x00	; 0
    665c:	be 01       	movw	r22, r28
    665e:	6f 5f       	subi	r22, 0xFF	; 255
    6660:	7f 4f       	sbci	r23, 0xFF	; 255
    6662:	88 e2       	ldi	r24, 0x28	; 40
    6664:	9c e1       	ldi	r25, 0x1C	; 28
    6666:	0e 94 a2 05 	call	0xb44	; 0xb44 <buffer_remove_token>
    666a:	6c 01       	movw	r12, r24
		xSemaphoreGive(xUartMutex);
    666c:	60 e0       	ldi	r22, 0x00	; 0
    666e:	70 e0       	ldi	r23, 0x00	; 0
    6670:	80 91 87 1b 	lds	r24, 0x1B87	; 0x801b87 <xUartMutex>
    6674:	90 91 88 1b 	lds	r25, 0x1B88	; 0x801b88 <xUartMutex+0x1>
    6678:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
		if(num>0) {
    667c:	c1 14       	cp	r12, r1
    667e:	d1 04       	cpc	r13, r1
    6680:	79 f0       	breq	.+30     	; 0x66a0 <vUartSendTask+0x84>
    6682:	fe 01       	movw	r30, r28
    6684:	31 96       	adiw	r30, 0x01	; 1
    6686:	9f 01       	movw	r18, r30
    6688:	2c 0d       	add	r18, r12
    668a:	3d 1d       	adc	r19, r13
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    668c:	d8 01       	movw	r26, r16
    668e:	8c 91       	ld	r24, X
    6690:	85 ff       	sbrs	r24, 5
    6692:	fc cf       	rjmp	.-8      	; 0x668c <vUartSendTask+0x70>
				UDR2 = data[i];
    6694:	81 91       	ld	r24, Z+
    6696:	d7 01       	movw	r26, r14
    6698:	8c 93       	st	X, r24
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
    669a:	2e 17       	cp	r18, r30
    669c:	3f 07       	cpc	r19, r31
    669e:	b1 f7       	brne	.-20     	; 0x668c <vUartSendTask+0x70>
				while ( !( UCSR2A & (1<<UDRE2)) );
				UDR2 = data[i];
			}
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
    66a0:	8a e0       	ldi	r24, 0x0A	; 10
    66a2:	90 e0       	ldi	r25, 0x00	; 0
    66a4:	0e 94 a5 29 	call	0x534a	; 0x534a <vTaskDelay>
	}
    66a8:	cb cf       	rjmp	.-106    	; 0x6640 <vUartSendTask+0x24>

000066aa <vUSART_init>:
/************************************************************************/
//Initialize USART driver, note that RXD0/TXD0 (PD0/PD1) is used
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    66aa:	af 92       	push	r10
    66ac:	bf 92       	push	r11
    66ae:	cf 92       	push	r12
    66b0:	df 92       	push	r13
    66b2:	ef 92       	push	r14
    66b4:	ff 92       	push	r15
    66b6:	0f 93       	push	r16
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    66b8:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    66bc:	89 e1       	ldi	r24, 0x19	; 25
    66be:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    66c2:	80 ee       	ldi	r24, 0xE0	; 224
    66c4:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    66c8:	88 e9       	ldi	r24, 0x98	; 152
    66ca:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    66ce:	e2 ed       	ldi	r30, 0xD2	; 210
    66d0:	f0 e0       	ldi	r31, 0x00	; 0
    66d2:	86 e0       	ldi	r24, 0x06	; 6
    66d4:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    66d6:	80 81       	ld	r24, Z
    66d8:	80 83       	st	Z, r24

	uint8_t *buf = pvPortMalloc(100);
    66da:	84 e6       	ldi	r24, 0x64	; 100
    66dc:	90 e0       	ldi	r25, 0x00	; 0
    66de:	0e 94 27 08 	call	0x104e	; 0x104e <pvPortMalloc>
	buffer_init(&send_buffer, buf, 100);
    66e2:	44 e6       	ldi	r20, 0x64	; 100
    66e4:	50 e0       	ldi	r21, 0x00	; 0
    66e6:	bc 01       	movw	r22, r24
    66e8:	88 e2       	ldi	r24, 0x28	; 40
    66ea:	9c e1       	ldi	r25, 0x1C	; 28
    66ec:	0e 94 2c 05 	call	0xa58	; 0xa58 <buffer_init>
	xTaskCreate(vFrameReaderTask, "FrameReader", 300, NULL, 4, NULL);
    66f0:	a1 2c       	mov	r10, r1
    66f2:	b1 2c       	mov	r11, r1
    66f4:	c1 2c       	mov	r12, r1
    66f6:	d1 2c       	mov	r13, r1
    66f8:	e1 2c       	mov	r14, r1
    66fa:	f1 2c       	mov	r15, r1
    66fc:	04 e0       	ldi	r16, 0x04	; 4
    66fe:	20 e0       	ldi	r18, 0x00	; 0
    6700:	30 e0       	ldi	r19, 0x00	; 0
    6702:	4c e2       	ldi	r20, 0x2C	; 44
    6704:	51 e0       	ldi	r21, 0x01	; 1
    6706:	63 e5       	ldi	r22, 0x53	; 83
    6708:	77 e0       	ldi	r23, 0x07	; 7
    670a:	87 ee       	ldi	r24, 0xE7	; 231
    670c:	92 e3       	ldi	r25, 0x32	; 50
    670e:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <xTaskGenericCreate>
	xTaskCreate(vUartSendTask, "UartSendTask", 300, NULL, 4, NULL);
    6712:	20 e0       	ldi	r18, 0x00	; 0
    6714:	30 e0       	ldi	r19, 0x00	; 0
    6716:	4c e2       	ldi	r20, 0x2C	; 44
    6718:	51 e0       	ldi	r21, 0x01	; 1
    671a:	6f e5       	ldi	r22, 0x5F	; 95
    671c:	77 e0       	ldi	r23, 0x07	; 7
    671e:	8e e0       	ldi	r24, 0x0E	; 14
    6720:	93 e3       	ldi	r25, 0x33	; 51
    6722:	0e 94 e6 26 	call	0x4dcc	; 0x4dcc <xTaskGenericCreate>
	
	xUartMutex = xSemaphoreCreateMutex();
    6726:	81 e0       	ldi	r24, 0x01	; 1
    6728:	0e 94 b9 1d 	call	0x3b72	; 0x3b72 <xQueueCreateMutex>
    672c:	90 93 88 1b 	sts	0x1B88, r25	; 0x801b88 <xUartMutex+0x1>
    6730:	80 93 87 1b 	sts	0x1B87, r24	; 0x801b87 <xUartMutex>
}
    6734:	0f 91       	pop	r16
    6736:	ff 90       	pop	r15
    6738:	ef 90       	pop	r14
    673a:	df 90       	pop	r13
    673c:	cf 90       	pop	r12
    673e:	bf 90       	pop	r11
    6740:	af 90       	pop	r10
    6742:	08 95       	ret

00006744 <vUSART_send>:




void vUSART_send(uint8_t *data, uint16_t len) {
    6744:	0f 93       	push	r16
    6746:	1f 93       	push	r17
    6748:	cf 93       	push	r28
    674a:	df 93       	push	r29
    674c:	ec 01       	movw	r28, r24
    674e:	8b 01       	movw	r16, r22
	xSemaphoreTake(xUartMutex, portMAX_DELAY);
    6750:	20 e0       	ldi	r18, 0x00	; 0
    6752:	4f ef       	ldi	r20, 0xFF	; 255
    6754:	5f ef       	ldi	r21, 0xFF	; 255
    6756:	60 e0       	ldi	r22, 0x00	; 0
    6758:	70 e0       	ldi	r23, 0x00	; 0
    675a:	80 91 87 1b 	lds	r24, 0x1B87	; 0x801b87 <xUartMutex>
    675e:	90 91 88 1b 	lds	r25, 0x1B88	; 0x801b88 <xUartMutex+0x1>
    6762:	0e 94 a7 22 	call	0x454e	; 0x454e <xQueueGenericReceive>
	buffer_append(&send_buffer, data, len);
    6766:	a8 01       	movw	r20, r16
    6768:	be 01       	movw	r22, r28
    676a:	88 e2       	ldi	r24, 0x28	; 40
    676c:	9c e1       	ldi	r25, 0x1C	; 28
    676e:	0e 94 3e 05 	call	0xa7c	; 0xa7c <buffer_append>
	xSemaphoreGive(xUartMutex);
    6772:	60 e0       	ldi	r22, 0x00	; 0
    6774:	70 e0       	ldi	r23, 0x00	; 0
    6776:	80 91 87 1b 	lds	r24, 0x1B87	; 0x801b87 <xUartMutex>
    677a:	90 91 88 1b 	lds	r25, 0x1B88	; 0x801b88 <xUartMutex+0x1>
    677e:	0e 94 0b 21 	call	0x4216	; 0x4216 <xQueueGive>
}
    6782:	df 91       	pop	r29
    6784:	cf 91       	pop	r28
    6786:	1f 91       	pop	r17
    6788:	0f 91       	pop	r16
    678a:	08 95       	ret

0000678c <vUSART_set_receive_callback>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint8_t)) {
	receive_callback = cb;
    678c:	90 93 c3 1b 	sts	0x1BC3, r25	; 0x801bc3 <receive_callback+0x1>
    6790:	80 93 c2 1b 	sts	0x1BC2, r24	; 0x801bc2 <receive_callback>
    6794:	08 95       	ret

00006796 <__vector_51>:
		vTaskDelay(10*portTICK_PERIOD_MS);
	}
}


ISR(USART2_RX_vect){
    6796:	1f 92       	push	r1
    6798:	0f 92       	push	r0
    679a:	0f b6       	in	r0, 0x3f	; 63
    679c:	0f 92       	push	r0
    679e:	11 24       	eor	r1, r1
    67a0:	0b b6       	in	r0, 0x3b	; 59
    67a2:	0f 92       	push	r0
    67a4:	cf 92       	push	r12
    67a6:	df 92       	push	r13
    67a8:	ef 92       	push	r14
    67aa:	ff 92       	push	r15
    67ac:	0f 93       	push	r16
    67ae:	1f 93       	push	r17
    67b0:	2f 93       	push	r18
    67b2:	3f 93       	push	r19
    67b4:	4f 93       	push	r20
    67b6:	5f 93       	push	r21
    67b8:	6f 93       	push	r22
    67ba:	7f 93       	push	r23
    67bc:	8f 93       	push	r24
    67be:	9f 93       	push	r25
    67c0:	af 93       	push	r26
    67c2:	bf 93       	push	r27
    67c4:	cf 93       	push	r28
    67c6:	df 93       	push	r29
    67c8:	ef 93       	push	r30
    67ca:	ff 93       	push	r31
	static uint8_t input_buffer[100];
	static uint16_t input_index = 0;
	input_buffer[input_index++] = UDR2;
    67cc:	80 91 5f 1b 	lds	r24, 0x1B5F	; 0x801b5f <input_index.2398>
    67d0:	90 91 60 1b 	lds	r25, 0x1B60	; 0x801b60 <input_index.2398+0x1>
    67d4:	ec 01       	movw	r28, r24
    67d6:	21 96       	adiw	r28, 0x01	; 1
    67d8:	d0 93 60 1b 	sts	0x1B60, r29	; 0x801b60 <input_index.2398+0x1>
    67dc:	c0 93 5f 1b 	sts	0x1B5F, r28	; 0x801b5f <input_index.2398>
    67e0:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    67e4:	fc 01       	movw	r30, r24
    67e6:	e5 50       	subi	r30, 0x05	; 5
    67e8:	f5 4e       	sbci	r31, 0xE5	; 229
    67ea:	20 83       	st	Z, r18
	if(input_buffer[input_index-1] == 0x00) {
    67ec:	21 11       	cpse	r18, r1
    67ee:	1d c0       	rjmp	.+58     	; 0x682a <__vector_51+0x94>
		if(frame_receiver != NULL) {
    67f0:	c0 90 61 1b 	lds	r12, 0x1B61	; 0x801b61 <frame_receiver>
    67f4:	d0 90 62 1b 	lds	r13, 0x1B62	; 0x801b62 <frame_receiver+0x1>
    67f8:	c1 14       	cp	r12, r1
    67fa:	d1 04       	cpc	r13, r1
    67fc:	89 f0       	breq	.+34     	; 0x6820 <__vector_51+0x8a>
			memcpy(receive_buffer, input_buffer, input_index);
    67fe:	ae 01       	movw	r20, r28
    6800:	6b ef       	ldi	r22, 0xFB	; 251
    6802:	7a e1       	ldi	r23, 0x1A	; 26
    6804:	84 ec       	ldi	r24, 0xC4	; 196
    6806:	9b e1       	ldi	r25, 0x1B	; 27
    6808:	0e 94 2f 3c 	call	0x785e	; 0x785e <memcpy>
			xTaskNotifyFromISR(frame_receiver, input_index, eSetValueWithoutOverwrite, NULL);
    680c:	ae 01       	movw	r20, r28
    680e:	60 e0       	ldi	r22, 0x00	; 0
    6810:	70 e0       	ldi	r23, 0x00	; 0
    6812:	e1 2c       	mov	r14, r1
    6814:	f1 2c       	mov	r15, r1
    6816:	00 e0       	ldi	r16, 0x00	; 0
    6818:	10 e0       	ldi	r17, 0x00	; 0
    681a:	24 e0       	ldi	r18, 0x04	; 4
    681c:	c6 01       	movw	r24, r12
    681e:	35 de       	rcall	.-918    	; 0x648a <xTaskGenericNotifyFromISR>
		}
		input_index = 0;
    6820:	10 92 60 1b 	sts	0x1B60, r1	; 0x801b60 <input_index.2398+0x1>
    6824:	10 92 5f 1b 	sts	0x1B5F, r1	; 0x801b5f <input_index.2398>
    6828:	07 c0       	rjmp	.+14     	; 0x6838 <__vector_51+0xa2>
	}
	if(input_index > 100) input_index = 0; // Something went wrong, received too many bytes
    682a:	c5 36       	cpi	r28, 0x65	; 101
    682c:	d1 05       	cpc	r29, r1
    682e:	20 f0       	brcs	.+8      	; 0x6838 <__vector_51+0xa2>
    6830:	10 92 60 1b 	sts	0x1B60, r1	; 0x801b60 <input_index.2398+0x1>
    6834:	10 92 5f 1b 	sts	0x1B5F, r1	; 0x801b5f <input_index.2398>
    6838:	ff 91       	pop	r31
    683a:	ef 91       	pop	r30
    683c:	df 91       	pop	r29
    683e:	cf 91       	pop	r28
    6840:	bf 91       	pop	r27
    6842:	af 91       	pop	r26
    6844:	9f 91       	pop	r25
    6846:	8f 91       	pop	r24
    6848:	7f 91       	pop	r23
    684a:	6f 91       	pop	r22
    684c:	5f 91       	pop	r21
    684e:	4f 91       	pop	r20
    6850:	3f 91       	pop	r19
    6852:	2f 91       	pop	r18
    6854:	1f 91       	pop	r17
    6856:	0f 91       	pop	r16
    6858:	ff 90       	pop	r15
    685a:	ef 90       	pop	r14
    685c:	df 90       	pop	r13
    685e:	cf 90       	pop	r12
    6860:	0f 90       	pop	r0
    6862:	0b be       	out	0x3b, r0	; 59
    6864:	0f 90       	pop	r0
    6866:	0f be       	out	0x3f, r0	; 63
    6868:	0f 90       	pop	r0
    686a:	1f 90       	pop	r1
    686c:	18 95       	reti

0000686e <__subsf3>:
    686e:	50 58       	subi	r21, 0x80	; 128

00006870 <__addsf3>:
    6870:	bb 27       	eor	r27, r27
    6872:	aa 27       	eor	r26, r26
    6874:	0e d0       	rcall	.+28     	; 0x6892 <__addsf3x>
    6876:	27 c2       	rjmp	.+1102   	; 0x6cc6 <__fp_round>
    6878:	f0 d1       	rcall	.+992    	; 0x6c5a <__fp_pscA>
    687a:	30 f0       	brcs	.+12     	; 0x6888 <__addsf3+0x18>
    687c:	f5 d1       	rcall	.+1002   	; 0x6c68 <__fp_pscB>
    687e:	20 f0       	brcs	.+8      	; 0x6888 <__addsf3+0x18>
    6880:	31 f4       	brne	.+12     	; 0x688e <__addsf3+0x1e>
    6882:	9f 3f       	cpi	r25, 0xFF	; 255
    6884:	11 f4       	brne	.+4      	; 0x688a <__addsf3+0x1a>
    6886:	1e f4       	brtc	.+6      	; 0x688e <__addsf3+0x1e>
    6888:	c0 c1       	rjmp	.+896    	; 0x6c0a <__fp_nan>
    688a:	0e f4       	brtc	.+2      	; 0x688e <__addsf3+0x1e>
    688c:	e0 95       	com	r30
    688e:	e7 fb       	bst	r30, 7
    6890:	b6 c1       	rjmp	.+876    	; 0x6bfe <__fp_inf>

00006892 <__addsf3x>:
    6892:	e9 2f       	mov	r30, r25
    6894:	3a d2       	rcall	.+1140   	; 0x6d0a <__fp_split3>
    6896:	80 f3       	brcs	.-32     	; 0x6878 <__addsf3+0x8>
    6898:	ba 17       	cp	r27, r26
    689a:	62 07       	cpc	r22, r18
    689c:	73 07       	cpc	r23, r19
    689e:	84 07       	cpc	r24, r20
    68a0:	95 07       	cpc	r25, r21
    68a2:	18 f0       	brcs	.+6      	; 0x68aa <__addsf3x+0x18>
    68a4:	71 f4       	brne	.+28     	; 0x68c2 <__addsf3x+0x30>
    68a6:	9e f5       	brtc	.+102    	; 0x690e <__addsf3x+0x7c>
    68a8:	52 c2       	rjmp	.+1188   	; 0x6d4e <__fp_zero>
    68aa:	0e f4       	brtc	.+2      	; 0x68ae <__addsf3x+0x1c>
    68ac:	e0 95       	com	r30
    68ae:	0b 2e       	mov	r0, r27
    68b0:	ba 2f       	mov	r27, r26
    68b2:	a0 2d       	mov	r26, r0
    68b4:	0b 01       	movw	r0, r22
    68b6:	b9 01       	movw	r22, r18
    68b8:	90 01       	movw	r18, r0
    68ba:	0c 01       	movw	r0, r24
    68bc:	ca 01       	movw	r24, r20
    68be:	a0 01       	movw	r20, r0
    68c0:	11 24       	eor	r1, r1
    68c2:	ff 27       	eor	r31, r31
    68c4:	59 1b       	sub	r21, r25
    68c6:	99 f0       	breq	.+38     	; 0x68ee <__addsf3x+0x5c>
    68c8:	59 3f       	cpi	r21, 0xF9	; 249
    68ca:	50 f4       	brcc	.+20     	; 0x68e0 <__addsf3x+0x4e>
    68cc:	50 3e       	cpi	r21, 0xE0	; 224
    68ce:	68 f1       	brcs	.+90     	; 0x692a <__addsf3x+0x98>
    68d0:	1a 16       	cp	r1, r26
    68d2:	f0 40       	sbci	r31, 0x00	; 0
    68d4:	a2 2f       	mov	r26, r18
    68d6:	23 2f       	mov	r18, r19
    68d8:	34 2f       	mov	r19, r20
    68da:	44 27       	eor	r20, r20
    68dc:	58 5f       	subi	r21, 0xF8	; 248
    68de:	f3 cf       	rjmp	.-26     	; 0x68c6 <__addsf3x+0x34>
    68e0:	46 95       	lsr	r20
    68e2:	37 95       	ror	r19
    68e4:	27 95       	ror	r18
    68e6:	a7 95       	ror	r26
    68e8:	f0 40       	sbci	r31, 0x00	; 0
    68ea:	53 95       	inc	r21
    68ec:	c9 f7       	brne	.-14     	; 0x68e0 <__addsf3x+0x4e>
    68ee:	7e f4       	brtc	.+30     	; 0x690e <__addsf3x+0x7c>
    68f0:	1f 16       	cp	r1, r31
    68f2:	ba 0b       	sbc	r27, r26
    68f4:	62 0b       	sbc	r22, r18
    68f6:	73 0b       	sbc	r23, r19
    68f8:	84 0b       	sbc	r24, r20
    68fa:	ba f0       	brmi	.+46     	; 0x692a <__addsf3x+0x98>
    68fc:	91 50       	subi	r25, 0x01	; 1
    68fe:	a1 f0       	breq	.+40     	; 0x6928 <__addsf3x+0x96>
    6900:	ff 0f       	add	r31, r31
    6902:	bb 1f       	adc	r27, r27
    6904:	66 1f       	adc	r22, r22
    6906:	77 1f       	adc	r23, r23
    6908:	88 1f       	adc	r24, r24
    690a:	c2 f7       	brpl	.-16     	; 0x68fc <__addsf3x+0x6a>
    690c:	0e c0       	rjmp	.+28     	; 0x692a <__addsf3x+0x98>
    690e:	ba 0f       	add	r27, r26
    6910:	62 1f       	adc	r22, r18
    6912:	73 1f       	adc	r23, r19
    6914:	84 1f       	adc	r24, r20
    6916:	48 f4       	brcc	.+18     	; 0x692a <__addsf3x+0x98>
    6918:	87 95       	ror	r24
    691a:	77 95       	ror	r23
    691c:	67 95       	ror	r22
    691e:	b7 95       	ror	r27
    6920:	f7 95       	ror	r31
    6922:	9e 3f       	cpi	r25, 0xFE	; 254
    6924:	08 f0       	brcs	.+2      	; 0x6928 <__addsf3x+0x96>
    6926:	b3 cf       	rjmp	.-154    	; 0x688e <__addsf3+0x1e>
    6928:	93 95       	inc	r25
    692a:	88 0f       	add	r24, r24
    692c:	08 f0       	brcs	.+2      	; 0x6930 <__addsf3x+0x9e>
    692e:	99 27       	eor	r25, r25
    6930:	ee 0f       	add	r30, r30
    6932:	97 95       	ror	r25
    6934:	87 95       	ror	r24
    6936:	08 95       	ret
    6938:	90 d1       	rcall	.+800    	; 0x6c5a <__fp_pscA>
    693a:	58 f0       	brcs	.+22     	; 0x6952 <__addsf3x+0xc0>
    693c:	80 e8       	ldi	r24, 0x80	; 128
    693e:	91 e0       	ldi	r25, 0x01	; 1
    6940:	09 f4       	brne	.+2      	; 0x6944 <__addsf3x+0xb2>
    6942:	9e ef       	ldi	r25, 0xFE	; 254
    6944:	91 d1       	rcall	.+802    	; 0x6c68 <__fp_pscB>
    6946:	28 f0       	brcs	.+10     	; 0x6952 <__addsf3x+0xc0>
    6948:	40 e8       	ldi	r20, 0x80	; 128
    694a:	51 e0       	ldi	r21, 0x01	; 1
    694c:	59 f4       	brne	.+22     	; 0x6964 <atan2+0xe>
    694e:	5e ef       	ldi	r21, 0xFE	; 254
    6950:	09 c0       	rjmp	.+18     	; 0x6964 <atan2+0xe>
    6952:	5b c1       	rjmp	.+694    	; 0x6c0a <__fp_nan>
    6954:	fc c1       	rjmp	.+1016   	; 0x6d4e <__fp_zero>

00006956 <atan2>:
    6956:	e9 2f       	mov	r30, r25
    6958:	e0 78       	andi	r30, 0x80	; 128
    695a:	d7 d1       	rcall	.+942    	; 0x6d0a <__fp_split3>
    695c:	68 f3       	brcs	.-38     	; 0x6938 <__addsf3x+0xa6>
    695e:	09 2e       	mov	r0, r25
    6960:	05 2a       	or	r0, r21
    6962:	c1 f3       	breq	.-16     	; 0x6954 <__addsf3x+0xc2>
    6964:	26 17       	cp	r18, r22
    6966:	37 07       	cpc	r19, r23
    6968:	48 07       	cpc	r20, r24
    696a:	59 07       	cpc	r21, r25
    696c:	38 f0       	brcs	.+14     	; 0x697c <atan2+0x26>
    696e:	0e 2e       	mov	r0, r30
    6970:	07 f8       	bld	r0, 7
    6972:	e0 25       	eor	r30, r0
    6974:	69 f0       	breq	.+26     	; 0x6990 <atan2+0x3a>
    6976:	e0 25       	eor	r30, r0
    6978:	e0 64       	ori	r30, 0x40	; 64
    697a:	0a c0       	rjmp	.+20     	; 0x6990 <atan2+0x3a>
    697c:	ef 63       	ori	r30, 0x3F	; 63
    697e:	07 f8       	bld	r0, 7
    6980:	00 94       	com	r0
    6982:	07 fa       	bst	r0, 7
    6984:	db 01       	movw	r26, r22
    6986:	b9 01       	movw	r22, r18
    6988:	9d 01       	movw	r18, r26
    698a:	dc 01       	movw	r26, r24
    698c:	ca 01       	movw	r24, r20
    698e:	ad 01       	movw	r20, r26
    6990:	ef 93       	push	r30
    6992:	4a d0       	rcall	.+148    	; 0x6a28 <__divsf3_pse>
    6994:	98 d1       	rcall	.+816    	; 0x6cc6 <__fp_round>
    6996:	0a d0       	rcall	.+20     	; 0x69ac <atan>
    6998:	5f 91       	pop	r21
    699a:	55 23       	and	r21, r21
    699c:	31 f0       	breq	.+12     	; 0x69aa <atan2+0x54>
    699e:	2b ed       	ldi	r18, 0xDB	; 219
    69a0:	3f e0       	ldi	r19, 0x0F	; 15
    69a2:	49 e4       	ldi	r20, 0x49	; 73
    69a4:	50 fd       	sbrc	r21, 0
    69a6:	49 ec       	ldi	r20, 0xC9	; 201
    69a8:	63 cf       	rjmp	.-314    	; 0x6870 <__addsf3>
    69aa:	08 95       	ret

000069ac <atan>:
    69ac:	df 93       	push	r29
    69ae:	dd 27       	eor	r29, r29
    69b0:	b9 2f       	mov	r27, r25
    69b2:	bf 77       	andi	r27, 0x7F	; 127
    69b4:	40 e8       	ldi	r20, 0x80	; 128
    69b6:	5f e3       	ldi	r21, 0x3F	; 63
    69b8:	16 16       	cp	r1, r22
    69ba:	17 06       	cpc	r1, r23
    69bc:	48 07       	cpc	r20, r24
    69be:	5b 07       	cpc	r21, r27
    69c0:	10 f4       	brcc	.+4      	; 0x69c6 <atan+0x1a>
    69c2:	d9 2f       	mov	r29, r25
    69c4:	cf d1       	rcall	.+926    	; 0x6d64 <inverse>
    69c6:	9f 93       	push	r25
    69c8:	8f 93       	push	r24
    69ca:	7f 93       	push	r23
    69cc:	6f 93       	push	r22
    69ce:	7c d2       	rcall	.+1272   	; 0x6ec8 <square>
    69d0:	e4 ee       	ldi	r30, 0xE4	; 228
    69d2:	f0 e0       	ldi	r31, 0x00	; 0
    69d4:	1d d1       	rcall	.+570    	; 0x6c10 <__fp_powser>
    69d6:	77 d1       	rcall	.+750    	; 0x6cc6 <__fp_round>
    69d8:	2f 91       	pop	r18
    69da:	3f 91       	pop	r19
    69dc:	4f 91       	pop	r20
    69de:	5f 91       	pop	r21
    69e0:	d4 d1       	rcall	.+936    	; 0x6d8a <__mulsf3x>
    69e2:	dd 23       	and	r29, r29
    69e4:	49 f0       	breq	.+18     	; 0x69f8 <atan+0x4c>
    69e6:	90 58       	subi	r25, 0x80	; 128
    69e8:	a2 ea       	ldi	r26, 0xA2	; 162
    69ea:	2a ed       	ldi	r18, 0xDA	; 218
    69ec:	3f e0       	ldi	r19, 0x0F	; 15
    69ee:	49 ec       	ldi	r20, 0xC9	; 201
    69f0:	5f e3       	ldi	r21, 0x3F	; 63
    69f2:	d0 78       	andi	r29, 0x80	; 128
    69f4:	5d 27       	eor	r21, r29
    69f6:	4d df       	rcall	.-358    	; 0x6892 <__addsf3x>
    69f8:	df 91       	pop	r29
    69fa:	65 c1       	rjmp	.+714    	; 0x6cc6 <__fp_round>

000069fc <__cmpsf2>:
    69fc:	dc d0       	rcall	.+440    	; 0x6bb6 <__fp_cmp>
    69fe:	08 f4       	brcc	.+2      	; 0x6a02 <__cmpsf2+0x6>
    6a00:	81 e0       	ldi	r24, 0x01	; 1
    6a02:	08 95       	ret

00006a04 <cos>:
    6a04:	39 d1       	rcall	.+626    	; 0x6c78 <__fp_rempio2>
    6a06:	e3 95       	inc	r30
    6a08:	6f c1       	rjmp	.+734    	; 0x6ce8 <__fp_sinus>

00006a0a <__divsf3>:
    6a0a:	0c d0       	rcall	.+24     	; 0x6a24 <__divsf3x>
    6a0c:	5c c1       	rjmp	.+696    	; 0x6cc6 <__fp_round>
    6a0e:	2c d1       	rcall	.+600    	; 0x6c68 <__fp_pscB>
    6a10:	40 f0       	brcs	.+16     	; 0x6a22 <__divsf3+0x18>
    6a12:	23 d1       	rcall	.+582    	; 0x6c5a <__fp_pscA>
    6a14:	30 f0       	brcs	.+12     	; 0x6a22 <__divsf3+0x18>
    6a16:	21 f4       	brne	.+8      	; 0x6a20 <__divsf3+0x16>
    6a18:	5f 3f       	cpi	r21, 0xFF	; 255
    6a1a:	19 f0       	breq	.+6      	; 0x6a22 <__divsf3+0x18>
    6a1c:	f0 c0       	rjmp	.+480    	; 0x6bfe <__fp_inf>
    6a1e:	51 11       	cpse	r21, r1
    6a20:	97 c1       	rjmp	.+814    	; 0x6d50 <__fp_szero>
    6a22:	f3 c0       	rjmp	.+486    	; 0x6c0a <__fp_nan>

00006a24 <__divsf3x>:
    6a24:	72 d1       	rcall	.+740    	; 0x6d0a <__fp_split3>
    6a26:	98 f3       	brcs	.-26     	; 0x6a0e <__divsf3+0x4>

00006a28 <__divsf3_pse>:
    6a28:	99 23       	and	r25, r25
    6a2a:	c9 f3       	breq	.-14     	; 0x6a1e <__divsf3+0x14>
    6a2c:	55 23       	and	r21, r21
    6a2e:	b1 f3       	breq	.-20     	; 0x6a1c <__divsf3+0x12>
    6a30:	95 1b       	sub	r25, r21
    6a32:	55 0b       	sbc	r21, r21
    6a34:	bb 27       	eor	r27, r27
    6a36:	aa 27       	eor	r26, r26
    6a38:	62 17       	cp	r22, r18
    6a3a:	73 07       	cpc	r23, r19
    6a3c:	84 07       	cpc	r24, r20
    6a3e:	38 f0       	brcs	.+14     	; 0x6a4e <__divsf3_pse+0x26>
    6a40:	9f 5f       	subi	r25, 0xFF	; 255
    6a42:	5f 4f       	sbci	r21, 0xFF	; 255
    6a44:	22 0f       	add	r18, r18
    6a46:	33 1f       	adc	r19, r19
    6a48:	44 1f       	adc	r20, r20
    6a4a:	aa 1f       	adc	r26, r26
    6a4c:	a9 f3       	breq	.-22     	; 0x6a38 <__divsf3_pse+0x10>
    6a4e:	33 d0       	rcall	.+102    	; 0x6ab6 <__divsf3_pse+0x8e>
    6a50:	0e 2e       	mov	r0, r30
    6a52:	3a f0       	brmi	.+14     	; 0x6a62 <__divsf3_pse+0x3a>
    6a54:	e0 e8       	ldi	r30, 0x80	; 128
    6a56:	30 d0       	rcall	.+96     	; 0x6ab8 <__divsf3_pse+0x90>
    6a58:	91 50       	subi	r25, 0x01	; 1
    6a5a:	50 40       	sbci	r21, 0x00	; 0
    6a5c:	e6 95       	lsr	r30
    6a5e:	00 1c       	adc	r0, r0
    6a60:	ca f7       	brpl	.-14     	; 0x6a54 <__divsf3_pse+0x2c>
    6a62:	29 d0       	rcall	.+82     	; 0x6ab6 <__divsf3_pse+0x8e>
    6a64:	fe 2f       	mov	r31, r30
    6a66:	27 d0       	rcall	.+78     	; 0x6ab6 <__divsf3_pse+0x8e>
    6a68:	66 0f       	add	r22, r22
    6a6a:	77 1f       	adc	r23, r23
    6a6c:	88 1f       	adc	r24, r24
    6a6e:	bb 1f       	adc	r27, r27
    6a70:	26 17       	cp	r18, r22
    6a72:	37 07       	cpc	r19, r23
    6a74:	48 07       	cpc	r20, r24
    6a76:	ab 07       	cpc	r26, r27
    6a78:	b0 e8       	ldi	r27, 0x80	; 128
    6a7a:	09 f0       	breq	.+2      	; 0x6a7e <__divsf3_pse+0x56>
    6a7c:	bb 0b       	sbc	r27, r27
    6a7e:	80 2d       	mov	r24, r0
    6a80:	bf 01       	movw	r22, r30
    6a82:	ff 27       	eor	r31, r31
    6a84:	93 58       	subi	r25, 0x83	; 131
    6a86:	5f 4f       	sbci	r21, 0xFF	; 255
    6a88:	2a f0       	brmi	.+10     	; 0x6a94 <__divsf3_pse+0x6c>
    6a8a:	9e 3f       	cpi	r25, 0xFE	; 254
    6a8c:	51 05       	cpc	r21, r1
    6a8e:	68 f0       	brcs	.+26     	; 0x6aaa <__divsf3_pse+0x82>
    6a90:	b6 c0       	rjmp	.+364    	; 0x6bfe <__fp_inf>
    6a92:	5e c1       	rjmp	.+700    	; 0x6d50 <__fp_szero>
    6a94:	5f 3f       	cpi	r21, 0xFF	; 255
    6a96:	ec f3       	brlt	.-6      	; 0x6a92 <__divsf3_pse+0x6a>
    6a98:	98 3e       	cpi	r25, 0xE8	; 232
    6a9a:	dc f3       	brlt	.-10     	; 0x6a92 <__divsf3_pse+0x6a>
    6a9c:	86 95       	lsr	r24
    6a9e:	77 95       	ror	r23
    6aa0:	67 95       	ror	r22
    6aa2:	b7 95       	ror	r27
    6aa4:	f7 95       	ror	r31
    6aa6:	9f 5f       	subi	r25, 0xFF	; 255
    6aa8:	c9 f7       	brne	.-14     	; 0x6a9c <__divsf3_pse+0x74>
    6aaa:	88 0f       	add	r24, r24
    6aac:	91 1d       	adc	r25, r1
    6aae:	96 95       	lsr	r25
    6ab0:	87 95       	ror	r24
    6ab2:	97 f9       	bld	r25, 7
    6ab4:	08 95       	ret
    6ab6:	e1 e0       	ldi	r30, 0x01	; 1
    6ab8:	66 0f       	add	r22, r22
    6aba:	77 1f       	adc	r23, r23
    6abc:	88 1f       	adc	r24, r24
    6abe:	bb 1f       	adc	r27, r27
    6ac0:	62 17       	cp	r22, r18
    6ac2:	73 07       	cpc	r23, r19
    6ac4:	84 07       	cpc	r24, r20
    6ac6:	ba 07       	cpc	r27, r26
    6ac8:	20 f0       	brcs	.+8      	; 0x6ad2 <__divsf3_pse+0xaa>
    6aca:	62 1b       	sub	r22, r18
    6acc:	73 0b       	sbc	r23, r19
    6ace:	84 0b       	sbc	r24, r20
    6ad0:	ba 0b       	sbc	r27, r26
    6ad2:	ee 1f       	adc	r30, r30
    6ad4:	88 f7       	brcc	.-30     	; 0x6ab8 <__divsf3_pse+0x90>
    6ad6:	e0 95       	com	r30
    6ad8:	08 95       	ret

00006ada <__fixsfsi>:
    6ada:	04 d0       	rcall	.+8      	; 0x6ae4 <__fixunssfsi>
    6adc:	68 94       	set
    6ade:	b1 11       	cpse	r27, r1
    6ae0:	37 c1       	rjmp	.+622    	; 0x6d50 <__fp_szero>
    6ae2:	08 95       	ret

00006ae4 <__fixunssfsi>:
    6ae4:	1a d1       	rcall	.+564    	; 0x6d1a <__fp_splitA>
    6ae6:	88 f0       	brcs	.+34     	; 0x6b0a <__fixunssfsi+0x26>
    6ae8:	9f 57       	subi	r25, 0x7F	; 127
    6aea:	90 f0       	brcs	.+36     	; 0x6b10 <__fixunssfsi+0x2c>
    6aec:	b9 2f       	mov	r27, r25
    6aee:	99 27       	eor	r25, r25
    6af0:	b7 51       	subi	r27, 0x17	; 23
    6af2:	a0 f0       	brcs	.+40     	; 0x6b1c <__fixunssfsi+0x38>
    6af4:	d1 f0       	breq	.+52     	; 0x6b2a <__fixunssfsi+0x46>
    6af6:	66 0f       	add	r22, r22
    6af8:	77 1f       	adc	r23, r23
    6afa:	88 1f       	adc	r24, r24
    6afc:	99 1f       	adc	r25, r25
    6afe:	1a f0       	brmi	.+6      	; 0x6b06 <__fixunssfsi+0x22>
    6b00:	ba 95       	dec	r27
    6b02:	c9 f7       	brne	.-14     	; 0x6af6 <__fixunssfsi+0x12>
    6b04:	12 c0       	rjmp	.+36     	; 0x6b2a <__fixunssfsi+0x46>
    6b06:	b1 30       	cpi	r27, 0x01	; 1
    6b08:	81 f0       	breq	.+32     	; 0x6b2a <__fixunssfsi+0x46>
    6b0a:	21 d1       	rcall	.+578    	; 0x6d4e <__fp_zero>
    6b0c:	b1 e0       	ldi	r27, 0x01	; 1
    6b0e:	08 95       	ret
    6b10:	1e c1       	rjmp	.+572    	; 0x6d4e <__fp_zero>
    6b12:	67 2f       	mov	r22, r23
    6b14:	78 2f       	mov	r23, r24
    6b16:	88 27       	eor	r24, r24
    6b18:	b8 5f       	subi	r27, 0xF8	; 248
    6b1a:	39 f0       	breq	.+14     	; 0x6b2a <__fixunssfsi+0x46>
    6b1c:	b9 3f       	cpi	r27, 0xF9	; 249
    6b1e:	cc f3       	brlt	.-14     	; 0x6b12 <__fixunssfsi+0x2e>
    6b20:	86 95       	lsr	r24
    6b22:	77 95       	ror	r23
    6b24:	67 95       	ror	r22
    6b26:	b3 95       	inc	r27
    6b28:	d9 f7       	brne	.-10     	; 0x6b20 <__fixunssfsi+0x3c>
    6b2a:	3e f4       	brtc	.+14     	; 0x6b3a <__fixunssfsi+0x56>
    6b2c:	90 95       	com	r25
    6b2e:	80 95       	com	r24
    6b30:	70 95       	com	r23
    6b32:	61 95       	neg	r22
    6b34:	7f 4f       	sbci	r23, 0xFF	; 255
    6b36:	8f 4f       	sbci	r24, 0xFF	; 255
    6b38:	9f 4f       	sbci	r25, 0xFF	; 255
    6b3a:	08 95       	ret

00006b3c <__floatunsisf>:
    6b3c:	e8 94       	clt
    6b3e:	09 c0       	rjmp	.+18     	; 0x6b52 <__floatsisf+0x12>

00006b40 <__floatsisf>:
    6b40:	97 fb       	bst	r25, 7
    6b42:	3e f4       	brtc	.+14     	; 0x6b52 <__floatsisf+0x12>
    6b44:	90 95       	com	r25
    6b46:	80 95       	com	r24
    6b48:	70 95       	com	r23
    6b4a:	61 95       	neg	r22
    6b4c:	7f 4f       	sbci	r23, 0xFF	; 255
    6b4e:	8f 4f       	sbci	r24, 0xFF	; 255
    6b50:	9f 4f       	sbci	r25, 0xFF	; 255
    6b52:	99 23       	and	r25, r25
    6b54:	a9 f0       	breq	.+42     	; 0x6b80 <__floatsisf+0x40>
    6b56:	f9 2f       	mov	r31, r25
    6b58:	96 e9       	ldi	r25, 0x96	; 150
    6b5a:	bb 27       	eor	r27, r27
    6b5c:	93 95       	inc	r25
    6b5e:	f6 95       	lsr	r31
    6b60:	87 95       	ror	r24
    6b62:	77 95       	ror	r23
    6b64:	67 95       	ror	r22
    6b66:	b7 95       	ror	r27
    6b68:	f1 11       	cpse	r31, r1
    6b6a:	f8 cf       	rjmp	.-16     	; 0x6b5c <__floatsisf+0x1c>
    6b6c:	fa f4       	brpl	.+62     	; 0x6bac <__floatsisf+0x6c>
    6b6e:	bb 0f       	add	r27, r27
    6b70:	11 f4       	brne	.+4      	; 0x6b76 <__floatsisf+0x36>
    6b72:	60 ff       	sbrs	r22, 0
    6b74:	1b c0       	rjmp	.+54     	; 0x6bac <__floatsisf+0x6c>
    6b76:	6f 5f       	subi	r22, 0xFF	; 255
    6b78:	7f 4f       	sbci	r23, 0xFF	; 255
    6b7a:	8f 4f       	sbci	r24, 0xFF	; 255
    6b7c:	9f 4f       	sbci	r25, 0xFF	; 255
    6b7e:	16 c0       	rjmp	.+44     	; 0x6bac <__floatsisf+0x6c>
    6b80:	88 23       	and	r24, r24
    6b82:	11 f0       	breq	.+4      	; 0x6b88 <__floatsisf+0x48>
    6b84:	96 e9       	ldi	r25, 0x96	; 150
    6b86:	11 c0       	rjmp	.+34     	; 0x6baa <__floatsisf+0x6a>
    6b88:	77 23       	and	r23, r23
    6b8a:	21 f0       	breq	.+8      	; 0x6b94 <__floatsisf+0x54>
    6b8c:	9e e8       	ldi	r25, 0x8E	; 142
    6b8e:	87 2f       	mov	r24, r23
    6b90:	76 2f       	mov	r23, r22
    6b92:	05 c0       	rjmp	.+10     	; 0x6b9e <__floatsisf+0x5e>
    6b94:	66 23       	and	r22, r22
    6b96:	71 f0       	breq	.+28     	; 0x6bb4 <__floatsisf+0x74>
    6b98:	96 e8       	ldi	r25, 0x86	; 134
    6b9a:	86 2f       	mov	r24, r22
    6b9c:	70 e0       	ldi	r23, 0x00	; 0
    6b9e:	60 e0       	ldi	r22, 0x00	; 0
    6ba0:	2a f0       	brmi	.+10     	; 0x6bac <__floatsisf+0x6c>
    6ba2:	9a 95       	dec	r25
    6ba4:	66 0f       	add	r22, r22
    6ba6:	77 1f       	adc	r23, r23
    6ba8:	88 1f       	adc	r24, r24
    6baa:	da f7       	brpl	.-10     	; 0x6ba2 <__floatsisf+0x62>
    6bac:	88 0f       	add	r24, r24
    6bae:	96 95       	lsr	r25
    6bb0:	87 95       	ror	r24
    6bb2:	97 f9       	bld	r25, 7
    6bb4:	08 95       	ret

00006bb6 <__fp_cmp>:
    6bb6:	99 0f       	add	r25, r25
    6bb8:	00 08       	sbc	r0, r0
    6bba:	55 0f       	add	r21, r21
    6bbc:	aa 0b       	sbc	r26, r26
    6bbe:	e0 e8       	ldi	r30, 0x80	; 128
    6bc0:	fe ef       	ldi	r31, 0xFE	; 254
    6bc2:	16 16       	cp	r1, r22
    6bc4:	17 06       	cpc	r1, r23
    6bc6:	e8 07       	cpc	r30, r24
    6bc8:	f9 07       	cpc	r31, r25
    6bca:	c0 f0       	brcs	.+48     	; 0x6bfc <__fp_cmp+0x46>
    6bcc:	12 16       	cp	r1, r18
    6bce:	13 06       	cpc	r1, r19
    6bd0:	e4 07       	cpc	r30, r20
    6bd2:	f5 07       	cpc	r31, r21
    6bd4:	98 f0       	brcs	.+38     	; 0x6bfc <__fp_cmp+0x46>
    6bd6:	62 1b       	sub	r22, r18
    6bd8:	73 0b       	sbc	r23, r19
    6bda:	84 0b       	sbc	r24, r20
    6bdc:	95 0b       	sbc	r25, r21
    6bde:	39 f4       	brne	.+14     	; 0x6bee <__fp_cmp+0x38>
    6be0:	0a 26       	eor	r0, r26
    6be2:	61 f0       	breq	.+24     	; 0x6bfc <__fp_cmp+0x46>
    6be4:	23 2b       	or	r18, r19
    6be6:	24 2b       	or	r18, r20
    6be8:	25 2b       	or	r18, r21
    6bea:	21 f4       	brne	.+8      	; 0x6bf4 <__fp_cmp+0x3e>
    6bec:	08 95       	ret
    6bee:	0a 26       	eor	r0, r26
    6bf0:	09 f4       	brne	.+2      	; 0x6bf4 <__fp_cmp+0x3e>
    6bf2:	a1 40       	sbci	r26, 0x01	; 1
    6bf4:	a6 95       	lsr	r26
    6bf6:	8f ef       	ldi	r24, 0xFF	; 255
    6bf8:	81 1d       	adc	r24, r1
    6bfa:	81 1d       	adc	r24, r1
    6bfc:	08 95       	ret

00006bfe <__fp_inf>:
    6bfe:	97 f9       	bld	r25, 7
    6c00:	9f 67       	ori	r25, 0x7F	; 127
    6c02:	80 e8       	ldi	r24, 0x80	; 128
    6c04:	70 e0       	ldi	r23, 0x00	; 0
    6c06:	60 e0       	ldi	r22, 0x00	; 0
    6c08:	08 95       	ret

00006c0a <__fp_nan>:
    6c0a:	9f ef       	ldi	r25, 0xFF	; 255
    6c0c:	80 ec       	ldi	r24, 0xC0	; 192
    6c0e:	08 95       	ret

00006c10 <__fp_powser>:
    6c10:	df 93       	push	r29
    6c12:	cf 93       	push	r28
    6c14:	1f 93       	push	r17
    6c16:	0f 93       	push	r16
    6c18:	ff 92       	push	r15
    6c1a:	ef 92       	push	r14
    6c1c:	df 92       	push	r13
    6c1e:	7b 01       	movw	r14, r22
    6c20:	8c 01       	movw	r16, r24
    6c22:	68 94       	set
    6c24:	05 c0       	rjmp	.+10     	; 0x6c30 <__fp_powser+0x20>
    6c26:	da 2e       	mov	r13, r26
    6c28:	ef 01       	movw	r28, r30
    6c2a:	af d0       	rcall	.+350    	; 0x6d8a <__mulsf3x>
    6c2c:	fe 01       	movw	r30, r28
    6c2e:	e8 94       	clt
    6c30:	a5 91       	lpm	r26, Z+
    6c32:	25 91       	lpm	r18, Z+
    6c34:	35 91       	lpm	r19, Z+
    6c36:	45 91       	lpm	r20, Z+
    6c38:	55 91       	lpm	r21, Z+
    6c3a:	ae f3       	brts	.-22     	; 0x6c26 <__fp_powser+0x16>
    6c3c:	ef 01       	movw	r28, r30
    6c3e:	29 de       	rcall	.-942    	; 0x6892 <__addsf3x>
    6c40:	fe 01       	movw	r30, r28
    6c42:	97 01       	movw	r18, r14
    6c44:	a8 01       	movw	r20, r16
    6c46:	da 94       	dec	r13
    6c48:	79 f7       	brne	.-34     	; 0x6c28 <__fp_powser+0x18>
    6c4a:	df 90       	pop	r13
    6c4c:	ef 90       	pop	r14
    6c4e:	ff 90       	pop	r15
    6c50:	0f 91       	pop	r16
    6c52:	1f 91       	pop	r17
    6c54:	cf 91       	pop	r28
    6c56:	df 91       	pop	r29
    6c58:	08 95       	ret

00006c5a <__fp_pscA>:
    6c5a:	00 24       	eor	r0, r0
    6c5c:	0a 94       	dec	r0
    6c5e:	16 16       	cp	r1, r22
    6c60:	17 06       	cpc	r1, r23
    6c62:	18 06       	cpc	r1, r24
    6c64:	09 06       	cpc	r0, r25
    6c66:	08 95       	ret

00006c68 <__fp_pscB>:
    6c68:	00 24       	eor	r0, r0
    6c6a:	0a 94       	dec	r0
    6c6c:	12 16       	cp	r1, r18
    6c6e:	13 06       	cpc	r1, r19
    6c70:	14 06       	cpc	r1, r20
    6c72:	05 06       	cpc	r0, r21
    6c74:	08 95       	ret
    6c76:	c9 cf       	rjmp	.-110    	; 0x6c0a <__fp_nan>

00006c78 <__fp_rempio2>:
    6c78:	50 d0       	rcall	.+160    	; 0x6d1a <__fp_splitA>
    6c7a:	e8 f3       	brcs	.-6      	; 0x6c76 <__fp_pscB+0xe>
    6c7c:	e8 94       	clt
    6c7e:	e0 e0       	ldi	r30, 0x00	; 0
    6c80:	bb 27       	eor	r27, r27
    6c82:	9f 57       	subi	r25, 0x7F	; 127
    6c84:	f0 f0       	brcs	.+60     	; 0x6cc2 <__fp_rempio2+0x4a>
    6c86:	2a ed       	ldi	r18, 0xDA	; 218
    6c88:	3f e0       	ldi	r19, 0x0F	; 15
    6c8a:	49 ec       	ldi	r20, 0xC9	; 201
    6c8c:	06 c0       	rjmp	.+12     	; 0x6c9a <__fp_rempio2+0x22>
    6c8e:	ee 0f       	add	r30, r30
    6c90:	bb 0f       	add	r27, r27
    6c92:	66 1f       	adc	r22, r22
    6c94:	77 1f       	adc	r23, r23
    6c96:	88 1f       	adc	r24, r24
    6c98:	28 f0       	brcs	.+10     	; 0x6ca4 <__fp_rempio2+0x2c>
    6c9a:	b2 3a       	cpi	r27, 0xA2	; 162
    6c9c:	62 07       	cpc	r22, r18
    6c9e:	73 07       	cpc	r23, r19
    6ca0:	84 07       	cpc	r24, r20
    6ca2:	28 f0       	brcs	.+10     	; 0x6cae <__fp_rempio2+0x36>
    6ca4:	b2 5a       	subi	r27, 0xA2	; 162
    6ca6:	62 0b       	sbc	r22, r18
    6ca8:	73 0b       	sbc	r23, r19
    6caa:	84 0b       	sbc	r24, r20
    6cac:	e3 95       	inc	r30
    6cae:	9a 95       	dec	r25
    6cb0:	72 f7       	brpl	.-36     	; 0x6c8e <__fp_rempio2+0x16>
    6cb2:	80 38       	cpi	r24, 0x80	; 128
    6cb4:	30 f4       	brcc	.+12     	; 0x6cc2 <__fp_rempio2+0x4a>
    6cb6:	9a 95       	dec	r25
    6cb8:	bb 0f       	add	r27, r27
    6cba:	66 1f       	adc	r22, r22
    6cbc:	77 1f       	adc	r23, r23
    6cbe:	88 1f       	adc	r24, r24
    6cc0:	d2 f7       	brpl	.-12     	; 0x6cb6 <__fp_rempio2+0x3e>
    6cc2:	90 48       	sbci	r25, 0x80	; 128
    6cc4:	06 c1       	rjmp	.+524    	; 0x6ed2 <__fp_mpack_finite>

00006cc6 <__fp_round>:
    6cc6:	09 2e       	mov	r0, r25
    6cc8:	03 94       	inc	r0
    6cca:	00 0c       	add	r0, r0
    6ccc:	11 f4       	brne	.+4      	; 0x6cd2 <__fp_round+0xc>
    6cce:	88 23       	and	r24, r24
    6cd0:	52 f0       	brmi	.+20     	; 0x6ce6 <__fp_round+0x20>
    6cd2:	bb 0f       	add	r27, r27
    6cd4:	40 f4       	brcc	.+16     	; 0x6ce6 <__fp_round+0x20>
    6cd6:	bf 2b       	or	r27, r31
    6cd8:	11 f4       	brne	.+4      	; 0x6cde <__fp_round+0x18>
    6cda:	60 ff       	sbrs	r22, 0
    6cdc:	04 c0       	rjmp	.+8      	; 0x6ce6 <__fp_round+0x20>
    6cde:	6f 5f       	subi	r22, 0xFF	; 255
    6ce0:	7f 4f       	sbci	r23, 0xFF	; 255
    6ce2:	8f 4f       	sbci	r24, 0xFF	; 255
    6ce4:	9f 4f       	sbci	r25, 0xFF	; 255
    6ce6:	08 95       	ret

00006ce8 <__fp_sinus>:
    6ce8:	ef 93       	push	r30
    6cea:	e0 ff       	sbrs	r30, 0
    6cec:	06 c0       	rjmp	.+12     	; 0x6cfa <__fp_sinus+0x12>
    6cee:	a2 ea       	ldi	r26, 0xA2	; 162
    6cf0:	2a ed       	ldi	r18, 0xDA	; 218
    6cf2:	3f e0       	ldi	r19, 0x0F	; 15
    6cf4:	49 ec       	ldi	r20, 0xC9	; 201
    6cf6:	5f eb       	ldi	r21, 0xBF	; 191
    6cf8:	cc dd       	rcall	.-1128   	; 0x6892 <__addsf3x>
    6cfa:	e5 df       	rcall	.-54     	; 0x6cc6 <__fp_round>
    6cfc:	0f 90       	pop	r0
    6cfe:	03 94       	inc	r0
    6d00:	01 fc       	sbrc	r0, 1
    6d02:	90 58       	subi	r25, 0x80	; 128
    6d04:	e1 e1       	ldi	r30, 0x11	; 17
    6d06:	f1 e0       	ldi	r31, 0x01	; 1
    6d08:	f7 c0       	rjmp	.+494    	; 0x6ef8 <__fp_powsodd>

00006d0a <__fp_split3>:
    6d0a:	57 fd       	sbrc	r21, 7
    6d0c:	90 58       	subi	r25, 0x80	; 128
    6d0e:	44 0f       	add	r20, r20
    6d10:	55 1f       	adc	r21, r21
    6d12:	59 f0       	breq	.+22     	; 0x6d2a <__fp_splitA+0x10>
    6d14:	5f 3f       	cpi	r21, 0xFF	; 255
    6d16:	71 f0       	breq	.+28     	; 0x6d34 <__fp_splitA+0x1a>
    6d18:	47 95       	ror	r20

00006d1a <__fp_splitA>:
    6d1a:	88 0f       	add	r24, r24
    6d1c:	97 fb       	bst	r25, 7
    6d1e:	99 1f       	adc	r25, r25
    6d20:	61 f0       	breq	.+24     	; 0x6d3a <__fp_splitA+0x20>
    6d22:	9f 3f       	cpi	r25, 0xFF	; 255
    6d24:	79 f0       	breq	.+30     	; 0x6d44 <__fp_splitA+0x2a>
    6d26:	87 95       	ror	r24
    6d28:	08 95       	ret
    6d2a:	12 16       	cp	r1, r18
    6d2c:	13 06       	cpc	r1, r19
    6d2e:	14 06       	cpc	r1, r20
    6d30:	55 1f       	adc	r21, r21
    6d32:	f2 cf       	rjmp	.-28     	; 0x6d18 <__fp_split3+0xe>
    6d34:	46 95       	lsr	r20
    6d36:	f1 df       	rcall	.-30     	; 0x6d1a <__fp_splitA>
    6d38:	08 c0       	rjmp	.+16     	; 0x6d4a <__fp_splitA+0x30>
    6d3a:	16 16       	cp	r1, r22
    6d3c:	17 06       	cpc	r1, r23
    6d3e:	18 06       	cpc	r1, r24
    6d40:	99 1f       	adc	r25, r25
    6d42:	f1 cf       	rjmp	.-30     	; 0x6d26 <__fp_splitA+0xc>
    6d44:	86 95       	lsr	r24
    6d46:	71 05       	cpc	r23, r1
    6d48:	61 05       	cpc	r22, r1
    6d4a:	08 94       	sec
    6d4c:	08 95       	ret

00006d4e <__fp_zero>:
    6d4e:	e8 94       	clt

00006d50 <__fp_szero>:
    6d50:	bb 27       	eor	r27, r27
    6d52:	66 27       	eor	r22, r22
    6d54:	77 27       	eor	r23, r23
    6d56:	cb 01       	movw	r24, r22
    6d58:	97 f9       	bld	r25, 7
    6d5a:	08 95       	ret

00006d5c <__gesf2>:
    6d5c:	2c df       	rcall	.-424    	; 0x6bb6 <__fp_cmp>
    6d5e:	08 f4       	brcc	.+2      	; 0x6d62 <__gesf2+0x6>
    6d60:	8f ef       	ldi	r24, 0xFF	; 255
    6d62:	08 95       	ret

00006d64 <inverse>:
    6d64:	9b 01       	movw	r18, r22
    6d66:	ac 01       	movw	r20, r24
    6d68:	60 e0       	ldi	r22, 0x00	; 0
    6d6a:	70 e0       	ldi	r23, 0x00	; 0
    6d6c:	80 e8       	ldi	r24, 0x80	; 128
    6d6e:	9f e3       	ldi	r25, 0x3F	; 63
    6d70:	4c ce       	rjmp	.-872    	; 0x6a0a <__divsf3>

00006d72 <__mulsf3>:
    6d72:	0b d0       	rcall	.+22     	; 0x6d8a <__mulsf3x>
    6d74:	a8 cf       	rjmp	.-176    	; 0x6cc6 <__fp_round>
    6d76:	71 df       	rcall	.-286    	; 0x6c5a <__fp_pscA>
    6d78:	28 f0       	brcs	.+10     	; 0x6d84 <__mulsf3+0x12>
    6d7a:	76 df       	rcall	.-276    	; 0x6c68 <__fp_pscB>
    6d7c:	18 f0       	brcs	.+6      	; 0x6d84 <__mulsf3+0x12>
    6d7e:	95 23       	and	r25, r21
    6d80:	09 f0       	breq	.+2      	; 0x6d84 <__mulsf3+0x12>
    6d82:	3d cf       	rjmp	.-390    	; 0x6bfe <__fp_inf>
    6d84:	42 cf       	rjmp	.-380    	; 0x6c0a <__fp_nan>
    6d86:	11 24       	eor	r1, r1
    6d88:	e3 cf       	rjmp	.-58     	; 0x6d50 <__fp_szero>

00006d8a <__mulsf3x>:
    6d8a:	bf df       	rcall	.-130    	; 0x6d0a <__fp_split3>
    6d8c:	a0 f3       	brcs	.-24     	; 0x6d76 <__mulsf3+0x4>

00006d8e <__mulsf3_pse>:
    6d8e:	95 9f       	mul	r25, r21
    6d90:	d1 f3       	breq	.-12     	; 0x6d86 <__mulsf3+0x14>
    6d92:	95 0f       	add	r25, r21
    6d94:	50 e0       	ldi	r21, 0x00	; 0
    6d96:	55 1f       	adc	r21, r21
    6d98:	62 9f       	mul	r22, r18
    6d9a:	f0 01       	movw	r30, r0
    6d9c:	72 9f       	mul	r23, r18
    6d9e:	bb 27       	eor	r27, r27
    6da0:	f0 0d       	add	r31, r0
    6da2:	b1 1d       	adc	r27, r1
    6da4:	63 9f       	mul	r22, r19
    6da6:	aa 27       	eor	r26, r26
    6da8:	f0 0d       	add	r31, r0
    6daa:	b1 1d       	adc	r27, r1
    6dac:	aa 1f       	adc	r26, r26
    6dae:	64 9f       	mul	r22, r20
    6db0:	66 27       	eor	r22, r22
    6db2:	b0 0d       	add	r27, r0
    6db4:	a1 1d       	adc	r26, r1
    6db6:	66 1f       	adc	r22, r22
    6db8:	82 9f       	mul	r24, r18
    6dba:	22 27       	eor	r18, r18
    6dbc:	b0 0d       	add	r27, r0
    6dbe:	a1 1d       	adc	r26, r1
    6dc0:	62 1f       	adc	r22, r18
    6dc2:	73 9f       	mul	r23, r19
    6dc4:	b0 0d       	add	r27, r0
    6dc6:	a1 1d       	adc	r26, r1
    6dc8:	62 1f       	adc	r22, r18
    6dca:	83 9f       	mul	r24, r19
    6dcc:	a0 0d       	add	r26, r0
    6dce:	61 1d       	adc	r22, r1
    6dd0:	22 1f       	adc	r18, r18
    6dd2:	74 9f       	mul	r23, r20
    6dd4:	33 27       	eor	r19, r19
    6dd6:	a0 0d       	add	r26, r0
    6dd8:	61 1d       	adc	r22, r1
    6dda:	23 1f       	adc	r18, r19
    6ddc:	84 9f       	mul	r24, r20
    6dde:	60 0d       	add	r22, r0
    6de0:	21 1d       	adc	r18, r1
    6de2:	82 2f       	mov	r24, r18
    6de4:	76 2f       	mov	r23, r22
    6de6:	6a 2f       	mov	r22, r26
    6de8:	11 24       	eor	r1, r1
    6dea:	9f 57       	subi	r25, 0x7F	; 127
    6dec:	50 40       	sbci	r21, 0x00	; 0
    6dee:	8a f0       	brmi	.+34     	; 0x6e12 <__mulsf3_pse+0x84>
    6df0:	e1 f0       	breq	.+56     	; 0x6e2a <__mulsf3_pse+0x9c>
    6df2:	88 23       	and	r24, r24
    6df4:	4a f0       	brmi	.+18     	; 0x6e08 <__mulsf3_pse+0x7a>
    6df6:	ee 0f       	add	r30, r30
    6df8:	ff 1f       	adc	r31, r31
    6dfa:	bb 1f       	adc	r27, r27
    6dfc:	66 1f       	adc	r22, r22
    6dfe:	77 1f       	adc	r23, r23
    6e00:	88 1f       	adc	r24, r24
    6e02:	91 50       	subi	r25, 0x01	; 1
    6e04:	50 40       	sbci	r21, 0x00	; 0
    6e06:	a9 f7       	brne	.-22     	; 0x6df2 <__mulsf3_pse+0x64>
    6e08:	9e 3f       	cpi	r25, 0xFE	; 254
    6e0a:	51 05       	cpc	r21, r1
    6e0c:	70 f0       	brcs	.+28     	; 0x6e2a <__mulsf3_pse+0x9c>
    6e0e:	f7 ce       	rjmp	.-530    	; 0x6bfe <__fp_inf>
    6e10:	9f cf       	rjmp	.-194    	; 0x6d50 <__fp_szero>
    6e12:	5f 3f       	cpi	r21, 0xFF	; 255
    6e14:	ec f3       	brlt	.-6      	; 0x6e10 <__mulsf3_pse+0x82>
    6e16:	98 3e       	cpi	r25, 0xE8	; 232
    6e18:	dc f3       	brlt	.-10     	; 0x6e10 <__mulsf3_pse+0x82>
    6e1a:	86 95       	lsr	r24
    6e1c:	77 95       	ror	r23
    6e1e:	67 95       	ror	r22
    6e20:	b7 95       	ror	r27
    6e22:	f7 95       	ror	r31
    6e24:	e7 95       	ror	r30
    6e26:	9f 5f       	subi	r25, 0xFF	; 255
    6e28:	c1 f7       	brne	.-16     	; 0x6e1a <__mulsf3_pse+0x8c>
    6e2a:	fe 2b       	or	r31, r30
    6e2c:	88 0f       	add	r24, r24
    6e2e:	91 1d       	adc	r25, r1
    6e30:	96 95       	lsr	r25
    6e32:	87 95       	ror	r24
    6e34:	97 f9       	bld	r25, 7
    6e36:	08 95       	ret

00006e38 <sin>:
    6e38:	9f 93       	push	r25
    6e3a:	1e df       	rcall	.-452    	; 0x6c78 <__fp_rempio2>
    6e3c:	0f 90       	pop	r0
    6e3e:	07 fc       	sbrc	r0, 7
    6e40:	ee 5f       	subi	r30, 0xFE	; 254
    6e42:	52 cf       	rjmp	.-348    	; 0x6ce8 <__fp_sinus>
    6e44:	11 f4       	brne	.+4      	; 0x6e4a <sin+0x12>
    6e46:	0e f4       	brtc	.+2      	; 0x6e4a <sin+0x12>
    6e48:	e0 ce       	rjmp	.-576    	; 0x6c0a <__fp_nan>
    6e4a:	41 c0       	rjmp	.+130    	; 0x6ece <__fp_mpack>

00006e4c <sqrt>:
    6e4c:	66 df       	rcall	.-308    	; 0x6d1a <__fp_splitA>
    6e4e:	d0 f3       	brcs	.-12     	; 0x6e44 <sin+0xc>
    6e50:	99 23       	and	r25, r25
    6e52:	d9 f3       	breq	.-10     	; 0x6e4a <sin+0x12>
    6e54:	ce f3       	brts	.-14     	; 0x6e48 <sin+0x10>
    6e56:	9f 57       	subi	r25, 0x7F	; 127
    6e58:	55 0b       	sbc	r21, r21
    6e5a:	87 ff       	sbrs	r24, 7
    6e5c:	46 d0       	rcall	.+140    	; 0x6eea <__fp_norm2>
    6e5e:	00 24       	eor	r0, r0
    6e60:	a0 e6       	ldi	r26, 0x60	; 96
    6e62:	40 ea       	ldi	r20, 0xA0	; 160
    6e64:	90 01       	movw	r18, r0
    6e66:	80 58       	subi	r24, 0x80	; 128
    6e68:	56 95       	lsr	r21
    6e6a:	97 95       	ror	r25
    6e6c:	28 f4       	brcc	.+10     	; 0x6e78 <sqrt+0x2c>
    6e6e:	80 5c       	subi	r24, 0xC0	; 192
    6e70:	66 0f       	add	r22, r22
    6e72:	77 1f       	adc	r23, r23
    6e74:	88 1f       	adc	r24, r24
    6e76:	20 f0       	brcs	.+8      	; 0x6e80 <sqrt+0x34>
    6e78:	26 17       	cp	r18, r22
    6e7a:	37 07       	cpc	r19, r23
    6e7c:	48 07       	cpc	r20, r24
    6e7e:	30 f4       	brcc	.+12     	; 0x6e8c <sqrt+0x40>
    6e80:	62 1b       	sub	r22, r18
    6e82:	73 0b       	sbc	r23, r19
    6e84:	84 0b       	sbc	r24, r20
    6e86:	20 29       	or	r18, r0
    6e88:	31 29       	or	r19, r1
    6e8a:	4a 2b       	or	r20, r26
    6e8c:	a6 95       	lsr	r26
    6e8e:	17 94       	ror	r1
    6e90:	07 94       	ror	r0
    6e92:	20 25       	eor	r18, r0
    6e94:	31 25       	eor	r19, r1
    6e96:	4a 27       	eor	r20, r26
    6e98:	58 f7       	brcc	.-42     	; 0x6e70 <sqrt+0x24>
    6e9a:	66 0f       	add	r22, r22
    6e9c:	77 1f       	adc	r23, r23
    6e9e:	88 1f       	adc	r24, r24
    6ea0:	20 f0       	brcs	.+8      	; 0x6eaa <sqrt+0x5e>
    6ea2:	26 17       	cp	r18, r22
    6ea4:	37 07       	cpc	r19, r23
    6ea6:	48 07       	cpc	r20, r24
    6ea8:	30 f4       	brcc	.+12     	; 0x6eb6 <sqrt+0x6a>
    6eaa:	62 0b       	sbc	r22, r18
    6eac:	73 0b       	sbc	r23, r19
    6eae:	84 0b       	sbc	r24, r20
    6eb0:	20 0d       	add	r18, r0
    6eb2:	31 1d       	adc	r19, r1
    6eb4:	41 1d       	adc	r20, r1
    6eb6:	a0 95       	com	r26
    6eb8:	81 f7       	brne	.-32     	; 0x6e9a <sqrt+0x4e>
    6eba:	b9 01       	movw	r22, r18
    6ebc:	84 2f       	mov	r24, r20
    6ebe:	91 58       	subi	r25, 0x81	; 129
    6ec0:	88 0f       	add	r24, r24
    6ec2:	96 95       	lsr	r25
    6ec4:	87 95       	ror	r24
    6ec6:	08 95       	ret

00006ec8 <square>:
    6ec8:	9b 01       	movw	r18, r22
    6eca:	ac 01       	movw	r20, r24
    6ecc:	52 cf       	rjmp	.-348    	; 0x6d72 <__mulsf3>

00006ece <__fp_mpack>:
    6ece:	9f 3f       	cpi	r25, 0xFF	; 255
    6ed0:	31 f0       	breq	.+12     	; 0x6ede <__fp_mpack_finite+0xc>

00006ed2 <__fp_mpack_finite>:
    6ed2:	91 50       	subi	r25, 0x01	; 1
    6ed4:	20 f4       	brcc	.+8      	; 0x6ede <__fp_mpack_finite+0xc>
    6ed6:	87 95       	ror	r24
    6ed8:	77 95       	ror	r23
    6eda:	67 95       	ror	r22
    6edc:	b7 95       	ror	r27
    6ede:	88 0f       	add	r24, r24
    6ee0:	91 1d       	adc	r25, r1
    6ee2:	96 95       	lsr	r25
    6ee4:	87 95       	ror	r24
    6ee6:	97 f9       	bld	r25, 7
    6ee8:	08 95       	ret

00006eea <__fp_norm2>:
    6eea:	91 50       	subi	r25, 0x01	; 1
    6eec:	50 40       	sbci	r21, 0x00	; 0
    6eee:	66 0f       	add	r22, r22
    6ef0:	77 1f       	adc	r23, r23
    6ef2:	88 1f       	adc	r24, r24
    6ef4:	d2 f7       	brpl	.-12     	; 0x6eea <__fp_norm2>
    6ef6:	08 95       	ret

00006ef8 <__fp_powsodd>:
    6ef8:	9f 93       	push	r25
    6efa:	8f 93       	push	r24
    6efc:	7f 93       	push	r23
    6efe:	6f 93       	push	r22
    6f00:	ff 93       	push	r31
    6f02:	ef 93       	push	r30
    6f04:	9b 01       	movw	r18, r22
    6f06:	ac 01       	movw	r20, r24
    6f08:	34 df       	rcall	.-408    	; 0x6d72 <__mulsf3>
    6f0a:	ef 91       	pop	r30
    6f0c:	ff 91       	pop	r31
    6f0e:	80 de       	rcall	.-768    	; 0x6c10 <__fp_powser>
    6f10:	2f 91       	pop	r18
    6f12:	3f 91       	pop	r19
    6f14:	4f 91       	pop	r20
    6f16:	5f 91       	pop	r21
    6f18:	2c cf       	rjmp	.-424    	; 0x6d72 <__mulsf3>

00006f1a <vfprintf>:
    6f1a:	2f 92       	push	r2
    6f1c:	3f 92       	push	r3
    6f1e:	4f 92       	push	r4
    6f20:	5f 92       	push	r5
    6f22:	6f 92       	push	r6
    6f24:	7f 92       	push	r7
    6f26:	8f 92       	push	r8
    6f28:	9f 92       	push	r9
    6f2a:	af 92       	push	r10
    6f2c:	bf 92       	push	r11
    6f2e:	cf 92       	push	r12
    6f30:	df 92       	push	r13
    6f32:	ef 92       	push	r14
    6f34:	ff 92       	push	r15
    6f36:	0f 93       	push	r16
    6f38:	1f 93       	push	r17
    6f3a:	cf 93       	push	r28
    6f3c:	df 93       	push	r29
    6f3e:	cd b7       	in	r28, 0x3d	; 61
    6f40:	de b7       	in	r29, 0x3e	; 62
    6f42:	60 97       	sbiw	r28, 0x10	; 16
    6f44:	0f b6       	in	r0, 0x3f	; 63
    6f46:	f8 94       	cli
    6f48:	de bf       	out	0x3e, r29	; 62
    6f4a:	0f be       	out	0x3f, r0	; 63
    6f4c:	cd bf       	out	0x3d, r28	; 61
    6f4e:	7c 01       	movw	r14, r24
    6f50:	1b 01       	movw	r2, r22
    6f52:	6a 01       	movw	r12, r20
    6f54:	fc 01       	movw	r30, r24
    6f56:	17 82       	std	Z+7, r1	; 0x07
    6f58:	16 82       	std	Z+6, r1	; 0x06
    6f5a:	83 81       	ldd	r24, Z+3	; 0x03
    6f5c:	81 ff       	sbrs	r24, 1
    6f5e:	2a c3       	rjmp	.+1620   	; 0x75b4 <vfprintf+0x69a>
    6f60:	9e 01       	movw	r18, r28
    6f62:	2f 5f       	subi	r18, 0xFF	; 255
    6f64:	3f 4f       	sbci	r19, 0xFF	; 255
    6f66:	39 01       	movw	r6, r18
    6f68:	f7 01       	movw	r30, r14
    6f6a:	93 81       	ldd	r25, Z+3	; 0x03
    6f6c:	f1 01       	movw	r30, r2
    6f6e:	93 fd       	sbrc	r25, 3
    6f70:	85 91       	lpm	r24, Z+
    6f72:	93 ff       	sbrs	r25, 3
    6f74:	81 91       	ld	r24, Z+
    6f76:	1f 01       	movw	r2, r30
    6f78:	88 23       	and	r24, r24
    6f7a:	09 f4       	brne	.+2      	; 0x6f7e <vfprintf+0x64>
    6f7c:	17 c3       	rjmp	.+1582   	; 0x75ac <vfprintf+0x692>
    6f7e:	85 32       	cpi	r24, 0x25	; 37
    6f80:	39 f4       	brne	.+14     	; 0x6f90 <vfprintf+0x76>
    6f82:	93 fd       	sbrc	r25, 3
    6f84:	85 91       	lpm	r24, Z+
    6f86:	93 ff       	sbrs	r25, 3
    6f88:	81 91       	ld	r24, Z+
    6f8a:	1f 01       	movw	r2, r30
    6f8c:	85 32       	cpi	r24, 0x25	; 37
    6f8e:	31 f4       	brne	.+12     	; 0x6f9c <vfprintf+0x82>
    6f90:	b7 01       	movw	r22, r14
    6f92:	90 e0       	ldi	r25, 0x00	; 0
    6f94:	7f d4       	rcall	.+2302   	; 0x7894 <fputc>
    6f96:	56 01       	movw	r10, r12
    6f98:	65 01       	movw	r12, r10
    6f9a:	e6 cf       	rjmp	.-52     	; 0x6f68 <vfprintf+0x4e>
    6f9c:	10 e0       	ldi	r17, 0x00	; 0
    6f9e:	51 2c       	mov	r5, r1
    6fa0:	91 2c       	mov	r9, r1
    6fa2:	ff e1       	ldi	r31, 0x1F	; 31
    6fa4:	f9 15       	cp	r31, r9
    6fa6:	d8 f0       	brcs	.+54     	; 0x6fde <vfprintf+0xc4>
    6fa8:	8b 32       	cpi	r24, 0x2B	; 43
    6faa:	79 f0       	breq	.+30     	; 0x6fca <vfprintf+0xb0>
    6fac:	38 f4       	brcc	.+14     	; 0x6fbc <vfprintf+0xa2>
    6fae:	80 32       	cpi	r24, 0x20	; 32
    6fb0:	79 f0       	breq	.+30     	; 0x6fd0 <vfprintf+0xb6>
    6fb2:	83 32       	cpi	r24, 0x23	; 35
    6fb4:	a1 f4       	brne	.+40     	; 0x6fde <vfprintf+0xc4>
    6fb6:	f9 2d       	mov	r31, r9
    6fb8:	f0 61       	ori	r31, 0x10	; 16
    6fba:	2e c0       	rjmp	.+92     	; 0x7018 <vfprintf+0xfe>
    6fbc:	8d 32       	cpi	r24, 0x2D	; 45
    6fbe:	61 f0       	breq	.+24     	; 0x6fd8 <vfprintf+0xbe>
    6fc0:	80 33       	cpi	r24, 0x30	; 48
    6fc2:	69 f4       	brne	.+26     	; 0x6fde <vfprintf+0xc4>
    6fc4:	29 2d       	mov	r18, r9
    6fc6:	21 60       	ori	r18, 0x01	; 1
    6fc8:	2d c0       	rjmp	.+90     	; 0x7024 <vfprintf+0x10a>
    6fca:	39 2d       	mov	r19, r9
    6fcc:	32 60       	ori	r19, 0x02	; 2
    6fce:	93 2e       	mov	r9, r19
    6fd0:	89 2d       	mov	r24, r9
    6fd2:	84 60       	ori	r24, 0x04	; 4
    6fd4:	98 2e       	mov	r9, r24
    6fd6:	2a c0       	rjmp	.+84     	; 0x702c <vfprintf+0x112>
    6fd8:	e9 2d       	mov	r30, r9
    6fda:	e8 60       	ori	r30, 0x08	; 8
    6fdc:	15 c0       	rjmp	.+42     	; 0x7008 <vfprintf+0xee>
    6fde:	97 fc       	sbrc	r9, 7
    6fe0:	2d c0       	rjmp	.+90     	; 0x703c <vfprintf+0x122>
    6fe2:	20 ed       	ldi	r18, 0xD0	; 208
    6fe4:	28 0f       	add	r18, r24
    6fe6:	2a 30       	cpi	r18, 0x0A	; 10
    6fe8:	88 f4       	brcc	.+34     	; 0x700c <vfprintf+0xf2>
    6fea:	96 fe       	sbrs	r9, 6
    6fec:	06 c0       	rjmp	.+12     	; 0x6ffa <vfprintf+0xe0>
    6fee:	3a e0       	ldi	r19, 0x0A	; 10
    6ff0:	13 9f       	mul	r17, r19
    6ff2:	20 0d       	add	r18, r0
    6ff4:	11 24       	eor	r1, r1
    6ff6:	12 2f       	mov	r17, r18
    6ff8:	19 c0       	rjmp	.+50     	; 0x702c <vfprintf+0x112>
    6ffa:	8a e0       	ldi	r24, 0x0A	; 10
    6ffc:	58 9e       	mul	r5, r24
    6ffe:	20 0d       	add	r18, r0
    7000:	11 24       	eor	r1, r1
    7002:	52 2e       	mov	r5, r18
    7004:	e9 2d       	mov	r30, r9
    7006:	e0 62       	ori	r30, 0x20	; 32
    7008:	9e 2e       	mov	r9, r30
    700a:	10 c0       	rjmp	.+32     	; 0x702c <vfprintf+0x112>
    700c:	8e 32       	cpi	r24, 0x2E	; 46
    700e:	31 f4       	brne	.+12     	; 0x701c <vfprintf+0x102>
    7010:	96 fc       	sbrc	r9, 6
    7012:	cc c2       	rjmp	.+1432   	; 0x75ac <vfprintf+0x692>
    7014:	f9 2d       	mov	r31, r9
    7016:	f0 64       	ori	r31, 0x40	; 64
    7018:	9f 2e       	mov	r9, r31
    701a:	08 c0       	rjmp	.+16     	; 0x702c <vfprintf+0x112>
    701c:	8c 36       	cpi	r24, 0x6C	; 108
    701e:	21 f4       	brne	.+8      	; 0x7028 <vfprintf+0x10e>
    7020:	29 2d       	mov	r18, r9
    7022:	20 68       	ori	r18, 0x80	; 128
    7024:	92 2e       	mov	r9, r18
    7026:	02 c0       	rjmp	.+4      	; 0x702c <vfprintf+0x112>
    7028:	88 36       	cpi	r24, 0x68	; 104
    702a:	41 f4       	brne	.+16     	; 0x703c <vfprintf+0x122>
    702c:	f1 01       	movw	r30, r2
    702e:	93 fd       	sbrc	r25, 3
    7030:	85 91       	lpm	r24, Z+
    7032:	93 ff       	sbrs	r25, 3
    7034:	81 91       	ld	r24, Z+
    7036:	1f 01       	movw	r2, r30
    7038:	81 11       	cpse	r24, r1
    703a:	b3 cf       	rjmp	.-154    	; 0x6fa2 <vfprintf+0x88>
    703c:	9b eb       	ldi	r25, 0xBB	; 187
    703e:	98 0f       	add	r25, r24
    7040:	93 30       	cpi	r25, 0x03	; 3
    7042:	20 f4       	brcc	.+8      	; 0x704c <vfprintf+0x132>
    7044:	99 2d       	mov	r25, r9
    7046:	90 61       	ori	r25, 0x10	; 16
    7048:	80 5e       	subi	r24, 0xE0	; 224
    704a:	07 c0       	rjmp	.+14     	; 0x705a <vfprintf+0x140>
    704c:	9b e9       	ldi	r25, 0x9B	; 155
    704e:	98 0f       	add	r25, r24
    7050:	93 30       	cpi	r25, 0x03	; 3
    7052:	08 f0       	brcs	.+2      	; 0x7056 <vfprintf+0x13c>
    7054:	59 c1       	rjmp	.+690    	; 0x7308 <vfprintf+0x3ee>
    7056:	99 2d       	mov	r25, r9
    7058:	9f 7e       	andi	r25, 0xEF	; 239
    705a:	96 ff       	sbrs	r25, 6
    705c:	16 e0       	ldi	r17, 0x06	; 6
    705e:	9f 73       	andi	r25, 0x3F	; 63
    7060:	99 2e       	mov	r9, r25
    7062:	85 36       	cpi	r24, 0x65	; 101
    7064:	19 f4       	brne	.+6      	; 0x706c <vfprintf+0x152>
    7066:	90 64       	ori	r25, 0x40	; 64
    7068:	99 2e       	mov	r9, r25
    706a:	08 c0       	rjmp	.+16     	; 0x707c <vfprintf+0x162>
    706c:	86 36       	cpi	r24, 0x66	; 102
    706e:	21 f4       	brne	.+8      	; 0x7078 <vfprintf+0x15e>
    7070:	39 2f       	mov	r19, r25
    7072:	30 68       	ori	r19, 0x80	; 128
    7074:	93 2e       	mov	r9, r19
    7076:	02 c0       	rjmp	.+4      	; 0x707c <vfprintf+0x162>
    7078:	11 11       	cpse	r17, r1
    707a:	11 50       	subi	r17, 0x01	; 1
    707c:	97 fe       	sbrs	r9, 7
    707e:	07 c0       	rjmp	.+14     	; 0x708e <vfprintf+0x174>
    7080:	1c 33       	cpi	r17, 0x3C	; 60
    7082:	50 f4       	brcc	.+20     	; 0x7098 <vfprintf+0x17e>
    7084:	44 24       	eor	r4, r4
    7086:	43 94       	inc	r4
    7088:	41 0e       	add	r4, r17
    708a:	27 e0       	ldi	r18, 0x07	; 7
    708c:	0b c0       	rjmp	.+22     	; 0x70a4 <vfprintf+0x18a>
    708e:	18 30       	cpi	r17, 0x08	; 8
    7090:	38 f0       	brcs	.+14     	; 0x70a0 <vfprintf+0x186>
    7092:	27 e0       	ldi	r18, 0x07	; 7
    7094:	17 e0       	ldi	r17, 0x07	; 7
    7096:	05 c0       	rjmp	.+10     	; 0x70a2 <vfprintf+0x188>
    7098:	27 e0       	ldi	r18, 0x07	; 7
    709a:	9c e3       	ldi	r25, 0x3C	; 60
    709c:	49 2e       	mov	r4, r25
    709e:	02 c0       	rjmp	.+4      	; 0x70a4 <vfprintf+0x18a>
    70a0:	21 2f       	mov	r18, r17
    70a2:	41 2c       	mov	r4, r1
    70a4:	56 01       	movw	r10, r12
    70a6:	84 e0       	ldi	r24, 0x04	; 4
    70a8:	a8 0e       	add	r10, r24
    70aa:	b1 1c       	adc	r11, r1
    70ac:	f6 01       	movw	r30, r12
    70ae:	60 81       	ld	r22, Z
    70b0:	71 81       	ldd	r23, Z+1	; 0x01
    70b2:	82 81       	ldd	r24, Z+2	; 0x02
    70b4:	93 81       	ldd	r25, Z+3	; 0x03
    70b6:	04 2d       	mov	r16, r4
    70b8:	a3 01       	movw	r20, r6
    70ba:	ee d2       	rcall	.+1500   	; 0x7698 <__ftoa_engine>
    70bc:	6c 01       	movw	r12, r24
    70be:	f9 81       	ldd	r31, Y+1	; 0x01
    70c0:	fc 87       	std	Y+12, r31	; 0x0c
    70c2:	f0 ff       	sbrs	r31, 0
    70c4:	02 c0       	rjmp	.+4      	; 0x70ca <vfprintf+0x1b0>
    70c6:	f3 ff       	sbrs	r31, 3
    70c8:	06 c0       	rjmp	.+12     	; 0x70d6 <vfprintf+0x1bc>
    70ca:	91 fc       	sbrc	r9, 1
    70cc:	06 c0       	rjmp	.+12     	; 0x70da <vfprintf+0x1c0>
    70ce:	92 fe       	sbrs	r9, 2
    70d0:	06 c0       	rjmp	.+12     	; 0x70de <vfprintf+0x1c4>
    70d2:	00 e2       	ldi	r16, 0x20	; 32
    70d4:	05 c0       	rjmp	.+10     	; 0x70e0 <vfprintf+0x1c6>
    70d6:	0d e2       	ldi	r16, 0x2D	; 45
    70d8:	03 c0       	rjmp	.+6      	; 0x70e0 <vfprintf+0x1c6>
    70da:	0b e2       	ldi	r16, 0x2B	; 43
    70dc:	01 c0       	rjmp	.+2      	; 0x70e0 <vfprintf+0x1c6>
    70de:	00 e0       	ldi	r16, 0x00	; 0
    70e0:	8c 85       	ldd	r24, Y+12	; 0x0c
    70e2:	8c 70       	andi	r24, 0x0C	; 12
    70e4:	19 f0       	breq	.+6      	; 0x70ec <vfprintf+0x1d2>
    70e6:	01 11       	cpse	r16, r1
    70e8:	43 c2       	rjmp	.+1158   	; 0x7570 <vfprintf+0x656>
    70ea:	80 c2       	rjmp	.+1280   	; 0x75ec <vfprintf+0x6d2>
    70ec:	97 fe       	sbrs	r9, 7
    70ee:	10 c0       	rjmp	.+32     	; 0x7110 <vfprintf+0x1f6>
    70f0:	4c 0c       	add	r4, r12
    70f2:	fc 85       	ldd	r31, Y+12	; 0x0c
    70f4:	f4 ff       	sbrs	r31, 4
    70f6:	04 c0       	rjmp	.+8      	; 0x7100 <vfprintf+0x1e6>
    70f8:	8a 81       	ldd	r24, Y+2	; 0x02
    70fa:	81 33       	cpi	r24, 0x31	; 49
    70fc:	09 f4       	brne	.+2      	; 0x7100 <vfprintf+0x1e6>
    70fe:	4a 94       	dec	r4
    7100:	14 14       	cp	r1, r4
    7102:	74 f5       	brge	.+92     	; 0x7160 <vfprintf+0x246>
    7104:	28 e0       	ldi	r18, 0x08	; 8
    7106:	24 15       	cp	r18, r4
    7108:	78 f5       	brcc	.+94     	; 0x7168 <vfprintf+0x24e>
    710a:	88 e0       	ldi	r24, 0x08	; 8
    710c:	48 2e       	mov	r4, r24
    710e:	2c c0       	rjmp	.+88     	; 0x7168 <vfprintf+0x24e>
    7110:	96 fc       	sbrc	r9, 6
    7112:	2a c0       	rjmp	.+84     	; 0x7168 <vfprintf+0x24e>
    7114:	81 2f       	mov	r24, r17
    7116:	90 e0       	ldi	r25, 0x00	; 0
    7118:	8c 15       	cp	r24, r12
    711a:	9d 05       	cpc	r25, r13
    711c:	9c f0       	brlt	.+38     	; 0x7144 <vfprintf+0x22a>
    711e:	3c ef       	ldi	r19, 0xFC	; 252
    7120:	c3 16       	cp	r12, r19
    7122:	3f ef       	ldi	r19, 0xFF	; 255
    7124:	d3 06       	cpc	r13, r19
    7126:	74 f0       	brlt	.+28     	; 0x7144 <vfprintf+0x22a>
    7128:	89 2d       	mov	r24, r9
    712a:	80 68       	ori	r24, 0x80	; 128
    712c:	98 2e       	mov	r9, r24
    712e:	0a c0       	rjmp	.+20     	; 0x7144 <vfprintf+0x22a>
    7130:	e2 e0       	ldi	r30, 0x02	; 2
    7132:	f0 e0       	ldi	r31, 0x00	; 0
    7134:	ec 0f       	add	r30, r28
    7136:	fd 1f       	adc	r31, r29
    7138:	e1 0f       	add	r30, r17
    713a:	f1 1d       	adc	r31, r1
    713c:	80 81       	ld	r24, Z
    713e:	80 33       	cpi	r24, 0x30	; 48
    7140:	19 f4       	brne	.+6      	; 0x7148 <vfprintf+0x22e>
    7142:	11 50       	subi	r17, 0x01	; 1
    7144:	11 11       	cpse	r17, r1
    7146:	f4 cf       	rjmp	.-24     	; 0x7130 <vfprintf+0x216>
    7148:	97 fe       	sbrs	r9, 7
    714a:	0e c0       	rjmp	.+28     	; 0x7168 <vfprintf+0x24e>
    714c:	44 24       	eor	r4, r4
    714e:	43 94       	inc	r4
    7150:	41 0e       	add	r4, r17
    7152:	81 2f       	mov	r24, r17
    7154:	90 e0       	ldi	r25, 0x00	; 0
    7156:	c8 16       	cp	r12, r24
    7158:	d9 06       	cpc	r13, r25
    715a:	2c f4       	brge	.+10     	; 0x7166 <vfprintf+0x24c>
    715c:	1c 19       	sub	r17, r12
    715e:	04 c0       	rjmp	.+8      	; 0x7168 <vfprintf+0x24e>
    7160:	44 24       	eor	r4, r4
    7162:	43 94       	inc	r4
    7164:	01 c0       	rjmp	.+2      	; 0x7168 <vfprintf+0x24e>
    7166:	10 e0       	ldi	r17, 0x00	; 0
    7168:	97 fe       	sbrs	r9, 7
    716a:	06 c0       	rjmp	.+12     	; 0x7178 <vfprintf+0x25e>
    716c:	1c 14       	cp	r1, r12
    716e:	1d 04       	cpc	r1, r13
    7170:	34 f4       	brge	.+12     	; 0x717e <vfprintf+0x264>
    7172:	c6 01       	movw	r24, r12
    7174:	01 96       	adiw	r24, 0x01	; 1
    7176:	05 c0       	rjmp	.+10     	; 0x7182 <vfprintf+0x268>
    7178:	85 e0       	ldi	r24, 0x05	; 5
    717a:	90 e0       	ldi	r25, 0x00	; 0
    717c:	02 c0       	rjmp	.+4      	; 0x7182 <vfprintf+0x268>
    717e:	81 e0       	ldi	r24, 0x01	; 1
    7180:	90 e0       	ldi	r25, 0x00	; 0
    7182:	01 11       	cpse	r16, r1
    7184:	01 96       	adiw	r24, 0x01	; 1
    7186:	11 23       	and	r17, r17
    7188:	31 f0       	breq	.+12     	; 0x7196 <vfprintf+0x27c>
    718a:	21 2f       	mov	r18, r17
    718c:	30 e0       	ldi	r19, 0x00	; 0
    718e:	2f 5f       	subi	r18, 0xFF	; 255
    7190:	3f 4f       	sbci	r19, 0xFF	; 255
    7192:	82 0f       	add	r24, r18
    7194:	93 1f       	adc	r25, r19
    7196:	25 2d       	mov	r18, r5
    7198:	30 e0       	ldi	r19, 0x00	; 0
    719a:	82 17       	cp	r24, r18
    719c:	93 07       	cpc	r25, r19
    719e:	14 f4       	brge	.+4      	; 0x71a4 <vfprintf+0x28a>
    71a0:	58 1a       	sub	r5, r24
    71a2:	01 c0       	rjmp	.+2      	; 0x71a6 <vfprintf+0x28c>
    71a4:	51 2c       	mov	r5, r1
    71a6:	89 2d       	mov	r24, r9
    71a8:	89 70       	andi	r24, 0x09	; 9
    71aa:	41 f4       	brne	.+16     	; 0x71bc <vfprintf+0x2a2>
    71ac:	55 20       	and	r5, r5
    71ae:	31 f0       	breq	.+12     	; 0x71bc <vfprintf+0x2a2>
    71b0:	b7 01       	movw	r22, r14
    71b2:	80 e2       	ldi	r24, 0x20	; 32
    71b4:	90 e0       	ldi	r25, 0x00	; 0
    71b6:	6e d3       	rcall	.+1756   	; 0x7894 <fputc>
    71b8:	5a 94       	dec	r5
    71ba:	f8 cf       	rjmp	.-16     	; 0x71ac <vfprintf+0x292>
    71bc:	00 23       	and	r16, r16
    71be:	21 f0       	breq	.+8      	; 0x71c8 <vfprintf+0x2ae>
    71c0:	b7 01       	movw	r22, r14
    71c2:	80 2f       	mov	r24, r16
    71c4:	90 e0       	ldi	r25, 0x00	; 0
    71c6:	66 d3       	rcall	.+1740   	; 0x7894 <fputc>
    71c8:	93 fc       	sbrc	r9, 3
    71ca:	08 c0       	rjmp	.+16     	; 0x71dc <vfprintf+0x2c2>
    71cc:	55 20       	and	r5, r5
    71ce:	31 f0       	breq	.+12     	; 0x71dc <vfprintf+0x2c2>
    71d0:	b7 01       	movw	r22, r14
    71d2:	80 e3       	ldi	r24, 0x30	; 48
    71d4:	90 e0       	ldi	r25, 0x00	; 0
    71d6:	5e d3       	rcall	.+1724   	; 0x7894 <fputc>
    71d8:	5a 94       	dec	r5
    71da:	f8 cf       	rjmp	.-16     	; 0x71cc <vfprintf+0x2b2>
    71dc:	97 fe       	sbrs	r9, 7
    71de:	4a c0       	rjmp	.+148    	; 0x7274 <vfprintf+0x35a>
    71e0:	46 01       	movw	r8, r12
    71e2:	d7 fe       	sbrs	r13, 7
    71e4:	02 c0       	rjmp	.+4      	; 0x71ea <vfprintf+0x2d0>
    71e6:	81 2c       	mov	r8, r1
    71e8:	91 2c       	mov	r9, r1
    71ea:	c6 01       	movw	r24, r12
    71ec:	88 19       	sub	r24, r8
    71ee:	99 09       	sbc	r25, r9
    71f0:	f3 01       	movw	r30, r6
    71f2:	e8 0f       	add	r30, r24
    71f4:	f9 1f       	adc	r31, r25
    71f6:	fe 87       	std	Y+14, r31	; 0x0e
    71f8:	ed 87       	std	Y+13, r30	; 0x0d
    71fa:	96 01       	movw	r18, r12
    71fc:	24 19       	sub	r18, r4
    71fe:	31 09       	sbc	r19, r1
    7200:	38 8b       	std	Y+16, r19	; 0x10
    7202:	2f 87       	std	Y+15, r18	; 0x0f
    7204:	01 2f       	mov	r16, r17
    7206:	10 e0       	ldi	r17, 0x00	; 0
    7208:	11 95       	neg	r17
    720a:	01 95       	neg	r16
    720c:	11 09       	sbc	r17, r1
    720e:	3f ef       	ldi	r19, 0xFF	; 255
    7210:	83 16       	cp	r8, r19
    7212:	93 06       	cpc	r9, r19
    7214:	21 f4       	brne	.+8      	; 0x721e <vfprintf+0x304>
    7216:	b7 01       	movw	r22, r14
    7218:	8e e2       	ldi	r24, 0x2E	; 46
    721a:	90 e0       	ldi	r25, 0x00	; 0
    721c:	3b d3       	rcall	.+1654   	; 0x7894 <fputc>
    721e:	c8 14       	cp	r12, r8
    7220:	d9 04       	cpc	r13, r9
    7222:	4c f0       	brlt	.+18     	; 0x7236 <vfprintf+0x31c>
    7224:	8f 85       	ldd	r24, Y+15	; 0x0f
    7226:	98 89       	ldd	r25, Y+16	; 0x10
    7228:	88 15       	cp	r24, r8
    722a:	99 05       	cpc	r25, r9
    722c:	24 f4       	brge	.+8      	; 0x7236 <vfprintf+0x31c>
    722e:	ed 85       	ldd	r30, Y+13	; 0x0d
    7230:	fe 85       	ldd	r31, Y+14	; 0x0e
    7232:	81 81       	ldd	r24, Z+1	; 0x01
    7234:	01 c0       	rjmp	.+2      	; 0x7238 <vfprintf+0x31e>
    7236:	80 e3       	ldi	r24, 0x30	; 48
    7238:	f1 e0       	ldi	r31, 0x01	; 1
    723a:	8f 1a       	sub	r8, r31
    723c:	91 08       	sbc	r9, r1
    723e:	2d 85       	ldd	r18, Y+13	; 0x0d
    7240:	3e 85       	ldd	r19, Y+14	; 0x0e
    7242:	2f 5f       	subi	r18, 0xFF	; 255
    7244:	3f 4f       	sbci	r19, 0xFF	; 255
    7246:	3e 87       	std	Y+14, r19	; 0x0e
    7248:	2d 87       	std	Y+13, r18	; 0x0d
    724a:	80 16       	cp	r8, r16
    724c:	91 06       	cpc	r9, r17
    724e:	24 f0       	brlt	.+8      	; 0x7258 <vfprintf+0x33e>
    7250:	b7 01       	movw	r22, r14
    7252:	90 e0       	ldi	r25, 0x00	; 0
    7254:	1f d3       	rcall	.+1598   	; 0x7894 <fputc>
    7256:	db cf       	rjmp	.-74     	; 0x720e <vfprintf+0x2f4>
    7258:	c8 14       	cp	r12, r8
    725a:	d9 04       	cpc	r13, r9
    725c:	41 f4       	brne	.+16     	; 0x726e <vfprintf+0x354>
    725e:	9a 81       	ldd	r25, Y+2	; 0x02
    7260:	96 33       	cpi	r25, 0x36	; 54
    7262:	20 f4       	brcc	.+8      	; 0x726c <vfprintf+0x352>
    7264:	95 33       	cpi	r25, 0x35	; 53
    7266:	19 f4       	brne	.+6      	; 0x726e <vfprintf+0x354>
    7268:	3c 85       	ldd	r19, Y+12	; 0x0c
    726a:	34 ff       	sbrs	r19, 4
    726c:	81 e3       	ldi	r24, 0x31	; 49
    726e:	b7 01       	movw	r22, r14
    7270:	90 e0       	ldi	r25, 0x00	; 0
    7272:	48 c0       	rjmp	.+144    	; 0x7304 <vfprintf+0x3ea>
    7274:	8a 81       	ldd	r24, Y+2	; 0x02
    7276:	81 33       	cpi	r24, 0x31	; 49
    7278:	19 f0       	breq	.+6      	; 0x7280 <vfprintf+0x366>
    727a:	9c 85       	ldd	r25, Y+12	; 0x0c
    727c:	9f 7e       	andi	r25, 0xEF	; 239
    727e:	9c 87       	std	Y+12, r25	; 0x0c
    7280:	b7 01       	movw	r22, r14
    7282:	90 e0       	ldi	r25, 0x00	; 0
    7284:	07 d3       	rcall	.+1550   	; 0x7894 <fputc>
    7286:	11 11       	cpse	r17, r1
    7288:	05 c0       	rjmp	.+10     	; 0x7294 <vfprintf+0x37a>
    728a:	94 fc       	sbrc	r9, 4
    728c:	16 c0       	rjmp	.+44     	; 0x72ba <vfprintf+0x3a0>
    728e:	85 e6       	ldi	r24, 0x65	; 101
    7290:	90 e0       	ldi	r25, 0x00	; 0
    7292:	15 c0       	rjmp	.+42     	; 0x72be <vfprintf+0x3a4>
    7294:	b7 01       	movw	r22, r14
    7296:	8e e2       	ldi	r24, 0x2E	; 46
    7298:	90 e0       	ldi	r25, 0x00	; 0
    729a:	fc d2       	rcall	.+1528   	; 0x7894 <fputc>
    729c:	1e 5f       	subi	r17, 0xFE	; 254
    729e:	82 e0       	ldi	r24, 0x02	; 2
    72a0:	01 e0       	ldi	r16, 0x01	; 1
    72a2:	08 0f       	add	r16, r24
    72a4:	f3 01       	movw	r30, r6
    72a6:	e8 0f       	add	r30, r24
    72a8:	f1 1d       	adc	r31, r1
    72aa:	80 81       	ld	r24, Z
    72ac:	b7 01       	movw	r22, r14
    72ae:	90 e0       	ldi	r25, 0x00	; 0
    72b0:	f1 d2       	rcall	.+1506   	; 0x7894 <fputc>
    72b2:	80 2f       	mov	r24, r16
    72b4:	01 13       	cpse	r16, r17
    72b6:	f4 cf       	rjmp	.-24     	; 0x72a0 <vfprintf+0x386>
    72b8:	e8 cf       	rjmp	.-48     	; 0x728a <vfprintf+0x370>
    72ba:	85 e4       	ldi	r24, 0x45	; 69
    72bc:	90 e0       	ldi	r25, 0x00	; 0
    72be:	b7 01       	movw	r22, r14
    72c0:	e9 d2       	rcall	.+1490   	; 0x7894 <fputc>
    72c2:	d7 fc       	sbrc	r13, 7
    72c4:	06 c0       	rjmp	.+12     	; 0x72d2 <vfprintf+0x3b8>
    72c6:	c1 14       	cp	r12, r1
    72c8:	d1 04       	cpc	r13, r1
    72ca:	41 f4       	brne	.+16     	; 0x72dc <vfprintf+0x3c2>
    72cc:	ec 85       	ldd	r30, Y+12	; 0x0c
    72ce:	e4 ff       	sbrs	r30, 4
    72d0:	05 c0       	rjmp	.+10     	; 0x72dc <vfprintf+0x3c2>
    72d2:	d1 94       	neg	r13
    72d4:	c1 94       	neg	r12
    72d6:	d1 08       	sbc	r13, r1
    72d8:	8d e2       	ldi	r24, 0x2D	; 45
    72da:	01 c0       	rjmp	.+2      	; 0x72de <vfprintf+0x3c4>
    72dc:	8b e2       	ldi	r24, 0x2B	; 43
    72de:	b7 01       	movw	r22, r14
    72e0:	90 e0       	ldi	r25, 0x00	; 0
    72e2:	d8 d2       	rcall	.+1456   	; 0x7894 <fputc>
    72e4:	80 e3       	ldi	r24, 0x30	; 48
    72e6:	2a e0       	ldi	r18, 0x0A	; 10
    72e8:	c2 16       	cp	r12, r18
    72ea:	d1 04       	cpc	r13, r1
    72ec:	2c f0       	brlt	.+10     	; 0x72f8 <vfprintf+0x3de>
    72ee:	8f 5f       	subi	r24, 0xFF	; 255
    72f0:	fa e0       	ldi	r31, 0x0A	; 10
    72f2:	cf 1a       	sub	r12, r31
    72f4:	d1 08       	sbc	r13, r1
    72f6:	f7 cf       	rjmp	.-18     	; 0x72e6 <vfprintf+0x3cc>
    72f8:	b7 01       	movw	r22, r14
    72fa:	90 e0       	ldi	r25, 0x00	; 0
    72fc:	cb d2       	rcall	.+1430   	; 0x7894 <fputc>
    72fe:	b7 01       	movw	r22, r14
    7300:	c6 01       	movw	r24, r12
    7302:	c0 96       	adiw	r24, 0x30	; 48
    7304:	c7 d2       	rcall	.+1422   	; 0x7894 <fputc>
    7306:	49 c1       	rjmp	.+658    	; 0x759a <vfprintf+0x680>
    7308:	83 36       	cpi	r24, 0x63	; 99
    730a:	31 f0       	breq	.+12     	; 0x7318 <vfprintf+0x3fe>
    730c:	83 37       	cpi	r24, 0x73	; 115
    730e:	79 f0       	breq	.+30     	; 0x732e <vfprintf+0x414>
    7310:	83 35       	cpi	r24, 0x53	; 83
    7312:	09 f0       	breq	.+2      	; 0x7316 <vfprintf+0x3fc>
    7314:	52 c0       	rjmp	.+164    	; 0x73ba <vfprintf+0x4a0>
    7316:	1f c0       	rjmp	.+62     	; 0x7356 <vfprintf+0x43c>
    7318:	56 01       	movw	r10, r12
    731a:	32 e0       	ldi	r19, 0x02	; 2
    731c:	a3 0e       	add	r10, r19
    731e:	b1 1c       	adc	r11, r1
    7320:	f6 01       	movw	r30, r12
    7322:	80 81       	ld	r24, Z
    7324:	89 83       	std	Y+1, r24	; 0x01
    7326:	01 e0       	ldi	r16, 0x01	; 1
    7328:	10 e0       	ldi	r17, 0x00	; 0
    732a:	63 01       	movw	r12, r6
    732c:	11 c0       	rjmp	.+34     	; 0x7350 <vfprintf+0x436>
    732e:	56 01       	movw	r10, r12
    7330:	f2 e0       	ldi	r31, 0x02	; 2
    7332:	af 0e       	add	r10, r31
    7334:	b1 1c       	adc	r11, r1
    7336:	f6 01       	movw	r30, r12
    7338:	c0 80       	ld	r12, Z
    733a:	d1 80       	ldd	r13, Z+1	; 0x01
    733c:	96 fe       	sbrs	r9, 6
    733e:	03 c0       	rjmp	.+6      	; 0x7346 <vfprintf+0x42c>
    7340:	61 2f       	mov	r22, r17
    7342:	70 e0       	ldi	r23, 0x00	; 0
    7344:	02 c0       	rjmp	.+4      	; 0x734a <vfprintf+0x430>
    7346:	6f ef       	ldi	r22, 0xFF	; 255
    7348:	7f ef       	ldi	r23, 0xFF	; 255
    734a:	c6 01       	movw	r24, r12
    734c:	98 d2       	rcall	.+1328   	; 0x787e <strnlen>
    734e:	8c 01       	movw	r16, r24
    7350:	f9 2d       	mov	r31, r9
    7352:	ff 77       	andi	r31, 0x7F	; 127
    7354:	13 c0       	rjmp	.+38     	; 0x737c <vfprintf+0x462>
    7356:	56 01       	movw	r10, r12
    7358:	22 e0       	ldi	r18, 0x02	; 2
    735a:	a2 0e       	add	r10, r18
    735c:	b1 1c       	adc	r11, r1
    735e:	f6 01       	movw	r30, r12
    7360:	c0 80       	ld	r12, Z
    7362:	d1 80       	ldd	r13, Z+1	; 0x01
    7364:	96 fe       	sbrs	r9, 6
    7366:	03 c0       	rjmp	.+6      	; 0x736e <vfprintf+0x454>
    7368:	61 2f       	mov	r22, r17
    736a:	70 e0       	ldi	r23, 0x00	; 0
    736c:	02 c0       	rjmp	.+4      	; 0x7372 <vfprintf+0x458>
    736e:	6f ef       	ldi	r22, 0xFF	; 255
    7370:	7f ef       	ldi	r23, 0xFF	; 255
    7372:	c6 01       	movw	r24, r12
    7374:	69 d2       	rcall	.+1234   	; 0x7848 <strnlen_P>
    7376:	8c 01       	movw	r16, r24
    7378:	f9 2d       	mov	r31, r9
    737a:	f0 68       	ori	r31, 0x80	; 128
    737c:	9f 2e       	mov	r9, r31
    737e:	f3 fd       	sbrc	r31, 3
    7380:	18 c0       	rjmp	.+48     	; 0x73b2 <vfprintf+0x498>
    7382:	85 2d       	mov	r24, r5
    7384:	90 e0       	ldi	r25, 0x00	; 0
    7386:	08 17       	cp	r16, r24
    7388:	19 07       	cpc	r17, r25
    738a:	98 f4       	brcc	.+38     	; 0x73b2 <vfprintf+0x498>
    738c:	b7 01       	movw	r22, r14
    738e:	80 e2       	ldi	r24, 0x20	; 32
    7390:	90 e0       	ldi	r25, 0x00	; 0
    7392:	80 d2       	rcall	.+1280   	; 0x7894 <fputc>
    7394:	5a 94       	dec	r5
    7396:	f5 cf       	rjmp	.-22     	; 0x7382 <vfprintf+0x468>
    7398:	f6 01       	movw	r30, r12
    739a:	97 fc       	sbrc	r9, 7
    739c:	85 91       	lpm	r24, Z+
    739e:	97 fe       	sbrs	r9, 7
    73a0:	81 91       	ld	r24, Z+
    73a2:	6f 01       	movw	r12, r30
    73a4:	b7 01       	movw	r22, r14
    73a6:	90 e0       	ldi	r25, 0x00	; 0
    73a8:	75 d2       	rcall	.+1258   	; 0x7894 <fputc>
    73aa:	51 10       	cpse	r5, r1
    73ac:	5a 94       	dec	r5
    73ae:	01 50       	subi	r16, 0x01	; 1
    73b0:	11 09       	sbc	r17, r1
    73b2:	01 15       	cp	r16, r1
    73b4:	11 05       	cpc	r17, r1
    73b6:	81 f7       	brne	.-32     	; 0x7398 <vfprintf+0x47e>
    73b8:	f0 c0       	rjmp	.+480    	; 0x759a <vfprintf+0x680>
    73ba:	84 36       	cpi	r24, 0x64	; 100
    73bc:	11 f0       	breq	.+4      	; 0x73c2 <vfprintf+0x4a8>
    73be:	89 36       	cpi	r24, 0x69	; 105
    73c0:	59 f5       	brne	.+86     	; 0x7418 <vfprintf+0x4fe>
    73c2:	56 01       	movw	r10, r12
    73c4:	97 fe       	sbrs	r9, 7
    73c6:	09 c0       	rjmp	.+18     	; 0x73da <vfprintf+0x4c0>
    73c8:	24 e0       	ldi	r18, 0x04	; 4
    73ca:	a2 0e       	add	r10, r18
    73cc:	b1 1c       	adc	r11, r1
    73ce:	f6 01       	movw	r30, r12
    73d0:	60 81       	ld	r22, Z
    73d2:	71 81       	ldd	r23, Z+1	; 0x01
    73d4:	82 81       	ldd	r24, Z+2	; 0x02
    73d6:	93 81       	ldd	r25, Z+3	; 0x03
    73d8:	0a c0       	rjmp	.+20     	; 0x73ee <vfprintf+0x4d4>
    73da:	f2 e0       	ldi	r31, 0x02	; 2
    73dc:	af 0e       	add	r10, r31
    73de:	b1 1c       	adc	r11, r1
    73e0:	f6 01       	movw	r30, r12
    73e2:	60 81       	ld	r22, Z
    73e4:	71 81       	ldd	r23, Z+1	; 0x01
    73e6:	07 2e       	mov	r0, r23
    73e8:	00 0c       	add	r0, r0
    73ea:	88 0b       	sbc	r24, r24
    73ec:	99 0b       	sbc	r25, r25
    73ee:	f9 2d       	mov	r31, r9
    73f0:	ff 76       	andi	r31, 0x6F	; 111
    73f2:	9f 2e       	mov	r9, r31
    73f4:	97 ff       	sbrs	r25, 7
    73f6:	09 c0       	rjmp	.+18     	; 0x740a <vfprintf+0x4f0>
    73f8:	90 95       	com	r25
    73fa:	80 95       	com	r24
    73fc:	70 95       	com	r23
    73fe:	61 95       	neg	r22
    7400:	7f 4f       	sbci	r23, 0xFF	; 255
    7402:	8f 4f       	sbci	r24, 0xFF	; 255
    7404:	9f 4f       	sbci	r25, 0xFF	; 255
    7406:	f0 68       	ori	r31, 0x80	; 128
    7408:	9f 2e       	mov	r9, r31
    740a:	2a e0       	ldi	r18, 0x0A	; 10
    740c:	30 e0       	ldi	r19, 0x00	; 0
    740e:	a3 01       	movw	r20, r6
    7410:	a5 d2       	rcall	.+1354   	; 0x795c <__ultoa_invert>
    7412:	c8 2e       	mov	r12, r24
    7414:	c6 18       	sub	r12, r6
    7416:	3e c0       	rjmp	.+124    	; 0x7494 <vfprintf+0x57a>
    7418:	09 2d       	mov	r16, r9
    741a:	85 37       	cpi	r24, 0x75	; 117
    741c:	21 f4       	brne	.+8      	; 0x7426 <vfprintf+0x50c>
    741e:	0f 7e       	andi	r16, 0xEF	; 239
    7420:	2a e0       	ldi	r18, 0x0A	; 10
    7422:	30 e0       	ldi	r19, 0x00	; 0
    7424:	1d c0       	rjmp	.+58     	; 0x7460 <vfprintf+0x546>
    7426:	09 7f       	andi	r16, 0xF9	; 249
    7428:	8f 36       	cpi	r24, 0x6F	; 111
    742a:	91 f0       	breq	.+36     	; 0x7450 <vfprintf+0x536>
    742c:	18 f4       	brcc	.+6      	; 0x7434 <vfprintf+0x51a>
    742e:	88 35       	cpi	r24, 0x58	; 88
    7430:	59 f0       	breq	.+22     	; 0x7448 <vfprintf+0x52e>
    7432:	bc c0       	rjmp	.+376    	; 0x75ac <vfprintf+0x692>
    7434:	80 37       	cpi	r24, 0x70	; 112
    7436:	19 f0       	breq	.+6      	; 0x743e <vfprintf+0x524>
    7438:	88 37       	cpi	r24, 0x78	; 120
    743a:	11 f0       	breq	.+4      	; 0x7440 <vfprintf+0x526>
    743c:	b7 c0       	rjmp	.+366    	; 0x75ac <vfprintf+0x692>
    743e:	00 61       	ori	r16, 0x10	; 16
    7440:	04 ff       	sbrs	r16, 4
    7442:	09 c0       	rjmp	.+18     	; 0x7456 <vfprintf+0x53c>
    7444:	04 60       	ori	r16, 0x04	; 4
    7446:	07 c0       	rjmp	.+14     	; 0x7456 <vfprintf+0x53c>
    7448:	94 fe       	sbrs	r9, 4
    744a:	08 c0       	rjmp	.+16     	; 0x745c <vfprintf+0x542>
    744c:	06 60       	ori	r16, 0x06	; 6
    744e:	06 c0       	rjmp	.+12     	; 0x745c <vfprintf+0x542>
    7450:	28 e0       	ldi	r18, 0x08	; 8
    7452:	30 e0       	ldi	r19, 0x00	; 0
    7454:	05 c0       	rjmp	.+10     	; 0x7460 <vfprintf+0x546>
    7456:	20 e1       	ldi	r18, 0x10	; 16
    7458:	30 e0       	ldi	r19, 0x00	; 0
    745a:	02 c0       	rjmp	.+4      	; 0x7460 <vfprintf+0x546>
    745c:	20 e1       	ldi	r18, 0x10	; 16
    745e:	32 e0       	ldi	r19, 0x02	; 2
    7460:	56 01       	movw	r10, r12
    7462:	07 ff       	sbrs	r16, 7
    7464:	09 c0       	rjmp	.+18     	; 0x7478 <vfprintf+0x55e>
    7466:	84 e0       	ldi	r24, 0x04	; 4
    7468:	a8 0e       	add	r10, r24
    746a:	b1 1c       	adc	r11, r1
    746c:	f6 01       	movw	r30, r12
    746e:	60 81       	ld	r22, Z
    7470:	71 81       	ldd	r23, Z+1	; 0x01
    7472:	82 81       	ldd	r24, Z+2	; 0x02
    7474:	93 81       	ldd	r25, Z+3	; 0x03
    7476:	08 c0       	rjmp	.+16     	; 0x7488 <vfprintf+0x56e>
    7478:	f2 e0       	ldi	r31, 0x02	; 2
    747a:	af 0e       	add	r10, r31
    747c:	b1 1c       	adc	r11, r1
    747e:	f6 01       	movw	r30, r12
    7480:	60 81       	ld	r22, Z
    7482:	71 81       	ldd	r23, Z+1	; 0x01
    7484:	80 e0       	ldi	r24, 0x00	; 0
    7486:	90 e0       	ldi	r25, 0x00	; 0
    7488:	a3 01       	movw	r20, r6
    748a:	68 d2       	rcall	.+1232   	; 0x795c <__ultoa_invert>
    748c:	c8 2e       	mov	r12, r24
    748e:	c6 18       	sub	r12, r6
    7490:	0f 77       	andi	r16, 0x7F	; 127
    7492:	90 2e       	mov	r9, r16
    7494:	96 fe       	sbrs	r9, 6
    7496:	0b c0       	rjmp	.+22     	; 0x74ae <vfprintf+0x594>
    7498:	09 2d       	mov	r16, r9
    749a:	0e 7f       	andi	r16, 0xFE	; 254
    749c:	c1 16       	cp	r12, r17
    749e:	50 f4       	brcc	.+20     	; 0x74b4 <vfprintf+0x59a>
    74a0:	94 fe       	sbrs	r9, 4
    74a2:	0a c0       	rjmp	.+20     	; 0x74b8 <vfprintf+0x59e>
    74a4:	92 fc       	sbrc	r9, 2
    74a6:	08 c0       	rjmp	.+16     	; 0x74b8 <vfprintf+0x59e>
    74a8:	09 2d       	mov	r16, r9
    74aa:	0e 7e       	andi	r16, 0xEE	; 238
    74ac:	05 c0       	rjmp	.+10     	; 0x74b8 <vfprintf+0x59e>
    74ae:	dc 2c       	mov	r13, r12
    74b0:	09 2d       	mov	r16, r9
    74b2:	03 c0       	rjmp	.+6      	; 0x74ba <vfprintf+0x5a0>
    74b4:	dc 2c       	mov	r13, r12
    74b6:	01 c0       	rjmp	.+2      	; 0x74ba <vfprintf+0x5a0>
    74b8:	d1 2e       	mov	r13, r17
    74ba:	04 ff       	sbrs	r16, 4
    74bc:	0d c0       	rjmp	.+26     	; 0x74d8 <vfprintf+0x5be>
    74be:	fe 01       	movw	r30, r28
    74c0:	ec 0d       	add	r30, r12
    74c2:	f1 1d       	adc	r31, r1
    74c4:	80 81       	ld	r24, Z
    74c6:	80 33       	cpi	r24, 0x30	; 48
    74c8:	11 f4       	brne	.+4      	; 0x74ce <vfprintf+0x5b4>
    74ca:	09 7e       	andi	r16, 0xE9	; 233
    74cc:	09 c0       	rjmp	.+18     	; 0x74e0 <vfprintf+0x5c6>
    74ce:	02 ff       	sbrs	r16, 2
    74d0:	06 c0       	rjmp	.+12     	; 0x74de <vfprintf+0x5c4>
    74d2:	d3 94       	inc	r13
    74d4:	d3 94       	inc	r13
    74d6:	04 c0       	rjmp	.+8      	; 0x74e0 <vfprintf+0x5c6>
    74d8:	80 2f       	mov	r24, r16
    74da:	86 78       	andi	r24, 0x86	; 134
    74dc:	09 f0       	breq	.+2      	; 0x74e0 <vfprintf+0x5c6>
    74de:	d3 94       	inc	r13
    74e0:	03 fd       	sbrc	r16, 3
    74e2:	10 c0       	rjmp	.+32     	; 0x7504 <vfprintf+0x5ea>
    74e4:	00 ff       	sbrs	r16, 0
    74e6:	06 c0       	rjmp	.+12     	; 0x74f4 <vfprintf+0x5da>
    74e8:	1c 2d       	mov	r17, r12
    74ea:	d5 14       	cp	r13, r5
    74ec:	78 f4       	brcc	.+30     	; 0x750c <vfprintf+0x5f2>
    74ee:	15 0d       	add	r17, r5
    74f0:	1d 19       	sub	r17, r13
    74f2:	0c c0       	rjmp	.+24     	; 0x750c <vfprintf+0x5f2>
    74f4:	d5 14       	cp	r13, r5
    74f6:	50 f4       	brcc	.+20     	; 0x750c <vfprintf+0x5f2>
    74f8:	b7 01       	movw	r22, r14
    74fa:	80 e2       	ldi	r24, 0x20	; 32
    74fc:	90 e0       	ldi	r25, 0x00	; 0
    74fe:	ca d1       	rcall	.+916    	; 0x7894 <fputc>
    7500:	d3 94       	inc	r13
    7502:	f8 cf       	rjmp	.-16     	; 0x74f4 <vfprintf+0x5da>
    7504:	d5 14       	cp	r13, r5
    7506:	10 f4       	brcc	.+4      	; 0x750c <vfprintf+0x5f2>
    7508:	5d 18       	sub	r5, r13
    750a:	01 c0       	rjmp	.+2      	; 0x750e <vfprintf+0x5f4>
    750c:	51 2c       	mov	r5, r1
    750e:	04 ff       	sbrs	r16, 4
    7510:	0f c0       	rjmp	.+30     	; 0x7530 <vfprintf+0x616>
    7512:	b7 01       	movw	r22, r14
    7514:	80 e3       	ldi	r24, 0x30	; 48
    7516:	90 e0       	ldi	r25, 0x00	; 0
    7518:	bd d1       	rcall	.+890    	; 0x7894 <fputc>
    751a:	02 ff       	sbrs	r16, 2
    751c:	16 c0       	rjmp	.+44     	; 0x754a <vfprintf+0x630>
    751e:	01 fd       	sbrc	r16, 1
    7520:	03 c0       	rjmp	.+6      	; 0x7528 <vfprintf+0x60e>
    7522:	88 e7       	ldi	r24, 0x78	; 120
    7524:	90 e0       	ldi	r25, 0x00	; 0
    7526:	02 c0       	rjmp	.+4      	; 0x752c <vfprintf+0x612>
    7528:	88 e5       	ldi	r24, 0x58	; 88
    752a:	90 e0       	ldi	r25, 0x00	; 0
    752c:	b7 01       	movw	r22, r14
    752e:	0c c0       	rjmp	.+24     	; 0x7548 <vfprintf+0x62e>
    7530:	80 2f       	mov	r24, r16
    7532:	86 78       	andi	r24, 0x86	; 134
    7534:	51 f0       	breq	.+20     	; 0x754a <vfprintf+0x630>
    7536:	01 ff       	sbrs	r16, 1
    7538:	02 c0       	rjmp	.+4      	; 0x753e <vfprintf+0x624>
    753a:	8b e2       	ldi	r24, 0x2B	; 43
    753c:	01 c0       	rjmp	.+2      	; 0x7540 <vfprintf+0x626>
    753e:	80 e2       	ldi	r24, 0x20	; 32
    7540:	07 fd       	sbrc	r16, 7
    7542:	8d e2       	ldi	r24, 0x2D	; 45
    7544:	b7 01       	movw	r22, r14
    7546:	90 e0       	ldi	r25, 0x00	; 0
    7548:	a5 d1       	rcall	.+842    	; 0x7894 <fputc>
    754a:	c1 16       	cp	r12, r17
    754c:	30 f4       	brcc	.+12     	; 0x755a <vfprintf+0x640>
    754e:	b7 01       	movw	r22, r14
    7550:	80 e3       	ldi	r24, 0x30	; 48
    7552:	90 e0       	ldi	r25, 0x00	; 0
    7554:	9f d1       	rcall	.+830    	; 0x7894 <fputc>
    7556:	11 50       	subi	r17, 0x01	; 1
    7558:	f8 cf       	rjmp	.-16     	; 0x754a <vfprintf+0x630>
    755a:	ca 94       	dec	r12
    755c:	f3 01       	movw	r30, r6
    755e:	ec 0d       	add	r30, r12
    7560:	f1 1d       	adc	r31, r1
    7562:	80 81       	ld	r24, Z
    7564:	b7 01       	movw	r22, r14
    7566:	90 e0       	ldi	r25, 0x00	; 0
    7568:	95 d1       	rcall	.+810    	; 0x7894 <fputc>
    756a:	c1 10       	cpse	r12, r1
    756c:	f6 cf       	rjmp	.-20     	; 0x755a <vfprintf+0x640>
    756e:	15 c0       	rjmp	.+42     	; 0x759a <vfprintf+0x680>
    7570:	f4 e0       	ldi	r31, 0x04	; 4
    7572:	f5 15       	cp	r31, r5
    7574:	50 f5       	brcc	.+84     	; 0x75ca <vfprintf+0x6b0>
    7576:	84 e0       	ldi	r24, 0x04	; 4
    7578:	58 1a       	sub	r5, r24
    757a:	93 fe       	sbrs	r9, 3
    757c:	1e c0       	rjmp	.+60     	; 0x75ba <vfprintf+0x6a0>
    757e:	01 11       	cpse	r16, r1
    7580:	25 c0       	rjmp	.+74     	; 0x75cc <vfprintf+0x6b2>
    7582:	2c 85       	ldd	r18, Y+12	; 0x0c
    7584:	23 ff       	sbrs	r18, 3
    7586:	27 c0       	rjmp	.+78     	; 0x75d6 <vfprintf+0x6bc>
    7588:	00 e3       	ldi	r16, 0x30	; 48
    758a:	11 e0       	ldi	r17, 0x01	; 1
    758c:	39 2d       	mov	r19, r9
    758e:	30 71       	andi	r19, 0x10	; 16
    7590:	93 2e       	mov	r9, r19
    7592:	f8 01       	movw	r30, r16
    7594:	84 91       	lpm	r24, Z
    7596:	81 11       	cpse	r24, r1
    7598:	21 c0       	rjmp	.+66     	; 0x75dc <vfprintf+0x6c2>
    759a:	55 20       	and	r5, r5
    759c:	09 f4       	brne	.+2      	; 0x75a0 <vfprintf+0x686>
    759e:	fc cc       	rjmp	.-1544   	; 0x6f98 <vfprintf+0x7e>
    75a0:	b7 01       	movw	r22, r14
    75a2:	80 e2       	ldi	r24, 0x20	; 32
    75a4:	90 e0       	ldi	r25, 0x00	; 0
    75a6:	76 d1       	rcall	.+748    	; 0x7894 <fputc>
    75a8:	5a 94       	dec	r5
    75aa:	f7 cf       	rjmp	.-18     	; 0x759a <vfprintf+0x680>
    75ac:	f7 01       	movw	r30, r14
    75ae:	86 81       	ldd	r24, Z+6	; 0x06
    75b0:	97 81       	ldd	r25, Z+7	; 0x07
    75b2:	23 c0       	rjmp	.+70     	; 0x75fa <vfprintf+0x6e0>
    75b4:	8f ef       	ldi	r24, 0xFF	; 255
    75b6:	9f ef       	ldi	r25, 0xFF	; 255
    75b8:	20 c0       	rjmp	.+64     	; 0x75fa <vfprintf+0x6e0>
    75ba:	b7 01       	movw	r22, r14
    75bc:	80 e2       	ldi	r24, 0x20	; 32
    75be:	90 e0       	ldi	r25, 0x00	; 0
    75c0:	69 d1       	rcall	.+722    	; 0x7894 <fputc>
    75c2:	5a 94       	dec	r5
    75c4:	51 10       	cpse	r5, r1
    75c6:	f9 cf       	rjmp	.-14     	; 0x75ba <vfprintf+0x6a0>
    75c8:	da cf       	rjmp	.-76     	; 0x757e <vfprintf+0x664>
    75ca:	51 2c       	mov	r5, r1
    75cc:	b7 01       	movw	r22, r14
    75ce:	80 2f       	mov	r24, r16
    75d0:	90 e0       	ldi	r25, 0x00	; 0
    75d2:	60 d1       	rcall	.+704    	; 0x7894 <fputc>
    75d4:	d6 cf       	rjmp	.-84     	; 0x7582 <vfprintf+0x668>
    75d6:	04 e3       	ldi	r16, 0x34	; 52
    75d8:	11 e0       	ldi	r17, 0x01	; 1
    75da:	d8 cf       	rjmp	.-80     	; 0x758c <vfprintf+0x672>
    75dc:	91 10       	cpse	r9, r1
    75de:	80 52       	subi	r24, 0x20	; 32
    75e0:	b7 01       	movw	r22, r14
    75e2:	90 e0       	ldi	r25, 0x00	; 0
    75e4:	57 d1       	rcall	.+686    	; 0x7894 <fputc>
    75e6:	0f 5f       	subi	r16, 0xFF	; 255
    75e8:	1f 4f       	sbci	r17, 0xFF	; 255
    75ea:	d3 cf       	rjmp	.-90     	; 0x7592 <vfprintf+0x678>
    75ec:	23 e0       	ldi	r18, 0x03	; 3
    75ee:	25 15       	cp	r18, r5
    75f0:	10 f4       	brcc	.+4      	; 0x75f6 <vfprintf+0x6dc>
    75f2:	83 e0       	ldi	r24, 0x03	; 3
    75f4:	c1 cf       	rjmp	.-126    	; 0x7578 <vfprintf+0x65e>
    75f6:	51 2c       	mov	r5, r1
    75f8:	c4 cf       	rjmp	.-120    	; 0x7582 <vfprintf+0x668>
    75fa:	60 96       	adiw	r28, 0x10	; 16
    75fc:	0f b6       	in	r0, 0x3f	; 63
    75fe:	f8 94       	cli
    7600:	de bf       	out	0x3e, r29	; 62
    7602:	0f be       	out	0x3f, r0	; 63
    7604:	cd bf       	out	0x3d, r28	; 61
    7606:	df 91       	pop	r29
    7608:	cf 91       	pop	r28
    760a:	1f 91       	pop	r17
    760c:	0f 91       	pop	r16
    760e:	ff 90       	pop	r15
    7610:	ef 90       	pop	r14
    7612:	df 90       	pop	r13
    7614:	cf 90       	pop	r12
    7616:	bf 90       	pop	r11
    7618:	af 90       	pop	r10
    761a:	9f 90       	pop	r9
    761c:	8f 90       	pop	r8
    761e:	7f 90       	pop	r7
    7620:	6f 90       	pop	r6
    7622:	5f 90       	pop	r5
    7624:	4f 90       	pop	r4
    7626:	3f 90       	pop	r3
    7628:	2f 90       	pop	r2
    762a:	08 95       	ret

0000762c <__divmodhi4>:
    762c:	97 fb       	bst	r25, 7
    762e:	07 2e       	mov	r0, r23
    7630:	16 f4       	brtc	.+4      	; 0x7636 <__divmodhi4+0xa>
    7632:	00 94       	com	r0
    7634:	06 d0       	rcall	.+12     	; 0x7642 <__divmodhi4_neg1>
    7636:	77 fd       	sbrc	r23, 7
    7638:	08 d0       	rcall	.+16     	; 0x764a <__divmodhi4_neg2>
    763a:	1a d0       	rcall	.+52     	; 0x7670 <__udivmodhi4>
    763c:	07 fc       	sbrc	r0, 7
    763e:	05 d0       	rcall	.+10     	; 0x764a <__divmodhi4_neg2>
    7640:	3e f4       	brtc	.+14     	; 0x7650 <__divmodhi4_exit>

00007642 <__divmodhi4_neg1>:
    7642:	90 95       	com	r25
    7644:	81 95       	neg	r24
    7646:	9f 4f       	sbci	r25, 0xFF	; 255
    7648:	08 95       	ret

0000764a <__divmodhi4_neg2>:
    764a:	70 95       	com	r23
    764c:	61 95       	neg	r22
    764e:	7f 4f       	sbci	r23, 0xFF	; 255

00007650 <__divmodhi4_exit>:
    7650:	08 95       	ret

00007652 <__umulhisi3>:
    7652:	a2 9f       	mul	r26, r18
    7654:	b0 01       	movw	r22, r0
    7656:	b3 9f       	mul	r27, r19
    7658:	c0 01       	movw	r24, r0
    765a:	a3 9f       	mul	r26, r19
    765c:	70 0d       	add	r23, r0
    765e:	81 1d       	adc	r24, r1
    7660:	11 24       	eor	r1, r1
    7662:	91 1d       	adc	r25, r1
    7664:	b2 9f       	mul	r27, r18
    7666:	70 0d       	add	r23, r0
    7668:	81 1d       	adc	r24, r1
    766a:	11 24       	eor	r1, r1
    766c:	91 1d       	adc	r25, r1
    766e:	08 95       	ret

00007670 <__udivmodhi4>:
    7670:	aa 1b       	sub	r26, r26
    7672:	bb 1b       	sub	r27, r27
    7674:	51 e1       	ldi	r21, 0x11	; 17
    7676:	07 c0       	rjmp	.+14     	; 0x7686 <__udivmodhi4_ep>

00007678 <__udivmodhi4_loop>:
    7678:	aa 1f       	adc	r26, r26
    767a:	bb 1f       	adc	r27, r27
    767c:	a6 17       	cp	r26, r22
    767e:	b7 07       	cpc	r27, r23
    7680:	10 f0       	brcs	.+4      	; 0x7686 <__udivmodhi4_ep>
    7682:	a6 1b       	sub	r26, r22
    7684:	b7 0b       	sbc	r27, r23

00007686 <__udivmodhi4_ep>:
    7686:	88 1f       	adc	r24, r24
    7688:	99 1f       	adc	r25, r25
    768a:	5a 95       	dec	r21
    768c:	a9 f7       	brne	.-22     	; 0x7678 <__udivmodhi4_loop>
    768e:	80 95       	com	r24
    7690:	90 95       	com	r25
    7692:	bc 01       	movw	r22, r24
    7694:	cd 01       	movw	r24, r26
    7696:	08 95       	ret

00007698 <__ftoa_engine>:
    7698:	28 30       	cpi	r18, 0x08	; 8
    769a:	08 f0       	brcs	.+2      	; 0x769e <__ftoa_engine+0x6>
    769c:	27 e0       	ldi	r18, 0x07	; 7
    769e:	33 27       	eor	r19, r19
    76a0:	da 01       	movw	r26, r20
    76a2:	99 0f       	add	r25, r25
    76a4:	31 1d       	adc	r19, r1
    76a6:	87 fd       	sbrc	r24, 7
    76a8:	91 60       	ori	r25, 0x01	; 1
    76aa:	00 96       	adiw	r24, 0x00	; 0
    76ac:	61 05       	cpc	r22, r1
    76ae:	71 05       	cpc	r23, r1
    76b0:	39 f4       	brne	.+14     	; 0x76c0 <__ftoa_engine+0x28>
    76b2:	32 60       	ori	r19, 0x02	; 2
    76b4:	2e 5f       	subi	r18, 0xFE	; 254
    76b6:	3d 93       	st	X+, r19
    76b8:	30 e3       	ldi	r19, 0x30	; 48
    76ba:	2a 95       	dec	r18
    76bc:	e1 f7       	brne	.-8      	; 0x76b6 <__ftoa_engine+0x1e>
    76be:	08 95       	ret
    76c0:	9f 3f       	cpi	r25, 0xFF	; 255
    76c2:	30 f0       	brcs	.+12     	; 0x76d0 <__ftoa_engine+0x38>
    76c4:	80 38       	cpi	r24, 0x80	; 128
    76c6:	71 05       	cpc	r23, r1
    76c8:	61 05       	cpc	r22, r1
    76ca:	09 f0       	breq	.+2      	; 0x76ce <__ftoa_engine+0x36>
    76cc:	3c 5f       	subi	r19, 0xFC	; 252
    76ce:	3c 5f       	subi	r19, 0xFC	; 252
    76d0:	3d 93       	st	X+, r19
    76d2:	91 30       	cpi	r25, 0x01	; 1
    76d4:	08 f0       	brcs	.+2      	; 0x76d8 <__ftoa_engine+0x40>
    76d6:	80 68       	ori	r24, 0x80	; 128
    76d8:	91 1d       	adc	r25, r1
    76da:	df 93       	push	r29
    76dc:	cf 93       	push	r28
    76de:	1f 93       	push	r17
    76e0:	0f 93       	push	r16
    76e2:	ff 92       	push	r15
    76e4:	ef 92       	push	r14
    76e6:	19 2f       	mov	r17, r25
    76e8:	98 7f       	andi	r25, 0xF8	; 248
    76ea:	96 95       	lsr	r25
    76ec:	e9 2f       	mov	r30, r25
    76ee:	96 95       	lsr	r25
    76f0:	96 95       	lsr	r25
    76f2:	e9 0f       	add	r30, r25
    76f4:	ff 27       	eor	r31, r31
    76f6:	ee 56       	subi	r30, 0x6E	; 110
    76f8:	fe 4f       	sbci	r31, 0xFE	; 254
    76fa:	99 27       	eor	r25, r25
    76fc:	33 27       	eor	r19, r19
    76fe:	ee 24       	eor	r14, r14
    7700:	ff 24       	eor	r15, r15
    7702:	a7 01       	movw	r20, r14
    7704:	e7 01       	movw	r28, r14
    7706:	05 90       	lpm	r0, Z+
    7708:	08 94       	sec
    770a:	07 94       	ror	r0
    770c:	28 f4       	brcc	.+10     	; 0x7718 <__ftoa_engine+0x80>
    770e:	36 0f       	add	r19, r22
    7710:	e7 1e       	adc	r14, r23
    7712:	f8 1e       	adc	r15, r24
    7714:	49 1f       	adc	r20, r25
    7716:	51 1d       	adc	r21, r1
    7718:	66 0f       	add	r22, r22
    771a:	77 1f       	adc	r23, r23
    771c:	88 1f       	adc	r24, r24
    771e:	99 1f       	adc	r25, r25
    7720:	06 94       	lsr	r0
    7722:	a1 f7       	brne	.-24     	; 0x770c <__ftoa_engine+0x74>
    7724:	05 90       	lpm	r0, Z+
    7726:	07 94       	ror	r0
    7728:	28 f4       	brcc	.+10     	; 0x7734 <__ftoa_engine+0x9c>
    772a:	e7 0e       	add	r14, r23
    772c:	f8 1e       	adc	r15, r24
    772e:	49 1f       	adc	r20, r25
    7730:	56 1f       	adc	r21, r22
    7732:	c1 1d       	adc	r28, r1
    7734:	77 0f       	add	r23, r23
    7736:	88 1f       	adc	r24, r24
    7738:	99 1f       	adc	r25, r25
    773a:	66 1f       	adc	r22, r22
    773c:	06 94       	lsr	r0
    773e:	a1 f7       	brne	.-24     	; 0x7728 <__ftoa_engine+0x90>
    7740:	05 90       	lpm	r0, Z+
    7742:	07 94       	ror	r0
    7744:	28 f4       	brcc	.+10     	; 0x7750 <__ftoa_engine+0xb8>
    7746:	f8 0e       	add	r15, r24
    7748:	49 1f       	adc	r20, r25
    774a:	56 1f       	adc	r21, r22
    774c:	c7 1f       	adc	r28, r23
    774e:	d1 1d       	adc	r29, r1
    7750:	88 0f       	add	r24, r24
    7752:	99 1f       	adc	r25, r25
    7754:	66 1f       	adc	r22, r22
    7756:	77 1f       	adc	r23, r23
    7758:	06 94       	lsr	r0
    775a:	a1 f7       	brne	.-24     	; 0x7744 <__ftoa_engine+0xac>
    775c:	05 90       	lpm	r0, Z+
    775e:	07 94       	ror	r0
    7760:	20 f4       	brcc	.+8      	; 0x776a <__ftoa_engine+0xd2>
    7762:	49 0f       	add	r20, r25
    7764:	56 1f       	adc	r21, r22
    7766:	c7 1f       	adc	r28, r23
    7768:	d8 1f       	adc	r29, r24
    776a:	99 0f       	add	r25, r25
    776c:	66 1f       	adc	r22, r22
    776e:	77 1f       	adc	r23, r23
    7770:	88 1f       	adc	r24, r24
    7772:	06 94       	lsr	r0
    7774:	a9 f7       	brne	.-22     	; 0x7760 <__ftoa_engine+0xc8>
    7776:	84 91       	lpm	r24, Z
    7778:	10 95       	com	r17
    777a:	17 70       	andi	r17, 0x07	; 7
    777c:	41 f0       	breq	.+16     	; 0x778e <__ftoa_engine+0xf6>
    777e:	d6 95       	lsr	r29
    7780:	c7 95       	ror	r28
    7782:	57 95       	ror	r21
    7784:	47 95       	ror	r20
    7786:	f7 94       	ror	r15
    7788:	e7 94       	ror	r14
    778a:	1a 95       	dec	r17
    778c:	c1 f7       	brne	.-16     	; 0x777e <__ftoa_engine+0xe6>
    778e:	e8 e3       	ldi	r30, 0x38	; 56
    7790:	f1 e0       	ldi	r31, 0x01	; 1
    7792:	68 94       	set
    7794:	15 90       	lpm	r1, Z+
    7796:	15 91       	lpm	r17, Z+
    7798:	35 91       	lpm	r19, Z+
    779a:	65 91       	lpm	r22, Z+
    779c:	95 91       	lpm	r25, Z+
    779e:	05 90       	lpm	r0, Z+
    77a0:	7f e2       	ldi	r23, 0x2F	; 47
    77a2:	73 95       	inc	r23
    77a4:	e1 18       	sub	r14, r1
    77a6:	f1 0a       	sbc	r15, r17
    77a8:	43 0b       	sbc	r20, r19
    77aa:	56 0b       	sbc	r21, r22
    77ac:	c9 0b       	sbc	r28, r25
    77ae:	d0 09       	sbc	r29, r0
    77b0:	c0 f7       	brcc	.-16     	; 0x77a2 <__ftoa_engine+0x10a>
    77b2:	e1 0c       	add	r14, r1
    77b4:	f1 1e       	adc	r15, r17
    77b6:	43 1f       	adc	r20, r19
    77b8:	56 1f       	adc	r21, r22
    77ba:	c9 1f       	adc	r28, r25
    77bc:	d0 1d       	adc	r29, r0
    77be:	7e f4       	brtc	.+30     	; 0x77de <__ftoa_engine+0x146>
    77c0:	70 33       	cpi	r23, 0x30	; 48
    77c2:	11 f4       	brne	.+4      	; 0x77c8 <__ftoa_engine+0x130>
    77c4:	8a 95       	dec	r24
    77c6:	e6 cf       	rjmp	.-52     	; 0x7794 <__ftoa_engine+0xfc>
    77c8:	e8 94       	clt
    77ca:	01 50       	subi	r16, 0x01	; 1
    77cc:	30 f0       	brcs	.+12     	; 0x77da <__ftoa_engine+0x142>
    77ce:	08 0f       	add	r16, r24
    77d0:	0a f4       	brpl	.+2      	; 0x77d4 <__ftoa_engine+0x13c>
    77d2:	00 27       	eor	r16, r16
    77d4:	02 17       	cp	r16, r18
    77d6:	08 f4       	brcc	.+2      	; 0x77da <__ftoa_engine+0x142>
    77d8:	20 2f       	mov	r18, r16
    77da:	23 95       	inc	r18
    77dc:	02 2f       	mov	r16, r18
    77de:	7a 33       	cpi	r23, 0x3A	; 58
    77e0:	28 f0       	brcs	.+10     	; 0x77ec <__ftoa_engine+0x154>
    77e2:	79 e3       	ldi	r23, 0x39	; 57
    77e4:	7d 93       	st	X+, r23
    77e6:	2a 95       	dec	r18
    77e8:	e9 f7       	brne	.-6      	; 0x77e4 <__ftoa_engine+0x14c>
    77ea:	10 c0       	rjmp	.+32     	; 0x780c <__ftoa_engine+0x174>
    77ec:	7d 93       	st	X+, r23
    77ee:	2a 95       	dec	r18
    77f0:	89 f6       	brne	.-94     	; 0x7794 <__ftoa_engine+0xfc>
    77f2:	06 94       	lsr	r0
    77f4:	97 95       	ror	r25
    77f6:	67 95       	ror	r22
    77f8:	37 95       	ror	r19
    77fa:	17 95       	ror	r17
    77fc:	17 94       	ror	r1
    77fe:	e1 18       	sub	r14, r1
    7800:	f1 0a       	sbc	r15, r17
    7802:	43 0b       	sbc	r20, r19
    7804:	56 0b       	sbc	r21, r22
    7806:	c9 0b       	sbc	r28, r25
    7808:	d0 09       	sbc	r29, r0
    780a:	98 f0       	brcs	.+38     	; 0x7832 <__ftoa_engine+0x19a>
    780c:	23 95       	inc	r18
    780e:	7e 91       	ld	r23, -X
    7810:	73 95       	inc	r23
    7812:	7a 33       	cpi	r23, 0x3A	; 58
    7814:	08 f0       	brcs	.+2      	; 0x7818 <__ftoa_engine+0x180>
    7816:	70 e3       	ldi	r23, 0x30	; 48
    7818:	7c 93       	st	X, r23
    781a:	20 13       	cpse	r18, r16
    781c:	b8 f7       	brcc	.-18     	; 0x780c <__ftoa_engine+0x174>
    781e:	7e 91       	ld	r23, -X
    7820:	70 61       	ori	r23, 0x10	; 16
    7822:	7d 93       	st	X+, r23
    7824:	30 f0       	brcs	.+12     	; 0x7832 <__ftoa_engine+0x19a>
    7826:	83 95       	inc	r24
    7828:	71 e3       	ldi	r23, 0x31	; 49
    782a:	7d 93       	st	X+, r23
    782c:	70 e3       	ldi	r23, 0x30	; 48
    782e:	2a 95       	dec	r18
    7830:	e1 f7       	brne	.-8      	; 0x782a <__ftoa_engine+0x192>
    7832:	11 24       	eor	r1, r1
    7834:	ef 90       	pop	r14
    7836:	ff 90       	pop	r15
    7838:	0f 91       	pop	r16
    783a:	1f 91       	pop	r17
    783c:	cf 91       	pop	r28
    783e:	df 91       	pop	r29
    7840:	99 27       	eor	r25, r25
    7842:	87 fd       	sbrc	r24, 7
    7844:	90 95       	com	r25
    7846:	08 95       	ret

00007848 <strnlen_P>:
    7848:	fc 01       	movw	r30, r24
    784a:	05 90       	lpm	r0, Z+
    784c:	61 50       	subi	r22, 0x01	; 1
    784e:	70 40       	sbci	r23, 0x00	; 0
    7850:	01 10       	cpse	r0, r1
    7852:	d8 f7       	brcc	.-10     	; 0x784a <strnlen_P+0x2>
    7854:	80 95       	com	r24
    7856:	90 95       	com	r25
    7858:	8e 0f       	add	r24, r30
    785a:	9f 1f       	adc	r25, r31
    785c:	08 95       	ret

0000785e <memcpy>:
    785e:	fb 01       	movw	r30, r22
    7860:	dc 01       	movw	r26, r24
    7862:	02 c0       	rjmp	.+4      	; 0x7868 <memcpy+0xa>
    7864:	01 90       	ld	r0, Z+
    7866:	0d 92       	st	X+, r0
    7868:	41 50       	subi	r20, 0x01	; 1
    786a:	50 40       	sbci	r21, 0x00	; 0
    786c:	d8 f7       	brcc	.-10     	; 0x7864 <memcpy+0x6>
    786e:	08 95       	ret

00007870 <memset>:
    7870:	dc 01       	movw	r26, r24
    7872:	01 c0       	rjmp	.+2      	; 0x7876 <memset+0x6>
    7874:	6d 93       	st	X+, r22
    7876:	41 50       	subi	r20, 0x01	; 1
    7878:	50 40       	sbci	r21, 0x00	; 0
    787a:	e0 f7       	brcc	.-8      	; 0x7874 <memset+0x4>
    787c:	08 95       	ret

0000787e <strnlen>:
    787e:	fc 01       	movw	r30, r24
    7880:	61 50       	subi	r22, 0x01	; 1
    7882:	70 40       	sbci	r23, 0x00	; 0
    7884:	01 90       	ld	r0, Z+
    7886:	01 10       	cpse	r0, r1
    7888:	d8 f7       	brcc	.-10     	; 0x7880 <strnlen+0x2>
    788a:	80 95       	com	r24
    788c:	90 95       	com	r25
    788e:	8e 0f       	add	r24, r30
    7890:	9f 1f       	adc	r25, r31
    7892:	08 95       	ret

00007894 <fputc>:
    7894:	0f 93       	push	r16
    7896:	1f 93       	push	r17
    7898:	cf 93       	push	r28
    789a:	df 93       	push	r29
    789c:	fb 01       	movw	r30, r22
    789e:	23 81       	ldd	r18, Z+3	; 0x03
    78a0:	21 fd       	sbrc	r18, 1
    78a2:	03 c0       	rjmp	.+6      	; 0x78aa <fputc+0x16>
    78a4:	8f ef       	ldi	r24, 0xFF	; 255
    78a6:	9f ef       	ldi	r25, 0xFF	; 255
    78a8:	2c c0       	rjmp	.+88     	; 0x7902 <fputc+0x6e>
    78aa:	22 ff       	sbrs	r18, 2
    78ac:	16 c0       	rjmp	.+44     	; 0x78da <fputc+0x46>
    78ae:	46 81       	ldd	r20, Z+6	; 0x06
    78b0:	57 81       	ldd	r21, Z+7	; 0x07
    78b2:	24 81       	ldd	r18, Z+4	; 0x04
    78b4:	35 81       	ldd	r19, Z+5	; 0x05
    78b6:	42 17       	cp	r20, r18
    78b8:	53 07       	cpc	r21, r19
    78ba:	44 f4       	brge	.+16     	; 0x78cc <fputc+0x38>
    78bc:	a0 81       	ld	r26, Z
    78be:	b1 81       	ldd	r27, Z+1	; 0x01
    78c0:	9d 01       	movw	r18, r26
    78c2:	2f 5f       	subi	r18, 0xFF	; 255
    78c4:	3f 4f       	sbci	r19, 0xFF	; 255
    78c6:	31 83       	std	Z+1, r19	; 0x01
    78c8:	20 83       	st	Z, r18
    78ca:	8c 93       	st	X, r24
    78cc:	26 81       	ldd	r18, Z+6	; 0x06
    78ce:	37 81       	ldd	r19, Z+7	; 0x07
    78d0:	2f 5f       	subi	r18, 0xFF	; 255
    78d2:	3f 4f       	sbci	r19, 0xFF	; 255
    78d4:	37 83       	std	Z+7, r19	; 0x07
    78d6:	26 83       	std	Z+6, r18	; 0x06
    78d8:	14 c0       	rjmp	.+40     	; 0x7902 <fputc+0x6e>
    78da:	8b 01       	movw	r16, r22
    78dc:	ec 01       	movw	r28, r24
    78de:	fb 01       	movw	r30, r22
    78e0:	00 84       	ldd	r0, Z+8	; 0x08
    78e2:	f1 85       	ldd	r31, Z+9	; 0x09
    78e4:	e0 2d       	mov	r30, r0
    78e6:	19 95       	eicall
    78e8:	89 2b       	or	r24, r25
    78ea:	e1 f6       	brne	.-72     	; 0x78a4 <fputc+0x10>
    78ec:	d8 01       	movw	r26, r16
    78ee:	16 96       	adiw	r26, 0x06	; 6
    78f0:	8d 91       	ld	r24, X+
    78f2:	9c 91       	ld	r25, X
    78f4:	17 97       	sbiw	r26, 0x07	; 7
    78f6:	01 96       	adiw	r24, 0x01	; 1
    78f8:	17 96       	adiw	r26, 0x07	; 7
    78fa:	9c 93       	st	X, r25
    78fc:	8e 93       	st	-X, r24
    78fe:	16 97       	sbiw	r26, 0x06	; 6
    7900:	ce 01       	movw	r24, r28
    7902:	df 91       	pop	r29
    7904:	cf 91       	pop	r28
    7906:	1f 91       	pop	r17
    7908:	0f 91       	pop	r16
    790a:	08 95       	ret

0000790c <vsprintf>:
    790c:	0f 93       	push	r16
    790e:	1f 93       	push	r17
    7910:	cf 93       	push	r28
    7912:	df 93       	push	r29
    7914:	cd b7       	in	r28, 0x3d	; 61
    7916:	de b7       	in	r29, 0x3e	; 62
    7918:	2e 97       	sbiw	r28, 0x0e	; 14
    791a:	0f b6       	in	r0, 0x3f	; 63
    791c:	f8 94       	cli
    791e:	de bf       	out	0x3e, r29	; 62
    7920:	0f be       	out	0x3f, r0	; 63
    7922:	cd bf       	out	0x3d, r28	; 61
    7924:	8c 01       	movw	r16, r24
    7926:	86 e0       	ldi	r24, 0x06	; 6
    7928:	8c 83       	std	Y+4, r24	; 0x04
    792a:	1a 83       	std	Y+2, r17	; 0x02
    792c:	09 83       	std	Y+1, r16	; 0x01
    792e:	8f ef       	ldi	r24, 0xFF	; 255
    7930:	9f e7       	ldi	r25, 0x7F	; 127
    7932:	9e 83       	std	Y+6, r25	; 0x06
    7934:	8d 83       	std	Y+5, r24	; 0x05
    7936:	ce 01       	movw	r24, r28
    7938:	01 96       	adiw	r24, 0x01	; 1
    793a:	ef da       	rcall	.-2594   	; 0x6f1a <vfprintf>
    793c:	ef 81       	ldd	r30, Y+7	; 0x07
    793e:	f8 85       	ldd	r31, Y+8	; 0x08
    7940:	e0 0f       	add	r30, r16
    7942:	f1 1f       	adc	r31, r17
    7944:	10 82       	st	Z, r1
    7946:	2e 96       	adiw	r28, 0x0e	; 14
    7948:	0f b6       	in	r0, 0x3f	; 63
    794a:	f8 94       	cli
    794c:	de bf       	out	0x3e, r29	; 62
    794e:	0f be       	out	0x3f, r0	; 63
    7950:	cd bf       	out	0x3d, r28	; 61
    7952:	df 91       	pop	r29
    7954:	cf 91       	pop	r28
    7956:	1f 91       	pop	r17
    7958:	0f 91       	pop	r16
    795a:	08 95       	ret

0000795c <__ultoa_invert>:
    795c:	fa 01       	movw	r30, r20
    795e:	aa 27       	eor	r26, r26
    7960:	28 30       	cpi	r18, 0x08	; 8
    7962:	51 f1       	breq	.+84     	; 0x79b8 <__ultoa_invert+0x5c>
    7964:	20 31       	cpi	r18, 0x10	; 16
    7966:	81 f1       	breq	.+96     	; 0x79c8 <__ultoa_invert+0x6c>
    7968:	e8 94       	clt
    796a:	6f 93       	push	r22
    796c:	6e 7f       	andi	r22, 0xFE	; 254
    796e:	6e 5f       	subi	r22, 0xFE	; 254
    7970:	7f 4f       	sbci	r23, 0xFF	; 255
    7972:	8f 4f       	sbci	r24, 0xFF	; 255
    7974:	9f 4f       	sbci	r25, 0xFF	; 255
    7976:	af 4f       	sbci	r26, 0xFF	; 255
    7978:	b1 e0       	ldi	r27, 0x01	; 1
    797a:	3e d0       	rcall	.+124    	; 0x79f8 <__ultoa_invert+0x9c>
    797c:	b4 e0       	ldi	r27, 0x04	; 4
    797e:	3c d0       	rcall	.+120    	; 0x79f8 <__ultoa_invert+0x9c>
    7980:	67 0f       	add	r22, r23
    7982:	78 1f       	adc	r23, r24
    7984:	89 1f       	adc	r24, r25
    7986:	9a 1f       	adc	r25, r26
    7988:	a1 1d       	adc	r26, r1
    798a:	68 0f       	add	r22, r24
    798c:	79 1f       	adc	r23, r25
    798e:	8a 1f       	adc	r24, r26
    7990:	91 1d       	adc	r25, r1
    7992:	a1 1d       	adc	r26, r1
    7994:	6a 0f       	add	r22, r26
    7996:	71 1d       	adc	r23, r1
    7998:	81 1d       	adc	r24, r1
    799a:	91 1d       	adc	r25, r1
    799c:	a1 1d       	adc	r26, r1
    799e:	20 d0       	rcall	.+64     	; 0x79e0 <__ultoa_invert+0x84>
    79a0:	09 f4       	brne	.+2      	; 0x79a4 <__ultoa_invert+0x48>
    79a2:	68 94       	set
    79a4:	3f 91       	pop	r19
    79a6:	2a e0       	ldi	r18, 0x0A	; 10
    79a8:	26 9f       	mul	r18, r22
    79aa:	11 24       	eor	r1, r1
    79ac:	30 19       	sub	r19, r0
    79ae:	30 5d       	subi	r19, 0xD0	; 208
    79b0:	31 93       	st	Z+, r19
    79b2:	de f6       	brtc	.-74     	; 0x796a <__ultoa_invert+0xe>
    79b4:	cf 01       	movw	r24, r30
    79b6:	08 95       	ret
    79b8:	46 2f       	mov	r20, r22
    79ba:	47 70       	andi	r20, 0x07	; 7
    79bc:	40 5d       	subi	r20, 0xD0	; 208
    79be:	41 93       	st	Z+, r20
    79c0:	b3 e0       	ldi	r27, 0x03	; 3
    79c2:	0f d0       	rcall	.+30     	; 0x79e2 <__ultoa_invert+0x86>
    79c4:	c9 f7       	brne	.-14     	; 0x79b8 <__ultoa_invert+0x5c>
    79c6:	f6 cf       	rjmp	.-20     	; 0x79b4 <__ultoa_invert+0x58>
    79c8:	46 2f       	mov	r20, r22
    79ca:	4f 70       	andi	r20, 0x0F	; 15
    79cc:	40 5d       	subi	r20, 0xD0	; 208
    79ce:	4a 33       	cpi	r20, 0x3A	; 58
    79d0:	18 f0       	brcs	.+6      	; 0x79d8 <__ultoa_invert+0x7c>
    79d2:	49 5d       	subi	r20, 0xD9	; 217
    79d4:	31 fd       	sbrc	r19, 1
    79d6:	40 52       	subi	r20, 0x20	; 32
    79d8:	41 93       	st	Z+, r20
    79da:	02 d0       	rcall	.+4      	; 0x79e0 <__ultoa_invert+0x84>
    79dc:	a9 f7       	brne	.-22     	; 0x79c8 <__ultoa_invert+0x6c>
    79de:	ea cf       	rjmp	.-44     	; 0x79b4 <__ultoa_invert+0x58>
    79e0:	b4 e0       	ldi	r27, 0x04	; 4
    79e2:	a6 95       	lsr	r26
    79e4:	97 95       	ror	r25
    79e6:	87 95       	ror	r24
    79e8:	77 95       	ror	r23
    79ea:	67 95       	ror	r22
    79ec:	ba 95       	dec	r27
    79ee:	c9 f7       	brne	.-14     	; 0x79e2 <__ultoa_invert+0x86>
    79f0:	00 97       	sbiw	r24, 0x00	; 0
    79f2:	61 05       	cpc	r22, r1
    79f4:	71 05       	cpc	r23, r1
    79f6:	08 95       	ret
    79f8:	9b 01       	movw	r18, r22
    79fa:	ac 01       	movw	r20, r24
    79fc:	0a 2e       	mov	r0, r26
    79fe:	06 94       	lsr	r0
    7a00:	57 95       	ror	r21
    7a02:	47 95       	ror	r20
    7a04:	37 95       	ror	r19
    7a06:	27 95       	ror	r18
    7a08:	ba 95       	dec	r27
    7a0a:	c9 f7       	brne	.-14     	; 0x79fe <__ultoa_invert+0xa2>
    7a0c:	62 0f       	add	r22, r18
    7a0e:	73 1f       	adc	r23, r19
    7a10:	84 1f       	adc	r24, r20
    7a12:	95 1f       	adc	r25, r21
    7a14:	a0 1d       	adc	r26, r0
    7a16:	08 95       	ret

00007a18 <_exit>:
    7a18:	f8 94       	cli

00007a1a <__stop_program>:
    7a1a:	ff cf       	rjmp	.-2      	; 0x7a1a <__stop_program>
