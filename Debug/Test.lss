
Test.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         000000d0  00800200  0000413a  000041ce  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         0000413a  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          000014ae  008002d0  008002d0  0000429e  2**0
                  ALLOC
  3 .comment      0000008c  00000000  00000000  0000429e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000432c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000728  00000000  00000000  0000436c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   0000a057  00000000  00000000  00004a94  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002099  00000000  00000000  0000eaeb  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005c80  00000000  00000000  00010b84  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000016fc  00000000  00000000  00016804  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002edb  00000000  00000000  00017f00  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00009a69  00000000  00000000  0001addb  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000808  00000000  00000000  00024844  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	f2 c0       	rjmp	.+484    	; 0x1e6 <__ctors_end>
       2:	00 00       	nop
       4:	10 c1       	rjmp	.+544    	; 0x226 <__bad_interrupt>
       6:	00 00       	nop
       8:	0e c1       	rjmp	.+540    	; 0x226 <__bad_interrupt>
       a:	00 00       	nop
       c:	0c 94 03 09 	jmp	0x1206	; 0x1206 <__vector_3>
      10:	0c 94 f2 08 	jmp	0x11e4	; 0x11e4 <__vector_4>
      14:	0c 94 14 09 	jmp	0x1228	; 0x1228 <__vector_5>
      18:	06 c1       	rjmp	.+524    	; 0x226 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	04 c1       	rjmp	.+520    	; 0x226 <__bad_interrupt>
      1e:	00 00       	nop
      20:	02 c1       	rjmp	.+516    	; 0x226 <__bad_interrupt>
      22:	00 00       	nop
      24:	00 c1       	rjmp	.+512    	; 0x226 <__bad_interrupt>
      26:	00 00       	nop
      28:	fe c0       	rjmp	.+508    	; 0x226 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	fc c0       	rjmp	.+504    	; 0x226 <__bad_interrupt>
      2e:	00 00       	nop
      30:	fa c0       	rjmp	.+500    	; 0x226 <__bad_interrupt>
      32:	00 00       	nop
      34:	f8 c0       	rjmp	.+496    	; 0x226 <__bad_interrupt>
      36:	00 00       	nop
      38:	f6 c0       	rjmp	.+492    	; 0x226 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	f4 c0       	rjmp	.+488    	; 0x226 <__bad_interrupt>
      3e:	00 00       	nop
      40:	f2 c0       	rjmp	.+484    	; 0x226 <__bad_interrupt>
      42:	00 00       	nop
      44:	f0 c0       	rjmp	.+480    	; 0x226 <__bad_interrupt>
      46:	00 00       	nop
      48:	ee c0       	rjmp	.+476    	; 0x226 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ec c0       	rjmp	.+472    	; 0x226 <__bad_interrupt>
      4e:	00 00       	nop
      50:	ea c0       	rjmp	.+468    	; 0x226 <__bad_interrupt>
      52:	00 00       	nop
      54:	e8 c0       	rjmp	.+464    	; 0x226 <__bad_interrupt>
      56:	00 00       	nop
      58:	e6 c0       	rjmp	.+460    	; 0x226 <__bad_interrupt>
      5a:	00 00       	nop
      5c:	e4 c0       	rjmp	.+456    	; 0x226 <__bad_interrupt>
      5e:	00 00       	nop
      60:	e2 c0       	rjmp	.+452    	; 0x226 <__bad_interrupt>
      62:	00 00       	nop
      64:	e0 c0       	rjmp	.+448    	; 0x226 <__bad_interrupt>
      66:	00 00       	nop
      68:	de c0       	rjmp	.+444    	; 0x226 <__bad_interrupt>
      6a:	00 00       	nop
      6c:	dc c0       	rjmp	.+440    	; 0x226 <__bad_interrupt>
      6e:	00 00       	nop
      70:	da c0       	rjmp	.+436    	; 0x226 <__bad_interrupt>
      72:	00 00       	nop
      74:	d8 c0       	rjmp	.+432    	; 0x226 <__bad_interrupt>
      76:	00 00       	nop
      78:	d6 c0       	rjmp	.+428    	; 0x226 <__bad_interrupt>
      7a:	00 00       	nop
      7c:	d4 c0       	rjmp	.+424    	; 0x226 <__bad_interrupt>
      7e:	00 00       	nop
      80:	0c 94 26 0c 	jmp	0x184c	; 0x184c <__vector_32>
      84:	d0 c0       	rjmp	.+416    	; 0x226 <__bad_interrupt>
      86:	00 00       	nop
      88:	ce c0       	rjmp	.+412    	; 0x226 <__bad_interrupt>
      8a:	00 00       	nop
      8c:	cc c0       	rjmp	.+408    	; 0x226 <__bad_interrupt>
      8e:	00 00       	nop
      90:	ca c0       	rjmp	.+404    	; 0x226 <__bad_interrupt>
      92:	00 00       	nop
      94:	c8 c0       	rjmp	.+400    	; 0x226 <__bad_interrupt>
      96:	00 00       	nop
      98:	c6 c0       	rjmp	.+396    	; 0x226 <__bad_interrupt>
      9a:	00 00       	nop
      9c:	c4 c0       	rjmp	.+392    	; 0x226 <__bad_interrupt>
      9e:	00 00       	nop
      a0:	c2 c0       	rjmp	.+388    	; 0x226 <__bad_interrupt>
      a2:	00 00       	nop
      a4:	c0 c0       	rjmp	.+384    	; 0x226 <__bad_interrupt>
      a6:	00 00       	nop
      a8:	be c0       	rjmp	.+380    	; 0x226 <__bad_interrupt>
      aa:	00 00       	nop
      ac:	bc c0       	rjmp	.+376    	; 0x226 <__bad_interrupt>
      ae:	00 00       	nop
      b0:	ba c0       	rjmp	.+372    	; 0x226 <__bad_interrupt>
      b2:	00 00       	nop
      b4:	b8 c0       	rjmp	.+368    	; 0x226 <__bad_interrupt>
      b6:	00 00       	nop
      b8:	b6 c0       	rjmp	.+364    	; 0x226 <__bad_interrupt>
      ba:	00 00       	nop
      bc:	b4 c0       	rjmp	.+360    	; 0x226 <__bad_interrupt>
      be:	00 00       	nop
      c0:	b2 c0       	rjmp	.+356    	; 0x226 <__bad_interrupt>
      c2:	00 00       	nop
      c4:	b0 c0       	rjmp	.+352    	; 0x226 <__bad_interrupt>
      c6:	00 00       	nop
      c8:	ae c0       	rjmp	.+348    	; 0x226 <__bad_interrupt>
      ca:	00 00       	nop
      cc:	0c 94 16 1b 	jmp	0x362c	; 0x362c <__vector_51>
      d0:	aa c0       	rjmp	.+340    	; 0x226 <__bad_interrupt>
      d2:	00 00       	nop
      d4:	a8 c0       	rjmp	.+336    	; 0x226 <__bad_interrupt>
      d6:	00 00       	nop
      d8:	a6 c0       	rjmp	.+332    	; 0x226 <__bad_interrupt>
      da:	00 00       	nop
      dc:	a4 c0       	rjmp	.+328    	; 0x226 <__bad_interrupt>
      de:	00 00       	nop
      e0:	a2 c0       	rjmp	.+324    	; 0x226 <__bad_interrupt>
	...

000000e4 <__trampolines_end>:
      e4:	6e 61       	ori	r22, 0x1E	; 30
      e6:	6e 00       	.word	0x006e	; ????

000000e8 <__c.2332>:
      e8:	69 6e 66 00 00 40 7a 10 f3 5a 00 a0 72 4e 18 09     inf..@z..Z..rN..
      f8:	00 10 a5 d4 e8 00 00 e8 76 48 17 00 00 e4 0b 54     ........vH.....T
     108:	02 00 00 ca 9a 3b 00 00 00 e1 f5 05 00 00 80 96     .....;..........
     118:	98 00 00 00 40 42 0f 00 00 00 a0 86 01 00 00 00     ....@B..........
     128:	10 27 00 00 00 00 e8 03 00 00 00 00 64 00 00 00     .'..........d...
     138:	00 00 0a 00 00 00 00 00 01 00 00 00 00 00 2c 76     ..............,v
     148:	d8 88 dc 67 4f 08 23 df c1 df ae 59 e1 b1 b7 96     ...gO.#....Y....
     158:	e5 e3 e4 53 c6 3a e6 51 99 76 96 e8 e6 c2 84 26     ...S.:.Q.v.....&
     168:	eb 89 8c 9b 62 ed 40 7c 6f fc ef bc 9c 9f 40 f2     ....b.@|o.....@.
     178:	ba a5 6f a5 f4 90 05 5a 2a f7 5c 93 6b 6c f9 67     ..o....Z*.\.kl.g
     188:	6d c1 1b fc e0 e4 0d 47 fe f5 20 e6 b5 00 d0 ed     m......G.. .....
     198:	90 2e 03 00 94 35 77 05 00 80 84 1e 08 00 00 20     .....5w........ 
     1a8:	4e 0a 00 00 00 c8 0c 33 33 33 33 0f 98 6e 12 83     N......3333..n..
     1b8:	11 41 ef 8d 21 14 89 3b e6 55 16 cf fe e6 db 18     .A..!..;.U......
     1c8:	d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb e4 24 20 32     ..K8..|......$ 2
     1d8:	84 72 5e 22 81 00 c9 f1 24 ec a1 e5 3d 27           .r^"....$...='

000001e6 <__ctors_end>:
     1e6:	11 24       	eor	r1, r1
     1e8:	1f be       	out	0x3f, r1	; 63
     1ea:	cf ef       	ldi	r28, 0xFF	; 255
     1ec:	d1 e2       	ldi	r29, 0x21	; 33
     1ee:	de bf       	out	0x3e, r29	; 62
     1f0:	cd bf       	out	0x3d, r28	; 61
     1f2:	00 e0       	ldi	r16, 0x00	; 0
     1f4:	0c bf       	out	0x3c, r16	; 60

000001f6 <__do_copy_data>:
     1f6:	12 e0       	ldi	r17, 0x02	; 2
     1f8:	a0 e0       	ldi	r26, 0x00	; 0
     1fa:	b2 e0       	ldi	r27, 0x02	; 2
     1fc:	ea e3       	ldi	r30, 0x3A	; 58
     1fe:	f1 e4       	ldi	r31, 0x41	; 65
     200:	00 e0       	ldi	r16, 0x00	; 0
     202:	0b bf       	out	0x3b, r16	; 59
     204:	02 c0       	rjmp	.+4      	; 0x20a <__do_copy_data+0x14>
     206:	07 90       	elpm	r0, Z+
     208:	0d 92       	st	X+, r0
     20a:	a0 3d       	cpi	r26, 0xD0	; 208
     20c:	b1 07       	cpc	r27, r17
     20e:	d9 f7       	brne	.-10     	; 0x206 <__do_copy_data+0x10>

00000210 <__do_clear_bss>:
     210:	27 e1       	ldi	r18, 0x17	; 23
     212:	a0 ed       	ldi	r26, 0xD0	; 208
     214:	b2 e0       	ldi	r27, 0x02	; 2
     216:	01 c0       	rjmp	.+2      	; 0x21a <.do_clear_bss_start>

00000218 <.do_clear_bss_loop>:
     218:	1d 92       	st	X+, r1

0000021a <.do_clear_bss_start>:
     21a:	ae 37       	cpi	r26, 0x7E	; 126
     21c:	b2 07       	cpc	r27, r18
     21e:	e1 f7       	brne	.-8      	; 0x218 <.do_clear_bss_loop>
     220:	a4 d7       	rcall	.+3912   	; 0x116a <main>
     222:	0c 94 9b 20 	jmp	0x4136	; 0x4136 <_exit>

00000226 <__bad_interrupt>:
     226:	ec ce       	rjmp	.-552    	; 0x0 <__vectors>

00000228 <arq_init>:
    con->sequence_number = (con->sequence_number+1) & 127;
    network_send(con->remote_address, PROTOCOL_ARQ, data, len+2);
  } 
  
  xSemaphoreGive(con->mutex);
}
     228:	cf 93       	push	r28
     22a:	df 93       	push	r29
     22c:	64 ea       	ldi	r22, 0xA4	; 164
     22e:	71 e0       	ldi	r23, 0x01	; 1
     230:	81 e0       	ldi	r24, 0x01	; 1
     232:	0e 94 68 0a 	call	0x14d0	; 0x14d0 <network_set_callback>
     236:	10 92 d1 02 	sts	0x02D1, r1	; 0x8002d1 <__data_end+0x1>
     23a:	10 92 d0 02 	sts	0x02D0, r1	; 0x8002d0 <__data_end>
     23e:	c2 ed       	ldi	r28, 0xD2	; 210
     240:	d2 e0       	ldi	r29, 0x02	; 2
     242:	8d e8       	ldi	r24, 0x8D	; 141
     244:	fe 01       	movw	r30, r28
     246:	11 92       	st	Z+, r1
     248:	8a 95       	dec	r24
     24a:	e9 f7       	brne	.-6      	; 0x246 <arq_init+0x1e>
     24c:	81 e0       	ldi	r24, 0x01	; 1
     24e:	0e 94 28 0c 	call	0x1850	; 0x1850 <xQueueCreateMutex>
     252:	90 93 5c 03 	sts	0x035C, r25	; 0x80035c <connections+0x8a>
     256:	80 93 5b 03 	sts	0x035B, r24	; 0x80035b <connections+0x89>
     25a:	18 82       	st	Y, r1
     25c:	df 91       	pop	r29
     25e:	cf 91       	pop	r28
     260:	08 95       	ret

00000262 <arq_send_ack>:
     262:	cf 93       	push	r28
     264:	df 93       	push	r29
     266:	1f 92       	push	r1
     268:	1f 92       	push	r1
     26a:	cd b7       	in	r28, 0x3d	; 61
     26c:	de b7       	in	r29, 0x3e	; 62
     26e:	81 11       	cpse	r24, r1
     270:	14 c0       	rjmp	.+40     	; 0x29a <arq_send_ack+0x38>
     272:	80 91 d2 02 	lds	r24, 0x02D2	; 0x8002d2 <connections>
     276:	82 30       	cpi	r24, 0x02	; 2
     278:	91 f4       	brne	.+36     	; 0x29e <arq_send_ack+0x3c>
     27a:	66 23       	and	r22, r22
     27c:	94 f0       	brlt	.+36     	; 0x2a2 <arq_send_ack+0x40>
     27e:	81 e0       	ldi	r24, 0x01	; 1
     280:	89 83       	std	Y+1, r24	; 0x01
     282:	6a 83       	std	Y+2, r22	; 0x02
     284:	22 e0       	ldi	r18, 0x02	; 2
     286:	30 e0       	ldi	r19, 0x00	; 0
     288:	ae 01       	movw	r20, r28
     28a:	4f 5f       	subi	r20, 0xFF	; 255
     28c:	5f 4f       	sbci	r21, 0xFF	; 255
     28e:	61 e0       	ldi	r22, 0x01	; 1
     290:	80 91 f2 02 	lds	r24, 0x02F2	; 0x8002f2 <connections+0x20>
     294:	0e 94 73 0a 	call	0x14e6	; 0x14e6 <network_send>
     298:	05 c0       	rjmp	.+10     	; 0x2a4 <arq_send_ack+0x42>
     29a:	80 e0       	ldi	r24, 0x00	; 0
     29c:	03 c0       	rjmp	.+6      	; 0x2a4 <arq_send_ack+0x42>
     29e:	80 e0       	ldi	r24, 0x00	; 0
     2a0:	01 c0       	rjmp	.+2      	; 0x2a4 <arq_send_ack+0x42>
     2a2:	80 e0       	ldi	r24, 0x00	; 0
     2a4:	0f 90       	pop	r0
     2a6:	0f 90       	pop	r0
     2a8:	df 91       	pop	r29
     2aa:	cf 91       	pop	r28
     2ac:	08 95       	ret

000002ae <arq_reassembly>:

void arq_reassembly(arq_connection id, uint8_t *data, uint16_t len) { 
     2ae:	0f 93       	push	r16
     2b0:	1f 93       	push	r17
     2b2:	cf 93       	push	r28
     2b4:	df 93       	push	r29
     2b6:	ea 01       	movw	r28, r20
  if(id >= MAX_CONNECTIONS) return;
     2b8:	81 11       	cpse	r24, r1
     2ba:	41 c0       	rjmp	.+130    	; 0x33e <arq_reassembly+0x90>
  
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
     2bc:	80 91 f5 02 	lds	r24, 0x02F5	; 0x8002f5 <connections+0x23>
     2c0:	90 91 f6 02 	lds	r25, 0x02F6	; 0x8002f6 <connections+0x24>
     2c4:	89 2b       	or	r24, r25
     2c6:	99 f4       	brne	.+38     	; 0x2ee <arq_reassembly+0x40>
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
     2c8:	db 01       	movw	r26, r22
     2ca:	11 96       	adiw	r26, 0x01	; 1
     2cc:	8c 91       	ld	r24, X
     2ce:	11 97       	sbiw	r26, 0x01	; 1
     2d0:	90 e0       	ldi	r25, 0x00	; 0
     2d2:	98 2f       	mov	r25, r24
     2d4:	88 27       	eor	r24, r24
     2d6:	2c 91       	ld	r18, X
     2d8:	82 2b       	or	r24, r18
     2da:	90 93 f6 02 	sts	0x02F6, r25	; 0x8002f6 <connections+0x24>
     2de:	80 93 f5 02 	sts	0x02F5, r24	; 0x8002f5 <connections+0x23>
    len-=2; // Remove the header from the length, left with the length of the payload
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
     2e2:	85 36       	cpi	r24, 0x65	; 101
     2e4:	91 05       	cpc	r25, r1
     2e6:	58 f5       	brcc	.+86     	; 0x33e <arq_reassembly+0x90>
  arq_connection_t *con = &connections[id];
  // Dont need to take the mutex because this funcion is only called from receiver, and at that point the task already holds the mutex. Could use a recursive mutex, but it is not necessary
  
  if(con->receive_message_length == 0) { // Not in the midle of receiving, so this is the start of a message
    con->receive_message_length = data[0] | (data[1] << 8); //First two bytes of messsage is length
    len-=2; // Remove the header from the length, left with the length of the payload
     2e8:	22 97       	sbiw	r28, 0x02	; 2
    data+=2; // Move the pointer to skip past the length bytes and point to the actual data
     2ea:	6e 5f       	subi	r22, 0xFE	; 254
     2ec:	7f 4f       	sbci	r23, 0xFF	; 255
    
    if(con->receive_message_length > MAX_MESSAGE_SIZE) {
      return;
    }
  } 
  memcpy(con->message+con->num_received_bytes, data, len);
     2ee:	02 ed       	ldi	r16, 0xD2	; 210
     2f0:	12 e0       	ldi	r17, 0x02	; 2
     2f2:	f8 01       	movw	r30, r16
     2f4:	81 a1       	ldd	r24, Z+33	; 0x21
     2f6:	92 a1       	ldd	r25, Z+34	; 0x22
     2f8:	ae 01       	movw	r20, r28
     2fa:	89 50       	subi	r24, 0x09	; 9
     2fc:	9d 4f       	sbci	r25, 0xFD	; 253
     2fe:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
  con->num_received_bytes += len;
     302:	d8 01       	movw	r26, r16
     304:	91 96       	adiw	r26, 0x21	; 33
     306:	6d 91       	ld	r22, X+
     308:	7c 91       	ld	r23, X
     30a:	92 97       	sbiw	r26, 0x22	; 34
     30c:	6c 0f       	add	r22, r28
     30e:	7d 1f       	adc	r23, r29
     310:	92 96       	adiw	r26, 0x22	; 34
     312:	7c 93       	st	X, r23
     314:	6e 93       	st	-X, r22
     316:	91 97       	sbiw	r26, 0x21	; 33
  
  if(con->num_received_bytes == con->receive_message_length) {
     318:	93 96       	adiw	r26, 0x23	; 35
     31a:	8d 91       	ld	r24, X+
     31c:	9c 91       	ld	r25, X
     31e:	94 97       	sbiw	r26, 0x24	; 36
     320:	68 17       	cp	r22, r24
     322:	79 07       	cpc	r23, r25
     324:	61 f4       	brne	.+24     	; 0x33e <arq_reassembly+0x90>
    con->callback_data_received(con->message, con->num_received_bytes);
     326:	57 96       	adiw	r26, 0x17	; 23
     328:	ed 91       	ld	r30, X+
     32a:	fc 91       	ld	r31, X
     32c:	58 97       	sbiw	r26, 0x18	; 24
     32e:	87 ef       	ldi	r24, 0xF7	; 247
     330:	92 e0       	ldi	r25, 0x02	; 2
     332:	19 95       	eicall
    con->num_received_bytes = con->receive_message_length = 0;
     334:	f8 01       	movw	r30, r16
     336:	14 a2       	std	Z+36, r1	; 0x24
     338:	13 a2       	std	Z+35, r1	; 0x23
     33a:	12 a2       	std	Z+34, r1	; 0x22
     33c:	11 a2       	std	Z+33, r1	; 0x21
  }
}
     33e:	df 91       	pop	r29
     340:	cf 91       	pop	r28
     342:	1f 91       	pop	r17
     344:	0f 91       	pop	r16
     346:	08 95       	ret

00000348 <receiver>:
  data[0] = TYPE_ACK;
  data[1] = sequence_number;
  return network_send(con->remote_address, PROTOCOL_ARQ, data, 2);
}

void receiver(uint8_t address, uint8_t *data, uint16_t len) {
     348:	9f 92       	push	r9
     34a:	af 92       	push	r10
     34c:	bf 92       	push	r11
     34e:	cf 92       	push	r12
     350:	df 92       	push	r13
     352:	ef 92       	push	r14
     354:	ff 92       	push	r15
     356:	0f 93       	push	r16
     358:	1f 93       	push	r17
     35a:	cf 93       	push	r28
     35c:	df 93       	push	r29
     35e:	1f 92       	push	r1
     360:	cd b7       	in	r28, 0x3d	; 61
     362:	de b7       	in	r29, 0x3e	; 62
     364:	8b 01       	movw	r16, r22
     366:	5a 01       	movw	r10, r20
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
     368:	90 91 f2 02 	lds	r25, 0x02F2	; 0x8002f2 <connections+0x20>
     36c:	98 13       	cpse	r25, r24
     36e:	b8 c0       	rjmp	.+368    	; 0x4e0 <__FUSE_REGION_LENGTH__+0xe0>
     370:	90 91 d2 02 	lds	r25, 0x02D2	; 0x8002d2 <connections>
     374:	99 23       	and	r25, r25
     376:	09 f4       	brne	.+2      	; 0x37a <receiver+0x32>
     378:	b3 c0       	rjmp	.+358    	; 0x4e0 <__FUSE_REGION_LENGTH__+0xe0>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     37a:	fb 01       	movw	r30, r22
     37c:	d0 80       	ld	r13, Z
  arq_connection_t *con = NULL;
  uint8_t id;
  uint8_t i;
  for(i=0;i<MAX_CONNECTIONS;i++) {
    if(connections[i].remote_address == address && connections[i].status != STATUS_NONE) {
      con = &connections[i];
     37e:	0f 2e       	mov	r0, r31
     380:	f2 ed       	ldi	r31, 0xD2	; 210
     382:	ef 2e       	mov	r14, r31
     384:	f2 e0       	ldi	r31, 0x02	; 2
     386:	ff 2e       	mov	r15, r31
     388:	f0 2d       	mov	r31, r0
     38a:	13 c0       	rjmp	.+38     	; 0x3b2 <receiver+0x6a>
    }
  }
  uint8_t type = data[0];
  
  if(con == NULL && type != TYPE_SYN) return;
  if(con == NULL && type == TYPE_SYN && listening_task != NULL) {
     38c:	e0 91 d0 02 	lds	r30, 0x02D0	; 0x8002d0 <__data_end>
     390:	f0 91 d1 02 	lds	r31, 0x02D1	; 0x8002d1 <__data_end+0x1>
     394:	30 97       	sbiw	r30, 0x00	; 0
     396:	59 f0       	breq	.+22     	; 0x3ae <receiver+0x66>
    xTaskNotify(listening_task, address, eSetValueWithOverwrite);
     398:	48 2f       	mov	r20, r24
     39a:	50 e0       	ldi	r21, 0x00	; 0
     39c:	60 e0       	ldi	r22, 0x00	; 0
     39e:	70 e0       	ldi	r23, 0x00	; 0
     3a0:	00 e0       	ldi	r16, 0x00	; 0
     3a2:	10 e0       	ldi	r17, 0x00	; 0
     3a4:	23 e0       	ldi	r18, 0x03	; 3
     3a6:	cf 01       	movw	r24, r30
     3a8:	0e 94 26 19 	call	0x324c	; 0x324c <xTaskGenericNotify>
    return;
     3ac:	aa c0       	rjmp	.+340    	; 0x502 <__FUSE_REGION_LENGTH__+0x102>
     3ae:	e1 2c       	mov	r14, r1
     3b0:	f1 2c       	mov	r15, r1
  }
  xSemaphoreTake(con->mutex, portMAX_DELAY);
     3b2:	20 e0       	ldi	r18, 0x00	; 0
     3b4:	4f ef       	ldi	r20, 0xFF	; 255
     3b6:	5f ef       	ldi	r21, 0xFF	; 255
     3b8:	60 e0       	ldi	r22, 0x00	; 0
     3ba:	70 e0       	ldi	r23, 0x00	; 0
     3bc:	f7 01       	movw	r30, r14
     3be:	e7 57       	subi	r30, 0x77	; 119
     3c0:	ff 4f       	sbci	r31, 0xFF	; 255
     3c2:	80 81       	ld	r24, Z
     3c4:	91 81       	ldd	r25, Z+1	; 0x01
     3c6:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <xQueueGenericReceive>
  
  if(con->status == STATUS_CLOSED || con->status == STATUS_NONE || len == 0 || data == NULL) {
     3ca:	f7 01       	movw	r30, r14
     3cc:	80 81       	ld	r24, Z
     3ce:	82 30       	cpi	r24, 0x02	; 2
     3d0:	30 f0       	brcs	.+12     	; 0x3de <receiver+0x96>
     3d2:	a1 14       	cp	r10, r1
     3d4:	b1 04       	cpc	r11, r1
     3d6:	19 f0       	breq	.+6      	; 0x3de <receiver+0x96>
     3d8:	01 15       	cp	r16, r1
     3da:	11 05       	cpc	r17, r1
     3dc:	51 f4       	brne	.+20     	; 0x3f2 <receiver+0xaa>
    xSemaphoreGive(con->mutex);
     3de:	f7 01       	movw	r30, r14
     3e0:	e7 57       	subi	r30, 0x77	; 119
     3e2:	ff 4f       	sbci	r31, 0xFF	; 255
     3e4:	60 e0       	ldi	r22, 0x00	; 0
     3e6:	70 e0       	ldi	r23, 0x00	; 0
     3e8:	80 81       	ld	r24, Z
     3ea:	91 81       	ldd	r25, Z+1	; 0x01
     3ec:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <xQueueGive>
    return;
     3f0:	88 c0       	rjmp	.+272    	; 0x502 <__FUSE_REGION_LENGTH__+0x102>
  }
  
  if(con->status == STATUS_CONNECTING && type == TYPE_SYNACK) {
     3f2:	83 30       	cpi	r24, 0x03	; 3
     3f4:	21 f5       	brne	.+72     	; 0x43e <__FUSE_REGION_LENGTH__+0x3e>
     3f6:	f3 e0       	ldi	r31, 0x03	; 3
     3f8:	df 12       	cpse	r13, r31
     3fa:	21 c0       	rjmp	.+66     	; 0x43e <__FUSE_REGION_LENGTH__+0x3e>
    if(con->blocked_task != NULL) {
     3fc:	f7 01       	movw	r30, r14
     3fe:	e5 57       	subi	r30, 0x75	; 117
     400:	ff 4f       	sbci	r31, 0xFF	; 255
     402:	80 81       	ld	r24, Z
     404:	91 81       	ldd	r25, Z+1	; 0x01
     406:	00 97       	sbiw	r24, 0x00	; 0
     408:	81 f0       	breq	.+32     	; 0x42a <__FUSE_REGION_LENGTH__+0x2a>
      xTaskNotifyGive(con->blocked_task);
     40a:	00 e0       	ldi	r16, 0x00	; 0
     40c:	10 e0       	ldi	r17, 0x00	; 0
     40e:	22 e0       	ldi	r18, 0x02	; 2
     410:	40 e0       	ldi	r20, 0x00	; 0
     412:	50 e0       	ldi	r21, 0x00	; 0
     414:	ba 01       	movw	r22, r20
     416:	0e 94 26 19 	call	0x324c	; 0x324c <xTaskGenericNotify>
      con->blocked_task = NULL;
     41a:	f7 01       	movw	r30, r14
     41c:	e5 57       	subi	r30, 0x75	; 117
     41e:	ff 4f       	sbci	r31, 0xFF	; 255
     420:	11 82       	std	Z+1, r1	; 0x01
     422:	10 82       	st	Z, r1
      arq_send_ack(id, 0x00);
     424:	60 e0       	ldi	r22, 0x00	; 0
     426:	80 e0       	ldi	r24, 0x00	; 0
     428:	1c df       	rcall	.-456    	; 0x262 <arq_send_ack>
    }
    
    xSemaphoreGive(con->mutex);
     42a:	f7 01       	movw	r30, r14
     42c:	e7 57       	subi	r30, 0x77	; 119
     42e:	ff 4f       	sbci	r31, 0xFF	; 255
     430:	60 e0       	ldi	r22, 0x00	; 0
     432:	70 e0       	ldi	r23, 0x00	; 0
     434:	80 81       	ld	r24, Z
     436:	91 81       	ldd	r25, Z+1	; 0x01
     438:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <xQueueGive>
    return;
     43c:	62 c0       	rjmp	.+196    	; 0x502 <__FUSE_REGION_LENGTH__+0x102>
  }
  
  uint8_t sequence = data[1];
     43e:	f8 01       	movw	r30, r16
     440:	c1 80       	ldd	r12, Z+1	; 0x01
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
     442:	dd 20       	and	r13, r13
     444:	09 f4       	brne	.+2      	; 0x448 <__FUSE_REGION_LENGTH__+0x48>
     446:	52 c0       	rjmp	.+164    	; 0x4ec <__FUSE_REGION_LENGTH__+0xec>
     448:	f4 e0       	ldi	r31, 0x04	; 4
     44a:	df 12       	cpse	r13, r31
     44c:	13 c0       	rjmp	.+38     	; 0x474 <__FUSE_REGION_LENGTH__+0x74>
     44e:	53 c0       	rjmp	.+166    	; 0x4f6 <__FUSE_REGION_LENGTH__+0xf6>
    if(sequence == con->request_number) {
      if(type == TYPE_DATA) arq_reassembly(id, &data[2], len-2);
     450:	a5 01       	movw	r20, r10
     452:	42 50       	subi	r20, 0x02	; 2
     454:	51 09       	sbc	r21, r1
     456:	b8 01       	movw	r22, r16
     458:	6e 5f       	subi	r22, 0xFE	; 254
     45a:	7f 4f       	sbci	r23, 0xFF	; 255
     45c:	80 e0       	ldi	r24, 0x00	; 0
     45e:	27 df       	rcall	.-434    	; 0x2ae <arq_reassembly>
      con->request_number = (con->request_number+1) & 127;
     460:	f7 01       	movw	r30, r14
     462:	82 8d       	ldd	r24, Z+26	; 0x1a
     464:	8f 5f       	subi	r24, 0xFF	; 255
     466:	8f 77       	andi	r24, 0x7F	; 127
     468:	82 8f       	std	Z+26, r24	; 0x1a
    }
    arq_send_ack(id, con->request_number);
     46a:	f7 01       	movw	r30, r14
     46c:	62 8d       	ldd	r22, Z+26	; 0x1a
     46e:	80 e0       	ldi	r24, 0x00	; 0
     470:	f8 de       	rcall	.-528    	; 0x262 <arq_send_ack>
     472:	2c c0       	rjmp	.+88     	; 0x4cc <__FUSE_REGION_LENGTH__+0xcc>
  } else if(type == TYPE_ACK) {
     474:	f1 e0       	ldi	r31, 0x01	; 1
     476:	df 12       	cpse	r13, r31
     478:	29 c0       	rjmp	.+82     	; 0x4cc <__FUSE_REGION_LENGTH__+0xcc>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
     47a:	f7 01       	movw	r30, r14
     47c:	83 8d       	ldd	r24, Z+27	; 0x1b
     47e:	fc 2d       	mov	r31, r12
     480:	f8 1b       	sub	r31, r24
     482:	8f 2f       	mov	r24, r31
     484:	8f 77       	andi	r24, 0x7F	; 127
     486:	98 2e       	mov	r9, r24
    if(count != 0) {
     488:	09 f1       	breq	.+66     	; 0x4cc <__FUSE_REGION_LENGTH__+0xcc>
     48a:	d1 2c       	mov	r13, r1
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     48c:	57 01       	movw	r10, r14
     48e:	8b e0       	ldi	r24, 0x0B	; 11
     490:	a8 0e       	add	r10, r24
     492:	b1 1c       	adc	r11, r1
        buffer_remove(&con->send_buffer, NULL, len);
     494:	87 01       	movw	r16, r14
     496:	0f 5f       	subi	r16, 0xFF	; 255
     498:	1f 4f       	sbci	r17, 0xFF	; 255
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
        buffer_remove(&con->segment_lengths, &len, 2);
     49a:	42 e0       	ldi	r20, 0x02	; 2
     49c:	50 e0       	ldi	r21, 0x00	; 0
     49e:	be 01       	movw	r22, r28
     4a0:	6f 5f       	subi	r22, 0xFF	; 255
     4a2:	7f 4f       	sbci	r23, 0xFF	; 255
     4a4:	c5 01       	movw	r24, r10
     4a6:	fb d0       	rcall	.+502    	; 0x69e <buffer_remove>
        buffer_remove(&con->send_buffer, NULL, len);
     4a8:	49 81       	ldd	r20, Y+1	; 0x01
     4aa:	50 e0       	ldi	r21, 0x00	; 0
     4ac:	60 e0       	ldi	r22, 0x00	; 0
     4ae:	70 e0       	ldi	r23, 0x00	; 0
     4b0:	c8 01       	movw	r24, r16
     4b2:	f5 d0       	rcall	.+490    	; 0x69e <buffer_remove>
    uint8_t i;
    uint8_t count;
    count = (sequence-con->sequence_base) & 127;
    if(count != 0) {
      uint8_t len;
      for(i=0;i<count;i++) {
     4b4:	d3 94       	inc	r13
     4b6:	9d 10       	cpse	r9, r13
     4b8:	f0 cf       	rjmp	.-32     	; 0x49a <__FUSE_REGION_LENGTH__+0x9a>
        buffer_remove(&con->segment_lengths, &len, 2);
        buffer_remove(&con->send_buffer, NULL, len);
      }
      con->sequence_base = sequence;
     4ba:	f7 01       	movw	r30, r14
     4bc:	c3 8e       	std	Z+27, r12	; 0x1b

      con->timer = 0;
     4be:	14 8e       	std	Z+28, r1	; 0x1c
      con->timeout = 0;
     4c0:	16 8e       	std	Z+30, r1	; 0x1e
     4c2:	15 8e       	std	Z+29, r1	; 0x1d
      if(con->sequence_base == con->sequence_number) con->timer_started = 0; // No more un-acked packets
     4c4:	81 8d       	ldd	r24, Z+25	; 0x19
     4c6:	c8 12       	cpse	r12, r24
     4c8:	01 c0       	rjmp	.+2      	; 0x4cc <__FUSE_REGION_LENGTH__+0xcc>
     4ca:	17 8e       	std	Z+31, r1	; 0x1f
    }
  }
  
  xSemaphoreGive(con->mutex);
     4cc:	f7 01       	movw	r30, r14
     4ce:	e7 57       	subi	r30, 0x77	; 119
     4d0:	ff 4f       	sbci	r31, 0xFF	; 255
     4d2:	60 e0       	ldi	r22, 0x00	; 0
     4d4:	70 e0       	ldi	r23, 0x00	; 0
     4d6:	80 81       	ld	r24, Z
     4d8:	91 81       	ldd	r25, Z+1	; 0x01
     4da:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <xQueueGive>
     4de:	11 c0       	rjmp	.+34     	; 0x502 <__FUSE_REGION_LENGTH__+0x102>
      con = &connections[i];
      id = i;
      break;
    }
  }
  uint8_t type = data[0];
     4e0:	f8 01       	movw	r30, r16
     4e2:	d0 80       	ld	r13, Z
  
  if(con == NULL && type != TYPE_SYN) return;
     4e4:	f2 e0       	ldi	r31, 0x02	; 2
     4e6:	df 12       	cpse	r13, r31
     4e8:	0c c0       	rjmp	.+24     	; 0x502 <__FUSE_REGION_LENGTH__+0x102>
     4ea:	50 cf       	rjmp	.-352    	; 0x38c <receiver+0x44>
    return;
  }
  
  uint8_t sequence = data[1];
  if(type == TYPE_DATA || type == TYPE_ALIVE_TEST) {
    if(sequence == con->request_number) {
     4ec:	f7 01       	movw	r30, r14
     4ee:	82 8d       	ldd	r24, Z+26	; 0x1a
     4f0:	c8 12       	cpse	r12, r24
     4f2:	bb cf       	rjmp	.-138    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
     4f4:	ad cf       	rjmp	.-166    	; 0x450 <__FUSE_REGION_LENGTH__+0x50>
     4f6:	f7 01       	movw	r30, r14
     4f8:	82 8d       	ldd	r24, Z+26	; 0x1a
     4fa:	c8 16       	cp	r12, r24
     4fc:	09 f4       	brne	.+2      	; 0x500 <__FUSE_REGION_LENGTH__+0x100>
     4fe:	b0 cf       	rjmp	.-160    	; 0x460 <__FUSE_REGION_LENGTH__+0x60>
     500:	b4 cf       	rjmp	.-152    	; 0x46a <__FUSE_REGION_LENGTH__+0x6a>
    }
  }
  
  xSemaphoreGive(con->mutex);
  
}
     502:	0f 90       	pop	r0
     504:	df 91       	pop	r29
     506:	cf 91       	pop	r28
     508:	1f 91       	pop	r17
     50a:	0f 91       	pop	r16
     50c:	ff 90       	pop	r15
     50e:	ef 90       	pop	r14
     510:	df 90       	pop	r13
     512:	cf 90       	pop	r12
     514:	bf 90       	pop	r11
     516:	af 90       	pop	r10
     518:	9f 90       	pop	r9
     51a:	08 95       	ret

0000051c <buffer_init>:
     51c:	fc 01       	movw	r30, r24
     51e:	61 15       	cp	r22, r1
     520:	71 05       	cpc	r23, r1
     522:	61 f0       	breq	.+24     	; 0x53c <buffer_init+0x20>
     524:	71 83       	std	Z+1, r23	; 0x01
     526:	60 83       	st	Z, r22
     528:	53 83       	std	Z+3, r21	; 0x03
     52a:	42 83       	std	Z+2, r20	; 0x02
     52c:	11 86       	std	Z+9, r1	; 0x09
     52e:	10 86       	std	Z+8, r1	; 0x08
     530:	17 82       	std	Z+7, r1	; 0x07
     532:	16 82       	std	Z+6, r1	; 0x06
     534:	15 82       	std	Z+5, r1	; 0x05
     536:	14 82       	std	Z+4, r1	; 0x04
     538:	81 e0       	ldi	r24, 0x01	; 1
     53a:	08 95       	ret
     53c:	80 e0       	ldi	r24, 0x00	; 0
     53e:	08 95       	ret

00000540 <buffer_append>:
     540:	ef 92       	push	r14
     542:	ff 92       	push	r15
     544:	0f 93       	push	r16
     546:	1f 93       	push	r17
     548:	cf 93       	push	r28
     54a:	df 93       	push	r29
     54c:	ec 01       	movw	r28, r24
     54e:	2a 81       	ldd	r18, Y+2	; 0x02
     550:	3b 81       	ldd	r19, Y+3	; 0x03
     552:	88 85       	ldd	r24, Y+8	; 0x08
     554:	99 85       	ldd	r25, Y+9	; 0x09
     556:	f9 01       	movw	r30, r18
     558:	e8 1b       	sub	r30, r24
     55a:	f9 0b       	sbc	r31, r25
     55c:	e4 17       	cp	r30, r20
     55e:	f5 07       	cpc	r31, r21
     560:	08 f4       	brcc	.+2      	; 0x564 <buffer_append+0x24>
     562:	49 c0       	rjmp	.+146    	; 0x5f6 <buffer_append+0xb6>
     564:	8a 01       	movw	r16, r20
     566:	7b 01       	movw	r14, r22
     568:	8c 81       	ldd	r24, Y+4	; 0x04
     56a:	9d 81       	ldd	r25, Y+5	; 0x05
     56c:	a9 01       	movw	r20, r18
     56e:	48 1b       	sub	r20, r24
     570:	59 0b       	sbc	r21, r25
     572:	04 17       	cp	r16, r20
     574:	15 07       	cpc	r17, r21
     576:	a8 f4       	brcc	.+42     	; 0x5a2 <buffer_append+0x62>
     578:	28 81       	ld	r18, Y
     57a:	39 81       	ldd	r19, Y+1	; 0x01
     57c:	a8 01       	movw	r20, r16
     57e:	82 0f       	add	r24, r18
     580:	93 1f       	adc	r25, r19
     582:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
     586:	8c 81       	ldd	r24, Y+4	; 0x04
     588:	9d 81       	ldd	r25, Y+5	; 0x05
     58a:	80 0f       	add	r24, r16
     58c:	91 1f       	adc	r25, r17
     58e:	9d 83       	std	Y+5, r25	; 0x05
     590:	8c 83       	std	Y+4, r24	; 0x04
     592:	2a 81       	ldd	r18, Y+2	; 0x02
     594:	3b 81       	ldd	r19, Y+3	; 0x03
     596:	82 17       	cp	r24, r18
     598:	93 07       	cpc	r25, r19
     59a:	21 f5       	brne	.+72     	; 0x5e4 <buffer_append+0xa4>
     59c:	1d 82       	std	Y+5, r1	; 0x05
     59e:	1c 82       	std	Y+4, r1	; 0x04
     5a0:	21 c0       	rjmp	.+66     	; 0x5e4 <buffer_append+0xa4>
     5a2:	28 81       	ld	r18, Y
     5a4:	39 81       	ldd	r19, Y+1	; 0x01
     5a6:	82 0f       	add	r24, r18
     5a8:	93 1f       	adc	r25, r19
     5aa:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
     5ae:	8c 81       	ldd	r24, Y+4	; 0x04
     5b0:	9d 81       	ldd	r25, Y+5	; 0x05
     5b2:	6a 81       	ldd	r22, Y+2	; 0x02
     5b4:	7b 81       	ldd	r23, Y+3	; 0x03
     5b6:	ac 01       	movw	r20, r24
     5b8:	46 1b       	sub	r20, r22
     5ba:	57 0b       	sbc	r21, r23
     5bc:	40 0f       	add	r20, r16
     5be:	51 1f       	adc	r21, r17
     5c0:	68 1b       	sub	r22, r24
     5c2:	79 0b       	sbc	r23, r25
     5c4:	6e 0d       	add	r22, r14
     5c6:	7f 1d       	adc	r23, r15
     5c8:	88 81       	ld	r24, Y
     5ca:	99 81       	ldd	r25, Y+1	; 0x01
     5cc:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
     5d0:	8c 81       	ldd	r24, Y+4	; 0x04
     5d2:	9d 81       	ldd	r25, Y+5	; 0x05
     5d4:	2a 81       	ldd	r18, Y+2	; 0x02
     5d6:	3b 81       	ldd	r19, Y+3	; 0x03
     5d8:	82 1b       	sub	r24, r18
     5da:	93 0b       	sbc	r25, r19
     5dc:	80 0f       	add	r24, r16
     5de:	91 1f       	adc	r25, r17
     5e0:	9d 83       	std	Y+5, r25	; 0x05
     5e2:	8c 83       	std	Y+4, r24	; 0x04
     5e4:	48 85       	ldd	r20, Y+8	; 0x08
     5e6:	59 85       	ldd	r21, Y+9	; 0x09
     5e8:	04 0f       	add	r16, r20
     5ea:	15 1f       	adc	r17, r21
     5ec:	19 87       	std	Y+9, r17	; 0x09
     5ee:	08 87       	std	Y+8, r16	; 0x08
     5f0:	81 e0       	ldi	r24, 0x01	; 1
     5f2:	90 e0       	ldi	r25, 0x00	; 0
     5f4:	02 c0       	rjmp	.+4      	; 0x5fa <buffer_append+0xba>
     5f6:	80 e0       	ldi	r24, 0x00	; 0
     5f8:	90 e0       	ldi	r25, 0x00	; 0
     5fa:	df 91       	pop	r29
     5fc:	cf 91       	pop	r28
     5fe:	1f 91       	pop	r17
     600:	0f 91       	pop	r16
     602:	ff 90       	pop	r15
     604:	ef 90       	pop	r14
     606:	08 95       	ret

00000608 <buffer_remove_token>:
     608:	0f 93       	push	r16
     60a:	1f 93       	push	r17
     60c:	cf 93       	push	r28
     60e:	df 93       	push	r29
     610:	fc 01       	movw	r30, r24
     612:	21 15       	cp	r18, r1
     614:	31 05       	cpc	r19, r1
     616:	c9 f1       	breq	.+114    	; 0x68a <buffer_remove_token+0x82>
     618:	a6 81       	ldd	r26, Z+6	; 0x06
     61a:	b7 81       	ldd	r27, Z+7	; 0x07
     61c:	84 81       	ldd	r24, Z+4	; 0x04
     61e:	95 81       	ldd	r25, Z+5	; 0x05
     620:	a8 17       	cp	r26, r24
     622:	b9 07       	cpc	r27, r25
     624:	a9 f1       	breq	.+106    	; 0x690 <buffer_remove_token+0x88>
     626:	c6 2f       	mov	r28, r22
     628:	d7 2f       	mov	r29, r23
     62a:	80 e0       	ldi	r24, 0x00	; 0
     62c:	90 e0       	ldi	r25, 0x00	; 0
     62e:	07 c0       	rjmp	.+14     	; 0x63e <buffer_remove_token+0x36>
     630:	a6 81       	ldd	r26, Z+6	; 0x06
     632:	b7 81       	ldd	r27, Z+7	; 0x07
     634:	64 81       	ldd	r22, Z+4	; 0x04
     636:	75 81       	ldd	r23, Z+5	; 0x05
     638:	a6 17       	cp	r26, r22
     63a:	b7 07       	cpc	r27, r23
     63c:	59 f1       	breq	.+86     	; 0x694 <buffer_remove_token+0x8c>
     63e:	60 81       	ld	r22, Z
     640:	71 81       	ldd	r23, Z+1	; 0x01
     642:	a6 0f       	add	r26, r22
     644:	b7 1f       	adc	r27, r23
     646:	5c 91       	ld	r21, X
     648:	8e 01       	movw	r16, r28
     64a:	58 83       	st	Y, r21
     64c:	66 81       	ldd	r22, Z+6	; 0x06
     64e:	77 81       	ldd	r23, Z+7	; 0x07
     650:	6f 5f       	subi	r22, 0xFF	; 255
     652:	7f 4f       	sbci	r23, 0xFF	; 255
     654:	77 83       	std	Z+7, r23	; 0x07
     656:	66 83       	std	Z+6, r22	; 0x06
     658:	a0 85       	ldd	r26, Z+8	; 0x08
     65a:	b1 85       	ldd	r27, Z+9	; 0x09
     65c:	11 97       	sbiw	r26, 0x01	; 1
     65e:	b1 87       	std	Z+9, r27	; 0x09
     660:	a0 87       	std	Z+8, r26	; 0x08
     662:	a2 81       	ldd	r26, Z+2	; 0x02
     664:	b3 81       	ldd	r27, Z+3	; 0x03
     666:	6a 17       	cp	r22, r26
     668:	7b 07       	cpc	r23, r27
     66a:	11 f4       	brne	.+4      	; 0x670 <buffer_remove_token+0x68>
     66c:	17 82       	std	Z+7, r1	; 0x07
     66e:	16 82       	std	Z+6, r1	; 0x06
     670:	21 96       	adiw	r28, 0x01	; 1
     672:	d8 01       	movw	r26, r16
     674:	5c 91       	ld	r21, X
     676:	54 13       	cpse	r21, r20
     678:	02 c0       	rjmp	.+4      	; 0x67e <buffer_remove_token+0x76>
     67a:	01 96       	adiw	r24, 0x01	; 1
     67c:	0b c0       	rjmp	.+22     	; 0x694 <buffer_remove_token+0x8c>
     67e:	01 96       	adiw	r24, 0x01	; 1
     680:	28 17       	cp	r18, r24
     682:	39 07       	cpc	r19, r25
     684:	a9 f6       	brne	.-86     	; 0x630 <buffer_remove_token+0x28>
     686:	c9 01       	movw	r24, r18
     688:	05 c0       	rjmp	.+10     	; 0x694 <buffer_remove_token+0x8c>
     68a:	80 e0       	ldi	r24, 0x00	; 0
     68c:	90 e0       	ldi	r25, 0x00	; 0
     68e:	02 c0       	rjmp	.+4      	; 0x694 <buffer_remove_token+0x8c>
     690:	80 e0       	ldi	r24, 0x00	; 0
     692:	90 e0       	ldi	r25, 0x00	; 0
     694:	df 91       	pop	r29
     696:	cf 91       	pop	r28
     698:	1f 91       	pop	r17
     69a:	0f 91       	pop	r16
     69c:	08 95       	ret

0000069e <buffer_remove>:
     69e:	ef 92       	push	r14
     6a0:	ff 92       	push	r15
     6a2:	0f 93       	push	r16
     6a4:	1f 93       	push	r17
     6a6:	cf 93       	push	r28
     6a8:	df 93       	push	r29
     6aa:	ec 01       	movw	r28, r24
     6ac:	7b 01       	movw	r14, r22
     6ae:	08 85       	ldd	r16, Y+8	; 0x08
     6b0:	19 85       	ldd	r17, Y+9	; 0x09
     6b2:	40 17       	cp	r20, r16
     6b4:	51 07       	cpc	r21, r17
     6b6:	08 f4       	brcc	.+2      	; 0x6ba <buffer_remove+0x1c>
     6b8:	8a 01       	movw	r16, r20
     6ba:	8e 81       	ldd	r24, Y+6	; 0x06
     6bc:	9f 81       	ldd	r25, Y+7	; 0x07
     6be:	4a 81       	ldd	r20, Y+2	; 0x02
     6c0:	5b 81       	ldd	r21, Y+3	; 0x03
     6c2:	48 1b       	sub	r20, r24
     6c4:	59 0b       	sbc	r21, r25
     6c6:	40 17       	cp	r20, r16
     6c8:	51 07       	cpc	r21, r17
     6ca:	c8 f0       	brcs	.+50     	; 0x6fe <buffer_remove+0x60>
     6cc:	e1 14       	cp	r14, r1
     6ce:	f1 04       	cpc	r15, r1
     6d0:	41 f0       	breq	.+16     	; 0x6e2 <buffer_remove+0x44>
     6d2:	68 81       	ld	r22, Y
     6d4:	79 81       	ldd	r23, Y+1	; 0x01
     6d6:	68 0f       	add	r22, r24
     6d8:	79 1f       	adc	r23, r25
     6da:	a8 01       	movw	r20, r16
     6dc:	c7 01       	movw	r24, r14
     6de:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
     6e2:	8e 81       	ldd	r24, Y+6	; 0x06
     6e4:	9f 81       	ldd	r25, Y+7	; 0x07
     6e6:	80 0f       	add	r24, r16
     6e8:	91 1f       	adc	r25, r17
     6ea:	9f 83       	std	Y+7, r25	; 0x07
     6ec:	8e 83       	std	Y+6, r24	; 0x06
     6ee:	2a 81       	ldd	r18, Y+2	; 0x02
     6f0:	3b 81       	ldd	r19, Y+3	; 0x03
     6f2:	82 17       	cp	r24, r18
     6f4:	93 07       	cpc	r25, r19
     6f6:	41 f5       	brne	.+80     	; 0x748 <buffer_remove+0xaa>
     6f8:	1f 82       	std	Y+7, r1	; 0x07
     6fa:	1e 82       	std	Y+6, r1	; 0x06
     6fc:	25 c0       	rjmp	.+74     	; 0x748 <buffer_remove+0xaa>
     6fe:	e1 14       	cp	r14, r1
     700:	f1 04       	cpc	r15, r1
     702:	c1 f0       	breq	.+48     	; 0x734 <buffer_remove+0x96>
     704:	68 81       	ld	r22, Y
     706:	79 81       	ldd	r23, Y+1	; 0x01
     708:	68 0f       	add	r22, r24
     70a:	79 1f       	adc	r23, r25
     70c:	c7 01       	movw	r24, r14
     70e:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
     712:	4e 81       	ldd	r20, Y+6	; 0x06
     714:	5f 81       	ldd	r21, Y+7	; 0x07
     716:	2a 81       	ldd	r18, Y+2	; 0x02
     718:	3b 81       	ldd	r19, Y+3	; 0x03
     71a:	c9 01       	movw	r24, r18
     71c:	84 1b       	sub	r24, r20
     71e:	95 0b       	sbc	r25, r21
     720:	42 1b       	sub	r20, r18
     722:	53 0b       	sbc	r21, r19
     724:	40 0f       	add	r20, r16
     726:	51 1f       	adc	r21, r17
     728:	68 81       	ld	r22, Y
     72a:	79 81       	ldd	r23, Y+1	; 0x01
     72c:	8e 0d       	add	r24, r14
     72e:	9f 1d       	adc	r25, r15
     730:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
     734:	8e 81       	ldd	r24, Y+6	; 0x06
     736:	9f 81       	ldd	r25, Y+7	; 0x07
     738:	2a 81       	ldd	r18, Y+2	; 0x02
     73a:	3b 81       	ldd	r19, Y+3	; 0x03
     73c:	82 1b       	sub	r24, r18
     73e:	93 0b       	sbc	r25, r19
     740:	80 0f       	add	r24, r16
     742:	91 1f       	adc	r25, r17
     744:	9f 83       	std	Y+7, r25	; 0x07
     746:	8e 83       	std	Y+6, r24	; 0x06
     748:	88 85       	ldd	r24, Y+8	; 0x08
     74a:	99 85       	ldd	r25, Y+9	; 0x09
     74c:	80 1b       	sub	r24, r16
     74e:	91 0b       	sbc	r25, r17
     750:	99 87       	std	Y+9, r25	; 0x09
     752:	88 87       	std	Y+8, r24	; 0x08
     754:	c8 01       	movw	r24, r16
     756:	df 91       	pop	r29
     758:	cf 91       	pop	r28
     75a:	1f 91       	pop	r17
     75c:	0f 91       	pop	r16
     75e:	ff 90       	pop	r15
     760:	ef 90       	pop	r14
     762:	08 95       	ret

00000764 <cobs_encode>:
     764:	ef 92       	push	r14
     766:	ff 92       	push	r15
     768:	0f 93       	push	r16
     76a:	1f 93       	push	r17
     76c:	cf 93       	push	r28
     76e:	df 93       	push	r29
     770:	7c 01       	movw	r14, r24
     772:	68 0f       	add	r22, r24
     774:	79 1f       	adc	r23, r25
     776:	fc 01       	movw	r30, r24
     778:	31 96       	adiw	r30, 0x01	; 1
     77a:	00 97       	sbiw	r24, 0x00	; 0
     77c:	19 f0       	breq	.+6      	; 0x784 <cobs_encode+0x20>
     77e:	41 15       	cp	r20, r1
     780:	51 05       	cpc	r21, r1
     782:	21 f4       	brne	.+8      	; 0x78c <cobs_encode+0x28>
     784:	60 e0       	ldi	r22, 0x00	; 0
     786:	70 e0       	ldi	r23, 0x00	; 0
     788:	81 e0       	ldi	r24, 0x01	; 1
     78a:	4b c0       	rjmp	.+150    	; 0x822 <cobs_encode+0xbe>
     78c:	21 15       	cp	r18, r1
     78e:	31 05       	cpc	r19, r1
     790:	59 f1       	breq	.+86     	; 0x7e8 <cobs_encode+0x84>
     792:	e6 17       	cp	r30, r22
     794:	f7 07       	cpc	r31, r23
     796:	60 f5       	brcc	.+88     	; 0x7f0 <cobs_encode+0x8c>
     798:	8a 01       	movw	r16, r20
     79a:	02 0f       	add	r16, r18
     79c:	13 1f       	adc	r17, r19
     79e:	da 01       	movw	r26, r20
     7a0:	ec 01       	movw	r28, r24
     7a2:	91 e0       	ldi	r25, 0x01	; 1
     7a4:	2f ef       	ldi	r18, 0xFF	; 255
     7a6:	04 c0       	rjmp	.+8      	; 0x7b0 <cobs_encode+0x4c>
     7a8:	fa 01       	movw	r30, r20
     7aa:	e6 17       	cp	r30, r22
     7ac:	f7 07       	cpc	r31, r23
     7ae:	20 f5       	brcc	.+72     	; 0x7f8 <cobs_encode+0x94>
     7b0:	3d 91       	ld	r19, X+
     7b2:	31 11       	cpse	r19, r1
     7b4:	0a c0       	rjmp	.+20     	; 0x7ca <cobs_encode+0x66>
     7b6:	98 83       	st	Y, r25
     7b8:	cf 01       	movw	r24, r30
     7ba:	01 96       	adiw	r24, 0x01	; 1
     7bc:	a0 17       	cp	r26, r16
     7be:	b1 07       	cpc	r27, r17
     7c0:	e8 f4       	brcc	.+58     	; 0x7fc <cobs_encode+0x98>
     7c2:	ef 01       	movw	r28, r30
     7c4:	fc 01       	movw	r30, r24
     7c6:	91 e0       	ldi	r25, 0x01	; 1
     7c8:	f0 cf       	rjmp	.-32     	; 0x7aa <cobs_encode+0x46>
     7ca:	af 01       	movw	r20, r30
     7cc:	4f 5f       	subi	r20, 0xFF	; 255
     7ce:	5f 4f       	sbci	r21, 0xFF	; 255
     7d0:	30 83       	st	Z, r19
     7d2:	9f 5f       	subi	r25, 0xFF	; 255
     7d4:	a0 17       	cp	r26, r16
     7d6:	b1 07       	cpc	r27, r17
     7d8:	b0 f4       	brcc	.+44     	; 0x806 <cobs_encode+0xa2>
     7da:	9f 3f       	cpi	r25, 0xFF	; 255
     7dc:	29 f7       	brne	.-54     	; 0x7a8 <cobs_encode+0x44>
     7de:	28 83       	st	Y, r18
     7e0:	32 96       	adiw	r30, 0x02	; 2
     7e2:	ea 01       	movw	r28, r20
     7e4:	91 e0       	ldi	r25, 0x01	; 1
     7e6:	e1 cf       	rjmp	.-62     	; 0x7aa <cobs_encode+0x46>
     7e8:	ec 01       	movw	r28, r24
     7ea:	80 e0       	ldi	r24, 0x00	; 0
     7ec:	91 e0       	ldi	r25, 0x01	; 1
     7ee:	0d c0       	rjmp	.+26     	; 0x80a <cobs_encode+0xa6>
     7f0:	ec 01       	movw	r28, r24
     7f2:	82 e0       	ldi	r24, 0x02	; 2
     7f4:	91 e0       	ldi	r25, 0x01	; 1
     7f6:	09 c0       	rjmp	.+18     	; 0x80a <cobs_encode+0xa6>
     7f8:	82 e0       	ldi	r24, 0x02	; 2
     7fa:	07 c0       	rjmp	.+14     	; 0x80a <cobs_encode+0xa6>
     7fc:	ef 01       	movw	r28, r30
     7fe:	fc 01       	movw	r30, r24
     800:	80 e0       	ldi	r24, 0x00	; 0
     802:	91 e0       	ldi	r25, 0x01	; 1
     804:	02 c0       	rjmp	.+4      	; 0x80a <cobs_encode+0xa6>
     806:	fa 01       	movw	r30, r20
     808:	80 e0       	ldi	r24, 0x00	; 0
     80a:	c6 17       	cp	r28, r22
     80c:	d7 07       	cpc	r29, r23
     80e:	18 f4       	brcc	.+6      	; 0x816 <cobs_encode+0xb2>
     810:	98 83       	st	Y, r25
     812:	bf 01       	movw	r22, r30
     814:	01 c0       	rjmp	.+2      	; 0x818 <cobs_encode+0xb4>
     816:	82 e0       	ldi	r24, 0x02	; 2
     818:	9b 01       	movw	r18, r22
     81a:	2e 19       	sub	r18, r14
     81c:	3f 09       	sbc	r19, r15
     81e:	62 2f       	mov	r22, r18
     820:	73 2f       	mov	r23, r19
     822:	df 91       	pop	r29
     824:	cf 91       	pop	r28
     826:	1f 91       	pop	r17
     828:	0f 91       	pop	r16
     82a:	ff 90       	pop	r15
     82c:	ef 90       	pop	r14
     82e:	08 95       	ret

00000830 <cobs_decode>:
     830:	af 92       	push	r10
     832:	bf 92       	push	r11
     834:	cf 92       	push	r12
     836:	df 92       	push	r13
     838:	ef 92       	push	r14
     83a:	ff 92       	push	r15
     83c:	0f 93       	push	r16
     83e:	1f 93       	push	r17
     840:	cf 93       	push	r28
     842:	df 93       	push	r29
     844:	7c 01       	movw	r14, r24
     846:	da 01       	movw	r26, r20
     848:	00 97       	sbiw	r24, 0x00	; 0
     84a:	11 f0       	breq	.+4      	; 0x850 <cobs_decode+0x20>
     84c:	10 97       	sbiw	r26, 0x00	; 0
     84e:	21 f4       	brne	.+8      	; 0x858 <cobs_decode+0x28>
     850:	60 e0       	ldi	r22, 0x00	; 0
     852:	70 e0       	ldi	r23, 0x00	; 0
     854:	81 e0       	ldi	r24, 0x01	; 1
     856:	5f c0       	rjmp	.+190    	; 0x916 <cobs_decode+0xe6>
     858:	21 15       	cp	r18, r1
     85a:	31 05       	cpc	r19, r1
     85c:	09 f4       	brne	.+2      	; 0x860 <cobs_decode+0x30>
     85e:	4b c0       	rjmp	.+150    	; 0x8f6 <cobs_decode+0xc6>
     860:	6a 01       	movw	r12, r20
     862:	c2 0e       	add	r12, r18
     864:	d3 1e       	adc	r13, r19
     866:	5c 01       	movw	r10, r24
     868:	a6 0e       	add	r10, r22
     86a:	b7 1e       	adc	r11, r23
     86c:	8c 01       	movw	r16, r24
     86e:	50 e0       	ldi	r21, 0x00	; 0
     870:	01 c0       	rjmp	.+2      	; 0x874 <cobs_decode+0x44>
     872:	8f 01       	movw	r16, r30
     874:	ed 01       	movw	r28, r26
     876:	21 96       	adiw	r28, 0x01	; 1
     878:	7c 91       	ld	r23, X
     87a:	71 11       	cpse	r23, r1
     87c:	03 c0       	rjmp	.+6      	; 0x884 <cobs_decode+0x54>
     87e:	54 60       	ori	r21, 0x04	; 4
     880:	f8 01       	movw	r30, r16
     882:	3d c0       	rjmp	.+122    	; 0x8fe <cobs_decode+0xce>
     884:	71 50       	subi	r23, 0x01	; 1
     886:	c6 01       	movw	r24, r12
     888:	8c 1b       	sub	r24, r28
     88a:	9d 0b       	sbc	r25, r29
     88c:	27 2f       	mov	r18, r23
     88e:	30 e0       	ldi	r19, 0x00	; 0
     890:	82 17       	cp	r24, r18
     892:	93 07       	cpc	r25, r19
     894:	10 f4       	brcc	.+4      	; 0x89a <cobs_decode+0x6a>
     896:	78 2f       	mov	r23, r24
     898:	58 60       	ori	r21, 0x08	; 8
     89a:	c5 01       	movw	r24, r10
     89c:	80 1b       	sub	r24, r16
     89e:	91 0b       	sbc	r25, r17
     8a0:	27 2f       	mov	r18, r23
     8a2:	30 e0       	ldi	r19, 0x00	; 0
     8a4:	82 17       	cp	r24, r18
     8a6:	93 07       	cpc	r25, r19
     8a8:	10 f4       	brcc	.+4      	; 0x8ae <cobs_decode+0x7e>
     8aa:	78 2f       	mov	r23, r24
     8ac:	52 60       	ori	r21, 0x02	; 2
     8ae:	77 23       	and	r23, r23
     8b0:	61 f1       	breq	.+88     	; 0x90a <cobs_decode+0xda>
     8b2:	de 01       	movw	r26, r28
     8b4:	f8 01       	movw	r30, r16
     8b6:	97 2f       	mov	r25, r23
     8b8:	3d 91       	ld	r19, X+
     8ba:	31 11       	cpse	r19, r1
     8bc:	01 c0       	rjmp	.+2      	; 0x8c0 <cobs_decode+0x90>
     8be:	54 60       	ori	r21, 0x04	; 4
     8c0:	31 93       	st	Z+, r19
     8c2:	91 50       	subi	r25, 0x01	; 1
     8c4:	c9 f7       	brne	.-14     	; 0x8b8 <cobs_decode+0x88>
     8c6:	ef ef       	ldi	r30, 0xFF	; 255
     8c8:	e7 0f       	add	r30, r23
     8ca:	f0 e0       	ldi	r31, 0x00	; 0
     8cc:	31 96       	adiw	r30, 0x01	; 1
     8ce:	de 01       	movw	r26, r28
     8d0:	ae 0f       	add	r26, r30
     8d2:	bf 1f       	adc	r27, r31
     8d4:	e0 0f       	add	r30, r16
     8d6:	f1 1f       	adc	r31, r17
     8d8:	ac 15       	cp	r26, r12
     8da:	bd 05       	cpc	r27, r13
     8dc:	80 f4       	brcc	.+32     	; 0x8fe <cobs_decode+0xce>
     8de:	7e 3f       	cpi	r23, 0xFE	; 254
     8e0:	41 f2       	breq	.-112    	; 0x872 <cobs_decode+0x42>
     8e2:	ea 15       	cp	r30, r10
     8e4:	fb 05       	cpc	r31, r11
     8e6:	10 f0       	brcs	.+4      	; 0x8ec <cobs_decode+0xbc>
     8e8:	52 60       	ori	r21, 0x02	; 2
     8ea:	09 c0       	rjmp	.+18     	; 0x8fe <cobs_decode+0xce>
     8ec:	8f 01       	movw	r16, r30
     8ee:	0f 5f       	subi	r16, 0xFF	; 255
     8f0:	1f 4f       	sbci	r17, 0xFF	; 255
     8f2:	10 82       	st	Z, r1
     8f4:	bf cf       	rjmp	.-130    	; 0x874 <cobs_decode+0x44>
     8f6:	fc 01       	movw	r30, r24
     8f8:	50 e0       	ldi	r21, 0x00	; 0
     8fa:	01 c0       	rjmp	.+2      	; 0x8fe <cobs_decode+0xce>
     8fc:	f8 01       	movw	r30, r16
     8fe:	ee 19       	sub	r30, r14
     900:	ff 09       	sbc	r31, r15
     902:	6e 2f       	mov	r22, r30
     904:	7f 2f       	mov	r23, r31
     906:	85 2f       	mov	r24, r21
     908:	06 c0       	rjmp	.+12     	; 0x916 <cobs_decode+0xe6>
     90a:	cc 15       	cp	r28, r12
     90c:	dd 05       	cpc	r29, r13
     90e:	b0 f7       	brcc	.-20     	; 0x8fc <cobs_decode+0xcc>
     910:	f8 01       	movw	r30, r16
     912:	de 01       	movw	r26, r28
     914:	e6 cf       	rjmp	.-52     	; 0x8e2 <cobs_decode+0xb2>
     916:	df 91       	pop	r29
     918:	cf 91       	pop	r28
     91a:	1f 91       	pop	r17
     91c:	0f 91       	pop	r16
     91e:	ff 90       	pop	r15
     920:	ef 90       	pop	r14
     922:	df 90       	pop	r13
     924:	cf 90       	pop	r12
     926:	bf 90       	pop	r11
     928:	af 90       	pop	r10
     92a:	08 95       	ret

0000092c <crc_ibutton_update>:
     92c:	86 27       	eor	r24, r22
     92e:	98 e0       	ldi	r25, 0x08	; 8
     930:	2c e8       	ldi	r18, 0x8C	; 140
     932:	80 ff       	sbrs	r24, 0
     934:	03 c0       	rjmp	.+6      	; 0x93c <crc_ibutton_update+0x10>
     936:	86 95       	lsr	r24
     938:	82 27       	eor	r24, r18
     93a:	01 c0       	rjmp	.+2      	; 0x93e <crc_ibutton_update+0x12>
     93c:	86 95       	lsr	r24
     93e:	91 50       	subi	r25, 0x01	; 1
     940:	c1 f7       	brne	.-16     	; 0x932 <crc_ibutton_update+0x6>
     942:	08 95       	ret

00000944 <calculate_crc>:
     944:	0f 93       	push	r16
     946:	1f 93       	push	r17
     948:	cf 93       	push	r28
     94a:	df 93       	push	r29
     94c:	66 23       	and	r22, r22
     94e:	59 f0       	breq	.+22     	; 0x966 <calculate_crc+0x22>
     950:	8c 01       	movw	r16, r24
     952:	ec 01       	movw	r28, r24
     954:	06 0f       	add	r16, r22
     956:	11 1d       	adc	r17, r1
     958:	80 e0       	ldi	r24, 0x00	; 0
     95a:	69 91       	ld	r22, Y+
     95c:	e7 df       	rcall	.-50     	; 0x92c <crc_ibutton_update>
     95e:	c0 17       	cp	r28, r16
     960:	d1 07       	cpc	r29, r17
     962:	d9 f7       	brne	.-10     	; 0x95a <calculate_crc+0x16>
     964:	01 c0       	rjmp	.+2      	; 0x968 <calculate_crc+0x24>
     966:	80 e0       	ldi	r24, 0x00	; 0
     968:	df 91       	pop	r29
     96a:	cf 91       	pop	r28
     96c:	1f 91       	pop	r17
     96e:	0f 91       	pop	r16
     970:	08 95       	ret

00000972 <vDistSens_init>:
};

/* Initialize distance sensors and ADC */
void vDistSens_init(){
    /* Initialize sensor pins as input */
    distSensReg &= ~((1<<distSensFwd) & (1<<distSensLeft) & (1<<distSensRear) & (1<<distSensRight));
     972:	80 b3       	in	r24, 0x10	; 16
     974:	80 bb       	out	0x10, r24	; 16
    
    /* Internal 2.56V VREG with external capacitor at AREF pin */
    /* Datasheet p281 table 26-3 */
    ADMUX |= (1<<REFS1) | (1<<REFS0);
     976:	ec e7       	ldi	r30, 0x7C	; 124
     978:	f0 e0       	ldi	r31, 0x00	; 0
     97a:	80 81       	ld	r24, Z
     97c:	80 6c       	ori	r24, 0xC0	; 192
     97e:	80 83       	st	Z, r24
    
    /* ADC enable */
    ADCSRA |= (1<<ADEN);
     980:	ea e7       	ldi	r30, 0x7A	; 122
     982:	f0 e0       	ldi	r31, 0x00	; 0
     984:	80 81       	ld	r24, Z
     986:	80 68       	ori	r24, 0x80	; 128
     988:	80 83       	st	Z, r24
    
    /* ADC prescaler setting (div. factor = 16) */
    /* Datasheet p257 table 21-5 */
    ADCSRA |= (1<<ADPS2) | (0<<ADPS1) | (0<<ADPS0);
     98a:	80 81       	ld	r24, Z
     98c:	84 60       	ori	r24, 0x04	; 4
     98e:	80 83       	st	Z, r24
     990:	08 95       	ret

00000992 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
     992:	ef 92       	push	r14
     994:	ff 92       	push	r15
     996:	0f 93       	push	r16
     998:	1f 93       	push	r17
     99a:	cf 93       	push	r28
     99c:	df 93       	push	r29
     99e:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
     9a0:	0e 94 27 14 	call	0x284e	; 0x284e <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
     9a4:	80 91 65 03 	lds	r24, 0x0365	; 0x800365 <pxEnd>
     9a8:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <pxEnd+0x1>
     9ac:	89 2b       	or	r24, r25
     9ae:	41 f5       	brne	.+80     	; 0xa00 <pvPortMalloc+0x6e>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
     9b0:	e7 e6       	ldi	r30, 0x67	; 103
     9b2:	f3 e0       	ldi	r31, 0x03	; 3
     9b4:	ab e6       	ldi	r26, 0x6B	; 107
     9b6:	b3 e0       	ldi	r27, 0x03	; 3
     9b8:	b1 83       	std	Z+1, r27	; 0x01
     9ba:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
     9bc:	13 82       	std	Z+3, r1	; 0x03
     9be:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
     9c0:	e7 e6       	ldi	r30, 0x67	; 103
     9c2:	f5 e1       	ldi	r31, 0x15	; 21
     9c4:	f0 93 66 03 	sts	0x0366, r31	; 0x800366 <pxEnd+0x1>
     9c8:	e0 93 65 03 	sts	0x0365, r30	; 0x800365 <pxEnd>
	pxEnd->xBlockSize = 0;
     9cc:	13 82       	std	Z+3, r1	; 0x03
     9ce:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
     9d0:	11 82       	std	Z+1, r1	; 0x01
     9d2:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
     9d4:	8c ef       	ldi	r24, 0xFC	; 252
     9d6:	91 e1       	ldi	r25, 0x11	; 17
     9d8:	13 96       	adiw	r26, 0x03	; 3
     9da:	9c 93       	st	X, r25
     9dc:	8e 93       	st	-X, r24
     9de:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
     9e0:	ed 93       	st	X+, r30
     9e2:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     9e4:	90 93 62 03 	sts	0x0362, r25	; 0x800362 <xMinimumEverFreeBytesRemaining+0x1>
     9e8:	80 93 61 03 	sts	0x0361, r24	; 0x800361 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
     9ec:	90 93 64 03 	sts	0x0364, r25	; 0x800364 <xFreeBytesRemaining+0x1>
     9f0:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
     9f4:	80 e0       	ldi	r24, 0x00	; 0
     9f6:	90 e8       	ldi	r25, 0x80	; 128
     9f8:	90 93 60 03 	sts	0x0360, r25	; 0x800360 <xBlockAllocatedBit+0x1>
     9fc:	80 93 5f 03 	sts	0x035F, r24	; 0x80035f <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
     a00:	80 91 5f 03 	lds	r24, 0x035F	; 0x80035f <xBlockAllocatedBit>
     a04:	90 91 60 03 	lds	r25, 0x0360	; 0x800360 <xBlockAllocatedBit+0x1>
     a08:	8c 23       	and	r24, r28
     a0a:	9d 23       	and	r25, r29
     a0c:	89 2b       	or	r24, r25
     a0e:	09 f0       	breq	.+2      	; 0xa12 <pvPortMalloc+0x80>
     a10:	b2 c0       	rjmp	.+356    	; 0xb76 <pvPortMalloc+0x1e4>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
     a12:	20 97       	sbiw	r28, 0x00	; 0
     a14:	09 f4       	brne	.+2      	; 0xa18 <pvPortMalloc+0x86>
     a16:	b2 c0       	rjmp	.+356    	; 0xb7c <pvPortMalloc+0x1ea>
			{
				xWantedSize += xHeapStructSize;
     a18:	ae 01       	movw	r20, r28
     a1a:	4c 5f       	subi	r20, 0xFC	; 252
     a1c:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
     a1e:	09 f4       	brne	.+2      	; 0xa22 <pvPortMalloc+0x90>
     a20:	b0 c0       	rjmp	.+352    	; 0xb82 <pvPortMalloc+0x1f0>
     a22:	80 91 63 03 	lds	r24, 0x0363	; 0x800363 <xFreeBytesRemaining>
     a26:	90 91 64 03 	lds	r25, 0x0364	; 0x800364 <xFreeBytesRemaining+0x1>
     a2a:	84 17       	cp	r24, r20
     a2c:	95 07       	cpc	r25, r21
     a2e:	08 f4       	brcc	.+2      	; 0xa32 <pvPortMalloc+0xa0>
     a30:	ab c0       	rjmp	.+342    	; 0xb88 <pvPortMalloc+0x1f6>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
     a32:	e0 91 67 03 	lds	r30, 0x0367	; 0x800367 <xStart>
     a36:	f0 91 68 03 	lds	r31, 0x0368	; 0x800368 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
     a3a:	a7 e6       	ldi	r26, 0x67	; 103
     a3c:	b3 e0       	ldi	r27, 0x03	; 3
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     a3e:	02 c0       	rjmp	.+4      	; 0xa44 <pvPortMalloc+0xb2>
     a40:	df 01       	movw	r26, r30
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
     a42:	f9 01       	movw	r30, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
     a44:	22 81       	ldd	r18, Z+2	; 0x02
     a46:	33 81       	ldd	r19, Z+3	; 0x03
     a48:	24 17       	cp	r18, r20
     a4a:	35 07       	cpc	r19, r21
     a4c:	28 f4       	brcc	.+10     	; 0xa58 <pvPortMalloc+0xc6>
     a4e:	20 81       	ld	r18, Z
     a50:	31 81       	ldd	r19, Z+1	; 0x01
     a52:	21 15       	cp	r18, r1
     a54:	31 05       	cpc	r19, r1
     a56:	a1 f7       	brne	.-24     	; 0xa40 <pvPortMalloc+0xae>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
     a58:	60 91 65 03 	lds	r22, 0x0365	; 0x800365 <pxEnd>
     a5c:	70 91 66 03 	lds	r23, 0x0366	; 0x800366 <pxEnd+0x1>
     a60:	e6 17       	cp	r30, r22
     a62:	f7 07       	cpc	r31, r23
     a64:	09 f4       	brne	.+2      	; 0xa68 <pvPortMalloc+0xd6>
     a66:	93 c0       	rjmp	.+294    	; 0xb8e <pvPortMalloc+0x1fc>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
     a68:	cd 91       	ld	r28, X+
     a6a:	dc 91       	ld	r29, X
     a6c:	11 97       	sbiw	r26, 0x01	; 1
     a6e:	7e 01       	movw	r14, r28
     a70:	84 e0       	ldi	r24, 0x04	; 4
     a72:	e8 0e       	add	r14, r24
     a74:	f1 1c       	adc	r15, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
     a76:	80 81       	ld	r24, Z
     a78:	91 81       	ldd	r25, Z+1	; 0x01
     a7a:	8d 93       	st	X+, r24
     a7c:	9c 93       	st	X, r25

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
     a7e:	82 81       	ldd	r24, Z+2	; 0x02
     a80:	93 81       	ldd	r25, Z+3	; 0x03
     a82:	84 1b       	sub	r24, r20
     a84:	95 0b       	sbc	r25, r21
     a86:	89 30       	cpi	r24, 0x09	; 9
     a88:	91 05       	cpc	r25, r1
     a8a:	08 f4       	brcc	.+2      	; 0xa8e <pvPortMalloc+0xfc>
     a8c:	52 c0       	rjmp	.+164    	; 0xb32 <pvPortMalloc+0x1a0>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
     a8e:	9f 01       	movw	r18, r30
     a90:	24 0f       	add	r18, r20
     a92:	35 1f       	adc	r19, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
     a94:	d9 01       	movw	r26, r18
     a96:	13 96       	adiw	r26, 0x03	; 3
     a98:	9c 93       	st	X, r25
     a9a:	8e 93       	st	-X, r24
     a9c:	12 97       	sbiw	r26, 0x02	; 2
						pxBlock->xBlockSize = xWantedSize;
     a9e:	53 83       	std	Z+3, r21	; 0x03
     aa0:	42 83       	std	Z+2, r20	; 0x02
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     aa2:	a7 e6       	ldi	r26, 0x67	; 103
     aa4:	b3 e0       	ldi	r27, 0x03	; 3
     aa6:	01 c0       	rjmp	.+2      	; 0xaaa <pvPortMalloc+0x118>
     aa8:	dc 01       	movw	r26, r24
     aaa:	8d 91       	ld	r24, X+
     aac:	9c 91       	ld	r25, X
     aae:	11 97       	sbiw	r26, 0x01	; 1
     ab0:	82 17       	cp	r24, r18
     ab2:	93 07       	cpc	r25, r19
     ab4:	c8 f3       	brcs	.-14     	; 0xaa8 <pvPortMalloc+0x116>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     ab6:	12 96       	adiw	r26, 0x02	; 2
     ab8:	4d 91       	ld	r20, X+
     aba:	5c 91       	ld	r21, X
     abc:	13 97       	sbiw	r26, 0x03	; 3
     abe:	8d 01       	movw	r16, r26
     ac0:	04 0f       	add	r16, r20
     ac2:	15 1f       	adc	r17, r21
     ac4:	20 17       	cp	r18, r16
     ac6:	31 07       	cpc	r19, r17
     ac8:	51 f4       	brne	.+20     	; 0xade <pvPortMalloc+0x14c>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     aca:	e9 01       	movw	r28, r18
     acc:	2a 81       	ldd	r18, Y+2	; 0x02
     ace:	3b 81       	ldd	r19, Y+3	; 0x03
     ad0:	42 0f       	add	r20, r18
     ad2:	53 1f       	adc	r21, r19
     ad4:	13 96       	adiw	r26, 0x03	; 3
     ad6:	5c 93       	st	X, r21
     ad8:	4e 93       	st	-X, r20
     ada:	12 97       	sbiw	r26, 0x02	; 2
     adc:	9d 01       	movw	r18, r26
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     ade:	e9 01       	movw	r28, r18
     ae0:	4a 81       	ldd	r20, Y+2	; 0x02
     ae2:	5b 81       	ldd	r21, Y+3	; 0x03
     ae4:	89 01       	movw	r16, r18
     ae6:	04 0f       	add	r16, r20
     ae8:	15 1f       	adc	r17, r21
     aea:	80 17       	cp	r24, r16
     aec:	91 07       	cpc	r25, r17
     aee:	c9 f4       	brne	.+50     	; 0xb22 <pvPortMalloc+0x190>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     af0:	60 17       	cp	r22, r16
     af2:	71 07       	cpc	r23, r17
     af4:	91 f0       	breq	.+36     	; 0xb1a <pvPortMalloc+0x188>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     af6:	e8 01       	movw	r28, r16
     af8:	8a 81       	ldd	r24, Y+2	; 0x02
     afa:	9b 81       	ldd	r25, Y+3	; 0x03
     afc:	48 0f       	add	r20, r24
     afe:	59 1f       	adc	r21, r25
     b00:	e9 01       	movw	r28, r18
     b02:	5b 83       	std	Y+3, r21	; 0x03
     b04:	4a 83       	std	Y+2, r20	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     b06:	8d 91       	ld	r24, X+
     b08:	9c 91       	ld	r25, X
     b0a:	11 97       	sbiw	r26, 0x01	; 1
     b0c:	ec 01       	movw	r28, r24
     b0e:	88 81       	ld	r24, Y
     b10:	99 81       	ldd	r25, Y+1	; 0x01
     b12:	e9 01       	movw	r28, r18
     b14:	99 83       	std	Y+1, r25	; 0x01
     b16:	88 83       	st	Y, r24
     b18:	07 c0       	rjmp	.+14     	; 0xb28 <pvPortMalloc+0x196>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     b1a:	e9 01       	movw	r28, r18
     b1c:	79 83       	std	Y+1, r23	; 0x01
     b1e:	68 83       	st	Y, r22
     b20:	03 c0       	rjmp	.+6      	; 0xb28 <pvPortMalloc+0x196>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     b22:	e9 01       	movw	r28, r18
     b24:	99 83       	std	Y+1, r25	; 0x01
     b26:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     b28:	a2 17       	cp	r26, r18
     b2a:	b3 07       	cpc	r27, r19
     b2c:	11 f0       	breq	.+4      	; 0xb32 <pvPortMalloc+0x1a0>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     b2e:	2d 93       	st	X+, r18
     b30:	3c 93       	st	X, r19
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
     b32:	22 81       	ldd	r18, Z+2	; 0x02
     b34:	33 81       	ldd	r19, Z+3	; 0x03
     b36:	80 91 63 03 	lds	r24, 0x0363	; 0x800363 <xFreeBytesRemaining>
     b3a:	90 91 64 03 	lds	r25, 0x0364	; 0x800364 <xFreeBytesRemaining+0x1>
     b3e:	82 1b       	sub	r24, r18
     b40:	93 0b       	sbc	r25, r19
     b42:	90 93 64 03 	sts	0x0364, r25	; 0x800364 <xFreeBytesRemaining+0x1>
     b46:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
     b4a:	40 91 61 03 	lds	r20, 0x0361	; 0x800361 <xMinimumEverFreeBytesRemaining>
     b4e:	50 91 62 03 	lds	r21, 0x0362	; 0x800362 <xMinimumEverFreeBytesRemaining+0x1>
     b52:	84 17       	cp	r24, r20
     b54:	95 07       	cpc	r25, r21
     b56:	20 f4       	brcc	.+8      	; 0xb60 <pvPortMalloc+0x1ce>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
     b58:	90 93 62 03 	sts	0x0362, r25	; 0x800362 <xMinimumEverFreeBytesRemaining+0x1>
     b5c:	80 93 61 03 	sts	0x0361, r24	; 0x800361 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
     b60:	80 91 5f 03 	lds	r24, 0x035F	; 0x80035f <xBlockAllocatedBit>
     b64:	90 91 60 03 	lds	r25, 0x0360	; 0x800360 <xBlockAllocatedBit+0x1>
     b68:	28 2b       	or	r18, r24
     b6a:	39 2b       	or	r19, r25
     b6c:	33 83       	std	Z+3, r19	; 0x03
     b6e:	22 83       	std	Z+2, r18	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
     b70:	11 82       	std	Z+1, r1	; 0x01
     b72:	10 82       	st	Z, r1
     b74:	0e c0       	rjmp	.+28     	; 0xb92 <pvPortMalloc+0x200>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
     b76:	e1 2c       	mov	r14, r1
     b78:	f1 2c       	mov	r15, r1
     b7a:	0b c0       	rjmp	.+22     	; 0xb92 <pvPortMalloc+0x200>
     b7c:	e1 2c       	mov	r14, r1
     b7e:	f1 2c       	mov	r15, r1
     b80:	08 c0       	rjmp	.+16     	; 0xb92 <pvPortMalloc+0x200>
     b82:	e1 2c       	mov	r14, r1
     b84:	f1 2c       	mov	r15, r1
     b86:	05 c0       	rjmp	.+10     	; 0xb92 <pvPortMalloc+0x200>
     b88:	e1 2c       	mov	r14, r1
     b8a:	f1 2c       	mov	r15, r1
     b8c:	02 c0       	rjmp	.+4      	; 0xb92 <pvPortMalloc+0x200>
     b8e:	e1 2c       	mov	r14, r1
     b90:	f1 2c       	mov	r15, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
     b92:	0e 94 2d 14 	call	0x285a	; 0x285a <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( uint32_t ) pvReturn ) & portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
     b96:	c7 01       	movw	r24, r14
     b98:	df 91       	pop	r29
     b9a:	cf 91       	pop	r28
     b9c:	1f 91       	pop	r17
     b9e:	0f 91       	pop	r16
     ba0:	ff 90       	pop	r15
     ba2:	ef 90       	pop	r14
     ba4:	08 95       	ret

00000ba6 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
     ba6:	cf 93       	push	r28
     ba8:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
     baa:	00 97       	sbiw	r24, 0x00	; 0
     bac:	09 f4       	brne	.+2      	; 0xbb0 <vPortFree+0xa>
     bae:	68 c0       	rjmp	.+208    	; 0xc80 <vPortFree+0xda>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
     bb0:	fc 01       	movw	r30, r24
     bb2:	34 97       	sbiw	r30, 0x04	; 4
     bb4:	22 81       	ldd	r18, Z+2	; 0x02
     bb6:	33 81       	ldd	r19, Z+3	; 0x03
     bb8:	40 91 5f 03 	lds	r20, 0x035F	; 0x80035f <xBlockAllocatedBit>
     bbc:	50 91 60 03 	lds	r21, 0x0360	; 0x800360 <xBlockAllocatedBit+0x1>
     bc0:	b9 01       	movw	r22, r18
     bc2:	64 23       	and	r22, r20
     bc4:	75 23       	and	r23, r21
     bc6:	67 2b       	or	r22, r23
     bc8:	09 f4       	brne	.+2      	; 0xbcc <vPortFree+0x26>
     bca:	5a c0       	rjmp	.+180    	; 0xc80 <vPortFree+0xda>
		{
			if( pxLink->pxNextFreeBlock == NULL )
     bcc:	60 81       	ld	r22, Z
     bce:	71 81       	ldd	r23, Z+1	; 0x01
     bd0:	67 2b       	or	r22, r23
     bd2:	09 f0       	breq	.+2      	; 0xbd6 <vPortFree+0x30>
     bd4:	55 c0       	rjmp	.+170    	; 0xc80 <vPortFree+0xda>

	if( pv != NULL )
	{
		/* The memory being freed will have an BlockLink_t structure immediately
		before it. */
		puc -= xHeapStructSize;
     bd6:	ef 01       	movw	r28, r30
		{
			if( pxLink->pxNextFreeBlock == NULL )
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
     bd8:	40 95       	com	r20
     bda:	50 95       	com	r21
     bdc:	24 23       	and	r18, r20
     bde:	35 23       	and	r19, r21
     be0:	33 83       	std	Z+3, r19	; 0x03
     be2:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
     be4:	0e 94 27 14 	call	0x284e	; 0x284e <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
     be8:	4a 81       	ldd	r20, Y+2	; 0x02
     bea:	5b 81       	ldd	r21, Y+3	; 0x03
     bec:	80 91 63 03 	lds	r24, 0x0363	; 0x800363 <xFreeBytesRemaining>
     bf0:	90 91 64 03 	lds	r25, 0x0364	; 0x800364 <xFreeBytesRemaining+0x1>
     bf4:	84 0f       	add	r24, r20
     bf6:	95 1f       	adc	r25, r21
     bf8:	90 93 64 03 	sts	0x0364, r25	; 0x800364 <xFreeBytesRemaining+0x1>
     bfc:	80 93 63 03 	sts	0x0363, r24	; 0x800363 <xFreeBytesRemaining>
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
     c00:	e7 e6       	ldi	r30, 0x67	; 103
     c02:	f3 e0       	ldi	r31, 0x03	; 3
     c04:	01 c0       	rjmp	.+2      	; 0xc08 <vPortFree+0x62>
     c06:	fc 01       	movw	r30, r24
     c08:	80 81       	ld	r24, Z
     c0a:	91 81       	ldd	r25, Z+1	; 0x01
     c0c:	8c 17       	cp	r24, r28
     c0e:	9d 07       	cpc	r25, r29
     c10:	d0 f3       	brcs	.-12     	; 0xc06 <vPortFree+0x60>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
     c12:	22 81       	ldd	r18, Z+2	; 0x02
     c14:	33 81       	ldd	r19, Z+3	; 0x03
     c16:	bf 01       	movw	r22, r30
     c18:	62 0f       	add	r22, r18
     c1a:	73 1f       	adc	r23, r19
     c1c:	c6 17       	cp	r28, r22
     c1e:	d7 07       	cpc	r29, r23
     c20:	29 f4       	brne	.+10     	; 0xc2c <vPortFree+0x86>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
     c22:	24 0f       	add	r18, r20
     c24:	35 1f       	adc	r19, r21
     c26:	33 83       	std	Z+3, r19	; 0x03
     c28:	22 83       	std	Z+2, r18	; 0x02
     c2a:	ef 01       	movw	r28, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
     c2c:	2a 81       	ldd	r18, Y+2	; 0x02
     c2e:	3b 81       	ldd	r19, Y+3	; 0x03
     c30:	de 01       	movw	r26, r28
     c32:	a2 0f       	add	r26, r18
     c34:	b3 1f       	adc	r27, r19
     c36:	8a 17       	cp	r24, r26
     c38:	9b 07       	cpc	r25, r27
     c3a:	c9 f4       	brne	.+50     	; 0xc6e <vPortFree+0xc8>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
     c3c:	80 91 65 03 	lds	r24, 0x0365	; 0x800365 <pxEnd>
     c40:	90 91 66 03 	lds	r25, 0x0366	; 0x800366 <pxEnd+0x1>
     c44:	a8 17       	cp	r26, r24
     c46:	b9 07       	cpc	r27, r25
     c48:	79 f0       	breq	.+30     	; 0xc68 <vPortFree+0xc2>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
     c4a:	12 96       	adiw	r26, 0x02	; 2
     c4c:	8d 91       	ld	r24, X+
     c4e:	9c 91       	ld	r25, X
     c50:	13 97       	sbiw	r26, 0x03	; 3
     c52:	28 0f       	add	r18, r24
     c54:	39 1f       	adc	r19, r25
     c56:	3b 83       	std	Y+3, r19	; 0x03
     c58:	2a 83       	std	Y+2, r18	; 0x02
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
     c5a:	a0 81       	ld	r26, Z
     c5c:	b1 81       	ldd	r27, Z+1	; 0x01
     c5e:	8d 91       	ld	r24, X+
     c60:	9c 91       	ld	r25, X
     c62:	99 83       	std	Y+1, r25	; 0x01
     c64:	88 83       	st	Y, r24
     c66:	05 c0       	rjmp	.+10     	; 0xc72 <vPortFree+0xcc>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
     c68:	b9 83       	std	Y+1, r27	; 0x01
     c6a:	a8 83       	st	Y, r26
     c6c:	02 c0       	rjmp	.+4      	; 0xc72 <vPortFree+0xcc>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
     c6e:	99 83       	std	Y+1, r25	; 0x01
     c70:	88 83       	st	Y, r24

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
     c72:	ec 17       	cp	r30, r28
     c74:	fd 07       	cpc	r31, r29
     c76:	11 f0       	breq	.+4      	; 0xc7c <vPortFree+0xd6>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
     c78:	d1 83       	std	Z+1, r29	; 0x01
     c7a:	c0 83       	st	Z, r28
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
				}
				( void ) xTaskResumeAll();
     c7c:	0e 94 2d 14 	call	0x285a	; 0x285a <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
     c80:	df 91       	pop	r29
     c82:	cf 91       	pop	r28
     c84:	08 95       	ret

00000c86 <sIMU_readRegister>:
    int16_t tempBuffer = (myBuffer[1] << 8);
    int16_t output = (int16_t)myBuffer[0] | tempBuffer;
    
    *outputPointer = output;
    return returnError;
}
     c86:	cf 93       	push	r28
     c88:	df 93       	push	r29
     c8a:	ec 01       	movw	r28, r24
     c8c:	28 98       	cbi	0x05, 0	; 5
     c8e:	86 2f       	mov	r24, r22
     c90:	80 68       	ori	r24, 0x80	; 128
     c92:	0e 94 89 11 	call	0x2312	; 0x2312 <ui8SPI_MasterTransmit>
     c96:	80 e0       	ldi	r24, 0x00	; 0
     c98:	0e 94 89 11 	call	0x2312	; 0x2312 <ui8SPI_MasterTransmit>
     c9c:	28 9a       	sbi	0x05, 0	; 5
     c9e:	8f 3f       	cpi	r24, 0xFF	; 255
     ca0:	11 f4       	brne	.+4      	; 0xca6 <sIMU_readRegister+0x20>
     ca2:	95 e0       	ldi	r25, 0x05	; 5
     ca4:	01 c0       	rjmp	.+2      	; 0xca8 <sIMU_readRegister+0x22>
     ca6:	90 e0       	ldi	r25, 0x00	; 0
     ca8:	88 83       	st	Y, r24
     caa:	89 2f       	mov	r24, r25
     cac:	df 91       	pop	r29
     cae:	cf 91       	pop	r28
     cb0:	08 95       	ret

00000cb2 <sIMU_Init>:
     cb2:	cf 93       	push	r28
     cb4:	df 93       	push	r29
     cb6:	1f 92       	push	r1
     cb8:	1f 92       	push	r1
     cba:	cd b7       	in	r28, 0x3d	; 61
     cbc:	de b7       	in	r29, 0x3e	; 62
     cbe:	ee ea       	ldi	r30, 0xAE	; 174
     cc0:	f6 e1       	ldi	r31, 0x16	; 22
     cc2:	81 e0       	ldi	r24, 0x01	; 1
     cc4:	80 83       	st	Z, r24
     cc6:	24 ef       	ldi	r18, 0xF4	; 244
     cc8:	31 e0       	ldi	r19, 0x01	; 1
     cca:	32 83       	std	Z+2, r19	; 0x02
     ccc:	21 83       	std	Z+1, r18	; 0x01
     cce:	22 e8       	ldi	r18, 0x82	; 130
     cd0:	36 e0       	ldi	r19, 0x06	; 6
     cd2:	34 83       	std	Z+4, r19	; 0x04
     cd4:	23 83       	std	Z+3, r18	; 0x03
     cd6:	20 e9       	ldi	r18, 0x90	; 144
     cd8:	31 e0       	ldi	r19, 0x01	; 1
     cda:	36 83       	std	Z+6, r19	; 0x06
     cdc:	25 83       	std	Z+5, r18	; 0x05
     cde:	17 82       	std	Z+7, r1	; 0x07
     ce0:	10 86       	std	Z+8, r1	; 0x08
     ce2:	81 87       	std	Z+9, r24	; 0x09
     ce4:	82 87       	std	Z+10, r24	; 0x0a
     ce6:	20 e1       	ldi	r18, 0x10	; 16
     ce8:	30 e0       	ldi	r19, 0x00	; 0
     cea:	34 87       	std	Z+12, r19	; 0x0c
     cec:	23 87       	std	Z+11, r18	; 0x0b
     cee:	2d e0       	ldi	r18, 0x0D	; 13
     cf0:	30 e0       	ldi	r19, 0x00	; 0
     cf2:	36 87       	std	Z+14, r19	; 0x0e
     cf4:	25 87       	std	Z+13, r18	; 0x0d
     cf6:	22 e3       	ldi	r18, 0x32	; 50
     cf8:	30 e0       	ldi	r19, 0x00	; 0
     cfa:	30 8b       	std	Z+16, r19	; 0x10
     cfc:	27 87       	std	Z+15, r18	; 0x0f
     cfe:	11 8a       	std	Z+17, r1	; 0x11
     d00:	12 8a       	std	Z+18, r1	; 0x12
     d02:	83 8b       	std	Z+19, r24	; 0x13
     d04:	84 8b       	std	Z+20, r24	; 0x14
     d06:	88 eb       	ldi	r24, 0xB8	; 184
     d08:	9b e0       	ldi	r25, 0x0B	; 11
     d0a:	96 8b       	std	Z+22, r25	; 0x16
     d0c:	85 8b       	std	Z+21, r24	; 0x15
     d0e:	8a e0       	ldi	r24, 0x0A	; 10
     d10:	90 e0       	ldi	r25, 0x00	; 0
     d12:	90 8f       	std	Z+24, r25	; 0x18
     d14:	87 8b       	std	Z+23, r24	; 0x17
     d16:	11 8e       	std	Z+25, r1	; 0x19
     d18:	10 92 c9 16 	sts	0x16C9, r1	; 0x8016c9 <allOnesCounter+0x1>
     d1c:	10 92 c8 16 	sts	0x16C8, r1	; 0x8016c8 <allOnesCounter>
     d20:	10 92 cb 16 	sts	0x16CB, r1	; 0x8016cb <nonSuccessCounter+0x1>
     d24:	10 92 ca 16 	sts	0x16CA, r1	; 0x8016ca <nonSuccessCounter>
     d28:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <vSPI_MasterInit>
     d2c:	20 9a       	sbi	0x04, 0	; 4
     d2e:	28 9a       	sbi	0x05, 0	; 5
     d30:	19 82       	std	Y+1, r1	; 0x01
     d32:	20 e1       	ldi	r18, 0x10	; 16
     d34:	37 e2       	ldi	r19, 0x27	; 39
     d36:	89 81       	ldd	r24, Y+1	; 0x01
     d38:	8f 5f       	subi	r24, 0xFF	; 255
     d3a:	89 83       	std	Y+1, r24	; 0x01
     d3c:	21 50       	subi	r18, 0x01	; 1
     d3e:	31 09       	sbc	r19, r1
     d40:	d1 f7       	brne	.-12     	; 0xd36 <sIMU_Init+0x84>
     d42:	6f e0       	ldi	r22, 0x0F	; 15
     d44:	ce 01       	movw	r24, r28
     d46:	02 96       	adiw	r24, 0x02	; 2
     d48:	9e df       	rcall	.-196    	; 0xc86 <sIMU_readRegister>
     d4a:	8a 81       	ldd	r24, Y+2	; 0x02
     d4c:	89 36       	cpi	r24, 0x69	; 105
     d4e:	c9 f7       	brne	.-14     	; 0xd42 <sIMU_Init+0x90>
     d50:	80 e0       	ldi	r24, 0x00	; 0
     d52:	0f 90       	pop	r0
     d54:	0f 90       	pop	r0
     d56:	df 91       	pop	r29
     d58:	cf 91       	pop	r28
     d5a:	08 95       	ret

00000d5c <sIMU_writeRegister>:
//  Parameters:
//    offset -- register to write
//    dataToWrite -- 8 bit data to write to register
//
//****************************************************************************//
status_t sIMU_writeRegister(uint8_t offset, uint8_t dataToWrite ){
     d5c:	cf 93       	push	r28
     d5e:	c6 2f       	mov	r28, r22
    status_t returnError = IMU_SUCCESS;

    // take the chip select low to select the device:
    PORTB &= ~(1<<IMU_SS);
     d60:	28 98       	cbi	0x05, 0	; 5
    // send the device the register you want to read:
    ui8SPI_MasterTransmit(offset);
     d62:	0e 94 89 11 	call	0x2312	; 0x2312 <ui8SPI_MasterTransmit>
    // send a value of 0 to read the first byte returned:
    ui8SPI_MasterTransmit(dataToWrite);
     d66:	8c 2f       	mov	r24, r28
     d68:	0e 94 89 11 	call	0x2312	; 0x2312 <ui8SPI_MasterTransmit>
    // decrement the number of bytes left to read:
    // take the chip select high to de-select:
    PORTB |= (1<<IMU_SS);
     d6c:	28 9a       	sbi	0x05, 0	; 5
    return returnError;
}
     d6e:	80 e0       	ldi	r24, 0x00	; 0
     d70:	cf 91       	pop	r28
     d72:	08 95       	ret

00000d74 <sIMU_begin>:
//  This uses the stored SensorSettings to start the IMU
//  Use statements such as 
//  "myIMU.settings.accelEnabled = 1;" to configure before calling .begin();
//
//****************************************************************************//
status_t sIMU_begin(){
     d74:	1f 93       	push	r17
     d76:	cf 93       	push	r28
     d78:	df 93       	push	r29
     d7a:	1f 92       	push	r1
     d7c:	1f 92       	push	r1
     d7e:	cd b7       	in	r28, 0x3d	; 61
     d80:	de b7       	in	r29, 0x3e	; 62
    //Check the settings structure values to determine how to setup the device
    uint8_t dataToWrite = 0;  //Temporary variable
     d82:	19 82       	std	Y+1, r1	; 0x01

    //Initialize the IMU and the SPI driver
    status_t returnError = sIMU_Init();
     d84:	96 df       	rcall	.-212    	; 0xcb2 <sIMU_Init>
     d86:	18 2f       	mov	r17, r24

    //Setup the accelerometer******************************
    dataToWrite = 0; //Start Fresh!
     d88:	19 82       	std	Y+1, r1	; 0x01
    if ( settings.accelEnabled == 1) {
     d8a:	80 91 b7 16 	lds	r24, 0x16B7	; 0x8016b7 <settings+0x9>
     d8e:	81 30       	cpi	r24, 0x01	; 1
     d90:	09 f0       	breq	.+2      	; 0xd94 <sIMU_begin+0x20>
     d92:	83 c0       	rjmp	.+262    	; 0xe9a <sIMU_begin+0x126>
        //Build config reg
        //First patch in filter bandwidth
        switch (settings.accelBandWidth) {
     d94:	80 91 bd 16 	lds	r24, 0x16BD	; 0x8016bd <settings+0xf>
     d98:	90 91 be 16 	lds	r25, 0x16BE	; 0x8016be <settings+0x10>
     d9c:	84 36       	cpi	r24, 0x64	; 100
     d9e:	91 05       	cpc	r25, r1
     da0:	41 f0       	breq	.+16     	; 0xdb2 <sIMU_begin+0x3e>
     da2:	88 3c       	cpi	r24, 0xC8	; 200
     da4:	91 05       	cpc	r25, r1
     da6:	41 f0       	breq	.+16     	; 0xdb8 <sIMU_begin+0x44>
     da8:	c2 97       	sbiw	r24, 0x32	; 50
     daa:	41 f4       	brne	.+16     	; 0xdbc <sIMU_begin+0x48>
            case 50:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_50Hz;
     dac:	83 e0       	ldi	r24, 0x03	; 3
     dae:	89 83       	std	Y+1, r24	; 0x01
            break;
     db0:	05 c0       	rjmp	.+10     	; 0xdbc <sIMU_begin+0x48>
            case 100:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_100Hz;
     db2:	82 e0       	ldi	r24, 0x02	; 2
     db4:	89 83       	std	Y+1, r24	; 0x01
            break;
     db6:	02 c0       	rjmp	.+4      	; 0xdbc <sIMU_begin+0x48>
            case 200:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_200Hz;
     db8:	81 e0       	ldi	r24, 0x01	; 1
     dba:	89 83       	std	Y+1, r24	; 0x01
            case 400:
            dataToWrite |= LSM6DS3_ACC_GYRO_BW_XL_400Hz;
            break;
        }
        //Next, patch in full scale
        switch (settings.accelRange) {
     dbc:	80 91 b9 16 	lds	r24, 0x16B9	; 0x8016b9 <settings+0xb>
     dc0:	90 91 ba 16 	lds	r25, 0x16BA	; 0x8016ba <settings+0xc>
     dc4:	84 30       	cpi	r24, 0x04	; 4
     dc6:	91 05       	cpc	r25, r1
     dc8:	31 f0       	breq	.+12     	; 0xdd6 <sIMU_begin+0x62>
     dca:	88 30       	cpi	r24, 0x08	; 8
     dcc:	91 05       	cpc	r25, r1
     dce:	39 f0       	breq	.+14     	; 0xdde <sIMU_begin+0x6a>
     dd0:	02 97       	sbiw	r24, 0x02	; 2
     dd2:	49 f4       	brne	.+18     	; 0xde6 <sIMU_begin+0x72>
     dd4:	0b c0       	rjmp	.+22     	; 0xdec <sIMU_begin+0x78>
            case 2:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_2g;
            break;
            case 4:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_4g;
     dd6:	89 81       	ldd	r24, Y+1	; 0x01
     dd8:	88 60       	ori	r24, 0x08	; 8
     dda:	89 83       	std	Y+1, r24	; 0x01
            break;
     ddc:	07 c0       	rjmp	.+14     	; 0xdec <sIMU_begin+0x78>
            case 8:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_8g;
     dde:	89 81       	ldd	r24, Y+1	; 0x01
     de0:	8c 60       	ori	r24, 0x0C	; 12
     de2:	89 83       	std	Y+1, r24	; 0x01
            break;
     de4:	03 c0       	rjmp	.+6      	; 0xdec <sIMU_begin+0x78>
            default:  //set default case to 16(max)
            case 16:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_XL_16g;
     de6:	89 81       	ldd	r24, Y+1	; 0x01
     de8:	84 60       	ori	r24, 0x04	; 4
     dea:	89 83       	std	Y+1, r24	; 0x01
            break;
        }
        //Lastly, patch in accelerometer ODR
        switch (settings.accelSampleRate) {
     dec:	80 91 bb 16 	lds	r24, 0x16BB	; 0x8016bb <settings+0xd>
     df0:	90 91 bc 16 	lds	r25, 0x16BC	; 0x8016bc <settings+0xe>
     df4:	80 3a       	cpi	r24, 0xA0	; 160
     df6:	21 e0       	ldi	r18, 0x01	; 1
     df8:	92 07       	cpc	r25, r18
     dfa:	c1 f1       	breq	.+112    	; 0xe6c <sIMU_begin+0xf8>
     dfc:	70 f4       	brcc	.+28     	; 0xe1a <sIMU_begin+0xa6>
     dfe:	8a 31       	cpi	r24, 0x1A	; 26
     e00:	91 05       	cpc	r25, r1
     e02:	21 f1       	breq	.+72     	; 0xe4c <sIMU_begin+0xd8>
     e04:	18 f4       	brcc	.+6      	; 0xe0c <sIMU_begin+0x98>
     e06:	0d 97       	sbiw	r24, 0x0d	; 13
     e08:	e9 f0       	breq	.+58     	; 0xe44 <sIMU_begin+0xd0>
     e0a:	28 c0       	rjmp	.+80     	; 0xe5c <sIMU_begin+0xe8>
     e0c:	84 33       	cpi	r24, 0x34	; 52
     e0e:	91 05       	cpc	r25, r1
     e10:	09 f1       	breq	.+66     	; 0xe54 <sIMU_begin+0xe0>
     e12:	80 3d       	cpi	r24, 0xD0	; 208
     e14:	91 05       	cpc	r25, r1
     e16:	31 f1       	breq	.+76     	; 0xe64 <sIMU_begin+0xf0>
     e18:	21 c0       	rjmp	.+66     	; 0xe5c <sIMU_begin+0xe8>
     e1a:	82 30       	cpi	r24, 0x02	; 2
     e1c:	2d e0       	ldi	r18, 0x0D	; 13
     e1e:	92 07       	cpc	r25, r18
     e20:	89 f1       	breq	.+98     	; 0xe84 <sIMU_begin+0x110>
     e22:	40 f4       	brcc	.+16     	; 0xe34 <sIMU_begin+0xc0>
     e24:	81 34       	cpi	r24, 0x41	; 65
     e26:	23 e0       	ldi	r18, 0x03	; 3
     e28:	92 07       	cpc	r25, r18
     e2a:	21 f1       	breq	.+72     	; 0xe74 <sIMU_begin+0x100>
     e2c:	8c 37       	cpi	r24, 0x7C	; 124
     e2e:	96 40       	sbci	r25, 0x06	; 6
     e30:	29 f1       	breq	.+74     	; 0xe7c <sIMU_begin+0x108>
     e32:	14 c0       	rjmp	.+40     	; 0xe5c <sIMU_begin+0xe8>
     e34:	84 30       	cpi	r24, 0x04	; 4
     e36:	2a e1       	ldi	r18, 0x1A	; 26
     e38:	92 07       	cpc	r25, r18
     e3a:	41 f1       	breq	.+80     	; 0xe8c <sIMU_begin+0x118>
     e3c:	82 31       	cpi	r24, 0x12	; 18
     e3e:	94 43       	sbci	r25, 0x34	; 52
     e40:	49 f1       	breq	.+82     	; 0xe94 <sIMU_begin+0x120>
     e42:	0c c0       	rjmp	.+24     	; 0xe5c <sIMU_begin+0xe8>
            case 13:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_13Hz;
     e44:	89 81       	ldd	r24, Y+1	; 0x01
     e46:	80 61       	ori	r24, 0x10	; 16
     e48:	89 83       	std	Y+1, r24	; 0x01
            break;
     e4a:	27 c0       	rjmp	.+78     	; 0xe9a <sIMU_begin+0x126>
            case 26:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_26Hz;
     e4c:	89 81       	ldd	r24, Y+1	; 0x01
     e4e:	80 62       	ori	r24, 0x20	; 32
     e50:	89 83       	std	Y+1, r24	; 0x01
            break;
     e52:	23 c0       	rjmp	.+70     	; 0xe9a <sIMU_begin+0x126>
            case 52:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_52Hz;
     e54:	89 81       	ldd	r24, Y+1	; 0x01
     e56:	80 63       	ori	r24, 0x30	; 48
     e58:	89 83       	std	Y+1, r24	; 0x01
            break;
     e5a:	1f c0       	rjmp	.+62     	; 0xe9a <sIMU_begin+0x126>
            default:  //Set default to 104
            case 104:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_104Hz;
     e5c:	89 81       	ldd	r24, Y+1	; 0x01
     e5e:	80 64       	ori	r24, 0x40	; 64
     e60:	89 83       	std	Y+1, r24	; 0x01
            break;
     e62:	1b c0       	rjmp	.+54     	; 0xe9a <sIMU_begin+0x126>
            case 208:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_208Hz;
     e64:	89 81       	ldd	r24, Y+1	; 0x01
     e66:	80 65       	ori	r24, 0x50	; 80
     e68:	89 83       	std	Y+1, r24	; 0x01
            break;
     e6a:	17 c0       	rjmp	.+46     	; 0xe9a <sIMU_begin+0x126>
            case 416:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_416Hz;
     e6c:	89 81       	ldd	r24, Y+1	; 0x01
     e6e:	80 66       	ori	r24, 0x60	; 96
     e70:	89 83       	std	Y+1, r24	; 0x01
            break;
     e72:	13 c0       	rjmp	.+38     	; 0xe9a <sIMU_begin+0x126>
            case 833:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_833Hz;
     e74:	89 81       	ldd	r24, Y+1	; 0x01
     e76:	80 67       	ori	r24, 0x70	; 112
     e78:	89 83       	std	Y+1, r24	; 0x01
            break;
     e7a:	0f c0       	rjmp	.+30     	; 0xe9a <sIMU_begin+0x126>
            case 1660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_1660Hz;
     e7c:	89 81       	ldd	r24, Y+1	; 0x01
     e7e:	80 68       	ori	r24, 0x80	; 128
     e80:	89 83       	std	Y+1, r24	; 0x01
            break;
     e82:	0b c0       	rjmp	.+22     	; 0xe9a <sIMU_begin+0x126>
            case 3330:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_3330Hz;
     e84:	89 81       	ldd	r24, Y+1	; 0x01
     e86:	80 69       	ori	r24, 0x90	; 144
     e88:	89 83       	std	Y+1, r24	; 0x01
            break;
     e8a:	07 c0       	rjmp	.+14     	; 0xe9a <sIMU_begin+0x126>
            case 6660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_6660Hz;
     e8c:	89 81       	ldd	r24, Y+1	; 0x01
     e8e:	80 6a       	ori	r24, 0xA0	; 160
     e90:	89 83       	std	Y+1, r24	; 0x01
            break;
     e92:	03 c0       	rjmp	.+6      	; 0xe9a <sIMU_begin+0x126>
            case 13330:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_XL_13330Hz;
     e94:	89 81       	ldd	r24, Y+1	; 0x01
     e96:	80 6b       	ori	r24, 0xB0	; 176
     e98:	89 83       	std	Y+1, r24	; 0x01
    {
        //dataToWrite already = 0 (powerdown);
    }

    //Now, write the patched together data
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL1_XL, dataToWrite);
     e9a:	69 81       	ldd	r22, Y+1	; 0x01
     e9c:	80 e1       	ldi	r24, 0x10	; 16
     e9e:	5e df       	rcall	.-324    	; 0xd5c <sIMU_writeRegister>

    //Set the ODR bit
    sIMU_readRegister(&dataToWrite, LSM6DS3_ACC_GYRO_CTRL4_C);
     ea0:	63 e1       	ldi	r22, 0x13	; 19
     ea2:	ce 01       	movw	r24, r28
     ea4:	01 96       	adiw	r24, 0x01	; 1
     ea6:	ef de       	rcall	.-546    	; 0xc86 <sIMU_readRegister>
    dataToWrite &= ~((uint8_t)LSM6DS3_ACC_GYRO_BW_SCAL_ODR_ENABLED);
     ea8:	89 81       	ldd	r24, Y+1	; 0x01
     eaa:	8f 77       	andi	r24, 0x7F	; 127
     eac:	89 83       	std	Y+1, r24	; 0x01
    if ( settings.accelODROff == 1) {
     eae:	90 91 b8 16 	lds	r25, 0x16B8	; 0x8016b8 <settings+0xa>
     eb2:	91 30       	cpi	r25, 0x01	; 1
     eb4:	11 f4       	brne	.+4      	; 0xeba <sIMU_begin+0x146>
        dataToWrite |= LSM6DS3_ACC_GYRO_BW_SCAL_ODR_ENABLED;
     eb6:	80 68       	ori	r24, 0x80	; 128
    }
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL4_C, dataToWrite);
     eb8:	89 83       	std	Y+1, r24	; 0x01
     eba:	69 81       	ldd	r22, Y+1	; 0x01
     ebc:	83 e1       	ldi	r24, 0x13	; 19
     ebe:	4e df       	rcall	.-356    	; 0xd5c <sIMU_writeRegister>

    //Setup the gyroscope**********************************************
    dataToWrite = 0; //Start Fresh!
     ec0:	19 82       	std	Y+1, r1	; 0x01
    if ( settings.gyroEnabled == 1) {
     ec2:	80 91 ae 16 	lds	r24, 0x16AE	; 0x8016ae <settings>
     ec6:	81 30       	cpi	r24, 0x01	; 1
     ec8:	09 f0       	breq	.+2      	; 0xecc <sIMU_begin+0x158>
     eca:	5b c0       	rjmp	.+182    	; 0xf82 <sIMU_begin+0x20e>
        //Build config reg
        //First, patch in full scale
        switch (settings.gyroRange) {
     ecc:	80 91 af 16 	lds	r24, 0x16AF	; 0x8016af <settings+0x1>
     ed0:	90 91 b0 16 	lds	r25, 0x16B0	; 0x8016b0 <settings+0x2>
     ed4:	85 3f       	cpi	r24, 0xF5	; 245
     ed6:	91 05       	cpc	r25, r1
     ed8:	c1 f0       	breq	.+48     	; 0xf0a <sIMU_begin+0x196>
     eda:	20 f4       	brcc	.+8      	; 0xee4 <sIMU_begin+0x170>
     edc:	8d 37       	cpi	r24, 0x7D	; 125
     ede:	91 05       	cpc	r25, r1
     ee0:	49 f0       	breq	.+18     	; 0xef4 <sIMU_begin+0x180>
     ee2:	11 c0       	rjmp	.+34     	; 0xf06 <sIMU_begin+0x192>
     ee4:	84 3f       	cpi	r24, 0xF4	; 244
     ee6:	21 e0       	ldi	r18, 0x01	; 1
     ee8:	92 07       	cpc	r25, r18
     eea:	39 f0       	breq	.+14     	; 0xefa <sIMU_begin+0x186>
     eec:	88 3e       	cpi	r24, 0xE8	; 232
     eee:	93 40       	sbci	r25, 0x03	; 3
     ef0:	39 f0       	breq	.+14     	; 0xf00 <sIMU_begin+0x18c>
     ef2:	09 c0       	rjmp	.+18     	; 0xf06 <sIMU_begin+0x192>
            case 125:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_125_ENABLED;
     ef4:	82 e0       	ldi	r24, 0x02	; 2
     ef6:	89 83       	std	Y+1, r24	; 0x01
            break;
     ef8:	08 c0       	rjmp	.+16     	; 0xf0a <sIMU_begin+0x196>
            case 245:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_245dps;
            break;
            case 500:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_500dps;
     efa:	84 e0       	ldi	r24, 0x04	; 4
     efc:	89 83       	std	Y+1, r24	; 0x01
            break;
     efe:	05 c0       	rjmp	.+10     	; 0xf0a <sIMU_begin+0x196>
            case 1000:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_1000dps;
     f00:	88 e0       	ldi	r24, 0x08	; 8
     f02:	89 83       	std	Y+1, r24	; 0x01
            break;
     f04:	02 c0       	rjmp	.+4      	; 0xf0a <sIMU_begin+0x196>
            default:  //Default to full 2000DPS range
            case 2000:
            dataToWrite |= LSM6DS3_ACC_GYRO_FS_G_2000dps;
     f06:	8c e0       	ldi	r24, 0x0C	; 12
     f08:	89 83       	std	Y+1, r24	; 0x01
            break;
        }
        //Lastly, patch in gyro ODR
        switch (settings.gyroSampleRate) {
     f0a:	80 91 b1 16 	lds	r24, 0x16B1	; 0x8016b1 <settings+0x3>
     f0e:	90 91 b2 16 	lds	r25, 0x16B2	; 0x8016b2 <settings+0x4>
     f12:	80 3d       	cpi	r24, 0xD0	; 208
     f14:	91 05       	cpc	r25, r1
     f16:	31 f1       	breq	.+76     	; 0xf64 <sIMU_begin+0x1f0>
     f18:	48 f4       	brcc	.+18     	; 0xf2c <sIMU_begin+0x1b8>
     f1a:	8a 31       	cpi	r24, 0x1A	; 26
     f1c:	91 05       	cpc	r25, r1
     f1e:	b1 f0       	breq	.+44     	; 0xf4c <sIMU_begin+0x1d8>
     f20:	84 33       	cpi	r24, 0x34	; 52
     f22:	91 05       	cpc	r25, r1
     f24:	b9 f0       	breq	.+46     	; 0xf54 <sIMU_begin+0x1e0>
     f26:	0d 97       	sbiw	r24, 0x0d	; 13
     f28:	c9 f4       	brne	.+50     	; 0xf5c <sIMU_begin+0x1e8>
     f2a:	0c c0       	rjmp	.+24     	; 0xf44 <sIMU_begin+0x1d0>
     f2c:	81 34       	cpi	r24, 0x41	; 65
     f2e:	23 e0       	ldi	r18, 0x03	; 3
     f30:	92 07       	cpc	r25, r18
     f32:	01 f1       	breq	.+64     	; 0xf74 <sIMU_begin+0x200>
     f34:	8c 37       	cpi	r24, 0x7C	; 124
     f36:	26 e0       	ldi	r18, 0x06	; 6
     f38:	92 07       	cpc	r25, r18
     f3a:	01 f1       	breq	.+64     	; 0xf7c <sIMU_begin+0x208>
     f3c:	80 3a       	cpi	r24, 0xA0	; 160
     f3e:	91 40       	sbci	r25, 0x01	; 1
     f40:	69 f4       	brne	.+26     	; 0xf5c <sIMU_begin+0x1e8>
     f42:	14 c0       	rjmp	.+40     	; 0xf6c <sIMU_begin+0x1f8>
            case 13:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_13Hz;
     f44:	89 81       	ldd	r24, Y+1	; 0x01
     f46:	80 61       	ori	r24, 0x10	; 16
     f48:	89 83       	std	Y+1, r24	; 0x01
            break;
     f4a:	1b c0       	rjmp	.+54     	; 0xf82 <sIMU_begin+0x20e>
            case 26:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_26Hz;
     f4c:	89 81       	ldd	r24, Y+1	; 0x01
     f4e:	80 62       	ori	r24, 0x20	; 32
     f50:	89 83       	std	Y+1, r24	; 0x01
            break;
     f52:	17 c0       	rjmp	.+46     	; 0xf82 <sIMU_begin+0x20e>
            case 52:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_52Hz;
     f54:	89 81       	ldd	r24, Y+1	; 0x01
     f56:	80 63       	ori	r24, 0x30	; 48
     f58:	89 83       	std	Y+1, r24	; 0x01
            break;
     f5a:	13 c0       	rjmp	.+38     	; 0xf82 <sIMU_begin+0x20e>
            default:  //Set default to 104
            case 104:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_104Hz;
     f5c:	89 81       	ldd	r24, Y+1	; 0x01
     f5e:	80 64       	ori	r24, 0x40	; 64
     f60:	89 83       	std	Y+1, r24	; 0x01
            break;
     f62:	0f c0       	rjmp	.+30     	; 0xf82 <sIMU_begin+0x20e>
            case 208:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_208Hz;
     f64:	89 81       	ldd	r24, Y+1	; 0x01
     f66:	80 65       	ori	r24, 0x50	; 80
     f68:	89 83       	std	Y+1, r24	; 0x01
            break;
     f6a:	0b c0       	rjmp	.+22     	; 0xf82 <sIMU_begin+0x20e>
            case 416:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_416Hz;
     f6c:	89 81       	ldd	r24, Y+1	; 0x01
     f6e:	80 66       	ori	r24, 0x60	; 96
     f70:	89 83       	std	Y+1, r24	; 0x01
            break;
     f72:	07 c0       	rjmp	.+14     	; 0xf82 <sIMU_begin+0x20e>
            case 833:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_833Hz;
     f74:	89 81       	ldd	r24, Y+1	; 0x01
     f76:	80 67       	ori	r24, 0x70	; 112
     f78:	89 83       	std	Y+1, r24	; 0x01
            break;
     f7a:	03 c0       	rjmp	.+6      	; 0xf82 <sIMU_begin+0x20e>
            case 1660:
            dataToWrite |= LSM6DS3_ACC_GYRO_ODR_G_1660Hz;
     f7c:	89 81       	ldd	r24, Y+1	; 0x01
     f7e:	80 68       	ori	r24, 0x80	; 128
    }
    else{
        //dataToWrite already = 0 (powerdown);
    }
    //Write the byte
    sIMU_writeRegister(LSM6DS3_ACC_GYRO_CTRL2_G, dataToWrite);
     f80:	89 83       	std	Y+1, r24	; 0x01
     f82:	69 81       	ldd	r22, Y+1	; 0x01
     f84:	81 e1       	ldi	r24, 0x11	; 17
    if ( settings.tempEnabled == 1) {
    }

    //Return WHO AM I reg
    uint8_t result;
    sIMU_readRegister(&result, LSM6DS3_ACC_GYRO_WHO_AM_I_REG);
     f86:	ea de       	rcall	.-556    	; 0xd5c <sIMU_writeRegister>
     f88:	6f e0       	ldi	r22, 0x0F	; 15
     f8a:	ce 01       	movw	r24, r28
     f8c:	02 96       	adiw	r24, 0x02	; 2
     f8e:	7b de       	rcall	.-778    	; 0xc86 <sIMU_readRegister>

    return returnError;
}
     f90:	81 2f       	mov	r24, r17
     f92:	0f 90       	pop	r0
     f94:	0f 90       	pop	r0
     f96:	df 91       	pop	r29
     f98:	cf 91       	pop	r28
     f9a:	1f 91       	pop	r17
     f9c:	08 95       	ret

00000f9e <vLED_init>:
/*  Custom includes    */
#include "LED.h"

/* Initialize LEDport pins as output */
void vLED_init(){
	ledReg |= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
     f9e:	ea e0       	ldi	r30, 0x0A	; 10
     fa0:	f1 e0       	ldi	r31, 0x01	; 1
     fa2:	80 81       	ld	r24, Z
     fa4:	87 60       	ori	r24, 0x07	; 7
     fa6:	80 83       	st	Z, r24
     fa8:	08 95       	ret

00000faa <vLED_singleHigh>:
}

/* Set a specific, single LED high */
void vLED_singleHigh(int ledCOLOR){
	if (ledCOLOR == ledGREEN)			ledPORT |= (1<<ledGREEN);
     faa:	82 30       	cpi	r24, 0x02	; 2
     fac:	91 05       	cpc	r25, r1
     fae:	31 f4       	brne	.+12     	; 0xfbc <vLED_singleHigh+0x12>
     fb0:	eb e0       	ldi	r30, 0x0B	; 11
     fb2:	f1 e0       	ldi	r31, 0x01	; 1
     fb4:	80 81       	ld	r24, Z
     fb6:	84 60       	ori	r24, 0x04	; 4
     fb8:	80 83       	st	Z, r24
     fba:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)		ledPORT |= (1<<ledYELLOW);
     fbc:	81 30       	cpi	r24, 0x01	; 1
     fbe:	91 05       	cpc	r25, r1
     fc0:	31 f4       	brne	.+12     	; 0xfce <vLED_singleHigh+0x24>
     fc2:	eb e0       	ldi	r30, 0x0B	; 11
     fc4:	f1 e0       	ldi	r31, 0x01	; 1
     fc6:	80 81       	ld	r24, Z
     fc8:	82 60       	ori	r24, 0x02	; 2
     fca:	80 83       	st	Z, r24
     fcc:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT |= (1<<ledRED);
     fce:	89 2b       	or	r24, r25
     fd0:	29 f4       	brne	.+10     	; 0xfdc <vLED_singleHigh+0x32>
     fd2:	eb e0       	ldi	r30, 0x0B	; 11
     fd4:	f1 e0       	ldi	r31, 0x01	; 1
     fd6:	80 81       	ld	r24, Z
     fd8:	81 60       	ori	r24, 0x01	; 1
     fda:	80 83       	st	Z, r24
     fdc:	08 95       	ret

00000fde <vLED_singleLow>:
}

/* Set a specific, single LED low */
void vLED_singleLow(int ledCOLOR){
    if (ledCOLOR == ledGREEN)			ledPORT &= ~(1<<ledGREEN);
     fde:	82 30       	cpi	r24, 0x02	; 2
     fe0:	91 05       	cpc	r25, r1
     fe2:	31 f4       	brne	.+12     	; 0xff0 <vLED_singleLow+0x12>
     fe4:	eb e0       	ldi	r30, 0x0B	; 11
     fe6:	f1 e0       	ldi	r31, 0x01	; 1
     fe8:	80 81       	ld	r24, Z
     fea:	8b 7f       	andi	r24, 0xFB	; 251
     fec:	80 83       	st	Z, r24
     fee:	08 95       	ret
    else if (ledCOLOR == ledYELLOW)		ledPORT &= ~(1<<ledYELLOW);
     ff0:	81 30       	cpi	r24, 0x01	; 1
     ff2:	91 05       	cpc	r25, r1
     ff4:	31 f4       	brne	.+12     	; 0x1002 <vLED_singleLow+0x24>
     ff6:	eb e0       	ldi	r30, 0x0B	; 11
     ff8:	f1 e0       	ldi	r31, 0x01	; 1
     ffa:	80 81       	ld	r24, Z
     ffc:	8d 7f       	andi	r24, 0xFD	; 253
     ffe:	80 83       	st	Z, r24
    1000:	08 95       	ret
    else if (ledCOLOR == ledRED)		ledPORT &= ~(1<<ledRED);
    1002:	89 2b       	or	r24, r25
    1004:	29 f4       	brne	.+10     	; 0x1010 <vLED_singleLow+0x32>
    1006:	eb e0       	ldi	r30, 0x0B	; 11
    1008:	f1 e0       	ldi	r31, 0x01	; 1
    100a:	80 81       	ld	r24, Z
    100c:	8e 7f       	andi	r24, 0xFE	; 254
    100e:	80 83       	st	Z, r24
    1010:	08 95       	ret

00001012 <vLED_toggle>:
}

/* Toggle a single LED */
void vLED_toggle(int ledCOLOR){
	if (ledCOLOR == ledGREEN)		ledPORT ^= (1<<ledGREEN);
    1012:	82 30       	cpi	r24, 0x02	; 2
    1014:	91 05       	cpc	r25, r1
    1016:	39 f4       	brne	.+14     	; 0x1026 <vLED_toggle+0x14>
    1018:	eb e0       	ldi	r30, 0x0B	; 11
    101a:	f1 e0       	ldi	r31, 0x01	; 1
    101c:	90 81       	ld	r25, Z
    101e:	84 e0       	ldi	r24, 0x04	; 4
    1020:	89 27       	eor	r24, r25
    1022:	80 83       	st	Z, r24
    1024:	08 95       	ret
	else if (ledCOLOR == ledYELLOW)	ledPORT ^= (1<<ledYELLOW);
    1026:	81 30       	cpi	r24, 0x01	; 1
    1028:	91 05       	cpc	r25, r1
    102a:	39 f4       	brne	.+14     	; 0x103a <vLED_toggle+0x28>
    102c:	eb e0       	ldi	r30, 0x0B	; 11
    102e:	f1 e0       	ldi	r31, 0x01	; 1
    1030:	90 81       	ld	r25, Z
    1032:	82 e0       	ldi	r24, 0x02	; 2
    1034:	89 27       	eor	r24, r25
    1036:	80 83       	st	Z, r24
    1038:	08 95       	ret
	else if (ledCOLOR == ledRED)		ledPORT ^= (1<<ledRED);
    103a:	89 2b       	or	r24, r25
    103c:	31 f4       	brne	.+12     	; 0x104a <vLED_toggle+0x38>
    103e:	eb e0       	ldi	r30, 0x0B	; 11
    1040:	f1 e0       	ldi	r31, 0x01	; 1
    1042:	90 81       	ld	r25, Z
    1044:	81 e0       	ldi	r24, 0x01	; 1
    1046:	89 27       	eor	r24, r25
    1048:	80 83       	st	Z, r24
    104a:	08 95       	ret

0000104c <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    104c:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    104e:	03 96       	adiw	r24, 0x03	; 3
    1050:	92 83       	std	Z+2, r25	; 0x02
    1052:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1054:	2f ef       	ldi	r18, 0xFF	; 255
    1056:	3f ef       	ldi	r19, 0xFF	; 255
    1058:	34 83       	std	Z+4, r19	; 0x04
    105a:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    105c:	96 83       	std	Z+6, r25	; 0x06
    105e:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1060:	90 87       	std	Z+8, r25	; 0x08
    1062:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1064:	10 82       	st	Z, r1
    1066:	08 95       	ret

00001068 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1068:	fc 01       	movw	r30, r24
    106a:	11 86       	std	Z+9, r1	; 0x09
    106c:	10 86       	std	Z+8, r1	; 0x08
    106e:	08 95       	ret

00001070 <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    1070:	cf 93       	push	r28
    1072:	df 93       	push	r29
    1074:	9c 01       	movw	r18, r24
    1076:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    1078:	dc 01       	movw	r26, r24
    107a:	11 96       	adiw	r26, 0x01	; 1
    107c:	cd 91       	ld	r28, X+
    107e:	dc 91       	ld	r29, X
    1080:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    1082:	d3 83       	std	Z+3, r29	; 0x03
    1084:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    1086:	8c 81       	ldd	r24, Y+4	; 0x04
    1088:	9d 81       	ldd	r25, Y+5	; 0x05
    108a:	95 83       	std	Z+5, r25	; 0x05
    108c:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    108e:	8c 81       	ldd	r24, Y+4	; 0x04
    1090:	9d 81       	ldd	r25, Y+5	; 0x05
    1092:	dc 01       	movw	r26, r24
    1094:	13 96       	adiw	r26, 0x03	; 3
    1096:	7c 93       	st	X, r23
    1098:	6e 93       	st	-X, r22
    109a:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    109c:	7d 83       	std	Y+5, r23	; 0x05
    109e:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    10a0:	31 87       	std	Z+9, r19	; 0x09
    10a2:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    10a4:	f9 01       	movw	r30, r18
    10a6:	80 81       	ld	r24, Z
    10a8:	8f 5f       	subi	r24, 0xFF	; 255
    10aa:	80 83       	st	Z, r24
}
    10ac:	df 91       	pop	r29
    10ae:	cf 91       	pop	r28
    10b0:	08 95       	ret

000010b2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    10b2:	cf 93       	push	r28
    10b4:	df 93       	push	r29
    10b6:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    10b8:	48 81       	ld	r20, Y
    10ba:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCB's which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    10bc:	4f 3f       	cpi	r20, 0xFF	; 255
    10be:	2f ef       	ldi	r18, 0xFF	; 255
    10c0:	52 07       	cpc	r21, r18
    10c2:	21 f4       	brne	.+8      	; 0x10cc <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    10c4:	fc 01       	movw	r30, r24
    10c6:	a7 81       	ldd	r26, Z+7	; 0x07
    10c8:	b0 85       	ldd	r27, Z+8	; 0x08
    10ca:	0d c0       	rjmp	.+26     	; 0x10e6 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    10cc:	dc 01       	movw	r26, r24
    10ce:	13 96       	adiw	r26, 0x03	; 3
    10d0:	01 c0       	rjmp	.+2      	; 0x10d4 <vListInsert+0x22>
    10d2:	df 01       	movw	r26, r30
    10d4:	12 96       	adiw	r26, 0x02	; 2
    10d6:	ed 91       	ld	r30, X+
    10d8:	fc 91       	ld	r31, X
    10da:	13 97       	sbiw	r26, 0x03	; 3
    10dc:	20 81       	ld	r18, Z
    10de:	31 81       	ldd	r19, Z+1	; 0x01
    10e0:	42 17       	cp	r20, r18
    10e2:	53 07       	cpc	r21, r19
    10e4:	b0 f7       	brcc	.-20     	; 0x10d2 <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    10e6:	12 96       	adiw	r26, 0x02	; 2
    10e8:	ed 91       	ld	r30, X+
    10ea:	fc 91       	ld	r31, X
    10ec:	13 97       	sbiw	r26, 0x03	; 3
    10ee:	fb 83       	std	Y+3, r31	; 0x03
    10f0:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    10f2:	d5 83       	std	Z+5, r29	; 0x05
    10f4:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    10f6:	bd 83       	std	Y+5, r27	; 0x05
    10f8:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    10fa:	13 96       	adiw	r26, 0x03	; 3
    10fc:	dc 93       	st	X, r29
    10fe:	ce 93       	st	-X, r28
    1100:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1102:	99 87       	std	Y+9, r25	; 0x09
    1104:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1106:	fc 01       	movw	r30, r24
    1108:	20 81       	ld	r18, Z
    110a:	2f 5f       	subi	r18, 0xFF	; 255
    110c:	20 83       	st	Z, r18
}
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	08 95       	ret

00001114 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1114:	cf 93       	push	r28
    1116:	df 93       	push	r29
    1118:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = ( List_t * ) pxItemToRemove->pvContainer;
    111a:	a0 85       	ldd	r26, Z+8	; 0x08
    111c:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    111e:	c2 81       	ldd	r28, Z+2	; 0x02
    1120:	d3 81       	ldd	r29, Z+3	; 0x03
    1122:	84 81       	ldd	r24, Z+4	; 0x04
    1124:	95 81       	ldd	r25, Z+5	; 0x05
    1126:	9d 83       	std	Y+5, r25	; 0x05
    1128:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    112a:	c4 81       	ldd	r28, Z+4	; 0x04
    112c:	d5 81       	ldd	r29, Z+5	; 0x05
    112e:	82 81       	ldd	r24, Z+2	; 0x02
    1130:	93 81       	ldd	r25, Z+3	; 0x03
    1132:	9b 83       	std	Y+3, r25	; 0x03
    1134:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1136:	11 96       	adiw	r26, 0x01	; 1
    1138:	8d 91       	ld	r24, X+
    113a:	9c 91       	ld	r25, X
    113c:	12 97       	sbiw	r26, 0x02	; 2
    113e:	e8 17       	cp	r30, r24
    1140:	f9 07       	cpc	r31, r25
    1142:	31 f4       	brne	.+12     	; 0x1150 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1144:	84 81       	ldd	r24, Z+4	; 0x04
    1146:	95 81       	ldd	r25, Z+5	; 0x05
    1148:	12 96       	adiw	r26, 0x02	; 2
    114a:	9c 93       	st	X, r25
    114c:	8e 93       	st	-X, r24
    114e:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pvContainer = NULL;
    1150:	11 86       	std	Z+9, r1	; 0x09
    1152:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1154:	8c 91       	ld	r24, X
    1156:	81 50       	subi	r24, 0x01	; 1
    1158:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
}
    115a:	df 91       	pop	r29
    115c:	cf 91       	pop	r28
    115e:	08 95       	ret

00001160 <vApplicationStackOverflowHook>:
}
#endif

/*  In case of stack overflow, disable all interrupts and handle it  */
void vApplicationStackOverflowHook(TaskHandle_t *pxTask, signed char *pcTaskName){
    cli();
    1160:	f8 94       	cli
    /*  Handle overflow */
    #ifdef DEBUG
       debug("Overflow\n");
    #endif
    while(1){
        vLED_toggle(ledRED);
    1162:	80 e0       	ldi	r24, 0x00	; 0
    1164:	90 e0       	ldi	r25, 0x00	; 0
    1166:	55 df       	rcall	.-342    	; 0x1012 <vLED_toggle>
    1168:	fc cf       	rjmp	.-8      	; 0x1162 <vApplicationStackOverflowHook+0x2>

0000116a <main>:
        //ledPORT ^= (1<<ledGREEN) | (1<<ledYELLOW) | (1<<ledRED);
    }// While(1) end
}

/*  Main function   */
int main(void){
    116a:	cf 93       	push	r28
    116c:	df 93       	push	r29
    116e:	1f 92       	push	r1
    1170:	cd b7       	in	r28, 0x3d	; 61
    1172:	de b7       	in	r29, 0x3e	; 62
    /* Setup - Initialize all settings before tasks  */
    /* Initialize LED, pins defined in LED.h   */
    vLED_init();
    1174:	14 df       	rcall	.-472    	; 0xf9e <vLED_init>
    vLED_singleHigh(ledRED); // Set red LED on to indicate INIT is ongoing
    1176:	80 e0       	ldi	r24, 0x00	; 0
    1178:	90 e0       	ldi	r25, 0x00	; 0
    117a:	17 df       	rcall	.-466    	; 0xfaa <vLED_singleHigh>
    /* Initialize USART driver, NB! baud is dependent on nRF51 dongle */
    vUSART_init();
    117c:	0e 94 a0 1a 	call	0x3540	; 0x3540 <vUSART_init>
    network_init();
    1180:	a2 d1       	rcall	.+836    	; 0x14c6 <network_init>
    arq_init();
    1182:	52 d8       	rcall	.-3932   	; 0x228 <arq_init>
    1184:	85 ec       	ldi	r24, 0xC5	; 197
    simple_p_init(server_receiver);
    1186:	90 e1       	ldi	r25, 0x10	; 16
    1188:	0e 94 6f 11 	call	0x22de	; 0x22de <simple_p_init>
        debug("tictoc!\n");
        tic;
    #endif
    
    /* Initialize servo for sensor tower to zero degrees */
    vServo_init(0);
    118c:	80 e0       	ldi	r24, 0x00	; 0
    /* Initialize sensors */
    vDistSens_init();
    118e:	0e 94 e7 10 	call	0x21ce	; 0x21ce <vServo_init>
    /* Initialize motor controller */
    vMotor_init();
    1192:	ef db       	rcall	.-2082   	; 0x972 <vDistSens_init>
    1194:	93 d0       	rcall	.+294    	; 0x12bc <vMotor_init>
    /* Initialize Inertial Measurement Unit (IMU) and SPI  */
    #ifdef DEBUG
        debug("IMU init..\n");
    #endif
    sIMU_begin(); 
    1196:	ee dd       	rcall	.-1060   	; 0xd74 <sIMU_begin>
    1198:	19 82       	std	Y+1, r1	; 0x01
    #endif
    
    //vCOM_init();
    
	uint8_t dummy = 30;
	uint8_t test = 0;
    119a:	9e 01       	movw	r18, r28
	while (1)
	{
		vMotorMovementSwitch(-dummy,-dummy,&test,&test);
    119c:	2f 5f       	subi	r18, 0xFF	; 255
    119e:	3f 4f       	sbci	r19, 0xFF	; 255
    11a0:	a9 01       	movw	r20, r18
    11a2:	62 ee       	ldi	r22, 0xE2	; 226
    11a4:	7f ef       	ldi	r23, 0xFF	; 255
    11a6:	82 ee       	ldi	r24, 0xE2	; 226
    11a8:	9f ef       	ldi	r25, 0xFF	; 255
    11aa:	15 d1       	rcall	.+554    	; 0x13d6 <vMotorMovementSwitch>
    11ac:	2f ef       	ldi	r18, 0xFF	; 255
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    11ae:	87 ea       	ldi	r24, 0xA7	; 167
    11b0:	91 e6       	ldi	r25, 0x61	; 97
    11b2:	21 50       	subi	r18, 0x01	; 1
    11b4:	80 40       	sbci	r24, 0x00	; 0
    11b6:	90 40       	sbci	r25, 0x00	; 0
    11b8:	e1 f7       	brne	.-8      	; 0x11b2 <main+0x48>
    11ba:	00 c0       	rjmp	.+0      	; 0x11bc <main+0x52>
    11bc:	00 00       	nop
    11be:	9e 01       	movw	r18, r28
		_delay_ms(2000);
		vMotorMovementSwitch(0,0,&test,&test);
    11c0:	2f 5f       	subi	r18, 0xFF	; 255
    11c2:	3f 4f       	sbci	r19, 0xFF	; 255
    11c4:	a9 01       	movw	r20, r18
    11c6:	60 e0       	ldi	r22, 0x00	; 0
    11c8:	70 e0       	ldi	r23, 0x00	; 0
    11ca:	80 e0       	ldi	r24, 0x00	; 0
    11cc:	90 e0       	ldi	r25, 0x00	; 0
    11ce:	03 d1       	rcall	.+518    	; 0x13d6 <vMotorMovementSwitch>
    11d0:	2f ef       	ldi	r18, 0xFF	; 255
    11d2:	87 ea       	ldi	r24, 0xA7	; 167
    11d4:	91 e6       	ldi	r25, 0x61	; 97
    11d6:	21 50       	subi	r18, 0x01	; 1
    11d8:	80 40       	sbci	r24, 0x00	; 0
    11da:	90 40       	sbci	r25, 0x00	; 0
    11dc:	e1 f7       	brne	.-8      	; 0x11d6 <main+0x6c>
    11de:	00 c0       	rjmp	.+0      	; 0x11e0 <main+0x76>
    11e0:	00 00       	nop
    11e2:	db cf       	rjmp	.-74     	; 0x119a <main+0x30>

000011e4 <__vector_4>:
    11e4:	1f 92       	push	r1

/* Handle tick from left wheel encoder */
// If ticks generate overly many interrupts, you can 
// connect to T0 and T5 pins and set up  hardware timer overflow to 
// prescale the ticks
ISR(leftWheelCount){
    11e6:	0f 92       	push	r0
    11e8:	0f b6       	in	r0, 0x3f	; 63
    11ea:	0f 92       	push	r0
    11ec:	11 24       	eor	r1, r1
    11ee:	8f 93       	push	r24
    gISR_leftWheelTicks++;
    11f0:	80 91 6d 15 	lds	r24, 0x156D	; 0x80156d <gISR_leftWheelTicks>
    11f4:	8f 5f       	subi	r24, 0xFF	; 255
    11f6:	80 93 6d 15 	sts	0x156D, r24	; 0x80156d <gISR_leftWheelTicks>
}
    11fa:	8f 91       	pop	r24
    11fc:	0f 90       	pop	r0
    11fe:	0f be       	out	0x3f, r0	; 63
    1200:	0f 90       	pop	r0
    1202:	1f 90       	pop	r1
    1204:	18 95       	reti

00001206 <__vector_3>:

/* Handle tick from right wheel encoder */
ISR(rightWheelCount){
    1206:	1f 92       	push	r1
    1208:	0f 92       	push	r0
    120a:	0f b6       	in	r0, 0x3f	; 63
    120c:	0f 92       	push	r0
    120e:	11 24       	eor	r1, r1
    1210:	8f 93       	push	r24
    gISR_rightWheelTicks++;
    1212:	80 91 6e 15 	lds	r24, 0x156E	; 0x80156e <gISR_rightWheelTicks>
    1216:	8f 5f       	subi	r24, 0xFF	; 255
    1218:	80 93 6e 15 	sts	0x156E, r24	; 0x80156e <gISR_rightWheelTicks>
}
    121c:	8f 91       	pop	r24
    121e:	0f 90       	pop	r0
    1220:	0f be       	out	0x3f, r0	; 63
    1222:	0f 90       	pop	r0
    1224:	1f 90       	pop	r1
    1226:	18 95       	reti

00001228 <__vector_5>:

/* Handle change of connection status */
ISR(nRF51_status){
    1228:	1f 92       	push	r1
    122a:	0f 92       	push	r0
    122c:	0f b6       	in	r0, 0x3f	; 63
    122e:	0f 92       	push	r0
    1230:	11 24       	eor	r1, r1
    1232:	0b b6       	in	r0, 0x3b	; 59
    1234:	0f 92       	push	r0
    1236:	2f 93       	push	r18
    1238:	3f 93       	push	r19
    123a:	4f 93       	push	r20
    123c:	5f 93       	push	r21
    123e:	6f 93       	push	r22
    1240:	7f 93       	push	r23
    1242:	8f 93       	push	r24
    1244:	9f 93       	push	r25
    1246:	af 93       	push	r26
    1248:	bf 93       	push	r27
    124a:	ef 93       	push	r30
    124c:	ff 93       	push	r31
    if (nRFconnected){
    124e:	64 99       	sbic	0x0c, 4	; 12
    1250:	07 c0       	rjmp	.+14     	; 0x1260 <__vector_5+0x38>
        // indicate we are connected
        vLED_singleHigh(ledGREEN);
    1252:	82 e0       	ldi	r24, 0x02	; 2
    1254:	90 e0       	ldi	r25, 0x00	; 0
    1256:	a9 de       	rcall	.-686    	; 0xfaa <vLED_singleHigh>
        vLED_singleHigh(ledYELLOW);
    1258:	81 e0       	ldi	r24, 0x01	; 1
    125a:	90 e0       	ldi	r25, 0x00	; 0
    125c:	a6 de       	rcall	.-692    	; 0xfaa <vLED_singleHigh>
    125e:	14 c0       	rjmp	.+40     	; 0x1288 <__vector_5+0x60>
    }
    else{
        // We are not connected or lost connection, reset handshake flag
        gHandshook = FALSE;
    1260:	10 92 6c 15 	sts	0x156C, r1	; 0x80156c <gHandshook>
        gPaused = FALSE;
    1264:	10 92 6b 15 	sts	0x156B, r1	; 0x80156b <gPaused>
        vLED_singleLow(ledGREEN);
    1268:	82 e0       	ldi	r24, 0x02	; 2
    126a:	90 e0       	ldi	r25, 0x00	; 0
    126c:	b8 de       	rcall	.-656    	; 0xfde <vLED_singleLow>
        vLED_singleLow(ledYELLOW);
    126e:	81 e0       	ldi	r24, 0x01	; 1
    1270:	90 e0       	ldi	r25, 0x00	; 0
    1272:	b5 de       	rcall	.-662    	; 0xfde <vLED_singleLow>
        vLED_singleLow(ledRED);
    1274:	80 e0       	ldi	r24, 0x00	; 0
    1276:	90 e0       	ldi	r25, 0x00	; 0
    1278:	b2 de       	rcall	.-668    	; 0xfde <vLED_singleLow>
    127a:	60 e0       	ldi	r22, 0x00	; 0
        xSemaphoreGiveFromISR(xCommandReadyBSem,0); // Let uart parser reset if needed
    127c:	70 e0       	ldi	r23, 0x00	; 0
    127e:	80 91 d4 16 	lds	r24, 0x16D4	; 0x8016d4 <xCommandReadyBSem>
    1282:	90 91 d5 16 	lds	r25, 0x16D5	; 0x8016d5 <xCommandReadyBSem+0x1>
    1286:	cc d5       	rcall	.+2968   	; 0x1e20 <xQueueGiveFromISR>
    1288:	60 e0       	ldi	r22, 0x00	; 0
    }
    xSemaphoreGiveFromISR(xControllerBSem,0); // let the controller reset if needed    
    128a:	70 e0       	ldi	r23, 0x00	; 0
    128c:	80 91 ce 16 	lds	r24, 0x16CE	; 0x8016ce <xControllerBSem>
    1290:	90 91 cf 16 	lds	r25, 0x16CF	; 0x8016cf <xControllerBSem+0x1>
    1294:	c5 d5       	rcall	.+2954   	; 0x1e20 <xQueueGiveFromISR>
    1296:	ff 91       	pop	r31
}
    1298:	ef 91       	pop	r30
    129a:	bf 91       	pop	r27
    129c:	af 91       	pop	r26
    129e:	9f 91       	pop	r25
    12a0:	8f 91       	pop	r24
    12a2:	7f 91       	pop	r23
    12a4:	6f 91       	pop	r22
    12a6:	5f 91       	pop	r21
    12a8:	4f 91       	pop	r20
    12aa:	3f 91       	pop	r19
    12ac:	2f 91       	pop	r18
    12ae:	0f 90       	pop	r0
    12b0:	0b be       	out	0x3b, r0	; 59
    12b2:	0f 90       	pop	r0
    12b4:	0f be       	out	0x3f, r0	; 63
    12b6:	0f 90       	pop	r0
    12b8:	1f 90       	pop	r1
    12ba:	18 95       	reti

000012bc <vMotor_init>:
    12bc:	e1 e0       	ldi	r30, 0x01	; 1

void vMotorGlideRight(){
    motorRightPWM = 0;
    //PORTH &= ~(1<<motorRightOn);
    PORTH &= ~(1<<motorRightForward);
    PORTH &= ~(1<<motorRightBackward);
    12be:	f1 e0       	ldi	r31, 0x01	; 1
    12c0:	80 81       	ld	r24, Z
    12c2:	80 63       	ori	r24, 0x30	; 48
    12c4:	80 83       	st	Z, r24
    12c6:	26 9a       	sbi	0x04, 6	; 4
    12c8:	84 b1       	in	r24, 0x04	; 4
    12ca:	80 66       	ori	r24, 0x60	; 96
    12cc:	84 b9       	out	0x04, r24	; 4
    12ce:	27 9a       	sbi	0x04, 7	; 4
    12d0:	2f 98       	cbi	0x05, 7	; 5
    12d2:	2e 98       	cbi	0x05, 6	; 5
    12d4:	85 b1       	in	r24, 0x05	; 5
    12d6:	8f 79       	andi	r24, 0x9F	; 159
    12d8:	85 b9       	out	0x05, r24	; 5
    12da:	e2 e0       	ldi	r30, 0x02	; 2
    12dc:	f1 e0       	ldi	r31, 0x01	; 1
    12de:	80 81       	ld	r24, Z
    12e0:	8f 7c       	andi	r24, 0xCF	; 207
    12e2:	80 83       	st	Z, r24
    12e4:	8a b1       	in	r24, 0x0a	; 10
    12e6:	8a b9       	out	0x0a, r24	; 10
    12e8:	8b b1       	in	r24, 0x0b	; 11
    12ea:	8c 60       	ori	r24, 0x0C	; 12
    12ec:	8b b9       	out	0x0b, r24	; 11
    12ee:	6c 98       	cbi	0x0d, 4	; 13
    12f0:	8d b3       	in	r24, 0x1d	; 29
    12f2:	8d bb       	out	0x1d, r24	; 29
    12f4:	e9 e6       	ldi	r30, 0x69	; 105
    12f6:	f0 e0       	ldi	r31, 0x00	; 0
    12f8:	80 81       	ld	r24, Z
    12fa:	80 6f       	ori	r24, 0xF0	; 240
    12fc:	80 83       	st	Z, r24
    12fe:	ea e6       	ldi	r30, 0x6A	; 106
    1300:	f0 e0       	ldi	r31, 0x00	; 0
    1302:	80 81       	ld	r24, Z
    1304:	81 60       	ori	r24, 0x01	; 1
    1306:	80 83       	st	Z, r24
    1308:	8c e1       	ldi	r24, 0x1C	; 28
    130a:	8c bb       	out	0x1c, r24	; 28
    130c:	8d b3       	in	r24, 0x1d	; 29
    130e:	8c 61       	ori	r24, 0x1C	; 28
    1310:	8d bb       	out	0x1d, r24	; 29
    1312:	84 b5       	in	r24, 0x24	; 36
    1314:	80 68       	ori	r24, 0x80	; 128
    1316:	84 bd       	out	0x24, r24	; 36
    1318:	e0 e8       	ldi	r30, 0x80	; 128
    131a:	f0 e0       	ldi	r31, 0x00	; 0
    131c:	80 81       	ld	r24, Z
    131e:	80 62       	ori	r24, 0x20	; 32
    1320:	80 83       	st	Z, r24
    1322:	84 b5       	in	r24, 0x24	; 36
    1324:	83 60       	ori	r24, 0x03	; 3
    1326:	84 bd       	out	0x24, r24	; 36
    1328:	85 b5       	in	r24, 0x25	; 37
    132a:	85 bd       	out	0x25, r24	; 37
    132c:	80 81       	ld	r24, Z
    132e:	81 60       	ori	r24, 0x01	; 1
    1330:	80 83       	st	Z, r24
    1332:	e1 e8       	ldi	r30, 0x81	; 129
    1334:	f0 e0       	ldi	r31, 0x00	; 0
    1336:	80 81       	ld	r24, Z
    1338:	88 60       	ori	r24, 0x08	; 8
    133a:	80 83       	st	Z, r24
    133c:	85 b5       	in	r24, 0x25	; 37
    133e:	85 60       	ori	r24, 0x05	; 5
    1340:	85 bd       	out	0x25, r24	; 37
    1342:	80 81       	ld	r24, Z
    1344:	85 60       	ori	r24, 0x05	; 5
    1346:	80 83       	st	Z, r24
    1348:	26 9a       	sbi	0x04, 6	; 4
    134a:	27 9a       	sbi	0x04, 7	; 4
    134c:	08 95       	ret

0000134e <vMotorMoveLeftForward>:
    134e:	87 bd       	out	0x27, r24	; 39
    1350:	2c 9a       	sbi	0x05, 4	; 5
    1352:	2d 98       	cbi	0x05, 5	; 5
    1354:	84 e0       	ldi	r24, 0x04	; 4
    1356:	fb 01       	movw	r30, r22
    1358:	80 83       	st	Z, r24
    135a:	08 95       	ret

0000135c <vMotorMoveRightForward>:
    135c:	90 e0       	ldi	r25, 0x00	; 0
    135e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    1362:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    1366:	e2 e0       	ldi	r30, 0x02	; 2
    1368:	f1 e0       	ldi	r31, 0x01	; 1
    136a:	80 81       	ld	r24, Z
    136c:	80 64       	ori	r24, 0x40	; 64
    136e:	80 83       	st	Z, r24
    1370:	80 81       	ld	r24, Z
    1372:	8f 7d       	andi	r24, 0xDF	; 223
    1374:	80 83       	st	Z, r24
    1376:	86 e0       	ldi	r24, 0x06	; 6
    1378:	fb 01       	movw	r30, r22
    137a:	80 83       	st	Z, r24
    137c:	08 95       	ret

0000137e <vMotorMoveLeftBackward>:
    137e:	87 bd       	out	0x27, r24	; 39
    1380:	2c 98       	cbi	0x05, 4	; 5
    1382:	2d 9a       	sbi	0x05, 5	; 5
    1384:	85 e0       	ldi	r24, 0x05	; 5
    1386:	fb 01       	movw	r30, r22
    1388:	80 83       	st	Z, r24
    138a:	08 95       	ret

0000138c <vMotorMoveRightBackward>:
    138c:	90 e0       	ldi	r25, 0x00	; 0
    138e:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    1392:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    1396:	e2 e0       	ldi	r30, 0x02	; 2
    1398:	f1 e0       	ldi	r31, 0x01	; 1
    139a:	80 81       	ld	r24, Z
    139c:	8f 7b       	andi	r24, 0xBF	; 191
    139e:	80 83       	st	Z, r24
    13a0:	80 81       	ld	r24, Z
    13a2:	80 62       	ori	r24, 0x20	; 32
    13a4:	80 83       	st	Z, r24
    13a6:	85 e0       	ldi	r24, 0x05	; 5
    13a8:	fb 01       	movw	r30, r22
    13aa:	80 83       	st	Z, r24
    13ac:	08 95       	ret

000013ae <vMotorBrakeLeft>:
    13ae:	8f ef       	ldi	r24, 0xFF	; 255
    13b0:	87 bd       	out	0x27, r24	; 39
    13b2:	2c 98       	cbi	0x05, 4	; 5
    13b4:	2d 98       	cbi	0x05, 5	; 5
    13b6:	08 95       	ret

000013b8 <vMotorBrakeRight>:
    13b8:	8f ef       	ldi	r24, 0xFF	; 255
    13ba:	90 e0       	ldi	r25, 0x00	; 0
    13bc:	90 93 8b 00 	sts	0x008B, r25	; 0x80008b <__TEXT_REGION_LENGTH__+0x70008b>
    13c0:	80 93 8a 00 	sts	0x008A, r24	; 0x80008a <__TEXT_REGION_LENGTH__+0x70008a>
    13c4:	e2 e0       	ldi	r30, 0x02	; 2
    13c6:	f1 e0       	ldi	r31, 0x01	; 1
    13c8:	80 81       	ld	r24, Z
    13ca:	8f 7b       	andi	r24, 0xBF	; 191
    13cc:	80 83       	st	Z, r24
    13ce:	80 81       	ld	r24, Z
    13d0:	8f 7d       	andi	r24, 0xDF	; 223
    13d2:	80 83       	st	Z, r24
    13d4:	08 95       	ret

000013d6 <vMotorMovementSwitch>:
}
/* Switch for robot movement to abstract the logic away from main */

void vMotorMovementSwitch(int16_t leftSpeed, int16_t rightSpeed, uint8_t *leftWheelDirection, uint8_t *rightWheelDirection){
    13d6:	0f 93       	push	r16
    13d8:	1f 93       	push	r17
    13da:	cf 93       	push	r28
    13dc:	df 93       	push	r29
    13de:	eb 01       	movw	r28, r22
    13e0:	89 01       	movw	r16, r18
    if (leftSpeed > 0){
    13e2:	18 16       	cp	r1, r24
    13e4:	19 06       	cpc	r1, r25
    13e6:	1c f4       	brge	.+6      	; 0x13ee <vMotorMovementSwitch+0x18>
		vMotorMoveLeftForward(leftSpeed, leftWheelDirection);
    13e8:	ba 01       	movw	r22, r20
    13ea:	b1 df       	rcall	.-158    	; 0x134e <vMotorMoveLeftForward>
    13ec:	07 c0       	rjmp	.+14     	; 0x13fc <vMotorMovementSwitch+0x26>
    }else if(leftSpeed < 0){
    13ee:	99 23       	and	r25, r25
    13f0:	24 f4       	brge	.+8      	; 0x13fa <vMotorMovementSwitch+0x24>
		vMotorMoveLeftBackward(-leftSpeed,leftWheelDirection);
    13f2:	ba 01       	movw	r22, r20
    13f4:	81 95       	neg	r24
    13f6:	c3 df       	rcall	.-122    	; 0x137e <vMotorMoveLeftBackward>
    }else{
		vMotorBrakeLeft();
    13f8:	01 c0       	rjmp	.+2      	; 0x13fc <vMotorMovementSwitch+0x26>
    13fa:	d9 df       	rcall	.-78     	; 0x13ae <vMotorBrakeLeft>
	}
	
	if (rightSpeed > 0) {
    13fc:	1c 16       	cp	r1, r28
    13fe:	1d 06       	cpc	r1, r29
		vMotorMoveRightForward(rightSpeed,rightWheelDirection);
    1400:	24 f4       	brge	.+8      	; 0x140a <vMotorMovementSwitch+0x34>
    1402:	b8 01       	movw	r22, r16
    1404:	8c 2f       	mov	r24, r28
    1406:	aa df       	rcall	.-172    	; 0x135c <vMotorMoveRightForward>
    1408:	08 c0       	rjmp	.+16     	; 0x141a <vMotorMovementSwitch+0x44>
	}else if (rightSpeed < 0) {
    140a:	dd 23       	and	r29, r29
		vMotorMoveRightBackward(-rightSpeed,rightWheelDirection);
    140c:	2c f4       	brge	.+10     	; 0x1418 <vMotorMovementSwitch+0x42>
    140e:	b8 01       	movw	r22, r16
    1410:	8c 2f       	mov	r24, r28
    1412:	81 95       	neg	r24
    1414:	bb df       	rcall	.-138    	; 0x138c <vMotorMoveRightBackward>
	}else {
		vMotorBrakeRight();
    1416:	01 c0       	rjmp	.+2      	; 0x141a <vMotorMovementSwitch+0x44>
    1418:	cf df       	rcall	.-98     	; 0x13b8 <vMotorBrakeRight>
	
	
	
	

}
    141a:	df 91       	pop	r29
    141c:	cf 91       	pop	r28
    141e:	1f 91       	pop	r17
    1420:	0f 91       	pop	r16
    1422:	08 95       	ret

00001424 <network_receive>:

uint8_t network_get_address(void) {
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
    1424:	ef 92       	push	r14
    1426:	ff 92       	push	r15
    1428:	0f 93       	push	r16
    142a:	1f 93       	push	r17
    142c:	cf 93       	push	r28
    142e:	df 93       	push	r29
    1430:	7c 01       	movw	r14, r24
    1432:	8b 01       	movw	r16, r22
   uint8_t *decoded_data = pvPortMalloc(len);
    1434:	cb 01       	movw	r24, r22
    1436:	ad da       	rcall	.-2726   	; 0x992 <pvPortMalloc>
    1438:	ec 01       	movw	r28, r24
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    143a:	98 01       	movw	r18, r16
    143c:	21 50       	subi	r18, 0x01	; 1
    143e:	31 09       	sbc	r19, r1
    1440:	a7 01       	movw	r20, r14
    1442:	b8 01       	movw	r22, r16
    1444:	f5 d9       	rcall	.-3094   	; 0x830 <cobs_decode>
   static uint8_t cobs = 0;
   static uint8_t crc = 0;
   if(result.status != COBS_DECODE_OK) {
    1446:	88 23       	and	r24, r24
    1448:	41 f0       	breq	.+16     	; 0x145a <network_receive+0x36>
	   ++cobs;
    144a:	80 91 70 15 	lds	r24, 0x1570	; 0x801570 <cobs.2024>
    144e:	8f 5f       	subi	r24, 0xFF	; 255
    1450:	80 93 70 15 	sts	0x1570, r24	; 0x801570 <cobs.2024>
	   vPortFree(decoded_data);
    1454:	ce 01       	movw	r24, r28
    1456:	a7 db       	rcall	.-2226   	; 0xba6 <vPortFree>
	   return;
    1458:	2f c0       	rjmp	.+94     	; 0x14b8 <network_receive+0x94>
  return ADDRESS;
}

void network_receive(uint8_t *frame, uint16_t len) {
   uint8_t *decoded_data = pvPortMalloc(len);
   cobs_decode_result result = cobs_decode(decoded_data, len, frame, len-1);
    145a:	86 2f       	mov	r24, r22
    145c:	97 2f       	mov	r25, r23
    145e:	8c 01       	movw	r16, r24
   if(result.status != COBS_DECODE_OK) {
	   ++cobs;
	   vPortFree(decoded_data);
	   return;
   }
   if(decoded_data[result.out_len-1] != calculate_crc(decoded_data, result.out_len-1) ) {
    1460:	fe 01       	movw	r30, r28
    1462:	e8 0f       	add	r30, r24
    1464:	f9 1f       	adc	r31, r25
    1466:	31 97       	sbiw	r30, 0x01	; 1
    1468:	f0 80       	ld	r15, Z
    146a:	6f ef       	ldi	r22, 0xFF	; 255
    146c:	68 0f       	add	r22, r24
    146e:	ce 01       	movw	r24, r28
    1470:	69 da       	rcall	.-2862   	; 0x944 <calculate_crc>
    1472:	f8 16       	cp	r15, r24
    1474:	41 f0       	breq	.+16     	; 0x1486 <network_receive+0x62>
	   ++crc;
    1476:	80 91 6f 15 	lds	r24, 0x156F	; 0x80156f <crc.2025>
    147a:	8f 5f       	subi	r24, 0xFF	; 255
    147c:	80 93 6f 15 	sts	0x156F, r24	; 0x80156f <crc.2025>
	   vPortFree(decoded_data);
    1480:	ce 01       	movw	r24, r28
    1482:	91 db       	rcall	.-2270   	; 0xba6 <vPortFree>
	   return;
   }
   uint8_t receiver = decoded_data[0];
   uint8_t sender = decoded_data[1];
   uint8_t protocol = decoded_data[2];
   if(receiver != ADDRESS) {
    1484:	19 c0       	rjmp	.+50     	; 0x14b8 <network_receive+0x94>
    1486:	88 81       	ld	r24, Y
    1488:	83 30       	cpi	r24, 0x03	; 3
	   vPortFree(decoded_data);
    148a:	19 f0       	breq	.+6      	; 0x1492 <network_receive+0x6e>
    148c:	ce 01       	movw	r24, r28
    148e:	8b db       	rcall	.-2282   	; 0xba6 <vPortFree>
	   return;
    1490:	13 c0       	rjmp	.+38     	; 0x14b8 <network_receive+0x94>
   }
   receive_callbacks[protocol](sender, decoded_data+3, result.out_len-4);
    1492:	a8 01       	movw	r20, r16
    1494:	44 50       	subi	r20, 0x04	; 4
    1496:	51 09       	sbc	r21, r1
    1498:	be 01       	movw	r22, r28
    149a:	6d 5f       	subi	r22, 0xFD	; 253
    149c:	7f 4f       	sbci	r23, 0xFF	; 255
    149e:	ea 81       	ldd	r30, Y+2	; 0x02
    14a0:	f0 e0       	ldi	r31, 0x00	; 0
    14a2:	ee 0f       	add	r30, r30
    14a4:	ff 1f       	adc	r31, r31
    14a6:	ec 50       	subi	r30, 0x0C	; 12
    14a8:	f9 4e       	sbci	r31, 0xE9	; 233
    14aa:	01 90       	ld	r0, Z+
    14ac:	f0 81       	ld	r31, Z
    14ae:	e0 2d       	mov	r30, r0
    14b0:	89 81       	ldd	r24, Y+1	; 0x01
   vPortFree(decoded_data);
    14b2:	19 95       	eicall
    14b4:	ce 01       	movw	r24, r28
    14b6:	77 db       	rcall	.-2322   	; 0xba6 <vPortFree>
}
    14b8:	df 91       	pop	r29
    14ba:	cf 91       	pop	r28
    14bc:	1f 91       	pop	r17
    14be:	0f 91       	pop	r16
    14c0:	ff 90       	pop	r15
    14c2:	ef 90       	pop	r14
    14c4:	08 95       	ret

000014c6 <network_init>:
void network_receive(uint8_t *frame, uint16_t len);

void (*receive_callbacks[10])(uint8_t, uint8_t*, uint16_t);

void network_init(void) {
  vUSART_set_receive_callback(network_receive);
    14c6:	82 e1       	ldi	r24, 0x12	; 18
    14c8:	9a e0       	ldi	r25, 0x0A	; 10
    14ca:	0c 94 11 1b 	jmp	0x3622	; 0x3622 <vUSART_set_receive_callback>
    14ce:	08 95       	ret

000014d0 <network_set_callback>:
}

void network_set_callback(uint8_t protocol, void (*cb)(uint8_t, uint8_t*, uint16_t)) {
  if(protocol == PROTOCOL_ARQ || protocol == PROTOCOL_SIMPLE) receive_callbacks[protocol] = cb;
    14d0:	82 30       	cpi	r24, 0x02	; 2
    14d2:	40 f4       	brcc	.+16     	; 0x14e4 <network_set_callback+0x14>
    14d4:	e8 2f       	mov	r30, r24
    14d6:	f0 e0       	ldi	r31, 0x00	; 0
    14d8:	ee 0f       	add	r30, r30
    14da:	ff 1f       	adc	r31, r31
    14dc:	ec 50       	subi	r30, 0x0C	; 12
    14de:	f9 4e       	sbci	r31, 0xE9	; 233
    14e0:	71 83       	std	Z+1, r23	; 0x01
    14e2:	60 83       	st	Z, r22
    14e4:	08 95       	ret

000014e6 <network_send>:
}
    
uint8_t network_send(uint8_t remote_address, uint8_t protocol, uint8_t *data, uint16_t len) {
    14e6:	8f 92       	push	r8
    14e8:	9f 92       	push	r9
    14ea:	af 92       	push	r10
    14ec:	bf 92       	push	r11
    14ee:	cf 92       	push	r12
    14f0:	df 92       	push	r13
    14f2:	ef 92       	push	r14
    14f4:	ff 92       	push	r15
    14f6:	0f 93       	push	r16
    14f8:	1f 93       	push	r17
    14fa:	cf 93       	push	r28
    14fc:	df 93       	push	r29
    14fe:	88 2e       	mov	r8, r24
    1500:	96 2e       	mov	r9, r22
    1502:	5a 01       	movw	r10, r20
    1504:	89 01       	movw	r16, r18
  uint8_t *packet = pvPortMalloc(len+4);
    1506:	69 01       	movw	r12, r18
    1508:	84 e0       	ldi	r24, 0x04	; 4
    150a:	c8 0e       	add	r12, r24
    150c:	d1 1c       	adc	r13, r1
    150e:	c6 01       	movw	r24, r12
    1510:	40 da       	rcall	.-2944   	; 0x992 <pvPortMalloc>
    1512:	ec 01       	movw	r28, r24
  uint8_t *encoded_data = pvPortMalloc(len+6);
    1514:	c8 01       	movw	r24, r16
    1516:	06 96       	adiw	r24, 0x06	; 6
    1518:	3c da       	rcall	.-2952   	; 0x992 <pvPortMalloc>
    151a:	7c 01       	movw	r14, r24
  if(packet == NULL || encoded_data == NULL) {
    151c:	20 97       	sbiw	r28, 0x00	; 0
    151e:	11 f0       	breq	.+4      	; 0x1524 <network_send+0x3e>
    1520:	89 2b       	or	r24, r25
    vPortFree(packet);
    1522:	31 f4       	brne	.+12     	; 0x1530 <network_send+0x4a>
    1524:	ce 01       	movw	r24, r28
    vPortFree(encoded_data);
    1526:	3f db       	rcall	.-2434   	; 0xba6 <vPortFree>
    1528:	c7 01       	movw	r24, r14
    152a:	3d db       	rcall	.-2438   	; 0xba6 <vPortFree>
    return 0;
    152c:	80 e0       	ldi	r24, 0x00	; 0
    152e:	36 c0       	rjmp	.+108    	; 0x159c <network_send+0xb6>
  }
  packet[0] = remote_address;
    1530:	88 82       	st	Y, r8
  packet[1] = ADDRESS;
    1532:	83 e0       	ldi	r24, 0x03	; 3
    1534:	89 83       	std	Y+1, r24	; 0x01
  packet[2] = protocol;
    1536:	9a 82       	std	Y+2, r9	; 0x02
  memcpy(packet+3, data, len);
    1538:	a8 01       	movw	r20, r16
    153a:	b5 01       	movw	r22, r10
    153c:	ce 01       	movw	r24, r28
    153e:	03 96       	adiw	r24, 0x03	; 3
    1540:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
  packet[3+len] = calculate_crc(packet, 3+len);
    1544:	58 01       	movw	r10, r16
    1546:	e3 e0       	ldi	r30, 0x03	; 3
    1548:	ae 0e       	add	r10, r30
    154a:	b1 1c       	adc	r11, r1
    154c:	ac 0e       	add	r10, r28
    154e:	bd 1e       	adc	r11, r29
    1550:	63 e0       	ldi	r22, 0x03	; 3
    1552:	60 0f       	add	r22, r16
    1554:	ce 01       	movw	r24, r28
    1556:	f6 d9       	rcall	.-3092   	; 0x944 <calculate_crc>
    1558:	f5 01       	movw	r30, r10
    155a:	80 83       	st	Z, r24
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    155c:	b8 01       	movw	r22, r16
    155e:	6b 5f       	subi	r22, 0xFB	; 251
    1560:	7f 4f       	sbci	r23, 0xFF	; 255
    1562:	96 01       	movw	r18, r12
    1564:	ae 01       	movw	r20, r28
    1566:	c7 01       	movw	r24, r14
  if(result.status != COBS_ENCODE_OK) {
    1568:	fd d8       	rcall	.-3590   	; 0x764 <cobs_encode>
    156a:	88 23       	and	r24, r24
    vPortFree(packet);
    156c:	31 f0       	breq	.+12     	; 0x157a <network_send+0x94>
    156e:	ce 01       	movw	r24, r28
    1570:	1a db       	rcall	.-2508   	; 0xba6 <vPortFree>
    vPortFree(encoded_data);
    1572:	c7 01       	movw	r24, r14
    1574:	18 db       	rcall	.-2512   	; 0xba6 <vPortFree>
    1576:	80 e0       	ldi	r24, 0x00	; 0
    return 0;
    1578:	11 c0       	rjmp	.+34     	; 0x159c <network_send+0xb6>
    157a:	86 2f       	mov	r24, r22
  packet[0] = remote_address;
  packet[1] = ADDRESS;
  packet[2] = protocol;
  memcpy(packet+3, data, len);
  packet[3+len] = calculate_crc(packet, 3+len);
  cobs_encode_result result = cobs_encode(encoded_data, len+5, packet, len+4);
    157c:	97 2f       	mov	r25, r23
    157e:	f7 01       	movw	r30, r14
  if(result.status != COBS_ENCODE_OK) {
    vPortFree(packet);
    vPortFree(encoded_data);
    return 0;
  }
  encoded_data[result.out_len] = 0x00;
    1580:	e8 0f       	add	r30, r24
    1582:	f9 1f       	adc	r31, r25
    1584:	10 82       	st	Z, r1
  vUSART_send(encoded_data, result.out_len+1);
    1586:	bc 01       	movw	r22, r24
    1588:	6f 5f       	subi	r22, 0xFF	; 255
    158a:	7f 4f       	sbci	r23, 0xFF	; 255
    158c:	c7 01       	movw	r24, r14
    158e:	0e 94 ed 1a 	call	0x35da	; 0x35da <vUSART_send>
  vPortFree(packet);
    1592:	ce 01       	movw	r24, r28
    1594:	08 db       	rcall	.-2544   	; 0xba6 <vPortFree>
  vPortFree(encoded_data);
    1596:	c7 01       	movw	r24, r14
    1598:	06 db       	rcall	.-2548   	; 0xba6 <vPortFree>
    159a:	81 e0       	ldi	r24, 0x01	; 1
  return 1;
    159c:	df 91       	pop	r29
}
    159e:	cf 91       	pop	r28
    15a0:	1f 91       	pop	r17
    15a2:	0f 91       	pop	r16
    15a4:	ff 90       	pop	r15
    15a6:	ef 90       	pop	r14
    15a8:	df 90       	pop	r13
    15aa:	cf 90       	pop	r12
    15ac:	bf 90       	pop	r11
    15ae:	af 90       	pop	r10
    15b0:	9f 90       	pop	r9
    15b2:	8f 90       	pop	r8
    15b4:	08 95       	ret

000015b6 <pxPortInitialiseStack>:
    15b6:	31 e1       	ldi	r19, 0x11	; 17
#elif defined( portUSE_TIMER2 )
	portTIMSK &= ~( _BV(OCIE2B)|_BV(OCIE2A)|_BV(TOIE2) );	// disable all Timer2 interrupts
    ASSR = 0x00;              								// set Timer/Counter2 to be off

#elif defined( portUSE_TIMER3 )
	portTIMSK &= ~( _BV(OCIE3B)|_BV(OCIE3A)|_BV(TOIE3) );	// disable all Timer3 interrupts
    15b8:	fc 01       	movw	r30, r24
    15ba:	30 83       	st	Z, r19
    15bc:	31 97       	sbiw	r30, 0x01	; 1
    15be:	22 e2       	ldi	r18, 0x22	; 34
    15c0:	20 83       	st	Z, r18
    15c2:	31 97       	sbiw	r30, 0x01	; 1
    15c4:	a3 e3       	ldi	r26, 0x33	; 51
    15c6:	a0 83       	st	Z, r26
    15c8:	31 97       	sbiw	r30, 0x01	; 1
    15ca:	60 83       	st	Z, r22
    15cc:	31 97       	sbiw	r30, 0x01	; 1
    15ce:	70 83       	st	Z, r23
    15d0:	31 97       	sbiw	r30, 0x01	; 1
    15d2:	10 82       	st	Z, r1
    15d4:	31 97       	sbiw	r30, 0x01	; 1
    15d6:	10 82       	st	Z, r1
    15d8:	31 97       	sbiw	r30, 0x01	; 1
    15da:	60 e8       	ldi	r22, 0x80	; 128
    15dc:	60 83       	st	Z, r22
    15de:	31 97       	sbiw	r30, 0x01	; 1
    15e0:	10 82       	st	Z, r1
    15e2:	31 97       	sbiw	r30, 0x01	; 1
    15e4:	10 82       	st	Z, r1
    15e6:	31 97       	sbiw	r30, 0x01	; 1
    15e8:	10 82       	st	Z, r1
    15ea:	31 97       	sbiw	r30, 0x01	; 1
    15ec:	62 e0       	ldi	r22, 0x02	; 2
    15ee:	60 83       	st	Z, r22
    15f0:	31 97       	sbiw	r30, 0x01	; 1
    15f2:	63 e0       	ldi	r22, 0x03	; 3
    15f4:	60 83       	st	Z, r22
    15f6:	31 97       	sbiw	r30, 0x01	; 1
    15f8:	64 e0       	ldi	r22, 0x04	; 4
    15fa:	60 83       	st	Z, r22
    15fc:	31 97       	sbiw	r30, 0x01	; 1
    15fe:	65 e0       	ldi	r22, 0x05	; 5
    1600:	60 83       	st	Z, r22
    1602:	31 97       	sbiw	r30, 0x01	; 1
    1604:	66 e0       	ldi	r22, 0x06	; 6
    1606:	60 83       	st	Z, r22
    1608:	31 97       	sbiw	r30, 0x01	; 1
    160a:	67 e0       	ldi	r22, 0x07	; 7
    160c:	60 83       	st	Z, r22
    160e:	31 97       	sbiw	r30, 0x01	; 1
    1610:	68 e0       	ldi	r22, 0x08	; 8
    1612:	60 83       	st	Z, r22
    1614:	31 97       	sbiw	r30, 0x01	; 1
    1616:	69 e0       	ldi	r22, 0x09	; 9
    1618:	60 83       	st	Z, r22
    161a:	31 97       	sbiw	r30, 0x01	; 1
    161c:	60 e1       	ldi	r22, 0x10	; 16
    161e:	60 83       	st	Z, r22
    1620:	31 97       	sbiw	r30, 0x01	; 1
    1622:	30 83       	st	Z, r19
    1624:	31 97       	sbiw	r30, 0x01	; 1
    1626:	32 e1       	ldi	r19, 0x12	; 18
    1628:	30 83       	st	Z, r19
    162a:	31 97       	sbiw	r30, 0x01	; 1
    162c:	33 e1       	ldi	r19, 0x13	; 19
    162e:	30 83       	st	Z, r19
    1630:	31 97       	sbiw	r30, 0x01	; 1
    1632:	34 e1       	ldi	r19, 0x14	; 20
    1634:	30 83       	st	Z, r19
    1636:	31 97       	sbiw	r30, 0x01	; 1
    1638:	35 e1       	ldi	r19, 0x15	; 21
    163a:	30 83       	st	Z, r19
    163c:	31 97       	sbiw	r30, 0x01	; 1
    163e:	36 e1       	ldi	r19, 0x16	; 22
    1640:	30 83       	st	Z, r19
    1642:	31 97       	sbiw	r30, 0x01	; 1
    1644:	37 e1       	ldi	r19, 0x17	; 23
    1646:	30 83       	st	Z, r19
    1648:	31 97       	sbiw	r30, 0x01	; 1
    164a:	38 e1       	ldi	r19, 0x18	; 24
    164c:	30 83       	st	Z, r19
    164e:	31 97       	sbiw	r30, 0x01	; 1
    1650:	39 e1       	ldi	r19, 0x19	; 25
    1652:	30 83       	st	Z, r19
    1654:	31 97       	sbiw	r30, 0x01	; 1
    1656:	30 e2       	ldi	r19, 0x20	; 32
    1658:	30 83       	st	Z, r19
    165a:	31 97       	sbiw	r30, 0x01	; 1
    165c:	31 e2       	ldi	r19, 0x21	; 33
    165e:	30 83       	st	Z, r19
    1660:	31 97       	sbiw	r30, 0x01	; 1
    1662:	20 83       	st	Z, r18
    1664:	31 97       	sbiw	r30, 0x01	; 1
    1666:	23 e2       	ldi	r18, 0x23	; 35
    1668:	20 83       	st	Z, r18
    166a:	31 97       	sbiw	r30, 0x01	; 1
    166c:	40 83       	st	Z, r20
    166e:	31 97       	sbiw	r30, 0x01	; 1
    1670:	50 83       	st	Z, r21
    1672:	31 97       	sbiw	r30, 0x01	; 1
    1674:	26 e2       	ldi	r18, 0x26	; 38
    1676:	20 83       	st	Z, r18
    1678:	31 97       	sbiw	r30, 0x01	; 1
    167a:	27 e2       	ldi	r18, 0x27	; 39
    167c:	20 83       	st	Z, r18
    167e:	31 97       	sbiw	r30, 0x01	; 1
    1680:	28 e2       	ldi	r18, 0x28	; 40
    1682:	20 83       	st	Z, r18
    1684:	31 97       	sbiw	r30, 0x01	; 1
    1686:	29 e2       	ldi	r18, 0x29	; 41
    1688:	20 83       	st	Z, r18
    168a:	31 97       	sbiw	r30, 0x01	; 1
    168c:	20 e3       	ldi	r18, 0x30	; 48
    168e:	20 83       	st	Z, r18
    1690:	31 97       	sbiw	r30, 0x01	; 1
    1692:	21 e3       	ldi	r18, 0x31	; 49
    1694:	20 83       	st	Z, r18
    1696:	89 97       	sbiw	r24, 0x29	; 41
    1698:	08 95       	ret

0000169a <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    169a:	0f 92       	push	r0
    169c:	0f b6       	in	r0, 0x3f	; 63
    169e:	f8 94       	cli
    16a0:	0f 92       	push	r0
    16a2:	0b b6       	in	r0, 0x3b	; 59
    16a4:	0f 92       	push	r0
    16a6:	0c b6       	in	r0, 0x3c	; 60
    16a8:	0f 92       	push	r0
    16aa:	1f 92       	push	r1
    16ac:	11 24       	eor	r1, r1
    16ae:	2f 92       	push	r2
    16b0:	3f 92       	push	r3
    16b2:	4f 92       	push	r4
    16b4:	5f 92       	push	r5
    16b6:	6f 92       	push	r6
    16b8:	7f 92       	push	r7
    16ba:	8f 92       	push	r8
    16bc:	9f 92       	push	r9
    16be:	af 92       	push	r10
    16c0:	bf 92       	push	r11
    16c2:	cf 92       	push	r12
    16c4:	df 92       	push	r13
    16c6:	ef 92       	push	r14
    16c8:	ff 92       	push	r15
    16ca:	0f 93       	push	r16
    16cc:	1f 93       	push	r17
    16ce:	2f 93       	push	r18
    16d0:	3f 93       	push	r19
    16d2:	4f 93       	push	r20
    16d4:	5f 93       	push	r21
    16d6:	6f 93       	push	r22
    16d8:	7f 93       	push	r23
    16da:	8f 93       	push	r24
    16dc:	9f 93       	push	r25
    16de:	af 93       	push	r26
    16e0:	bf 93       	push	r27
    16e2:	cf 93       	push	r28
    16e4:	df 93       	push	r29
    16e6:	ef 93       	push	r30
    16e8:	ff 93       	push	r31
    16ea:	a0 91 44 16 	lds	r26, 0x1644	; 0x801644 <pxCurrentTCB>
    16ee:	b0 91 45 16 	lds	r27, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    16f2:	0d b6       	in	r0, 0x3d	; 61
    16f4:	0d 92       	st	X+, r0
    16f6:	0e b6       	in	r0, 0x3e	; 62
    16f8:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    16fa:	0e 94 29 16 	call	0x2c52	; 0x2c52 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    16fe:	a0 91 44 16 	lds	r26, 0x1644	; 0x801644 <pxCurrentTCB>
    1702:	b0 91 45 16 	lds	r27, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    1706:	cd 91       	ld	r28, X+
    1708:	cd bf       	out	0x3d, r28	; 61
    170a:	dd 91       	ld	r29, X+
    170c:	de bf       	out	0x3e, r29	; 62
    170e:	ff 91       	pop	r31
    1710:	ef 91       	pop	r30
    1712:	df 91       	pop	r29
    1714:	cf 91       	pop	r28
    1716:	bf 91       	pop	r27
    1718:	af 91       	pop	r26
    171a:	9f 91       	pop	r25
    171c:	8f 91       	pop	r24
    171e:	7f 91       	pop	r23
    1720:	6f 91       	pop	r22
    1722:	5f 91       	pop	r21
    1724:	4f 91       	pop	r20
    1726:	3f 91       	pop	r19
    1728:	2f 91       	pop	r18
    172a:	1f 91       	pop	r17
    172c:	0f 91       	pop	r16
    172e:	ff 90       	pop	r15
    1730:	ef 90       	pop	r14
    1732:	df 90       	pop	r13
    1734:	cf 90       	pop	r12
    1736:	bf 90       	pop	r11
    1738:	af 90       	pop	r10
    173a:	9f 90       	pop	r9
    173c:	8f 90       	pop	r8
    173e:	7f 90       	pop	r7
    1740:	6f 90       	pop	r6
    1742:	5f 90       	pop	r5
    1744:	4f 90       	pop	r4
    1746:	3f 90       	pop	r3
    1748:	2f 90       	pop	r2
    174a:	1f 90       	pop	r1
    174c:	0f 90       	pop	r0
    174e:	0c be       	out	0x3c, r0	; 60
    1750:	0f 90       	pop	r0
    1752:	0b be       	out	0x3b, r0	; 59
    1754:	0f 90       	pop	r0
    1756:	0f be       	out	0x3f, r0	; 63
    1758:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    175a:	08 95       	ret

0000175c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( hot, flatten, naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    175c:	0f 92       	push	r0
    175e:	0f b6       	in	r0, 0x3f	; 63
    1760:	f8 94       	cli
    1762:	0f 92       	push	r0
    1764:	0b b6       	in	r0, 0x3b	; 59
    1766:	0f 92       	push	r0
    1768:	0c b6       	in	r0, 0x3c	; 60
    176a:	0f 92       	push	r0
    176c:	1f 92       	push	r1
    176e:	11 24       	eor	r1, r1
    1770:	2f 92       	push	r2
    1772:	3f 92       	push	r3
    1774:	4f 92       	push	r4
    1776:	5f 92       	push	r5
    1778:	6f 92       	push	r6
    177a:	7f 92       	push	r7
    177c:	8f 92       	push	r8
    177e:	9f 92       	push	r9
    1780:	af 92       	push	r10
    1782:	bf 92       	push	r11
    1784:	cf 92       	push	r12
    1786:	df 92       	push	r13
    1788:	ef 92       	push	r14
    178a:	ff 92       	push	r15
    178c:	0f 93       	push	r16
    178e:	1f 93       	push	r17
    1790:	2f 93       	push	r18
    1792:	3f 93       	push	r19
    1794:	4f 93       	push	r20
    1796:	5f 93       	push	r21
    1798:	6f 93       	push	r22
    179a:	7f 93       	push	r23
    179c:	8f 93       	push	r24
    179e:	9f 93       	push	r25
    17a0:	af 93       	push	r26
    17a2:	bf 93       	push	r27
    17a4:	cf 93       	push	r28
    17a6:	df 93       	push	r29
    17a8:	ef 93       	push	r30
    17aa:	ff 93       	push	r31
    17ac:	a0 91 44 16 	lds	r26, 0x1644	; 0x801644 <pxCurrentTCB>
    17b0:	b0 91 45 16 	lds	r27, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    17b4:	0d b6       	in	r0, 0x3d	; 61
    17b6:	0d 92       	st	X+, r0
    17b8:	0e b6       	in	r0, 0x3e	; 62
    17ba:	0d 92       	st	X+, r0

	sleep_reset();		//	 reset the sleep_mode() faster than sleep_disable();
    17bc:	13 be       	out	0x33, r1	; 51
	// start mark - check for start of interrupt - for debugging only
	PORTD |=  _BV(PORTD7);				// Ping IO line.
#endif

#if !defined(portUSE_TIMER2_RTC)
	if (--ticksRemainingInSec == 0)
    17be:	80 91 0a 17 	lds	r24, 0x170A	; 0x80170a <ticksRemainingInSec>
    17c2:	90 91 0b 17 	lds	r25, 0x170B	; 0x80170b <ticksRemainingInSec+0x1>
    17c6:	01 97       	sbiw	r24, 0x01	; 1
    17c8:	90 93 0b 17 	sts	0x170B, r25	; 0x80170b <ticksRemainingInSec+0x1>
    17cc:	80 93 0a 17 	sts	0x170A, r24	; 0x80170a <ticksRemainingInSec>
    17d0:	89 2b       	or	r24, r25
    17d2:	41 f4       	brne	.+16     	; 0x17e4 <vPortYieldFromTick+0x88>
	{
		//system_tick();
		ticksRemainingInSec = portTickRateHz;
    17d4:	80 91 08 17 	lds	r24, 0x1708	; 0x801708 <portTickRateHz>
    17d8:	90 91 09 17 	lds	r25, 0x1709	; 0x801709 <portTickRateHz+0x1>
    17dc:	90 93 0b 17 	sts	0x170B, r25	; 0x80170b <ticksRemainingInSec+0x1>
    17e0:	80 93 0a 17 	sts	0x170A, r24	; 0x80170a <ticksRemainingInSec>
	}
#endif

	if( xTaskIncrementTick() != pdFALSE )
    17e4:	0e 94 68 15 	call	0x2ad0	; 0x2ad0 <xTaskIncrementTick>
    17e8:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    17ea:	0e 94 29 16 	call	0x2c52	; 0x2c52 <vTaskSwitchContext>
#if defined(DEBUG_PING)
	// end mark - check for end of interrupt - for debugging only
	PORTD &= ~_BV(PORTD7);
#endif

	portRESTORE_CONTEXT();
    17ee:	a0 91 44 16 	lds	r26, 0x1644	; 0x801644 <pxCurrentTCB>
    17f2:	b0 91 45 16 	lds	r27, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    17f6:	cd 91       	ld	r28, X+
    17f8:	cd bf       	out	0x3d, r28	; 61
    17fa:	dd 91       	ld	r29, X+
    17fc:	de bf       	out	0x3e, r29	; 62
    17fe:	ff 91       	pop	r31
    1800:	ef 91       	pop	r30
    1802:	df 91       	pop	r29
    1804:	cf 91       	pop	r28
    1806:	bf 91       	pop	r27
    1808:	af 91       	pop	r26
    180a:	9f 91       	pop	r25
    180c:	8f 91       	pop	r24
    180e:	7f 91       	pop	r23
    1810:	6f 91       	pop	r22
    1812:	5f 91       	pop	r21
    1814:	4f 91       	pop	r20
    1816:	3f 91       	pop	r19
    1818:	2f 91       	pop	r18
    181a:	1f 91       	pop	r17
    181c:	0f 91       	pop	r16
    181e:	ff 90       	pop	r15
    1820:	ef 90       	pop	r14
    1822:	df 90       	pop	r13
    1824:	cf 90       	pop	r12
    1826:	bf 90       	pop	r11
    1828:	af 90       	pop	r10
    182a:	9f 90       	pop	r9
    182c:	8f 90       	pop	r8
    182e:	7f 90       	pop	r7
    1830:	6f 90       	pop	r6
    1832:	5f 90       	pop	r5
    1834:	4f 90       	pop	r4
    1836:	3f 90       	pop	r3
    1838:	2f 90       	pop	r2
    183a:	1f 90       	pop	r1
    183c:	0f 90       	pop	r0
    183e:	0c be       	out	0x3c, r0	; 60
    1840:	0f 90       	pop	r0
    1842:	0b be       	out	0x3b, r0	; 59
    1844:	0f 90       	pop	r0
    1846:	0f be       	out	0x3f, r0	; 63
    1848:	0f 90       	pop	r0

	__asm__ __volatile__ ( "ret" );
    184a:	08 95       	ret

0000184c <__vector_32>:
	 */
//	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK)
	ISR(portSCHEDULER_ISR, ISR_NAKED ISR_NOBLOCK) __attribute__ ((hot, flatten));
	ISR(portSCHEDULER_ISR)
	{
		vPortYieldFromTick();
    184c:	87 df       	rcall	.-242    	; 0x175c <vPortYieldFromTick>
		__asm__ __volatile__ ( "reti" );
    184e:	18 95       	reti

00001850 <xQueueCreateMutex>:
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1850:	9f 92       	push	r9
    1852:	af 92       	push	r10
    1854:	bf 92       	push	r11
    1856:	cf 92       	push	r12
    1858:	df 92       	push	r13
    185a:	ef 92       	push	r14
    185c:	ff 92       	push	r15
    185e:	0f 93       	push	r16
    1860:	1f 93       	push	r17
    1862:	cf 93       	push	r28
    1864:	df 93       	push	r29
    1866:	00 d0       	rcall	.+0      	; 0x1868 <xQueueCreateMutex+0x18>
    1868:	1f 92       	push	r1
    186a:	1f 92       	push	r1
    186c:	cd b7       	in	r28, 0x3d	; 61
    186e:	de b7       	in	r29, 0x3e	; 62
    1870:	8f e1       	ldi	r24, 0x1F	; 31
    1872:	90 e0       	ldi	r25, 0x00	; 0
    1874:	8e d8       	rcall	.-3812   	; 0x992 <pvPortMalloc>
    1876:	8c 01       	movw	r16, r24
    1878:	00 97       	sbiw	r24, 0x00	; 0
    187a:	09 f4       	brne	.+2      	; 0x187e <xQueueCreateMutex+0x2e>
    187c:	52 c1       	rjmp	.+676    	; 0x1b22 <xQueueCreateMutex+0x2d2>
    187e:	fc 01       	movw	r30, r24
    1880:	13 82       	std	Z+3, r1	; 0x03
    1882:	12 82       	std	Z+2, r1	; 0x02
    1884:	11 82       	std	Z+1, r1	; 0x01
    1886:	10 82       	st	Z, r1
    1888:	15 82       	std	Z+5, r1	; 0x05
    188a:	14 82       	std	Z+4, r1	; 0x04
    188c:	17 82       	std	Z+7, r1	; 0x07
    188e:	16 82       	std	Z+6, r1	; 0x06
    1890:	12 8e       	std	Z+26, r1	; 0x1a
    1892:	81 e0       	ldi	r24, 0x01	; 1
    1894:	83 8f       	std	Z+27, r24	; 0x1b
    1896:	14 8e       	std	Z+28, r1	; 0x1c
    1898:	8f ef       	ldi	r24, 0xFF	; 255
    189a:	85 8f       	std	Z+29, r24	; 0x1d
    189c:	86 8f       	std	Z+30, r24	; 0x1e
    189e:	78 01       	movw	r14, r16
    18a0:	f8 e0       	ldi	r31, 0x08	; 8
    18a2:	ef 0e       	add	r14, r31
    18a4:	f1 1c       	adc	r15, r1
    18a6:	c7 01       	movw	r24, r14
    18a8:	d1 db       	rcall	.-2142   	; 0x104c <vListInitialise>
    18aa:	68 01       	movw	r12, r16
    18ac:	81 e1       	ldi	r24, 0x11	; 17
    18ae:	c8 0e       	add	r12, r24
    18b0:	d1 1c       	adc	r13, r1
    18b2:	c6 01       	movw	r24, r12
    18b4:	cb db       	rcall	.-2154   	; 0x104c <vListInitialise>
    18b6:	1d 82       	std	Y+5, r1	; 0x05
    18b8:	1c 82       	std	Y+4, r1	; 0x04
    18ba:	a1 2c       	mov	r10, r1
    18bc:	99 24       	eor	r9, r9
    18be:	93 94       	inc	r9
    18c0:	bb 24       	eor	r11, r11
    18c2:	ba 94       	dec	r11
    18c4:	0f b6       	in	r0, 0x3f	; 63
    18c6:	f8 94       	cli
    18c8:	0f 92       	push	r0
    18ca:	f8 01       	movw	r30, r16
    18cc:	92 8d       	ldd	r25, Z+26	; 0x1a
    18ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    18d0:	98 17       	cp	r25, r24
    18d2:	f0 f4       	brcc	.+60     	; 0x1910 <xQueueCreateMutex+0xc0>
    18d4:	80 81       	ld	r24, Z
    18d6:	91 81       	ldd	r25, Z+1	; 0x01
    18d8:	89 2b       	or	r24, r25
    18da:	09 f0       	breq	.+2      	; 0x18de <xQueueCreateMutex+0x8e>
    18dc:	19 c1       	rjmp	.+562    	; 0x1b10 <xQueueCreateMutex+0x2c0>
    18de:	82 81       	ldd	r24, Z+2	; 0x02
    18e0:	93 81       	ldd	r25, Z+3	; 0x03
    18e2:	0e 94 05 18 	call	0x300a	; 0x300a <xTaskPriorityDisinherit>
    18e6:	f8 01       	movw	r30, r16
    18e8:	13 82       	std	Z+3, r1	; 0x03
    18ea:	12 82       	std	Z+2, r1	; 0x02
    18ec:	92 8d       	ldd	r25, Z+26	; 0x1a
    18ee:	9f 5f       	subi	r25, 0xFF	; 255
    18f0:	92 8f       	std	Z+26, r25	; 0x1a
    18f2:	91 89       	ldd	r25, Z+17	; 0x11
    18f4:	99 23       	and	r25, r25
    18f6:	39 f0       	breq	.+14     	; 0x1906 <xQueueCreateMutex+0xb6>
    18f8:	c6 01       	movw	r24, r12
    18fa:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    18fe:	81 30       	cpi	r24, 0x01	; 1
    1900:	21 f4       	brne	.+8      	; 0x190a <xQueueCreateMutex+0xba>
    1902:	cb de       	rcall	.-618    	; 0x169a <vPortYield>
    1904:	02 c0       	rjmp	.+4      	; 0x190a <xQueueCreateMutex+0xba>
    1906:	81 11       	cpse	r24, r1
    1908:	c8 de       	rcall	.-624    	; 0x169a <vPortYield>
    190a:	0f 90       	pop	r0
    190c:	0f be       	out	0x3f, r0	; 63
    190e:	09 c1       	rjmp	.+530    	; 0x1b22 <xQueueCreateMutex+0x2d2>
    1910:	8c 81       	ldd	r24, Y+4	; 0x04
    1912:	9d 81       	ldd	r25, Y+5	; 0x05
    1914:	89 2b       	or	r24, r25
    1916:	19 f4       	brne	.+6      	; 0x191e <xQueueCreateMutex+0xce>
    1918:	0f 90       	pop	r0
    191a:	0f be       	out	0x3f, r0	; 63
    191c:	02 c1       	rjmp	.+516    	; 0x1b22 <xQueueCreateMutex+0x2d2>
    191e:	a1 10       	cpse	r10, r1
    1920:	05 c0       	rjmp	.+10     	; 0x192c <xQueueCreateMutex+0xdc>
    1922:	ce 01       	movw	r24, r28
    1924:	01 96       	adiw	r24, 0x01	; 1
    1926:	0e 94 54 17 	call	0x2ea8	; 0x2ea8 <vTaskSetTimeOutState>
    192a:	a9 2c       	mov	r10, r9
    192c:	0f 90       	pop	r0
    192e:	0f be       	out	0x3f, r0	; 63
    1930:	8e d7       	rcall	.+3868   	; 0x284e <vTaskSuspendAll>
    1932:	0f b6       	in	r0, 0x3f	; 63
    1934:	f8 94       	cli
    1936:	0f 92       	push	r0
    1938:	f8 01       	movw	r30, r16
    193a:	85 8d       	ldd	r24, Z+29	; 0x1d
    193c:	8f 3f       	cpi	r24, 0xFF	; 255
    193e:	09 f4       	brne	.+2      	; 0x1942 <xQueueCreateMutex+0xf2>
    1940:	15 8e       	std	Z+29, r1	; 0x1d
    1942:	f8 01       	movw	r30, r16
    1944:	86 8d       	ldd	r24, Z+30	; 0x1e
    1946:	8f 3f       	cpi	r24, 0xFF	; 255
    1948:	09 f4       	brne	.+2      	; 0x194c <xQueueCreateMutex+0xfc>
    194a:	16 8e       	std	Z+30, r1	; 0x1e
    194c:	0f 90       	pop	r0
    194e:	0f be       	out	0x3f, r0	; 63
    1950:	be 01       	movw	r22, r28
    1952:	6c 5f       	subi	r22, 0xFC	; 252
    1954:	7f 4f       	sbci	r23, 0xFF	; 255
    1956:	ce 01       	movw	r24, r28
    1958:	01 96       	adiw	r24, 0x01	; 1
    195a:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <xTaskCheckForTimeOut>
    195e:	81 11       	cpse	r24, r1
    1960:	94 c0       	rjmp	.+296    	; 0x1a8a <xQueueCreateMutex+0x23a>
    1962:	0f b6       	in	r0, 0x3f	; 63
    1964:	f8 94       	cli
    1966:	0f 92       	push	r0
    1968:	f8 01       	movw	r30, r16
    196a:	92 8d       	ldd	r25, Z+26	; 0x1a
    196c:	83 8d       	ldd	r24, Z+27	; 0x1b
    196e:	0f 90       	pop	r0
    1970:	0f be       	out	0x3f, r0	; 63
    1972:	98 13       	cpse	r25, r24
    1974:	49 c0       	rjmp	.+146    	; 0x1a08 <xQueueCreateMutex+0x1b8>
    1976:	6c 81       	ldd	r22, Y+4	; 0x04
    1978:	7d 81       	ldd	r23, Y+5	; 0x05
    197a:	c7 01       	movw	r24, r14
    197c:	0e 94 b1 16 	call	0x2d62	; 0x2d62 <vTaskPlaceOnEventList>
    1980:	0f b6       	in	r0, 0x3f	; 63
    1982:	f8 94       	cli
    1984:	0f 92       	push	r0
    1986:	f8 01       	movw	r30, r16
    1988:	86 8d       	ldd	r24, Z+30	; 0x1e
    198a:	18 16       	cp	r1, r24
    198c:	ac f4       	brge	.+42     	; 0x19b8 <xQueueCreateMutex+0x168>
    198e:	81 89       	ldd	r24, Z+17	; 0x11
    1990:	81 11       	cpse	r24, r1
    1992:	05 c0       	rjmp	.+10     	; 0x199e <xQueueCreateMutex+0x14e>
    1994:	11 c0       	rjmp	.+34     	; 0x19b8 <xQueueCreateMutex+0x168>
    1996:	f8 01       	movw	r30, r16
    1998:	81 89       	ldd	r24, Z+17	; 0x11
    199a:	88 23       	and	r24, r24
    199c:	69 f0       	breq	.+26     	; 0x19b8 <xQueueCreateMutex+0x168>
    199e:	c6 01       	movw	r24, r12
    19a0:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    19a4:	81 11       	cpse	r24, r1
    19a6:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    19aa:	f8 01       	movw	r30, r16
    19ac:	86 8d       	ldd	r24, Z+30	; 0x1e
    19ae:	81 50       	subi	r24, 0x01	; 1
    19b0:	86 8f       	std	Z+30, r24	; 0x1e
    19b2:	86 8d       	ldd	r24, Z+30	; 0x1e
    19b4:	18 16       	cp	r1, r24
    19b6:	7c f3       	brlt	.-34     	; 0x1996 <xQueueCreateMutex+0x146>
    19b8:	f8 01       	movw	r30, r16
    19ba:	b6 8e       	std	Z+30, r11	; 0x1e
    19bc:	0f 90       	pop	r0
    19be:	0f be       	out	0x3f, r0	; 63
    19c0:	0f b6       	in	r0, 0x3f	; 63
    19c2:	f8 94       	cli
    19c4:	0f 92       	push	r0
    19c6:	85 8d       	ldd	r24, Z+29	; 0x1d
    19c8:	18 16       	cp	r1, r24
    19ca:	ac f4       	brge	.+42     	; 0x19f6 <xQueueCreateMutex+0x1a6>
    19cc:	80 85       	ldd	r24, Z+8	; 0x08
    19ce:	81 11       	cpse	r24, r1
    19d0:	05 c0       	rjmp	.+10     	; 0x19dc <xQueueCreateMutex+0x18c>
    19d2:	11 c0       	rjmp	.+34     	; 0x19f6 <xQueueCreateMutex+0x1a6>
    19d4:	f8 01       	movw	r30, r16
    19d6:	80 85       	ldd	r24, Z+8	; 0x08
    19d8:	88 23       	and	r24, r24
    19da:	69 f0       	breq	.+26     	; 0x19f6 <xQueueCreateMutex+0x1a6>
    19dc:	c7 01       	movw	r24, r14
    19de:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    19e2:	81 11       	cpse	r24, r1
    19e4:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    19e8:	f8 01       	movw	r30, r16
    19ea:	85 8d       	ldd	r24, Z+29	; 0x1d
    19ec:	81 50       	subi	r24, 0x01	; 1
    19ee:	85 8f       	std	Z+29, r24	; 0x1d
    19f0:	85 8d       	ldd	r24, Z+29	; 0x1d
    19f2:	18 16       	cp	r1, r24
    19f4:	7c f3       	brlt	.-34     	; 0x19d4 <xQueueCreateMutex+0x184>
    19f6:	f8 01       	movw	r30, r16
    19f8:	b5 8e       	std	Z+29, r11	; 0x1d
    19fa:	0f 90       	pop	r0
    19fc:	0f be       	out	0x3f, r0	; 63
    19fe:	2d d7       	rcall	.+3674   	; 0x285a <xTaskResumeAll>
    1a00:	81 11       	cpse	r24, r1
    1a02:	60 cf       	rjmp	.-320    	; 0x18c4 <xQueueCreateMutex+0x74>
    1a04:	4a de       	rcall	.-876    	; 0x169a <vPortYield>
    1a06:	5e cf       	rjmp	.-324    	; 0x18c4 <xQueueCreateMutex+0x74>
    1a08:	0f b6       	in	r0, 0x3f	; 63
    1a0a:	f8 94       	cli
    1a0c:	0f 92       	push	r0
    1a0e:	f8 01       	movw	r30, r16
    1a10:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a12:	18 16       	cp	r1, r24
    1a14:	ac f4       	brge	.+42     	; 0x1a40 <xQueueCreateMutex+0x1f0>
    1a16:	81 89       	ldd	r24, Z+17	; 0x11
    1a18:	81 11       	cpse	r24, r1
    1a1a:	05 c0       	rjmp	.+10     	; 0x1a26 <xQueueCreateMutex+0x1d6>
    1a1c:	11 c0       	rjmp	.+34     	; 0x1a40 <xQueueCreateMutex+0x1f0>
    1a1e:	f8 01       	movw	r30, r16
    1a20:	81 89       	ldd	r24, Z+17	; 0x11
    1a22:	88 23       	and	r24, r24
    1a24:	69 f0       	breq	.+26     	; 0x1a40 <xQueueCreateMutex+0x1f0>
    1a26:	c6 01       	movw	r24, r12
    1a28:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1a2c:	81 11       	cpse	r24, r1
    1a2e:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1a32:	f8 01       	movw	r30, r16
    1a34:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a36:	81 50       	subi	r24, 0x01	; 1
    1a38:	86 8f       	std	Z+30, r24	; 0x1e
    1a3a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a3c:	18 16       	cp	r1, r24
    1a3e:	7c f3       	brlt	.-34     	; 0x1a1e <xQueueCreateMutex+0x1ce>
    1a40:	f8 01       	movw	r30, r16
    1a42:	b6 8e       	std	Z+30, r11	; 0x1e
    1a44:	0f 90       	pop	r0
    1a46:	0f be       	out	0x3f, r0	; 63
    1a48:	0f b6       	in	r0, 0x3f	; 63
    1a4a:	f8 94       	cli
    1a4c:	0f 92       	push	r0
    1a4e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a50:	18 16       	cp	r1, r24
    1a52:	ac f4       	brge	.+42     	; 0x1a7e <xQueueCreateMutex+0x22e>
    1a54:	80 85       	ldd	r24, Z+8	; 0x08
    1a56:	81 11       	cpse	r24, r1
    1a58:	05 c0       	rjmp	.+10     	; 0x1a64 <xQueueCreateMutex+0x214>
    1a5a:	11 c0       	rjmp	.+34     	; 0x1a7e <xQueueCreateMutex+0x22e>
    1a5c:	f8 01       	movw	r30, r16
    1a5e:	80 85       	ldd	r24, Z+8	; 0x08
    1a60:	88 23       	and	r24, r24
    1a62:	69 f0       	breq	.+26     	; 0x1a7e <xQueueCreateMutex+0x22e>
    1a64:	c7 01       	movw	r24, r14
    1a66:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1a6a:	81 11       	cpse	r24, r1
    1a6c:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1a70:	f8 01       	movw	r30, r16
    1a72:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a74:	81 50       	subi	r24, 0x01	; 1
    1a76:	85 8f       	std	Z+29, r24	; 0x1d
    1a78:	85 8d       	ldd	r24, Z+29	; 0x1d
    1a7a:	18 16       	cp	r1, r24
    1a7c:	7c f3       	brlt	.-34     	; 0x1a5c <xQueueCreateMutex+0x20c>
    1a7e:	f8 01       	movw	r30, r16
    1a80:	b5 8e       	std	Z+29, r11	; 0x1d
    1a82:	0f 90       	pop	r0
    1a84:	0f be       	out	0x3f, r0	; 63
    1a86:	e9 d6       	rcall	.+3538   	; 0x285a <xTaskResumeAll>
    1a88:	1d cf       	rjmp	.-454    	; 0x18c4 <xQueueCreateMutex+0x74>
    1a8a:	0f b6       	in	r0, 0x3f	; 63
    1a8c:	f8 94       	cli
    1a8e:	0f 92       	push	r0
    1a90:	f8 01       	movw	r30, r16
    1a92:	86 8d       	ldd	r24, Z+30	; 0x1e
    1a94:	18 16       	cp	r1, r24
    1a96:	ac f4       	brge	.+42     	; 0x1ac2 <xQueueCreateMutex+0x272>
    1a98:	81 89       	ldd	r24, Z+17	; 0x11
    1a9a:	81 11       	cpse	r24, r1
    1a9c:	05 c0       	rjmp	.+10     	; 0x1aa8 <xQueueCreateMutex+0x258>
    1a9e:	11 c0       	rjmp	.+34     	; 0x1ac2 <xQueueCreateMutex+0x272>
    1aa0:	f8 01       	movw	r30, r16
    1aa2:	81 89       	ldd	r24, Z+17	; 0x11
    1aa4:	88 23       	and	r24, r24
    1aa6:	69 f0       	breq	.+26     	; 0x1ac2 <xQueueCreateMutex+0x272>
    1aa8:	c6 01       	movw	r24, r12
    1aaa:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1aae:	81 11       	cpse	r24, r1
    1ab0:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1ab4:	f8 01       	movw	r30, r16
    1ab6:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ab8:	81 50       	subi	r24, 0x01	; 1
    1aba:	86 8f       	std	Z+30, r24	; 0x1e
    1abc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1abe:	18 16       	cp	r1, r24
    1ac0:	7c f3       	brlt	.-34     	; 0x1aa0 <xQueueCreateMutex+0x250>
    1ac2:	8f ef       	ldi	r24, 0xFF	; 255
    1ac4:	f8 01       	movw	r30, r16
    1ac6:	86 8f       	std	Z+30, r24	; 0x1e
    1ac8:	0f 90       	pop	r0
    1aca:	0f be       	out	0x3f, r0	; 63
    1acc:	0f b6       	in	r0, 0x3f	; 63
    1ace:	f8 94       	cli
    1ad0:	0f 92       	push	r0
    1ad2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1ad4:	18 16       	cp	r1, r24
    1ad6:	ac f4       	brge	.+42     	; 0x1b02 <xQueueCreateMutex+0x2b2>
    1ad8:	80 85       	ldd	r24, Z+8	; 0x08
    1ada:	81 11       	cpse	r24, r1
    1adc:	05 c0       	rjmp	.+10     	; 0x1ae8 <xQueueCreateMutex+0x298>
    1ade:	11 c0       	rjmp	.+34     	; 0x1b02 <xQueueCreateMutex+0x2b2>
    1ae0:	f8 01       	movw	r30, r16
    1ae2:	80 85       	ldd	r24, Z+8	; 0x08
    1ae4:	88 23       	and	r24, r24
    1ae6:	69 f0       	breq	.+26     	; 0x1b02 <xQueueCreateMutex+0x2b2>
    1ae8:	c7 01       	movw	r24, r14
    1aea:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1aee:	81 11       	cpse	r24, r1
    1af0:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1af4:	f8 01       	movw	r30, r16
    1af6:	85 8d       	ldd	r24, Z+29	; 0x1d
    1af8:	81 50       	subi	r24, 0x01	; 1
    1afa:	85 8f       	std	Z+29, r24	; 0x1d
    1afc:	85 8d       	ldd	r24, Z+29	; 0x1d
    1afe:	18 16       	cp	r1, r24
    1b00:	7c f3       	brlt	.-34     	; 0x1ae0 <xQueueCreateMutex+0x290>
    1b02:	8f ef       	ldi	r24, 0xFF	; 255
    1b04:	f8 01       	movw	r30, r16
    1b06:	85 8f       	std	Z+29, r24	; 0x1d
    1b08:	0f 90       	pop	r0
    1b0a:	0f be       	out	0x3f, r0	; 63
    1b0c:	a6 d6       	rcall	.+3404   	; 0x285a <xTaskResumeAll>
    1b0e:	09 c0       	rjmp	.+18     	; 0x1b22 <xQueueCreateMutex+0x2d2>
    1b10:	f8 01       	movw	r30, r16
    1b12:	82 8d       	ldd	r24, Z+26	; 0x1a
    1b14:	8f 5f       	subi	r24, 0xFF	; 255
    1b16:	82 8f       	std	Z+26, r24	; 0x1a
    1b18:	81 89       	ldd	r24, Z+17	; 0x11
    1b1a:	88 23       	and	r24, r24
    1b1c:	09 f4       	brne	.+2      	; 0x1b20 <xQueueCreateMutex+0x2d0>
    1b1e:	f5 ce       	rjmp	.-534    	; 0x190a <xQueueCreateMutex+0xba>
    1b20:	eb ce       	rjmp	.-554    	; 0x18f8 <xQueueCreateMutex+0xa8>
    1b22:	c8 01       	movw	r24, r16
    1b24:	0f 90       	pop	r0
    1b26:	0f 90       	pop	r0
    1b28:	0f 90       	pop	r0
    1b2a:	0f 90       	pop	r0
    1b2c:	0f 90       	pop	r0
    1b2e:	df 91       	pop	r29
    1b30:	cf 91       	pop	r28
    1b32:	1f 91       	pop	r17
    1b34:	0f 91       	pop	r16
    1b36:	ff 90       	pop	r15
    1b38:	ef 90       	pop	r14
    1b3a:	df 90       	pop	r13
    1b3c:	cf 90       	pop	r12
    1b3e:	bf 90       	pop	r11
    1b40:	af 90       	pop	r10
    1b42:	9f 90       	pop	r9
    1b44:	08 95       	ret

00001b46 <xQueueGive>:
    1b46:	9f 92       	push	r9
    1b48:	af 92       	push	r10
    1b4a:	bf 92       	push	r11
    1b4c:	cf 92       	push	r12
    1b4e:	df 92       	push	r13
    1b50:	ef 92       	push	r14
    1b52:	ff 92       	push	r15
    1b54:	0f 93       	push	r16
    1b56:	1f 93       	push	r17
    1b58:	cf 93       	push	r28
    1b5a:	df 93       	push	r29
    1b5c:	00 d0       	rcall	.+0      	; 0x1b5e <xQueueGive+0x18>
    1b5e:	1f 92       	push	r1
    1b60:	1f 92       	push	r1
    1b62:	cd b7       	in	r28, 0x3d	; 61
    1b64:	de b7       	in	r29, 0x3e	; 62
    1b66:	8c 01       	movw	r16, r24
    1b68:	7d 83       	std	Y+5, r23	; 0x05
    1b6a:	6c 83       	std	Y+4, r22	; 0x04
    1b6c:	a1 2c       	mov	r10, r1
    1b6e:	99 24       	eor	r9, r9
    1b70:	93 94       	inc	r9
    1b72:	bb 24       	eor	r11, r11
    1b74:	ba 94       	dec	r11
    1b76:	7c 01       	movw	r14, r24
    1b78:	88 e0       	ldi	r24, 0x08	; 8
    1b7a:	e8 0e       	add	r14, r24
    1b7c:	f1 1c       	adc	r15, r1
    1b7e:	68 01       	movw	r12, r16
    1b80:	e1 e1       	ldi	r30, 0x11	; 17
    1b82:	ce 0e       	add	r12, r30
    1b84:	d1 1c       	adc	r13, r1
    1b86:	0f b6       	in	r0, 0x3f	; 63
    1b88:	f8 94       	cli
    1b8a:	0f 92       	push	r0
    1b8c:	f8 01       	movw	r30, r16
    1b8e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1b90:	83 8d       	ldd	r24, Z+27	; 0x1b
    1b92:	98 17       	cp	r25, r24
    1b94:	00 f5       	brcc	.+64     	; 0x1bd6 <xQueueGive+0x90>
    1b96:	80 81       	ld	r24, Z
    1b98:	91 81       	ldd	r25, Z+1	; 0x01
    1b9a:	89 2b       	or	r24, r25
    1b9c:	09 f0       	breq	.+2      	; 0x1ba0 <xQueueGive+0x5a>
    1b9e:	27 c1       	rjmp	.+590    	; 0x1dee <xQueueGive+0x2a8>
    1ba0:	82 81       	ldd	r24, Z+2	; 0x02
    1ba2:	93 81       	ldd	r25, Z+3	; 0x03
    1ba4:	0e 94 05 18 	call	0x300a	; 0x300a <xTaskPriorityDisinherit>
    1ba8:	f8 01       	movw	r30, r16
    1baa:	13 82       	std	Z+3, r1	; 0x03
    1bac:	12 82       	std	Z+2, r1	; 0x02
    1bae:	92 8d       	ldd	r25, Z+26	; 0x1a
    1bb0:	9f 5f       	subi	r25, 0xFF	; 255
    1bb2:	92 8f       	std	Z+26, r25	; 0x1a
    1bb4:	91 89       	ldd	r25, Z+17	; 0x11
    1bb6:	99 23       	and	r25, r25
    1bb8:	41 f0       	breq	.+16     	; 0x1bca <xQueueGive+0x84>
    1bba:	c8 01       	movw	r24, r16
    1bbc:	41 96       	adiw	r24, 0x11	; 17
    1bbe:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1bc2:	81 30       	cpi	r24, 0x01	; 1
    1bc4:	21 f4       	brne	.+8      	; 0x1bce <xQueueGive+0x88>
    1bc6:	69 dd       	rcall	.-1326   	; 0x169a <vPortYield>
    1bc8:	02 c0       	rjmp	.+4      	; 0x1bce <xQueueGive+0x88>
    1bca:	81 11       	cpse	r24, r1
    1bcc:	66 dd       	rcall	.-1332   	; 0x169a <vPortYield>
    1bce:	0f 90       	pop	r0
    1bd0:	0f be       	out	0x3f, r0	; 63
    1bd2:	81 e0       	ldi	r24, 0x01	; 1
    1bd4:	14 c1       	rjmp	.+552    	; 0x1dfe <xQueueGive+0x2b8>
    1bd6:	8c 81       	ldd	r24, Y+4	; 0x04
    1bd8:	9d 81       	ldd	r25, Y+5	; 0x05
    1bda:	89 2b       	or	r24, r25
    1bdc:	21 f4       	brne	.+8      	; 0x1be6 <xQueueGive+0xa0>
    1bde:	0f 90       	pop	r0
    1be0:	0f be       	out	0x3f, r0	; 63
    1be2:	80 e0       	ldi	r24, 0x00	; 0
    1be4:	0c c1       	rjmp	.+536    	; 0x1dfe <xQueueGive+0x2b8>
    1be6:	a1 10       	cpse	r10, r1
    1be8:	05 c0       	rjmp	.+10     	; 0x1bf4 <xQueueGive+0xae>
    1bea:	ce 01       	movw	r24, r28
    1bec:	01 96       	adiw	r24, 0x01	; 1
    1bee:	0e 94 54 17 	call	0x2ea8	; 0x2ea8 <vTaskSetTimeOutState>
    1bf2:	a9 2c       	mov	r10, r9
    1bf4:	0f 90       	pop	r0
    1bf6:	0f be       	out	0x3f, r0	; 63
    1bf8:	2a d6       	rcall	.+3156   	; 0x284e <vTaskSuspendAll>
    1bfa:	0f b6       	in	r0, 0x3f	; 63
    1bfc:	f8 94       	cli
    1bfe:	0f 92       	push	r0
    1c00:	f8 01       	movw	r30, r16
    1c02:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c04:	8f 3f       	cpi	r24, 0xFF	; 255
    1c06:	09 f4       	brne	.+2      	; 0x1c0a <xQueueGive+0xc4>
    1c08:	15 8e       	std	Z+29, r1	; 0x1d
    1c0a:	f8 01       	movw	r30, r16
    1c0c:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c0e:	8f 3f       	cpi	r24, 0xFF	; 255
    1c10:	09 f4       	brne	.+2      	; 0x1c14 <xQueueGive+0xce>
    1c12:	16 8e       	std	Z+30, r1	; 0x1e
    1c14:	0f 90       	pop	r0
    1c16:	0f be       	out	0x3f, r0	; 63
    1c18:	be 01       	movw	r22, r28
    1c1a:	6c 5f       	subi	r22, 0xFC	; 252
    1c1c:	7f 4f       	sbci	r23, 0xFF	; 255
    1c1e:	ce 01       	movw	r24, r28
    1c20:	01 96       	adiw	r24, 0x01	; 1
    1c22:	0e 94 5f 17 	call	0x2ebe	; 0x2ebe <xTaskCheckForTimeOut>
    1c26:	81 11       	cpse	r24, r1
    1c28:	94 c0       	rjmp	.+296    	; 0x1d52 <xQueueGive+0x20c>
    1c2a:	0f b6       	in	r0, 0x3f	; 63
    1c2c:	f8 94       	cli
    1c2e:	0f 92       	push	r0
    1c30:	f8 01       	movw	r30, r16
    1c32:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c34:	83 8d       	ldd	r24, Z+27	; 0x1b
    1c36:	0f 90       	pop	r0
    1c38:	0f be       	out	0x3f, r0	; 63
    1c3a:	98 13       	cpse	r25, r24
    1c3c:	49 c0       	rjmp	.+146    	; 0x1cd0 <xQueueGive+0x18a>
    1c3e:	6c 81       	ldd	r22, Y+4	; 0x04
    1c40:	7d 81       	ldd	r23, Y+5	; 0x05
    1c42:	c7 01       	movw	r24, r14
    1c44:	0e 94 b1 16 	call	0x2d62	; 0x2d62 <vTaskPlaceOnEventList>
    1c48:	0f b6       	in	r0, 0x3f	; 63
    1c4a:	f8 94       	cli
    1c4c:	0f 92       	push	r0
    1c4e:	f8 01       	movw	r30, r16
    1c50:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c52:	18 16       	cp	r1, r24
    1c54:	ac f4       	brge	.+42     	; 0x1c80 <xQueueGive+0x13a>
    1c56:	81 89       	ldd	r24, Z+17	; 0x11
    1c58:	81 11       	cpse	r24, r1
    1c5a:	05 c0       	rjmp	.+10     	; 0x1c66 <xQueueGive+0x120>
    1c5c:	11 c0       	rjmp	.+34     	; 0x1c80 <xQueueGive+0x13a>
    1c5e:	f8 01       	movw	r30, r16
    1c60:	81 89       	ldd	r24, Z+17	; 0x11
    1c62:	88 23       	and	r24, r24
    1c64:	69 f0       	breq	.+26     	; 0x1c80 <xQueueGive+0x13a>
    1c66:	c6 01       	movw	r24, r12
    1c68:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1c6c:	81 11       	cpse	r24, r1
    1c6e:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1c72:	f8 01       	movw	r30, r16
    1c74:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c76:	81 50       	subi	r24, 0x01	; 1
    1c78:	86 8f       	std	Z+30, r24	; 0x1e
    1c7a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1c7c:	18 16       	cp	r1, r24
    1c7e:	7c f3       	brlt	.-34     	; 0x1c5e <xQueueGive+0x118>
    1c80:	f8 01       	movw	r30, r16
    1c82:	b6 8e       	std	Z+30, r11	; 0x1e
    1c84:	0f 90       	pop	r0
    1c86:	0f be       	out	0x3f, r0	; 63
    1c88:	0f b6       	in	r0, 0x3f	; 63
    1c8a:	f8 94       	cli
    1c8c:	0f 92       	push	r0
    1c8e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c90:	18 16       	cp	r1, r24
    1c92:	ac f4       	brge	.+42     	; 0x1cbe <xQueueGive+0x178>
    1c94:	80 85       	ldd	r24, Z+8	; 0x08
    1c96:	81 11       	cpse	r24, r1
    1c98:	05 c0       	rjmp	.+10     	; 0x1ca4 <xQueueGive+0x15e>
    1c9a:	11 c0       	rjmp	.+34     	; 0x1cbe <xQueueGive+0x178>
    1c9c:	f8 01       	movw	r30, r16
    1c9e:	80 85       	ldd	r24, Z+8	; 0x08
    1ca0:	88 23       	and	r24, r24
    1ca2:	69 f0       	breq	.+26     	; 0x1cbe <xQueueGive+0x178>
    1ca4:	c7 01       	movw	r24, r14
    1ca6:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1caa:	81 11       	cpse	r24, r1
    1cac:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1cb0:	f8 01       	movw	r30, r16
    1cb2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cb4:	81 50       	subi	r24, 0x01	; 1
    1cb6:	85 8f       	std	Z+29, r24	; 0x1d
    1cb8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1cba:	18 16       	cp	r1, r24
    1cbc:	7c f3       	brlt	.-34     	; 0x1c9c <xQueueGive+0x156>
    1cbe:	f8 01       	movw	r30, r16
    1cc0:	b5 8e       	std	Z+29, r11	; 0x1d
    1cc2:	0f 90       	pop	r0
    1cc4:	0f be       	out	0x3f, r0	; 63
    1cc6:	c9 d5       	rcall	.+2962   	; 0x285a <xTaskResumeAll>
    1cc8:	81 11       	cpse	r24, r1
    1cca:	5d cf       	rjmp	.-326    	; 0x1b86 <xQueueGive+0x40>
    1ccc:	e6 dc       	rcall	.-1588   	; 0x169a <vPortYield>
    1cce:	5b cf       	rjmp	.-330    	; 0x1b86 <xQueueGive+0x40>
    1cd0:	0f b6       	in	r0, 0x3f	; 63
    1cd2:	f8 94       	cli
    1cd4:	0f 92       	push	r0
    1cd6:	f8 01       	movw	r30, r16
    1cd8:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cda:	18 16       	cp	r1, r24
    1cdc:	ac f4       	brge	.+42     	; 0x1d08 <xQueueGive+0x1c2>
    1cde:	81 89       	ldd	r24, Z+17	; 0x11
    1ce0:	81 11       	cpse	r24, r1
    1ce2:	05 c0       	rjmp	.+10     	; 0x1cee <xQueueGive+0x1a8>
    1ce4:	11 c0       	rjmp	.+34     	; 0x1d08 <xQueueGive+0x1c2>
    1ce6:	f8 01       	movw	r30, r16
    1ce8:	81 89       	ldd	r24, Z+17	; 0x11
    1cea:	88 23       	and	r24, r24
    1cec:	69 f0       	breq	.+26     	; 0x1d08 <xQueueGive+0x1c2>
    1cee:	c6 01       	movw	r24, r12
    1cf0:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1cf4:	81 11       	cpse	r24, r1
    1cf6:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1cfa:	f8 01       	movw	r30, r16
    1cfc:	86 8d       	ldd	r24, Z+30	; 0x1e
    1cfe:	81 50       	subi	r24, 0x01	; 1
    1d00:	86 8f       	std	Z+30, r24	; 0x1e
    1d02:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d04:	18 16       	cp	r1, r24
    1d06:	7c f3       	brlt	.-34     	; 0x1ce6 <xQueueGive+0x1a0>
    1d08:	f8 01       	movw	r30, r16
    1d0a:	b6 8e       	std	Z+30, r11	; 0x1e
    1d0c:	0f 90       	pop	r0
    1d0e:	0f be       	out	0x3f, r0	; 63
    1d10:	0f b6       	in	r0, 0x3f	; 63
    1d12:	f8 94       	cli
    1d14:	0f 92       	push	r0
    1d16:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d18:	18 16       	cp	r1, r24
    1d1a:	ac f4       	brge	.+42     	; 0x1d46 <xQueueGive+0x200>
    1d1c:	80 85       	ldd	r24, Z+8	; 0x08
    1d1e:	81 11       	cpse	r24, r1
    1d20:	05 c0       	rjmp	.+10     	; 0x1d2c <xQueueGive+0x1e6>
    1d22:	11 c0       	rjmp	.+34     	; 0x1d46 <xQueueGive+0x200>
    1d24:	f8 01       	movw	r30, r16
    1d26:	80 85       	ldd	r24, Z+8	; 0x08
    1d28:	88 23       	and	r24, r24
    1d2a:	69 f0       	breq	.+26     	; 0x1d46 <xQueueGive+0x200>
    1d2c:	c7 01       	movw	r24, r14
    1d2e:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1d32:	81 11       	cpse	r24, r1
    1d34:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1d38:	f8 01       	movw	r30, r16
    1d3a:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d3c:	81 50       	subi	r24, 0x01	; 1
    1d3e:	85 8f       	std	Z+29, r24	; 0x1d
    1d40:	85 8d       	ldd	r24, Z+29	; 0x1d
    1d42:	18 16       	cp	r1, r24
    1d44:	7c f3       	brlt	.-34     	; 0x1d24 <xQueueGive+0x1de>
    1d46:	f8 01       	movw	r30, r16
    1d48:	b5 8e       	std	Z+29, r11	; 0x1d
    1d4a:	0f 90       	pop	r0
    1d4c:	0f be       	out	0x3f, r0	; 63
    1d4e:	85 d5       	rcall	.+2826   	; 0x285a <xTaskResumeAll>
    1d50:	1a cf       	rjmp	.-460    	; 0x1b86 <xQueueGive+0x40>
    1d52:	0f b6       	in	r0, 0x3f	; 63
    1d54:	f8 94       	cli
    1d56:	0f 92       	push	r0
    1d58:	f8 01       	movw	r30, r16
    1d5a:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d5c:	18 16       	cp	r1, r24
    1d5e:	d4 f4       	brge	.+52     	; 0x1d94 <xQueueGive+0x24e>
    1d60:	81 89       	ldd	r24, Z+17	; 0x11
    1d62:	81 11       	cpse	r24, r1
    1d64:	06 c0       	rjmp	.+12     	; 0x1d72 <xQueueGive+0x22c>
    1d66:	16 c0       	rjmp	.+44     	; 0x1d94 <xQueueGive+0x24e>
    1d68:	f8 01       	movw	r30, r16
    1d6a:	81 89       	ldd	r24, Z+17	; 0x11
    1d6c:	81 11       	cpse	r24, r1
    1d6e:	05 c0       	rjmp	.+10     	; 0x1d7a <xQueueGive+0x234>
    1d70:	11 c0       	rjmp	.+34     	; 0x1d94 <xQueueGive+0x24e>
    1d72:	78 01       	movw	r14, r16
    1d74:	f1 e1       	ldi	r31, 0x11	; 17
    1d76:	ef 0e       	add	r14, r31
    1d78:	f1 1c       	adc	r15, r1
    1d7a:	c7 01       	movw	r24, r14
    1d7c:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1d80:	81 11       	cpse	r24, r1
    1d82:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1d86:	f8 01       	movw	r30, r16
    1d88:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d8a:	81 50       	subi	r24, 0x01	; 1
    1d8c:	86 8f       	std	Z+30, r24	; 0x1e
    1d8e:	86 8d       	ldd	r24, Z+30	; 0x1e
    1d90:	18 16       	cp	r1, r24
    1d92:	54 f3       	brlt	.-44     	; 0x1d68 <xQueueGive+0x222>
    1d94:	8f ef       	ldi	r24, 0xFF	; 255
    1d96:	f8 01       	movw	r30, r16
    1d98:	86 8f       	std	Z+30, r24	; 0x1e
    1d9a:	0f 90       	pop	r0
    1d9c:	0f be       	out	0x3f, r0	; 63
    1d9e:	0f b6       	in	r0, 0x3f	; 63
    1da0:	f8 94       	cli
    1da2:	0f 92       	push	r0
    1da4:	85 8d       	ldd	r24, Z+29	; 0x1d
    1da6:	18 16       	cp	r1, r24
    1da8:	d4 f4       	brge	.+52     	; 0x1dde <xQueueGive+0x298>
    1daa:	80 85       	ldd	r24, Z+8	; 0x08
    1dac:	81 11       	cpse	r24, r1
    1dae:	06 c0       	rjmp	.+12     	; 0x1dbc <xQueueGive+0x276>
    1db0:	16 c0       	rjmp	.+44     	; 0x1dde <xQueueGive+0x298>
    1db2:	f8 01       	movw	r30, r16
    1db4:	80 85       	ldd	r24, Z+8	; 0x08
    1db6:	81 11       	cpse	r24, r1
    1db8:	05 c0       	rjmp	.+10     	; 0x1dc4 <xQueueGive+0x27e>
    1dba:	11 c0       	rjmp	.+34     	; 0x1dde <xQueueGive+0x298>
    1dbc:	78 01       	movw	r14, r16
    1dbe:	f8 e0       	ldi	r31, 0x08	; 8
    1dc0:	ef 0e       	add	r14, r31
    1dc2:	f1 1c       	adc	r15, r1
    1dc4:	c7 01       	movw	r24, r14
    1dc6:	0e 94 0c 17 	call	0x2e18	; 0x2e18 <xTaskRemoveFromEventList>
    1dca:	81 11       	cpse	r24, r1
    1dcc:	0e 94 9a 17 	call	0x2f34	; 0x2f34 <vTaskMissedYield>
    1dd0:	f8 01       	movw	r30, r16
    1dd2:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dd4:	81 50       	subi	r24, 0x01	; 1
    1dd6:	85 8f       	std	Z+29, r24	; 0x1d
    1dd8:	85 8d       	ldd	r24, Z+29	; 0x1d
    1dda:	18 16       	cp	r1, r24
    1ddc:	54 f3       	brlt	.-44     	; 0x1db2 <xQueueGive+0x26c>
    1dde:	8f ef       	ldi	r24, 0xFF	; 255
    1de0:	f8 01       	movw	r30, r16
    1de2:	85 8f       	std	Z+29, r24	; 0x1d
    1de4:	0f 90       	pop	r0
    1de6:	0f be       	out	0x3f, r0	; 63
    1de8:	38 d5       	rcall	.+2672   	; 0x285a <xTaskResumeAll>
    1dea:	80 e0       	ldi	r24, 0x00	; 0
    1dec:	08 c0       	rjmp	.+16     	; 0x1dfe <xQueueGive+0x2b8>
    1dee:	f8 01       	movw	r30, r16
    1df0:	82 8d       	ldd	r24, Z+26	; 0x1a
    1df2:	8f 5f       	subi	r24, 0xFF	; 255
    1df4:	82 8f       	std	Z+26, r24	; 0x1a
    1df6:	81 89       	ldd	r24, Z+17	; 0x11
    1df8:	81 11       	cpse	r24, r1
    1dfa:	df ce       	rjmp	.-578    	; 0x1bba <xQueueGive+0x74>
    1dfc:	e8 ce       	rjmp	.-560    	; 0x1bce <xQueueGive+0x88>
    1dfe:	0f 90       	pop	r0
    1e00:	0f 90       	pop	r0
    1e02:	0f 90       	pop	r0
    1e04:	0f 90       	pop	r0
    1e06:	0f 90       	pop	r0
    1e08:	df 91       	pop	r29
    1e0a:	cf 91       	pop	r28
    1e0c:	1f 91       	pop	r17
    1e0e:	0f 91       	pop	r16
    1e10:	ff 90       	pop	r15
    1e12:	ef 90       	pop	r14
    1e14:	df 90       	pop	r13
    1e16:	cf 90       	pop	r12
    1e18:	bf 90       	pop	r11
    1e1a:	af 90       	pop	r10
    1e1c:	9f 90       	pop	r9
    1e1e:	08 95       	ret

00001e20 <xQueueGiveFromISR>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
{
    1e20:	cf 93       	push	r28
    1e22:	df 93       	push	r29
    1e24:	fc 01       	movw	r30, r24
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* When the queue is used to implement a semaphore no data is ever
		moved through the queue but it is still valid to see if the queue 'has
		space'. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e26:	92 8d       	ldd	r25, Z+26	; 0x1a
    1e28:	83 8d       	ldd	r24, Z+27	; 0x1b
    1e2a:	98 17       	cp	r25, r24
    1e2c:	c8 f4       	brcc	.+50     	; 0x1e60 <xQueueGiveFromISR+0x40>
			holder - and if there is a mutex holder then the mutex cannot be
			given from an ISR.  As this is the ISR version of the function it
			can be assumed there is no mutex holder and no need to determine if
			priority disinheritance is needed.  Simply increase the count of
			messages (semaphores) available. */
			++( pxQueue->uxMessagesWaiting );
    1e2e:	82 8d       	ldd	r24, Z+26	; 0x1a
    1e30:	8f 5f       	subi	r24, 0xFF	; 255
    1e32:	82 8f       	std	Z+26, r24	; 0x1a

			/* The event list is not altered if the queue is locked.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1e34:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e36:	8f 3f       	cpi	r24, 0xFF	; 255
    1e38:	71 f4       	brne	.+28     	; 0x1e56 <xQueueGiveFromISR+0x36>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1e3a:	81 89       	ldd	r24, Z+17	; 0x11
    1e3c:	88 23       	and	r24, r24
    1e3e:	91 f0       	breq	.+36     	; 0x1e64 <xQueueGiveFromISR+0x44>
    1e40:	eb 01       	movw	r28, r22
    1e42:	cf 01       	movw	r24, r30
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1e44:	41 96       	adiw	r24, 0x11	; 17
    1e46:	e8 d7       	rcall	.+4048   	; 0x2e18 <xTaskRemoveFromEventList>
    1e48:	88 23       	and	r24, r24
    1e4a:	71 f0       	breq	.+28     	; 0x1e68 <xQueueGiveFromISR+0x48>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1e4c:	20 97       	sbiw	r28, 0x00	; 0
    1e4e:	71 f0       	breq	.+28     	; 0x1e6c <xQueueGiveFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    1e50:	81 e0       	ldi	r24, 0x01	; 1
    1e52:	88 83       	st	Y, r24
    1e54:	0c c0       	rjmp	.+24     	; 0x1e6e <xQueueGiveFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1e56:	86 8d       	ldd	r24, Z+30	; 0x1e
    1e58:	8f 5f       	subi	r24, 0xFF	; 255
    1e5a:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    1e5c:	81 e0       	ldi	r24, 0x01	; 1
    1e5e:	07 c0       	rjmp	.+14     	; 0x1e6e <xQueueGiveFromISR+0x4e>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    1e60:	80 e0       	ldi	r24, 0x00	; 0
    1e62:	05 c0       	rjmp	.+10     	; 0x1e6e <xQueueGiveFromISR+0x4e>
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
			}

			xReturn = pdPASS;
    1e64:	81 e0       	ldi	r24, 0x01	; 1
    1e66:	03 c0       	rjmp	.+6      	; 0x1e6e <xQueueGiveFromISR+0x4e>
    1e68:	81 e0       	ldi	r24, 0x01	; 1
    1e6a:	01 c0       	rjmp	.+2      	; 0x1e6e <xQueueGiveFromISR+0x4e>
    1e6c:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1e6e:	df 91       	pop	r29
    1e70:	cf 91       	pop	r28
    1e72:	08 95       	ret

00001e74 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
{
    1e74:	6f 92       	push	r6
    1e76:	7f 92       	push	r7
    1e78:	8f 92       	push	r8
    1e7a:	9f 92       	push	r9
    1e7c:	af 92       	push	r10
    1e7e:	bf 92       	push	r11
    1e80:	cf 92       	push	r12
    1e82:	df 92       	push	r13
    1e84:	ef 92       	push	r14
    1e86:	ff 92       	push	r15
    1e88:	0f 93       	push	r16
    1e8a:	1f 93       	push	r17
    1e8c:	cf 93       	push	r28
    1e8e:	df 93       	push	r29
    1e90:	00 d0       	rcall	.+0      	; 0x1e92 <xQueueGenericReceive+0x1e>
    1e92:	1f 92       	push	r1
    1e94:	1f 92       	push	r1
    1e96:	cd b7       	in	r28, 0x3d	; 61
    1e98:	de b7       	in	r29, 0x3e	; 62
    1e9a:	8c 01       	movw	r16, r24
    1e9c:	5b 01       	movw	r10, r22
    1e9e:	5d 83       	std	Y+5, r21	; 0x05
    1ea0:	4c 83       	std	Y+4, r20	; 0x04
    1ea2:	62 2e       	mov	r6, r18
BaseType_t xEntryTimeSet = pdFALSE;
    1ea4:	81 2c       	mov	r8, r1
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
					xEntryTimeSet = pdTRUE;
    1ea6:	77 24       	eor	r7, r7
    1ea8:	73 94       	inc	r7
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    1eaa:	99 24       	eor	r9, r9
    1eac:	9a 94       	dec	r9
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1eae:	6c 01       	movw	r12, r24
    1eb0:	88 e0       	ldi	r24, 0x08	; 8
    1eb2:	c8 0e       	add	r12, r24
    1eb4:	d1 1c       	adc	r13, r1
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1eb6:	78 01       	movw	r14, r16
    1eb8:	e1 e1       	ldi	r30, 0x11	; 17
    1eba:	ee 0e       	add	r14, r30
    1ebc:	f1 1c       	adc	r15, r1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1ebe:	0f b6       	in	r0, 0x3f	; 63
    1ec0:	f8 94       	cli
    1ec2:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running the calling task
			must be	the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
    1ec4:	f8 01       	movw	r30, r16
    1ec6:	82 8d       	ldd	r24, Z+26	; 0x1a
    1ec8:	88 23       	and	r24, r24
    1eca:	09 f4       	brne	.+2      	; 0x1ece <xQueueGenericReceive+0x5a>
    1ecc:	43 c0       	rjmp	.+134    	; 0x1f54 <xQueueGenericReceive+0xe0>
			{
				/* Remember the read position in case the queue is only being
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
    1ece:	e6 80       	ldd	r14, Z+6	; 0x06
    1ed0:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
{
	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
    1ed2:	44 8d       	ldd	r20, Z+28	; 0x1c
    1ed4:	44 23       	and	r20, r20
    1ed6:	a9 f0       	breq	.+42     	; 0x1f02 <xQueueGenericReceive+0x8e>
	{
		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
    1ed8:	50 e0       	ldi	r21, 0x00	; 0
    1eda:	c7 01       	movw	r24, r14
    1edc:	84 0f       	add	r24, r20
    1ede:	95 1f       	adc	r25, r21
    1ee0:	97 83       	std	Z+7, r25	; 0x07
    1ee2:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
    1ee4:	22 81       	ldd	r18, Z+2	; 0x02
    1ee6:	33 81       	ldd	r19, Z+3	; 0x03
    1ee8:	82 17       	cp	r24, r18
    1eea:	93 07       	cpc	r25, r19
    1eec:	20 f0       	brcs	.+8      	; 0x1ef6 <xQueueGenericReceive+0x82>
		{
			pxQueue->u.pcReadFrom = pxQueue->pcHead;
    1eee:	80 81       	ld	r24, Z
    1ef0:	91 81       	ldd	r25, Z+1	; 0x01
    1ef2:	97 83       	std	Z+7, r25	; 0x07
    1ef4:	86 83       	std	Z+6, r24	; 0x06
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
    1ef6:	f8 01       	movw	r30, r16
    1ef8:	66 81       	ldd	r22, Z+6	; 0x06
    1efa:	77 81       	ldd	r23, Z+7	; 0x07
    1efc:	c5 01       	movw	r24, r10
    1efe:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
				peeked. */
				pcOriginalReadPosition = pxQueue->u.pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    1f02:	61 10       	cpse	r6, r1
    1f04:	18 c0       	rjmp	.+48     	; 0x1f36 <xQueueGenericReceive+0xc2>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* Actually removing data, not just peeking. */
					--( pxQueue->uxMessagesWaiting );
    1f06:	f8 01       	movw	r30, r16
    1f08:	82 8d       	ldd	r24, Z+26	; 0x1a
    1f0a:	81 50       	subi	r24, 0x01	; 1
    1f0c:	82 8f       	std	Z+26, r24	; 0x1a

					#if ( configUSE_MUTEXES == 1 )
					{
						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1f0e:	80 81       	ld	r24, Z
    1f10:	91 81       	ldd	r25, Z+1	; 0x01
    1f12:	89 2b       	or	r24, r25
    1f14:	29 f4       	brne	.+10     	; 0x1f20 <xQueueGenericReceive+0xac>
						{
							/* Record the information required to implement
							priority inheritance should it become necessary. */
							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
    1f16:	0e 94 45 18 	call	0x308a	; 0x308a <pvTaskIncrementMutexHeldCount>
    1f1a:	f8 01       	movw	r30, r16
    1f1c:	93 83       	std	Z+3, r25	; 0x03
    1f1e:	82 83       	std	Z+2, r24	; 0x02
							mtCOVERAGE_TEST_MARKER();
						}
					}
					#endif /* configUSE_MUTEXES */

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1f20:	f8 01       	movw	r30, r16
    1f22:	80 85       	ldd	r24, Z+8	; 0x08
    1f24:	88 23       	and	r24, r24
    1f26:	91 f0       	breq	.+36     	; 0x1f4c <xQueueGenericReceive+0xd8>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    1f28:	c8 01       	movw	r24, r16
    1f2a:	08 96       	adiw	r24, 0x08	; 8
    1f2c:	75 d7       	rcall	.+3818   	; 0x2e18 <xTaskRemoveFromEventList>
    1f2e:	81 30       	cpi	r24, 0x01	; 1
    1f30:	69 f4       	brne	.+26     	; 0x1f4c <xQueueGenericReceive+0xd8>
						{
							queueYIELD_IF_USING_PREEMPTION();
    1f32:	b3 db       	rcall	.-2202   	; 0x169a <vPortYield>
    1f34:	0b c0       	rjmp	.+22     	; 0x1f4c <xQueueGenericReceive+0xd8>
    1f36:	f8 01       	movw	r30, r16
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
    1f38:	f7 82       	std	Z+7, r15	; 0x07
    1f3a:	e6 82       	std	Z+6, r14	; 0x06
    1f3c:	81 89       	ldd	r24, Z+17	; 0x11

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1f3e:	88 23       	and	r24, r24
    1f40:	29 f0       	breq	.+10     	; 0x1f4c <xQueueGenericReceive+0xd8>
    1f42:	c8 01       	movw	r24, r16
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1f44:	41 96       	adiw	r24, 0x11	; 17
    1f46:	68 d7       	rcall	.+3792   	; 0x2e18 <xTaskRemoveFromEventList>
    1f48:	81 11       	cpse	r24, r1
						{
							/* The task waiting has a higher priority than this task. */
							queueYIELD_IF_USING_PREEMPTION();
    1f4a:	a7 db       	rcall	.-2226   	; 0x169a <vPortYield>
    1f4c:	0f 90       	pop	r0
					{
						mtCOVERAGE_TEST_MARKER();
					}
				}

				taskEXIT_CRITICAL();
    1f4e:	0f be       	out	0x3f, r0	; 63
    1f50:	81 e0       	ldi	r24, 0x01	; 1
				return pdPASS;
    1f52:	07 c1       	rjmp	.+526    	; 0x2162 <xQueueGenericReceive+0x2ee>
    1f54:	8c 81       	ldd	r24, Y+4	; 0x04
			}
			else
			{
				if( xTicksToWait == ( TickType_t ) 0 )
    1f56:	9d 81       	ldd	r25, Y+5	; 0x05
    1f58:	89 2b       	or	r24, r25
    1f5a:	21 f4       	brne	.+8      	; 0x1f64 <xQueueGenericReceive+0xf0>
    1f5c:	0f 90       	pop	r0
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1f5e:	0f be       	out	0x3f, r0	; 63
    1f60:	80 e0       	ldi	r24, 0x00	; 0
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    1f62:	ff c0       	rjmp	.+510    	; 0x2162 <xQueueGenericReceive+0x2ee>
    1f64:	81 10       	cpse	r8, r1
				}
				else if( xEntryTimeSet == pdFALSE )
    1f66:	04 c0       	rjmp	.+8      	; 0x1f70 <xQueueGenericReceive+0xfc>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1f68:	ce 01       	movw	r24, r28
    1f6a:	01 96       	adiw	r24, 0x01	; 1
    1f6c:	9d d7       	rcall	.+3898   	; 0x2ea8 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1f6e:	87 2c       	mov	r8, r7
					/* Entry time was already set. */
					mtCOVERAGE_TEST_MARKER();
				}
			}
		}
		taskEXIT_CRITICAL();
    1f70:	0f 90       	pop	r0
    1f72:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f74:	6c d4       	rcall	.+2264   	; 0x284e <vTaskSuspendAll>
    1f76:	0f b6       	in	r0, 0x3f	; 63
		prvLockQueue( pxQueue );
    1f78:	f8 94       	cli
    1f7a:	0f 92       	push	r0
    1f7c:	f8 01       	movw	r30, r16
    1f7e:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f80:	8f 3f       	cpi	r24, 0xFF	; 255
    1f82:	09 f4       	brne	.+2      	; 0x1f86 <xQueueGenericReceive+0x112>
    1f84:	15 8e       	std	Z+29, r1	; 0x1d
    1f86:	f8 01       	movw	r30, r16
    1f88:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f8a:	8f 3f       	cpi	r24, 0xFF	; 255
    1f8c:	09 f4       	brne	.+2      	; 0x1f90 <xQueueGenericReceive+0x11c>
    1f8e:	16 8e       	std	Z+30, r1	; 0x1e
    1f90:	0f 90       	pop	r0
    1f92:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f94:	be 01       	movw	r22, r28
    1f96:	6c 5f       	subi	r22, 0xFC	; 252
    1f98:	7f 4f       	sbci	r23, 0xFF	; 255
    1f9a:	ce 01       	movw	r24, r28
    1f9c:	01 96       	adiw	r24, 0x01	; 1
    1f9e:	8f d7       	rcall	.+3870   	; 0x2ebe <xTaskCheckForTimeOut>
    1fa0:	81 11       	cpse	r24, r1
    1fa2:	96 c0       	rjmp	.+300    	; 0x20d0 <xQueueGenericReceive+0x25c>
    1fa4:	0f b6       	in	r0, 0x3f	; 63

static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
{
BaseType_t xReturn;

	taskENTER_CRITICAL();
    1fa6:	f8 94       	cli
    1fa8:	0f 92       	push	r0
    1faa:	f8 01       	movw	r30, r16
	{
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
    1fac:	82 8d       	ldd	r24, Z+26	; 0x1a
    1fae:	0f 90       	pop	r0
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1fb0:	0f be       	out	0x3f, r0	; 63
    1fb2:	81 11       	cpse	r24, r1
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    1fb4:	50 c0       	rjmp	.+160    	; 0x2056 <xQueueGenericReceive+0x1e2>
    1fb6:	80 81       	ld	r24, Z
			{
				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );

				#if ( configUSE_MUTEXES == 1 )
				{
					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
    1fb8:	91 81       	ldd	r25, Z+1	; 0x01
    1fba:	89 2b       	or	r24, r25
    1fbc:	41 f4       	brne	.+16     	; 0x1fce <xQueueGenericReceive+0x15a>
					{
						taskENTER_CRITICAL();
    1fbe:	0f b6       	in	r0, 0x3f	; 63
    1fc0:	f8 94       	cli
    1fc2:	0f 92       	push	r0
						{
							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
    1fc4:	82 81       	ldd	r24, Z+2	; 0x02
    1fc6:	93 81       	ldd	r25, Z+3	; 0x03
    1fc8:	be d7       	rcall	.+3964   	; 0x2f46 <vTaskPriorityInherit>
						}
						taskEXIT_CRITICAL();
    1fca:	0f 90       	pop	r0
    1fcc:	0f be       	out	0x3f, r0	; 63
						mtCOVERAGE_TEST_MARKER();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1fce:	6c 81       	ldd	r22, Y+4	; 0x04
    1fd0:	7d 81       	ldd	r23, Y+5	; 0x05
    1fd2:	c7 01       	movw	r24, r14
    1fd4:	c6 d6       	rcall	.+3468   	; 0x2d62 <vTaskPlaceOnEventList>
    1fd6:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    1fd8:	f8 94       	cli
    1fda:	0f 92       	push	r0
    1fdc:	f8 01       	movw	r30, r16
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    1fde:	86 8d       	ldd	r24, Z+30	; 0x1e
    1fe0:	18 16       	cp	r1, r24
    1fe2:	9c f4       	brge	.+38     	; 0x200a <xQueueGenericReceive+0x196>
    1fe4:	81 89       	ldd	r24, Z+17	; 0x11
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1fe6:	81 11       	cpse	r24, r1
    1fe8:	05 c0       	rjmp	.+10     	; 0x1ff4 <xQueueGenericReceive+0x180>
    1fea:	0f c0       	rjmp	.+30     	; 0x200a <xQueueGenericReceive+0x196>
    1fec:	f8 01       	movw	r30, r16
    1fee:	81 89       	ldd	r24, Z+17	; 0x11
    1ff0:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1ff2:	59 f0       	breq	.+22     	; 0x200a <xQueueGenericReceive+0x196>
    1ff4:	c7 01       	movw	r24, r14
    1ff6:	10 d7       	rcall	.+3616   	; 0x2e18 <xTaskRemoveFromEventList>
    1ff8:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    1ffa:	9c d7       	rcall	.+3896   	; 0x2f34 <vTaskMissedYield>
    1ffc:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    1ffe:	86 8d       	ldd	r24, Z+30	; 0x1e
    2000:	81 50       	subi	r24, 0x01	; 1
    2002:	86 8f       	std	Z+30, r24	; 0x1e
    2004:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2006:	18 16       	cp	r1, r24
    2008:	8c f3       	brlt	.-30     	; 0x1fec <xQueueGenericReceive+0x178>
    200a:	f8 01       	movw	r30, r16
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    200c:	96 8e       	std	Z+30, r9	; 0x1e
    200e:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    2010:	0f be       	out	0x3f, r0	; 63
    2012:	0f b6       	in	r0, 0x3f	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2014:	f8 94       	cli
    2016:	0f 92       	push	r0
    2018:	85 8d       	ldd	r24, Z+29	; 0x1d
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    201a:	18 16       	cp	r1, r24
    201c:	9c f4       	brge	.+38     	; 0x2044 <xQueueGenericReceive+0x1d0>
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    201e:	80 85       	ldd	r24, Z+8	; 0x08
    2020:	81 11       	cpse	r24, r1
    2022:	05 c0       	rjmp	.+10     	; 0x202e <xQueueGenericReceive+0x1ba>
    2024:	0f c0       	rjmp	.+30     	; 0x2044 <xQueueGenericReceive+0x1d0>
    2026:	f8 01       	movw	r30, r16
    2028:	80 85       	ldd	r24, Z+8	; 0x08
    202a:	88 23       	and	r24, r24
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    202c:	59 f0       	breq	.+22     	; 0x2044 <xQueueGenericReceive+0x1d0>
    202e:	c6 01       	movw	r24, r12
    2030:	f3 d6       	rcall	.+3558   	; 0x2e18 <xTaskRemoveFromEventList>
    2032:	81 11       	cpse	r24, r1
				{
					vTaskMissedYield();
    2034:	7f d7       	rcall	.+3838   	; 0x2f34 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2036:	f8 01       	movw	r30, r16
    2038:	85 8d       	ldd	r24, Z+29	; 0x1d
    203a:	81 50       	subi	r24, 0x01	; 1
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    203c:	85 8f       	std	Z+29, r24	; 0x1d
    203e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2040:	18 16       	cp	r1, r24
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2042:	8c f3       	brlt	.-30     	; 0x2026 <xQueueGenericReceive+0x1b2>
    2044:	f8 01       	movw	r30, r16
	}
	taskEXIT_CRITICAL();
    2046:	95 8e       	std	Z+29, r9	; 0x1d
    2048:	0f 90       	pop	r0
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
				prvUnlockQueue( pxQueue );
				if( xTaskResumeAll() == pdFALSE )
    204a:	0f be       	out	0x3f, r0	; 63
    204c:	06 d4       	rcall	.+2060   	; 0x285a <xTaskResumeAll>
    204e:	81 11       	cpse	r24, r1
    2050:	36 cf       	rjmp	.-404    	; 0x1ebe <xQueueGenericReceive+0x4a>
				{
					portYIELD_WITHIN_API();
    2052:	23 db       	rcall	.-2490   	; 0x169a <vPortYield>
    2054:	34 cf       	rjmp	.-408    	; 0x1ebe <xQueueGenericReceive+0x4a>
    2056:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    2058:	f8 94       	cli
    205a:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    205c:	f8 01       	movw	r30, r16
    205e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2060:	18 16       	cp	r1, r24
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    2062:	9c f4       	brge	.+38     	; 0x208a <xQueueGenericReceive+0x216>
    2064:	81 89       	ldd	r24, Z+17	; 0x11
    2066:	81 11       	cpse	r24, r1
    2068:	05 c0       	rjmp	.+10     	; 0x2074 <xQueueGenericReceive+0x200>
    206a:	0f c0       	rjmp	.+30     	; 0x208a <xQueueGenericReceive+0x216>
    206c:	f8 01       	movw	r30, r16
    206e:	81 89       	ldd	r24, Z+17	; 0x11
    2070:	88 23       	and	r24, r24
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2072:	59 f0       	breq	.+22     	; 0x208a <xQueueGenericReceive+0x216>
    2074:	c7 01       	movw	r24, r14
    2076:	d0 d6       	rcall	.+3488   	; 0x2e18 <xTaskRemoveFromEventList>
    2078:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    207a:	5c d7       	rcall	.+3768   	; 0x2f34 <vTaskMissedYield>
    207c:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    207e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2080:	81 50       	subi	r24, 0x01	; 1
    2082:	86 8f       	std	Z+30, r24	; 0x1e
    2084:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    2086:	18 16       	cp	r1, r24
    2088:	8c f3       	brlt	.-30     	; 0x206c <xQueueGenericReceive+0x1f8>
    208a:	f8 01       	movw	r30, r16
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    208c:	96 8e       	std	Z+30, r9	; 0x1e
    208e:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    2090:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2092:	0f b6       	in	r0, 0x3f	; 63
    2094:	f8 94       	cli
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2096:	0f 92       	push	r0
    2098:	85 8d       	ldd	r24, Z+29	; 0x1d
    209a:	18 16       	cp	r1, r24
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    209c:	9c f4       	brge	.+38     	; 0x20c4 <xQueueGenericReceive+0x250>
    209e:	80 85       	ldd	r24, Z+8	; 0x08
    20a0:	81 11       	cpse	r24, r1
    20a2:	05 c0       	rjmp	.+10     	; 0x20ae <xQueueGenericReceive+0x23a>
    20a4:	0f c0       	rjmp	.+30     	; 0x20c4 <xQueueGenericReceive+0x250>
    20a6:	f8 01       	movw	r30, r16
    20a8:	80 85       	ldd	r24, Z+8	; 0x08
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    20aa:	88 23       	and	r24, r24
    20ac:	59 f0       	breq	.+22     	; 0x20c4 <xQueueGenericReceive+0x250>
    20ae:	c6 01       	movw	r24, r12
    20b0:	b3 d6       	rcall	.+3430   	; 0x2e18 <xTaskRemoveFromEventList>
				{
					vTaskMissedYield();
    20b2:	81 11       	cpse	r24, r1
    20b4:	3f d7       	rcall	.+3710   	; 0x2f34 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    20b6:	f8 01       	movw	r30, r16
    20b8:	85 8d       	ldd	r24, Z+29	; 0x1d
    20ba:	81 50       	subi	r24, 0x01	; 1
    20bc:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    20be:	85 8d       	ldd	r24, Z+29	; 0x1d
    20c0:	18 16       	cp	r1, r24
    20c2:	8c f3       	brlt	.-30     	; 0x20a6 <xQueueGenericReceive+0x232>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    20c4:	f8 01       	movw	r30, r16
    20c6:	95 8e       	std	Z+29, r9	; 0x1d
	}
	taskEXIT_CRITICAL();
    20c8:	0f 90       	pop	r0
    20ca:	0f be       	out	0x3f, r0	; 63
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
				( void ) xTaskResumeAll();
    20cc:	c6 d3       	rcall	.+1932   	; 0x285a <xTaskResumeAll>
    20ce:	f7 ce       	rjmp	.-530    	; 0x1ebe <xQueueGenericReceive+0x4a>
    20d0:	0f b6       	in	r0, 0x3f	; 63

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    20d2:	f8 94       	cli
    20d4:	0f 92       	push	r0
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    20d6:	f8 01       	movw	r30, r16
    20d8:	86 8d       	ldd	r24, Z+30	; 0x1e
    20da:	18 16       	cp	r1, r24
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20dc:	c4 f4       	brge	.+48     	; 0x210e <xQueueGenericReceive+0x29a>
    20de:	81 89       	ldd	r24, Z+17	; 0x11
    20e0:	81 11       	cpse	r24, r1
    20e2:	06 c0       	rjmp	.+12     	; 0x20f0 <xQueueGenericReceive+0x27c>
    20e4:	14 c0       	rjmp	.+40     	; 0x210e <xQueueGenericReceive+0x29a>
    20e6:	f8 01       	movw	r30, r16
    20e8:	81 89       	ldd	r24, Z+17	; 0x11
    20ea:	81 11       	cpse	r24, r1
    20ec:	05 c0       	rjmp	.+10     	; 0x20f8 <xQueueGenericReceive+0x284>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20ee:	0f c0       	rjmp	.+30     	; 0x210e <xQueueGenericReceive+0x29a>
    20f0:	78 01       	movw	r14, r16
    20f2:	f1 e1       	ldi	r31, 0x11	; 17
    20f4:	ef 0e       	add	r14, r31
    20f6:	f1 1c       	adc	r15, r1
    20f8:	c7 01       	movw	r24, r14
    20fa:	8e d6       	rcall	.+3356   	; 0x2e18 <xTaskRemoveFromEventList>
    20fc:	81 11       	cpse	r24, r1
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    20fe:	1a d7       	rcall	.+3636   	; 0x2f34 <vTaskMissedYield>
    2100:	f8 01       	movw	r30, r16
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    2102:	86 8d       	ldd	r24, Z+30	; 0x1e
    2104:	81 50       	subi	r24, 0x01	; 1
    2106:	86 8f       	std	Z+30, r24	; 0x1e
    2108:	86 8d       	ldd	r24, Z+30	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    210a:	18 16       	cp	r1, r24
    210c:	64 f3       	brlt	.-40     	; 0x20e6 <xQueueGenericReceive+0x272>
    210e:	8f ef       	ldi	r24, 0xFF	; 255
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    2110:	f8 01       	movw	r30, r16
    2112:	86 8f       	std	Z+30, r24	; 0x1e
    2114:	0f 90       	pop	r0
	}
	taskEXIT_CRITICAL();
    2116:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    2118:	0f b6       	in	r0, 0x3f	; 63
    211a:	f8 94       	cli
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    211c:	0f 92       	push	r0
    211e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2120:	18 16       	cp	r1, r24
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2122:	c4 f4       	brge	.+48     	; 0x2154 <xQueueGenericReceive+0x2e0>
    2124:	80 85       	ldd	r24, Z+8	; 0x08
    2126:	81 11       	cpse	r24, r1
    2128:	06 c0       	rjmp	.+12     	; 0x2136 <xQueueGenericReceive+0x2c2>
    212a:	14 c0       	rjmp	.+40     	; 0x2154 <xQueueGenericReceive+0x2e0>
    212c:	f8 01       	movw	r30, r16
    212e:	80 85       	ldd	r24, Z+8	; 0x08
    2130:	81 11       	cpse	r24, r1
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2132:	05 c0       	rjmp	.+10     	; 0x213e <xQueueGenericReceive+0x2ca>
    2134:	0f c0       	rjmp	.+30     	; 0x2154 <xQueueGenericReceive+0x2e0>
    2136:	78 01       	movw	r14, r16
    2138:	f8 e0       	ldi	r31, 0x08	; 8
    213a:	ef 0e       	add	r14, r31
    213c:	f1 1c       	adc	r15, r1
    213e:	c7 01       	movw	r24, r14
    2140:	6b d6       	rcall	.+3286   	; 0x2e18 <xTaskRemoveFromEventList>
				{
					vTaskMissedYield();
    2142:	81 11       	cpse	r24, r1
    2144:	f7 d6       	rcall	.+3566   	; 0x2f34 <vTaskMissedYield>
				else
				{
					mtCOVERAGE_TEST_MARKER();
				}

				--( pxQueue->xRxLock );
    2146:	f8 01       	movw	r30, r16
    2148:	85 8d       	ldd	r24, Z+29	; 0x1d
    214a:	81 50       	subi	r24, 0x01	; 1
    214c:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    214e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2150:	18 16       	cp	r1, r24
    2152:	64 f3       	brlt	.-40     	; 0x212c <xQueueGenericReceive+0x2b8>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2154:	8f ef       	ldi	r24, 0xFF	; 255
    2156:	f8 01       	movw	r30, r16
    2158:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    215a:	0f 90       	pop	r0
    215c:	0f be       	out	0x3f, r0	; 63
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
			( void ) xTaskResumeAll();
    215e:	7d d3       	rcall	.+1786   	; 0x285a <xTaskResumeAll>
    2160:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    2162:	0f 90       	pop	r0
		}
	}
}
    2164:	0f 90       	pop	r0
    2166:	0f 90       	pop	r0
    2168:	0f 90       	pop	r0
    216a:	0f 90       	pop	r0
    216c:	df 91       	pop	r29
    216e:	cf 91       	pop	r28
    2170:	1f 91       	pop	r17
    2172:	0f 91       	pop	r16
    2174:	ff 90       	pop	r15
    2176:	ef 90       	pop	r14
    2178:	df 90       	pop	r13
    217a:	cf 90       	pop	r12
    217c:	bf 90       	pop	r11
    217e:	af 90       	pop	r10
    2180:	9f 90       	pop	r9
    2182:	8f 90       	pop	r8
    2184:	7f 90       	pop	r7
    2186:	6f 90       	pop	r6
    2188:	08 95       	ret

0000218a <server_receiver>:
  uint8_t status = TYPE_PING_RESPONSE;
  if(use_arq[TYPE_PING_RESPONSE]) arq_send(server_connection, &status, 1);
  else simple_p_send(SERVER_ADDRESS, &status, 1);
}

void server_receiver(uint8_t *data, uint16_t len) {
    218a:	ab 01       	movw	r20, r22
  if(data == NULL) { // ARQ passes NULL to the callback when connection is lost
    218c:	00 97       	sbiw	r24, 0x00	; 0
    218e:	11 f4       	brne	.+4      	; 0x2194 <server_receiver+0xa>
      gHandshook = 0;
    2190:	10 92 6c 15 	sts	0x156C, r1	; 0x80156c <gHandshook>
  }
  memcpy(&message_in, data, len);
    2194:	bc 01       	movw	r22, r24
    2196:	88 ed       	ldi	r24, 0xD8	; 216
    2198:	96 e1       	ldi	r25, 0x16	; 22
    219a:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
  xSemaphoreGive(xCommandReadyBSem);
    219e:	60 e0       	ldi	r22, 0x00	; 0
    21a0:	70 e0       	ldi	r23, 0x00	; 0
    21a2:	80 91 d4 16 	lds	r24, 0x16D4	; 0x8016d4 <xCommandReadyBSem>
    21a6:	90 91 d5 16 	lds	r25, 0x16D5	; 0x8016d5 <xCommandReadyBSem+0x1>
    21aa:	cd cc       	rjmp	.-1638   	; 0x1b46 <xQueueGive>
    21ac:	08 95       	ret

000021ae <vServo_setAngle>:
}

/* Sets servo angle to a specific degree */
void vServo_setAngle(uint8_t ServoAngleDeg){
    /* Ensure feasible values */
    if (ServoAngleDeg >= 90){
    21ae:	8a 35       	cpi	r24, 0x5A	; 90
    21b0:	08 f0       	brcs	.+2      	; 0x21b4 <vServo_setAngle+0x6>
        ServoAngleDeg = 90;
    21b2:	8a e5       	ldi	r24, 0x5A	; 90
    }
    else if(ServoAngleDeg <= 0){
        ServoAngleDeg = 0;
    }
    /* Fetch pulse width from array and set to output */
    servoOCR = DEG_TO_PWM[ServoAngleDeg];
    21b4:	e8 2f       	mov	r30, r24
    21b6:	f0 e0       	ldi	r31, 0x00	; 0
    21b8:	ee 0f       	add	r30, r30
    21ba:	ff 1f       	adc	r31, r31
    21bc:	e0 50       	subi	r30, 0x00	; 0
    21be:	fe 4f       	sbci	r31, 0xFE	; 254
    21c0:	80 81       	ld	r24, Z
    21c2:	91 81       	ldd	r25, Z+1	; 0x01
    21c4:	90 93 ab 00 	sts	0x00AB, r25	; 0x8000ab <__TEXT_REGION_LENGTH__+0x7000ab>
    21c8:	80 93 aa 00 	sts	0x00AA, r24	; 0x8000aa <__TEXT_REGION_LENGTH__+0x7000aa>
    21cc:	08 95       	ret

000021ce <vServo_init>:
/************************************************************************/
void vServo_init(uint8_t servoAngleDeg){
    /* Clear OCnA/OCnB on Compare Match, set */
    /* OCnA/OCnB at BOTTOM (non-inverting mode) */
    /* Datasheet p.132 Table 14-3 */
   TCCR4A |= (1<<COM4B1) | (0<<COM4B0);
    21ce:	a0 ea       	ldi	r26, 0xA0	; 160
    21d0:	b0 e0       	ldi	r27, 0x00	; 0
    21d2:	9c 91       	ld	r25, X
    21d4:	90 62       	ori	r25, 0x20	; 32
    21d6:	9c 93       	st	X, r25
    
    /* Waveform generation mode 14: Fast PWM */
    /* top: ICRn, Update bottom, flag set on top */
    /* Datasheet p.133 Table 14-5 */
    TCCR4B |= (1<<WGM43) | (1<<WGM42);
    21d8:	e1 ea       	ldi	r30, 0xA1	; 161
    21da:	f0 e0       	ldi	r31, 0x00	; 0
    21dc:	90 81       	ld	r25, Z
    21de:	98 61       	ori	r25, 0x18	; 24
    21e0:	90 83       	st	Z, r25
    TCCR4A |= (1<<WGM41) | (0<<WGM40);
    21e2:	9c 91       	ld	r25, X
    21e4:	92 60       	ori	r25, 0x02	; 2
    21e6:	9c 93       	st	X, r25

    /* Clock select bit description: */
    /* clkI/O/8 (From prescaler) - Datasheet p.134 Table 14-6*/
    TCCR4B |= (0<<CS42) | (1<<CS41) | (0<<CS40);
    21e8:	90 81       	ld	r25, Z
    21ea:	92 60       	ori	r25, 0x02	; 2
    21ec:	90 83       	st	Z, r25
    
    /* 50Hz 20ms period => 16Mhz/(8clk*50Hz) - 1 = ICR1] */
    /* Datasheet p.125 */
    ICR4 = 39999; // 49999 for 20mhz, 39 999 for 16mhz
    21ee:	2f e3       	ldi	r18, 0x3F	; 63
    21f0:	3c e9       	ldi	r19, 0x9C	; 156
    21f2:	30 93 a7 00 	sts	0x00A7, r19	; 0x8000a7 <__TEXT_REGION_LENGTH__+0x7000a7>
    21f6:	20 93 a6 00 	sts	0x00A6, r18	; 0x8000a6 <__TEXT_REGION_LENGTH__+0x7000a6>
    
    /*PortB Pin 5 as servo PWM Output (OC1A)*/
    servoReg |= (1<<servoPin);
    21fa:	e1 e0       	ldi	r30, 0x01	; 1
    21fc:	f1 e0       	ldi	r31, 0x01	; 1
    21fe:	90 81       	ld	r25, Z
    2200:	90 61       	ori	r25, 0x10	; 16
    2202:	90 83       	st	Z, r25
    
    /*  Set angle to desired start angle (usually 0)*/
    vServo_setAngle(servoAngleDeg);
    2204:	d4 cf       	rjmp	.-88     	; 0x21ae <vServo_setAngle>
    2206:	08 95       	ret

00002208 <simple_p_reassembly>:
  vPortFree(part);
  return 1;
}


void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length) {
    2208:	ef 92       	push	r14
    220a:	ff 92       	push	r15
    220c:	0f 93       	push	r16
    220e:	1f 93       	push	r17
    2210:	cf 93       	push	r28
    2212:	df 93       	push	r29
  uint8_t i;
  uint8_t id = 0xFF;
  uint8_t free = 0xFF;
  for(i=0;i<MAX_MESSAGES;i++) {
    if(messages[i].address == 0xFF && free == 0xFF) free = i;
    2214:	90 91 72 15 	lds	r25, 0x1572	; 0x801572 <messages+0x1>
    2218:	9f 3f       	cpi	r25, 0xFF	; 255
    221a:	11 f0       	breq	.+4      	; 0x2220 <simple_p_reassembly+0x18>
    else if(messages[i].address == sender) {
    221c:	98 13       	cpse	r25, r24
    221e:	58 c0       	rjmp	.+176    	; 0x22d0 <simple_p_reassembly+0xc8>
  if(id == 0xFF && free == 0xFF) return; // Not room for any more messages, and none is stored for this address
  else if(id == 0xFF && free != 0xFF) { // Did not find any part messages from this sender, but there is room to store a new one
    id = free; 
  }
    
  if(data[0] == 0) { // First part of a new message
    2220:	fb 01       	movw	r30, r22
    2222:	80 81       	ld	r24, Z
    2224:	81 11       	cpse	r24, r1
    2226:	05 c0       	rjmp	.+10     	; 0x2232 <simple_p_reassembly+0x2a>
    messages[id].num_received_bytes = 0;
    2228:	10 92 74 15 	sts	0x1574, r1	; 0x801574 <messages+0x3>
    222c:	10 92 73 15 	sts	0x1573, r1	; 0x801573 <messages+0x2>
    2230:	0c c0       	rjmp	.+24     	; 0x224a <simple_p_reassembly+0x42>
  } else if(data[0] != messages[id].next_part) {
    2232:	90 91 75 15 	lds	r25, 0x1575	; 0x801575 <messages+0x4>
    2236:	89 17       	cp	r24, r25
    2238:	41 f0       	breq	.+16     	; 0x224a <simple_p_reassembly+0x42>
    messages[id].next_part = 0;
    223a:	e1 e7       	ldi	r30, 0x71	; 113
    223c:	f5 e1       	ldi	r31, 0x15	; 21
    223e:	14 82       	std	Z+4, r1	; 0x04
    messages[id].num_received_bytes = 0;
    2240:	13 82       	std	Z+3, r1	; 0x03
    2242:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    2244:	8f ef       	ldi	r24, 0xFF	; 255
    2246:	81 83       	std	Z+1, r24	; 0x01
    return;
    2248:	43 c0       	rjmp	.+134    	; 0x22d0 <simple_p_reassembly+0xc8>
  }

  if(messages[id].num_received_bytes + (length-2) > MAX_MESSAGE_SIZE) { // Message is larger than what can be handled, discard it
    224a:	80 91 73 15 	lds	r24, 0x1573	; 0x801573 <messages+0x2>
    224e:	90 91 74 15 	lds	r25, 0x1574	; 0x801574 <messages+0x3>
    2252:	9c 01       	movw	r18, r24
    2254:	22 50       	subi	r18, 0x02	; 2
    2256:	31 09       	sbc	r19, r1
    2258:	24 0f       	add	r18, r20
    225a:	35 1f       	adc	r19, r21
    225c:	25 36       	cpi	r18, 0x65	; 101
    225e:	31 05       	cpc	r19, r1
    2260:	40 f0       	brcs	.+16     	; 0x2272 <simple_p_reassembly+0x6a>
    messages[id].num_received_bytes = 0;
    2262:	e1 e7       	ldi	r30, 0x71	; 113
    2264:	f5 e1       	ldi	r31, 0x15	; 21
    2266:	13 82       	std	Z+3, r1	; 0x03
    2268:	12 82       	std	Z+2, r1	; 0x02
    messages[id].next_part = 0;
    226a:	14 82       	std	Z+4, r1	; 0x04
    messages[id].address = 0xFF;
    226c:	8f ef       	ldi	r24, 0xFF	; 255
    226e:	81 83       	std	Z+1, r24	; 0x01
    return;
    2270:	2f c0       	rjmp	.+94     	; 0x22d0 <simple_p_reassembly+0xc8>
    2272:	8a 01       	movw	r16, r20
    2274:	eb 01       	movw	r28, r22
  }
  
  messages[id].next_part++;
    2276:	0f 2e       	mov	r0, r31
    2278:	f1 e7       	ldi	r31, 0x71	; 113
    227a:	ef 2e       	mov	r14, r31
    227c:	f5 e1       	ldi	r31, 0x15	; 21
    227e:	ff 2e       	mov	r15, r31
    2280:	f0 2d       	mov	r31, r0
    2282:	f7 01       	movw	r30, r14
    2284:	24 81       	ldd	r18, Z+4	; 0x04
    2286:	2f 5f       	subi	r18, 0xFF	; 255
    2288:	24 83       	std	Z+4, r18	; 0x04
  memcpy(messages[id].message+messages[id].num_received_bytes, data+2, length-2);
    228a:	42 50       	subi	r20, 0x02	; 2
    228c:	51 09       	sbc	r21, r1
    228e:	6e 5f       	subi	r22, 0xFE	; 254
    2290:	7f 4f       	sbci	r23, 0xFF	; 255
    2292:	8a 58       	subi	r24, 0x8A	; 138
    2294:	9a 4e       	sbci	r25, 0xEA	; 234
    2296:	0e 94 ed 1f 	call	0x3fda	; 0x3fda <memcpy>
  messages[id].num_received_bytes += (length-2);
    229a:	f7 01       	movw	r30, r14
    229c:	42 81       	ldd	r20, Z+2	; 0x02
    229e:	53 81       	ldd	r21, Z+3	; 0x03
    22a0:	42 50       	subi	r20, 0x02	; 2
    22a2:	51 09       	sbc	r21, r1
    22a4:	ba 01       	movw	r22, r20
    22a6:	60 0f       	add	r22, r16
    22a8:	71 1f       	adc	r23, r17
    22aa:	73 83       	std	Z+3, r23	; 0x03
    22ac:	62 83       	std	Z+2, r22	; 0x02
  
  if(data[0] == data[1]) {
    22ae:	98 81       	ld	r25, Y
    22b0:	89 81       	ldd	r24, Y+1	; 0x01
    22b2:	98 13       	cpse	r25, r24
    22b4:	0d c0       	rjmp	.+26     	; 0x22d0 <simple_p_reassembly+0xc8>
    callback_data_received(messages[id].message, messages[id].num_received_bytes);
    22b6:	e0 91 0c 17 	lds	r30, 0x170C	; 0x80170c <callback_data_received>
    22ba:	f0 91 0d 17 	lds	r31, 0x170D	; 0x80170d <callback_data_received+0x1>
    22be:	86 e7       	ldi	r24, 0x76	; 118
    22c0:	95 e1       	ldi	r25, 0x15	; 21
    22c2:	19 95       	eicall
    messages[id].num_received_bytes = messages[id].next_part = 0;
    22c4:	f7 01       	movw	r30, r14
    22c6:	14 82       	std	Z+4, r1	; 0x04
    22c8:	13 82       	std	Z+3, r1	; 0x03
    22ca:	12 82       	std	Z+2, r1	; 0x02
    messages[id].address = 0xFF;
    22cc:	8f ef       	ldi	r24, 0xFF	; 255
    22ce:	81 83       	std	Z+1, r24	; 0x01
  }
    22d0:	df 91       	pop	r29
    22d2:	cf 91       	pop	r28
    22d4:	1f 91       	pop	r17
    22d6:	0f 91       	pop	r16
    22d8:	ff 90       	pop	r15
    22da:	ef 90       	pop	r14
    22dc:	08 95       	ret

000022de <simple_p_init>:
void (*callback_data_received)(uint8_t*, uint16_t); 

void simple_p_reassembly(uint8_t sender, uint8_t *data, uint16_t length);

void simple_p_init(void (*cb)(uint8_t*, uint16_t)) {
  callback_data_received = cb;
    22de:	90 93 0d 17 	sts	0x170D, r25	; 0x80170d <callback_data_received+0x1>
    22e2:	80 93 0c 17 	sts	0x170C, r24	; 0x80170c <callback_data_received>
  uint8_t i;
  network_set_callback(PROTOCOL_SIMPLE, simple_p_reassembly);
    22e6:	64 e0       	ldi	r22, 0x04	; 4
    22e8:	71 e1       	ldi	r23, 0x11	; 17
    22ea:	80 e0       	ldi	r24, 0x00	; 0
    22ec:	f1 d8       	rcall	.-3614   	; 0x14d0 <network_set_callback>
  for(i=0;i<MAX_MESSAGES;i++) {
    messages[i].address = 0xFF;
    22ee:	8f ef       	ldi	r24, 0xFF	; 255
    22f0:	80 93 72 15 	sts	0x1572, r24	; 0x801572 <messages+0x1>
    22f4:	08 95       	ret

000022f6 <vSPI_MasterInit>:

#include "defines.h"

void vSPI_MasterInit(){
    /* Set MOSI SCK and slave select pin as output */
    DDR_SPI |= (1<<DD_MOSI) | (1<<DD_SCK) | (1<<IMU_SS);
    22f6:	84 b1       	in	r24, 0x04	; 4
    22f8:	87 60       	ori	r24, 0x07	; 7
    22fa:	84 b9       	out	0x04, r24	; 4
    DDR_SPI &= ~(1 << DD_MISO); // Set MISO as input
    22fc:	23 98       	cbi	0x04, 3	; 4
    
    /* Enable SPI, master, set clockrate at fck/128, MSB first */
    /* Max frequency for LSM6DS3 is 10Mhz, we use 156 250Hz */
    // Data is captured on rising edge of clock (CPHA = 0)
    // Base value of the clock is HIGH (CPOL = 1)
    SPCR |= (1<<SPI2X) | (0<<SPR1) | (0<<SPR0);
    22fe:	8c b5       	in	r24, 0x2c	; 44
    2300:	81 60       	ori	r24, 0x01	; 1
    2302:	8c bd       	out	0x2c, r24	; 44
    SPCR |= (1<<SPE) | (1<<MSTR) | (1<<CPOL) | (1<<CPHA);
    2304:	8c b5       	in	r24, 0x2c	; 44
    2306:	8c 65       	ori	r24, 0x5C	; 92
    2308:	8c bd       	out	0x2c, r24	; 44
    SPCR &= ~(1<<DORD); // MSB first
    230a:	8c b5       	in	r24, 0x2c	; 44
    230c:	8f 7d       	andi	r24, 0xDF	; 223
    230e:	8c bd       	out	0x2c, r24	; 44
    2310:	08 95       	ret

00002312 <ui8SPI_MasterTransmit>:
}

uint8_t ui8SPI_MasterTransmit(char cData){
    /* Start transmission */
    SPDR = cData;
    2312:	8e bd       	out	0x2e, r24	; 46
    /* Wait for transmission complete */
    asm volatile("nop");
    2314:	00 00       	nop
    while(!(SPSR & (1<<SPIF)));
    2316:	0d b4       	in	r0, 0x2d	; 45
    2318:	07 fe       	sbrs	r0, 7
    231a:	fd cf       	rjmp	.-6      	; 0x2316 <ui8SPI_MasterTransmit+0x4>
    /* Return anything recieved */
    return SPDR;
    231c:	8e b5       	in	r24, 0x2e	; 46
}
    231e:	08 95       	ret

00002320 <xTaskGenericCreate>:
			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
		}
		taskEXIT_CRITICAL();

		return ulReturn;
	}
    2320:	4f 92       	push	r4
    2322:	5f 92       	push	r5
    2324:	6f 92       	push	r6
    2326:	7f 92       	push	r7
    2328:	8f 92       	push	r8
    232a:	9f 92       	push	r9
    232c:	af 92       	push	r10
    232e:	bf 92       	push	r11
    2330:	cf 92       	push	r12
    2332:	df 92       	push	r13
    2334:	ef 92       	push	r14
    2336:	ff 92       	push	r15
    2338:	0f 93       	push	r16
    233a:	1f 93       	push	r17
    233c:	cf 93       	push	r28
    233e:	df 93       	push	r29
    2340:	3c 01       	movw	r6, r24
    2342:	5b 01       	movw	r10, r22
    2344:	4a 01       	movw	r8, r20
    2346:	29 01       	movw	r4, r18
    2348:	c1 14       	cp	r12, r1
    234a:	d1 04       	cpc	r13, r1
    234c:	39 f4       	brne	.+14     	; 0x235c <xTaskGenericCreate+0x3c>
    234e:	ca 01       	movw	r24, r20
    2350:	0e 94 c9 04 	call	0x992	; 0x992 <pvPortMalloc>
    2354:	6c 01       	movw	r12, r24
    2356:	89 2b       	or	r24, r25
    2358:	09 f4       	brne	.+2      	; 0x235c <xTaskGenericCreate+0x3c>
    235a:	e2 c0       	rjmp	.+452    	; 0x2520 <xTaskGenericCreate+0x200>
    235c:	88 e2       	ldi	r24, 0x28	; 40
    235e:	90 e0       	ldi	r25, 0x00	; 0
    2360:	0e 94 c9 04 	call	0x992	; 0x992 <pvPortMalloc>
    2364:	ec 01       	movw	r28, r24
    2366:	89 2b       	or	r24, r25
    2368:	71 f0       	breq	.+28     	; 0x2386 <xTaskGenericCreate+0x66>
    236a:	d8 8e       	std	Y+24, r13	; 0x18
    236c:	cf 8a       	std	Y+23, r12	; 0x17
    236e:	81 e0       	ldi	r24, 0x01	; 1
    2370:	88 1a       	sub	r8, r24
    2372:	91 08       	sbc	r9, r1
    2374:	c8 0c       	add	r12, r8
    2376:	d9 1c       	adc	r13, r9
    2378:	d5 01       	movw	r26, r10
    237a:	8c 91       	ld	r24, X
    237c:	89 8f       	std	Y+25, r24	; 0x19
    237e:	8c 91       	ld	r24, X
    2380:	81 11       	cpse	r24, r1
    2382:	05 c0       	rjmp	.+10     	; 0x238e <xTaskGenericCreate+0x6e>
    2384:	18 c0       	rjmp	.+48     	; 0x23b6 <xTaskGenericCreate+0x96>
    2386:	c6 01       	movw	r24, r12
    2388:	0e 94 d3 05 	call	0xba6	; 0xba6 <vPortFree>
    238c:	c9 c0       	rjmp	.+402    	; 0x2520 <xTaskGenericCreate+0x200>
    238e:	ae 01       	movw	r20, r28
    2390:	46 5e       	subi	r20, 0xE6	; 230
    2392:	5f 4f       	sbci	r21, 0xFF	; 255
    2394:	f5 01       	movw	r30, r10
    2396:	31 96       	adiw	r30, 0x01	; 1
    2398:	b8 e0       	ldi	r27, 0x08	; 8
    239a:	ab 0e       	add	r10, r27
    239c:	b1 1c       	adc	r11, r1
    239e:	cf 01       	movw	r24, r30
    23a0:	21 91       	ld	r18, Z+
    23a2:	da 01       	movw	r26, r20
    23a4:	2d 93       	st	X+, r18
    23a6:	ad 01       	movw	r20, r26
    23a8:	dc 01       	movw	r26, r24
    23aa:	8c 91       	ld	r24, X
    23ac:	88 23       	and	r24, r24
    23ae:	19 f0       	breq	.+6      	; 0x23b6 <xTaskGenericCreate+0x96>
    23b0:	ae 16       	cp	r10, r30
    23b2:	bf 06       	cpc	r11, r31
    23b4:	a1 f7       	brne	.-24     	; 0x239e <xTaskGenericCreate+0x7e>
    23b6:	18 a2       	std	Y+32, r1	; 0x20
    23b8:	10 2f       	mov	r17, r16
    23ba:	06 30       	cpi	r16, 0x06	; 6
    23bc:	08 f0       	brcs	.+2      	; 0x23c0 <xTaskGenericCreate+0xa0>
    23be:	15 e0       	ldi	r17, 0x05	; 5
    23c0:	1e 8b       	std	Y+22, r17	; 0x16
    23c2:	19 a3       	std	Y+33, r17	; 0x21
    23c4:	1a a2       	std	Y+34, r1	; 0x22
    23c6:	5e 01       	movw	r10, r28
    23c8:	b2 e0       	ldi	r27, 0x02	; 2
    23ca:	ab 0e       	add	r10, r27
    23cc:	b1 1c       	adc	r11, r1
    23ce:	c5 01       	movw	r24, r10
    23d0:	0e 94 34 08 	call	0x1068	; 0x1068 <vListInitialiseItem>
    23d4:	ce 01       	movw	r24, r28
    23d6:	0c 96       	adiw	r24, 0x0c	; 12
    23d8:	0e 94 34 08 	call	0x1068	; 0x1068 <vListInitialiseItem>
    23dc:	d9 87       	std	Y+9, r29	; 0x09
    23de:	c8 87       	std	Y+8, r28	; 0x08
    23e0:	86 e0       	ldi	r24, 0x06	; 6
    23e2:	90 e0       	ldi	r25, 0x00	; 0
    23e4:	81 1b       	sub	r24, r17
    23e6:	91 09       	sbc	r25, r1
    23e8:	9d 87       	std	Y+13, r25	; 0x0d
    23ea:	8c 87       	std	Y+12, r24	; 0x0c
    23ec:	db 8b       	std	Y+19, r29	; 0x13
    23ee:	ca 8b       	std	Y+18, r28	; 0x12
    23f0:	1b a2       	std	Y+35, r1	; 0x23
    23f2:	1c a2       	std	Y+36, r1	; 0x24
    23f4:	1d a2       	std	Y+37, r1	; 0x25
    23f6:	1e a2       	std	Y+38, r1	; 0x26
    23f8:	1f a2       	std	Y+39, r1	; 0x27
    23fa:	a2 01       	movw	r20, r4
    23fc:	b3 01       	movw	r22, r6
    23fe:	c6 01       	movw	r24, r12
    2400:	da d8       	rcall	.-3660   	; 0x15b6 <pxPortInitialiseStack>
    2402:	99 83       	std	Y+1, r25	; 0x01
    2404:	88 83       	st	Y, r24
    2406:	e1 14       	cp	r14, r1
    2408:	f1 04       	cpc	r15, r1
    240a:	19 f0       	breq	.+6      	; 0x2412 <xTaskGenericCreate+0xf2>
    240c:	f7 01       	movw	r30, r14
    240e:	d1 83       	std	Z+1, r29	; 0x01
    2410:	c0 83       	st	Z, r28
    2412:	0f b6       	in	r0, 0x3f	; 63
    2414:	f8 94       	cli
    2416:	0f 92       	push	r0
    2418:	80 91 e5 15 	lds	r24, 0x15E5	; 0x8015e5 <uxCurrentNumberOfTasks>
    241c:	8f 5f       	subi	r24, 0xFF	; 255
    241e:	80 93 e5 15 	sts	0x15E5, r24	; 0x8015e5 <uxCurrentNumberOfTasks>
    2422:	80 91 44 16 	lds	r24, 0x1644	; 0x801644 <pxCurrentTCB>
    2426:	90 91 45 16 	lds	r25, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    242a:	89 2b       	or	r24, r25
    242c:	d9 f5       	brne	.+118    	; 0x24a4 <xTaskGenericCreate+0x184>
    242e:	d0 93 45 16 	sts	0x1645, r29	; 0x801645 <pxCurrentTCB+0x1>
    2432:	c0 93 44 16 	sts	0x1644, r28	; 0x801644 <pxCurrentTCB>
    2436:	80 91 e5 15 	lds	r24, 0x15E5	; 0x8015e5 <uxCurrentNumberOfTasks>
    243a:	81 30       	cpi	r24, 0x01	; 1
    243c:	09 f0       	breq	.+2      	; 0x2440 <xTaskGenericCreate+0x120>
    243e:	41 c0       	rjmp	.+130    	; 0x24c2 <xTaskGenericCreate+0x1a2>
    2440:	0f 2e       	mov	r0, r31
    2442:	fe e0       	ldi	r31, 0x0E	; 14
    2444:	ef 2e       	mov	r14, r31
    2446:	f6 e1       	ldi	r31, 0x16	; 22
    2448:	ff 2e       	mov	r15, r31
    244a:	f0 2d       	mov	r31, r0
    244c:	0f 2e       	mov	r0, r31
    244e:	f4 e4       	ldi	r31, 0x44	; 68
    2450:	cf 2e       	mov	r12, r31
    2452:	f6 e1       	ldi	r31, 0x16	; 22
    2454:	df 2e       	mov	r13, r31
    2456:	f0 2d       	mov	r31, r0
    2458:	c7 01       	movw	r24, r14
    245a:	0e 94 26 08 	call	0x104c	; 0x104c <vListInitialise>
    245e:	f9 e0       	ldi	r31, 0x09	; 9
    2460:	ef 0e       	add	r14, r31
    2462:	f1 1c       	adc	r15, r1
    2464:	ec 14       	cp	r14, r12
    2466:	fd 04       	cpc	r15, r13
    2468:	b9 f7       	brne	.-18     	; 0x2458 <xTaskGenericCreate+0x138>
    246a:	85 e0       	ldi	r24, 0x05	; 5
    246c:	96 e1       	ldi	r25, 0x16	; 22
    246e:	0e 94 26 08 	call	0x104c	; 0x104c <vListInitialise>
    2472:	8c ef       	ldi	r24, 0xFC	; 252
    2474:	95 e1       	ldi	r25, 0x15	; 21
    2476:	0e 94 26 08 	call	0x104c	; 0x104c <vListInitialise>
    247a:	8f ee       	ldi	r24, 0xEF	; 239
    247c:	95 e1       	ldi	r25, 0x15	; 21
    247e:	0e 94 26 08 	call	0x104c	; 0x104c <vListInitialise>
    2482:	86 ee       	ldi	r24, 0xE6	; 230
    2484:	95 e1       	ldi	r25, 0x15	; 21
    2486:	0e 94 26 08 	call	0x104c	; 0x104c <vListInitialise>
    248a:	85 e0       	ldi	r24, 0x05	; 5
    248c:	96 e1       	ldi	r25, 0x16	; 22
    248e:	90 93 fb 15 	sts	0x15FB, r25	; 0x8015fb <pxDelayedTaskList+0x1>
    2492:	80 93 fa 15 	sts	0x15FA, r24	; 0x8015fa <pxDelayedTaskList>
    2496:	8c ef       	ldi	r24, 0xFC	; 252
    2498:	95 e1       	ldi	r25, 0x15	; 21
    249a:	90 93 f9 15 	sts	0x15F9, r25	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    249e:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <pxOverflowDelayedTaskList>
    24a2:	0f c0       	rjmp	.+30     	; 0x24c2 <xTaskGenericCreate+0x1a2>
    24a4:	80 91 e1 15 	lds	r24, 0x15E1	; 0x8015e1 <xSchedulerRunning>
    24a8:	81 11       	cpse	r24, r1
    24aa:	0b c0       	rjmp	.+22     	; 0x24c2 <xTaskGenericCreate+0x1a2>
    24ac:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    24b0:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    24b4:	86 89       	ldd	r24, Z+22	; 0x16
    24b6:	08 17       	cp	r16, r24
    24b8:	20 f0       	brcs	.+8      	; 0x24c2 <xTaskGenericCreate+0x1a2>
    24ba:	d0 93 45 16 	sts	0x1645, r29	; 0x801645 <pxCurrentTCB+0x1>
    24be:	c0 93 44 16 	sts	0x1644, r28	; 0x801644 <pxCurrentTCB>
    24c2:	80 91 dd 15 	lds	r24, 0x15DD	; 0x8015dd <uxTaskNumber>
    24c6:	8f 5f       	subi	r24, 0xFF	; 255
    24c8:	80 93 dd 15 	sts	0x15DD, r24	; 0x8015dd <uxTaskNumber>
    24cc:	8e 89       	ldd	r24, Y+22	; 0x16
    24ce:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    24d2:	98 17       	cp	r25, r24
    24d4:	10 f4       	brcc	.+4      	; 0x24da <xTaskGenericCreate+0x1ba>
    24d6:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    24da:	90 e0       	ldi	r25, 0x00	; 0
    24dc:	9c 01       	movw	r18, r24
    24de:	22 0f       	add	r18, r18
    24e0:	33 1f       	adc	r19, r19
    24e2:	22 0f       	add	r18, r18
    24e4:	33 1f       	adc	r19, r19
    24e6:	22 0f       	add	r18, r18
    24e8:	33 1f       	adc	r19, r19
    24ea:	82 0f       	add	r24, r18
    24ec:	93 1f       	adc	r25, r19
    24ee:	b5 01       	movw	r22, r10
    24f0:	82 5f       	subi	r24, 0xF2	; 242
    24f2:	99 4e       	sbci	r25, 0xE9	; 233
    24f4:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    24f8:	0f 90       	pop	r0
    24fa:	0f be       	out	0x3f, r0	; 63
    24fc:	80 91 e1 15 	lds	r24, 0x15E1	; 0x8015e1 <xSchedulerRunning>
    2500:	88 23       	and	r24, r24
    2502:	51 f0       	breq	.+20     	; 0x2518 <xTaskGenericCreate+0x1f8>
    2504:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    2508:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    250c:	86 89       	ldd	r24, Z+22	; 0x16
    250e:	80 17       	cp	r24, r16
    2510:	28 f4       	brcc	.+10     	; 0x251c <xTaskGenericCreate+0x1fc>
    2512:	c3 d8       	rcall	.-3706   	; 0x169a <vPortYield>
    2514:	81 e0       	ldi	r24, 0x01	; 1
    2516:	05 c0       	rjmp	.+10     	; 0x2522 <xTaskGenericCreate+0x202>
    2518:	81 e0       	ldi	r24, 0x01	; 1
    251a:	03 c0       	rjmp	.+6      	; 0x2522 <xTaskGenericCreate+0x202>
    251c:	81 e0       	ldi	r24, 0x01	; 1
    251e:	01 c0       	rjmp	.+2      	; 0x2522 <xTaskGenericCreate+0x202>
    2520:	8f ef       	ldi	r24, 0xFF	; 255
    2522:	df 91       	pop	r29
    2524:	cf 91       	pop	r28
    2526:	1f 91       	pop	r17
    2528:	0f 91       	pop	r16
    252a:	ff 90       	pop	r15
    252c:	ef 90       	pop	r14
    252e:	df 90       	pop	r13
    2530:	cf 90       	pop	r12
    2532:	bf 90       	pop	r11
    2534:	af 90       	pop	r10
    2536:	9f 90       	pop	r9
    2538:	8f 90       	pop	r8
    253a:	7f 90       	pop	r7
    253c:	6f 90       	pop	r6
    253e:	5f 90       	pop	r5
    2540:	4f 90       	pop	r4
    2542:	08 95       	ret

00002544 <vTaskDelay>:
    2544:	9f 92       	push	r9
    2546:	af 92       	push	r10
    2548:	bf 92       	push	r11
    254a:	cf 92       	push	r12
    254c:	df 92       	push	r13
    254e:	ef 92       	push	r14
    2550:	ff 92       	push	r15
    2552:	0f 93       	push	r16
    2554:	1f 93       	push	r17
    2556:	cf 93       	push	r28
    2558:	df 93       	push	r29
    255a:	00 97       	sbiw	r24, 0x00	; 0
    255c:	09 f4       	brne	.+2      	; 0x2560 <vTaskDelay+0x1c>
    255e:	63 c1       	rjmp	.+710    	; 0x2826 <vTaskDelay+0x2e2>
    2560:	20 91 da 15 	lds	r18, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    2564:	2f 5f       	subi	r18, 0xFF	; 255
    2566:	20 93 da 15 	sts	0x15DA, r18	; 0x8015da <uxSchedulerSuspended>
    256a:	c0 91 e3 15 	lds	r28, 0x15E3	; 0x8015e3 <xTickCount>
    256e:	d0 91 e4 15 	lds	r29, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2572:	c8 0f       	add	r28, r24
    2574:	d9 1f       	adc	r29, r25
    2576:	80 91 44 16 	lds	r24, 0x1644	; 0x801644 <pxCurrentTCB>
    257a:	90 91 45 16 	lds	r25, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    257e:	02 96       	adiw	r24, 0x02	; 2
    2580:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2584:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    2588:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    258c:	d3 83       	std	Z+3, r29	; 0x03
    258e:	c2 83       	std	Z+2, r28	; 0x02
    2590:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    2594:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2598:	c8 17       	cp	r28, r24
    259a:	d9 07       	cpc	r29, r25
    259c:	68 f4       	brcc	.+26     	; 0x25b8 <vTaskDelay+0x74>
    259e:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    25a2:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    25a6:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <pxOverflowDelayedTaskList>
    25aa:	90 91 f9 15 	lds	r25, 0x15F9	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    25ae:	6e 5f       	subi	r22, 0xFE	; 254
    25b0:	7f 4f       	sbci	r23, 0xFF	; 255
    25b2:	0e 94 59 08 	call	0x10b2	; 0x10b2 <vListInsert>
    25b6:	17 c0       	rjmp	.+46     	; 0x25e6 <vTaskDelay+0xa2>
    25b8:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    25bc:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    25c0:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    25c4:	90 91 fb 15 	lds	r25, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    25c8:	6e 5f       	subi	r22, 0xFE	; 254
    25ca:	7f 4f       	sbci	r23, 0xFF	; 255
    25cc:	0e 94 59 08 	call	0x10b2	; 0x10b2 <vListInsert>
    25d0:	80 91 db 15 	lds	r24, 0x15DB	; 0x8015db <xNextTaskUnblockTime>
    25d4:	90 91 dc 15 	lds	r25, 0x15DC	; 0x8015dc <xNextTaskUnblockTime+0x1>
    25d8:	c8 17       	cp	r28, r24
    25da:	d9 07       	cpc	r29, r25
    25dc:	20 f4       	brcc	.+8      	; 0x25e6 <vTaskDelay+0xa2>
    25de:	d0 93 dc 15 	sts	0x15DC, r29	; 0x8015dc <xNextTaskUnblockTime+0x1>
    25e2:	c0 93 db 15 	sts	0x15DB, r28	; 0x8015db <xNextTaskUnblockTime>
    25e6:	0f b6       	in	r0, 0x3f	; 63
    25e8:	f8 94       	cli
    25ea:	0f 92       	push	r0
    25ec:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    25f0:	81 50       	subi	r24, 0x01	; 1
    25f2:	80 93 da 15 	sts	0x15DA, r24	; 0x8015da <uxSchedulerSuspended>
    25f6:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    25fa:	81 11       	cpse	r24, r1
    25fc:	0d c1       	rjmp	.+538    	; 0x2818 <vTaskDelay+0x2d4>
    25fe:	80 91 e5 15 	lds	r24, 0x15E5	; 0x8015e5 <uxCurrentNumberOfTasks>
    2602:	81 11       	cpse	r24, r1
    2604:	33 c0       	rjmp	.+102    	; 0x266c <vTaskDelay+0x128>
    2606:	0b c1       	rjmp	.+534    	; 0x281e <vTaskDelay+0x2da>
    2608:	d7 01       	movw	r26, r14
    260a:	15 96       	adiw	r26, 0x05	; 5
    260c:	ed 91       	ld	r30, X+
    260e:	fc 91       	ld	r31, X
    2610:	16 97       	sbiw	r26, 0x06	; 6
    2612:	c6 81       	ldd	r28, Z+6	; 0x06
    2614:	d7 81       	ldd	r29, Z+7	; 0x07
    2616:	ce 01       	movw	r24, r28
    2618:	0c 96       	adiw	r24, 0x0c	; 12
    261a:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    261e:	8e 01       	movw	r16, r28
    2620:	0e 5f       	subi	r16, 0xFE	; 254
    2622:	1f 4f       	sbci	r17, 0xFF	; 255
    2624:	c8 01       	movw	r24, r16
    2626:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    262a:	8e 89       	ldd	r24, Y+22	; 0x16
    262c:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2630:	98 17       	cp	r25, r24
    2632:	10 f4       	brcc	.+4      	; 0x2638 <vTaskDelay+0xf4>
    2634:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    2638:	90 e0       	ldi	r25, 0x00	; 0
    263a:	9c 01       	movw	r18, r24
    263c:	22 0f       	add	r18, r18
    263e:	33 1f       	adc	r19, r19
    2640:	22 0f       	add	r18, r18
    2642:	33 1f       	adc	r19, r19
    2644:	22 0f       	add	r18, r18
    2646:	33 1f       	adc	r19, r19
    2648:	82 0f       	add	r24, r18
    264a:	93 1f       	adc	r25, r19
    264c:	b8 01       	movw	r22, r16
    264e:	82 5f       	subi	r24, 0xF2	; 242
    2650:	99 4e       	sbci	r25, 0xE9	; 233
    2652:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    2656:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    265a:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    265e:	9e 89       	ldd	r25, Y+22	; 0x16
    2660:	86 89       	ldd	r24, Z+22	; 0x16
    2662:	98 17       	cp	r25, r24
    2664:	58 f0       	brcs	.+22     	; 0x267c <vTaskDelay+0x138>
    2666:	d0 92 df 15 	sts	0x15DF, r13	; 0x8015df <xYieldPending>
    266a:	08 c0       	rjmp	.+16     	; 0x267c <vTaskDelay+0x138>
    266c:	0f 2e       	mov	r0, r31
    266e:	ff ee       	ldi	r31, 0xEF	; 239
    2670:	ef 2e       	mov	r14, r31
    2672:	f5 e1       	ldi	r31, 0x15	; 21
    2674:	ff 2e       	mov	r15, r31
    2676:	f0 2d       	mov	r31, r0
    2678:	dd 24       	eor	r13, r13
    267a:	d3 94       	inc	r13
    267c:	f7 01       	movw	r30, r14
    267e:	80 81       	ld	r24, Z
    2680:	81 11       	cpse	r24, r1
    2682:	c2 cf       	rjmp	.-124    	; 0x2608 <vTaskDelay+0xc4>
    2684:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    2688:	88 23       	and	r24, r24
    268a:	09 f4       	brne	.+2      	; 0x268e <vTaskDelay+0x14a>
    268c:	bd c0       	rjmp	.+378    	; 0x2808 <vTaskDelay+0x2c4>
    268e:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    2692:	88 23       	and	r24, r24
    2694:	09 f4       	brne	.+2      	; 0x2698 <vTaskDelay+0x154>
    2696:	b8 c0       	rjmp	.+368    	; 0x2808 <vTaskDelay+0x2c4>
    2698:	91 2c       	mov	r9, r1
    269a:	bb 24       	eor	r11, r11
    269c:	b3 94       	inc	r11
    269e:	cc 24       	eor	r12, r12
    26a0:	ca 94       	dec	r12
    26a2:	dc 2c       	mov	r13, r12
    26a4:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    26a8:	81 11       	cpse	r24, r1
    26aa:	98 c0       	rjmp	.+304    	; 0x27dc <vTaskDelay+0x298>
    26ac:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    26b0:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    26b4:	01 96       	adiw	r24, 0x01	; 1
    26b6:	90 93 e4 15 	sts	0x15E4, r25	; 0x8015e4 <xTickCount+0x1>
    26ba:	80 93 e3 15 	sts	0x15E3, r24	; 0x8015e3 <xTickCount>
    26be:	e0 90 e3 15 	lds	r14, 0x15E3	; 0x8015e3 <xTickCount>
    26c2:	f0 90 e4 15 	lds	r15, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    26c6:	e1 14       	cp	r14, r1
    26c8:	f1 04       	cpc	r15, r1
    26ca:	89 f5       	brne	.+98     	; 0x272e <vTaskDelay+0x1ea>
    26cc:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    26d0:	90 91 fb 15 	lds	r25, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    26d4:	20 91 f8 15 	lds	r18, 0x15F8	; 0x8015f8 <pxOverflowDelayedTaskList>
    26d8:	30 91 f9 15 	lds	r19, 0x15F9	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    26dc:	30 93 fb 15 	sts	0x15FB, r19	; 0x8015fb <pxDelayedTaskList+0x1>
    26e0:	20 93 fa 15 	sts	0x15FA, r18	; 0x8015fa <pxDelayedTaskList>
    26e4:	90 93 f9 15 	sts	0x15F9, r25	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    26e8:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <pxOverflowDelayedTaskList>
    26ec:	80 91 de 15 	lds	r24, 0x15DE	; 0x8015de <xNumOfOverflows>
    26f0:	8f 5f       	subi	r24, 0xFF	; 255
    26f2:	80 93 de 15 	sts	0x15DE, r24	; 0x8015de <xNumOfOverflows>
    26f6:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    26fa:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    26fe:	80 81       	ld	r24, Z
    2700:	81 11       	cpse	r24, r1
    2702:	05 c0       	rjmp	.+10     	; 0x270e <vTaskDelay+0x1ca>
    2704:	d0 92 dc 15 	sts	0x15DC, r13	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2708:	c0 92 db 15 	sts	0x15DB, r12	; 0x8015db <xNextTaskUnblockTime>
    270c:	10 c0       	rjmp	.+32     	; 0x272e <vTaskDelay+0x1ea>
    270e:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2712:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2716:	05 80       	ldd	r0, Z+5	; 0x05
    2718:	f6 81       	ldd	r31, Z+6	; 0x06
    271a:	e0 2d       	mov	r30, r0
    271c:	06 80       	ldd	r0, Z+6	; 0x06
    271e:	f7 81       	ldd	r31, Z+7	; 0x07
    2720:	e0 2d       	mov	r30, r0
    2722:	82 81       	ldd	r24, Z+2	; 0x02
    2724:	93 81       	ldd	r25, Z+3	; 0x03
    2726:	90 93 dc 15 	sts	0x15DC, r25	; 0x8015dc <xNextTaskUnblockTime+0x1>
    272a:	80 93 db 15 	sts	0x15DB, r24	; 0x8015db <xNextTaskUnblockTime>
    272e:	80 91 db 15 	lds	r24, 0x15DB	; 0x8015db <xNextTaskUnblockTime>
    2732:	90 91 dc 15 	lds	r25, 0x15DC	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2736:	e8 16       	cp	r14, r24
    2738:	f9 06       	cpc	r15, r25
    273a:	08 f4       	brcc	.+2      	; 0x273e <vTaskDelay+0x1fa>
    273c:	77 c0       	rjmp	.+238    	; 0x282c <vTaskDelay+0x2e8>
    273e:	a9 2c       	mov	r10, r9
    2740:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2744:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2748:	80 81       	ld	r24, Z
    274a:	81 11       	cpse	r24, r1
    274c:	05 c0       	rjmp	.+10     	; 0x2758 <vTaskDelay+0x214>
    274e:	d0 92 dc 15 	sts	0x15DC, r13	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2752:	c0 92 db 15 	sts	0x15DB, r12	; 0x8015db <xNextTaskUnblockTime>
    2756:	48 c0       	rjmp	.+144    	; 0x27e8 <vTaskDelay+0x2a4>
    2758:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    275c:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2760:	05 80       	ldd	r0, Z+5	; 0x05
    2762:	f6 81       	ldd	r31, Z+6	; 0x06
    2764:	e0 2d       	mov	r30, r0
    2766:	c6 81       	ldd	r28, Z+6	; 0x06
    2768:	d7 81       	ldd	r29, Z+7	; 0x07
    276a:	8a 81       	ldd	r24, Y+2	; 0x02
    276c:	9b 81       	ldd	r25, Y+3	; 0x03
    276e:	e8 16       	cp	r14, r24
    2770:	f9 06       	cpc	r15, r25
    2772:	28 f4       	brcc	.+10     	; 0x277e <vTaskDelay+0x23a>
    2774:	90 93 dc 15 	sts	0x15DC, r25	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2778:	80 93 db 15 	sts	0x15DB, r24	; 0x8015db <xNextTaskUnblockTime>
    277c:	35 c0       	rjmp	.+106    	; 0x27e8 <vTaskDelay+0x2a4>
    277e:	8e 01       	movw	r16, r28
    2780:	0e 5f       	subi	r16, 0xFE	; 254
    2782:	1f 4f       	sbci	r17, 0xFF	; 255
    2784:	c8 01       	movw	r24, r16
    2786:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    278a:	8c 89       	ldd	r24, Y+20	; 0x14
    278c:	9d 89       	ldd	r25, Y+21	; 0x15
    278e:	89 2b       	or	r24, r25
    2790:	21 f0       	breq	.+8      	; 0x279a <vTaskDelay+0x256>
    2792:	ce 01       	movw	r24, r28
    2794:	0c 96       	adiw	r24, 0x0c	; 12
    2796:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    279a:	8e 89       	ldd	r24, Y+22	; 0x16
    279c:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    27a0:	98 17       	cp	r25, r24
    27a2:	10 f4       	brcc	.+4      	; 0x27a8 <vTaskDelay+0x264>
    27a4:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    27a8:	90 e0       	ldi	r25, 0x00	; 0
    27aa:	9c 01       	movw	r18, r24
    27ac:	22 0f       	add	r18, r18
    27ae:	33 1f       	adc	r19, r19
    27b0:	22 0f       	add	r18, r18
    27b2:	33 1f       	adc	r19, r19
    27b4:	22 0f       	add	r18, r18
    27b6:	33 1f       	adc	r19, r19
    27b8:	82 0f       	add	r24, r18
    27ba:	93 1f       	adc	r25, r19
    27bc:	b8 01       	movw	r22, r16
    27be:	82 5f       	subi	r24, 0xF2	; 242
    27c0:	99 4e       	sbci	r25, 0xE9	; 233
    27c2:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    27c6:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    27ca:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    27ce:	9e 89       	ldd	r25, Y+22	; 0x16
    27d0:	86 89       	ldd	r24, Z+22	; 0x16
    27d2:	98 17       	cp	r25, r24
    27d4:	08 f4       	brcc	.+2      	; 0x27d8 <vTaskDelay+0x294>
    27d6:	b4 cf       	rjmp	.-152    	; 0x2740 <vTaskDelay+0x1fc>
    27d8:	ab 2c       	mov	r10, r11
    27da:	b2 cf       	rjmp	.-156    	; 0x2740 <vTaskDelay+0x1fc>
    27dc:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    27e0:	8f 5f       	subi	r24, 0xFF	; 255
    27e2:	80 93 e0 15 	sts	0x15E0, r24	; 0x8015e0 <uxPendedTicks>
    27e6:	22 c0       	rjmp	.+68     	; 0x282c <vTaskDelay+0x2e8>
    27e8:	80 91 df 15 	lds	r24, 0x15DF	; 0x8015df <xYieldPending>
    27ec:	81 11       	cpse	r24, r1
    27ee:	01 c0       	rjmp	.+2      	; 0x27f2 <vTaskDelay+0x2ae>
    27f0:	a1 10       	cpse	r10, r1
    27f2:	b0 92 df 15 	sts	0x15DF, r11	; 0x8015df <xYieldPending>
    27f6:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    27fa:	81 50       	subi	r24, 0x01	; 1
    27fc:	80 93 e0 15 	sts	0x15E0, r24	; 0x8015e0 <uxPendedTicks>
    2800:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    2804:	81 11       	cpse	r24, r1
    2806:	4e cf       	rjmp	.-356    	; 0x26a4 <vTaskDelay+0x160>
    2808:	80 91 df 15 	lds	r24, 0x15DF	; 0x8015df <xYieldPending>
    280c:	81 30       	cpi	r24, 0x01	; 1
    280e:	31 f4       	brne	.+12     	; 0x281c <vTaskDelay+0x2d8>
    2810:	0e 94 4d 0b 	call	0x169a	; 0x169a <vPortYield>
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	03 c0       	rjmp	.+6      	; 0x281e <vTaskDelay+0x2da>
    2818:	80 e0       	ldi	r24, 0x00	; 0
    281a:	01 c0       	rjmp	.+2      	; 0x281e <vTaskDelay+0x2da>
    281c:	80 e0       	ldi	r24, 0x00	; 0
    281e:	0f 90       	pop	r0
    2820:	0f be       	out	0x3f, r0	; 63
    2822:	81 11       	cpse	r24, r1
    2824:	08 c0       	rjmp	.+16     	; 0x2836 <vTaskDelay+0x2f2>
    2826:	0e 94 4d 0b 	call	0x169a	; 0x169a <vPortYield>
    282a:	05 c0       	rjmp	.+10     	; 0x2836 <vTaskDelay+0x2f2>
    282c:	80 91 df 15 	lds	r24, 0x15DF	; 0x8015df <xYieldPending>
    2830:	81 11       	cpse	r24, r1
    2832:	df cf       	rjmp	.-66     	; 0x27f2 <vTaskDelay+0x2ae>
    2834:	e0 cf       	rjmp	.-64     	; 0x27f6 <vTaskDelay+0x2b2>
    2836:	df 91       	pop	r29
    2838:	cf 91       	pop	r28
    283a:	1f 91       	pop	r17
    283c:	0f 91       	pop	r16
    283e:	ff 90       	pop	r15
    2840:	ef 90       	pop	r14
    2842:	df 90       	pop	r13
    2844:	cf 90       	pop	r12
    2846:	bf 90       	pop	r11
    2848:	af 90       	pop	r10
    284a:	9f 90       	pop	r9
    284c:	08 95       	ret

0000284e <vTaskSuspendAll>:
    284e:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    2852:	8f 5f       	subi	r24, 0xFF	; 255
    2854:	80 93 da 15 	sts	0x15DA, r24	; 0x8015da <uxSchedulerSuspended>
    2858:	08 95       	ret

0000285a <xTaskResumeAll>:
    285a:	9f 92       	push	r9
    285c:	af 92       	push	r10
    285e:	bf 92       	push	r11
    2860:	cf 92       	push	r12
    2862:	df 92       	push	r13
    2864:	ef 92       	push	r14
    2866:	ff 92       	push	r15
    2868:	0f 93       	push	r16
    286a:	1f 93       	push	r17
    286c:	cf 93       	push	r28
    286e:	df 93       	push	r29
    2870:	0f b6       	in	r0, 0x3f	; 63
    2872:	f8 94       	cli
    2874:	0f 92       	push	r0
    2876:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    287a:	81 50       	subi	r24, 0x01	; 1
    287c:	80 93 da 15 	sts	0x15DA, r24	; 0x8015da <uxSchedulerSuspended>
    2880:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    2884:	81 11       	cpse	r24, r1
    2886:	0d c1       	rjmp	.+538    	; 0x2aa2 <xTaskResumeAll+0x248>
    2888:	80 91 e5 15 	lds	r24, 0x15E5	; 0x8015e5 <uxCurrentNumberOfTasks>
    288c:	81 11       	cpse	r24, r1
    288e:	33 c0       	rjmp	.+102    	; 0x28f6 <xTaskResumeAll+0x9c>
    2890:	0b c1       	rjmp	.+534    	; 0x2aa8 <xTaskResumeAll+0x24e>
    2892:	d7 01       	movw	r26, r14
    2894:	15 96       	adiw	r26, 0x05	; 5
    2896:	ed 91       	ld	r30, X+
    2898:	fc 91       	ld	r31, X
    289a:	16 97       	sbiw	r26, 0x06	; 6
    289c:	c6 81       	ldd	r28, Z+6	; 0x06
    289e:	d7 81       	ldd	r29, Z+7	; 0x07
    28a0:	ce 01       	movw	r24, r28
    28a2:	0c 96       	adiw	r24, 0x0c	; 12
    28a4:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    28a8:	8e 01       	movw	r16, r28
    28aa:	0e 5f       	subi	r16, 0xFE	; 254
    28ac:	1f 4f       	sbci	r17, 0xFF	; 255
    28ae:	c8 01       	movw	r24, r16
    28b0:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    28b4:	8e 89       	ldd	r24, Y+22	; 0x16
    28b6:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    28ba:	98 17       	cp	r25, r24
    28bc:	10 f4       	brcc	.+4      	; 0x28c2 <xTaskResumeAll+0x68>
    28be:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    28c2:	90 e0       	ldi	r25, 0x00	; 0
    28c4:	9c 01       	movw	r18, r24
    28c6:	22 0f       	add	r18, r18
    28c8:	33 1f       	adc	r19, r19
    28ca:	22 0f       	add	r18, r18
    28cc:	33 1f       	adc	r19, r19
    28ce:	22 0f       	add	r18, r18
    28d0:	33 1f       	adc	r19, r19
    28d2:	82 0f       	add	r24, r18
    28d4:	93 1f       	adc	r25, r19
    28d6:	b8 01       	movw	r22, r16
    28d8:	82 5f       	subi	r24, 0xF2	; 242
    28da:	99 4e       	sbci	r25, 0xE9	; 233
    28dc:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    28e0:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    28e4:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    28e8:	9e 89       	ldd	r25, Y+22	; 0x16
    28ea:	86 89       	ldd	r24, Z+22	; 0x16
    28ec:	98 17       	cp	r25, r24
    28ee:	58 f0       	brcs	.+22     	; 0x2906 <xTaskResumeAll+0xac>
    28f0:	d0 92 df 15 	sts	0x15DF, r13	; 0x8015df <xYieldPending>
    28f4:	08 c0       	rjmp	.+16     	; 0x2906 <xTaskResumeAll+0xac>
    28f6:	0f 2e       	mov	r0, r31
    28f8:	ff ee       	ldi	r31, 0xEF	; 239
    28fa:	ef 2e       	mov	r14, r31
    28fc:	f5 e1       	ldi	r31, 0x15	; 21
    28fe:	ff 2e       	mov	r15, r31
    2900:	f0 2d       	mov	r31, r0
    2902:	dd 24       	eor	r13, r13
    2904:	d3 94       	inc	r13
    2906:	f7 01       	movw	r30, r14
    2908:	80 81       	ld	r24, Z
    290a:	81 11       	cpse	r24, r1
    290c:	c2 cf       	rjmp	.-124    	; 0x2892 <xTaskResumeAll+0x38>
    290e:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    2912:	88 23       	and	r24, r24
    2914:	09 f4       	brne	.+2      	; 0x2918 <xTaskResumeAll+0xbe>
    2916:	bd c0       	rjmp	.+378    	; 0x2a92 <xTaskResumeAll+0x238>
    2918:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    291c:	88 23       	and	r24, r24
    291e:	09 f4       	brne	.+2      	; 0x2922 <xTaskResumeAll+0xc8>
    2920:	b8 c0       	rjmp	.+368    	; 0x2a92 <xTaskResumeAll+0x238>
    2922:	91 2c       	mov	r9, r1
    2924:	bb 24       	eor	r11, r11
    2926:	b3 94       	inc	r11
    2928:	cc 24       	eor	r12, r12
    292a:	ca 94       	dec	r12
    292c:	dc 2c       	mov	r13, r12
    292e:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    2932:	81 11       	cpse	r24, r1
    2934:	98 c0       	rjmp	.+304    	; 0x2a66 <xTaskResumeAll+0x20c>
    2936:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    293a:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    293e:	01 96       	adiw	r24, 0x01	; 1
    2940:	90 93 e4 15 	sts	0x15E4, r25	; 0x8015e4 <xTickCount+0x1>
    2944:	80 93 e3 15 	sts	0x15E3, r24	; 0x8015e3 <xTickCount>
    2948:	e0 90 e3 15 	lds	r14, 0x15E3	; 0x8015e3 <xTickCount>
    294c:	f0 90 e4 15 	lds	r15, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2950:	e1 14       	cp	r14, r1
    2952:	f1 04       	cpc	r15, r1
    2954:	89 f5       	brne	.+98     	; 0x29b8 <xTaskResumeAll+0x15e>
    2956:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    295a:	90 91 fb 15 	lds	r25, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    295e:	20 91 f8 15 	lds	r18, 0x15F8	; 0x8015f8 <pxOverflowDelayedTaskList>
    2962:	30 91 f9 15 	lds	r19, 0x15F9	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    2966:	30 93 fb 15 	sts	0x15FB, r19	; 0x8015fb <pxDelayedTaskList+0x1>
    296a:	20 93 fa 15 	sts	0x15FA, r18	; 0x8015fa <pxDelayedTaskList>
    296e:	90 93 f9 15 	sts	0x15F9, r25	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    2972:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <pxOverflowDelayedTaskList>
    2976:	80 91 de 15 	lds	r24, 0x15DE	; 0x8015de <xNumOfOverflows>
    297a:	8f 5f       	subi	r24, 0xFF	; 255
    297c:	80 93 de 15 	sts	0x15DE, r24	; 0x8015de <xNumOfOverflows>
    2980:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2984:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2988:	80 81       	ld	r24, Z
    298a:	81 11       	cpse	r24, r1
    298c:	05 c0       	rjmp	.+10     	; 0x2998 <xTaskResumeAll+0x13e>
    298e:	d0 92 dc 15 	sts	0x15DC, r13	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2992:	c0 92 db 15 	sts	0x15DB, r12	; 0x8015db <xNextTaskUnblockTime>
    2996:	10 c0       	rjmp	.+32     	; 0x29b8 <xTaskResumeAll+0x15e>
    2998:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    299c:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    29a0:	05 80       	ldd	r0, Z+5	; 0x05
    29a2:	f6 81       	ldd	r31, Z+6	; 0x06
    29a4:	e0 2d       	mov	r30, r0
    29a6:	06 80       	ldd	r0, Z+6	; 0x06
    29a8:	f7 81       	ldd	r31, Z+7	; 0x07
    29aa:	e0 2d       	mov	r30, r0
    29ac:	82 81       	ldd	r24, Z+2	; 0x02
    29ae:	93 81       	ldd	r25, Z+3	; 0x03
    29b0:	90 93 dc 15 	sts	0x15DC, r25	; 0x8015dc <xNextTaskUnblockTime+0x1>
    29b4:	80 93 db 15 	sts	0x15DB, r24	; 0x8015db <xNextTaskUnblockTime>
    29b8:	80 91 db 15 	lds	r24, 0x15DB	; 0x8015db <xNextTaskUnblockTime>
    29bc:	90 91 dc 15 	lds	r25, 0x15DC	; 0x8015dc <xNextTaskUnblockTime+0x1>
    29c0:	e8 16       	cp	r14, r24
    29c2:	f9 06       	cpc	r15, r25
    29c4:	08 f4       	brcc	.+2      	; 0x29c8 <xTaskResumeAll+0x16e>
    29c6:	73 c0       	rjmp	.+230    	; 0x2aae <xTaskResumeAll+0x254>
    29c8:	a9 2c       	mov	r10, r9
    29ca:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    29ce:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    29d2:	80 81       	ld	r24, Z
    29d4:	81 11       	cpse	r24, r1
    29d6:	05 c0       	rjmp	.+10     	; 0x29e2 <xTaskResumeAll+0x188>
    29d8:	d0 92 dc 15 	sts	0x15DC, r13	; 0x8015dc <xNextTaskUnblockTime+0x1>
    29dc:	c0 92 db 15 	sts	0x15DB, r12	; 0x8015db <xNextTaskUnblockTime>
    29e0:	48 c0       	rjmp	.+144    	; 0x2a72 <xTaskResumeAll+0x218>
    29e2:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    29e6:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    29ea:	05 80       	ldd	r0, Z+5	; 0x05
    29ec:	f6 81       	ldd	r31, Z+6	; 0x06
    29ee:	e0 2d       	mov	r30, r0
    29f0:	c6 81       	ldd	r28, Z+6	; 0x06
    29f2:	d7 81       	ldd	r29, Z+7	; 0x07
    29f4:	8a 81       	ldd	r24, Y+2	; 0x02
    29f6:	9b 81       	ldd	r25, Y+3	; 0x03
    29f8:	e8 16       	cp	r14, r24
    29fa:	f9 06       	cpc	r15, r25
    29fc:	28 f4       	brcc	.+10     	; 0x2a08 <xTaskResumeAll+0x1ae>
    29fe:	90 93 dc 15 	sts	0x15DC, r25	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2a02:	80 93 db 15 	sts	0x15DB, r24	; 0x8015db <xNextTaskUnblockTime>
    2a06:	35 c0       	rjmp	.+106    	; 0x2a72 <xTaskResumeAll+0x218>
    2a08:	8e 01       	movw	r16, r28
    2a0a:	0e 5f       	subi	r16, 0xFE	; 254
    2a0c:	1f 4f       	sbci	r17, 0xFF	; 255
    2a0e:	c8 01       	movw	r24, r16
    2a10:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2a14:	8c 89       	ldd	r24, Y+20	; 0x14
    2a16:	9d 89       	ldd	r25, Y+21	; 0x15
    2a18:	89 2b       	or	r24, r25
    2a1a:	21 f0       	breq	.+8      	; 0x2a24 <xTaskResumeAll+0x1ca>
    2a1c:	ce 01       	movw	r24, r28
    2a1e:	0c 96       	adiw	r24, 0x0c	; 12
    2a20:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2a24:	8e 89       	ldd	r24, Y+22	; 0x16
    2a26:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2a2a:	98 17       	cp	r25, r24
    2a2c:	10 f4       	brcc	.+4      	; 0x2a32 <xTaskResumeAll+0x1d8>
    2a2e:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    2a32:	90 e0       	ldi	r25, 0x00	; 0
    2a34:	9c 01       	movw	r18, r24
    2a36:	22 0f       	add	r18, r18
    2a38:	33 1f       	adc	r19, r19
    2a3a:	22 0f       	add	r18, r18
    2a3c:	33 1f       	adc	r19, r19
    2a3e:	22 0f       	add	r18, r18
    2a40:	33 1f       	adc	r19, r19
    2a42:	82 0f       	add	r24, r18
    2a44:	93 1f       	adc	r25, r19
    2a46:	b8 01       	movw	r22, r16
    2a48:	82 5f       	subi	r24, 0xF2	; 242
    2a4a:	99 4e       	sbci	r25, 0xE9	; 233
    2a4c:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    2a50:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    2a54:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2a58:	9e 89       	ldd	r25, Y+22	; 0x16
    2a5a:	86 89       	ldd	r24, Z+22	; 0x16
    2a5c:	98 17       	cp	r25, r24
    2a5e:	08 f4       	brcc	.+2      	; 0x2a62 <xTaskResumeAll+0x208>
    2a60:	b4 cf       	rjmp	.-152    	; 0x29ca <xTaskResumeAll+0x170>
    2a62:	ab 2c       	mov	r10, r11
    2a64:	b2 cf       	rjmp	.-156    	; 0x29ca <xTaskResumeAll+0x170>
    2a66:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    2a6a:	8f 5f       	subi	r24, 0xFF	; 255
    2a6c:	80 93 e0 15 	sts	0x15E0, r24	; 0x8015e0 <uxPendedTicks>
    2a70:	1e c0       	rjmp	.+60     	; 0x2aae <xTaskResumeAll+0x254>
    2a72:	80 91 df 15 	lds	r24, 0x15DF	; 0x8015df <xYieldPending>
    2a76:	81 11       	cpse	r24, r1
    2a78:	01 c0       	rjmp	.+2      	; 0x2a7c <xTaskResumeAll+0x222>
    2a7a:	a1 10       	cpse	r10, r1
    2a7c:	b0 92 df 15 	sts	0x15DF, r11	; 0x8015df <xYieldPending>
    2a80:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    2a84:	81 50       	subi	r24, 0x01	; 1
    2a86:	80 93 e0 15 	sts	0x15E0, r24	; 0x8015e0 <uxPendedTicks>
    2a8a:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    2a8e:	81 11       	cpse	r24, r1
    2a90:	4e cf       	rjmp	.-356    	; 0x292e <xTaskResumeAll+0xd4>
    2a92:	80 91 df 15 	lds	r24, 0x15DF	; 0x8015df <xYieldPending>
    2a96:	81 30       	cpi	r24, 0x01	; 1
    2a98:	31 f4       	brne	.+12     	; 0x2aa6 <xTaskResumeAll+0x24c>
    2a9a:	0e 94 4d 0b 	call	0x169a	; 0x169a <vPortYield>
    2a9e:	81 e0       	ldi	r24, 0x01	; 1
    2aa0:	03 c0       	rjmp	.+6      	; 0x2aa8 <xTaskResumeAll+0x24e>
    2aa2:	80 e0       	ldi	r24, 0x00	; 0
    2aa4:	01 c0       	rjmp	.+2      	; 0x2aa8 <xTaskResumeAll+0x24e>
    2aa6:	80 e0       	ldi	r24, 0x00	; 0
    2aa8:	0f 90       	pop	r0
    2aaa:	0f be       	out	0x3f, r0	; 63
    2aac:	05 c0       	rjmp	.+10     	; 0x2ab8 <xTaskResumeAll+0x25e>
    2aae:	80 91 df 15 	lds	r24, 0x15DF	; 0x8015df <xYieldPending>
    2ab2:	81 11       	cpse	r24, r1
    2ab4:	e3 cf       	rjmp	.-58     	; 0x2a7c <xTaskResumeAll+0x222>
    2ab6:	e4 cf       	rjmp	.-56     	; 0x2a80 <xTaskResumeAll+0x226>
    2ab8:	df 91       	pop	r29
    2aba:	cf 91       	pop	r28
    2abc:	1f 91       	pop	r17
    2abe:	0f 91       	pop	r16
    2ac0:	ff 90       	pop	r15
    2ac2:	ef 90       	pop	r14
    2ac4:	df 90       	pop	r13
    2ac6:	cf 90       	pop	r12
    2ac8:	bf 90       	pop	r11
    2aca:	af 90       	pop	r10
    2acc:	9f 90       	pop	r9
    2ace:	08 95       	ret

00002ad0 <xTaskIncrementTick>:
    2ad0:	cf 92       	push	r12
    2ad2:	df 92       	push	r13
    2ad4:	ef 92       	push	r14
    2ad6:	ff 92       	push	r15
    2ad8:	0f 93       	push	r16
    2ada:	1f 93       	push	r17
    2adc:	cf 93       	push	r28
    2ade:	df 93       	push	r29
    2ae0:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    2ae4:	81 11       	cpse	r24, r1
    2ae6:	9f c0       	rjmp	.+318    	; 0x2c26 <xTaskIncrementTick+0x156>
    2ae8:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    2aec:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2af0:	01 96       	adiw	r24, 0x01	; 1
    2af2:	90 93 e4 15 	sts	0x15E4, r25	; 0x8015e4 <xTickCount+0x1>
    2af6:	80 93 e3 15 	sts	0x15E3, r24	; 0x8015e3 <xTickCount>
    2afa:	e0 90 e3 15 	lds	r14, 0x15E3	; 0x8015e3 <xTickCount>
    2afe:	f0 90 e4 15 	lds	r15, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2b02:	e1 14       	cp	r14, r1
    2b04:	f1 04       	cpc	r15, r1
    2b06:	99 f5       	brne	.+102    	; 0x2b6e <xTaskIncrementTick+0x9e>
    2b08:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2b0c:	90 91 fb 15 	lds	r25, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2b10:	20 91 f8 15 	lds	r18, 0x15F8	; 0x8015f8 <pxOverflowDelayedTaskList>
    2b14:	30 91 f9 15 	lds	r19, 0x15F9	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    2b18:	30 93 fb 15 	sts	0x15FB, r19	; 0x8015fb <pxDelayedTaskList+0x1>
    2b1c:	20 93 fa 15 	sts	0x15FA, r18	; 0x8015fa <pxDelayedTaskList>
    2b20:	90 93 f9 15 	sts	0x15F9, r25	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    2b24:	80 93 f8 15 	sts	0x15F8, r24	; 0x8015f8 <pxOverflowDelayedTaskList>
    2b28:	80 91 de 15 	lds	r24, 0x15DE	; 0x8015de <xNumOfOverflows>
    2b2c:	8f 5f       	subi	r24, 0xFF	; 255
    2b2e:	80 93 de 15 	sts	0x15DE, r24	; 0x8015de <xNumOfOverflows>
    2b32:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2b36:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2b3a:	80 81       	ld	r24, Z
    2b3c:	81 11       	cpse	r24, r1
    2b3e:	07 c0       	rjmp	.+14     	; 0x2b4e <xTaskIncrementTick+0x7e>
    2b40:	8f ef       	ldi	r24, 0xFF	; 255
    2b42:	9f ef       	ldi	r25, 0xFF	; 255
    2b44:	90 93 dc 15 	sts	0x15DC, r25	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2b48:	80 93 db 15 	sts	0x15DB, r24	; 0x8015db <xNextTaskUnblockTime>
    2b4c:	10 c0       	rjmp	.+32     	; 0x2b6e <xTaskIncrementTick+0x9e>
    2b4e:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2b52:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2b56:	05 80       	ldd	r0, Z+5	; 0x05
    2b58:	f6 81       	ldd	r31, Z+6	; 0x06
    2b5a:	e0 2d       	mov	r30, r0
    2b5c:	06 80       	ldd	r0, Z+6	; 0x06
    2b5e:	f7 81       	ldd	r31, Z+7	; 0x07
    2b60:	e0 2d       	mov	r30, r0
    2b62:	82 81       	ldd	r24, Z+2	; 0x02
    2b64:	93 81       	ldd	r25, Z+3	; 0x03
    2b66:	90 93 dc 15 	sts	0x15DC, r25	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2b6a:	80 93 db 15 	sts	0x15DB, r24	; 0x8015db <xNextTaskUnblockTime>
    2b6e:	80 91 db 15 	lds	r24, 0x15DB	; 0x8015db <xNextTaskUnblockTime>
    2b72:	90 91 dc 15 	lds	r25, 0x15DC	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2b76:	e8 16       	cp	r14, r24
    2b78:	f9 06       	cpc	r15, r25
    2b7a:	10 f4       	brcc	.+4      	; 0x2b80 <xTaskIncrementTick+0xb0>
    2b7c:	d1 2c       	mov	r13, r1
    2b7e:	59 c0       	rjmp	.+178    	; 0x2c32 <xTaskIncrementTick+0x162>
    2b80:	d1 2c       	mov	r13, r1
    2b82:	cc 24       	eor	r12, r12
    2b84:	c3 94       	inc	r12
    2b86:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2b8a:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2b8e:	80 81       	ld	r24, Z
    2b90:	81 11       	cpse	r24, r1
    2b92:	07 c0       	rjmp	.+14     	; 0x2ba2 <xTaskIncrementTick+0xd2>
    2b94:	8f ef       	ldi	r24, 0xFF	; 255
    2b96:	9f ef       	ldi	r25, 0xFF	; 255
    2b98:	90 93 dc 15 	sts	0x15DC, r25	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2b9c:	80 93 db 15 	sts	0x15DB, r24	; 0x8015db <xNextTaskUnblockTime>
    2ba0:	48 c0       	rjmp	.+144    	; 0x2c32 <xTaskIncrementTick+0x162>
    2ba2:	e0 91 fa 15 	lds	r30, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2ba6:	f0 91 fb 15 	lds	r31, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2baa:	05 80       	ldd	r0, Z+5	; 0x05
    2bac:	f6 81       	ldd	r31, Z+6	; 0x06
    2bae:	e0 2d       	mov	r30, r0
    2bb0:	c6 81       	ldd	r28, Z+6	; 0x06
    2bb2:	d7 81       	ldd	r29, Z+7	; 0x07
    2bb4:	8a 81       	ldd	r24, Y+2	; 0x02
    2bb6:	9b 81       	ldd	r25, Y+3	; 0x03
    2bb8:	e8 16       	cp	r14, r24
    2bba:	f9 06       	cpc	r15, r25
    2bbc:	28 f4       	brcc	.+10     	; 0x2bc8 <xTaskIncrementTick+0xf8>
    2bbe:	90 93 dc 15 	sts	0x15DC, r25	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2bc2:	80 93 db 15 	sts	0x15DB, r24	; 0x8015db <xNextTaskUnblockTime>
    2bc6:	35 c0       	rjmp	.+106    	; 0x2c32 <xTaskIncrementTick+0x162>
    2bc8:	8e 01       	movw	r16, r28
    2bca:	0e 5f       	subi	r16, 0xFE	; 254
    2bcc:	1f 4f       	sbci	r17, 0xFF	; 255
    2bce:	c8 01       	movw	r24, r16
    2bd0:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2bd4:	8c 89       	ldd	r24, Y+20	; 0x14
    2bd6:	9d 89       	ldd	r25, Y+21	; 0x15
    2bd8:	89 2b       	or	r24, r25
    2bda:	21 f0       	breq	.+8      	; 0x2be4 <xTaskIncrementTick+0x114>
    2bdc:	ce 01       	movw	r24, r28
    2bde:	0c 96       	adiw	r24, 0x0c	; 12
    2be0:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2be4:	8e 89       	ldd	r24, Y+22	; 0x16
    2be6:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2bea:	98 17       	cp	r25, r24
    2bec:	10 f4       	brcc	.+4      	; 0x2bf2 <xTaskIncrementTick+0x122>
    2bee:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    2bf2:	90 e0       	ldi	r25, 0x00	; 0
    2bf4:	9c 01       	movw	r18, r24
    2bf6:	22 0f       	add	r18, r18
    2bf8:	33 1f       	adc	r19, r19
    2bfa:	22 0f       	add	r18, r18
    2bfc:	33 1f       	adc	r19, r19
    2bfe:	22 0f       	add	r18, r18
    2c00:	33 1f       	adc	r19, r19
    2c02:	82 0f       	add	r24, r18
    2c04:	93 1f       	adc	r25, r19
    2c06:	b8 01       	movw	r22, r16
    2c08:	82 5f       	subi	r24, 0xF2	; 242
    2c0a:	99 4e       	sbci	r25, 0xE9	; 233
    2c0c:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    2c10:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    2c14:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2c18:	9e 89       	ldd	r25, Y+22	; 0x16
    2c1a:	86 89       	ldd	r24, Z+22	; 0x16
    2c1c:	98 17       	cp	r25, r24
    2c1e:	08 f4       	brcc	.+2      	; 0x2c22 <xTaskIncrementTick+0x152>
    2c20:	b2 cf       	rjmp	.-156    	; 0x2b86 <xTaskIncrementTick+0xb6>
    2c22:	dc 2c       	mov	r13, r12
    2c24:	b0 cf       	rjmp	.-160    	; 0x2b86 <xTaskIncrementTick+0xb6>
    2c26:	80 91 e0 15 	lds	r24, 0x15E0	; 0x8015e0 <uxPendedTicks>
    2c2a:	8f 5f       	subi	r24, 0xFF	; 255
    2c2c:	80 93 e0 15 	sts	0x15E0, r24	; 0x8015e0 <uxPendedTicks>
    2c30:	d1 2c       	mov	r13, r1
    2c32:	80 91 df 15 	lds	r24, 0x15DF	; 0x8015df <xYieldPending>
    2c36:	88 23       	and	r24, r24
    2c38:	11 f0       	breq	.+4      	; 0x2c3e <xTaskIncrementTick+0x16e>
    2c3a:	dd 24       	eor	r13, r13
    2c3c:	d3 94       	inc	r13
    2c3e:	8d 2d       	mov	r24, r13
    2c40:	df 91       	pop	r29
    2c42:	cf 91       	pop	r28
    2c44:	1f 91       	pop	r17
    2c46:	0f 91       	pop	r16
    2c48:	ff 90       	pop	r15
    2c4a:	ef 90       	pop	r14
    2c4c:	df 90       	pop	r13
    2c4e:	cf 90       	pop	r12
    2c50:	08 95       	ret

00002c52 <vTaskSwitchContext>:
    2c52:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    2c56:	88 23       	and	r24, r24
    2c58:	21 f0       	breq	.+8      	; 0x2c62 <vTaskSwitchContext+0x10>
    2c5a:	81 e0       	ldi	r24, 0x01	; 1
    2c5c:	80 93 df 15 	sts	0x15DF, r24	; 0x8015df <xYieldPending>
    2c60:	08 95       	ret
    2c62:	10 92 df 15 	sts	0x15DF, r1	; 0x8015df <xYieldPending>
    2c66:	a0 91 44 16 	lds	r26, 0x1644	; 0x801644 <pxCurrentTCB>
    2c6a:	b0 91 45 16 	lds	r27, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2c6e:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    2c72:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2c76:	2d 91       	ld	r18, X+
    2c78:	3c 91       	ld	r19, X
    2c7a:	87 89       	ldd	r24, Z+23	; 0x17
    2c7c:	90 8d       	ldd	r25, Z+24	; 0x18
    2c7e:	82 17       	cp	r24, r18
    2c80:	93 07       	cpc	r25, r19
    2c82:	60 f0       	brcs	.+24     	; 0x2c9c <vTaskSwitchContext+0x4a>
    2c84:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    2c88:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2c8c:	80 91 44 16 	lds	r24, 0x1644	; 0x801644 <pxCurrentTCB>
    2c90:	90 91 45 16 	lds	r25, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2c94:	67 5e       	subi	r22, 0xE7	; 231
    2c96:	7f 4f       	sbci	r23, 0xFF	; 255
    2c98:	0e 94 b0 08 	call	0x1160	; 0x1160 <vApplicationStackOverflowHook>
    2c9c:	80 91 e2 15 	lds	r24, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2ca0:	90 e0       	ldi	r25, 0x00	; 0
    2ca2:	fc 01       	movw	r30, r24
    2ca4:	ee 0f       	add	r30, r30
    2ca6:	ff 1f       	adc	r31, r31
    2ca8:	ee 0f       	add	r30, r30
    2caa:	ff 1f       	adc	r31, r31
    2cac:	ee 0f       	add	r30, r30
    2cae:	ff 1f       	adc	r31, r31
    2cb0:	8e 0f       	add	r24, r30
    2cb2:	9f 1f       	adc	r25, r31
    2cb4:	fc 01       	movw	r30, r24
    2cb6:	e2 5f       	subi	r30, 0xF2	; 242
    2cb8:	f9 4e       	sbci	r31, 0xE9	; 233
    2cba:	80 81       	ld	r24, Z
    2cbc:	81 11       	cpse	r24, r1
    2cbe:	17 c0       	rjmp	.+46     	; 0x2cee <vTaskSwitchContext+0x9c>
    2cc0:	80 91 e2 15 	lds	r24, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2cc4:	81 50       	subi	r24, 0x01	; 1
    2cc6:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    2cca:	80 91 e2 15 	lds	r24, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2cce:	90 e0       	ldi	r25, 0x00	; 0
    2cd0:	fc 01       	movw	r30, r24
    2cd2:	ee 0f       	add	r30, r30
    2cd4:	ff 1f       	adc	r31, r31
    2cd6:	ee 0f       	add	r30, r30
    2cd8:	ff 1f       	adc	r31, r31
    2cda:	ee 0f       	add	r30, r30
    2cdc:	ff 1f       	adc	r31, r31
    2cde:	8e 0f       	add	r24, r30
    2ce0:	9f 1f       	adc	r25, r31
    2ce2:	fc 01       	movw	r30, r24
    2ce4:	e2 5f       	subi	r30, 0xF2	; 242
    2ce6:	f9 4e       	sbci	r31, 0xE9	; 233
    2ce8:	80 81       	ld	r24, Z
    2cea:	88 23       	and	r24, r24
    2cec:	49 f3       	breq	.-46     	; 0x2cc0 <vTaskSwitchContext+0x6e>
    2cee:	80 91 e2 15 	lds	r24, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2cf2:	90 e0       	ldi	r25, 0x00	; 0
    2cf4:	9c 01       	movw	r18, r24
    2cf6:	22 0f       	add	r18, r18
    2cf8:	33 1f       	adc	r19, r19
    2cfa:	22 0f       	add	r18, r18
    2cfc:	33 1f       	adc	r19, r19
    2cfe:	22 0f       	add	r18, r18
    2d00:	33 1f       	adc	r19, r19
    2d02:	28 0f       	add	r18, r24
    2d04:	39 1f       	adc	r19, r25
    2d06:	d9 01       	movw	r26, r18
    2d08:	a2 5f       	subi	r26, 0xF2	; 242
    2d0a:	b9 4e       	sbci	r27, 0xE9	; 233
    2d0c:	11 96       	adiw	r26, 0x01	; 1
    2d0e:	ed 91       	ld	r30, X+
    2d10:	fc 91       	ld	r31, X
    2d12:	12 97       	sbiw	r26, 0x02	; 2
    2d14:	02 80       	ldd	r0, Z+2	; 0x02
    2d16:	f3 81       	ldd	r31, Z+3	; 0x03
    2d18:	e0 2d       	mov	r30, r0
    2d1a:	12 96       	adiw	r26, 0x02	; 2
    2d1c:	fc 93       	st	X, r31
    2d1e:	ee 93       	st	-X, r30
    2d20:	11 97       	sbiw	r26, 0x01	; 1
    2d22:	2f 5e       	subi	r18, 0xEF	; 239
    2d24:	39 4e       	sbci	r19, 0xE9	; 233
    2d26:	e2 17       	cp	r30, r18
    2d28:	f3 07       	cpc	r31, r19
    2d2a:	29 f4       	brne	.+10     	; 0x2d36 <vTaskSwitchContext+0xe4>
    2d2c:	22 81       	ldd	r18, Z+2	; 0x02
    2d2e:	33 81       	ldd	r19, Z+3	; 0x03
    2d30:	fd 01       	movw	r30, r26
    2d32:	32 83       	std	Z+2, r19	; 0x02
    2d34:	21 83       	std	Z+1, r18	; 0x01
    2d36:	fc 01       	movw	r30, r24
    2d38:	ee 0f       	add	r30, r30
    2d3a:	ff 1f       	adc	r31, r31
    2d3c:	ee 0f       	add	r30, r30
    2d3e:	ff 1f       	adc	r31, r31
    2d40:	ee 0f       	add	r30, r30
    2d42:	ff 1f       	adc	r31, r31
    2d44:	8e 0f       	add	r24, r30
    2d46:	9f 1f       	adc	r25, r31
    2d48:	fc 01       	movw	r30, r24
    2d4a:	e2 5f       	subi	r30, 0xF2	; 242
    2d4c:	f9 4e       	sbci	r31, 0xE9	; 233
    2d4e:	01 80       	ldd	r0, Z+1	; 0x01
    2d50:	f2 81       	ldd	r31, Z+2	; 0x02
    2d52:	e0 2d       	mov	r30, r0
    2d54:	86 81       	ldd	r24, Z+6	; 0x06
    2d56:	97 81       	ldd	r25, Z+7	; 0x07
    2d58:	90 93 45 16 	sts	0x1645, r25	; 0x801645 <pxCurrentTCB+0x1>
    2d5c:	80 93 44 16 	sts	0x1644, r24	; 0x801644 <pxCurrentTCB>
    2d60:	08 95       	ret

00002d62 <vTaskPlaceOnEventList>:
    2d62:	cf 93       	push	r28
    2d64:	df 93       	push	r29
    2d66:	eb 01       	movw	r28, r22
    2d68:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    2d6c:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2d70:	64 5f       	subi	r22, 0xF4	; 244
    2d72:	7f 4f       	sbci	r23, 0xFF	; 255
    2d74:	0e 94 59 08 	call	0x10b2	; 0x10b2 <vListInsert>
    2d78:	80 91 44 16 	lds	r24, 0x1644	; 0x801644 <pxCurrentTCB>
    2d7c:	90 91 45 16 	lds	r25, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2d80:	02 96       	adiw	r24, 0x02	; 2
    2d82:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2d86:	cf 3f       	cpi	r28, 0xFF	; 255
    2d88:	8f ef       	ldi	r24, 0xFF	; 255
    2d8a:	d8 07       	cpc	r29, r24
    2d8c:	59 f4       	brne	.+22     	; 0x2da4 <vTaskPlaceOnEventList+0x42>
    2d8e:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    2d92:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2d96:	6e 5f       	subi	r22, 0xFE	; 254
    2d98:	7f 4f       	sbci	r23, 0xFF	; 255
    2d9a:	86 ee       	ldi	r24, 0xE6	; 230
    2d9c:	95 e1       	ldi	r25, 0x15	; 21
    2d9e:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    2da2:	37 c0       	rjmp	.+110    	; 0x2e12 <vTaskPlaceOnEventList+0xb0>
    2da4:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    2da8:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2dac:	c8 0f       	add	r28, r24
    2dae:	d9 1f       	adc	r29, r25
    2db0:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    2db4:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2db8:	d3 83       	std	Z+3, r29	; 0x03
    2dba:	c2 83       	std	Z+2, r28	; 0x02
    2dbc:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    2dc0:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2dc4:	c8 17       	cp	r28, r24
    2dc6:	d9 07       	cpc	r29, r25
    2dc8:	68 f4       	brcc	.+26     	; 0x2de4 <vTaskPlaceOnEventList+0x82>
    2dca:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    2dce:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2dd2:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <pxOverflowDelayedTaskList>
    2dd6:	90 91 f9 15 	lds	r25, 0x15F9	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    2dda:	6e 5f       	subi	r22, 0xFE	; 254
    2ddc:	7f 4f       	sbci	r23, 0xFF	; 255
    2dde:	0e 94 59 08 	call	0x10b2	; 0x10b2 <vListInsert>
    2de2:	17 c0       	rjmp	.+46     	; 0x2e12 <vTaskPlaceOnEventList+0xb0>
    2de4:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    2de8:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2dec:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    2df0:	90 91 fb 15 	lds	r25, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    2df4:	6e 5f       	subi	r22, 0xFE	; 254
    2df6:	7f 4f       	sbci	r23, 0xFF	; 255
    2df8:	0e 94 59 08 	call	0x10b2	; 0x10b2 <vListInsert>
    2dfc:	80 91 db 15 	lds	r24, 0x15DB	; 0x8015db <xNextTaskUnblockTime>
    2e00:	90 91 dc 15 	lds	r25, 0x15DC	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2e04:	c8 17       	cp	r28, r24
    2e06:	d9 07       	cpc	r29, r25
    2e08:	20 f4       	brcc	.+8      	; 0x2e12 <vTaskPlaceOnEventList+0xb0>
    2e0a:	d0 93 dc 15 	sts	0x15DC, r29	; 0x8015dc <xNextTaskUnblockTime+0x1>
    2e0e:	c0 93 db 15 	sts	0x15DB, r28	; 0x8015db <xNextTaskUnblockTime>
    2e12:	df 91       	pop	r29
    2e14:	cf 91       	pop	r28
    2e16:	08 95       	ret

00002e18 <xTaskRemoveFromEventList>:
    2e18:	0f 93       	push	r16
    2e1a:	1f 93       	push	r17
    2e1c:	cf 93       	push	r28
    2e1e:	df 93       	push	r29
    2e20:	dc 01       	movw	r26, r24
    2e22:	15 96       	adiw	r26, 0x05	; 5
    2e24:	ed 91       	ld	r30, X+
    2e26:	fc 91       	ld	r31, X
    2e28:	16 97       	sbiw	r26, 0x06	; 6
    2e2a:	c6 81       	ldd	r28, Z+6	; 0x06
    2e2c:	d7 81       	ldd	r29, Z+7	; 0x07
    2e2e:	8e 01       	movw	r16, r28
    2e30:	04 5f       	subi	r16, 0xF4	; 244
    2e32:	1f 4f       	sbci	r17, 0xFF	; 255
    2e34:	c8 01       	movw	r24, r16
    2e36:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2e3a:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    2e3e:	81 11       	cpse	r24, r1
    2e40:	1c c0       	rjmp	.+56     	; 0x2e7a <xTaskRemoveFromEventList+0x62>
    2e42:	0a 50       	subi	r16, 0x0A	; 10
    2e44:	11 09       	sbc	r17, r1
    2e46:	c8 01       	movw	r24, r16
    2e48:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2e4c:	8e 89       	ldd	r24, Y+22	; 0x16
    2e4e:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2e52:	98 17       	cp	r25, r24
    2e54:	10 f4       	brcc	.+4      	; 0x2e5a <xTaskRemoveFromEventList+0x42>
    2e56:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    2e5a:	90 e0       	ldi	r25, 0x00	; 0
    2e5c:	9c 01       	movw	r18, r24
    2e5e:	22 0f       	add	r18, r18
    2e60:	33 1f       	adc	r19, r19
    2e62:	22 0f       	add	r18, r18
    2e64:	33 1f       	adc	r19, r19
    2e66:	22 0f       	add	r18, r18
    2e68:	33 1f       	adc	r19, r19
    2e6a:	82 0f       	add	r24, r18
    2e6c:	93 1f       	adc	r25, r19
    2e6e:	b8 01       	movw	r22, r16
    2e70:	82 5f       	subi	r24, 0xF2	; 242
    2e72:	99 4e       	sbci	r25, 0xE9	; 233
    2e74:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    2e78:	05 c0       	rjmp	.+10     	; 0x2e84 <xTaskRemoveFromEventList+0x6c>
    2e7a:	b8 01       	movw	r22, r16
    2e7c:	8f ee       	ldi	r24, 0xEF	; 239
    2e7e:	95 e1       	ldi	r25, 0x15	; 21
    2e80:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    2e84:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    2e88:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2e8c:	9e 89       	ldd	r25, Y+22	; 0x16
    2e8e:	86 89       	ldd	r24, Z+22	; 0x16
    2e90:	89 17       	cp	r24, r25
    2e92:	20 f4       	brcc	.+8      	; 0x2e9c <xTaskRemoveFromEventList+0x84>
    2e94:	81 e0       	ldi	r24, 0x01	; 1
    2e96:	80 93 df 15 	sts	0x15DF, r24	; 0x8015df <xYieldPending>
    2e9a:	01 c0       	rjmp	.+2      	; 0x2e9e <xTaskRemoveFromEventList+0x86>
    2e9c:	80 e0       	ldi	r24, 0x00	; 0
    2e9e:	df 91       	pop	r29
    2ea0:	cf 91       	pop	r28
    2ea2:	1f 91       	pop	r17
    2ea4:	0f 91       	pop	r16
    2ea6:	08 95       	ret

00002ea8 <vTaskSetTimeOutState>:
    2ea8:	20 91 de 15 	lds	r18, 0x15DE	; 0x8015de <xNumOfOverflows>
    2eac:	fc 01       	movw	r30, r24
    2eae:	20 83       	st	Z, r18
    2eb0:	20 91 e3 15 	lds	r18, 0x15E3	; 0x8015e3 <xTickCount>
    2eb4:	30 91 e4 15 	lds	r19, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2eb8:	32 83       	std	Z+2, r19	; 0x02
    2eba:	21 83       	std	Z+1, r18	; 0x01
    2ebc:	08 95       	ret

00002ebe <xTaskCheckForTimeOut>:
    2ebe:	fc 01       	movw	r30, r24
    2ec0:	0f b6       	in	r0, 0x3f	; 63
    2ec2:	f8 94       	cli
    2ec4:	0f 92       	push	r0
    2ec6:	20 91 e3 15 	lds	r18, 0x15E3	; 0x8015e3 <xTickCount>
    2eca:	30 91 e4 15 	lds	r19, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2ece:	db 01       	movw	r26, r22
    2ed0:	8d 91       	ld	r24, X+
    2ed2:	9c 91       	ld	r25, X
    2ed4:	8f 3f       	cpi	r24, 0xFF	; 255
    2ed6:	bf ef       	ldi	r27, 0xFF	; 255
    2ed8:	9b 07       	cpc	r25, r27
    2eda:	21 f1       	breq	.+72     	; 0x2f24 <xTaskCheckForTimeOut+0x66>
    2edc:	40 91 de 15 	lds	r20, 0x15DE	; 0x8015de <xNumOfOverflows>
    2ee0:	50 81       	ld	r21, Z
    2ee2:	54 17       	cp	r21, r20
    2ee4:	29 f0       	breq	.+10     	; 0x2ef0 <xTaskCheckForTimeOut+0x32>
    2ee6:	41 81       	ldd	r20, Z+1	; 0x01
    2ee8:	52 81       	ldd	r21, Z+2	; 0x02
    2eea:	24 17       	cp	r18, r20
    2eec:	35 07       	cpc	r19, r21
    2eee:	e0 f4       	brcc	.+56     	; 0x2f28 <xTaskCheckForTimeOut+0x6a>
    2ef0:	41 81       	ldd	r20, Z+1	; 0x01
    2ef2:	52 81       	ldd	r21, Z+2	; 0x02
    2ef4:	d9 01       	movw	r26, r18
    2ef6:	a4 1b       	sub	r26, r20
    2ef8:	b5 0b       	sbc	r27, r21
    2efa:	a8 17       	cp	r26, r24
    2efc:	b9 07       	cpc	r27, r25
    2efe:	b0 f4       	brcc	.+44     	; 0x2f2c <xTaskCheckForTimeOut+0x6e>
    2f00:	42 1b       	sub	r20, r18
    2f02:	53 0b       	sbc	r21, r19
    2f04:	84 0f       	add	r24, r20
    2f06:	95 1f       	adc	r25, r21
    2f08:	db 01       	movw	r26, r22
    2f0a:	8d 93       	st	X+, r24
    2f0c:	9c 93       	st	X, r25
    2f0e:	80 91 de 15 	lds	r24, 0x15DE	; 0x8015de <xNumOfOverflows>
    2f12:	80 83       	st	Z, r24
    2f14:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    2f18:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    2f1c:	92 83       	std	Z+2, r25	; 0x02
    2f1e:	81 83       	std	Z+1, r24	; 0x01
    2f20:	80 e0       	ldi	r24, 0x00	; 0
    2f22:	05 c0       	rjmp	.+10     	; 0x2f2e <xTaskCheckForTimeOut+0x70>
    2f24:	80 e0       	ldi	r24, 0x00	; 0
    2f26:	03 c0       	rjmp	.+6      	; 0x2f2e <xTaskCheckForTimeOut+0x70>
    2f28:	81 e0       	ldi	r24, 0x01	; 1
    2f2a:	01 c0       	rjmp	.+2      	; 0x2f2e <xTaskCheckForTimeOut+0x70>
    2f2c:	81 e0       	ldi	r24, 0x01	; 1
    2f2e:	0f 90       	pop	r0
    2f30:	0f be       	out	0x3f, r0	; 63
    2f32:	08 95       	ret

00002f34 <vTaskMissedYield>:
    2f34:	81 e0       	ldi	r24, 0x01	; 1
    2f36:	80 93 df 15 	sts	0x15DF, r24	; 0x8015df <xYieldPending>
    2f3a:	08 95       	ret

00002f3c <xTaskGetCurrentTaskHandle>:
    2f3c:	80 91 44 16 	lds	r24, 0x1644	; 0x801644 <pxCurrentTCB>
    2f40:	90 91 45 16 	lds	r25, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2f44:	08 95       	ret

00002f46 <vTaskPriorityInherit>:
    2f46:	0f 93       	push	r16
    2f48:	1f 93       	push	r17
    2f4a:	cf 93       	push	r28
    2f4c:	df 93       	push	r29
    2f4e:	fc 01       	movw	r30, r24
    2f50:	89 2b       	or	r24, r25
    2f52:	09 f4       	brne	.+2      	; 0x2f56 <vTaskPriorityInherit+0x10>
    2f54:	55 c0       	rjmp	.+170    	; 0x3000 <vTaskPriorityInherit+0xba>
    2f56:	26 89       	ldd	r18, Z+22	; 0x16
    2f58:	a0 91 44 16 	lds	r26, 0x1644	; 0x801644 <pxCurrentTCB>
    2f5c:	b0 91 45 16 	lds	r27, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2f60:	56 96       	adiw	r26, 0x16	; 22
    2f62:	8c 91       	ld	r24, X
    2f64:	28 17       	cp	r18, r24
    2f66:	08 f0       	brcs	.+2      	; 0x2f6a <vTaskPriorityInherit+0x24>
    2f68:	4b c0       	rjmp	.+150    	; 0x3000 <vTaskPriorityInherit+0xba>
    2f6a:	84 85       	ldd	r24, Z+12	; 0x0c
    2f6c:	95 85       	ldd	r25, Z+13	; 0x0d
    2f6e:	99 23       	and	r25, r25
    2f70:	64 f0       	brlt	.+24     	; 0x2f8a <vTaskPriorityInherit+0x44>
    2f72:	a0 91 44 16 	lds	r26, 0x1644	; 0x801644 <pxCurrentTCB>
    2f76:	b0 91 45 16 	lds	r27, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2f7a:	56 96       	adiw	r26, 0x16	; 22
    2f7c:	3c 91       	ld	r19, X
    2f7e:	86 e0       	ldi	r24, 0x06	; 6
    2f80:	90 e0       	ldi	r25, 0x00	; 0
    2f82:	83 1b       	sub	r24, r19
    2f84:	91 09       	sbc	r25, r1
    2f86:	95 87       	std	Z+13, r25	; 0x0d
    2f88:	84 87       	std	Z+12, r24	; 0x0c
    2f8a:	30 e0       	ldi	r19, 0x00	; 0
    2f8c:	c9 01       	movw	r24, r18
    2f8e:	88 0f       	add	r24, r24
    2f90:	99 1f       	adc	r25, r25
    2f92:	88 0f       	add	r24, r24
    2f94:	99 1f       	adc	r25, r25
    2f96:	88 0f       	add	r24, r24
    2f98:	99 1f       	adc	r25, r25
    2f9a:	28 0f       	add	r18, r24
    2f9c:	39 1f       	adc	r19, r25
    2f9e:	22 5f       	subi	r18, 0xF2	; 242
    2fa0:	39 4e       	sbci	r19, 0xE9	; 233
    2fa2:	82 85       	ldd	r24, Z+10	; 0x0a
    2fa4:	93 85       	ldd	r25, Z+11	; 0x0b
    2fa6:	82 17       	cp	r24, r18
    2fa8:	93 07       	cpc	r25, r19
    2faa:	19 f5       	brne	.+70     	; 0x2ff2 <vTaskPriorityInherit+0xac>
    2fac:	8f 01       	movw	r16, r30
    2fae:	ef 01       	movw	r28, r30
    2fb0:	22 96       	adiw	r28, 0x02	; 2
    2fb2:	ce 01       	movw	r24, r28
    2fb4:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    2fb8:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    2fbc:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2fc0:	86 89       	ldd	r24, Z+22	; 0x16
    2fc2:	f8 01       	movw	r30, r16
    2fc4:	86 8b       	std	Z+22, r24	; 0x16
    2fc6:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    2fca:	98 17       	cp	r25, r24
    2fcc:	10 f4       	brcc	.+4      	; 0x2fd2 <vTaskPriorityInherit+0x8c>
    2fce:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    2fd2:	90 e0       	ldi	r25, 0x00	; 0
    2fd4:	9c 01       	movw	r18, r24
    2fd6:	22 0f       	add	r18, r18
    2fd8:	33 1f       	adc	r19, r19
    2fda:	22 0f       	add	r18, r18
    2fdc:	33 1f       	adc	r19, r19
    2fde:	22 0f       	add	r18, r18
    2fe0:	33 1f       	adc	r19, r19
    2fe2:	82 0f       	add	r24, r18
    2fe4:	93 1f       	adc	r25, r19
    2fe6:	be 01       	movw	r22, r28
    2fe8:	82 5f       	subi	r24, 0xF2	; 242
    2fea:	99 4e       	sbci	r25, 0xE9	; 233
    2fec:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    2ff0:	07 c0       	rjmp	.+14     	; 0x3000 <vTaskPriorityInherit+0xba>
    2ff2:	a0 91 44 16 	lds	r26, 0x1644	; 0x801644 <pxCurrentTCB>
    2ff6:	b0 91 45 16 	lds	r27, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    2ffa:	56 96       	adiw	r26, 0x16	; 22
    2ffc:	8c 91       	ld	r24, X
    2ffe:	86 8b       	std	Z+22, r24	; 0x16
    3000:	df 91       	pop	r29
    3002:	cf 91       	pop	r28
    3004:	1f 91       	pop	r17
    3006:	0f 91       	pop	r16
    3008:	08 95       	ret

0000300a <xTaskPriorityDisinherit>:
    300a:	0f 93       	push	r16
    300c:	1f 93       	push	r17
    300e:	cf 93       	push	r28
    3010:	df 93       	push	r29
    3012:	fc 01       	movw	r30, r24
    3014:	89 2b       	or	r24, r25
    3016:	79 f1       	breq	.+94     	; 0x3076 <xTaskPriorityDisinherit+0x6c>
    3018:	82 a1       	ldd	r24, Z+34	; 0x22
    301a:	81 50       	subi	r24, 0x01	; 1
    301c:	82 a3       	std	Z+34, r24	; 0x22
    301e:	26 89       	ldd	r18, Z+22	; 0x16
    3020:	91 a1       	ldd	r25, Z+33	; 0x21
    3022:	29 17       	cp	r18, r25
    3024:	51 f1       	breq	.+84     	; 0x307a <xTaskPriorityDisinherit+0x70>
    3026:	81 11       	cpse	r24, r1
    3028:	2a c0       	rjmp	.+84     	; 0x307e <xTaskPriorityDisinherit+0x74>
    302a:	ef 01       	movw	r28, r30
    302c:	8f 01       	movw	r16, r30
    302e:	0e 5f       	subi	r16, 0xFE	; 254
    3030:	1f 4f       	sbci	r17, 0xFF	; 255
    3032:	c8 01       	movw	r24, r16
    3034:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
    3038:	89 a1       	ldd	r24, Y+33	; 0x21
    303a:	8e 8b       	std	Y+22, r24	; 0x16
    303c:	26 e0       	ldi	r18, 0x06	; 6
    303e:	30 e0       	ldi	r19, 0x00	; 0
    3040:	28 1b       	sub	r18, r24
    3042:	31 09       	sbc	r19, r1
    3044:	3d 87       	std	Y+13, r19	; 0x0d
    3046:	2c 87       	std	Y+12, r18	; 0x0c
    3048:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    304c:	98 17       	cp	r25, r24
    304e:	10 f4       	brcc	.+4      	; 0x3054 <xTaskPriorityDisinherit+0x4a>
    3050:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    3054:	90 e0       	ldi	r25, 0x00	; 0
    3056:	9c 01       	movw	r18, r24
    3058:	22 0f       	add	r18, r18
    305a:	33 1f       	adc	r19, r19
    305c:	22 0f       	add	r18, r18
    305e:	33 1f       	adc	r19, r19
    3060:	22 0f       	add	r18, r18
    3062:	33 1f       	adc	r19, r19
    3064:	82 0f       	add	r24, r18
    3066:	93 1f       	adc	r25, r19
    3068:	b8 01       	movw	r22, r16
    306a:	82 5f       	subi	r24, 0xF2	; 242
    306c:	99 4e       	sbci	r25, 0xE9	; 233
    306e:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    3072:	81 e0       	ldi	r24, 0x01	; 1
    3074:	05 c0       	rjmp	.+10     	; 0x3080 <xTaskPriorityDisinherit+0x76>
    3076:	80 e0       	ldi	r24, 0x00	; 0
    3078:	03 c0       	rjmp	.+6      	; 0x3080 <xTaskPriorityDisinherit+0x76>
    307a:	80 e0       	ldi	r24, 0x00	; 0
    307c:	01 c0       	rjmp	.+2      	; 0x3080 <xTaskPriorityDisinherit+0x76>
    307e:	80 e0       	ldi	r24, 0x00	; 0
    3080:	df 91       	pop	r29
    3082:	cf 91       	pop	r28
    3084:	1f 91       	pop	r17
    3086:	0f 91       	pop	r16
    3088:	08 95       	ret

0000308a <pvTaskIncrementMutexHeldCount>:
    308a:	80 91 44 16 	lds	r24, 0x1644	; 0x801644 <pxCurrentTCB>
    308e:	90 91 45 16 	lds	r25, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    3092:	89 2b       	or	r24, r25
    3094:	39 f0       	breq	.+14     	; 0x30a4 <pvTaskIncrementMutexHeldCount+0x1a>
    3096:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    309a:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    309e:	82 a1       	ldd	r24, Z+34	; 0x22
    30a0:	8f 5f       	subi	r24, 0xFF	; 255
    30a2:	82 a3       	std	Z+34, r24	; 0x22
    30a4:	80 91 44 16 	lds	r24, 0x1644	; 0x801644 <pxCurrentTCB>
    30a8:	90 91 45 16 	lds	r25, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    30ac:	08 95       	ret

000030ae <xTaskNotifyWait>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
	{
    30ae:	4f 92       	push	r4
    30b0:	5f 92       	push	r5
    30b2:	6f 92       	push	r6
    30b4:	7f 92       	push	r7
    30b6:	8f 92       	push	r8
    30b8:	9f 92       	push	r9
    30ba:	af 92       	push	r10
    30bc:	bf 92       	push	r11
    30be:	ef 92       	push	r14
    30c0:	ff 92       	push	r15
    30c2:	0f 93       	push	r16
    30c4:	1f 93       	push	r17
    30c6:	49 01       	movw	r8, r18
    30c8:	5a 01       	movw	r10, r20
	TickType_t xTimeToWake;
	BaseType_t xReturn;

		taskENTER_CRITICAL();
    30ca:	0f b6       	in	r0, 0x3f	; 63
    30cc:	f8 94       	cli
    30ce:	0f 92       	push	r0
		{
			/* Only block if a notification is not already pending. */
			if( pxCurrentTCB->eNotifyState != eNotified )
    30d0:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    30d4:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    30d8:	27 a1       	ldd	r18, Z+39	; 0x27
    30da:	22 30       	cpi	r18, 0x02	; 2
    30dc:	09 f4       	brne	.+2      	; 0x30e0 <xTaskNotifyWait+0x32>
    30de:	6f c0       	rjmp	.+222    	; 0x31be <xTaskNotifyWait+0x110>
			{
				/* Clear bits in the task's notification value as bits may get
				set	by the notifying task or interrupt.  This can be used to
				clear the value to zero. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
    30e0:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    30e4:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    30e8:	43 a0       	ldd	r4, Z+35	; 0x23
    30ea:	54 a0       	ldd	r5, Z+36	; 0x24
    30ec:	65 a0       	ldd	r6, Z+37	; 0x25
    30ee:	76 a0       	ldd	r7, Z+38	; 0x26
    30f0:	dc 01       	movw	r26, r24
    30f2:	cb 01       	movw	r24, r22
    30f4:	80 95       	com	r24
    30f6:	90 95       	com	r25
    30f8:	a0 95       	com	r26
    30fa:	b0 95       	com	r27
    30fc:	84 21       	and	r24, r4
    30fe:	95 21       	and	r25, r5
    3100:	a6 21       	and	r26, r6
    3102:	b7 21       	and	r27, r7
    3104:	83 a3       	std	Z+35, r24	; 0x23
    3106:	94 a3       	std	Z+36, r25	; 0x24
    3108:	a5 a3       	std	Z+37, r26	; 0x25
    310a:	b6 a3       	std	Z+38, r27	; 0x26

				/* Mark this task as waiting for a notification. */
				pxCurrentTCB->eNotifyState = eWaitingNotification;
    310c:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    3110:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    3114:	81 e0       	ldi	r24, 0x01	; 1
    3116:	87 a3       	std	Z+39, r24	; 0x27

				if( xTicksToWait > ( TickType_t ) 0 )
    3118:	e1 14       	cp	r14, r1
    311a:	f1 04       	cpc	r15, r1
    311c:	09 f4       	brne	.+2      	; 0x3120 <xTaskNotifyWait+0x72>
    311e:	4f c0       	rjmp	.+158    	; 0x31be <xTaskNotifyWait+0x110>
				{
					/* The task is going to block.  First it must be removed
					from the	ready list. */
					if( uxListRemove( &( pxCurrentTCB->xGenericListItem ) ) == ( UBaseType_t ) 0 )
    3120:	80 91 44 16 	lds	r24, 0x1644	; 0x801644 <pxCurrentTCB>
    3124:	90 91 45 16 	lds	r25, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    3128:	02 96       	adiw	r24, 0x02	; 2
    312a:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
						mtCOVERAGE_TEST_MARKER();
					}

					#if ( INCLUDE_vTaskSuspend == 1 )
					{
						if( xTicksToWait == portMAX_DELAY )
    312e:	8f ef       	ldi	r24, 0xFF	; 255
    3130:	e8 16       	cp	r14, r24
    3132:	f8 06       	cpc	r15, r24
    3134:	59 f4       	brne	.+22     	; 0x314c <xTaskNotifyWait+0x9e>
						{
							/* Add the task to the suspended task list instead
							of a delayed task list to ensure the task is not
							woken by a timing event.  It will block
							indefinitely. */
							vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3136:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    313a:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    313e:	6e 5f       	subi	r22, 0xFE	; 254
    3140:	7f 4f       	sbci	r23, 0xFF	; 255
    3142:	86 ee       	ldi	r24, 0xE6	; 230
    3144:	95 e1       	ldi	r25, 0x15	; 21
    3146:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    314a:	37 c0       	rjmp	.+110    	; 0x31ba <xTaskNotifyWait+0x10c>
						{
							/* Calculate the time at which the task should be
							woken if no notification events occur.  This may
							overflow but this doesn't matter, the scheduler will
							handle it. */
							xTimeToWake = xTickCount + xTicksToWait;
    314c:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    3150:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    3154:	e8 0e       	add	r14, r24
    3156:	f9 1e       	adc	r15, r25
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( const TickType_t xTimeToWake )
{
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    3158:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    315c:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    3160:	f3 82       	std	Z+3, r15	; 0x03
    3162:	e2 82       	std	Z+2, r14	; 0x02

	if( xTimeToWake < xTickCount )
    3164:	80 91 e3 15 	lds	r24, 0x15E3	; 0x8015e3 <xTickCount>
    3168:	90 91 e4 15 	lds	r25, 0x15E4	; 0x8015e4 <xTickCount+0x1>
    316c:	e8 16       	cp	r14, r24
    316e:	f9 06       	cpc	r15, r25
    3170:	68 f4       	brcc	.+26     	; 0x318c <xTaskNotifyWait+0xde>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    3172:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    3176:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    317a:	80 91 f8 15 	lds	r24, 0x15F8	; 0x8015f8 <pxOverflowDelayedTaskList>
    317e:	90 91 f9 15 	lds	r25, 0x15F9	; 0x8015f9 <pxOverflowDelayedTaskList+0x1>
    3182:	6e 5f       	subi	r22, 0xFE	; 254
    3184:	7f 4f       	sbci	r23, 0xFF	; 255
    3186:	0e 94 59 08 	call	0x10b2	; 0x10b2 <vListInsert>
    318a:	17 c0       	rjmp	.+46     	; 0x31ba <xTaskNotifyWait+0x10c>
	}
	else
	{
		/* The wake time has not overflowed, so the current block list is used. */
		vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xGenericListItem ) );
    318c:	60 91 44 16 	lds	r22, 0x1644	; 0x801644 <pxCurrentTCB>
    3190:	70 91 45 16 	lds	r23, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    3194:	80 91 fa 15 	lds	r24, 0x15FA	; 0x8015fa <pxDelayedTaskList>
    3198:	90 91 fb 15 	lds	r25, 0x15FB	; 0x8015fb <pxDelayedTaskList+0x1>
    319c:	6e 5f       	subi	r22, 0xFE	; 254
    319e:	7f 4f       	sbci	r23, 0xFF	; 255
    31a0:	0e 94 59 08 	call	0x10b2	; 0x10b2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    31a4:	80 91 db 15 	lds	r24, 0x15DB	; 0x8015db <xNextTaskUnblockTime>
    31a8:	90 91 dc 15 	lds	r25, 0x15DC	; 0x8015dc <xNextTaskUnblockTime+0x1>
    31ac:	e8 16       	cp	r14, r24
    31ae:	f9 06       	cpc	r15, r25
    31b0:	20 f4       	brcc	.+8      	; 0x31ba <xTaskNotifyWait+0x10c>
		{
			xNextTaskUnblockTime = xTimeToWake;
    31b2:	f0 92 dc 15 	sts	0x15DC, r15	; 0x8015dc <xNextTaskUnblockTime+0x1>
    31b6:	e0 92 db 15 	sts	0x15DB, r14	; 0x8015db <xNextTaskUnblockTime>

					/* All ports are written to allow a yield in a critical
					section (some will yield immediately, others wait until the
					critical section exits) - but it is not something that
					application code should ever do. */
					portYIELD_WITHIN_API();
    31ba:	0e 94 4d 0b 	call	0x169a	; 0x169a <vPortYield>
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    31be:	0f 90       	pop	r0
    31c0:	0f be       	out	0x3f, r0	; 63

		taskENTER_CRITICAL();
    31c2:	0f b6       	in	r0, 0x3f	; 63
    31c4:	f8 94       	cli
    31c6:	0f 92       	push	r0
		{
			traceTASK_NOTIFY_WAIT();

			if( pulNotificationValue != NULL )
    31c8:	01 15       	cp	r16, r1
    31ca:	11 05       	cpc	r17, r1
    31cc:	69 f0       	breq	.+26     	; 0x31e8 <xTaskNotifyWait+0x13a>
			{
				/* Output the current notification value, which may or may not
				have changed. */
				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
    31ce:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    31d2:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    31d6:	83 a1       	ldd	r24, Z+35	; 0x23
    31d8:	94 a1       	ldd	r25, Z+36	; 0x24
    31da:	a5 a1       	ldd	r26, Z+37	; 0x25
    31dc:	b6 a1       	ldd	r27, Z+38	; 0x26
    31de:	f8 01       	movw	r30, r16
    31e0:	80 83       	st	Z, r24
    31e2:	91 83       	std	Z+1, r25	; 0x01
    31e4:	a2 83       	std	Z+2, r26	; 0x02
    31e6:	b3 83       	std	Z+3, r27	; 0x03

			/* If eNotifyValue is set then either the task never entered the
			blocked state (because a notification was already pending) or the
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
    31e8:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    31ec:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    31f0:	87 a1       	ldd	r24, Z+39	; 0x27
    31f2:	81 30       	cpi	r24, 0x01	; 1
    31f4:	b1 f0       	breq	.+44     	; 0x3222 <xTaskNotifyWait+0x174>
			}
			else
			{
				/* A notification was already pending or a notification was
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
    31f6:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    31fa:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    31fe:	83 a1       	ldd	r24, Z+35	; 0x23
    3200:	94 a1       	ldd	r25, Z+36	; 0x24
    3202:	a5 a1       	ldd	r26, Z+37	; 0x25
    3204:	b6 a1       	ldd	r27, Z+38	; 0x26
    3206:	80 94       	com	r8
    3208:	90 94       	com	r9
    320a:	a0 94       	com	r10
    320c:	b0 94       	com	r11
    320e:	88 22       	and	r8, r24
    3210:	99 22       	and	r9, r25
    3212:	aa 22       	and	r10, r26
    3214:	bb 22       	and	r11, r27
    3216:	83 a2       	std	Z+35, r8	; 0x23
    3218:	94 a2       	std	Z+36, r9	; 0x24
    321a:	a5 a2       	std	Z+37, r10	; 0x25
    321c:	b6 a2       	std	Z+38, r11	; 0x26
				xReturn = pdTRUE;
    321e:	81 e0       	ldi	r24, 0x01	; 1
    3220:	01 c0       	rjmp	.+2      	; 0x3224 <xTaskNotifyWait+0x176>
			task unblocked because of a notification.  Otherwise the task
			unblocked because of a timeout. */
			if( pxCurrentTCB->eNotifyState == eWaitingNotification )
			{
				/* A notification was not received. */
				xReturn = pdFALSE;
    3222:	80 e0       	ldi	r24, 0x00	; 0
				received while the task was waiting. */
				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
				xReturn = pdTRUE;
			}

			pxCurrentTCB->eNotifyState = eNotWaitingNotification;
    3224:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    3228:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    322c:	17 a2       	std	Z+39, r1	; 0x27
		}
		taskEXIT_CRITICAL();
    322e:	0f 90       	pop	r0
    3230:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    3232:	1f 91       	pop	r17
    3234:	0f 91       	pop	r16
    3236:	ff 90       	pop	r15
    3238:	ef 90       	pop	r14
    323a:	bf 90       	pop	r11
    323c:	af 90       	pop	r10
    323e:	9f 90       	pop	r9
    3240:	8f 90       	pop	r8
    3242:	7f 90       	pop	r7
    3244:	6f 90       	pop	r6
    3246:	5f 90       	pop	r5
    3248:	4f 90       	pop	r4
    324a:	08 95       	ret

0000324c <xTaskGenericNotify>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
	{
    324c:	0f 93       	push	r16
    324e:	1f 93       	push	r17
    3250:	cf 93       	push	r28
    3252:	df 93       	push	r29
    3254:	fc 01       	movw	r30, r24
	BaseType_t xReturn = pdPASS;

		configASSERT( xTaskToNotify );
		pxTCB = ( TCB_t * ) xTaskToNotify;

		taskENTER_CRITICAL();
    3256:	0f b6       	in	r0, 0x3f	; 63
    3258:	f8 94       	cli
    325a:	0f 92       	push	r0
		{
			if( pulPreviousNotificationValue != NULL )
    325c:	01 15       	cp	r16, r1
    325e:	11 05       	cpc	r17, r1
    3260:	49 f0       	breq	.+18     	; 0x3274 <xTaskGenericNotify+0x28>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    3262:	83 a1       	ldd	r24, Z+35	; 0x23
    3264:	94 a1       	ldd	r25, Z+36	; 0x24
    3266:	a5 a1       	ldd	r26, Z+37	; 0x25
    3268:	b6 a1       	ldd	r27, Z+38	; 0x26
    326a:	e8 01       	movw	r28, r16
    326c:	88 83       	st	Y, r24
    326e:	99 83       	std	Y+1, r25	; 0x01
    3270:	aa 83       	std	Y+2, r26	; 0x02
    3272:	bb 83       	std	Y+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    3274:	87 a1       	ldd	r24, Z+39	; 0x27

			pxTCB->eNotifyState = eNotified;
    3276:	92 e0       	ldi	r25, 0x02	; 2
    3278:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    327a:	22 30       	cpi	r18, 0x02	; 2
    327c:	b1 f0       	breq	.+44     	; 0x32aa <xTaskGenericNotify+0x5e>
    327e:	18 f4       	brcc	.+6      	; 0x3286 <xTaskGenericNotify+0x3a>
    3280:	21 30       	cpi	r18, 0x01	; 1
    3282:	31 f0       	breq	.+12     	; 0x3290 <xTaskGenericNotify+0x44>
    3284:	2a c0       	rjmp	.+84     	; 0x32da <xTaskGenericNotify+0x8e>
    3286:	23 30       	cpi	r18, 0x03	; 3
    3288:	e9 f0       	breq	.+58     	; 0x32c4 <xTaskGenericNotify+0x78>
    328a:	24 30       	cpi	r18, 0x04	; 4
    328c:	01 f1       	breq	.+64     	; 0x32ce <xTaskGenericNotify+0x82>
    328e:	25 c0       	rjmp	.+74     	; 0x32da <xTaskGenericNotify+0x8e>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    3290:	03 a1       	ldd	r16, Z+35	; 0x23
    3292:	14 a1       	ldd	r17, Z+36	; 0x24
    3294:	25 a1       	ldd	r18, Z+37	; 0x25
    3296:	36 a1       	ldd	r19, Z+38	; 0x26
    3298:	40 2b       	or	r20, r16
    329a:	51 2b       	or	r21, r17
    329c:	62 2b       	or	r22, r18
    329e:	73 2b       	or	r23, r19
    32a0:	43 a3       	std	Z+35, r20	; 0x23
    32a2:	54 a3       	std	Z+36, r21	; 0x24
    32a4:	65 a3       	std	Z+37, r22	; 0x25
    32a6:	76 a3       	std	Z+38, r23	; 0x26
					break;
    32a8:	18 c0       	rjmp	.+48     	; 0x32da <xTaskGenericNotify+0x8e>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    32aa:	43 a1       	ldd	r20, Z+35	; 0x23
    32ac:	54 a1       	ldd	r21, Z+36	; 0x24
    32ae:	65 a1       	ldd	r22, Z+37	; 0x25
    32b0:	76 a1       	ldd	r23, Z+38	; 0x26
    32b2:	4f 5f       	subi	r20, 0xFF	; 255
    32b4:	5f 4f       	sbci	r21, 0xFF	; 255
    32b6:	6f 4f       	sbci	r22, 0xFF	; 255
    32b8:	7f 4f       	sbci	r23, 0xFF	; 255
    32ba:	43 a3       	std	Z+35, r20	; 0x23
    32bc:	54 a3       	std	Z+36, r21	; 0x24
    32be:	65 a3       	std	Z+37, r22	; 0x25
    32c0:	76 a3       	std	Z+38, r23	; 0x26
					break;
    32c2:	0b c0       	rjmp	.+22     	; 0x32da <xTaskGenericNotify+0x8e>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    32c4:	43 a3       	std	Z+35, r20	; 0x23
    32c6:	54 a3       	std	Z+36, r21	; 0x24
    32c8:	65 a3       	std	Z+37, r22	; 0x25
    32ca:	76 a3       	std	Z+38, r23	; 0x26
					break;
    32cc:	06 c0       	rjmp	.+12     	; 0x32da <xTaskGenericNotify+0x8e>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    32ce:	82 30       	cpi	r24, 0x02	; 2
    32d0:	79 f1       	breq	.+94     	; 0x3330 <xTaskGenericNotify+0xe4>
					{
						pxTCB->ulNotifiedValue = ulValue;
    32d2:	43 a3       	std	Z+35, r20	; 0x23
    32d4:	54 a3       	std	Z+36, r21	; 0x24
    32d6:	65 a3       	std	Z+37, r22	; 0x25
    32d8:	76 a3       	std	Z+38, r23	; 0x26

			traceTASK_NOTIFY();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    32da:	81 30       	cpi	r24, 0x01	; 1
    32dc:	59 f5       	brne	.+86     	; 0x3334 <xTaskGenericNotify+0xe8>
    32de:	ef 01       	movw	r28, r30
			{
				( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    32e0:	8f 01       	movw	r16, r30
    32e2:	0e 5f       	subi	r16, 0xFE	; 254
    32e4:	1f 4f       	sbci	r17, 0xFF	; 255
    32e6:	c8 01       	movw	r24, r16
    32e8:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
				prvAddTaskToReadyList( pxTCB );
    32ec:	8e 89       	ldd	r24, Y+22	; 0x16
    32ee:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    32f2:	98 17       	cp	r25, r24
    32f4:	10 f4       	brcc	.+4      	; 0x32fa <xTaskGenericNotify+0xae>
    32f6:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    32fa:	90 e0       	ldi	r25, 0x00	; 0
    32fc:	9c 01       	movw	r18, r24
    32fe:	22 0f       	add	r18, r18
    3300:	33 1f       	adc	r19, r19
    3302:	22 0f       	add	r18, r18
    3304:	33 1f       	adc	r19, r19
    3306:	22 0f       	add	r18, r18
    3308:	33 1f       	adc	r19, r19
    330a:	82 0f       	add	r24, r18
    330c:	93 1f       	adc	r25, r19
    330e:	b8 01       	movw	r22, r16
    3310:	82 5f       	subi	r24, 0xF2	; 242
    3312:	99 4e       	sbci	r25, 0xE9	; 233
    3314:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
					earliest possible time. */
					prvResetNextTaskUnblockTime();
				}
				#endif

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    3318:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    331c:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    3320:	9e 89       	ldd	r25, Y+22	; 0x16
    3322:	86 89       	ldd	r24, Z+22	; 0x16
    3324:	89 17       	cp	r24, r25
    3326:	40 f4       	brcc	.+16     	; 0x3338 <xTaskGenericNotify+0xec>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					taskYIELD_IF_USING_PREEMPTION();
    3328:	0e 94 4d 0b 	call	0x169a	; 0x169a <vPortYield>
    332c:	81 e0       	ldi	r24, 0x01	; 1
    332e:	05 c0       	rjmp	.+10     	; 0x333a <xTaskGenericNotify+0xee>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3330:	80 e0       	ldi	r24, 0x00	; 0
    3332:	03 c0       	rjmp	.+6      	; 0x333a <xTaskGenericNotify+0xee>
    3334:	81 e0       	ldi	r24, 0x01	; 1
    3336:	01 c0       	rjmp	.+2      	; 0x333a <xTaskGenericNotify+0xee>
    3338:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}
		}
		taskEXIT_CRITICAL();
    333a:	0f 90       	pop	r0
    333c:	0f be       	out	0x3f, r0	; 63

		return xReturn;
	}
    333e:	df 91       	pop	r29
    3340:	cf 91       	pop	r28
    3342:	1f 91       	pop	r17
    3344:	0f 91       	pop	r16
    3346:	08 95       	ret

00003348 <xTaskGenericNotifyFromISR>:
/*-----------------------------------------------------------*/

#if( configUSE_TASK_NOTIFICATIONS == 1 )

	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
	{
    3348:	ef 92       	push	r14
    334a:	ff 92       	push	r15
    334c:	0f 93       	push	r16
    334e:	1f 93       	push	r17
    3350:	cf 93       	push	r28
    3352:	df 93       	push	r29
    3354:	fc 01       	movw	r30, r24

		pxTCB = ( TCB_t * ) xTaskToNotify;

		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
		{
			if( pulPreviousNotificationValue != NULL )
    3356:	01 15       	cp	r16, r1
    3358:	11 05       	cpc	r17, r1
    335a:	49 f0       	breq	.+18     	; 0x336e <xTaskGenericNotifyFromISR+0x26>
			{
				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
    335c:	83 a1       	ldd	r24, Z+35	; 0x23
    335e:	94 a1       	ldd	r25, Z+36	; 0x24
    3360:	a5 a1       	ldd	r26, Z+37	; 0x25
    3362:	b6 a1       	ldd	r27, Z+38	; 0x26
    3364:	e8 01       	movw	r28, r16
    3366:	88 83       	st	Y, r24
    3368:	99 83       	std	Y+1, r25	; 0x01
    336a:	aa 83       	std	Y+2, r26	; 0x02
    336c:	bb 83       	std	Y+3, r27	; 0x03
			}

			eOriginalNotifyState = pxTCB->eNotifyState;
    336e:	87 a1       	ldd	r24, Z+39	; 0x27
			pxTCB->eNotifyState = eNotified;
    3370:	92 e0       	ldi	r25, 0x02	; 2
    3372:	97 a3       	std	Z+39, r25	; 0x27

			switch( eAction )
    3374:	22 30       	cpi	r18, 0x02	; 2
    3376:	b1 f0       	breq	.+44     	; 0x33a4 <xTaskGenericNotifyFromISR+0x5c>
    3378:	18 f4       	brcc	.+6      	; 0x3380 <xTaskGenericNotifyFromISR+0x38>
    337a:	21 30       	cpi	r18, 0x01	; 1
    337c:	31 f0       	breq	.+12     	; 0x338a <xTaskGenericNotifyFromISR+0x42>
    337e:	2a c0       	rjmp	.+84     	; 0x33d4 <xTaskGenericNotifyFromISR+0x8c>
    3380:	23 30       	cpi	r18, 0x03	; 3
    3382:	e9 f0       	breq	.+58     	; 0x33be <xTaskGenericNotifyFromISR+0x76>
    3384:	24 30       	cpi	r18, 0x04	; 4
    3386:	01 f1       	breq	.+64     	; 0x33c8 <xTaskGenericNotifyFromISR+0x80>
    3388:	25 c0       	rjmp	.+74     	; 0x33d4 <xTaskGenericNotifyFromISR+0x8c>
			{
				case eSetBits	:
					pxTCB->ulNotifiedValue |= ulValue;
    338a:	03 a1       	ldd	r16, Z+35	; 0x23
    338c:	14 a1       	ldd	r17, Z+36	; 0x24
    338e:	25 a1       	ldd	r18, Z+37	; 0x25
    3390:	36 a1       	ldd	r19, Z+38	; 0x26
    3392:	40 2b       	or	r20, r16
    3394:	51 2b       	or	r21, r17
    3396:	62 2b       	or	r22, r18
    3398:	73 2b       	or	r23, r19
    339a:	43 a3       	std	Z+35, r20	; 0x23
    339c:	54 a3       	std	Z+36, r21	; 0x24
    339e:	65 a3       	std	Z+37, r22	; 0x25
    33a0:	76 a3       	std	Z+38, r23	; 0x26
					break;
    33a2:	18 c0       	rjmp	.+48     	; 0x33d4 <xTaskGenericNotifyFromISR+0x8c>

				case eIncrement	:
					( pxTCB->ulNotifiedValue )++;
    33a4:	43 a1       	ldd	r20, Z+35	; 0x23
    33a6:	54 a1       	ldd	r21, Z+36	; 0x24
    33a8:	65 a1       	ldd	r22, Z+37	; 0x25
    33aa:	76 a1       	ldd	r23, Z+38	; 0x26
    33ac:	4f 5f       	subi	r20, 0xFF	; 255
    33ae:	5f 4f       	sbci	r21, 0xFF	; 255
    33b0:	6f 4f       	sbci	r22, 0xFF	; 255
    33b2:	7f 4f       	sbci	r23, 0xFF	; 255
    33b4:	43 a3       	std	Z+35, r20	; 0x23
    33b6:	54 a3       	std	Z+36, r21	; 0x24
    33b8:	65 a3       	std	Z+37, r22	; 0x25
    33ba:	76 a3       	std	Z+38, r23	; 0x26
					break;
    33bc:	0b c0       	rjmp	.+22     	; 0x33d4 <xTaskGenericNotifyFromISR+0x8c>

				case eSetValueWithOverwrite	:
					pxTCB->ulNotifiedValue = ulValue;
    33be:	43 a3       	std	Z+35, r20	; 0x23
    33c0:	54 a3       	std	Z+36, r21	; 0x24
    33c2:	65 a3       	std	Z+37, r22	; 0x25
    33c4:	76 a3       	std	Z+38, r23	; 0x26
					break;
    33c6:	06 c0       	rjmp	.+12     	; 0x33d4 <xTaskGenericNotifyFromISR+0x8c>

				case eSetValueWithoutOverwrite :
					if( eOriginalNotifyState != eNotified )
    33c8:	82 30       	cpi	r24, 0x02	; 2
    33ca:	f1 f1       	breq	.+124    	; 0x3448 <xTaskGenericNotifyFromISR+0x100>
					{
						pxTCB->ulNotifiedValue = ulValue;
    33cc:	43 a3       	std	Z+35, r20	; 0x23
    33ce:	54 a3       	std	Z+36, r21	; 0x24
    33d0:	65 a3       	std	Z+37, r22	; 0x25
    33d2:	76 a3       	std	Z+38, r23	; 0x26

			traceTASK_NOTIFY_FROM_ISR();

			/* If the task is in the blocked state specifically to wait for a
			notification then unblock it now. */
			if( eOriginalNotifyState == eWaitingNotification )
    33d4:	81 30       	cpi	r24, 0x01	; 1
    33d6:	d1 f5       	brne	.+116    	; 0x344c <xTaskGenericNotifyFromISR+0x104>
    33d8:	ef 01       	movw	r28, r30
			{
				/* The task should not have been on an event list. */
				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );

				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
    33da:	80 91 da 15 	lds	r24, 0x15DA	; 0x8015da <uxSchedulerSuspended>
    33de:	81 11       	cpse	r24, r1
    33e0:	1d c0       	rjmp	.+58     	; 0x341c <xTaskGenericNotifyFromISR+0xd4>
				{
					( void ) uxListRemove( &( pxTCB->xGenericListItem ) );
    33e2:	8f 01       	movw	r16, r30
    33e4:	0e 5f       	subi	r16, 0xFE	; 254
    33e6:	1f 4f       	sbci	r17, 0xFF	; 255
    33e8:	c8 01       	movw	r24, r16
    33ea:	0e 94 8a 08 	call	0x1114	; 0x1114 <uxListRemove>
					prvAddTaskToReadyList( pxTCB );
    33ee:	8e 89       	ldd	r24, Y+22	; 0x16
    33f0:	90 91 e2 15 	lds	r25, 0x15E2	; 0x8015e2 <uxTopReadyPriority>
    33f4:	98 17       	cp	r25, r24
    33f6:	10 f4       	brcc	.+4      	; 0x33fc <xTaskGenericNotifyFromISR+0xb4>
    33f8:	80 93 e2 15 	sts	0x15E2, r24	; 0x8015e2 <uxTopReadyPriority>
    33fc:	90 e0       	ldi	r25, 0x00	; 0
    33fe:	9c 01       	movw	r18, r24
    3400:	22 0f       	add	r18, r18
    3402:	33 1f       	adc	r19, r19
    3404:	22 0f       	add	r18, r18
    3406:	33 1f       	adc	r19, r19
    3408:	22 0f       	add	r18, r18
    340a:	33 1f       	adc	r19, r19
    340c:	82 0f       	add	r24, r18
    340e:	93 1f       	adc	r25, r19
    3410:	b8 01       	movw	r22, r16
    3412:	82 5f       	subi	r24, 0xF2	; 242
    3414:	99 4e       	sbci	r25, 0xE9	; 233
    3416:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
    341a:	07 c0       	rjmp	.+14     	; 0x342a <xTaskGenericNotifyFromISR+0xe2>
				}
				else
				{
					/* The delayed and ready lists cannot be accessed, so hold
					this task pending until the scheduler is resumed. */
					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    341c:	bf 01       	movw	r22, r30
    341e:	64 5f       	subi	r22, 0xF4	; 244
    3420:	7f 4f       	sbci	r23, 0xFF	; 255
    3422:	8f ee       	ldi	r24, 0xEF	; 239
    3424:	95 e1       	ldi	r25, 0x15	; 21
    3426:	0e 94 38 08 	call	0x1070	; 0x1070 <vListInsertEnd>
				}

				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
    342a:	e0 91 44 16 	lds	r30, 0x1644	; 0x801644 <pxCurrentTCB>
    342e:	f0 91 45 16 	lds	r31, 0x1645	; 0x801645 <pxCurrentTCB+0x1>
    3432:	9e 89       	ldd	r25, Y+22	; 0x16
    3434:	86 89       	ldd	r24, Z+22	; 0x16
    3436:	89 17       	cp	r24, r25
    3438:	58 f4       	brcc	.+22     	; 0x3450 <xTaskGenericNotifyFromISR+0x108>
				{
					/* The notified task has a priority above the currently
					executing task so a yield is required. */
					if( pxHigherPriorityTaskWoken != NULL )
    343a:	e1 14       	cp	r14, r1
    343c:	f1 04       	cpc	r15, r1
    343e:	51 f0       	breq	.+20     	; 0x3454 <xTaskGenericNotifyFromISR+0x10c>
					{
						*pxHigherPriorityTaskWoken = pdTRUE;
    3440:	81 e0       	ldi	r24, 0x01	; 1
    3442:	f7 01       	movw	r30, r14
    3444:	80 83       	st	Z, r24
    3446:	07 c0       	rjmp	.+14     	; 0x3456 <xTaskGenericNotifyFromISR+0x10e>
						pxTCB->ulNotifiedValue = ulValue;
					}
					else
					{
						/* The value could not be written to the task. */
						xReturn = pdFAIL;
    3448:	80 e0       	ldi	r24, 0x00	; 0
    344a:	05 c0       	rjmp	.+10     	; 0x3456 <xTaskGenericNotifyFromISR+0x10e>
    344c:	81 e0       	ldi	r24, 0x01	; 1
    344e:	03 c0       	rjmp	.+6      	; 0x3456 <xTaskGenericNotifyFromISR+0x10e>
    3450:	81 e0       	ldi	r24, 0x01	; 1
    3452:	01 c0       	rjmp	.+2      	; 0x3456 <xTaskGenericNotifyFromISR+0x10e>
    3454:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

		return xReturn;
	}
    3456:	df 91       	pop	r29
    3458:	cf 91       	pop	r28
    345a:	1f 91       	pop	r17
    345c:	0f 91       	pop	r16
    345e:	ff 90       	pop	r15
    3460:	ef 90       	pop	r14
    3462:	08 95       	ret

00003464 <vFrameReaderTask>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
}

void vFrameReaderTask( void *pvParameters ){
    3464:	cf 93       	push	r28
    3466:	df 93       	push	r29
    3468:	00 d0       	rcall	.+0      	; 0x346a <vFrameReaderTask+0x6>
    346a:	1f 92       	push	r1
    346c:	cd b7       	in	r28, 0x3d	; 61
    346e:	de b7       	in	r29, 0x3e	; 62
	frame_receiver = xTaskGetCurrentTaskHandle();
    3470:	65 dd       	rcall	.-1334   	; 0x2f3c <xTaskGetCurrentTaskHandle>
    3472:	90 93 ad 16 	sts	0x16AD, r25	; 0x8016ad <frame_receiver+0x1>
    3476:	80 93 ac 16 	sts	0x16AC, r24	; 0x8016ac <frame_receiver>
	uint32_t notification_value = 0;
    347a:	19 82       	std	Y+1, r1	; 0x01
    347c:	1a 82       	std	Y+2, r1	; 0x02
    347e:	1b 82       	std	Y+3, r1	; 0x03
    3480:	1c 82       	std	Y+4, r1	; 0x04
	while(1){
		xTaskNotifyWait(0xFFFFFFFF, 0xFFFFFFFF, &notification_value, portMAX_DELAY);
    3482:	ee 24       	eor	r14, r14
    3484:	ea 94       	dec	r14
    3486:	fe 2c       	mov	r15, r14
    3488:	8e 01       	movw	r16, r28
    348a:	0f 5f       	subi	r16, 0xFF	; 255
    348c:	1f 4f       	sbci	r17, 0xFF	; 255
    348e:	2f ef       	ldi	r18, 0xFF	; 255
    3490:	3f ef       	ldi	r19, 0xFF	; 255
    3492:	a9 01       	movw	r20, r18
    3494:	6f ef       	ldi	r22, 0xFF	; 255
    3496:	7f ef       	ldi	r23, 0xFF	; 255
    3498:	cb 01       	movw	r24, r22
    349a:	09 de       	rcall	.-1006   	; 0x30ae <xTaskNotifyWait>
		if(receive_callback != NULL) receive_callback(receive_buffer, (uint16_t)notification_value);
    349c:	e0 91 0e 17 	lds	r30, 0x170E	; 0x80170e <receive_callback>
    34a0:	f0 91 0f 17 	lds	r31, 0x170F	; 0x80170f <receive_callback+0x1>
    34a4:	30 97       	sbiw	r30, 0x00	; 0
    34a6:	69 f3       	breq	.-38     	; 0x3482 <vFrameReaderTask+0x1e>
    34a8:	69 81       	ldd	r22, Y+1	; 0x01
    34aa:	7a 81       	ldd	r23, Y+2	; 0x02
    34ac:	80 e1       	ldi	r24, 0x10	; 16
    34ae:	97 e1       	ldi	r25, 0x17	; 23
    34b0:	19 95       	eicall
    34b2:	e7 cf       	rjmp	.-50     	; 0x3482 <vFrameReaderTask+0x1e>

000034b4 <vUartSendTask>:
	}
}

void vUartSendTask(void *pvParamters) {
    34b4:	cf 93       	push	r28
    34b6:	df 93       	push	r29
    34b8:	cd b7       	in	r28, 0x3d	; 61
    34ba:	de b7       	in	r29, 0x3e	; 62
    34bc:	c4 56       	subi	r28, 0x64	; 100
    34be:	d1 09       	sbc	r29, r1
    34c0:	0f b6       	in	r0, 0x3f	; 63
    34c2:	f8 94       	cli
    34c4:	de bf       	out	0x3e, r29	; 62
    34c6:	0f be       	out	0x3f, r0	; 63
    34c8:	cd bf       	out	0x3d, r28	; 61
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    34ca:	00 ed       	ldi	r16, 0xD0	; 208
    34cc:	10 e0       	ldi	r17, 0x00	; 0
				UDR2 = data[i];
    34ce:	0f 2e       	mov	r0, r31
    34d0:	f6 ed       	ldi	r31, 0xD6	; 214
    34d2:	ef 2e       	mov	r14, r31
    34d4:	f1 2c       	mov	r15, r1
    34d6:	f0 2d       	mov	r31, r0
void vUartSendTask(void *pvParamters) {
	uint8_t data[100];
	uint16_t num;
	uint16_t i;
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
    34d8:	20 e0       	ldi	r18, 0x00	; 0
    34da:	4f ef       	ldi	r20, 0xFF	; 255
    34dc:	5f ef       	ldi	r21, 0xFF	; 255
    34de:	60 e0       	ldi	r22, 0x00	; 0
    34e0:	70 e0       	ldi	r23, 0x00	; 0
    34e2:	80 91 d2 16 	lds	r24, 0x16D2	; 0x8016d2 <xUartMutex>
    34e6:	90 91 d3 16 	lds	r25, 0x16D3	; 0x8016d3 <xUartMutex+0x1>
    34ea:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <xQueueGenericReceive>
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
    34ee:	24 e6       	ldi	r18, 0x64	; 100
    34f0:	30 e0       	ldi	r19, 0x00	; 0
    34f2:	40 e0       	ldi	r20, 0x00	; 0
    34f4:	be 01       	movw	r22, r28
    34f6:	6f 5f       	subi	r22, 0xFF	; 255
    34f8:	7f 4f       	sbci	r23, 0xFF	; 255
    34fa:	84 e7       	ldi	r24, 0x74	; 116
    34fc:	97 e1       	ldi	r25, 0x17	; 23
    34fe:	0e 94 04 03 	call	0x608	; 0x608 <buffer_remove_token>
    3502:	6c 01       	movw	r12, r24
		xSemaphoreGive(xUartMutex);
    3504:	60 e0       	ldi	r22, 0x00	; 0
    3506:	70 e0       	ldi	r23, 0x00	; 0
    3508:	80 91 d2 16 	lds	r24, 0x16D2	; 0x8016d2 <xUartMutex>
    350c:	90 91 d3 16 	lds	r25, 0x16D3	; 0x8016d3 <xUartMutex+0x1>
    3510:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <xQueueGive>
		if(num>0) {
    3514:	c1 14       	cp	r12, r1
    3516:	d1 04       	cpc	r13, r1
    3518:	79 f0       	breq	.+30     	; 0x3538 <vUartSendTask+0x84>
    351a:	fe 01       	movw	r30, r28
    351c:	31 96       	adiw	r30, 0x01	; 1
    351e:	9f 01       	movw	r18, r30
    3520:	2c 0d       	add	r18, r12
    3522:	3d 1d       	adc	r19, r13
			for(i=0;i<num;i++) {
				while ( !( UCSR2A & (1<<UDRE2)) );
    3524:	d8 01       	movw	r26, r16
    3526:	8c 91       	ld	r24, X
    3528:	85 ff       	sbrs	r24, 5
    352a:	fc cf       	rjmp	.-8      	; 0x3524 <vUartSendTask+0x70>
				UDR2 = data[i];
    352c:	81 91       	ld	r24, Z+
    352e:	d7 01       	movw	r26, r14
    3530:	8c 93       	st	X, r24
	while(1){
		xSemaphoreTake(xUartMutex, portMAX_DELAY);
		num = buffer_remove_token(&send_buffer, data, 0x00, 100);
		xSemaphoreGive(xUartMutex);
		if(num>0) {
			for(i=0;i<num;i++) {
    3532:	2e 17       	cp	r18, r30
    3534:	3f 07       	cpc	r19, r31
    3536:	b1 f7       	brne	.-20     	; 0x3524 <vUartSendTask+0x70>
				while ( !( UCSR2A & (1<<UDRE2)) );
				UDR2 = data[i];
			}
		}
		vTaskDelay(10*portTICK_PERIOD_MS);
    3538:	8a e0       	ldi	r24, 0x0A	; 10
    353a:	90 e0       	ldi	r25, 0x00	; 0
    353c:	03 d8       	rcall	.-4090   	; 0x2544 <vTaskDelay>
	}
    353e:	cc cf       	rjmp	.-104    	; 0x34d8 <vUartSendTask+0x24>

00003540 <vUSART_init>:
/************************************************************************/
//Initialize USART driver, note that RXD0/TXD0 (PD0/PD1) is used
// Note that the nRF51 dongle is limited to send 20 characters
// in each package
/************************************************************************/
void vUSART_init(){
    3540:	af 92       	push	r10
    3542:	bf 92       	push	r11
    3544:	cf 92       	push	r12
    3546:	df 92       	push	r13
    3548:	ef 92       	push	r14
    354a:	ff 92       	push	r15
    354c:	0f 93       	push	r16
    /* Set baud rate, has to match nRF51 dongle! */
    UBRR2H = (unsigned char)(BAUD_PRESCALE>>8);
    354e:	10 92 d5 00 	sts	0x00D5, r1	; 0x8000d5 <__TEXT_REGION_LENGTH__+0x7000d5>
    UBRR2L = (unsigned char)BAUD_PRESCALE;
    3552:	89 e1       	ldi	r24, 0x19	; 25
    3554:	80 93 d4 00 	sts	0x00D4, r24	; 0x8000d4 <__TEXT_REGION_LENGTH__+0x7000d4>
    
    /* RX/TX Complete, data register empty */
    UCSR2A = (1<<RXC2) | (1<<TXC2) | (1<<UDRE2);
    3558:	80 ee       	ldi	r24, 0xE0	; 224
    355a:	80 93 d0 00 	sts	0x00D0, r24	; 0x8000d0 <__TEXT_REGION_LENGTH__+0x7000d0>

    /* Enable reciever, transmitter, and recieve interrupt enable*/
    UCSR2B = (1<<RXEN2) | (1<<TXEN2) | (1<<RXCIE2);
    355e:	88 e9       	ldi	r24, 0x98	; 152
    3560:	80 93 d1 00 	sts	0x00D1, r24	; 0x8000d1 <__TEXT_REGION_LENGTH__+0x7000d1>

    /* Set frame format: 8data, 1 stop bit, no parity */
    UCSR2C = (1<<UCSZ20) | (1<<UCSZ21);
    3564:	e2 ed       	ldi	r30, 0xD2	; 210
    3566:	f0 e0       	ldi	r31, 0x00	; 0
    3568:	86 e0       	ldi	r24, 0x06	; 6
    356a:	80 83       	st	Z, r24
    UCSR2C &= ~((1<<USBS2) & (1<<UPM21) & (1<<UPM20));
    356c:	80 81       	ld	r24, Z
    356e:	80 83       	st	Z, r24

	uint8_t *buf = pvPortMalloc(100);
    3570:	84 e6       	ldi	r24, 0x64	; 100
    3572:	90 e0       	ldi	r25, 0x00	; 0
    3574:	0e 94 c9 04 	call	0x992	; 0x992 <pvPortMalloc>
	buffer_init(&send_buffer, buf, 100);
    3578:	44 e6       	ldi	r20, 0x64	; 100
    357a:	50 e0       	ldi	r21, 0x00	; 0
    357c:	bc 01       	movw	r22, r24
    357e:	84 e7       	ldi	r24, 0x74	; 116
    3580:	97 e1       	ldi	r25, 0x17	; 23
    3582:	0e 94 8e 02 	call	0x51c	; 0x51c <buffer_init>
	xTaskCreate(vFrameReaderTask, "FrameReader", 300, NULL, 4, NULL);
    3586:	a1 2c       	mov	r10, r1
    3588:	b1 2c       	mov	r11, r1
    358a:	c1 2c       	mov	r12, r1
    358c:	d1 2c       	mov	r13, r1
    358e:	e1 2c       	mov	r14, r1
    3590:	f1 2c       	mov	r15, r1
    3592:	04 e0       	ldi	r16, 0x04	; 4
    3594:	20 e0       	ldi	r18, 0x00	; 0
    3596:	30 e0       	ldi	r19, 0x00	; 0
    3598:	4c e2       	ldi	r20, 0x2C	; 44
    359a:	51 e0       	ldi	r21, 0x01	; 1
    359c:	66 eb       	ldi	r22, 0xB6	; 182
    359e:	72 e0       	ldi	r23, 0x02	; 2
    35a0:	82 e3       	ldi	r24, 0x32	; 50
    35a2:	9a e1       	ldi	r25, 0x1A	; 26
    35a4:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskGenericCreate>
	xTaskCreate(vUartSendTask, "UartSendTask", 300, NULL, 4, NULL);
    35a8:	20 e0       	ldi	r18, 0x00	; 0
    35aa:	30 e0       	ldi	r19, 0x00	; 0
    35ac:	4c e2       	ldi	r20, 0x2C	; 44
    35ae:	51 e0       	ldi	r21, 0x01	; 1
    35b0:	62 ec       	ldi	r22, 0xC2	; 194
    35b2:	72 e0       	ldi	r23, 0x02	; 2
    35b4:	8a e5       	ldi	r24, 0x5A	; 90
    35b6:	9a e1       	ldi	r25, 0x1A	; 26
    35b8:	0e 94 90 11 	call	0x2320	; 0x2320 <xTaskGenericCreate>
	
	xUartMutex = xSemaphoreCreateMutex();
    35bc:	81 e0       	ldi	r24, 0x01	; 1
    35be:	0e 94 28 0c 	call	0x1850	; 0x1850 <xQueueCreateMutex>
    35c2:	90 93 d3 16 	sts	0x16D3, r25	; 0x8016d3 <xUartMutex+0x1>
    35c6:	80 93 d2 16 	sts	0x16D2, r24	; 0x8016d2 <xUartMutex>
}
    35ca:	0f 91       	pop	r16
    35cc:	ff 90       	pop	r15
    35ce:	ef 90       	pop	r14
    35d0:	df 90       	pop	r13
    35d2:	cf 90       	pop	r12
    35d4:	bf 90       	pop	r11
    35d6:	af 90       	pop	r10
    35d8:	08 95       	ret

000035da <vUSART_send>:

void vUSART_send(uint8_t *data, uint16_t len) {
    35da:	0f 93       	push	r16
    35dc:	1f 93       	push	r17
    35de:	cf 93       	push	r28
    35e0:	df 93       	push	r29
    35e2:	ec 01       	movw	r28, r24
    35e4:	8b 01       	movw	r16, r22
	xSemaphoreTake(xUartMutex, portMAX_DELAY);
    35e6:	20 e0       	ldi	r18, 0x00	; 0
    35e8:	4f ef       	ldi	r20, 0xFF	; 255
    35ea:	5f ef       	ldi	r21, 0xFF	; 255
    35ec:	60 e0       	ldi	r22, 0x00	; 0
    35ee:	70 e0       	ldi	r23, 0x00	; 0
    35f0:	80 91 d2 16 	lds	r24, 0x16D2	; 0x8016d2 <xUartMutex>
    35f4:	90 91 d3 16 	lds	r25, 0x16D3	; 0x8016d3 <xUartMutex+0x1>
    35f8:	0e 94 3a 0f 	call	0x1e74	; 0x1e74 <xQueueGenericReceive>
	buffer_append(&send_buffer, data, len);
    35fc:	a8 01       	movw	r20, r16
    35fe:	be 01       	movw	r22, r28
    3600:	84 e7       	ldi	r24, 0x74	; 116
    3602:	97 e1       	ldi	r25, 0x17	; 23
    3604:	0e 94 a0 02 	call	0x540	; 0x540 <buffer_append>
	xSemaphoreGive(xUartMutex);
    3608:	60 e0       	ldi	r22, 0x00	; 0
    360a:	70 e0       	ldi	r23, 0x00	; 0
    360c:	80 91 d2 16 	lds	r24, 0x16D2	; 0x8016d2 <xUartMutex>
    3610:	90 91 d3 16 	lds	r25, 0x16D3	; 0x8016d3 <xUartMutex+0x1>
    3614:	0e 94 a3 0d 	call	0x1b46	; 0x1b46 <xQueueGive>
}
    3618:	df 91       	pop	r29
    361a:	cf 91       	pop	r28
    361c:	1f 91       	pop	r17
    361e:	0f 91       	pop	r16
    3620:	08 95       	ret

00003622 <vUSART_set_receive_callback>:

void vUSART_set_receive_callback(void(*cb)(uint8_t*, uint16_t)) {
	receive_callback = cb;
    3622:	90 93 0f 17 	sts	0x170F, r25	; 0x80170f <receive_callback+0x1>
    3626:	80 93 0e 17 	sts	0x170E, r24	; 0x80170e <receive_callback>
    362a:	08 95       	ret

0000362c <__vector_51>:
		vTaskDelay(10*portTICK_PERIOD_MS);
	}
}


ISR(USART2_RX_vect){
    362c:	1f 92       	push	r1
    362e:	0f 92       	push	r0
    3630:	0f b6       	in	r0, 0x3f	; 63
    3632:	0f 92       	push	r0
    3634:	11 24       	eor	r1, r1
    3636:	0b b6       	in	r0, 0x3b	; 59
    3638:	0f 92       	push	r0
    363a:	cf 92       	push	r12
    363c:	df 92       	push	r13
    363e:	ef 92       	push	r14
    3640:	ff 92       	push	r15
    3642:	0f 93       	push	r16
    3644:	1f 93       	push	r17
    3646:	2f 93       	push	r18
    3648:	3f 93       	push	r19
    364a:	4f 93       	push	r20
    364c:	5f 93       	push	r21
    364e:	6f 93       	push	r22
    3650:	7f 93       	push	r23
    3652:	8f 93       	push	r24
    3654:	9f 93       	push	r25
    3656:	af 93       	push	r26
    3658:	bf 93       	push	r27
    365a:	cf 93       	push	r28
    365c:	df 93       	push	r29
    365e:	ef 93       	push	r30
    3660:	ff 93       	push	r31
	static uint8_t input_buffer[100];
	static uint16_t input_index = 0;
	input_buffer[input_index++] = UDR2;
    3662:	80 91 aa 16 	lds	r24, 0x16AA	; 0x8016aa <input_index.2398>
    3666:	90 91 ab 16 	lds	r25, 0x16AB	; 0x8016ab <input_index.2398+0x1>
    366a:	ec 01       	movw	r28, r24
    366c:	21 96       	adiw	r28, 0x01	; 1
    366e:	d0 93 ab 16 	sts	0x16AB, r29	; 0x8016ab <input_index.2398+0x1>
    3672:	c0 93 aa 16 	sts	0x16AA, r28	; 0x8016aa <input_index.2398>
    3676:	20 91 d6 00 	lds	r18, 0x00D6	; 0x8000d6 <__TEXT_REGION_LENGTH__+0x7000d6>
    367a:	fc 01       	movw	r30, r24
    367c:	ea 5b       	subi	r30, 0xBA	; 186
    367e:	f9 4e       	sbci	r31, 0xE9	; 233
    3680:	20 83       	st	Z, r18
	if(input_buffer[input_index-1] == 0x00) {
    3682:	21 11       	cpse	r18, r1
    3684:	1c c0       	rjmp	.+56     	; 0x36be <__vector_51+0x92>
		if(frame_receiver != NULL) {
    3686:	c0 90 ac 16 	lds	r12, 0x16AC	; 0x8016ac <frame_receiver>
    368a:	d0 90 ad 16 	lds	r13, 0x16AD	; 0x8016ad <frame_receiver+0x1>
    368e:	c1 14       	cp	r12, r1
    3690:	d1 04       	cpc	r13, r1
    3692:	81 f0       	breq	.+32     	; 0x36b4 <__vector_51+0x88>
			memcpy(receive_buffer, input_buffer, input_index);
    3694:	ae 01       	movw	r20, r28
    3696:	66 e4       	ldi	r22, 0x46	; 70
    3698:	76 e1       	ldi	r23, 0x16	; 22
    369a:	80 e1       	ldi	r24, 0x10	; 16
    369c:	97 e1       	ldi	r25, 0x17	; 23
    369e:	9d d4       	rcall	.+2362   	; 0x3fda <memcpy>
			xTaskNotifyFromISR(frame_receiver, input_index, eSetValueWithoutOverwrite, NULL);
    36a0:	ae 01       	movw	r20, r28
    36a2:	60 e0       	ldi	r22, 0x00	; 0
    36a4:	70 e0       	ldi	r23, 0x00	; 0
    36a6:	e1 2c       	mov	r14, r1
    36a8:	f1 2c       	mov	r15, r1
    36aa:	00 e0       	ldi	r16, 0x00	; 0
    36ac:	10 e0       	ldi	r17, 0x00	; 0
    36ae:	24 e0       	ldi	r18, 0x04	; 4
    36b0:	c6 01       	movw	r24, r12
    36b2:	4a de       	rcall	.-876    	; 0x3348 <xTaskGenericNotifyFromISR>
		}
		input_index = 0;
    36b4:	10 92 ab 16 	sts	0x16AB, r1	; 0x8016ab <input_index.2398+0x1>
    36b8:	10 92 aa 16 	sts	0x16AA, r1	; 0x8016aa <input_index.2398>
    36bc:	07 c0       	rjmp	.+14     	; 0x36cc <__vector_51+0xa0>
	}
	if(input_index > 100) input_index = 0; // Something went wrong, received too many bytes
    36be:	c5 36       	cpi	r28, 0x65	; 101
    36c0:	d1 05       	cpc	r29, r1
    36c2:	20 f0       	brcs	.+8      	; 0x36cc <__vector_51+0xa0>
    36c4:	10 92 ab 16 	sts	0x16AB, r1	; 0x8016ab <input_index.2398+0x1>
    36c8:	10 92 aa 16 	sts	0x16AA, r1	; 0x8016aa <input_index.2398>
    36cc:	ff 91       	pop	r31
    36ce:	ef 91       	pop	r30
    36d0:	df 91       	pop	r29
    36d2:	cf 91       	pop	r28
    36d4:	bf 91       	pop	r27
    36d6:	af 91       	pop	r26
    36d8:	9f 91       	pop	r25
    36da:	8f 91       	pop	r24
    36dc:	7f 91       	pop	r23
    36de:	6f 91       	pop	r22
    36e0:	5f 91       	pop	r21
    36e2:	4f 91       	pop	r20
    36e4:	3f 91       	pop	r19
    36e6:	2f 91       	pop	r18
    36e8:	1f 91       	pop	r17
    36ea:	0f 91       	pop	r16
    36ec:	ff 90       	pop	r15
    36ee:	ef 90       	pop	r14
    36f0:	df 90       	pop	r13
    36f2:	cf 90       	pop	r12
    36f4:	0f 90       	pop	r0
    36f6:	0b be       	out	0x3b, r0	; 59
    36f8:	0f 90       	pop	r0
    36fa:	0f be       	out	0x3f, r0	; 63
    36fc:	0f 90       	pop	r0
    36fe:	1f 90       	pop	r1
    3700:	18 95       	reti

00003702 <vfprintf>:
    3702:	2f 92       	push	r2
    3704:	3f 92       	push	r3
    3706:	4f 92       	push	r4
    3708:	5f 92       	push	r5
    370a:	6f 92       	push	r6
    370c:	7f 92       	push	r7
    370e:	8f 92       	push	r8
    3710:	9f 92       	push	r9
    3712:	af 92       	push	r10
    3714:	bf 92       	push	r11
    3716:	cf 92       	push	r12
    3718:	df 92       	push	r13
    371a:	ef 92       	push	r14
    371c:	ff 92       	push	r15
    371e:	0f 93       	push	r16
    3720:	1f 93       	push	r17
    3722:	cf 93       	push	r28
    3724:	df 93       	push	r29
    3726:	cd b7       	in	r28, 0x3d	; 61
    3728:	de b7       	in	r29, 0x3e	; 62
    372a:	60 97       	sbiw	r28, 0x10	; 16
    372c:	0f b6       	in	r0, 0x3f	; 63
    372e:	f8 94       	cli
    3730:	de bf       	out	0x3e, r29	; 62
    3732:	0f be       	out	0x3f, r0	; 63
    3734:	cd bf       	out	0x3d, r28	; 61
    3736:	7c 01       	movw	r14, r24
    3738:	1b 01       	movw	r2, r22
    373a:	6a 01       	movw	r12, r20
    373c:	fc 01       	movw	r30, r24
    373e:	17 82       	std	Z+7, r1	; 0x07
    3740:	16 82       	std	Z+6, r1	; 0x06
    3742:	83 81       	ldd	r24, Z+3	; 0x03
    3744:	81 ff       	sbrs	r24, 1
    3746:	2a c3       	rjmp	.+1620   	; 0x3d9c <vfprintf+0x69a>
    3748:	9e 01       	movw	r18, r28
    374a:	2f 5f       	subi	r18, 0xFF	; 255
    374c:	3f 4f       	sbci	r19, 0xFF	; 255
    374e:	39 01       	movw	r6, r18
    3750:	f7 01       	movw	r30, r14
    3752:	93 81       	ldd	r25, Z+3	; 0x03
    3754:	f1 01       	movw	r30, r2
    3756:	93 fd       	sbrc	r25, 3
    3758:	85 91       	lpm	r24, Z+
    375a:	93 ff       	sbrs	r25, 3
    375c:	81 91       	ld	r24, Z+
    375e:	1f 01       	movw	r2, r30
    3760:	88 23       	and	r24, r24
    3762:	09 f4       	brne	.+2      	; 0x3766 <vfprintf+0x64>
    3764:	17 c3       	rjmp	.+1582   	; 0x3d94 <vfprintf+0x692>
    3766:	85 32       	cpi	r24, 0x25	; 37
    3768:	39 f4       	brne	.+14     	; 0x3778 <vfprintf+0x76>
    376a:	93 fd       	sbrc	r25, 3
    376c:	85 91       	lpm	r24, Z+
    376e:	93 ff       	sbrs	r25, 3
    3770:	81 91       	ld	r24, Z+
    3772:	1f 01       	movw	r2, r30
    3774:	85 32       	cpi	r24, 0x25	; 37
    3776:	31 f4       	brne	.+12     	; 0x3784 <vfprintf+0x82>
    3778:	b7 01       	movw	r22, r14
    377a:	90 e0       	ldi	r25, 0x00	; 0
    377c:	42 d4       	rcall	.+2180   	; 0x4002 <fputc>
    377e:	56 01       	movw	r10, r12
    3780:	65 01       	movw	r12, r10
    3782:	e6 cf       	rjmp	.-52     	; 0x3750 <vfprintf+0x4e>
    3784:	10 e0       	ldi	r17, 0x00	; 0
    3786:	51 2c       	mov	r5, r1
    3788:	91 2c       	mov	r9, r1
    378a:	ff e1       	ldi	r31, 0x1F	; 31
    378c:	f9 15       	cp	r31, r9
    378e:	d8 f0       	brcs	.+54     	; 0x37c6 <vfprintf+0xc4>
    3790:	8b 32       	cpi	r24, 0x2B	; 43
    3792:	79 f0       	breq	.+30     	; 0x37b2 <vfprintf+0xb0>
    3794:	38 f4       	brcc	.+14     	; 0x37a4 <vfprintf+0xa2>
    3796:	80 32       	cpi	r24, 0x20	; 32
    3798:	79 f0       	breq	.+30     	; 0x37b8 <vfprintf+0xb6>
    379a:	83 32       	cpi	r24, 0x23	; 35
    379c:	a1 f4       	brne	.+40     	; 0x37c6 <vfprintf+0xc4>
    379e:	f9 2d       	mov	r31, r9
    37a0:	f0 61       	ori	r31, 0x10	; 16
    37a2:	2e c0       	rjmp	.+92     	; 0x3800 <vfprintf+0xfe>
    37a4:	8d 32       	cpi	r24, 0x2D	; 45
    37a6:	61 f0       	breq	.+24     	; 0x37c0 <vfprintf+0xbe>
    37a8:	80 33       	cpi	r24, 0x30	; 48
    37aa:	69 f4       	brne	.+26     	; 0x37c6 <vfprintf+0xc4>
    37ac:	29 2d       	mov	r18, r9
    37ae:	21 60       	ori	r18, 0x01	; 1
    37b0:	2d c0       	rjmp	.+90     	; 0x380c <vfprintf+0x10a>
    37b2:	39 2d       	mov	r19, r9
    37b4:	32 60       	ori	r19, 0x02	; 2
    37b6:	93 2e       	mov	r9, r19
    37b8:	89 2d       	mov	r24, r9
    37ba:	84 60       	ori	r24, 0x04	; 4
    37bc:	98 2e       	mov	r9, r24
    37be:	2a c0       	rjmp	.+84     	; 0x3814 <vfprintf+0x112>
    37c0:	e9 2d       	mov	r30, r9
    37c2:	e8 60       	ori	r30, 0x08	; 8
    37c4:	15 c0       	rjmp	.+42     	; 0x37f0 <vfprintf+0xee>
    37c6:	97 fc       	sbrc	r9, 7
    37c8:	2d c0       	rjmp	.+90     	; 0x3824 <vfprintf+0x122>
    37ca:	20 ed       	ldi	r18, 0xD0	; 208
    37cc:	28 0f       	add	r18, r24
    37ce:	2a 30       	cpi	r18, 0x0A	; 10
    37d0:	88 f4       	brcc	.+34     	; 0x37f4 <vfprintf+0xf2>
    37d2:	96 fe       	sbrs	r9, 6
    37d4:	06 c0       	rjmp	.+12     	; 0x37e2 <vfprintf+0xe0>
    37d6:	3a e0       	ldi	r19, 0x0A	; 10
    37d8:	13 9f       	mul	r17, r19
    37da:	20 0d       	add	r18, r0
    37dc:	11 24       	eor	r1, r1
    37de:	12 2f       	mov	r17, r18
    37e0:	19 c0       	rjmp	.+50     	; 0x3814 <vfprintf+0x112>
    37e2:	8a e0       	ldi	r24, 0x0A	; 10
    37e4:	58 9e       	mul	r5, r24
    37e6:	20 0d       	add	r18, r0
    37e8:	11 24       	eor	r1, r1
    37ea:	52 2e       	mov	r5, r18
    37ec:	e9 2d       	mov	r30, r9
    37ee:	e0 62       	ori	r30, 0x20	; 32
    37f0:	9e 2e       	mov	r9, r30
    37f2:	10 c0       	rjmp	.+32     	; 0x3814 <vfprintf+0x112>
    37f4:	8e 32       	cpi	r24, 0x2E	; 46
    37f6:	31 f4       	brne	.+12     	; 0x3804 <vfprintf+0x102>
    37f8:	96 fc       	sbrc	r9, 6
    37fa:	cc c2       	rjmp	.+1432   	; 0x3d94 <vfprintf+0x692>
    37fc:	f9 2d       	mov	r31, r9
    37fe:	f0 64       	ori	r31, 0x40	; 64
    3800:	9f 2e       	mov	r9, r31
    3802:	08 c0       	rjmp	.+16     	; 0x3814 <vfprintf+0x112>
    3804:	8c 36       	cpi	r24, 0x6C	; 108
    3806:	21 f4       	brne	.+8      	; 0x3810 <vfprintf+0x10e>
    3808:	29 2d       	mov	r18, r9
    380a:	20 68       	ori	r18, 0x80	; 128
    380c:	92 2e       	mov	r9, r18
    380e:	02 c0       	rjmp	.+4      	; 0x3814 <vfprintf+0x112>
    3810:	88 36       	cpi	r24, 0x68	; 104
    3812:	41 f4       	brne	.+16     	; 0x3824 <vfprintf+0x122>
    3814:	f1 01       	movw	r30, r2
    3816:	93 fd       	sbrc	r25, 3
    3818:	85 91       	lpm	r24, Z+
    381a:	93 ff       	sbrs	r25, 3
    381c:	81 91       	ld	r24, Z+
    381e:	1f 01       	movw	r2, r30
    3820:	81 11       	cpse	r24, r1
    3822:	b3 cf       	rjmp	.-154    	; 0x378a <vfprintf+0x88>
    3824:	9b eb       	ldi	r25, 0xBB	; 187
    3826:	98 0f       	add	r25, r24
    3828:	93 30       	cpi	r25, 0x03	; 3
    382a:	20 f4       	brcc	.+8      	; 0x3834 <vfprintf+0x132>
    382c:	99 2d       	mov	r25, r9
    382e:	90 61       	ori	r25, 0x10	; 16
    3830:	80 5e       	subi	r24, 0xE0	; 224
    3832:	07 c0       	rjmp	.+14     	; 0x3842 <vfprintf+0x140>
    3834:	9b e9       	ldi	r25, 0x9B	; 155
    3836:	98 0f       	add	r25, r24
    3838:	93 30       	cpi	r25, 0x03	; 3
    383a:	08 f0       	brcs	.+2      	; 0x383e <vfprintf+0x13c>
    383c:	59 c1       	rjmp	.+690    	; 0x3af0 <vfprintf+0x3ee>
    383e:	99 2d       	mov	r25, r9
    3840:	9f 7e       	andi	r25, 0xEF	; 239
    3842:	96 ff       	sbrs	r25, 6
    3844:	16 e0       	ldi	r17, 0x06	; 6
    3846:	9f 73       	andi	r25, 0x3F	; 63
    3848:	99 2e       	mov	r9, r25
    384a:	85 36       	cpi	r24, 0x65	; 101
    384c:	19 f4       	brne	.+6      	; 0x3854 <vfprintf+0x152>
    384e:	90 64       	ori	r25, 0x40	; 64
    3850:	99 2e       	mov	r9, r25
    3852:	08 c0       	rjmp	.+16     	; 0x3864 <vfprintf+0x162>
    3854:	86 36       	cpi	r24, 0x66	; 102
    3856:	21 f4       	brne	.+8      	; 0x3860 <vfprintf+0x15e>
    3858:	39 2f       	mov	r19, r25
    385a:	30 68       	ori	r19, 0x80	; 128
    385c:	93 2e       	mov	r9, r19
    385e:	02 c0       	rjmp	.+4      	; 0x3864 <vfprintf+0x162>
    3860:	11 11       	cpse	r17, r1
    3862:	11 50       	subi	r17, 0x01	; 1
    3864:	97 fe       	sbrs	r9, 7
    3866:	07 c0       	rjmp	.+14     	; 0x3876 <vfprintf+0x174>
    3868:	1c 33       	cpi	r17, 0x3C	; 60
    386a:	50 f4       	brcc	.+20     	; 0x3880 <vfprintf+0x17e>
    386c:	44 24       	eor	r4, r4
    386e:	43 94       	inc	r4
    3870:	41 0e       	add	r4, r17
    3872:	27 e0       	ldi	r18, 0x07	; 7
    3874:	0b c0       	rjmp	.+22     	; 0x388c <vfprintf+0x18a>
    3876:	18 30       	cpi	r17, 0x08	; 8
    3878:	38 f0       	brcs	.+14     	; 0x3888 <vfprintf+0x186>
    387a:	27 e0       	ldi	r18, 0x07	; 7
    387c:	17 e0       	ldi	r17, 0x07	; 7
    387e:	05 c0       	rjmp	.+10     	; 0x388a <vfprintf+0x188>
    3880:	27 e0       	ldi	r18, 0x07	; 7
    3882:	9c e3       	ldi	r25, 0x3C	; 60
    3884:	49 2e       	mov	r4, r25
    3886:	02 c0       	rjmp	.+4      	; 0x388c <vfprintf+0x18a>
    3888:	21 2f       	mov	r18, r17
    388a:	41 2c       	mov	r4, r1
    388c:	56 01       	movw	r10, r12
    388e:	84 e0       	ldi	r24, 0x04	; 4
    3890:	a8 0e       	add	r10, r24
    3892:	b1 1c       	adc	r11, r1
    3894:	f6 01       	movw	r30, r12
    3896:	60 81       	ld	r22, Z
    3898:	71 81       	ldd	r23, Z+1	; 0x01
    389a:	82 81       	ldd	r24, Z+2	; 0x02
    389c:	93 81       	ldd	r25, Z+3	; 0x03
    389e:	04 2d       	mov	r16, r4
    38a0:	a3 01       	movw	r20, r6
    38a2:	b8 d2       	rcall	.+1392   	; 0x3e14 <__ftoa_engine>
    38a4:	6c 01       	movw	r12, r24
    38a6:	f9 81       	ldd	r31, Y+1	; 0x01
    38a8:	fc 87       	std	Y+12, r31	; 0x0c
    38aa:	f0 ff       	sbrs	r31, 0
    38ac:	02 c0       	rjmp	.+4      	; 0x38b2 <vfprintf+0x1b0>
    38ae:	f3 ff       	sbrs	r31, 3
    38b0:	06 c0       	rjmp	.+12     	; 0x38be <vfprintf+0x1bc>
    38b2:	91 fc       	sbrc	r9, 1
    38b4:	06 c0       	rjmp	.+12     	; 0x38c2 <vfprintf+0x1c0>
    38b6:	92 fe       	sbrs	r9, 2
    38b8:	06 c0       	rjmp	.+12     	; 0x38c6 <vfprintf+0x1c4>
    38ba:	00 e2       	ldi	r16, 0x20	; 32
    38bc:	05 c0       	rjmp	.+10     	; 0x38c8 <vfprintf+0x1c6>
    38be:	0d e2       	ldi	r16, 0x2D	; 45
    38c0:	03 c0       	rjmp	.+6      	; 0x38c8 <vfprintf+0x1c6>
    38c2:	0b e2       	ldi	r16, 0x2B	; 43
    38c4:	01 c0       	rjmp	.+2      	; 0x38c8 <vfprintf+0x1c6>
    38c6:	00 e0       	ldi	r16, 0x00	; 0
    38c8:	8c 85       	ldd	r24, Y+12	; 0x0c
    38ca:	8c 70       	andi	r24, 0x0C	; 12
    38cc:	19 f0       	breq	.+6      	; 0x38d4 <vfprintf+0x1d2>
    38ce:	01 11       	cpse	r16, r1
    38d0:	43 c2       	rjmp	.+1158   	; 0x3d58 <vfprintf+0x656>
    38d2:	80 c2       	rjmp	.+1280   	; 0x3dd4 <vfprintf+0x6d2>
    38d4:	97 fe       	sbrs	r9, 7
    38d6:	10 c0       	rjmp	.+32     	; 0x38f8 <vfprintf+0x1f6>
    38d8:	4c 0c       	add	r4, r12
    38da:	fc 85       	ldd	r31, Y+12	; 0x0c
    38dc:	f4 ff       	sbrs	r31, 4
    38de:	04 c0       	rjmp	.+8      	; 0x38e8 <vfprintf+0x1e6>
    38e0:	8a 81       	ldd	r24, Y+2	; 0x02
    38e2:	81 33       	cpi	r24, 0x31	; 49
    38e4:	09 f4       	brne	.+2      	; 0x38e8 <vfprintf+0x1e6>
    38e6:	4a 94       	dec	r4
    38e8:	14 14       	cp	r1, r4
    38ea:	74 f5       	brge	.+92     	; 0x3948 <vfprintf+0x246>
    38ec:	28 e0       	ldi	r18, 0x08	; 8
    38ee:	24 15       	cp	r18, r4
    38f0:	78 f5       	brcc	.+94     	; 0x3950 <vfprintf+0x24e>
    38f2:	88 e0       	ldi	r24, 0x08	; 8
    38f4:	48 2e       	mov	r4, r24
    38f6:	2c c0       	rjmp	.+88     	; 0x3950 <vfprintf+0x24e>
    38f8:	96 fc       	sbrc	r9, 6
    38fa:	2a c0       	rjmp	.+84     	; 0x3950 <vfprintf+0x24e>
    38fc:	81 2f       	mov	r24, r17
    38fe:	90 e0       	ldi	r25, 0x00	; 0
    3900:	8c 15       	cp	r24, r12
    3902:	9d 05       	cpc	r25, r13
    3904:	9c f0       	brlt	.+38     	; 0x392c <vfprintf+0x22a>
    3906:	3c ef       	ldi	r19, 0xFC	; 252
    3908:	c3 16       	cp	r12, r19
    390a:	3f ef       	ldi	r19, 0xFF	; 255
    390c:	d3 06       	cpc	r13, r19
    390e:	74 f0       	brlt	.+28     	; 0x392c <vfprintf+0x22a>
    3910:	89 2d       	mov	r24, r9
    3912:	80 68       	ori	r24, 0x80	; 128
    3914:	98 2e       	mov	r9, r24
    3916:	0a c0       	rjmp	.+20     	; 0x392c <vfprintf+0x22a>
    3918:	e2 e0       	ldi	r30, 0x02	; 2
    391a:	f0 e0       	ldi	r31, 0x00	; 0
    391c:	ec 0f       	add	r30, r28
    391e:	fd 1f       	adc	r31, r29
    3920:	e1 0f       	add	r30, r17
    3922:	f1 1d       	adc	r31, r1
    3924:	80 81       	ld	r24, Z
    3926:	80 33       	cpi	r24, 0x30	; 48
    3928:	19 f4       	brne	.+6      	; 0x3930 <vfprintf+0x22e>
    392a:	11 50       	subi	r17, 0x01	; 1
    392c:	11 11       	cpse	r17, r1
    392e:	f4 cf       	rjmp	.-24     	; 0x3918 <vfprintf+0x216>
    3930:	97 fe       	sbrs	r9, 7
    3932:	0e c0       	rjmp	.+28     	; 0x3950 <vfprintf+0x24e>
    3934:	44 24       	eor	r4, r4
    3936:	43 94       	inc	r4
    3938:	41 0e       	add	r4, r17
    393a:	81 2f       	mov	r24, r17
    393c:	90 e0       	ldi	r25, 0x00	; 0
    393e:	c8 16       	cp	r12, r24
    3940:	d9 06       	cpc	r13, r25
    3942:	2c f4       	brge	.+10     	; 0x394e <vfprintf+0x24c>
    3944:	1c 19       	sub	r17, r12
    3946:	04 c0       	rjmp	.+8      	; 0x3950 <vfprintf+0x24e>
    3948:	44 24       	eor	r4, r4
    394a:	43 94       	inc	r4
    394c:	01 c0       	rjmp	.+2      	; 0x3950 <vfprintf+0x24e>
    394e:	10 e0       	ldi	r17, 0x00	; 0
    3950:	97 fe       	sbrs	r9, 7
    3952:	06 c0       	rjmp	.+12     	; 0x3960 <vfprintf+0x25e>
    3954:	1c 14       	cp	r1, r12
    3956:	1d 04       	cpc	r1, r13
    3958:	34 f4       	brge	.+12     	; 0x3966 <vfprintf+0x264>
    395a:	c6 01       	movw	r24, r12
    395c:	01 96       	adiw	r24, 0x01	; 1
    395e:	05 c0       	rjmp	.+10     	; 0x396a <vfprintf+0x268>
    3960:	85 e0       	ldi	r24, 0x05	; 5
    3962:	90 e0       	ldi	r25, 0x00	; 0
    3964:	02 c0       	rjmp	.+4      	; 0x396a <vfprintf+0x268>
    3966:	81 e0       	ldi	r24, 0x01	; 1
    3968:	90 e0       	ldi	r25, 0x00	; 0
    396a:	01 11       	cpse	r16, r1
    396c:	01 96       	adiw	r24, 0x01	; 1
    396e:	11 23       	and	r17, r17
    3970:	31 f0       	breq	.+12     	; 0x397e <vfprintf+0x27c>
    3972:	21 2f       	mov	r18, r17
    3974:	30 e0       	ldi	r19, 0x00	; 0
    3976:	2f 5f       	subi	r18, 0xFF	; 255
    3978:	3f 4f       	sbci	r19, 0xFF	; 255
    397a:	82 0f       	add	r24, r18
    397c:	93 1f       	adc	r25, r19
    397e:	25 2d       	mov	r18, r5
    3980:	30 e0       	ldi	r19, 0x00	; 0
    3982:	82 17       	cp	r24, r18
    3984:	93 07       	cpc	r25, r19
    3986:	14 f4       	brge	.+4      	; 0x398c <vfprintf+0x28a>
    3988:	58 1a       	sub	r5, r24
    398a:	01 c0       	rjmp	.+2      	; 0x398e <vfprintf+0x28c>
    398c:	51 2c       	mov	r5, r1
    398e:	89 2d       	mov	r24, r9
    3990:	89 70       	andi	r24, 0x09	; 9
    3992:	41 f4       	brne	.+16     	; 0x39a4 <vfprintf+0x2a2>
    3994:	55 20       	and	r5, r5
    3996:	31 f0       	breq	.+12     	; 0x39a4 <vfprintf+0x2a2>
    3998:	b7 01       	movw	r22, r14
    399a:	80 e2       	ldi	r24, 0x20	; 32
    399c:	90 e0       	ldi	r25, 0x00	; 0
    399e:	31 d3       	rcall	.+1634   	; 0x4002 <fputc>
    39a0:	5a 94       	dec	r5
    39a2:	f8 cf       	rjmp	.-16     	; 0x3994 <vfprintf+0x292>
    39a4:	00 23       	and	r16, r16
    39a6:	21 f0       	breq	.+8      	; 0x39b0 <vfprintf+0x2ae>
    39a8:	b7 01       	movw	r22, r14
    39aa:	80 2f       	mov	r24, r16
    39ac:	90 e0       	ldi	r25, 0x00	; 0
    39ae:	29 d3       	rcall	.+1618   	; 0x4002 <fputc>
    39b0:	93 fc       	sbrc	r9, 3
    39b2:	08 c0       	rjmp	.+16     	; 0x39c4 <vfprintf+0x2c2>
    39b4:	55 20       	and	r5, r5
    39b6:	31 f0       	breq	.+12     	; 0x39c4 <vfprintf+0x2c2>
    39b8:	b7 01       	movw	r22, r14
    39ba:	80 e3       	ldi	r24, 0x30	; 48
    39bc:	90 e0       	ldi	r25, 0x00	; 0
    39be:	21 d3       	rcall	.+1602   	; 0x4002 <fputc>
    39c0:	5a 94       	dec	r5
    39c2:	f8 cf       	rjmp	.-16     	; 0x39b4 <vfprintf+0x2b2>
    39c4:	97 fe       	sbrs	r9, 7
    39c6:	4a c0       	rjmp	.+148    	; 0x3a5c <vfprintf+0x35a>
    39c8:	46 01       	movw	r8, r12
    39ca:	d7 fe       	sbrs	r13, 7
    39cc:	02 c0       	rjmp	.+4      	; 0x39d2 <vfprintf+0x2d0>
    39ce:	81 2c       	mov	r8, r1
    39d0:	91 2c       	mov	r9, r1
    39d2:	c6 01       	movw	r24, r12
    39d4:	88 19       	sub	r24, r8
    39d6:	99 09       	sbc	r25, r9
    39d8:	f3 01       	movw	r30, r6
    39da:	e8 0f       	add	r30, r24
    39dc:	f9 1f       	adc	r31, r25
    39de:	fe 87       	std	Y+14, r31	; 0x0e
    39e0:	ed 87       	std	Y+13, r30	; 0x0d
    39e2:	96 01       	movw	r18, r12
    39e4:	24 19       	sub	r18, r4
    39e6:	31 09       	sbc	r19, r1
    39e8:	38 8b       	std	Y+16, r19	; 0x10
    39ea:	2f 87       	std	Y+15, r18	; 0x0f
    39ec:	01 2f       	mov	r16, r17
    39ee:	10 e0       	ldi	r17, 0x00	; 0
    39f0:	11 95       	neg	r17
    39f2:	01 95       	neg	r16
    39f4:	11 09       	sbc	r17, r1
    39f6:	3f ef       	ldi	r19, 0xFF	; 255
    39f8:	83 16       	cp	r8, r19
    39fa:	93 06       	cpc	r9, r19
    39fc:	21 f4       	brne	.+8      	; 0x3a06 <vfprintf+0x304>
    39fe:	b7 01       	movw	r22, r14
    3a00:	8e e2       	ldi	r24, 0x2E	; 46
    3a02:	90 e0       	ldi	r25, 0x00	; 0
    3a04:	fe d2       	rcall	.+1532   	; 0x4002 <fputc>
    3a06:	c8 14       	cp	r12, r8
    3a08:	d9 04       	cpc	r13, r9
    3a0a:	4c f0       	brlt	.+18     	; 0x3a1e <vfprintf+0x31c>
    3a0c:	8f 85       	ldd	r24, Y+15	; 0x0f
    3a0e:	98 89       	ldd	r25, Y+16	; 0x10
    3a10:	88 15       	cp	r24, r8
    3a12:	99 05       	cpc	r25, r9
    3a14:	24 f4       	brge	.+8      	; 0x3a1e <vfprintf+0x31c>
    3a16:	ed 85       	ldd	r30, Y+13	; 0x0d
    3a18:	fe 85       	ldd	r31, Y+14	; 0x0e
    3a1a:	81 81       	ldd	r24, Z+1	; 0x01
    3a1c:	01 c0       	rjmp	.+2      	; 0x3a20 <vfprintf+0x31e>
    3a1e:	80 e3       	ldi	r24, 0x30	; 48
    3a20:	f1 e0       	ldi	r31, 0x01	; 1
    3a22:	8f 1a       	sub	r8, r31
    3a24:	91 08       	sbc	r9, r1
    3a26:	2d 85       	ldd	r18, Y+13	; 0x0d
    3a28:	3e 85       	ldd	r19, Y+14	; 0x0e
    3a2a:	2f 5f       	subi	r18, 0xFF	; 255
    3a2c:	3f 4f       	sbci	r19, 0xFF	; 255
    3a2e:	3e 87       	std	Y+14, r19	; 0x0e
    3a30:	2d 87       	std	Y+13, r18	; 0x0d
    3a32:	80 16       	cp	r8, r16
    3a34:	91 06       	cpc	r9, r17
    3a36:	24 f0       	brlt	.+8      	; 0x3a40 <vfprintf+0x33e>
    3a38:	b7 01       	movw	r22, r14
    3a3a:	90 e0       	ldi	r25, 0x00	; 0
    3a3c:	e2 d2       	rcall	.+1476   	; 0x4002 <fputc>
    3a3e:	db cf       	rjmp	.-74     	; 0x39f6 <vfprintf+0x2f4>
    3a40:	c8 14       	cp	r12, r8
    3a42:	d9 04       	cpc	r13, r9
    3a44:	41 f4       	brne	.+16     	; 0x3a56 <vfprintf+0x354>
    3a46:	9a 81       	ldd	r25, Y+2	; 0x02
    3a48:	96 33       	cpi	r25, 0x36	; 54
    3a4a:	20 f4       	brcc	.+8      	; 0x3a54 <vfprintf+0x352>
    3a4c:	95 33       	cpi	r25, 0x35	; 53
    3a4e:	19 f4       	brne	.+6      	; 0x3a56 <vfprintf+0x354>
    3a50:	3c 85       	ldd	r19, Y+12	; 0x0c
    3a52:	34 ff       	sbrs	r19, 4
    3a54:	81 e3       	ldi	r24, 0x31	; 49
    3a56:	b7 01       	movw	r22, r14
    3a58:	90 e0       	ldi	r25, 0x00	; 0
    3a5a:	48 c0       	rjmp	.+144    	; 0x3aec <vfprintf+0x3ea>
    3a5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5e:	81 33       	cpi	r24, 0x31	; 49
    3a60:	19 f0       	breq	.+6      	; 0x3a68 <vfprintf+0x366>
    3a62:	9c 85       	ldd	r25, Y+12	; 0x0c
    3a64:	9f 7e       	andi	r25, 0xEF	; 239
    3a66:	9c 87       	std	Y+12, r25	; 0x0c
    3a68:	b7 01       	movw	r22, r14
    3a6a:	90 e0       	ldi	r25, 0x00	; 0
    3a6c:	ca d2       	rcall	.+1428   	; 0x4002 <fputc>
    3a6e:	11 11       	cpse	r17, r1
    3a70:	05 c0       	rjmp	.+10     	; 0x3a7c <vfprintf+0x37a>
    3a72:	94 fc       	sbrc	r9, 4
    3a74:	16 c0       	rjmp	.+44     	; 0x3aa2 <vfprintf+0x3a0>
    3a76:	85 e6       	ldi	r24, 0x65	; 101
    3a78:	90 e0       	ldi	r25, 0x00	; 0
    3a7a:	15 c0       	rjmp	.+42     	; 0x3aa6 <vfprintf+0x3a4>
    3a7c:	b7 01       	movw	r22, r14
    3a7e:	8e e2       	ldi	r24, 0x2E	; 46
    3a80:	90 e0       	ldi	r25, 0x00	; 0
    3a82:	bf d2       	rcall	.+1406   	; 0x4002 <fputc>
    3a84:	1e 5f       	subi	r17, 0xFE	; 254
    3a86:	82 e0       	ldi	r24, 0x02	; 2
    3a88:	01 e0       	ldi	r16, 0x01	; 1
    3a8a:	08 0f       	add	r16, r24
    3a8c:	f3 01       	movw	r30, r6
    3a8e:	e8 0f       	add	r30, r24
    3a90:	f1 1d       	adc	r31, r1
    3a92:	80 81       	ld	r24, Z
    3a94:	b7 01       	movw	r22, r14
    3a96:	90 e0       	ldi	r25, 0x00	; 0
    3a98:	b4 d2       	rcall	.+1384   	; 0x4002 <fputc>
    3a9a:	80 2f       	mov	r24, r16
    3a9c:	01 13       	cpse	r16, r17
    3a9e:	f4 cf       	rjmp	.-24     	; 0x3a88 <vfprintf+0x386>
    3aa0:	e8 cf       	rjmp	.-48     	; 0x3a72 <vfprintf+0x370>
    3aa2:	85 e4       	ldi	r24, 0x45	; 69
    3aa4:	90 e0       	ldi	r25, 0x00	; 0
    3aa6:	b7 01       	movw	r22, r14
    3aa8:	ac d2       	rcall	.+1368   	; 0x4002 <fputc>
    3aaa:	d7 fc       	sbrc	r13, 7
    3aac:	06 c0       	rjmp	.+12     	; 0x3aba <vfprintf+0x3b8>
    3aae:	c1 14       	cp	r12, r1
    3ab0:	d1 04       	cpc	r13, r1
    3ab2:	41 f4       	brne	.+16     	; 0x3ac4 <vfprintf+0x3c2>
    3ab4:	ec 85       	ldd	r30, Y+12	; 0x0c
    3ab6:	e4 ff       	sbrs	r30, 4
    3ab8:	05 c0       	rjmp	.+10     	; 0x3ac4 <vfprintf+0x3c2>
    3aba:	d1 94       	neg	r13
    3abc:	c1 94       	neg	r12
    3abe:	d1 08       	sbc	r13, r1
    3ac0:	8d e2       	ldi	r24, 0x2D	; 45
    3ac2:	01 c0       	rjmp	.+2      	; 0x3ac6 <vfprintf+0x3c4>
    3ac4:	8b e2       	ldi	r24, 0x2B	; 43
    3ac6:	b7 01       	movw	r22, r14
    3ac8:	90 e0       	ldi	r25, 0x00	; 0
    3aca:	9b d2       	rcall	.+1334   	; 0x4002 <fputc>
    3acc:	80 e3       	ldi	r24, 0x30	; 48
    3ace:	2a e0       	ldi	r18, 0x0A	; 10
    3ad0:	c2 16       	cp	r12, r18
    3ad2:	d1 04       	cpc	r13, r1
    3ad4:	2c f0       	brlt	.+10     	; 0x3ae0 <vfprintf+0x3de>
    3ad6:	8f 5f       	subi	r24, 0xFF	; 255
    3ad8:	fa e0       	ldi	r31, 0x0A	; 10
    3ada:	cf 1a       	sub	r12, r31
    3adc:	d1 08       	sbc	r13, r1
    3ade:	f7 cf       	rjmp	.-18     	; 0x3ace <vfprintf+0x3cc>
    3ae0:	b7 01       	movw	r22, r14
    3ae2:	90 e0       	ldi	r25, 0x00	; 0
    3ae4:	8e d2       	rcall	.+1308   	; 0x4002 <fputc>
    3ae6:	b7 01       	movw	r22, r14
    3ae8:	c6 01       	movw	r24, r12
    3aea:	c0 96       	adiw	r24, 0x30	; 48
    3aec:	8a d2       	rcall	.+1300   	; 0x4002 <fputc>
    3aee:	49 c1       	rjmp	.+658    	; 0x3d82 <vfprintf+0x680>
    3af0:	83 36       	cpi	r24, 0x63	; 99
    3af2:	31 f0       	breq	.+12     	; 0x3b00 <vfprintf+0x3fe>
    3af4:	83 37       	cpi	r24, 0x73	; 115
    3af6:	79 f0       	breq	.+30     	; 0x3b16 <vfprintf+0x414>
    3af8:	83 35       	cpi	r24, 0x53	; 83
    3afa:	09 f0       	breq	.+2      	; 0x3afe <vfprintf+0x3fc>
    3afc:	52 c0       	rjmp	.+164    	; 0x3ba2 <vfprintf+0x4a0>
    3afe:	1f c0       	rjmp	.+62     	; 0x3b3e <vfprintf+0x43c>
    3b00:	56 01       	movw	r10, r12
    3b02:	32 e0       	ldi	r19, 0x02	; 2
    3b04:	a3 0e       	add	r10, r19
    3b06:	b1 1c       	adc	r11, r1
    3b08:	f6 01       	movw	r30, r12
    3b0a:	80 81       	ld	r24, Z
    3b0c:	89 83       	std	Y+1, r24	; 0x01
    3b0e:	01 e0       	ldi	r16, 0x01	; 1
    3b10:	10 e0       	ldi	r17, 0x00	; 0
    3b12:	63 01       	movw	r12, r6
    3b14:	11 c0       	rjmp	.+34     	; 0x3b38 <vfprintf+0x436>
    3b16:	56 01       	movw	r10, r12
    3b18:	f2 e0       	ldi	r31, 0x02	; 2
    3b1a:	af 0e       	add	r10, r31
    3b1c:	b1 1c       	adc	r11, r1
    3b1e:	f6 01       	movw	r30, r12
    3b20:	c0 80       	ld	r12, Z
    3b22:	d1 80       	ldd	r13, Z+1	; 0x01
    3b24:	96 fe       	sbrs	r9, 6
    3b26:	03 c0       	rjmp	.+6      	; 0x3b2e <vfprintf+0x42c>
    3b28:	61 2f       	mov	r22, r17
    3b2a:	70 e0       	ldi	r23, 0x00	; 0
    3b2c:	02 c0       	rjmp	.+4      	; 0x3b32 <vfprintf+0x430>
    3b2e:	6f ef       	ldi	r22, 0xFF	; 255
    3b30:	7f ef       	ldi	r23, 0xFF	; 255
    3b32:	c6 01       	movw	r24, r12
    3b34:	5b d2       	rcall	.+1206   	; 0x3fec <strnlen>
    3b36:	8c 01       	movw	r16, r24
    3b38:	f9 2d       	mov	r31, r9
    3b3a:	ff 77       	andi	r31, 0x7F	; 127
    3b3c:	13 c0       	rjmp	.+38     	; 0x3b64 <vfprintf+0x462>
    3b3e:	56 01       	movw	r10, r12
    3b40:	22 e0       	ldi	r18, 0x02	; 2
    3b42:	a2 0e       	add	r10, r18
    3b44:	b1 1c       	adc	r11, r1
    3b46:	f6 01       	movw	r30, r12
    3b48:	c0 80       	ld	r12, Z
    3b4a:	d1 80       	ldd	r13, Z+1	; 0x01
    3b4c:	96 fe       	sbrs	r9, 6
    3b4e:	03 c0       	rjmp	.+6      	; 0x3b56 <vfprintf+0x454>
    3b50:	61 2f       	mov	r22, r17
    3b52:	70 e0       	ldi	r23, 0x00	; 0
    3b54:	02 c0       	rjmp	.+4      	; 0x3b5a <vfprintf+0x458>
    3b56:	6f ef       	ldi	r22, 0xFF	; 255
    3b58:	7f ef       	ldi	r23, 0xFF	; 255
    3b5a:	c6 01       	movw	r24, r12
    3b5c:	33 d2       	rcall	.+1126   	; 0x3fc4 <strnlen_P>
    3b5e:	8c 01       	movw	r16, r24
    3b60:	f9 2d       	mov	r31, r9
    3b62:	f0 68       	ori	r31, 0x80	; 128
    3b64:	9f 2e       	mov	r9, r31
    3b66:	f3 fd       	sbrc	r31, 3
    3b68:	18 c0       	rjmp	.+48     	; 0x3b9a <vfprintf+0x498>
    3b6a:	85 2d       	mov	r24, r5
    3b6c:	90 e0       	ldi	r25, 0x00	; 0
    3b6e:	08 17       	cp	r16, r24
    3b70:	19 07       	cpc	r17, r25
    3b72:	98 f4       	brcc	.+38     	; 0x3b9a <vfprintf+0x498>
    3b74:	b7 01       	movw	r22, r14
    3b76:	80 e2       	ldi	r24, 0x20	; 32
    3b78:	90 e0       	ldi	r25, 0x00	; 0
    3b7a:	43 d2       	rcall	.+1158   	; 0x4002 <fputc>
    3b7c:	5a 94       	dec	r5
    3b7e:	f5 cf       	rjmp	.-22     	; 0x3b6a <vfprintf+0x468>
    3b80:	f6 01       	movw	r30, r12
    3b82:	97 fc       	sbrc	r9, 7
    3b84:	85 91       	lpm	r24, Z+
    3b86:	97 fe       	sbrs	r9, 7
    3b88:	81 91       	ld	r24, Z+
    3b8a:	6f 01       	movw	r12, r30
    3b8c:	b7 01       	movw	r22, r14
    3b8e:	90 e0       	ldi	r25, 0x00	; 0
    3b90:	38 d2       	rcall	.+1136   	; 0x4002 <fputc>
    3b92:	51 10       	cpse	r5, r1
    3b94:	5a 94       	dec	r5
    3b96:	01 50       	subi	r16, 0x01	; 1
    3b98:	11 09       	sbc	r17, r1
    3b9a:	01 15       	cp	r16, r1
    3b9c:	11 05       	cpc	r17, r1
    3b9e:	81 f7       	brne	.-32     	; 0x3b80 <vfprintf+0x47e>
    3ba0:	f0 c0       	rjmp	.+480    	; 0x3d82 <vfprintf+0x680>
    3ba2:	84 36       	cpi	r24, 0x64	; 100
    3ba4:	11 f0       	breq	.+4      	; 0x3baa <vfprintf+0x4a8>
    3ba6:	89 36       	cpi	r24, 0x69	; 105
    3ba8:	59 f5       	brne	.+86     	; 0x3c00 <vfprintf+0x4fe>
    3baa:	56 01       	movw	r10, r12
    3bac:	97 fe       	sbrs	r9, 7
    3bae:	09 c0       	rjmp	.+18     	; 0x3bc2 <vfprintf+0x4c0>
    3bb0:	24 e0       	ldi	r18, 0x04	; 4
    3bb2:	a2 0e       	add	r10, r18
    3bb4:	b1 1c       	adc	r11, r1
    3bb6:	f6 01       	movw	r30, r12
    3bb8:	60 81       	ld	r22, Z
    3bba:	71 81       	ldd	r23, Z+1	; 0x01
    3bbc:	82 81       	ldd	r24, Z+2	; 0x02
    3bbe:	93 81       	ldd	r25, Z+3	; 0x03
    3bc0:	0a c0       	rjmp	.+20     	; 0x3bd6 <vfprintf+0x4d4>
    3bc2:	f2 e0       	ldi	r31, 0x02	; 2
    3bc4:	af 0e       	add	r10, r31
    3bc6:	b1 1c       	adc	r11, r1
    3bc8:	f6 01       	movw	r30, r12
    3bca:	60 81       	ld	r22, Z
    3bcc:	71 81       	ldd	r23, Z+1	; 0x01
    3bce:	07 2e       	mov	r0, r23
    3bd0:	00 0c       	add	r0, r0
    3bd2:	88 0b       	sbc	r24, r24
    3bd4:	99 0b       	sbc	r25, r25
    3bd6:	f9 2d       	mov	r31, r9
    3bd8:	ff 76       	andi	r31, 0x6F	; 111
    3bda:	9f 2e       	mov	r9, r31
    3bdc:	97 ff       	sbrs	r25, 7
    3bde:	09 c0       	rjmp	.+18     	; 0x3bf2 <vfprintf+0x4f0>
    3be0:	90 95       	com	r25
    3be2:	80 95       	com	r24
    3be4:	70 95       	com	r23
    3be6:	61 95       	neg	r22
    3be8:	7f 4f       	sbci	r23, 0xFF	; 255
    3bea:	8f 4f       	sbci	r24, 0xFF	; 255
    3bec:	9f 4f       	sbci	r25, 0xFF	; 255
    3bee:	f0 68       	ori	r31, 0x80	; 128
    3bf0:	9f 2e       	mov	r9, r31
    3bf2:	2a e0       	ldi	r18, 0x0A	; 10
    3bf4:	30 e0       	ldi	r19, 0x00	; 0
    3bf6:	a3 01       	movw	r20, r6
    3bf8:	40 d2       	rcall	.+1152   	; 0x407a <__ultoa_invert>
    3bfa:	c8 2e       	mov	r12, r24
    3bfc:	c6 18       	sub	r12, r6
    3bfe:	3e c0       	rjmp	.+124    	; 0x3c7c <vfprintf+0x57a>
    3c00:	09 2d       	mov	r16, r9
    3c02:	85 37       	cpi	r24, 0x75	; 117
    3c04:	21 f4       	brne	.+8      	; 0x3c0e <vfprintf+0x50c>
    3c06:	0f 7e       	andi	r16, 0xEF	; 239
    3c08:	2a e0       	ldi	r18, 0x0A	; 10
    3c0a:	30 e0       	ldi	r19, 0x00	; 0
    3c0c:	1d c0       	rjmp	.+58     	; 0x3c48 <vfprintf+0x546>
    3c0e:	09 7f       	andi	r16, 0xF9	; 249
    3c10:	8f 36       	cpi	r24, 0x6F	; 111
    3c12:	91 f0       	breq	.+36     	; 0x3c38 <vfprintf+0x536>
    3c14:	18 f4       	brcc	.+6      	; 0x3c1c <vfprintf+0x51a>
    3c16:	88 35       	cpi	r24, 0x58	; 88
    3c18:	59 f0       	breq	.+22     	; 0x3c30 <vfprintf+0x52e>
    3c1a:	bc c0       	rjmp	.+376    	; 0x3d94 <vfprintf+0x692>
    3c1c:	80 37       	cpi	r24, 0x70	; 112
    3c1e:	19 f0       	breq	.+6      	; 0x3c26 <vfprintf+0x524>
    3c20:	88 37       	cpi	r24, 0x78	; 120
    3c22:	11 f0       	breq	.+4      	; 0x3c28 <vfprintf+0x526>
    3c24:	b7 c0       	rjmp	.+366    	; 0x3d94 <vfprintf+0x692>
    3c26:	00 61       	ori	r16, 0x10	; 16
    3c28:	04 ff       	sbrs	r16, 4
    3c2a:	09 c0       	rjmp	.+18     	; 0x3c3e <vfprintf+0x53c>
    3c2c:	04 60       	ori	r16, 0x04	; 4
    3c2e:	07 c0       	rjmp	.+14     	; 0x3c3e <vfprintf+0x53c>
    3c30:	94 fe       	sbrs	r9, 4
    3c32:	08 c0       	rjmp	.+16     	; 0x3c44 <vfprintf+0x542>
    3c34:	06 60       	ori	r16, 0x06	; 6
    3c36:	06 c0       	rjmp	.+12     	; 0x3c44 <vfprintf+0x542>
    3c38:	28 e0       	ldi	r18, 0x08	; 8
    3c3a:	30 e0       	ldi	r19, 0x00	; 0
    3c3c:	05 c0       	rjmp	.+10     	; 0x3c48 <vfprintf+0x546>
    3c3e:	20 e1       	ldi	r18, 0x10	; 16
    3c40:	30 e0       	ldi	r19, 0x00	; 0
    3c42:	02 c0       	rjmp	.+4      	; 0x3c48 <vfprintf+0x546>
    3c44:	20 e1       	ldi	r18, 0x10	; 16
    3c46:	32 e0       	ldi	r19, 0x02	; 2
    3c48:	56 01       	movw	r10, r12
    3c4a:	07 ff       	sbrs	r16, 7
    3c4c:	09 c0       	rjmp	.+18     	; 0x3c60 <vfprintf+0x55e>
    3c4e:	84 e0       	ldi	r24, 0x04	; 4
    3c50:	a8 0e       	add	r10, r24
    3c52:	b1 1c       	adc	r11, r1
    3c54:	f6 01       	movw	r30, r12
    3c56:	60 81       	ld	r22, Z
    3c58:	71 81       	ldd	r23, Z+1	; 0x01
    3c5a:	82 81       	ldd	r24, Z+2	; 0x02
    3c5c:	93 81       	ldd	r25, Z+3	; 0x03
    3c5e:	08 c0       	rjmp	.+16     	; 0x3c70 <vfprintf+0x56e>
    3c60:	f2 e0       	ldi	r31, 0x02	; 2
    3c62:	af 0e       	add	r10, r31
    3c64:	b1 1c       	adc	r11, r1
    3c66:	f6 01       	movw	r30, r12
    3c68:	60 81       	ld	r22, Z
    3c6a:	71 81       	ldd	r23, Z+1	; 0x01
    3c6c:	80 e0       	ldi	r24, 0x00	; 0
    3c6e:	90 e0       	ldi	r25, 0x00	; 0
    3c70:	a3 01       	movw	r20, r6
    3c72:	03 d2       	rcall	.+1030   	; 0x407a <__ultoa_invert>
    3c74:	c8 2e       	mov	r12, r24
    3c76:	c6 18       	sub	r12, r6
    3c78:	0f 77       	andi	r16, 0x7F	; 127
    3c7a:	90 2e       	mov	r9, r16
    3c7c:	96 fe       	sbrs	r9, 6
    3c7e:	0b c0       	rjmp	.+22     	; 0x3c96 <vfprintf+0x594>
    3c80:	09 2d       	mov	r16, r9
    3c82:	0e 7f       	andi	r16, 0xFE	; 254
    3c84:	c1 16       	cp	r12, r17
    3c86:	50 f4       	brcc	.+20     	; 0x3c9c <vfprintf+0x59a>
    3c88:	94 fe       	sbrs	r9, 4
    3c8a:	0a c0       	rjmp	.+20     	; 0x3ca0 <vfprintf+0x59e>
    3c8c:	92 fc       	sbrc	r9, 2
    3c8e:	08 c0       	rjmp	.+16     	; 0x3ca0 <vfprintf+0x59e>
    3c90:	09 2d       	mov	r16, r9
    3c92:	0e 7e       	andi	r16, 0xEE	; 238
    3c94:	05 c0       	rjmp	.+10     	; 0x3ca0 <vfprintf+0x59e>
    3c96:	dc 2c       	mov	r13, r12
    3c98:	09 2d       	mov	r16, r9
    3c9a:	03 c0       	rjmp	.+6      	; 0x3ca2 <vfprintf+0x5a0>
    3c9c:	dc 2c       	mov	r13, r12
    3c9e:	01 c0       	rjmp	.+2      	; 0x3ca2 <vfprintf+0x5a0>
    3ca0:	d1 2e       	mov	r13, r17
    3ca2:	04 ff       	sbrs	r16, 4
    3ca4:	0d c0       	rjmp	.+26     	; 0x3cc0 <vfprintf+0x5be>
    3ca6:	fe 01       	movw	r30, r28
    3ca8:	ec 0d       	add	r30, r12
    3caa:	f1 1d       	adc	r31, r1
    3cac:	80 81       	ld	r24, Z
    3cae:	80 33       	cpi	r24, 0x30	; 48
    3cb0:	11 f4       	brne	.+4      	; 0x3cb6 <vfprintf+0x5b4>
    3cb2:	09 7e       	andi	r16, 0xE9	; 233
    3cb4:	09 c0       	rjmp	.+18     	; 0x3cc8 <vfprintf+0x5c6>
    3cb6:	02 ff       	sbrs	r16, 2
    3cb8:	06 c0       	rjmp	.+12     	; 0x3cc6 <vfprintf+0x5c4>
    3cba:	d3 94       	inc	r13
    3cbc:	d3 94       	inc	r13
    3cbe:	04 c0       	rjmp	.+8      	; 0x3cc8 <vfprintf+0x5c6>
    3cc0:	80 2f       	mov	r24, r16
    3cc2:	86 78       	andi	r24, 0x86	; 134
    3cc4:	09 f0       	breq	.+2      	; 0x3cc8 <vfprintf+0x5c6>
    3cc6:	d3 94       	inc	r13
    3cc8:	03 fd       	sbrc	r16, 3
    3cca:	10 c0       	rjmp	.+32     	; 0x3cec <vfprintf+0x5ea>
    3ccc:	00 ff       	sbrs	r16, 0
    3cce:	06 c0       	rjmp	.+12     	; 0x3cdc <vfprintf+0x5da>
    3cd0:	1c 2d       	mov	r17, r12
    3cd2:	d5 14       	cp	r13, r5
    3cd4:	78 f4       	brcc	.+30     	; 0x3cf4 <vfprintf+0x5f2>
    3cd6:	15 0d       	add	r17, r5
    3cd8:	1d 19       	sub	r17, r13
    3cda:	0c c0       	rjmp	.+24     	; 0x3cf4 <vfprintf+0x5f2>
    3cdc:	d5 14       	cp	r13, r5
    3cde:	50 f4       	brcc	.+20     	; 0x3cf4 <vfprintf+0x5f2>
    3ce0:	b7 01       	movw	r22, r14
    3ce2:	80 e2       	ldi	r24, 0x20	; 32
    3ce4:	90 e0       	ldi	r25, 0x00	; 0
    3ce6:	8d d1       	rcall	.+794    	; 0x4002 <fputc>
    3ce8:	d3 94       	inc	r13
    3cea:	f8 cf       	rjmp	.-16     	; 0x3cdc <vfprintf+0x5da>
    3cec:	d5 14       	cp	r13, r5
    3cee:	10 f4       	brcc	.+4      	; 0x3cf4 <vfprintf+0x5f2>
    3cf0:	5d 18       	sub	r5, r13
    3cf2:	01 c0       	rjmp	.+2      	; 0x3cf6 <vfprintf+0x5f4>
    3cf4:	51 2c       	mov	r5, r1
    3cf6:	04 ff       	sbrs	r16, 4
    3cf8:	0f c0       	rjmp	.+30     	; 0x3d18 <vfprintf+0x616>
    3cfa:	b7 01       	movw	r22, r14
    3cfc:	80 e3       	ldi	r24, 0x30	; 48
    3cfe:	90 e0       	ldi	r25, 0x00	; 0
    3d00:	80 d1       	rcall	.+768    	; 0x4002 <fputc>
    3d02:	02 ff       	sbrs	r16, 2
    3d04:	16 c0       	rjmp	.+44     	; 0x3d32 <vfprintf+0x630>
    3d06:	01 fd       	sbrc	r16, 1
    3d08:	03 c0       	rjmp	.+6      	; 0x3d10 <vfprintf+0x60e>
    3d0a:	88 e7       	ldi	r24, 0x78	; 120
    3d0c:	90 e0       	ldi	r25, 0x00	; 0
    3d0e:	02 c0       	rjmp	.+4      	; 0x3d14 <vfprintf+0x612>
    3d10:	88 e5       	ldi	r24, 0x58	; 88
    3d12:	90 e0       	ldi	r25, 0x00	; 0
    3d14:	b7 01       	movw	r22, r14
    3d16:	0c c0       	rjmp	.+24     	; 0x3d30 <vfprintf+0x62e>
    3d18:	80 2f       	mov	r24, r16
    3d1a:	86 78       	andi	r24, 0x86	; 134
    3d1c:	51 f0       	breq	.+20     	; 0x3d32 <vfprintf+0x630>
    3d1e:	01 ff       	sbrs	r16, 1
    3d20:	02 c0       	rjmp	.+4      	; 0x3d26 <vfprintf+0x624>
    3d22:	8b e2       	ldi	r24, 0x2B	; 43
    3d24:	01 c0       	rjmp	.+2      	; 0x3d28 <vfprintf+0x626>
    3d26:	80 e2       	ldi	r24, 0x20	; 32
    3d28:	07 fd       	sbrc	r16, 7
    3d2a:	8d e2       	ldi	r24, 0x2D	; 45
    3d2c:	b7 01       	movw	r22, r14
    3d2e:	90 e0       	ldi	r25, 0x00	; 0
    3d30:	68 d1       	rcall	.+720    	; 0x4002 <fputc>
    3d32:	c1 16       	cp	r12, r17
    3d34:	30 f4       	brcc	.+12     	; 0x3d42 <vfprintf+0x640>
    3d36:	b7 01       	movw	r22, r14
    3d38:	80 e3       	ldi	r24, 0x30	; 48
    3d3a:	90 e0       	ldi	r25, 0x00	; 0
    3d3c:	62 d1       	rcall	.+708    	; 0x4002 <fputc>
    3d3e:	11 50       	subi	r17, 0x01	; 1
    3d40:	f8 cf       	rjmp	.-16     	; 0x3d32 <vfprintf+0x630>
    3d42:	ca 94       	dec	r12
    3d44:	f3 01       	movw	r30, r6
    3d46:	ec 0d       	add	r30, r12
    3d48:	f1 1d       	adc	r31, r1
    3d4a:	80 81       	ld	r24, Z
    3d4c:	b7 01       	movw	r22, r14
    3d4e:	90 e0       	ldi	r25, 0x00	; 0
    3d50:	58 d1       	rcall	.+688    	; 0x4002 <fputc>
    3d52:	c1 10       	cpse	r12, r1
    3d54:	f6 cf       	rjmp	.-20     	; 0x3d42 <vfprintf+0x640>
    3d56:	15 c0       	rjmp	.+42     	; 0x3d82 <vfprintf+0x680>
    3d58:	f4 e0       	ldi	r31, 0x04	; 4
    3d5a:	f5 15       	cp	r31, r5
    3d5c:	50 f5       	brcc	.+84     	; 0x3db2 <vfprintf+0x6b0>
    3d5e:	84 e0       	ldi	r24, 0x04	; 4
    3d60:	58 1a       	sub	r5, r24
    3d62:	93 fe       	sbrs	r9, 3
    3d64:	1e c0       	rjmp	.+60     	; 0x3da2 <vfprintf+0x6a0>
    3d66:	01 11       	cpse	r16, r1
    3d68:	25 c0       	rjmp	.+74     	; 0x3db4 <vfprintf+0x6b2>
    3d6a:	2c 85       	ldd	r18, Y+12	; 0x0c
    3d6c:	23 ff       	sbrs	r18, 3
    3d6e:	27 c0       	rjmp	.+78     	; 0x3dbe <vfprintf+0x6bc>
    3d70:	04 ee       	ldi	r16, 0xE4	; 228
    3d72:	10 e0       	ldi	r17, 0x00	; 0
    3d74:	39 2d       	mov	r19, r9
    3d76:	30 71       	andi	r19, 0x10	; 16
    3d78:	93 2e       	mov	r9, r19
    3d7a:	f8 01       	movw	r30, r16
    3d7c:	84 91       	lpm	r24, Z
    3d7e:	81 11       	cpse	r24, r1
    3d80:	21 c0       	rjmp	.+66     	; 0x3dc4 <vfprintf+0x6c2>
    3d82:	55 20       	and	r5, r5
    3d84:	09 f4       	brne	.+2      	; 0x3d88 <vfprintf+0x686>
    3d86:	fc cc       	rjmp	.-1544   	; 0x3780 <vfprintf+0x7e>
    3d88:	b7 01       	movw	r22, r14
    3d8a:	80 e2       	ldi	r24, 0x20	; 32
    3d8c:	90 e0       	ldi	r25, 0x00	; 0
    3d8e:	39 d1       	rcall	.+626    	; 0x4002 <fputc>
    3d90:	5a 94       	dec	r5
    3d92:	f7 cf       	rjmp	.-18     	; 0x3d82 <vfprintf+0x680>
    3d94:	f7 01       	movw	r30, r14
    3d96:	86 81       	ldd	r24, Z+6	; 0x06
    3d98:	97 81       	ldd	r25, Z+7	; 0x07
    3d9a:	23 c0       	rjmp	.+70     	; 0x3de2 <vfprintf+0x6e0>
    3d9c:	8f ef       	ldi	r24, 0xFF	; 255
    3d9e:	9f ef       	ldi	r25, 0xFF	; 255
    3da0:	20 c0       	rjmp	.+64     	; 0x3de2 <vfprintf+0x6e0>
    3da2:	b7 01       	movw	r22, r14
    3da4:	80 e2       	ldi	r24, 0x20	; 32
    3da6:	90 e0       	ldi	r25, 0x00	; 0
    3da8:	2c d1       	rcall	.+600    	; 0x4002 <fputc>
    3daa:	5a 94       	dec	r5
    3dac:	51 10       	cpse	r5, r1
    3dae:	f9 cf       	rjmp	.-14     	; 0x3da2 <vfprintf+0x6a0>
    3db0:	da cf       	rjmp	.-76     	; 0x3d66 <vfprintf+0x664>
    3db2:	51 2c       	mov	r5, r1
    3db4:	b7 01       	movw	r22, r14
    3db6:	80 2f       	mov	r24, r16
    3db8:	90 e0       	ldi	r25, 0x00	; 0
    3dba:	23 d1       	rcall	.+582    	; 0x4002 <fputc>
    3dbc:	d6 cf       	rjmp	.-84     	; 0x3d6a <vfprintf+0x668>
    3dbe:	08 ee       	ldi	r16, 0xE8	; 232
    3dc0:	10 e0       	ldi	r17, 0x00	; 0
    3dc2:	d8 cf       	rjmp	.-80     	; 0x3d74 <vfprintf+0x672>
    3dc4:	91 10       	cpse	r9, r1
    3dc6:	80 52       	subi	r24, 0x20	; 32
    3dc8:	b7 01       	movw	r22, r14
    3dca:	90 e0       	ldi	r25, 0x00	; 0
    3dcc:	1a d1       	rcall	.+564    	; 0x4002 <fputc>
    3dce:	0f 5f       	subi	r16, 0xFF	; 255
    3dd0:	1f 4f       	sbci	r17, 0xFF	; 255
    3dd2:	d3 cf       	rjmp	.-90     	; 0x3d7a <vfprintf+0x678>
    3dd4:	23 e0       	ldi	r18, 0x03	; 3
    3dd6:	25 15       	cp	r18, r5
    3dd8:	10 f4       	brcc	.+4      	; 0x3dde <vfprintf+0x6dc>
    3dda:	83 e0       	ldi	r24, 0x03	; 3
    3ddc:	c1 cf       	rjmp	.-126    	; 0x3d60 <vfprintf+0x65e>
    3dde:	51 2c       	mov	r5, r1
    3de0:	c4 cf       	rjmp	.-120    	; 0x3d6a <vfprintf+0x668>
    3de2:	60 96       	adiw	r28, 0x10	; 16
    3de4:	0f b6       	in	r0, 0x3f	; 63
    3de6:	f8 94       	cli
    3de8:	de bf       	out	0x3e, r29	; 62
    3dea:	0f be       	out	0x3f, r0	; 63
    3dec:	cd bf       	out	0x3d, r28	; 61
    3dee:	df 91       	pop	r29
    3df0:	cf 91       	pop	r28
    3df2:	1f 91       	pop	r17
    3df4:	0f 91       	pop	r16
    3df6:	ff 90       	pop	r15
    3df8:	ef 90       	pop	r14
    3dfa:	df 90       	pop	r13
    3dfc:	cf 90       	pop	r12
    3dfe:	bf 90       	pop	r11
    3e00:	af 90       	pop	r10
    3e02:	9f 90       	pop	r9
    3e04:	8f 90       	pop	r8
    3e06:	7f 90       	pop	r7
    3e08:	6f 90       	pop	r6
    3e0a:	5f 90       	pop	r5
    3e0c:	4f 90       	pop	r4
    3e0e:	3f 90       	pop	r3
    3e10:	2f 90       	pop	r2
    3e12:	08 95       	ret

00003e14 <__ftoa_engine>:
    3e14:	28 30       	cpi	r18, 0x08	; 8
    3e16:	08 f0       	brcs	.+2      	; 0x3e1a <__ftoa_engine+0x6>
    3e18:	27 e0       	ldi	r18, 0x07	; 7
    3e1a:	33 27       	eor	r19, r19
    3e1c:	da 01       	movw	r26, r20
    3e1e:	99 0f       	add	r25, r25
    3e20:	31 1d       	adc	r19, r1
    3e22:	87 fd       	sbrc	r24, 7
    3e24:	91 60       	ori	r25, 0x01	; 1
    3e26:	00 96       	adiw	r24, 0x00	; 0
    3e28:	61 05       	cpc	r22, r1
    3e2a:	71 05       	cpc	r23, r1
    3e2c:	39 f4       	brne	.+14     	; 0x3e3c <__ftoa_engine+0x28>
    3e2e:	32 60       	ori	r19, 0x02	; 2
    3e30:	2e 5f       	subi	r18, 0xFE	; 254
    3e32:	3d 93       	st	X+, r19
    3e34:	30 e3       	ldi	r19, 0x30	; 48
    3e36:	2a 95       	dec	r18
    3e38:	e1 f7       	brne	.-8      	; 0x3e32 <__ftoa_engine+0x1e>
    3e3a:	08 95       	ret
    3e3c:	9f 3f       	cpi	r25, 0xFF	; 255
    3e3e:	30 f0       	brcs	.+12     	; 0x3e4c <__ftoa_engine+0x38>
    3e40:	80 38       	cpi	r24, 0x80	; 128
    3e42:	71 05       	cpc	r23, r1
    3e44:	61 05       	cpc	r22, r1
    3e46:	09 f0       	breq	.+2      	; 0x3e4a <__ftoa_engine+0x36>
    3e48:	3c 5f       	subi	r19, 0xFC	; 252
    3e4a:	3c 5f       	subi	r19, 0xFC	; 252
    3e4c:	3d 93       	st	X+, r19
    3e4e:	91 30       	cpi	r25, 0x01	; 1
    3e50:	08 f0       	brcs	.+2      	; 0x3e54 <__ftoa_engine+0x40>
    3e52:	80 68       	ori	r24, 0x80	; 128
    3e54:	91 1d       	adc	r25, r1
    3e56:	df 93       	push	r29
    3e58:	cf 93       	push	r28
    3e5a:	1f 93       	push	r17
    3e5c:	0f 93       	push	r16
    3e5e:	ff 92       	push	r15
    3e60:	ef 92       	push	r14
    3e62:	19 2f       	mov	r17, r25
    3e64:	98 7f       	andi	r25, 0xF8	; 248
    3e66:	96 95       	lsr	r25
    3e68:	e9 2f       	mov	r30, r25
    3e6a:	96 95       	lsr	r25
    3e6c:	96 95       	lsr	r25
    3e6e:	e9 0f       	add	r30, r25
    3e70:	ff 27       	eor	r31, r31
    3e72:	ea 5b       	subi	r30, 0xBA	; 186
    3e74:	fe 4f       	sbci	r31, 0xFE	; 254
    3e76:	99 27       	eor	r25, r25
    3e78:	33 27       	eor	r19, r19
    3e7a:	ee 24       	eor	r14, r14
    3e7c:	ff 24       	eor	r15, r15
    3e7e:	a7 01       	movw	r20, r14
    3e80:	e7 01       	movw	r28, r14
    3e82:	05 90       	lpm	r0, Z+
    3e84:	08 94       	sec
    3e86:	07 94       	ror	r0
    3e88:	28 f4       	brcc	.+10     	; 0x3e94 <__ftoa_engine+0x80>
    3e8a:	36 0f       	add	r19, r22
    3e8c:	e7 1e       	adc	r14, r23
    3e8e:	f8 1e       	adc	r15, r24
    3e90:	49 1f       	adc	r20, r25
    3e92:	51 1d       	adc	r21, r1
    3e94:	66 0f       	add	r22, r22
    3e96:	77 1f       	adc	r23, r23
    3e98:	88 1f       	adc	r24, r24
    3e9a:	99 1f       	adc	r25, r25
    3e9c:	06 94       	lsr	r0
    3e9e:	a1 f7       	brne	.-24     	; 0x3e88 <__ftoa_engine+0x74>
    3ea0:	05 90       	lpm	r0, Z+
    3ea2:	07 94       	ror	r0
    3ea4:	28 f4       	brcc	.+10     	; 0x3eb0 <__ftoa_engine+0x9c>
    3ea6:	e7 0e       	add	r14, r23
    3ea8:	f8 1e       	adc	r15, r24
    3eaa:	49 1f       	adc	r20, r25
    3eac:	56 1f       	adc	r21, r22
    3eae:	c1 1d       	adc	r28, r1
    3eb0:	77 0f       	add	r23, r23
    3eb2:	88 1f       	adc	r24, r24
    3eb4:	99 1f       	adc	r25, r25
    3eb6:	66 1f       	adc	r22, r22
    3eb8:	06 94       	lsr	r0
    3eba:	a1 f7       	brne	.-24     	; 0x3ea4 <__ftoa_engine+0x90>
    3ebc:	05 90       	lpm	r0, Z+
    3ebe:	07 94       	ror	r0
    3ec0:	28 f4       	brcc	.+10     	; 0x3ecc <__ftoa_engine+0xb8>
    3ec2:	f8 0e       	add	r15, r24
    3ec4:	49 1f       	adc	r20, r25
    3ec6:	56 1f       	adc	r21, r22
    3ec8:	c7 1f       	adc	r28, r23
    3eca:	d1 1d       	adc	r29, r1
    3ecc:	88 0f       	add	r24, r24
    3ece:	99 1f       	adc	r25, r25
    3ed0:	66 1f       	adc	r22, r22
    3ed2:	77 1f       	adc	r23, r23
    3ed4:	06 94       	lsr	r0
    3ed6:	a1 f7       	brne	.-24     	; 0x3ec0 <__ftoa_engine+0xac>
    3ed8:	05 90       	lpm	r0, Z+
    3eda:	07 94       	ror	r0
    3edc:	20 f4       	brcc	.+8      	; 0x3ee6 <__ftoa_engine+0xd2>
    3ede:	49 0f       	add	r20, r25
    3ee0:	56 1f       	adc	r21, r22
    3ee2:	c7 1f       	adc	r28, r23
    3ee4:	d8 1f       	adc	r29, r24
    3ee6:	99 0f       	add	r25, r25
    3ee8:	66 1f       	adc	r22, r22
    3eea:	77 1f       	adc	r23, r23
    3eec:	88 1f       	adc	r24, r24
    3eee:	06 94       	lsr	r0
    3ef0:	a9 f7       	brne	.-22     	; 0x3edc <__ftoa_engine+0xc8>
    3ef2:	84 91       	lpm	r24, Z
    3ef4:	10 95       	com	r17
    3ef6:	17 70       	andi	r17, 0x07	; 7
    3ef8:	41 f0       	breq	.+16     	; 0x3f0a <__ftoa_engine+0xf6>
    3efa:	d6 95       	lsr	r29
    3efc:	c7 95       	ror	r28
    3efe:	57 95       	ror	r21
    3f00:	47 95       	ror	r20
    3f02:	f7 94       	ror	r15
    3f04:	e7 94       	ror	r14
    3f06:	1a 95       	dec	r17
    3f08:	c1 f7       	brne	.-16     	; 0x3efa <__ftoa_engine+0xe6>
    3f0a:	ec ee       	ldi	r30, 0xEC	; 236
    3f0c:	f0 e0       	ldi	r31, 0x00	; 0
    3f0e:	68 94       	set
    3f10:	15 90       	lpm	r1, Z+
    3f12:	15 91       	lpm	r17, Z+
    3f14:	35 91       	lpm	r19, Z+
    3f16:	65 91       	lpm	r22, Z+
    3f18:	95 91       	lpm	r25, Z+
    3f1a:	05 90       	lpm	r0, Z+
    3f1c:	7f e2       	ldi	r23, 0x2F	; 47
    3f1e:	73 95       	inc	r23
    3f20:	e1 18       	sub	r14, r1
    3f22:	f1 0a       	sbc	r15, r17
    3f24:	43 0b       	sbc	r20, r19
    3f26:	56 0b       	sbc	r21, r22
    3f28:	c9 0b       	sbc	r28, r25
    3f2a:	d0 09       	sbc	r29, r0
    3f2c:	c0 f7       	brcc	.-16     	; 0x3f1e <__ftoa_engine+0x10a>
    3f2e:	e1 0c       	add	r14, r1
    3f30:	f1 1e       	adc	r15, r17
    3f32:	43 1f       	adc	r20, r19
    3f34:	56 1f       	adc	r21, r22
    3f36:	c9 1f       	adc	r28, r25
    3f38:	d0 1d       	adc	r29, r0
    3f3a:	7e f4       	brtc	.+30     	; 0x3f5a <__ftoa_engine+0x146>
    3f3c:	70 33       	cpi	r23, 0x30	; 48
    3f3e:	11 f4       	brne	.+4      	; 0x3f44 <__ftoa_engine+0x130>
    3f40:	8a 95       	dec	r24
    3f42:	e6 cf       	rjmp	.-52     	; 0x3f10 <__ftoa_engine+0xfc>
    3f44:	e8 94       	clt
    3f46:	01 50       	subi	r16, 0x01	; 1
    3f48:	30 f0       	brcs	.+12     	; 0x3f56 <__ftoa_engine+0x142>
    3f4a:	08 0f       	add	r16, r24
    3f4c:	0a f4       	brpl	.+2      	; 0x3f50 <__ftoa_engine+0x13c>
    3f4e:	00 27       	eor	r16, r16
    3f50:	02 17       	cp	r16, r18
    3f52:	08 f4       	brcc	.+2      	; 0x3f56 <__ftoa_engine+0x142>
    3f54:	20 2f       	mov	r18, r16
    3f56:	23 95       	inc	r18
    3f58:	02 2f       	mov	r16, r18
    3f5a:	7a 33       	cpi	r23, 0x3A	; 58
    3f5c:	28 f0       	brcs	.+10     	; 0x3f68 <__ftoa_engine+0x154>
    3f5e:	79 e3       	ldi	r23, 0x39	; 57
    3f60:	7d 93       	st	X+, r23
    3f62:	2a 95       	dec	r18
    3f64:	e9 f7       	brne	.-6      	; 0x3f60 <__ftoa_engine+0x14c>
    3f66:	10 c0       	rjmp	.+32     	; 0x3f88 <__ftoa_engine+0x174>
    3f68:	7d 93       	st	X+, r23
    3f6a:	2a 95       	dec	r18
    3f6c:	89 f6       	brne	.-94     	; 0x3f10 <__ftoa_engine+0xfc>
    3f6e:	06 94       	lsr	r0
    3f70:	97 95       	ror	r25
    3f72:	67 95       	ror	r22
    3f74:	37 95       	ror	r19
    3f76:	17 95       	ror	r17
    3f78:	17 94       	ror	r1
    3f7a:	e1 18       	sub	r14, r1
    3f7c:	f1 0a       	sbc	r15, r17
    3f7e:	43 0b       	sbc	r20, r19
    3f80:	56 0b       	sbc	r21, r22
    3f82:	c9 0b       	sbc	r28, r25
    3f84:	d0 09       	sbc	r29, r0
    3f86:	98 f0       	brcs	.+38     	; 0x3fae <__ftoa_engine+0x19a>
    3f88:	23 95       	inc	r18
    3f8a:	7e 91       	ld	r23, -X
    3f8c:	73 95       	inc	r23
    3f8e:	7a 33       	cpi	r23, 0x3A	; 58
    3f90:	08 f0       	brcs	.+2      	; 0x3f94 <__ftoa_engine+0x180>
    3f92:	70 e3       	ldi	r23, 0x30	; 48
    3f94:	7c 93       	st	X, r23
    3f96:	20 13       	cpse	r18, r16
    3f98:	b8 f7       	brcc	.-18     	; 0x3f88 <__ftoa_engine+0x174>
    3f9a:	7e 91       	ld	r23, -X
    3f9c:	70 61       	ori	r23, 0x10	; 16
    3f9e:	7d 93       	st	X+, r23
    3fa0:	30 f0       	brcs	.+12     	; 0x3fae <__ftoa_engine+0x19a>
    3fa2:	83 95       	inc	r24
    3fa4:	71 e3       	ldi	r23, 0x31	; 49
    3fa6:	7d 93       	st	X+, r23
    3fa8:	70 e3       	ldi	r23, 0x30	; 48
    3faa:	2a 95       	dec	r18
    3fac:	e1 f7       	brne	.-8      	; 0x3fa6 <__ftoa_engine+0x192>
    3fae:	11 24       	eor	r1, r1
    3fb0:	ef 90       	pop	r14
    3fb2:	ff 90       	pop	r15
    3fb4:	0f 91       	pop	r16
    3fb6:	1f 91       	pop	r17
    3fb8:	cf 91       	pop	r28
    3fba:	df 91       	pop	r29
    3fbc:	99 27       	eor	r25, r25
    3fbe:	87 fd       	sbrc	r24, 7
    3fc0:	90 95       	com	r25
    3fc2:	08 95       	ret

00003fc4 <strnlen_P>:
    3fc4:	fc 01       	movw	r30, r24
    3fc6:	05 90       	lpm	r0, Z+
    3fc8:	61 50       	subi	r22, 0x01	; 1
    3fca:	70 40       	sbci	r23, 0x00	; 0
    3fcc:	01 10       	cpse	r0, r1
    3fce:	d8 f7       	brcc	.-10     	; 0x3fc6 <strnlen_P+0x2>
    3fd0:	80 95       	com	r24
    3fd2:	90 95       	com	r25
    3fd4:	8e 0f       	add	r24, r30
    3fd6:	9f 1f       	adc	r25, r31
    3fd8:	08 95       	ret

00003fda <memcpy>:
    3fda:	fb 01       	movw	r30, r22
    3fdc:	dc 01       	movw	r26, r24
    3fde:	02 c0       	rjmp	.+4      	; 0x3fe4 <memcpy+0xa>
    3fe0:	01 90       	ld	r0, Z+
    3fe2:	0d 92       	st	X+, r0
    3fe4:	41 50       	subi	r20, 0x01	; 1
    3fe6:	50 40       	sbci	r21, 0x00	; 0
    3fe8:	d8 f7       	brcc	.-10     	; 0x3fe0 <memcpy+0x6>
    3fea:	08 95       	ret

00003fec <strnlen>:
    3fec:	fc 01       	movw	r30, r24
    3fee:	61 50       	subi	r22, 0x01	; 1
    3ff0:	70 40       	sbci	r23, 0x00	; 0
    3ff2:	01 90       	ld	r0, Z+
    3ff4:	01 10       	cpse	r0, r1
    3ff6:	d8 f7       	brcc	.-10     	; 0x3fee <strnlen+0x2>
    3ff8:	80 95       	com	r24
    3ffa:	90 95       	com	r25
    3ffc:	8e 0f       	add	r24, r30
    3ffe:	9f 1f       	adc	r25, r31
    4000:	08 95       	ret

00004002 <fputc>:
    4002:	0f 93       	push	r16
    4004:	1f 93       	push	r17
    4006:	cf 93       	push	r28
    4008:	df 93       	push	r29
    400a:	fb 01       	movw	r30, r22
    400c:	23 81       	ldd	r18, Z+3	; 0x03
    400e:	21 fd       	sbrc	r18, 1
    4010:	03 c0       	rjmp	.+6      	; 0x4018 <fputc+0x16>
    4012:	8f ef       	ldi	r24, 0xFF	; 255
    4014:	9f ef       	ldi	r25, 0xFF	; 255
    4016:	2c c0       	rjmp	.+88     	; 0x4070 <fputc+0x6e>
    4018:	22 ff       	sbrs	r18, 2
    401a:	16 c0       	rjmp	.+44     	; 0x4048 <fputc+0x46>
    401c:	46 81       	ldd	r20, Z+6	; 0x06
    401e:	57 81       	ldd	r21, Z+7	; 0x07
    4020:	24 81       	ldd	r18, Z+4	; 0x04
    4022:	35 81       	ldd	r19, Z+5	; 0x05
    4024:	42 17       	cp	r20, r18
    4026:	53 07       	cpc	r21, r19
    4028:	44 f4       	brge	.+16     	; 0x403a <fputc+0x38>
    402a:	a0 81       	ld	r26, Z
    402c:	b1 81       	ldd	r27, Z+1	; 0x01
    402e:	9d 01       	movw	r18, r26
    4030:	2f 5f       	subi	r18, 0xFF	; 255
    4032:	3f 4f       	sbci	r19, 0xFF	; 255
    4034:	31 83       	std	Z+1, r19	; 0x01
    4036:	20 83       	st	Z, r18
    4038:	8c 93       	st	X, r24
    403a:	26 81       	ldd	r18, Z+6	; 0x06
    403c:	37 81       	ldd	r19, Z+7	; 0x07
    403e:	2f 5f       	subi	r18, 0xFF	; 255
    4040:	3f 4f       	sbci	r19, 0xFF	; 255
    4042:	37 83       	std	Z+7, r19	; 0x07
    4044:	26 83       	std	Z+6, r18	; 0x06
    4046:	14 c0       	rjmp	.+40     	; 0x4070 <fputc+0x6e>
    4048:	8b 01       	movw	r16, r22
    404a:	ec 01       	movw	r28, r24
    404c:	fb 01       	movw	r30, r22
    404e:	00 84       	ldd	r0, Z+8	; 0x08
    4050:	f1 85       	ldd	r31, Z+9	; 0x09
    4052:	e0 2d       	mov	r30, r0
    4054:	19 95       	eicall
    4056:	89 2b       	or	r24, r25
    4058:	e1 f6       	brne	.-72     	; 0x4012 <fputc+0x10>
    405a:	d8 01       	movw	r26, r16
    405c:	16 96       	adiw	r26, 0x06	; 6
    405e:	8d 91       	ld	r24, X+
    4060:	9c 91       	ld	r25, X
    4062:	17 97       	sbiw	r26, 0x07	; 7
    4064:	01 96       	adiw	r24, 0x01	; 1
    4066:	17 96       	adiw	r26, 0x07	; 7
    4068:	9c 93       	st	X, r25
    406a:	8e 93       	st	-X, r24
    406c:	16 97       	sbiw	r26, 0x06	; 6
    406e:	ce 01       	movw	r24, r28
    4070:	df 91       	pop	r29
    4072:	cf 91       	pop	r28
    4074:	1f 91       	pop	r17
    4076:	0f 91       	pop	r16
    4078:	08 95       	ret

0000407a <__ultoa_invert>:
    407a:	fa 01       	movw	r30, r20
    407c:	aa 27       	eor	r26, r26
    407e:	28 30       	cpi	r18, 0x08	; 8
    4080:	51 f1       	breq	.+84     	; 0x40d6 <__ultoa_invert+0x5c>
    4082:	20 31       	cpi	r18, 0x10	; 16
    4084:	81 f1       	breq	.+96     	; 0x40e6 <__ultoa_invert+0x6c>
    4086:	e8 94       	clt
    4088:	6f 93       	push	r22
    408a:	6e 7f       	andi	r22, 0xFE	; 254
    408c:	6e 5f       	subi	r22, 0xFE	; 254
    408e:	7f 4f       	sbci	r23, 0xFF	; 255
    4090:	8f 4f       	sbci	r24, 0xFF	; 255
    4092:	9f 4f       	sbci	r25, 0xFF	; 255
    4094:	af 4f       	sbci	r26, 0xFF	; 255
    4096:	b1 e0       	ldi	r27, 0x01	; 1
    4098:	3e d0       	rcall	.+124    	; 0x4116 <__ultoa_invert+0x9c>
    409a:	b4 e0       	ldi	r27, 0x04	; 4
    409c:	3c d0       	rcall	.+120    	; 0x4116 <__ultoa_invert+0x9c>
    409e:	67 0f       	add	r22, r23
    40a0:	78 1f       	adc	r23, r24
    40a2:	89 1f       	adc	r24, r25
    40a4:	9a 1f       	adc	r25, r26
    40a6:	a1 1d       	adc	r26, r1
    40a8:	68 0f       	add	r22, r24
    40aa:	79 1f       	adc	r23, r25
    40ac:	8a 1f       	adc	r24, r26
    40ae:	91 1d       	adc	r25, r1
    40b0:	a1 1d       	adc	r26, r1
    40b2:	6a 0f       	add	r22, r26
    40b4:	71 1d       	adc	r23, r1
    40b6:	81 1d       	adc	r24, r1
    40b8:	91 1d       	adc	r25, r1
    40ba:	a1 1d       	adc	r26, r1
    40bc:	20 d0       	rcall	.+64     	; 0x40fe <__ultoa_invert+0x84>
    40be:	09 f4       	brne	.+2      	; 0x40c2 <__ultoa_invert+0x48>
    40c0:	68 94       	set
    40c2:	3f 91       	pop	r19
    40c4:	2a e0       	ldi	r18, 0x0A	; 10
    40c6:	26 9f       	mul	r18, r22
    40c8:	11 24       	eor	r1, r1
    40ca:	30 19       	sub	r19, r0
    40cc:	30 5d       	subi	r19, 0xD0	; 208
    40ce:	31 93       	st	Z+, r19
    40d0:	de f6       	brtc	.-74     	; 0x4088 <__ultoa_invert+0xe>
    40d2:	cf 01       	movw	r24, r30
    40d4:	08 95       	ret
    40d6:	46 2f       	mov	r20, r22
    40d8:	47 70       	andi	r20, 0x07	; 7
    40da:	40 5d       	subi	r20, 0xD0	; 208
    40dc:	41 93       	st	Z+, r20
    40de:	b3 e0       	ldi	r27, 0x03	; 3
    40e0:	0f d0       	rcall	.+30     	; 0x4100 <__ultoa_invert+0x86>
    40e2:	c9 f7       	brne	.-14     	; 0x40d6 <__ultoa_invert+0x5c>
    40e4:	f6 cf       	rjmp	.-20     	; 0x40d2 <__ultoa_invert+0x58>
    40e6:	46 2f       	mov	r20, r22
    40e8:	4f 70       	andi	r20, 0x0F	; 15
    40ea:	40 5d       	subi	r20, 0xD0	; 208
    40ec:	4a 33       	cpi	r20, 0x3A	; 58
    40ee:	18 f0       	brcs	.+6      	; 0x40f6 <__ultoa_invert+0x7c>
    40f0:	49 5d       	subi	r20, 0xD9	; 217
    40f2:	31 fd       	sbrc	r19, 1
    40f4:	40 52       	subi	r20, 0x20	; 32
    40f6:	41 93       	st	Z+, r20
    40f8:	02 d0       	rcall	.+4      	; 0x40fe <__ultoa_invert+0x84>
    40fa:	a9 f7       	brne	.-22     	; 0x40e6 <__ultoa_invert+0x6c>
    40fc:	ea cf       	rjmp	.-44     	; 0x40d2 <__ultoa_invert+0x58>
    40fe:	b4 e0       	ldi	r27, 0x04	; 4
    4100:	a6 95       	lsr	r26
    4102:	97 95       	ror	r25
    4104:	87 95       	ror	r24
    4106:	77 95       	ror	r23
    4108:	67 95       	ror	r22
    410a:	ba 95       	dec	r27
    410c:	c9 f7       	brne	.-14     	; 0x4100 <__ultoa_invert+0x86>
    410e:	00 97       	sbiw	r24, 0x00	; 0
    4110:	61 05       	cpc	r22, r1
    4112:	71 05       	cpc	r23, r1
    4114:	08 95       	ret
    4116:	9b 01       	movw	r18, r22
    4118:	ac 01       	movw	r20, r24
    411a:	0a 2e       	mov	r0, r26
    411c:	06 94       	lsr	r0
    411e:	57 95       	ror	r21
    4120:	47 95       	ror	r20
    4122:	37 95       	ror	r19
    4124:	27 95       	ror	r18
    4126:	ba 95       	dec	r27
    4128:	c9 f7       	brne	.-14     	; 0x411c <__ultoa_invert+0xa2>
    412a:	62 0f       	add	r22, r18
    412c:	73 1f       	adc	r23, r19
    412e:	84 1f       	adc	r24, r20
    4130:	95 1f       	adc	r25, r21
    4132:	a0 1d       	adc	r26, r0
    4134:	08 95       	ret

00004136 <_exit>:
    4136:	f8 94       	cli

00004138 <__stop_program>:
    4138:	ff cf       	rjmp	.-2      	; 0x4138 <__stop_program>
